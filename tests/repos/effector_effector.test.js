const { extractFromSource } = require('../../src/extractor');

describe('effector_effector', () => {
    it('effector_effector\\src\\babel\\__tests__\\babel-plugin.test.js', () => {
        const sourceCode = `
			import fs from 'fs'
			import path from 'path'
			import \{transformFileSync\} from '@babel/core'
			import \{format\} from 'prettier'
			
			describe('babel-plugin', () => \{
			  const fixturesDir = path.join(__dirname, 'fixtures')
			  const testCases = fs
			    .readdirSync(fixturesDir)
			    .filter(file => file.endsWith('.js'))
			    .sort()
			  for (const caseFile of testCases) \{
			    const isMultiPass = caseFile.includes('multiPass')
			    const caseName = caseFile.split('-').join(' ').slice(0, -3)
			
			    const optionsName = \`\$\{caseFile.slice(0, -3)\}.options.json\`
			    const optionsPath = path.join(fixturesDir, optionsName)
			    const hasOptions = fs.existsSync(optionsPath)
			
			    if (isMultiPass) \{
			      it('support multiple passes of babel plugin', () => \{
			        const options = \{filename: true, addLoc: true\}
			        const fixturePath = path.join(fixturesDir, caseFile)
			        const fixture = transformFileSync(fixturePath, \{
			          configFile: false,
			          babelrc: false,
			          envName: 'test',
			          plugins: [
			            [path.resolve(__dirname, '../babel-plugin.js'), options],
			            [
			              path.resolve(__dirname, '../babel-plugin.js'),
			              options,
			              'effector-logger',
			            ],
			          ],
			        \})?.code
			
			        expect(formatCode(fixture)).toMatchSnapshot()
			      \})
			    \} else if (hasOptions) \{
			      const options = JSON.parse(
			        fs.readFileSync(optionsPath, \{encoding: 'utf8'\}).toString(),
			      )
			
			      it(\`should \$\{caseName\} with options\`, () => \{
			        const fixturePath = path.join(fixturesDir, caseFile)
			        const fixture = transformFileSync(fixturePath, \{
			          configFile: false,
			          babelrc: false,
			          envName: 'test',
			          plugins: [[path.resolve(__dirname, '../babel-plugin.js'), options]],
			        \})?.code
			
			        expect(formatCode(fixture)).toMatchSnapshot()
			      \})
			    \} else \{
			      it(\`should \$\{caseName\}\`, () => \{
			        const fixturePath = path.join(fixturesDir, caseFile)
			        const fixture = transformFileSync(fixturePath, \{
			          configFile: path.join(__dirname, '.babelrc'),
			        \})?.code
			
			        expect(formatCode(fixture)).toMatchSnapshot()
			      \})
			    \}
			  \}
			\})
			
			function formatCode(code) \{
			  return format(code, \{
			    semi: false,
			    printWidth: 80,
			    tabWidth: 2,
			    singleQuote: true,
			    trailingComma: 'all',
			    bracketSpacing: false,
			    jsxBracketSameLine: true,
			    arrowParens: 'avoid',
			    parser: 'babel',
			  \})
			\}
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\babel\\__tests__\\babel-plugin.test.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\babel\\__tests__\\raw-config.test.js', () => {
        const sourceCode = `
			import \{combine, createDomain, createStore\} from 'effector'
			
			const readFullName = unit => unit.compositeName?.fullName
			
			describe('raw config', () => \{
			  const domain = createDomain('')
			
			  it('should set name', () => \{
			    const foo = createStore(0)
			    expect(readFullName(foo)).toBe('foo')
			    const bar = domain.store(0)
			    expect(readFullName(bar)).toBe('bar')
			    const e = \{combine\}.combine(foo, bar, (a, b) => (\{a, b\}))
			    expect(readFullName(e)).toBe('combine(foo, bar)')
			  \})
			
			  it('should prefer original name', () => \{
			    const foo = createStore(0, \{name: 'bar'\})
			    expect(readFullName(foo)).toBe('bar')
			    const bar = domain.store(0, \{name: 'foo'\})
			    expect(readFullName(bar)).toBe('foo')
			  \})
			
			  it('should ignore wrong config', () => \{
			    const a = createStore('h', \{\})
			
			    const b = createStore('h', 23020)
			    const config = \{option: 0\}
			    const c = createStore(null, config)
			    expect(readFullName(a)).toBe('a')
			    expect(readFullName(b)).toBe('b')
			    expect(readFullName(c)).toBe('c')
			
			    const d = domain.store('h', \{\})
			
			    const e = domain.store('h', 23020)
			    const f = domain.store(null, config)
			
			    const g = domain.store('h', 'meme')
			
			    const h = domain.store('h', null)
			
			    const j = domain.store('h', true)
			
			    const k = domain.store('h', false)
			    expect(readFullName(d)).toBe('d')
			    expect(readFullName(e)).toBe('e')
			    expect(readFullName(f)).toBe('f')
			  \})
			
			  it('should support onCreateStore', () => \{
			    const domain = createDomain('')
			    domain.onCreateStore(store => \{
			      expect(readFullName(store)).toBe('foo')
			    \})
			    const foo = domain.store(0)
			  \})
			\})
			
			describe('raw config alias', () => \{
			  const domain = createDomain('')
			
			  it('should set name', () => \{
			    const foo = createStore(0)
			    expect(readFullName(foo)).toBe('foo')
			    const bar = domain.createStore(0)
			    expect(readFullName(bar)).toBe('bar')
			    const e = \{combine\}.combine(foo, bar, (a, b) => (\{a, b\}))
			    expect(readFullName(e)).toBe('combine(foo, bar)')
			  \})
			
			  it('should prefer original name', () => \{
			    const foo = createStore(0, \{name: 'bar'\})
			    expect(readFullName(foo)).toBe('bar')
			    const bar = domain.createStore(0, \{name: 'foo'\})
			    expect(readFullName(bar)).toBe('foo')
			  \})
			
			  it('should ignore wrong config', () => \{
			    const a = createStore('h', \{\})
			
			    const b = createStore('h', 23020)
			    const config = \{option: 0\}
			    const c = createStore(null, config)
			    expect(readFullName(a)).toBe('a')
			    expect(readFullName(b)).toBe('b')
			    expect(readFullName(c)).toBe('c')
			
			    const d = domain.createStore('h', \{\})
			
			    const e = domain.createStore('h', 23020)
			    const f = domain.createStore(null, config)
			
			    const g = domain.createStore('h', 'meme')
			
			    const h = domain.createStore('h', null)
			
			    const j = domain.createStore('h', true)
			
			    const k = domain.createStore('h', false)
			    expect(readFullName(d)).toBe('d')
			    expect(readFullName(e)).toBe('e')
			    expect(readFullName(f)).toBe('f')
			  \})
			
			  it('should support onCreateStore', () => \{
			    const domain = createDomain('')
			    domain.onCreateStore(store => \{
			      expect(readFullName(store)).toBe('foo')
			    \})
			    const foo = domain.createStore(0)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\babel\\__tests__\\raw-config.test.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('effector_effector\\src\\compat\\browser.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{
			  createStore,
			  createEffect,
			  createEvent,
			  restore,
			  combine,
			  sample,
			  split,
			  guard,
			\} from 'effector'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			test('compat test', async () => \{
			  const updates = await execFunc(async () => \{
			    const updates = [] as any[]
			    const store = createStore(\{
			      message: 'hello',
			      isError: false,
			    \})
			
			    store.watch(e => \{
			      updates.push(e)
			    \})
			
			    //@ts-ignore
			    store.setState(\{
			      message: 'upd',
			      isError: false,
			    \})
			
			    return updates
			  \})
			
			  expect(updates).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "isError": false,
			        "message": "hello",
			      \},
			      Object \{
			        "isError": false,
			        "message": "upd",
			      \},
			    ]
			  \`)
			\})
			
			test('effect support', async () => \{
			  const updates = await execFunc(async () => \{
			    const updates = [] as any[]
			    const fx = createEffect(async (x: number) => \{
			      await Promise.resolve()
			      return x.toString()
			    \})
			    const store = createStore('hello').on(fx.doneData, (_, res) => res)
			
			    store.watch(e => \{
			      updates.push(e)
			    \})
			
			    await fx(1)
			    await fx(2)
			
			    return updates
			  \})
			  expect(updates).toMatchInlineSnapshot(\`
			    Array [
			      "hello",
			      "1",
			      "2",
			    ]
			  \`)
			\})
			
			test('split support', async () => \{
			  const updates = await execFunc(async () => \{
			    try \{
			      const intervalStore = createStore(Date.now())
			      const filter = createStore(true)
			      const enumType = 3
			      const typeStore = createStore<any>(enumType)
			      const source = guard(\{source: intervalStore, filter\})
			      const caseA = createEvent<any>()
			      const caseB = createEvent<any>()
			      split(\{source, match: typeStore, cases: \{[enumType]: caseA, __: caseB\}\})
			    \} catch (err) \{
			      return String(err.message)
			    \}
			    return 'ok'
			  \})
			
			  expect(updates).toBe('ok')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\compat\\browser.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\effector\\__tests__\\attach.test.ts', () => {
        const sourceCode = `
			import \{
			  attach,
			  createDomain,
			  createEffect,
			  createEvent,
			  createStore,
			  forward,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			it('map params and results by provided functions', async () => \{
			  const fn = jest.fn()
			  const requestFX = createEffect(\{
			    handler(x: number) \{
			      fn(\{tag: 'effect handler', data: x\})
			      return \{x\}
			    \},
			  \})
			  const attached = attach(\{
			    effect: requestFX,
			    mapParams: (word: string) => word.length,
			  \})
			  requestFX.watch(data => \{
			    fn(\{tag: 'request.watch', data\})
			  \})
			  requestFX.finally.watch(data => \{
			    fn(\{tag: 'request.finally.watch', data\})
			  \})
			  attached.watch(data => \{
			    fn(\{tag: 'attached.watch', data\})
			  \})
			  attached.finally.watch(data => \{
			    fn(\{tag: 'attached.finally.watch', data\})
			  \})
			  await attached('foo').then(data => \{
			    fn(\{tag: 'promise resolver', data\})
			  \})
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "data": "foo",
			        "tag": "attached.watch",
			      \},
			      Object \{
			        "data": 3,
			        "tag": "request.watch",
			      \},
			      Object \{
			        "data": 3,
			        "tag": "effect handler",
			      \},
			      Object \{
			        "data": Object \{
			          "params": 3,
			          "result": Object \{
			            "x": 3,
			          \},
			          "status": "done",
			        \},
			        "tag": "request.finally.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "params": "foo",
			          "result": Object \{
			            "x": 3,
			          \},
			          "status": "done",
			        \},
			        "tag": "attached.finally.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "x": 3,
			        \},
			        "tag": "promise resolver",
			      \},
			    ]
			  \`)
			\})
			
			it('support source store', async () => \{
			  const fn = jest.fn()
			  const requestFX = createEffect(\{
			    handler(data: \{url: string; token: string\}) \{
			      fn(\{tag: 'effect handler', data\})
			      return 'result'
			    \},
			  \})
			  const token = createStore('foo')
			  const attached = attach(\{
			    source: token,
			    effect: requestFX,
			    mapParams: (url: string, token) => (\{url, token\}),
			  \})
			  requestFX.watch(data => \{
			    fn(\{tag: 'request.watch', data\})
			  \})
			  requestFX.finally.watch(data => \{
			    fn(\{tag: 'request.finally.watch', data\})
			  \})
			  attached.watch(data => \{
			    fn(\{tag: 'attached.watch', data\})
			  \})
			  attached.finally.watch(data => \{
			    fn(\{tag: 'attached.finally.watch', data\})
			  \})
			  await attached('/user').then(data => \{
			    fn(\{tag: 'promise resolver', data\})
			  \})
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "data": "/user",
			        "tag": "attached.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "token": "foo",
			          "url": "/user",
			        \},
			        "tag": "request.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "token": "foo",
			          "url": "/user",
			        \},
			        "tag": "effect handler",
			      \},
			      Object \{
			        "data": Object \{
			          "params": Object \{
			            "token": "foo",
			            "url": "/user",
			          \},
			          "result": "result",
			          "status": "done",
			        \},
			        "tag": "request.finally.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "params": "/user",
			          "result": "result",
			          "status": "done",
			        \},
			        "tag": "attached.finally.watch",
			      \},
			      Object \{
			        "data": "result",
			        "tag": "promise resolver",
			      \},
			    ]
			  \`)
			\})
			it('support source shape', async () => \{
			  const fn = jest.fn()
			  const requestFX = createEffect(\{
			    handler(data: \{url: string; token: string\}) \{
			      fn(\{tag: 'effect handler', data\})
			      return 'result'
			    \},
			  \})
			  const token = createStore('foo')
			  const callCounter = createStore(0).on(requestFX.finally, x => x + 1)
			  const attached = attach(\{
			    source: \{token, count: callCounter\},
			    effect: requestFX,
			    mapParams: (url: string, \{token\}) => (\{url, token\}),
			  \})
			  requestFX.watch(data => \{
			    fn(\{tag: 'request.watch', data\})
			  \})
			  requestFX.finally.watch(data => \{
			    fn(\{tag: 'request.finally.watch', data\})
			  \})
			  attached.watch(data => \{
			    fn(\{tag: 'attached.watch', data\})
			  \})
			  attached.finally.watch(data => \{
			    fn(\{tag: 'attached.finally.watch', data\})
			  \})
			  await attached('/user').then(data => \{
			    fn(\{tag: 'promise resolver', data\})
			  \})
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "data": "/user",
			        "tag": "attached.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "token": "foo",
			          "url": "/user",
			        \},
			        "tag": "request.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "token": "foo",
			          "url": "/user",
			        \},
			        "tag": "effect handler",
			      \},
			      Object \{
			        "data": Object \{
			          "params": Object \{
			            "token": "foo",
			            "url": "/user",
			          \},
			          "result": "result",
			          "status": "done",
			        \},
			        "tag": "request.finally.watch",
			      \},
			      Object \{
			        "data": Object \{
			          "params": "/user",
			          "result": "result",
			          "status": "done",
			        \},
			        "tag": "attached.finally.watch",
			      \},
			      Object \{
			        "data": "result",
			        "tag": "promise resolver",
			      \},
			    ]
			  \`)
			\})
			
			it('pass source to inner effect if no mapParams provided', async () => \{
			  const fn = jest.fn()
			
			  const request = createEffect((token: string) => \{
			    fn(token)
			    return 'ok'
			  \})
			  const token = createStore('foo')
			
			  const fx = attach(\{
			    source: token,
			    effect: request,
			  \})
			  await expect(fx()).resolves.toBe('ok')
			\})
			
			it('if no source nor mapParams provided just create new derived effect', async () => \{
			  const fn = jest.fn()
			  const \$counter = createStore(0)
			  const originalFx = createEffect((params: number) => params * 10)
			  const derivedFx = attach(\{effect: originalFx\})
			
			  \$counter.on(originalFx.doneData, (counter, value) => counter + value)
			  \$counter.on(derivedFx.doneData, (counter, value) => counter - value)
			
			  derivedFx.watch(params => \{
			    fn(\{effect: 'derivedFx', params\})
			  \})
			  derivedFx.doneData.watch(data => \{
			    fn(\{effect: 'derivedFx.doneData', data\})
			  \})
			  originalFx.watch(params => \{
			    fn(\{effect: 'originalFx', params\})
			  \})
			  originalFx.doneData.watch(data => \{
			    fn(\{effect: 'originalFx.doneData', data\})
			  \})
			
			  await derivedFx(3)
			  expect(\$counter.getState()).toBe(0)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "effect": "derivedFx",
			        "params": 3,
			      \},
			      Object \{
			        "effect": "originalFx",
			        "params": 3,
			      \},
			      Object \{
			        "data": 30,
			        "effect": "originalFx.doneData",
			      \},
			      Object \{
			        "data": 30,
			        "effect": "derivedFx.doneData",
			      \},
			    ]
			  \`)
			\})
			
			it('handle fatal errors in mapParams', async () => \{
			  const effect = createEffect(() => \{\})
			  const fx = attach(\{
			    effect,
			    mapParams() \{
			      throw Error('fatal error')
			    \},
			  \})
			  await expect(fx()).rejects.toThrowErrorMatchingInlineSnapshot(\`"fatal error"\`)
			\})
			
			test('async effect', async () => \{
			  const fn = jest.fn()
			  const \$calls = createStore(0)
			  const fx = attach(\{
			    source: \$calls,
			    async effect(calls: number, params: string) \{
			      await new Promise(rs => setTimeout(rs, 30))
			      fn([params, calls])
			    \},
			  \})
			  \$calls.on(fx.doneData, x => x + 1)
			  await fx('a')
			  await fx('b')
			  await fx('c')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        "a",
			        0,
			      ],
			      Array [
			        "b",
			        1,
			      ],
			      Array [
			        "c",
			        2,
			      ],
			    ]
			  \`)
			\})
			
			test('interaction with watch and parallel updates', async () => \{
			  const fn = jest.fn()
			
			  const trigger = createEvent<string>()
			  const inc = createEvent()
			  const source = createStore(0)
			  const fxTarget = createEffect((params: \{n: number; tag: string\}) => \{
			    fn(params)
			  \})
			
			  source.on(inc, n => n + 10)
			  source.on(fxTarget, n => n + 1)
			
			  const fx = attach(\{
			    source,
			    effect: fxTarget,
			    mapParams: (tag: string, n) => (\{tag, n\}),
			  \})
			
			  forward(\{
			    from: trigger,
			    to: [fx, fx],
			  \})
			
			  trigger.watch(() => \{
			    inc()
			  \})
			
			  trigger('a')
			  trigger('b')
			
			  expect(argumentHistory(fn)).toEqual([
			    \{n: 10, tag: 'a'\},
			    \{n: 10, tag: 'a'\},
			    \{n: 22, tag: 'b'\},
			    \{n: 22, tag: 'b'\},
			  ])
			\})
			
			test('attached effect should got its name from parent domain', () => \{
			  const app = createDomain()
			  const fx = app.createEffect(() => \{\})
			  const attached = attach(\{effect: fx\})
			  expect(attached.compositeName.fullName).toBe('app/attached')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\attach.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\effector\\__tests__\\clearNode.test.ts', () => {
        const sourceCode = `
			import \{
			  clearNode,
			  createEvent,
			  createDomain,
			  forward,
			  createStore,
			  sample,
			  combine,
			  createEffect,
			  split,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			it('will deactivate event', () => \{
			  const fn = jest.fn()
			  const event = createEvent<number>()
			  event.watch(x => fn(x))
			  clearNode(event)
			  event(1)
			  expect(fn).toBeCalledTimes(0)
			\})
			
			it('will deactivate store', () => \{
			  const fn = jest.fn()
			  const store = createStore(0)
			  store.watch(x => fn(x))
			  expect(fn).toBeCalledTimes(1)
			  clearNode(store)
			  //@ts-expect-error
			  store.setState(1)
			  expect(fn).toBeCalledTimes(1)
			\})
			
			it('will not broke subscribers', () => \{
			  const fn = jest.fn()
			  const eventA = createEvent<number>()
			  const eventB = createEvent<number>()
			  eventB.watch(e => fn(e))
			
			  forward(\{
			    from: eventA,
			    to: eventB,
			  \})
			
			  eventA(0)
			  expect(fn).toBeCalledTimes(1)
			  clearNode(eventA)
			
			  eventA(1) //nothing happens
			  expect(fn).toBeCalledTimes(1)
			  eventB(2) //work as expected
			  expect(fn).toBeCalledTimes(2)
			\})
			
			test('deep cleaning', () => \{
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  const source = createStore(0)
			  const target = source.map(x => \{
			    fn1(x)
			    return x
			  \})
			  target.watch(x => fn2(x))
			  expect(fn1).toBeCalledTimes(1)
			  expect(fn2).toBeCalledTimes(1)
			  //please be careful with \{deep: true\}
			  //it will destroy everything related to that node
			  clearNode(source, \{deep: true\})
			  //@ts-expect-error
			  source.setState(1) //nothing happens
			  expect(fn1).toBeCalledTimes(1)
			  expect(fn2).toBeCalledTimes(1)
			  //@ts-expect-error
			  target.setState(2) //dead as well
			  expect(fn2).toBeCalledTimes(1)
			\})
			
			describe('itermediate steps should not stay', () => \{
			  it('support store.map', () => \{
			    const fn = jest.fn()
			    const source = createStore(0)
			    const target = source.map(x => \{
			      fn(x)
			      return x
			    \})
			    //@ts-expect-error
			    source.setState(1)
			    expect(fn).toBeCalledTimes(2)
			    clearNode(target)
			    //@ts-expect-error
			    source.setState(2)
			    expect(fn).toBeCalledTimes(2)
			  \})
			  it('support event.map', () => \{
			    const fn = jest.fn()
			    const source = createEvent<number>()
			    const target = source.map(x => \{
			      fn(x)
			      return x
			    \})
			    source(1)
			    expect(fn).toBeCalledTimes(1)
			    clearNode(target)
			    source(2)
			    expect(fn).toBeCalledTimes(1)
			  \})
			  it('support store.on', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent()
			    const store = createStore(0).on(trigger, x => \{
			      fn(x)
			      return x + 1
			    \})
			    trigger()
			    expect(fn).toBeCalledTimes(1)
			    clearNode(store)
			    trigger()
			    expect(fn).toBeCalledTimes(1)
			  \})
			  it('support sample result', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent()
			    const store = createStore(null)
			    const result = sample(\{
			      source: store,
			      clock: trigger,
			      fn,
			    \})
			    trigger()
			    expect(fn).toBeCalledTimes(1)
			    clearNode(result)
			    trigger()
			    expect(fn).toBeCalledTimes(1)
			  \})
			  it('support sample source', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent()
			    const store = createStore(null)
			    sample(\{
			      source: store,
			      clock: trigger,
			      fn,
			    \})
			    trigger()
			    expect(fn).toBeCalledTimes(1)
			    clearNode(store)
			    trigger()
			    expect(fn).toBeCalledTimes(1)
			  \})
			\})
			describe('based on clearNode', () => \{
			  it('will not clear store after event will be destroyed', () => \{
			    const fn = jest.fn()
			    const store = createStore(0)
			    const eventA = createEvent()
			    const eventB = createEvent()
			    store.on(eventA, x => x + 1).on(eventB, x => x + 1)
			    store.watch(fn)
			    eventA()
			    clearNode(eventA)
			    eventB()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			        2,
			      ]
			    \`)
			  \})
			  it('will not clear connected units after forward will be destroyed', () => \{
			    const fn = jest.fn()
			    const eventA = createEvent<number>()
			    const eventB = createEvent<number>()
			    const unsub = forward(\{
			      from: eventA,
			      to: eventB,
			    \})
			    eventA.watch(fn)
			    eventA(0)
			    unsub()
			    eventA(1)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			      ]
			    \`)
			  \})
			  it('will not clear unit after .watch will be destroyed', () => \{
			    const fn = jest.fn()
			    const event = createEvent<number>()
			    const unsub = event.watch(() => \{\})
			    event.watch(fn)
			    event(0)
			    unsub()
			    event(1)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			      ]
			    \`)
			  \})
			  it('will not clear store after store.updates.watch will be destroyed', () => \{
			    const fn = jest.fn()
			    const event = createEvent()
			    const store = createStore(0).on(event, x => x + 1)
			    const unsub = store.updates.watch(() => \{\})
			    store.updates.watch(fn)
			    event()
			    unsub()
			    event()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			  it('will not clear node, connected via forward to destroyed one', () => \{
			    const fn = jest.fn()
			    const store = createStore(0)
			    const event = createEvent<number>()
			    event.watch(fn)
			    forward(\{
			      from: store.updates,
			      to: event,
			    \})
			    //@ts-expect-error
			    store.setState(1)
			    event(2)
			    clearNode(store)
			    event(3)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			        3,
			      ]
			    \`)
			  \})
			  it('will not clear node, which forwarded to destroyed one', () => \{
			    const fn = jest.fn()
			    const store = createStore(0)
			    const event = createEvent()
			    store.updates.watch(fn)
			    forward(\{
			      from: store.updates,
			      to: event,
			    \})
			    //@ts-expect-error
			    store.setState(1)
			    clearNode(event)
			    //@ts-expect-error
			    store.setState(2)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			\})
			describe('domain support', () => \{
			  it('will not clear domain.createStore after event will be destroyed', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const store = domain.createStore(0)
			    const eventA = domain.createEvent()
			    const eventB = domain.createEvent()
			    store.on(eventA, x => x + 1).on(eventB, x => x + 1)
			    store.watch(fn)
			    eventA()
			    clearNode(eventA)
			    eventB()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			        2,
			      ]
			    \`)
			  \})
			  it('will not clear connected units after forward will be destroyed', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const eventA = domain.createEvent<number>()
			    const eventB = domain.createEvent<number>()
			    const unsub = forward(\{
			      from: eventA,
			      to: eventB,
			    \})
			    eventA.watch(fn)
			    eventA(0)
			    unsub()
			    eventA(1)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			      ]
			    \`)
			  \})
			  it('will not clear unit after .watch will be destroyed', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const event = domain.createEvent<number>()
			    const unsub = event.watch(() => \{\})
			    event.watch(fn)
			    event(0)
			    unsub()
			    event(1)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			      ]
			    \`)
			  \})
			  it('will not clear store after store.updates.watch will be destroyed', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const event = domain.createEvent()
			    const store = domain.createStore(0).on(event, x => x + 1)
			    const unsub = store.updates.watch(() => \{\})
			    store.updates.watch(fn)
			    event()
			    unsub()
			    event()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			  it('will not clear node, connected via forward to destroyed one', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const store = domain.createStore(0)
			    const event = domain.createEvent<number>()
			    event.watch(fn)
			    forward(\{
			      from: store.updates,
			      to: event,
			    \})
			    //@ts-expect-error
			    store.setState(1)
			    event(2)
			    clearNode(store)
			    event(3)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			        3,
			      ]
			    \`)
			  \})
			  it('will not clear node, which forwarded to destroyed one', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const store = domain.createStore(0)
			    const event = domain.createEvent()
			    store.updates.watch(fn)
			    forward(\{
			      from: store.updates,
			      to: event,
			    \})
			    //@ts-expect-error
			    store.setState(1)
			    clearNode(event)
			    //@ts-expect-error
			    store.setState(2)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			  it('will not clear event after clearNode call at its prepended event', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const event = domain.createEvent<number>()
			    const prepended = event.prepend<number>(_ => _)
			    event.watch(fn)
			
			    clearNode(prepended)
			    event(1)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			  test('child should not survive clearNode(domain) call', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const event = domain.createEvent<number>()
			    event.watch(fn)
			    event(1)
			    clearNode(domain)
			    event(2)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			  describe('clearNode(domain) should not affect sibling nodes', () => \{
			    describe('with forward', () => \{
			      test('from', () => \{
			        const fn = jest.fn()
			        const domain = createDomain()
			        const event = createEvent<number>()
			        const event2 = domain.createEvent<number>()
			        forward(\{
			          from: event,
			          to: event2,
			        \})
			        event.watch(fn)
			        event(0)
			        clearNode(domain)
			        event(1)
			        expect(argumentHistory(fn)).toEqual([0, 1])
			      \})
			      test('from array', () => \{
			        const fn = jest.fn()
			        const domain = createDomain()
			        const event = createEvent<number>()
			        const event2 = domain.createEvent<number>()
			        const event3 = domain.createEvent<number>()
			        forward(\{
			          from: [event, event2],
			          to: event3,
			        \})
			        event.watch(fn)
			        event(0)
			        clearNode(domain)
			        event(1)
			        expect(argumentHistory(fn)).toEqual([0, 1])
			      \})
			      test('to', () => \{
			        const fn = jest.fn()
			        const domain = createDomain()
			        const event = createEvent<number>()
			        const event2 = domain.createEvent<number>()
			        forward(\{
			          from: event2,
			          to: event,
			        \})
			        event.watch(fn)
			        event(0)
			        event2(1)
			        clearNode(domain)
			        event(2)
			        event2(3)
			        expect(argumentHistory(fn)).toEqual([0, 1, 2])
			      \})
			      test('to array', () => \{
			        const fn = jest.fn()
			        const domain = createDomain()
			        const event = createEvent<number>()
			        const event2 = domain.createEvent<number>()
			        const event3 = domain.createEvent<number>()
			        forward(\{
			          from: event2,
			          to: [event, event3],
			        \})
			        event.watch(fn)
			        event(0)
			        event2(1)
			        clearNode(domain)
			        event(2)
			        event2(3)
			        expect(argumentHistory(fn)).toEqual([0, 1, 2])
			      \})
			    \})
			    test('with sample', () => \{
			      const fn = jest.fn()
			      const fn2 = jest.fn()
			      const store = createStore<number | null>(null)
			      const event = createEvent<number>()
			      store.on(event, (_, e) => e)
			      store.watch(fn)
			
			      const domain = createDomain()
			      const eventInDomain = domain.createEvent<number>()
			      eventInDomain.watch(fn2)
			      sample(\{
			        source: store,
			        clock: eventInDomain,
			      \})
			
			      event(1)
			      eventInDomain(-1)
			
			      clearNode(domain)
			
			      event(2)
			      eventInDomain(-2)
			      expect(argumentHistory(fn2)).toEqual([-1])
			      expect(argumentHistory(fn)).toEqual([null, 1, 2])
			    \})
			    test('with combine', () => \{
			      const fn = jest.fn()
			      const fn2 = jest.fn()
			      const store = createStore<number | null>(null)
			      const event = createEvent<number>()
			      store.on(event, (_, e) => e)
			      store.watch(fn)
			
			      const domain = createDomain()
			      const storeInDomain = domain.createStore<number | null>(null)
			      storeInDomain.on(event, (_, e) => e)
			      storeInDomain.watch(fn2)
			      combine(\{store, storeInDomain\})
			
			      event(1)
			
			      clearNode(domain)
			
			      event(2)
			      expect(argumentHistory(fn2)).toEqual([null, 1])
			      expect(argumentHistory(fn)).toEqual([null, 1, 2])
			    \})
			    describe('with split', () => \{
			      test('from domain source to non-domain target', () => \{
			        const fn = jest.fn()
			        const domain = createDomain()
			        const source = domain.createEvent<number>()
			        const target = createEvent<number>()
			        split(\{
			          source,
			          match: \{even: x => x % 2 === 0\},
			          cases: \{even: target\},
			        \})
			        target.watch(fn)
			        clearNode(domain)
			        source(2)
			        target(4)
			        expect(argumentHistory(fn)).toEqual([4])
			      \})
			      test('from non-domain source to domain target', () => \{
			        const fn = jest.fn()
			        const domain = createDomain()
			        const source = createEvent<number>()
			        const target = domain.createEvent<number>()
			        split(\{
			          source,
			          match: \{even: x => x % 2 === 0\},
			          cases: \{even: target\},
			        \})
			        source.watch(fn)
			        clearNode(domain)
			        source(2)
			        target(4)
			        expect(argumentHistory(fn)).toEqual([2])
			      \})
			      test('from domain source to domain target', () => \{
			        const fn = jest.fn()
			        const domain1 = createDomain()
			        const domain2 = createDomain()
			        const source = domain1.createEvent<number>()
			        const target = domain2.createEvent<number>()
			        split(\{
			          source,
			          match: \{even: x => x % 2 === 0\},
			          cases: \{even: target\},
			        \})
			        target.watch(fn)
			        clearNode(domain1)
			        source(2)
			        target(4)
			        expect(argumentHistory(fn)).toEqual([4])
			      \})
			    \})
			  \})
			  describe('clearNode(domain) should not affect sample targets', () => \{
			    test('with store as source', () => \{
			      const fn = jest.fn()
			      const fn2 = jest.fn()
			
			      const event1 = createEvent<number>()
			      const event2 = createEvent<number>()
			      const storeA = createStore(0).on(event1, (_, v) => v)
			
			      const storeB = createStore(0).on(event2, (_, v) => v)
			      storeA.watch(fn)
			      storeB.watch(fn2)
			
			      const domain = createDomain()
			      const storeInDomain = domain.createStore(0)
			
			      sample(\{
			        source: storeInDomain,
			        clock: createEvent(),
			        target: storeA,
			      \})
			
			      sample(\{
			        source: storeA,
			        clock: createEvent(),
			        target: storeB,
			      \})
			
			      event1(1)
			      event2(100)
			
			      clearNode(domain)
			
			      event1(2)
			      event2(200)
			      expect(argumentHistory(fn2)).toEqual([0, 100, 200])
			      expect(argumentHistory(fn)).toEqual([0, 1, 2])
			    \})
			    test('with event as source', () => \{
			      const fn = jest.fn()
			      const fn2 = jest.fn()
			      const store = createStore(0)
			      const source = createEvent<number>()
			      const clock = createEvent()
			
			      source.watch(fn)
			      store.watch(fn2)
			
			      const domain = createDomain()
			      const eventInDomain = domain.createEvent<number>()
			
			      sample(\{
			        source: eventInDomain,
			        clock: createEvent(),
			        target: store,
			      \})
			
			      sample(\{
			        source,
			        clock,
			        target: store,
			      \})
			
			      source(1)
			      clock()
			
			      clearNode(domain)
			
			      source(2)
			      clock()
			      expect(argumentHistory(fn2)).toEqual([0, 1, 2])
			      expect(argumentHistory(fn)).toEqual([1, 2])
			    \})
			  \})
			  describe('clearNode(domain) should not propagate through .on', () => \{
			    test('to store without domain', async () => \{
			      const fn1 = jest.fn()
			      const fn2 = jest.fn()
			      const domain1 = createDomain()
			      const inc = createEffect(() => 1)
			      const dec = createEvent()
			      const store1 = domain1.createStore(0).on(inc.doneData, x => x + 1)
			      const store2 = createStore(0)
			        .on(inc.doneData, x => x + 1)
			        .on(dec, x => x - 1)
			      store2.watch(fn1)
			      inc.doneData.watch(fn2)
			      clearNode(domain1)
			      await inc()
			      await inc()
			      dec()
			      expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			          1,
			          2,
			          1,
			        ]
			      \`)
			      expect(fn2).toBeCalledTimes(2)
			    \})
			    describe('to sibling domain', () => \{
			      test('through effect without domain', async () => \{
			        const fn1 = jest.fn()
			        const fn2 = jest.fn()
			        const domain1 = createDomain()
			        const domain2 = createDomain()
			        const inc = createEffect(() => 1)
			        const dec = createEvent()
			        const store1 = domain1.createStore(0).on(inc.doneData, x => x + 1)
			        const store2 = domain2
			          .createStore(0)
			          .on(inc.doneData, x => x + 1)
			          .on(dec, x => x - 1)
			        store2.watch(fn1)
			        inc.doneData.watch(fn2)
			        clearNode(domain1)
			        await inc()
			        await inc()
			        dec()
			        expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			          Array [
			            0,
			            1,
			            2,
			            1,
			          ]
			        \`)
			        expect(fn2).toBeCalledTimes(2)
			      \})
			      test('through effect in sibling domain', async () => \{
			        const fn1 = jest.fn()
			        const fn2 = jest.fn()
			        const domain1 = createDomain()
			        const domain2 = createDomain()
			        const inc = domain2.createEffect(() => 1)
			        const dec = createEvent()
			        const store1 = domain1.createStore(0).on(inc.doneData, x => x + 1)
			        const store2 = domain2
			          .createStore(0)
			          .on(inc.doneData, x => x + 1)
			          .on(dec, x => x - 1)
			        store2.watch(fn1)
			        inc.doneData.watch(fn2)
			        clearNode(domain1)
			        await inc()
			        await inc()
			        dec()
			        expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			          Array [
			            0,
			            1,
			            2,
			            1,
			          ]
			        \`)
			        expect(fn2).toBeCalledTimes(2)
			      \})
			      test('through effect in target domain', async () => \{
			        const fn1 = jest.fn()
			        const fn2 = jest.fn()
			        const domain1 = createDomain()
			        const domain2 = createDomain()
			        const inc = domain1.createEffect(() => 1)
			        const dec = createEvent()
			        const store1 = domain1.createStore(0).on(inc.doneData, x => x + 1)
			        const store2 = domain2
			          .createStore(0)
			          .on(inc.doneData, x => x + 1)
			          .on(dec, x => x - 1)
			        store2.watch(fn1)
			        inc.doneData.watch(fn2)
			        clearNode(domain1)
			        inc()
			        inc()
			        dec()
			        expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			          Array [
			            0,
			            -1,
			          ]
			        \`)
			        expect(fn2).toBeCalledTimes(0)
			      \})
			    \})
			    describe('to parent domain', () => \{
			      test('through effect without domain', async () => \{
			        const fn1 = jest.fn()
			        const fn2 = jest.fn()
			        const rootDomain = createDomain()
			        const domain1 = rootDomain.createDomain()
			        const inc = createEffect(() => 1)
			        const dec = createEvent()
			        const store1 = domain1.createStore(0).on(inc.doneData, x => x + 1)
			        const store2 = rootDomain
			          .createStore(0)
			          .on(inc.doneData, x => x + 1)
			          .on(dec, x => x - 1)
			        store2.watch(fn1)
			        inc.doneData.watch(fn2)
			        clearNode(domain1)
			        await inc()
			        await inc()
			        dec()
			        expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			          Array [
			            0,
			            1,
			            2,
			            1,
			          ]
			        \`)
			        expect(fn2).toBeCalledTimes(2)
			      \})
			      test('through effect in root domain', async () => \{
			        const fn1 = jest.fn()
			        const fn2 = jest.fn()
			        const rootDomain = createDomain()
			        const domain1 = rootDomain.createDomain()
			        const inc = rootDomain.createEffect(() => 1)
			        const dec = createEvent()
			        const store1 = domain1.createStore(0).on(inc.doneData, x => x + 1)
			        const store2 = rootDomain
			          .createStore(0)
			          .on(inc.doneData, x => x + 1)
			          .on(dec, x => x - 1)
			        store2.watch(fn1)
			        inc.doneData.watch(fn2)
			        clearNode(domain1)
			        await inc()
			        await inc()
			        dec()
			        expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			          Array [
			            0,
			            1,
			            2,
			            1,
			          ]
			        \`)
			        expect(fn2).toBeCalledTimes(2)
			      \})
			      test('through effect in target domain', async () => \{
			        const fn1 = jest.fn()
			        const fn2 = jest.fn()
			        const rootDomain = createDomain()
			        const domain1 = rootDomain.createDomain()
			        const inc = domain1.createEffect(() => 1)
			        const dec = createEvent()
			        const store1 = domain1.createStore(0).on(inc.doneData, x => x + 1)
			        const store2 = rootDomain
			          .createStore(0)
			          .on(inc.doneData, x => x + 1)
			          .on(dec, x => x - 1)
			        store2.watch(fn1)
			        inc.doneData.watch(fn2)
			        clearNode(domain1)
			        inc()
			        inc()
			        dec()
			        expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			          Array [
			            0,
			            -1,
			          ]
			        \`)
			        expect(fn2).toBeCalledTimes(0)
			      \})
			    \})
			  \})
			  it('should remove erased units from domain hooks', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const event = domain.createEvent()
			    clearNode(event)
			    domain.onCreateEvent(fn)
			    expect(domain.history.events.size).toBe(0)
			    expect(fn).not.toHaveBeenCalled()
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\clearNode.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(42)
    });
    it('effector_effector\\src\\effector\\__tests__\\combine.test.ts', () => {
        const sourceCode = `
			import \{
			  combine,
			  createStore,
			  createEffect,
			  sample,
			  createEvent,
			  EffectResult,
			  createDomain,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			function rgbToHex(r: number, g: number, b: number) \{
			  return (
			    '#' +
			    r.toString(16).padStart(2, '0') +
			    g.toString(16).padStart(2, '0') +
			    b.toString(16).padStart(2, '0')
			  )
			\}
			describe('combine cases', () => \{
			  test('combine(\{R,G,B\})', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store = combine(\{R, G, B\})
			    expect(store.getState()).toEqual(\{R: 233, G: 88, B: 1\})
			  \})
			  test('combine([R,G,B])', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store = combine([R, G, B])
			    expect(store.getState()).toEqual([233, 88, 1])
			  \})
			  test('combine(\{Color\})', () => \{
			    const Color = createStore('#e95801')
			    const store = combine(\{Color\})
			    expect(store.getState()).toEqual(\{Color: '#e95801'\})
			  \})
			  test('combine([Color])', () => \{
			    const Color = createStore('#e95801')
			    const store = combine([Color])
			    expect(store.getState()).toEqual(['#e95801'])
			  \})
			  test(\`combine(\{R,G,B\}, (\{R,G,B\}) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store = combine(\{R, G, B\}, (\{R, G, B\}) => rgbToHex(R, G, B))
			    expect(store.getState()).toEqual('#e95801')
			  \})
			  test(\`combine([R,G,B], ([R,G,B]) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store = combine([R, G, B], ([R, G, B]) => rgbToHex(R, G, B))
			    expect(store.getState()).toEqual('#e95801')
			  \})
			  test(\`combine(\{Color\}, (\{Color\}) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    const store = combine(\{Color\}, (\{Color\}) => Color)
			    expect(store.getState()).toEqual('#e95801')
			  \})
			  test(\`combine([Color], ([Color]) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    const store = combine([Color], ([Color]) => Color)
			    expect(store.getState()).toEqual('#e95801')
			  \})
			  test(\`combine(Color, (Color) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    const store = combine(Color, Color => Color)
			    expect(store.getState()).toEqual('#e95801')
			  \})
			  test(\`combine(R,G,B, (R,G,B) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store = combine(R, G, B, (R, G, B) => rgbToHex(R, G, B))
			    expect(store.getState()).toEqual('#e95801')
			  \})
			  test('combine(R,G,B)', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store = combine(R, G, B)
			    expect(store.getState()).toEqual([233, 88, 1])
			  \})
			  test('combine(Color)', () => \{
			    const Color = createStore('#e95801')
			    const store = combine(Color)
			    expect(store.getState()).toEqual(['#e95801'])
			  \})
			  test('combine(...primitives)', () => \{
			    const store = combine(1, [false], \{value: 'a'\})
			    expect(store.getState()).toEqual([1, [false], \{value: 'a'\}])
			  \})
			  test('combine([primitives])', () => \{
			    const store = combine([1, [false], \{value: 'a'\}])
			    expect(store.getState()).toEqual([1, [false], \{value: 'a'\}])
			  \})
			  test('combine(Store, primitive)', () => \{
			    const Color = createStore('#e95801')
			    const store = combine(Color, '#e95801')
			    expect(store.getState()).toEqual(['#e95801', '#e95801'])
			  \})
			\})
			
			it('deduplicate outputs', async () => \{
			  const fn = jest.fn()
			  const fetchApi = createEffect(async () => \{
			    await new Promise(rs => setTimeout(rs, 10))
			    return [\{name: 'physics', id: 1\}]
			  \})
			  const data = createStore([] as EffectResult<typeof fetchApi>).on(
			    fetchApi.done,
			    (_, \{result\}) => result,
			  )
			  const lessonIndex = createStore(0)
			  const lesson = combine(
			    data,
			    lessonIndex,
			    (data, index) => data[index] || null,
			  )
			  const lessonWithPending = combine(
			    lesson,
			    fetchApi.pending,
			    (lesson, pending) => (\{lesson, pending\}),
			  )
			  sample(lessonWithPending).updates.watch(data => fn(data))
			
			  await fetchApi()
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "lesson": null,
			        "pending": true,
			      \},
			      Object \{
			        "lesson": Object \{
			          "id": 1,
			          "name": "physics",
			        \},
			        "pending": false,
			      \},
			    ]
			  \`)
			\})
			
			it('skip first duplicated update', () => \{
			  const fn = jest.fn()
			  const changedToken = createEvent<string>()
			
			  const \$token = createStore('').on(changedToken, (_, token) => token)
			  const \$token2 = createStore('').on(changedToken, (_, token) => token)
			
			  const websocketUrl = combine(\$token, () => null)
			  websocketUrl.watch(fn)
			  changedToken('token')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      null,
			    ]
			  \`)
			\})
			
			it('updates consistently', () => \{
			  const fn = jest.fn()
			  const e = createEvent<string>()
			
			  const s1 = createStore('').on(e, (_, m) => m)
			  const s2 = createStore('').on(e, (_, m) => m)
			  let i = 0
			  //prettier-ignore
			  const combined = combine(s1, s2, (_, m): (string | null | void) => \{
			    i+=1
			    switch (i) \{
			      case 1: return null
			      //a
			      case 2: return m
			      //return the same value twice
			      //b
			      case 3:
			      //c
			      case 4: return 'noop'
			      //d
			      case 5: return m
			      //return undefined
			      //e
			      case 6: return
			      //f
			      case 7: return m
			      //return undefined and then return same state
			      //g
			      case 8: return
			      //h
			      case 9: return (() => combined.getState())()
			      //i, j
			      default: return m
			    \}
			  \})
			  combined.watch(fn)
			  e('a')
			  e('b')
			  e('c')
			  e('d')
			  e('e')
			  e('f')
			  e('g')
			  e('h')
			  e('i')
			  e('j')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      null,
			      "a",
			      "noop",
			      "d",
			      "f",
			      "i",
			      "j",
			    ]
			  \`)
			\})
			
			describe('validations', () => \{
			  it('validate amount of arguments', () => \{
			    expect(() => \{
			      //@ts-expect-error
			      combine()
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"expect first argument be an object"\`,
			    )
			  \})
			
			  it('validate shape', () => \{
			    expect(() => \{
			      combine(null)
			    \}).toThrowErrorMatchingInlineSnapshot(\`"shape should be an object"\`)
			    expect(() => \{
			      combine('text')
			    \}).toThrowErrorMatchingInlineSnapshot(\`"shape should be an object"\`)
			    expect(() => \{
			      combine(0, () => \{\})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"shape should be an object"\`)
			  \})
			
			  it('doesn\`t allow events or other units in shape', () => \{
			    expect(() => \{
			      combine(\{a: createEvent()\})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"combine expects a store in a field a"\`,
			    )
			    expect(() => \{
			      combine(\{a: createEffect()\})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"combine expects a store in a field a"\`,
			    )
			    expect(() => \{
			      combine(\{a: createDomain()\})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"combine expects a store in a field a"\`,
			    )
			  \})
			  it('doesn\`t allow undefined in shape', () => \{
			    expect(() => \{
			      combine(\{a: undefined\})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"combine expects a store in a field a"\`,
			    )
			  \})
			\})
			
			it('doesn\`t leak internal variables to transform function', () => \{
			  const fn = jest.fn()
			  const inc = createEvent()
			  const a = createStore(0).on(inc, x => x + 1)
			  const combined = combine(\{a\}, (...args) => \{
			    fn(args)
			    return 0
			  \})
			  inc()
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        Object \{
			          "a": 0,
			        \},
			      ],
			      Array [
			        Object \{
			          "a": 1,
			        \},
			      ],
			    ]
			  \`)
			\})
			
			describe('doesn\`t fail with slice is not a function', () => \{
			  test('array', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const \$a = createStore(0).on(inc, x => x + 1)
			    const combined = combine([\$a], (array: any) => \{
			      const mainSlice = array.slice
			      array.slice = (...args: any[]) => \{
			        fn('slice')
			        return mainSlice.apply(array, args)
			      \}
			      return array[0] + 1
			    \})
			    inc()
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`Array []\`)
			  \})
			
			  test('combine + map', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const \$a = createStore(0).on(inc, x => x + 1)
			    const \$b = createStore(0).on(inc, x => x + 1)
			    const combined = combine([\$a, \$b]).map((array: any) => \{
			      const mainSlice = array.slice
			      array.slice = (...args: any[]) => \{
			        fn('slice')
			        return mainSlice.apply(array, args)
			      \}
			      return array[0] + 1
			    \})
			    inc()
			    inc()
			    inc()
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`Array []\`)
			  \})
			\})
			
			describe('don\`t reuse values from user', () => \{
			  test('with sample (more convenient)', () => \{
			    const triggerA = createEvent()
			    const triggerB = createEvent()
			    const foo = createStore(0)
			    const bar = createStore(0).on(triggerB, x => x + 10)
			    const combined = combine(\{foo, bar\})
			    sample(\{
			      clock: triggerA,
			      source: combined,
			      target: combined,
			      fn: (\{foo, bar\}) => (\{
			        foo: foo + 1,
			        bar: bar + 1,
			      \}),
			    \})
			
			    triggerA()
			    expect(combined.getState()).toEqual(\{foo: 1, bar: 1\})
			    triggerB()
			    expect(combined.getState()).toEqual(\{foo: 0, bar: 10\})
			    triggerA()
			    expect(combined.getState()).toEqual(\{foo: 1, bar: 11\})
			    triggerB()
			    expect(combined.getState()).toEqual(\{foo: 0, bar: 20\})
			  \})
			  test('with on (less convenient)', () => \{
			    const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			    const triggerA = createEvent()
			    const triggerB = createEvent()
			    const foo = createStore(0)
			    const bar = createStore(0).on(triggerB, x => x + 10)
			    const combined = combine(\{foo, bar\})
			    combined.on(triggerA, (\{foo, bar\}) => (\{
			      foo: foo + 1,
			      bar: bar + 1,
			    \}))
			    warn.mockRestore()
			
			    triggerA()
			    expect(combined.getState()).toEqual(\{foo: 1, bar: 1\})
			    triggerB()
			    expect(combined.getState()).toEqual(\{foo: 0, bar: 10\})
			    triggerA()
			    expect(combined.getState()).toEqual(\{foo: 1, bar: 11\})
			    triggerB()
			    expect(combined.getState()).toEqual(\{foo: 0, bar: 20\})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\combine.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(27)
    });
    it('effector_effector\\src\\effector\\__tests__\\createApi.test.ts', () => {
        const sourceCode = `
			import \{createApi, restore, combine\} from 'effector'
			
			test('create api', () => \{
			  const shape = restore(\{
			    todos: ['to do', 'list'],
			    newTodo: '',
			    selected: [1],
			  \})
			  const full = combine(shape)
			  const listCmd = createApi(shape.todos, \{
			    add(todos, item) \{
			      return [...todos, item]
			    \},
			    remove(todos, index) \{
			      return [...todos].splice(index, 1)
			    \},
			  \})
			  shape.selected.on(listCmd.remove, (selected, index) => \{
			    const pos = selected.indexOf(index)
			    if (pos === -1) return selected
			    return [...selected].splice(pos, 1)
			  \})
			  const selectionCmd = createApi(shape.selected, \{
			    add(selected, item) \{
			      return [...selected, item]
			    \},
			    remove(selected, index) \{
			      return [...selected].splice(index, 1)
			    \},
			  \})
			  expect(full.getState()).toMatchObject(\{
			    todos: ['to do', 'list'],
			    newTodo: '',
			    selected: [1],
			  \})
			  listCmd.add('new todo')
			  selectionCmd.add(2)
			  expect(full.getState()).toMatchObject(\{
			    todos: ['to do', 'list', 'new todo'],
			    newTodo: '',
			    selected: [1, 2],
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\createApi.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\effector\\__tests__\\createStoreObject.test.ts', () => {
        const sourceCode = `
			import \{createStore, createStoreObject\} from 'effector'
			let consoleError: any
			beforeEach(() => \{
			  consoleError = console.error
			  console.error = () => \{\}
			\})
			afterEach(() => \{
			  console.error = consoleError
			\})
			
			describe('createStoreObject', () => \{
			  test('.defaultState', () => \{
			    const foo = createStore('')
			    const bar = createStore('')
			    const store = createStoreObject(\{foo, bar, baz: 1\})
			    foo.setState('foo')
			    bar.setState('bar')
			    expect(foo.defaultState).toEqual('')
			    expect(bar.defaultState).toEqual('')
			    expect(store.defaultState).toEqual(\{foo: '', bar: '', baz: 1\})
			    expect(store.getState()).toEqual(\{foo: 'foo', bar: 'bar', baz: 1\})
			  \})
			\})
			
			describe('createStoreArray', () => \{
			  test('.defaultState', () => \{
			    const foo = createStore('')
			    const bar = createStore('')
			    const store = createStoreObject([foo, bar])
			    foo.setState('foo')
			    bar.setState('bar')
			    expect(foo.defaultState).toEqual('')
			    expect(bar.defaultState).toEqual('')
			    expect(store.defaultState).toEqual(['', ''])
			    expect(store.getState()).toEqual(['foo', 'bar'])
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\createStoreObject.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\effector\\__tests__\\createWatch.test.ts', () => {
        const sourceCode = `
			import \{
			  allSettled,
			  createEffect,
			  createEvent,
			  createStore,
			  createWatch,
			  fork,
			\} from 'effector'
			
			describe('createWatch on scope', () => \{
			  test('event', async () => \{
			    const event = createEvent()
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: event, scope, fn: listener\})
			
			    await allSettled(event, \{scope\})
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(undefined)
			  \})
			
			  test('event without scope', async () => \{
			    const event = createEvent()
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: event, scope, fn: listener\})
			
			    event()
			
			    expect(listener).not.toHaveBeenCalled()
			  \})
			
			  test('effect', async () => \{
			    const effect = createEffect(() => null)
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: effect, scope, fn: listener\})
			
			    await allSettled(effect, \{scope\})
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(undefined)
			  \})
			
			  test('effect without scope', async () => \{
			    const effect = createEffect(() => null)
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: effect, scope, fn: listener\})
			
			    effect()
			
			    expect(listener).not.toHaveBeenCalled()
			  \})
			
			  test('store', async () => \{
			    const event = createEvent<unknown>()
			    const store = createStore<unknown>(null).on(event, (_, value) => value)
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: store, scope, fn: listener\})
			
			    await allSettled(event, \{scope, params: \{\}\})
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(\{\})
			  \})
			
			  test('store without scope', async () => \{
			    const event = createEvent<unknown>()
			    const store = createStore<unknown>(null).on(event, (_, value) => value)
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: store, scope, fn: listener\})
			
			    event()
			
			    expect(listener).not.toHaveBeenCalled()
			  \})
			\})
			
			describe('createWatch without scope', () => \{
			  test('event', async () => \{
			    const event = createEvent()
			    const listener = jest.fn()
			
			    createWatch(\{unit: event, fn: listener\})
			
			    event()
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(undefined)
			  \})
			
			  test('event with scope', async () => \{
			    const event = createEvent()
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: event, fn: listener\})
			
			    await allSettled(event, \{scope\})
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(undefined)
			  \})
			
			  test('effect', async () => \{
			    const effect = createEffect(() => null)
			    const listener = jest.fn()
			
			    createWatch(\{unit: effect, fn: listener\})
			
			    await effect()
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(undefined)
			  \})
			
			  test('effect with scope', async () => \{
			    const effect = createEffect(() => null)
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: effect, fn: listener\})
			
			    await allSettled(effect, \{scope\})
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(undefined)
			  \})
			
			  test('store', async () => \{
			    const event = createEvent<unknown>()
			    const store = createStore<unknown>(null).on(event, (_, value) => value)
			    const listener = jest.fn()
			
			    createWatch(\{unit: store, fn: listener\})
			
			    event(\{\})
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(\{\})
			  \})
			
			  test('store with scope', async () => \{
			    const event = createEvent<unknown>()
			    const store = createStore<unknown>(null).on(event, (_, value) => value)
			    const scope = fork()
			    const listener = jest.fn()
			
			    createWatch(\{unit: store, fn: listener\})
			
			    await allSettled(event, \{scope, params: \{\}\})
			
			    expect(listener).toHaveBeenCalledTimes(1)
			    expect(listener).toBeCalledWith(\{\})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\createWatch.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\effector\\__tests__\\derived.test.ts', () => {
        const sourceCode = `
			import \{
			  createEvent,
			  createStore,
			  createEffect,
			  combine,
			  sample,
			  forward,
			  guard,
			  merge,
			  split,
			  createApi,
			\} from 'effector'
			
			let warn: jest.SpyInstance<void, [message?: any, ...optionalParams: any[]]>
			beforeEach(() => \{
			  warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			\})
			afterEach(() => \{
			  warn.mockRestore()
			\})
			
			function getWarning() \{
			  return warn.mock.calls.map(([msg]) => msg)[0]
			\}
			
			describe('call of derived events', () => \{
			  test('usage with .map is deprecated', () => \{
			    const a = createEvent()
			    const b = a.map(() => \{\})
			    b()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"call of derived event is deprecated, use createEvent instead"\`,
			    )
			  \})
			  test('usage with .filterMap is deprecated', () => \{
			    const a = createEvent()
			    const b = a.filterMap(() => \{\})
			    b()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"call of derived event is deprecated, use createEvent instead"\`,
			    )
			  \})
			  test('usage with .filter is deprecated', () => \{
			    const a = createEvent()
			    const b = a.filter(\{fn: () => false\})
			    b()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"call of derived event is deprecated, use createEvent instead"\`,
			    )
			  \})
			  test('usage with merge is deprecated', () => \{
			    const a = createEvent()
			    const b = merge([a])
			    b()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"call of derived event is deprecated, use createEvent instead"\`,
			    )
			  \})
			  test('usage with split is deprecated', () => \{
			    const trigger = createEvent<number>()
			    const \{derived\} = split(trigger, \{derived: x => x > 0\})
			    derived(0)
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"call of derived event is deprecated, use createEvent instead"\`,
			    )
			  \})
			  test('usage with sample is deprecated', () => \{
			    const a = createEvent()
			    const b = sample(\{clock: a, source: a\})
			    b()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"call of derived event is deprecated, use createEvent instead"\`,
			    )
			  \})
			  test('usage with guard is deprecated', () => \{
			    const a = createEvent()
			    const b = guard(\{source: a, filter: () => true\})
			    b()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"call of derived event is deprecated, use createEvent instead"\`,
			    )
			  \})
			  describe('interal events', () => \{
			    test('usage with effect.finally is warned', () => \{
			      const fx = createEffect(() => \{\})
			      // @ts-expect-error
			      fx.finally(\{
			        status: "done",
			        params: null,
			        result: null,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"call of derived event is deprecated, use createEvent instead"\`,
			      )
			    \})
			    test('usage with effect.done is warned', () => \{
			      const fx = createEffect(() => \{\})
			      // @ts-expect-error
			      fx.done()
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"call of derived event is deprecated, use createEvent instead"\`,
			      )
			    \})
			    test('usage with effect.fail is warned', () => \{
			      const fx = createEffect(() => \{\})
			      // @ts-expect-error
			      fx.fail()
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"call of derived event is deprecated, use createEvent instead"\`,
			      )
			    \})
			    test('usage with effect.doneData is warned', () => \{
			      const fx = createEffect(() => \{\})
			      fx.doneData()
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"call of derived event is deprecated, use createEvent instead"\`,
			      )
			    \})
			    test('usage with effect.failData is warned', () => \{
			      const fx = createEffect(() => \{\})
			      // @ts-expect-error
			      fx.failData()
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"call of derived event is deprecated, use createEvent instead"\`,
			      )
			    \})
			    test('usage with store.updates is warned', () => \{
			      const \$store = createStore(0)
			      \$store.updates(0)
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"call of derived event is deprecated, use createEvent instead"\`,
			      )
			    \})
			  \})
			\})
			
			test('createApi', () => \{
			  const \$a = createStore(0)
			  const \$derived = \$a.map(x => x)
			  createApi(\$derived, \{x: () => 0\})
			  expect(getWarning()).toMatchInlineSnapshot(
			    \`".on in derived store is deprecated, use .on in store created via createStore instead"\`,
			  )
			\})
			
			describe('.on/.reset with derived stores', () => \{
			  test('.on usage with .map is deprecated', () => \{
			    const trigger = createEvent()
			    const \$a = createStore(0)
			    const \$b = \$a.map(x => x)
			    \$b.on(trigger, x => x)
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`".on in derived store is deprecated, use .on in store created via createStore instead"\`,
			    )
			  \})
			  test('.reset usage with .map is deprecated', () => \{
			    const trigger = createEvent()
			    const \$a = createStore(0)
			    const \$b = \$a.map(x => x)
			    \$b.reset(trigger)
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`".reset in derived store is deprecated, use .reset in store created via createStore instead"\`,
			    )
			  \})
			  test('.on usage with combine is deprecated', () => \{
			    const trigger = createEvent()
			    const \$a = createStore(0)
			    const \$b = combine(\{a: \$a\})
			    \$b.on(trigger, x => x)
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`".on in derived store is deprecated, use .on in store created via createStore instead"\`,
			    )
			  \})
			  test('.reset usage with combine is deprecated', () => \{
			    const trigger = createEvent()
			    const \$a = createStore(0)
			    const \$b = combine(\{a: \$a\})
			    \$b.reset(trigger)
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`".reset in derived store is deprecated, use .reset in store created via createStore instead"\`,
			    )
			  \})
			  describe('internal stores', () => \{
			    test('usage with effect.inFlight is warned', () => \{
			      const trigger = createEvent()
			      const fx = createEffect(() => \{\})
			      fx.inFlight.on(trigger, s => s + 1)
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`".on in derived store is deprecated, use .on in store created via createStore instead"\`,
			      )
			    \})
			  \})
			\})
			
			describe('split cases', () => \{
			  test('with derived store', () => \{
			    const trigger = createEvent<number>()
			    const \$a = createStore(0)
			    const \$derived = \$a.map(x => x)
			    split(\{
			      source: trigger,
			      match: () => 'a',
			      cases: \{
			        a: \$derived,
			      \},
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  test('with derived event', () => \{
			    const trigger = createEvent<number>()
			    const a = createEvent<number>()
			    const derived = a.map(x => x)
			    split(\{
			      source: trigger,
			      match: () => 'a',
			      cases: \{
			        a: derived,
			      \},
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  describe('interal events', () => \{
			    test('usage with effect.finally is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      split(\{
			        source: trigger,
			        match: () => 'a',
			        cases: \{
			          a: fx.finally,
			        \},
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.done is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      split(\{
			        source: trigger,
			        match: () => 'a',
			        cases: \{
			          a: fx.done,
			        \},
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.fail is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      split(\{
			        source: trigger,
			        match: () => 'a',
			        cases: \{
			          a: fx.fail,
			        \},
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.doneData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      split(\{
			        source: trigger,
			        match: () => 'a',
			        cases: \{
			          a: fx.doneData,
			        \},
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.failData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      split(\{
			        source: trigger,
			        match: () => 'a',
			        cases: \{
			          a: fx.failData,
			        \},
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with store.updates is warned', () => \{
			      const trigger = createEvent<any>()
			      const \$store = createStore(0)
			      split(\{
			        source: trigger,
			        match: () => 'a',
			        cases: \{
			          a: \$store.updates,
			        \},
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			  describe('internal stores', () => \{
			    test('usage with effect.inFlight is warned', () => \{
			      const trigger = createEvent<number>()
			      const fx = createEffect(() => \{\})
			      split(\{
			        source: trigger,
			        match: () => 'a',
			        cases: \{
			          a: fx.inFlight,
			        \},
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"split: derived unit in \\\\"cases.a\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			\})
			
			describe('sample target', () => \{
			  test('with derived store', () => \{
			    const trigger = createEvent<number>()
			    const \$a = createStore(0)
			    const \$derived = \$a.map(x => x)
			    sample(\{
			      clock: trigger,
			      target: \$derived,
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  test('with derived event', () => \{
			    const trigger = createEvent<number>()
			    const a = createEvent<number>()
			    const derived = a.map(x => x)
			    sample(\{
			      clock: trigger,
			      target: derived,
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  describe('interal events', () => \{
			    test('usage with effect.finally is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      sample(\{
			        clock: trigger,
			        target: fx.finally,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.done is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      sample(\{
			        clock: trigger,
			        target: fx.done,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.fail is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      sample(\{
			        clock: trigger,
			        target: fx.fail,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.doneData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      sample(\{
			        clock: trigger,
			        target: fx.doneData,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.failData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      sample(\{
			        clock: trigger,
			        target: fx.failData,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with store.updates is warned', () => \{
			      const trigger = createEvent<any>()
			      const \$store = createStore(0)
			      sample(\{
			        clock: trigger,
			        target: \$store.updates,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			  describe('internal stores', () => \{
			    test('usage with effect.inFlight is warned', () => \{
			      const trigger = createEvent<number>()
			      const fx = createEffect(() => \{\})
			      sample(\{
			        clock: trigger,
			        target: fx.inFlight,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"sample: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			\})
			
			describe('guard target', () => \{
			  test('with derived store', () => \{
			    const trigger = createEvent<number>()
			    const \$a = createStore(0)
			    const \$derived = \$a.map(x => x)
			    guard(\{
			      clock: trigger,
			      filter: () => true,
			      target: \$derived,
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  test('with derived event', () => \{
			    const trigger = createEvent<number>()
			    const a = createEvent<number>()
			    const derived = a.map(x => x)
			    guard(\{
			      clock: trigger,
			      filter: () => true,
			      target: derived,
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  describe('interal events', () => \{
			    test('usage with effect.finally is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      guard(\{
			        clock: trigger,
			        filter: () => true,
			        target: fx.finally,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.done is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      guard(\{
			        clock: trigger,
			        filter: () => true,
			        target: fx.done,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.fail is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      guard(\{
			        clock: trigger,
			        filter: () => true,
			        target: fx.fail,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.doneData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      guard(\{
			        clock: trigger,
			        filter: () => true,
			        target: fx.doneData,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.failData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      guard(\{
			        clock: trigger,
			        filter: () => true,
			        target: fx.failData,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with store.updates is warned', () => \{
			      const trigger = createEvent<any>()
			      const \$store = createStore(0)
			      guard(\{
			        clock: trigger,
			        filter: () => true,
			        target: \$store.updates,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			  describe('internal stores', () => \{
			    test('usage with effect.inFlight is warned', () => \{
			      const trigger = createEvent<number>()
			      const fx = createEffect(() => \{\})
			      guard(\{
			        clock: trigger,
			        filter: () => true,
			        target: fx.inFlight,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"guard: derived unit in \\\\"target\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			\})
			
			describe('forward to', () => \{
			  test('with derived store', () => \{
			    const trigger = createEvent<number>()
			    const \$a = createStore(0)
			    const \$derived = \$a.map(x => x)
			    forward(\{
			      from: trigger,
			      to: \$derived,
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  test('with derived event', () => \{
			    const trigger = createEvent<number>()
			    const a = createEvent<number>()
			    const derived = a.map(x => x)
			    forward(\{
			      from: trigger,
			      to: derived,
			    \})
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			    )
			  \})
			  describe('interal events', () => \{
			    test('usage with effect.finally is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      forward(\{
			        from: trigger,
			        to: fx.finally,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.done is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      forward(\{
			        from: trigger,
			        to: fx.done,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.fail is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      forward(\{
			        from: trigger,
			        to: fx.fail,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.doneData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      forward(\{
			        from: trigger,
			        to: fx.doneData,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with effect.failData is warned', () => \{
			      const trigger = createEvent<any>()
			      const fx = createEffect(() => \{\})
			      forward(\{
			        from: trigger,
			        to: fx.failData,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			    test('usage with store.updates is warned', () => \{
			      const trigger = createEvent<any>()
			      const \$store = createStore(0)
			      forward(\{
			        from: trigger,
			        to: \$store.updates,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			  describe('internal stores', () => \{
			    test('usage with effect.inFlight is warned', () => \{
			      const trigger = createEvent<number>()
			      const fx = createEffect(() => \{\})
			      forward(\{
			        from: trigger,
			        to: fx.inFlight,
			      \})
			      expect(getWarning()).toMatchInlineSnapshot(
			        \`"forward: derived unit in \\\\"to\\\\" is deprecated, use createEvent/createStore instead"\`,
			      )
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\derived.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(55)
    });
    it('effector_effector\\src\\effector\\__tests__\\domain.test.ts', () => {
        const sourceCode = `
			import \{
			  createDomain,
			  clearNode,
			  createStore,
			  createEvent,
			  createEffect,
			  createApi,
			  restore,
			  attach,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('domain hooks', () => \{
			  test('domain.onCreateEvent(fn)', () => \{
			    const fn = jest.fn()
			    const dom = createDomain()
			    dom.createEvent()
			    const unsub = dom.onCreateEvent(e => fn(e))
			    expect(fn).toHaveBeenCalled()
			    const e2 = dom.createEvent()
			    expect(fn).toHaveBeenLastCalledWith(e2)
			    createEvent()
			    expect(fn).toHaveBeenCalledTimes(2)
			    const e4 = dom.createEvent()
			    expect(fn).toHaveBeenLastCalledWith(e4)
			    expect(fn).toHaveBeenCalledTimes(3)
			    expect(() => \{
			      unsub()
			    \}).not.toThrow()
			    dom.createEvent()
			    expect(fn).toHaveBeenCalledTimes(3)
			  \})
			
			  test('domain.onCreateEffect(fn)', () => \{
			    const fn = jest.fn()
			    const dom = createDomain()
			    dom.createEffect()
			    const unsub = dom.onCreateEffect(e => fn(e))
			    expect(fn).toHaveBeenCalled()
			    const e2 = dom.createEffect()
			    expect(fn).toHaveBeenLastCalledWith(e2)
			    createEffect()
			    expect(fn).toHaveBeenCalledTimes(2)
			    const e4 = dom.createEffect()
			    expect(fn).toHaveBeenLastCalledWith(e4)
			    expect(fn).toHaveBeenCalledTimes(3)
			    expect(() => \{
			      unsub()
			    \}).not.toThrow()
			    dom.createEffect()
			    expect(fn).toHaveBeenCalledTimes(3)
			  \})
			
			  test('nested domains', () => \{
			    const spyDom = jest.fn()
			    const spySub = jest.fn()
			    const dom = createDomain()
			    const subdom = dom.createDomain()
			    dom.onCreateEvent(e => spyDom(e))
			    subdom.onCreateEvent(e => spySub(e))
			    const e1 = dom.createEvent()
			    expect(spyDom).toHaveBeenLastCalledWith(e1)
			    expect(spySub).not.toHaveBeenCalled()
			    const e2 = subdom.createEvent()
			    expect(spyDom).toHaveBeenLastCalledWith(e2)
			    expect(spySub).toHaveBeenLastCalledWith(e2)
			  \})
			  test('create* aliases', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateEvent(fn)
			    domain.onCreateEffect(fn)
			    domain.onCreateStore(fn)
			    domain.onCreateDomain(fn)
			    const event = domain.createEvent()
			    const effect = domain.createEffect()
			    const store = domain.createStore(null)
			    const subdomain = domain.createDomain()
			    expect(argumentHistory(fn)).toEqual([event, effect, store, subdomain])
			  \})
			\})
			
			describe('domain name', () => \{
			  test("should return it's own name on domain.getType()", () => \{
			    expect(createDomain('foo').getType()).toBe('foo')
			  \})
			  test('subdomains should has full path in name', () => \{
			    const domain = createDomain('dom')
			    const subdomain = domain.createDomain('subdom')
			    expect(domain.createDomain('foo').getType()).toBe('dom/foo')
			    expect(subdomain.createDomain('bar').getType()).toBe('dom/subdom/bar')
			  \})
			  test('empty domain name should be skipped', () => \{
			    const domain = createDomain('')
			    const subdomain = domain.createDomain('subdom')
			    expect(domain.createDomain('foo').getType()).toBe('foo')
			    expect(subdomain.createDomain('bar').getType()).toBe('subdom/bar')
			  \})
			  describe('empty name support', () => \{
			    test(
			      'createDomain() should' + ' create domain with empty string used as name',
			      () => \{
			        //eslint-disable-next-line max-len
			        expect(createDomain().getType()).toBeDefined()
			        expect(createDomain().getType()).toBe('')
			      \},
			    )
			    test('domain.createDomain() should fallback to parent domain name', () => \{
			      const domain = createDomain('dom')
			      expect(domain.createDomain().getType()).toBeDefined()
			      expect(domain.createDomain().getType()).not.toBe('')
			      expect(domain.createDomain().getType()).toBe('dom')
			      expect(domain.createEffect().getType()).not.toBe('dom/')
			    \})
			  \})
			\})
			describe('config', () => \{
			  test('domain.createEffect(config)', async () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const fx = domain.createEffect(\{
			      name: 'fx1',
			      handler: fn,
			    \})
			    await fx('payload')
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "payload",
			      ]
			    \`)
			  \})
			\})
			describe('domain ownership', () => \{
			  test('reference example', () => \{
			    const fn = jest.fn()
			    const add = createEvent()
			    const source = createStore([]).on(add, (list, item) => [...list, item])
			    const mappedA = source.map(list => list.length)
			    const mappedB = source.map(list => list.length)
			    mappedA.watch(e => fn(e))
			    add('a')
			    clearNode(mappedB)
			    add('b')
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			        2,
			      ]
			    \`)
			  \})
			  test('edge case with domains', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const add = domain.createEvent()
			    const source = domain
			      .createStore([])
			      .on(add, (list, item) => [...list, item])
			    const mappedA = source.map(list => list.length)
			    const mappedB = source.map(list => list.length)
			    mappedA.watch(e => fn(e))
			    add('a')
			    clearNode(mappedB)
			    add('b')
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			        2,
			      ]
			    \`)
			  \})
			  test('clearNode(domain) should work as usual', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    const add = domain.createEvent()
			    const source = domain
			      .createStore([])
			      .on(add, (list, item) => [...list, item])
			    const mappedA = source.map(list => list.length)
			    source.map(list => list.length)
			    mappedA.watch(e => fn(e))
			    add('a')
			    clearNode(domain)
			    add('b')
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			      ]
			    \`)
			  \})
			  test('domain should own its hooks', () => \{
			    const domain = createDomain()
			    clearNode(domain)
			    //this mean onCreateEvent hook will be erased together with domain itself
			    expect(domain.hooks.event.graphite.scope).toBe(null)
			  \})
			\})
			
			describe('indirect child support', () => \{
			  it('support createApi', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateEvent(e => fn(e))
			    const position = domain.createStore(0)
			    const \{moveLeft, moveRight\} = createApi(position, \{
			      moveLeft: x => x - 1,
			      moveRight: x => x + 1,
			    \})
			    expect(argumentHistory(fn)).toEqual([moveLeft, moveRight])
			  \})
			  it('support restore', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateStore(e => fn(e))
			    const source = domain.createEvent()
			    const store = restore(source, null)
			    expect(argumentHistory(fn)).toEqual([store])
			  \})
			  it('support prepend', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateEvent(e => fn(e))
			    const source = domain.createEvent()
			    const prepended = source.prepend(() => \{\})
			    expect(argumentHistory(fn)).toEqual([source, prepended])
			  \})
			  describe('support attach', () => \{
			    test('with source', () => \{
			      const fn = jest.fn()
			      const domain = createDomain()
			      domain.onCreateEffect(e => fn(e))
			      const source = domain.createStore(null)
			      const fx = domain.createEffect()
			      const attached = attach(\{
			        source,
			        effect: fx,
			        mapParams: _ => _,
			      \})
			      expect(argumentHistory(fn)).toEqual([fx, attached])
			    \})
			    test('without source', () => \{
			      const fn = jest.fn()
			      const domain = createDomain()
			      domain.onCreateEffect(e => fn(e))
			      const fx = domain.createEffect()
			      const attached = attach(\{
			        effect: fx,
			        mapParams: _ => _,
			      \})
			      expect(argumentHistory(fn)).toEqual([fx, attached])
			    \})
			  \})
			\})
			
			test('parent assignment', () => \{
			  const fn = jest.fn()
			  const domain = createDomain()
			  domain.onCreateEffect(fx => \{
			    domain.hooks.event(fx.doneData)
			  \})
			  domain.onCreateStore(store => \{
			    fn(store.shortName)
			  \})
			  const fx = domain.createEffect()
			  const store = restore(fx.doneData, \{\})
			  expect(argumentHistory(fn)).toEqual(['store'])
			\})
			
			describe('pass domain into creator', () => \{
			  test('createStore is the same instance', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateStore(fn)
			
			    const \$store = createStore(0, \{domain\})
			
			    expect(fn).toBeCalledWith(\$store)
			  \})
			  test('createStore correctly passed into hook', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateStore(store => store.updates.watch(fn))
			
			    const run = createEvent<number>()
			    const \$store = createStore(0, \{domain\})
			    \$store.on(run, (_, i) => i)
			    run(2)
			
			    expect(fn).toHaveBeenCalledTimes(1)
			    expect(fn).toBeCalledWith(2)
			  \})
			  test('createEvent correctly passed into hook', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateEvent(fn)
			
			    const event = createEvent(\{domain\})
			
			    expect(fn).toHaveBeenCalledTimes(1)
			  \})
			  test('createEffect correctly passed into hook', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateEffect(fn)
			
			    const effect = createEffect(\{domain\})
			
			    expect(fn).toHaveBeenCalledTimes(1)
			  \})
			  test('createDomain correctly passed into hook', () => \{
			    const fn = jest.fn()
			    const domain = createDomain()
			    domain.onCreateDomain(fn)
			
			    const another = createDomain(\{domain\})
			
			    expect(fn).toHaveBeenCalledTimes(1)
			  \})
			  test('unit in nested domains triggers correctly', () => \{
			    const fn = jest.fn()
			    const d1 = createDomain()
			    d1.onCreateStore(fn)
			    const d2 = createDomain(\{domain: d1\})
			    d2.onCreateStore(fn)
			    const d3 = createDomain(\{domain: d2\})
			    d3.onCreateStore(fn)
			
			    const \$store = createStore(0, \{domain: d3\})
			
			    expect(fn).toHaveBeenCalledTimes(3)
			  \})
			
			  test('unit made from two domains should select indirect one', () => \{
			    const directFn = jest.fn()
			    const direct = createDomain()
			    direct.onCreateStore(directFn)
			
			    const indirectFn = jest.fn()
			    const indirect = createDomain()
			    indirect.onCreateStore(indirectFn)
			
			    // @ts-expect-error There is no types for case, just runtime check
			    const \$unit = direct.createStore(0, \{domain: indirect\})
			
			    expect(directFn).not.toHaveBeenCalled()
			    expect(indirectFn).toHaveBeenCalledTimes(1)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\domain.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(27)
    });
    it('effector_effector\\src\\effector\\__tests__\\effect\\di.test.ts', () => {
        const sourceCode = `
			import \{createEffect\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('effect.create single argument', async () => \{
			  const effect = createEffect()
			  effect.use(async () => \{
			    await 1
			    return 'done!'
			  \})
			  //@ts-expect-error
			  const oldCreate = effect.create
			  //@ts-expect-error
			  effect.create = jest.fn((payload, args) => oldCreate(payload, args))
			  const baz = jest.fn()
			  effect.done.watch(baz)
			
			  await effect(100)
			  await effect(200)
			  await effect(300)
			
			  //@ts-expect-error
			  expect(effect.create.mock.calls).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        100,
			        Array [],
			      ],
			      Array [
			        200,
			        Array [],
			      ],
			      Array [
			        300,
			        Array [],
			      ],
			    ]
			  \`)
			  expect(argumentHistory(baz)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "params": 100,
			        "result": "done!",
			      \},
			      Object \{
			        "params": 200,
			        "result": "done!",
			      \},
			      Object \{
			        "params": 300,
			        "result": "done!",
			      \},
			    ]
			  \`)
			\})
			
			function variadicEffect(name?: string) \{
			  const effect = createEffect<any, any>(name)
			  //@ts-expect-error
			  const oldCreate = effect.create
			  //@ts-expect-error
			  effect.create = jest.fn((payload, args) => oldCreate([payload, ...args], []))
			  const oldUse = effect.use
			  //@ts-expect-error
			  effect.use = handler => oldUse(payload => handler(...payload))
			
			  return effect as any
			\}
			
			test('effect.create multiple arguments', async () => \{
			  const useSpy = jest.fn()
			  const baz = jest.fn()
			  const effect = variadicEffect('long request')
			
			  //@ts-expect-error
			  effect.use(async (a, b) => \{
			    useSpy(\{a, b\})
			    await 1
			    return 'done!'
			  \})
			  effect.done.watch(baz)
			
			  await effect(100, 200)
			  await effect(200, 300)
			  await effect(300, 400)
			
			  expect(effect.create.mock.calls).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        100,
			        Array [
			          200,
			        ],
			      ],
			      Array [
			        200,
			        Array [
			          300,
			        ],
			      ],
			      Array [
			        300,
			        Array [
			          400,
			        ],
			      ],
			    ]
			  \`)
			  expect(argumentHistory(useSpy)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "a": 100,
			        "b": 200,
			      \},
			      Object \{
			        "a": 200,
			        "b": 300,
			      \},
			      Object \{
			        "a": 300,
			        "b": 400,
			      \},
			    ]
			  \`)
			  expect(argumentHistory(baz)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "params": Array [
			          100,
			          200,
			        ],
			        "result": "done!",
			      \},
			      Object \{
			        "params": Array [
			          200,
			          300,
			        ],
			        "result": "done!",
			      \},
			      Object \{
			        "params": Array [
			          300,
			          400,
			        ],
			        "result": "done!",
			      \},
			    ]
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\effect\\di.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\effector\\__tests__\\effect\\fxID.test.ts', () => {
        const sourceCode = `
			import \{
			  attach,
			  sample,
			  createEvent,
			  createEffect,
			  Unit,
			  Node,
			  step,
			  allSettled,
			  fork,
			\} from 'effector'
			
			function getNode(unit: Unit<any>): Node \{
			  //@ts-expect-error
			  return unit.graphite || unit
			\}
			
			describe('plain effect support', () => \{
			  test('fxID in fx seq', async () => \{
			    const fx = createEffect(() => \{\})
			    let fxID: any
			    getNode(fx).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          fxID = stack.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await fx()
			    expect(typeof fxID).toBe('string')
			  \})
			  test('fxID in fx.finally seq', async () => \{
			    const fx = createEffect(() => \{\})
			    let fxID: any
			    getNode(fx.finally).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          fxID = stack.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await fx()
			    expect(typeof fxID).toBe('string')
			  \})
			  test('fxID in fx.done seq', async () => \{
			    const fx = createEffect(() => \{\})
			    let fxID: any
			    getNode(fx.done).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          const finallyStack = stack.parent?.parent
			          fxID = finallyStack?.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await fx()
			    expect(typeof fxID).toBe('string')
			  \})
			  test('fxID in fx.doneData seq', async () => \{
			    const fx = createEffect(() => \{\})
			    let fxID: any
			    getNode(fx.doneData).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          const doneStack = stack.parent?.parent
			          const finallyStack = doneStack?.parent?.parent
			          fxID = finallyStack?.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await fx()
			    expect(typeof fxID).toBe('string')
			  \})
			\})
			
			describe('attach support', () => \{
			  describe('attached effect', () => \{
			    test('fxID in fx seq', async () => \{
			      const fx = attach(\{effect: createEffect(() => \{\})\})
			      let fxID: any
			      getNode(fx).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            fxID = stack.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await fx()
			      expect(typeof fxID).toBe('string')
			    \})
			    test('fxID in fx.finally seq', async () => \{
			      const fx = attach(\{effect: createEffect(() => \{\})\})
			      let fxID: any
			      getNode(fx.finally).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            fxID = stack.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await fx()
			      expect(typeof fxID).toBe('string')
			    \})
			    test('fxID in fx.done seq', async () => \{
			      const fx = attach(\{effect: createEffect(() => \{\})\})
			      let fxID: any
			      getNode(fx.done).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            const finallyStack = stack.parent?.parent
			            fxID = finallyStack?.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await fx()
			      expect(typeof fxID).toBe('string')
			    \})
			    test('fxID in fx.doneData seq', async () => \{
			      const fx = attach(\{effect: createEffect(() => \{\})\})
			      let fxID: any
			      getNode(fx.doneData).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            const doneStack = stack.parent?.parent
			            const finallyStack = doneStack?.parent?.parent
			            fxID = finallyStack?.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await fx()
			      expect(typeof fxID).toBe('string')
			    \})
			  \})
			  describe('inner effect', () => \{
			    test('fxID in fx seq', async () => \{
			      const fx = createEffect(() => \{\})
			      const attached = attach(\{effect: fx\})
			      let fxID: any
			      getNode(fx).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            fxID = stack.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await attached()
			      expect(typeof fxID).toBe('string')
			    \})
			    test('fxID in fx.finally seq', async () => \{
			      const fx = createEffect(() => \{\})
			      const attached = attach(\{effect: fx\})
			      let fxID: any
			      getNode(fx.finally).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            fxID = stack.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await attached()
			      expect(typeof fxID).toBe('string')
			    \})
			    test('fxID in fx.done seq', async () => \{
			      const fx = createEffect(() => \{\})
			      const attached = attach(\{effect: fx\})
			      let fxID: any
			      getNode(fx.done).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            const finallyStack = stack.parent?.parent
			            fxID = finallyStack?.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await attached()
			      expect(typeof fxID).toBe('string')
			    \})
			    test('fxID in fx.doneData seq', async () => \{
			      const fx = createEffect(() => \{\})
			      const attached = attach(\{effect: fx\})
			      let fxID: any
			      getNode(fx.doneData).seq.push(
			        step.compute(\{
			          fn(data, _, stack) \{
			            const doneStack = stack.parent?.parent
			            const finallyStack = doneStack?.parent?.parent
			            fxID = finallyStack?.meta?.fxID
			            return data
			          \},
			        \}),
			      )
			      await attached()
			      expect(typeof fxID).toBe('string')
			    \})
			  \})
			\})
			
			describe('computation chain support', () => \{
			  test('fxID in fx seq', async () => \{
			    const trigger = createEvent()
			    const fx = createEffect(() => \{\})
			    sample(\{clock: trigger, target: fx\})
			    let fxID: any
			    getNode(fx).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          fxID = stack.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await allSettled(trigger, \{scope: fork()\})
			    expect(typeof fxID).toBe('string')
			  \})
			  test('fxID in fx.finally seq', async () => \{
			    const trigger = createEvent()
			    const fx = createEffect(() => \{\})
			    sample(\{clock: trigger, target: fx\})
			    let fxID: any
			    getNode(fx.finally).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          fxID = stack.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await allSettled(trigger, \{scope: fork()\})
			    expect(typeof fxID).toBe('string')
			  \})
			  test('fxID in fx.done seq', async () => \{
			    const trigger = createEvent()
			    const fx = createEffect(() => \{\})
			    sample(\{clock: trigger, target: fx\})
			    let fxID: any
			    getNode(fx.done).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          const finallyStack = stack.parent?.parent
			          fxID = finallyStack?.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await allSettled(trigger, \{scope: fork()\})
			    expect(typeof fxID).toBe('string')
			  \})
			  test('fxID in fx.doneData seq', async () => \{
			    const trigger = createEvent()
			    const fx = createEffect(() => \{\})
			    sample(\{clock: trigger, target: fx\})
			    let fxID: any
			    getNode(fx.doneData).seq.push(
			      step.compute(\{
			        fn(data, _, stack) \{
			          const doneStack = stack.parent?.parent
			          const finallyStack = doneStack?.parent?.parent
			          fxID = finallyStack?.meta?.fxID
			          return data
			        \},
			      \}),
			    )
			    await allSettled(trigger, \{scope: fork()\})
			    expect(typeof fxID).toBe('string')
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\effect\\fxID.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(16)
    });
    it('effector_effector\\src\\effector\\__tests__\\effect\\index.test.ts', () => {
        const sourceCode = `
			import \{
			  createEffect,
			  createEvent,
			  createStore,
			  combine,
			  forward,
			  restore,
			  Unit,
			  Node,
			  step,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('createEffect(handler) support', () => \{
			  test('with babel plugin', async () => \{
			    const fx = createEffect(async (str: string) => str.length)
			    await expect(fx('ok')).resolves.toBe(2)
			    expect(fx.shortName).toBe('fx')
			  \})
			  test('without babel plugin', async () => \{
			    const fx = \{_: createEffect\}._(async (str: string) => str.length)
			    await expect(fx('ok')).resolves.toBe(2)
			  \})
			\})
			describe('effect(\{...\})', () => \{
			  test(\`if used function will resolve\`, async () => \{
			    const fn = jest.fn()
			    const effect = createEffect()
			    effect.use(async params => \{
			      fn(params)
			      return 'done!'
			    \})
			    await expect(effect('ok')).resolves.toBe('done!')
			  \})
			
			  test('if used function will throw', async () => \{
			    const fn = jest.fn()
			    const effect = createEffect()
			    effect.use(async params => \{
			      fn(params)
			      throw 'fail!'
			    \})
			    //eslint-disable-next-line max-len
			    await expect(effect('will throw')).rejects.toBe('fail!')
			  \})
			\})
			
			describe('future', () => \{
			  test(\`if used function will resolve\`, async () => \{
			    const fn = jest.fn()
			    const effect = createEffect()
			    effect.use(async params => \{
			      fn(params)
			      return 'done!'
			    \})
			    await expect(effect('ok')).resolves.toBe('done!')
			  \})
			
			  test('if used function will throw', async () => \{
			    const fn = jest.fn()
			    const effect = createEffect()
			    effect.use(async params => \{
			      fn(params)
			      throw 'fail!'
			    \})
			    await expect(effect('will throw')).rejects.toBe('fail!')
			  \})
			\})
			
			describe('effect.finally', () => \{
			  test(\`if used function will resolve\`, async () => \{
			    const fn = jest.fn()
			    const effect = createEffect(\{
			      async handler(\{fail\}) \{
			        if (fail) throw Error('[expected error]')
			        return 'done!'
			      \},
			    \})
			    effect.finally.watch(e => fn(e))
			    await effect(\{fail: false\})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "params": Object \{
			            "fail": false,
			          \},
			          "result": "done!",
			          "status": "done",
			        \},
			      ]
			    \`)
			  \})
			
			  test('if used function will throw', async () => \{
			    const fn = jest.fn()
			    const effect = createEffect(\{
			      async handler(\{fail\}) \{
			        if (fail) throw Error('[expected error]')
			        return 'done!'
			      \},
			    \})
			    effect.finally.watch(e => fn(e))
			    await effect(\{fail: true\}).catch(() => \{\})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "error": [Error: [expected error]],
			          "params": Object \{
			            "fail": true,
			          \},
			          "status": "fail",
			        \},
			      ]
			    \`)
			  \})
			\})
			test('effect without handler should throw an error during a call', async () => \{
			  const effect = createEffect()
			  await expect(effect('ok')).rejects.toThrowErrorMatchingInlineSnapshot(
			    \`"no handler used in effect"\`,
			  )
			\})
			describe('createEffect with config', () => \{
			  it('supports empty config as second argument', async () => \{
			    const effect = createEffect('fx without handler', \{\})
			    await expect(effect('ok')).rejects.toThrowErrorMatchingInlineSnapshot(
			      \`"no handler used in fx without handler"\`,
			    )
			  \})
			  it('supports default handler with config', async () => \{
			    const fn = jest.fn()
			    const effect = createEffect('long request', \{
			      async handler(params) \{
			        fn(params)
			        return 'done!'
			      \},
			    \})
			    await expect(effect('ok')).resolves.toBe('done!')
			  \})
			  it('supports default handler without name', async () => \{
			    const fn = jest.fn()
			    const effect = createEffect(\{
			      async handler(params) \{
			        fn(params)
			        return 'done!'
			      \},
			    \})
			    await expect(effect('ok')).resolves.toBe('done!')
			  \})
			\})
			
			it('should return itself at .use call', () => \{
			  const effect = createEffect()
			  expect(effect.use(() => 'done!')).toBe(effect)
			\})
			
			it('should handle both done and error in .finally', async () => \{
			  const fn = jest.fn()
			  const effect = createEffect(\{
			    async handler(params) \{
			      if (params === 'bar') throw Error('error')
			      return 'done!'
			    \},
			  \})
			  effect.finally.watch(params => fn(params))
			  await effect('foo').catch(() => \{\})
			  await effect('bar').catch(() => \{\})
			  expect(fn).toHaveBeenCalledTimes(2)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "params": "foo",
			        "result": "done!",
			        "status": "done",
			      \},
			      Object \{
			        "error": [Error: error],
			        "params": "bar",
			        "status": "fail",
			      \},
			    ]
			  \`)
			\})
			
			test('effect.doneData', async () => \{
			  const fn = jest.fn()
			  const fx = createEffect(\{
			    handler: () => 'result',
			  \})
			  fx.doneData.watch(fn)
			  await fx()
			  expect(argumentHistory(fn)).toEqual(['result'])
			\})
			test('effect.failData', async () => \{
			  const fn = jest.fn()
			  const fx = createEffect(\{
			    handler() \{
			      throw 'error'
			    \},
			  \})
			  fx.failData.watch(fn)
			  await fx().catch(() => \{\})
			  expect(argumentHistory(fn)).toEqual(['error'])
			\})
			
			test('effect.pending is a boolean store', async () => \{
			  const fn = jest.fn()
			  const fx = createEffect(\{
			    async handler() \{\},
			  \})
			  fx.pending.watch(fn)
			  await fx()
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      false,
			      true,
			      false,
			    ]
			  \`)
			\})
			
			it('should support forward', async () => \{
			  const fnHandler = jest.fn()
			  const fnWatcher = jest.fn()
			  const fetchData = createEffect(\{
			    async handler() \{
			      return 'fetchData result'
			    \},
			  \})
			
			  const logRequest = createEffect(\{
			    async handler(payload) \{
			      fnHandler(payload)
			      return 'logRequest result'
			    \},
			  \})
			
			  logRequest.done.watch(d => \{
			    fnWatcher(d)
			  \})
			
			  forward(\{
			    from: fetchData,
			    to: logRequest,
			  \})
			
			  await fetchData(\{url: 'xxx'\})
			  expect(argumentHistory(fnHandler)).toEqual([\{url: 'xxx'\}])
			  expect(argumentHistory(fnWatcher)).toEqual([
			    \{params: \{url: 'xxx'\}, result: 'logRequest result'\},
			  ])
			\})
			
			describe('execution order', () => \{
			  it('should run watchers and promise resolvers in order', async () => \{
			    const fn = jest.fn()
			    const fx = createEffect(\{
			      handler() \{
			        fn('handler')
			      \},
			    \})
			    fx.watch(() => \{
			      fn('start')
			    \})
			    fx.done.watch(() => \{
			      fn('done')
			    \})
			    fx.doneData.watch(() => \{
			      fn('doneData')
			    \})
			    fx.finally.watch(() => \{
			      fn('finally')
			    \})
			    fx.inFlight.updates.watch(n => \{
			      fn(\`inFlight \$\{n\}\`)
			    \})
			    fx.pending.updates.watch(pending => \{
			      fn(\`pending \$\{pending\}\`)
			    \})
			    await fx().then(() => \{
			      fn('promise resolver')
			    \})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "start",
			        "inFlight 1",
			        "pending true",
			        "handler",
			        "finally",
			        "done",
			        "doneData",
			        "inFlight 0",
			        "pending false",
			        "promise resolver",
			      ]
			    \`)
			  \})
			  it('should run watchers and promise resolvers in order (async)', async () => \{
			    const fn = jest.fn()
			    const fx = createEffect(\{
			      async handler() \{
			        fn('handler')
			      \},
			    \})
			    fx.watch(() => \{
			      fn('start')
			    \})
			    fx.done.watch(() => \{
			      fn('done')
			    \})
			    fx.doneData.watch(() => \{
			      fn('doneData')
			    \})
			    fx.finally.watch(() => \{
			      fn('finally')
			    \})
			    fx.inFlight.updates.watch(n => \{
			      fn(\`inFlight \$\{n\}\`)
			    \})
			    fx.pending.updates.watch(pending => \{
			      fn(\`pending \$\{pending\}\`)
			    \})
			    await fx().then(() => \{
			      fn('promise resolver')
			    \})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "start",
			        "inFlight 1",
			        "pending true",
			        "handler",
			        "finally",
			        "done",
			        "doneData",
			        "inFlight 0",
			        "pending false",
			        "promise resolver",
			      ]
			    \`)
			  \})
			  it('should run both .done and .finally at the same tick', async () => \{
			    const fn = jest.fn()
			    const fx = createEffect(\{
			      async handler() \{
			        return 'ok'
			      \},
			    \})
			    const a = restore(fx.finally, null)
			    const b = restore(fx.done, null)
			    const sum = combine(\{a, b\})
			    sum.watch(fn)
			    await fx(null)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			          Array [
			            Object \{
			              "a": null,
			              "b": null,
			            \},
			            Object \{
			              "a": Object \{
			                "params": null,
			                "result": "ok",
			                "status": "done",
			              \},
			              "b": Object \{
			                "params": null,
			                "result": "ok",
			              \},
			            \},
			          ]
			      \`)
			  \})
			
			  it('handle sync effect watchers in correct order', async () => \{
			    const fn = jest.fn()
			    const eff = createEffect(\{
			      handler: () => [1, 2, 3],
			    \})
			
			    eff.watch(e => fn(e))
			    eff.done.watch(e => fn(e))
			    await eff('run')
			    expect(argumentHistory(fn)).toEqual([
			      'run',
			      \{params: 'run', result: [1, 2, 3]\},
			    ])
			  \})
			
			  it('should not override sync event updates', async () => \{
			    const fn = jest.fn()
			    const uppercase = createEvent()
			
			    const fx = createEffect(\{
			      handler() \{
			        uppercase()
			      \},
			    \})
			    const user = createStore('alice')
			      .on(uppercase, user => user.toUpperCase())
			      .on(fx, (_, user) => user)
			    user.watch(user => fn(user))
			
			    await fx('bob')
			    expect(argumentHistory(fn)).toEqual(['alice', 'bob', 'BOB'])
			  \})
			
			  test('effect.pending becomes false only after all concurrent requests will be settled', async () => \{
			    const fx = createEffect()
			
			    expect(fx.pending.getState()).toBe(false)
			
			    fx.use(() => new Promise(rs => setTimeout(rs, 50)))
			    const req1 = fx()
			    expect(fx.pending.getState()).toBe(true)
			    fx.use(() => new Promise(rs => setTimeout(rs, 100)))
			    const req2 = fx()
			    await req1
			    expect(fx.pending.getState()).toBe(true)
			    await req2
			    expect(fx.pending.getState()).toBe(false)
			  \})
			\})
			
			it('should validate .use argument', () => \{
			  expect(() => \{
			    createEffect().use(null)
			  \}).toThrowErrorMatchingInlineSnapshot(\`".use argument should be a function"\`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\effect\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(25)
    });
    it('effector_effector\\src\\effector\\__tests__\\effect\\name.test.ts', () => {
        const sourceCode = `
			import \{createEffect, createDomain\} from 'effector'
			
			test("should return it's own name on effect.getType()", () => \{
			  expect(createEffect('foo').getType()).toBe('foo')
			  expect(createEffect('foo', \{name: 'bar'\}).getType()).toBe('foo')
			  expect(createEffect(\{name: 'foo'\}).getType()).toBe('foo')
			  expect(createEffect(\{handler: () => 'done!', name: 'foo'\}).getType()).toBe(
			    'foo',
			  )
			  expect(createEffect(\{handler: () => 'done!'\}, \{name: 'foo'\}).getType()).toBe(
			    'foo',
			  )
			  expect(
			    createEffect(
			      \{handler: () => 'done!', name: 'foo'\},
			      \{name: 'bar'\},
			    ).getType(),
			  ).toBe('foo')
			\})
			test('effect from domains should has full path in name', () => \{
			  const domain = createDomain('dom')
			  const subdomain = domain.createDomain('subdom')
			  expect(domain.createEffect('foo').getType()).toBe('dom/foo')
			  expect(subdomain.createEffect('bar').getType()).toBe('dom/subdom/bar')
			\})
			test('empty domain name should be skipped', () => \{
			  const domain = createDomain('')
			  const subdomain = domain.createDomain('subdom')
			  expect(domain.createEffect('foo').getType()).toBe('foo')
			  expect(domain.createEffect('foo').done.getType()).toBe('done')
			  expect(domain.createEffect('foo').fail.getType()).toBe('fail')
			  expect(subdomain.createEffect('bar').getType()).toBe('subdom/bar')
			\})
			describe('empty name support', () => \{
			  //eslint-disable-next-line max-len
			  test('createEffect() should create effect with string id used as name', () => \{
			    expect(createEffect().getType()).not.toBe(undefined)
			    expect(createEffect().getType()).not.toBe('')
			  \})
			  test('domain.createEffect() should not fallback to domain name', () => \{
			    const domain = createDomain('dom')
			    expect(domain.createEffect().getType()).not.toBe(undefined)
			    expect(domain.createEffect().getType()).not.toBe('')
			    expect(domain.createEffect().getType()).not.toBe('dom')
			    expect(domain.createEffect().getType()).not.toBe('dom/')
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\effect\\name.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('effector_effector\\src\\effector\\__tests__\\effector.test.ts', () => {
        const sourceCode = `
			import \{
			  allSettled,
			  combine,
			  createDomain,
			  createEvent,
			  createStore,
			  fork,
			\} from 'effector'
			
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('will run in expected order', () => \{
			  const fn = jest.fn()
			  const reset = createEvent()
			  const add = createEvent()
			  const mult = createEvent()
			  const listSize = createStore(3)
			    .on(add, (n, nn) => n + nn)
			    .on(mult, (n, q) => n * q)
			    .reset(reset)
			
			  const currentList = createStore([])
			    .on(add, (list, pl) => [...list, \{add: pl\}])
			    .on(mult, (list, pl) => [...list, \{mult: pl\}])
			    .reset(reset)
			  const selected = createStore([])
			
			  combine(\{listSize, currentList, selected\})
			
			  const unsub = currentList.subscribe(state => fn(state))
			  add(5)
			  mult(4)
			  unsub()
			  // halt()
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Array [],
			      Array [
			        Object \{
			          "add": 5,
			        \},
			      ],
			      Array [
			        Object \{
			          "add": 5,
			        \},
			        Object \{
			          "mult": 4,
			        \},
			      ],
			    ]
			  \`)
			  expect(fn).toHaveBeenCalledTimes(3)
			\})
			it('safe with nested triggers', () => \{
			  const a = createEvent()
			  const b = createEvent()
			  const c = createEvent()
			  const target = createStore(0)
			    .on(a, n => n + 1)
			    .on(c, n => n + 1)
			  let result
			  a.watch(() => \{
			    b()
			    result = target.getState()
			  \})
			  b.watch(() => \{
			    c()
			  \})
			  a()
			  expect(result).toBe(2)
			\})
			
			test('reducer defaults', () => \{
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  const fn3 = jest.fn()
			  const add = createEvent()
			  const sub = createEvent()
			  const state1 = createStore(3)
			    .on(add, (state, payload) => \{
			      fn1(\{state, payload\})
			    \})
			    .on(sub, (state, payload) => \{
			      fn2(\{state, payload\})
			      return state - payload
			    \})
			  state1.watch(fn3)
			  sub(1)
			  add(10)
			  add(2)
			  expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "payload": 10,
			        "state": 2,
			      \},
			      Object \{
			        "payload": 2,
			        "state": 2,
			      \},
			    ]
			  \`)
			  expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "payload": 1,
			        "state": 3,
			      \},
			    ]
			  \`)
			  expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			    Array [
			      3,
			      2,
			    ]
			  \`)
			  expect(state1.getState()).toMatchInlineSnapshot(\`2\`)
			\})
			
			test('store.reset(event)', () => \{
			  const fn = jest.fn()
			  const reset = createEvent()
			  const inc = createEvent()
			  const listSize = createStore(3)
			    .on(inc, n => n + 1)
			    .reset(reset)
			  const currentList = createStore(
			    Array.from(\{length: listSize.getState()\}, (_, n) => n),
			  )
			    .on(inc, list => [...list, list.length])
			    .reset(reset)
			  const selected = createStore([])
			
			  combine(\{listSize, currentList, selected\})
			
			  const unsub = currentList.subscribe(state => fn(state))
			  inc()
			  reset()
			  unsub()
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        0,
			        1,
			        2,
			      ],
			      Array [
			        0,
			        1,
			        2,
			        3,
			      ],
			      Array [
			        0,
			        1,
			        2,
			      ],
			    ]
			  \`)
			  expect(fn).toHaveBeenCalledTimes(3)
			\})
			
			test('combine', () => \{
			  const fn = jest.fn()
			  const inc = createEvent()
			  const dec = createEvent()
			  const s1 = createStore(0)
			  const s2 = createStore(0)
			  const s3 = createStore(0)
			  const s4 = createStore(0)
			  const result = combine(s1, s2, s3, s4, (a, b, c, d) => (\{a, b, c, d\}))
			  result.watch(fn)
			  s1.on(inc, _ => _ + 1).on(dec, _ => _ - 10)
			  s2.on(inc, _ => _ + 10).on(dec, _ => _ - 1)
			
			  expect(result.getState()).toMatchObject(\{a: 0, b: 0, c: 0, d: 0\})
			
			  inc()
			  dec()
			  expect(result.getState()).toMatchObject(\{a: -9, b: 9, c: 0, d: 0\})
			
			  expect(fn).toHaveBeenCalledTimes(3)
			  // expect(fn).toHaveBeenCalledTimes(5)
			\})
			
			test('no dull updates', () => \{
			  const store = createStore(false)
			  const e1 = createEvent<boolean>()
			  const e2 = createEvent<boolean>()
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  const fn3 = jest.fn()
			  store.watch(fn1)
			  store.on(e1, (_, payload): boolean => payload)
			  store.on(e2, (_, p) => _ === p)
			  const nextStore = store.map(x => (fn2(x), x))
			  nextStore.watch(fn3)
			  store.watch(() => \{\})
			  e1(false)
			  e1(true)
			  e1(false)
			  e2(false)
			  e2(false)
			  expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			    Array [
			      false,
			      true,
			      false,
			      true,
			      false,
			    ]
			  \`)
			  expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			    Array [
			      false,
			      true,
			      false,
			      true,
			      false,
			    ]
			  \`)
			  expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			    Array [
			      false,
			      true,
			      false,
			      true,
			      false,
			    ]
			  \`)
			  expect(fn1).toHaveBeenCalledTimes(5)
			  expect(fn2).toHaveBeenCalledTimes(5)
			  expect(fn3).toHaveBeenCalledTimes(5)
			\})
			test('no dull updates with fork', async () => \{
			  const store = createStore(false)
			  const e1 = createEvent<boolean>()
			  const e2 = createEvent<boolean>()
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  const fn3 = jest.fn()
			  store.watch(fn1)
			  store.on(e1, (_, payload): boolean => payload)
			  store.on(e2, (_, p) => _ === p)
			  const nextStore = store.map(x => (fn2(x), x))
			  nextStore.watch(fn3)
			  store.watch(() => \{\})
			  const scope = fork()
			  await allSettled(e1, \{params: false, scope\})
			  await allSettled(e1, \{params: true, scope\})
			  await allSettled(e1, \{params: false, scope\})
			  await allSettled(e2, \{params: false, scope\})
			  await allSettled(e2, \{params: false, scope\})
			  expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			    Array [
			      false,
			      true,
			      false,
			      true,
			      false,
			    ]
			  \`)
			  expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			    Array [
			      false,
			      true,
			      false,
			      true,
			      false,
			    ]
			  \`)
			  expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			    Array [
			      false,
			      true,
			      false,
			      true,
			      false,
			    ]
			  \`)
			  expect(fn1).toHaveBeenCalledTimes(5)
			  expect(fn2).toHaveBeenCalledTimes(5)
			  expect(fn3).toHaveBeenCalledTimes(5)
			\})
			
			test('smoke', async () => \{
			  const used = jest.fn(x => Promise.resolve(x))
			  const usedDone = jest.fn(x => Promise.resolve(x))
			  const domain = createDomain()
			
			  const effect = domain.createEffect()
			  effect.use(used)
			  effect.done.watch(usedDone)
			  const event = domain.createEvent()
			  expect(effect).toBeDefined()
			  expect(event).toBeDefined()
			  event('bar')
			  await effect('foo')
			  expect(used).toHaveBeenCalledTimes(1)
			  expect(usedDone).toHaveBeenCalledTimes(1)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\effector.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('effector_effector\\src\\effector\\__tests__\\event\\deepWatch.test.ts', () => {
        const sourceCode = `
			import \{createEvent\} from 'effector'
			
			it('can use deep stack calls', () => \{
			  const fn = jest.fn()
			  const a = createEvent()
			  const b = createEvent()
			  const c = createEvent()
			  const d = c.map(_ => _)
			  const e = d.map(_ => _)
			  const f = createEvent()
			
			  a.watch(data => \{
			    b(data)
			  \})
			  b.watch(data => \{
			    c(data)
			  \})
			  e.watch(data => \{
			    f(data)
			  \})
			  f.watch(data => \{
			    fn(data)
			  \})
			
			  a('payload')
			  expect(fn).toHaveBeenCalledTimes(1)
			  expect(fn).toBeCalledWith('payload')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\event\\deepWatch.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\effector\\__tests__\\event\\di.test.ts', () => {
        const sourceCode = `
			import \{createEvent\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('event.create single argument', () => \{
			  const foo = createEvent<number>() as any
			  const oldCreate = foo.create
			  foo.create = jest.fn((payload, args) => oldCreate(payload, args))
			  const baz = jest.fn()
			  foo.watch(baz)
			  foo(100)
			  foo(200)
			  foo(300)
			  expect(argumentHistory(baz)).toMatchInlineSnapshot(\`
			    Array [
			      100,
			      200,
			      300,
			    ]
			  \`)
			  expect(foo.create.mock.calls).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        100,
			        Array [],
			      ],
			      Array [
			        200,
			        Array [],
			      ],
			      Array [
			        300,
			        Array [],
			      ],
			    ]
			  \`)
			\})
			
			test('event.create multiple arguments', () => \{
			  const baz = jest.fn()
			  const bar = createEvent() as any
			  const oldCreate = bar.create
			  bar.create = jest.fn((payload, args) => oldCreate([payload, ...args], []))
			  bar.watch(baz)
			  bar(-2, 'foo')
			  bar(-3, 'bar')
			  bar(-2, 'baz')
			  expect(argumentHistory(baz)).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        -2,
			        "foo",
			      ],
			      Array [
			        -3,
			        "bar",
			      ],
			      Array [
			        -2,
			        "baz",
			      ],
			    ]
			  \`)
			  expect(bar.create.mock.calls).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        -2,
			        Array [
			          "foo",
			        ],
			      ],
			      Array [
			        -3,
			        Array [
			          "bar",
			        ],
			      ],
			      Array [
			        -2,
			        Array [
			          "baz",
			        ],
			      ],
			    ]
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\event\\di.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\effector\\__tests__\\event\\filter.test.ts', () => {
        const sourceCode = `
			import \{createEvent\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('event.filter with config \{fn: (T) => boolean\}', () => \{
			  it('filter out when fn returns falsy', () => \{
			    const fn = jest.fn()
			    const event = createEvent()
			    const filtered = event.filter(\{
			      fn: x => x > 0,
			    \})
			    filtered.watch(x => fn(x))
			    event(2)
			    event(-1)
			    expect(argumentHistory(fn)).toEqual([2])
			  \})
			  it('works with undefined as well', () => \{
			    const fn = jest.fn()
			    const event = createEvent()
			    const filtered = event.filter(\{
			      fn: x => x === undefined,
			    \})
			    filtered.watch(x => fn(x))
			    event(2)
			    event()
			    expect(argumentHistory(fn)).toEqual([undefined])
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\event\\filter.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\effector\\__tests__\\event\\filterMap.test.ts', () => {
        const sourceCode = `
			import \{createEvent, Event\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			import \{show\} from 'effector/fixtures/showstep'
			
			describe('event.filterMap', () => \{
			  test('event.filterMap should infer type', () => \{
			    const fn = jest.fn()
			    const num: Event<number | '-1'> = createEvent()
			
			    const evenNum = num.filterMap(n => \{
			      if (n !== '-1') return n
			    \})
			
			    evenNum.watch(e => fn(e))
			
			    num(0)
			    num('-1')
			    num(2)
			    num('-1')
			    num(4)
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        2,
			        4,
			      ]
			    \`)
			  \})
			
			  test('event.filterMap should drop undefined values', () => \{
			    const fn = jest.fn()
			    const num: Event<number> = createEvent()
			    const evenNum = num.filterMap(n => \{
			      if (n % 2 === 0) return n * 2
			    \})
			
			    evenNum.watch(e => fn(e))
			
			    num(0)
			    num(1)
			    num(2)
			    num(3)
			    num(4)
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        4,
			        8,
			      ]
			    \`)
			
			    //@ts-expect-error
			    expect(show(num.graphite)).toMatchSnapshot('num event graph')
			    //@ts-expect-error
			    expect(show(evenNum.graphite)).toMatchSnapshot('evenNum event graph')
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\event\\filterMap.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\effector\\__tests__\\event\\index.test.ts', () => {
        const sourceCode = `
			import \{from\} from 'most'
			import \{createEvent\} from 'effector'
			
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('symbol-observable support', () => \{
			  test('most.from(event) //stream of events', () => \{
			    const fn = jest.fn()
			    expect(() => \{
			      from(createEvent())
			    \}).not.toThrow()
			    const ev1 = createEvent<number>()
			    const ev2 = createEvent<string>()
			    const ev1\$ = from(ev1)
			    ev1\$.observe(fn)
			    ev1(0)
			    ev1(1)
			    ev1(2)
			    ev2('should ignore')
			    expect(fn).toHaveBeenCalledTimes(3)
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        1,
			        2,
			      ]
			    \`)
			  \})
			\})
			
			test('event.watch(fn)', () => \{
			  const fn = jest.fn()
			  const click = createEvent<number | void>()
			  click.watch(fn)
			  click()
			  click(1)
			  click(2)
			  expect(fn).toHaveBeenCalledTimes(3)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      undefined,
			      1,
			      2,
			    ]
			  \`)
			\})
			
			test('event.prepend(fn)', () => \{
			  const fn = jest.fn()
			  const click = createEvent<number>()
			  const preclick = click.prepend(([n]: number[]) => n)
			  click.watch(fn)
			  preclick([])
			  preclick([1])
			  preclick([2])
			
			  expect(fn).toHaveBeenCalledTimes(3)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      undefined,
			      1,
			      2,
			    ]
			  \`)
			\})
			
			test('event.map(fn)', () => \{
			  const fn = jest.fn()
			  const click = createEvent<number | void>()
			  const postclick = click.map(n => [n])
			  postclick.watch(fn)
			  click()
			  click(1)
			  click(2)
			  expect(fn).toHaveBeenCalledTimes(3)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        undefined,
			      ],
			      Array [
			        1,
			      ],
			      Array [
			        2,
			      ],
			    ]
			  \`)
			\})
			
			test('event.thru(fn)', () => \{
			  const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			  const click = createEvent()
			  const postclick = click.thru(event => event)
			  expect(warn.mock.calls.map(([msg]) => msg)[0]).toMatchInlineSnapshot(
			    \`"thru is deprecated, use js pipe instead"\`,
			  )
			  warn.mockRestore()
			  expect(postclick).toBe(click)
			\})
			
			test('watch validation', () => \{
			  const trigger = createEvent()
			  expect(() => \{
			    //@ts-expect-error
			    trigger.watch(NaN)
			  \}).toThrowErrorMatchingInlineSnapshot(
			    \`".watch argument should be a function"\`,
			  )
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\event\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\effector\\__tests__\\event\\name.test.ts', () => {
        const sourceCode = `
			import \{createEvent, createDomain\} from 'effector'
			
			test("should return it's own name on event.getType()", () => \{
			  expect(createEvent('foo').getType()).toBe('foo')
			  expect(createEvent(\{name: 'foo'\}).getType()).toBe('foo')
			  expect(createEvent('foo', \{name: 'bar'\}).getType()).toBe('foo')
			  expect(createEvent(undefined, \{name: 'bar'\}).getType()).toBe('bar')
			\})
			test('event from domains should has full path in name', () => \{
			  const domain = createDomain('dom')
			  const subdomain = domain.createDomain('subdom')
			  expect(domain.createEvent('foo').getType()).toBe('dom/foo')
			  expect(subdomain.createEvent('bar').getType()).toBe('dom/subdom/bar')
			\})
			test('empty domain name should be skipped', () => \{
			  const domain = createDomain('')
			  const subdomain = domain.createDomain('subdom')
			  expect(domain.createEvent('foo').getType()).toBe('foo')
			  expect(subdomain.createEvent('bar').getType()).toBe('subdom/bar')
			\})
			describe('empty name support', () => \{
			  test('createEvent() should create event with string id used as name', () => \{
			    expect(createEvent().getType()).not.toBe(undefined)
			    expect(createEvent().getType()).not.toBe('')
			  \})
			  test('domain.createEvent() should not fallback to domain name', () => \{
			    const domain = createDomain('dom')
			    expect(domain.createEvent().getType()).not.toBe(undefined)
			    expect(domain.createEvent().getType()).not.toBe('')
			    expect(domain.createEvent().getType()).not.toBe('dom')
			    expect(domain.createEvent().getType()).not.toBe('dom/')
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\event\\name.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('effector_effector\\src\\effector\\__tests__\\fork\\allSettled.test.ts', () => {
        const sourceCode = `
			import \{
			  createDomain,
			  createEffect,
			  createEvent,
			  attach,
			  fork,
			  allSettled,
			  sample,
			  serialize,
			  createStore,
			\} from 'effector'
			
			test('allSettled first argument validation', async () => \{
			  await expect(
			    //@ts-expect-error
			    allSettled(null, \{scope: fork()\}),
			  ).rejects.toThrowErrorMatchingInlineSnapshot(
			    \`"first argument should be unit"\`,
			  )
			
			  await expect(
			    allSettled(
			      createEffect(() => \{\}),
			      \{scope: fork()\},
			    ),
			  ).resolves.toEqual(\{status: 'done', value: undefined\})
			
			  await expect(
			    allSettled(createEvent(), \{scope: fork()\}),
			  ).resolves.toBeUndefined()
			
			  await expect(
			    allSettled(createStore(0), \{scope: fork(), params: 10\}),
			  ).resolves.toBeUndefined()
			
			  await expect(
			    // @ts-expect-error
			    allSettled(createDomain(), \{scope: fork()\}),
			  ).rejects.toThrowErrorMatchingInlineSnapshot(
			    \`"first argument accepts only effects, events, stores or scopes"\`,
			  )
			\})
			
			test('allSettled(scope)', async () => \{
			  const scope = fork()
			  const requestFx = createEffect(() => new Promise(rs => setTimeout(rs, 400)))
			  const \$done = createStore(false)
			  sample(\{
			    clock: requestFx.done,
			    target: \$done,
			    fn: () => true,
			  \})
			  allSettled(requestFx, \{scope\})
			  await allSettled(scope)
			  expect(serialize(scope)).toMatchInlineSnapshot(\`
			    Object \{
			      "el2wwt": true,
			    \}
			  \`)
			\})
			
			describe('allSettled return value', () => \{
			  test('in case of effect resolving', async () => \{
			    const fx = createEffect(async () => 'ok')
			    const scope = fork()
			    const result = await allSettled(fx, \{scope\})
			    expect(result).toEqual(\{status: 'done', value: 'ok'\})
			  \})
			  test('in case of effect rejecting', async () => \{
			    const fx = createEffect(async () => Promise.reject('err'))
			    const scope = fork()
			    const result = await allSettled(fx, \{scope\})
			    expect(result).toEqual(\{status: 'fail', value: 'err'\})
			  \})
			  test('in case of event call', async () => \{
			    const event = createEvent()
			    const scope = fork()
			    const result = await allSettled(event, \{scope\})
			    expect(result).toBe(undefined)
			  \})
			  test('in case of store call', async () => \{
			    const \$store = createStore('value')
			    const scope = fork()
			    const result = await allSettled(\$store, \{scope, params: 'value in scope'\})
			    expect(result).toBe(undefined)
			  \})
			  describe('attach support', () => \{
			    test('throw in original effect', async () => \{
			      const original = createEffect<void, any>(async () =>
			        Promise.reject('err'),
			      )
			      const fx = attach(\{
			        effect: original,
			        mapParams: (_: void) => \{\},
			      \})
			      const scope = fork()
			      const result = await allSettled(fx, \{scope\})
			      expect(result).toEqual(\{status: 'fail', value: 'err'\})
			    \})
			    test('throw in mapParams', async () => \{
			      const original = createEffect<void, any>(async () =>
			        Promise.reject('err'),
			      )
			      const fx = attach(\{
			        effect: original,
			        mapParams(_: void) \{
			          throw 'mapParams error'
			        \},
			      \})
			      const scope = fork()
			      const result = await allSettled(fx, \{scope\})
			      expect(result).toEqual(\{status: 'fail', value: 'mapParams error'\})
			    \})
			  \})
			\})
			
			describe('transactions', () => \{
			  test('add unit to domain during watch', async () => \{
			    const trigger = createEvent()
			    const eff = createEffect(async () => \{
			      await new Promise(rs => setTimeout(rs, 50))
			    \})
			    eff.done.watch(() => \{
			      const newEvent = createEvent()
			    \})
			    sample(\{
			      source: trigger,
			      target: eff,
			    \})
			    const scope = fork()
			    await allSettled(trigger, \{scope\})
			  \})
			  test('', async () => \{
			    const app = createDomain()
			    const inner1 = app.createEffect(async (x: string) => \{
			      await new Promise(rs => setTimeout(rs, 50))
			    \})
			    const inner2 = app.createEffect(async (x: string) => \{
			      await new Promise(rs => setTimeout(rs, 50))
			    \})
			    const req1 = app.createEffect(async (x: string) => \{
			      await inner1(x)
			      await inner2(x)
			      await inner1(\`\$\{x\} 2\`)
			    \})
			    const words = app
			      .createStore([] as string[])
			      .on(inner2.done, (list, \{params: word\}) => [...list, word])
			    const trigger = app.createEvent<string>()
			    const str = app.createStore('-').on(trigger, (_, x) => x)
			
			    sample(\{
			      source: str,
			      target: req1,
			    \})
			
			    const scope1 = fork(app)
			    const promise1 = allSettled(trigger, \{
			      scope: scope1,
			      params: 'a',
			    \})
			    expect(() => \{
			      const inner1 = app.createEffect(async (x: string) => \{
			        await new Promise(rs => setTimeout(rs, 50))
			      \})
			      const inner2 = app.createEffect(async (x: string) => \{
			        await new Promise(rs => setTimeout(rs, 40))
			      \})
			      const req1 = app.createEffect(async (x: string) => \{
			        await Promise.all([inner1(x), inner2(x)])
			      \})
			      const words = app
			        .createStore([] as string[])
			        .on(inner2.done, (list, \{params: word\}) => [...list, word])
			      const str = app.createStore('-').on(trigger, (_, x) => x)
			
			      sample(\{
			        source: str,
			        target: req1,
			      \})
			    \}).not.toThrow()
			    const scope2 = fork(app)
			    const promise2 = allSettled(trigger, \{
			      scope: scope2,
			      params: 'b',
			    \})
			    await promise1
			    expect(() => \{
			      const inner1 = app.createEffect(async (x: string) => \{
			        await new Promise(rs => setTimeout(rs, 50))
			      \})
			      const inner2 = app.createEffect(async (x: string) => \{
			        await new Promise(rs => setTimeout(rs, 50))
			      \})
			      const req1 = app.createEffect(async (x: string) => \{
			        await inner1(x)
			        await inner2(x)
			      \})
			      const words = app
			        .createStore([] as string[])
			        .on(inner2.done, (list, \{params: word\}) => [...list, word])
			      const str = app.createStore('-').on(trigger, (_, x) => x)
			
			      sample(\{
			        source: str,
			        target: req1,
			      \})
			    \}).not.toThrow()
			    await promise2
			    expect(serialize(scope1)).toMatchInlineSnapshot(\`
			      Object \{
			        "-ec3clm": Array [
			          "a",
			        ],
			        "-ywmq49": "a",
			      \}
			    \`)
			    expect(serialize(scope2)).toMatchInlineSnapshot(\`
			      Object \{
			        "-36m1ni": "b",
			        "-ec3clm": Array [
			          "b",
			        ],
			        "-ywmq49": "b",
			        "rsx11i": Array [
			          "b",
			        ],
			      \}
			    \`)
			  \})
			  test('starting store is serialized', async () => \{
			    const \$store = createStore('value')
			    const scope = fork()
			
			    await allSettled(\$store, \{scope, params: 'value in scope'\})
			    expect(serialize(scope)).toMatchObject(\{
			      [\$store.sid as string]: 'value in scope',
			    \})
			    expect(scope.getState(\$store)).toEqual('value in scope')
			  \})
			  test('starting store is serialized with correct value, if affected twice', async () => \{
			    const \$store = createStore('value')
			    sample(\{
			      source: \$store,
			      filter: str => !str.includes('1'),
			      fn: str => str + '1',
			      target: \$store,
			    \})
			    const scope = fork()
			
			    await allSettled(\$store, \{scope, params: 'value in scope'\})
			    expect(serialize(scope)).toMatchObject(\{
			      [\$store.sid as string]: 'value in scope1',
			    \})
			    expect(scope.getState(\$store)).toEqual('value in scope1')
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\fork\\allSettled.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\effector\\__tests__\\fork\\factory.test.ts', () => {
        const sourceCode = `
			import \{fork, serialize\} from 'effector'
			import \{createField, createFieldset\} from './factory'
			
			test('factory support', async () => \{
			  const username = createField('username', 'guest')
			  const age = createField('age', 0)
			  const scope = fork(\{
			    values: [
			      [username.value, 'alice'],
			      [age.value, 21],
			    ],
			  \})
			  expect(serialize(scope)).toMatchInlineSnapshot(\`
			    Object \{
			      "-iajnln|-77rc2s": 21,
			      "8iua16|-77rc2s": "alice",
			    \}
			  \`)
			\})
			
			test('nested factory support', async () => \{
			  const form = createFieldset(() => [
			    createField('username', 'guest'),
			    createField('age', 0),
			  ])
			  const scope = fork(\{
			    values: [
			      [form.shape.username, 'alice'],
			      [form.shape.age, 21],
			    ],
			  \})
			  expect(serialize(scope)).toMatchInlineSnapshot(\`
			    Object \{
			      "-fjbluz|1104zu|-77rc2s": "alice",
			      "-fjbluz|11jxl7|-77rc2s": 21,
			    \}
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\fork\\factory.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\effector\\__tests__\\fork\\fork.test.ts', () => {
        const sourceCode = `
			import \{
			  createDomain,
			  forward,
			  attach,
			  createEvent,
			  createStore,
			  createEffect,
			  fork,
			  allSettled,
			  serialize,
			  hydrate,
			  combine,
			  Store,
			  Scope,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('usage with domain', async () => \{
			  const app = createDomain()
			  const add = app.createEvent<number>()
			  const \$count = app.createStore(0).on(add, (n, x) => n + x)
			  const addFx = app.createEffect(() => 0)
			  forward(\{from: addFx.doneData, to: add\})
			
			  const scope = fork(app, \{
			    values: [[\$count, 10]],
			    handlers: [[addFx, () => 5]],
			  \})
			  await allSettled(addFx, \{scope\})
			  expect(scope.getState(\$count)).toBe(15)
			  expect(\$count.getState()).toBe(0)
			\})
			
			test('usage without domain', async () => \{
			  const add = createEvent<number>()
			  const \$count = createStore(0).on(add, (n, x) => n + x)
			  const addFx = createEffect(() => 0)
			  forward(\{from: addFx.doneData, to: add\})
			
			  const scope = fork(\{
			    values: [[\$count, 10]],
			    handlers: [[addFx, () => 5]],
			  \})
			  await allSettled(addFx, \{scope\})
			  expect(scope.getState(\$count)).toBe(15)
			  expect(\$count.getState()).toBe(0)
			\})
			describe('units without sids support', () => \{
			  test('store without sid should be supported', () => \{
			    //@ts-expect-error
			    const \$foo = createStore(0, \{sid: null\})
			    expect(() => \{
			      fork(\{values: [[\$foo, 1]]\})
			    \}).not.toThrow()
			    const scope = fork(\{values: [[\$foo, 2]]\})
			    expect(scope.getState(\$foo)).toBe(2)
			  \})
			  test('mapped stores derived from sidless ones should be supported', () => \{
			    //@ts-expect-error
			    const \$foo = createStore(0, \{sid: null\})
			    const \$bar = \$foo.map(x => x)
			    const scope = fork(\{values: [[\$foo, 2]]\})
			    expect(scope.getState(\$bar)).toBe(2)
			  \})
			  test('combined stores derived from sidless ones should be supported', () => \{
			    //@ts-expect-error
			    const \$foo = createStore(0, \{sid: null\})
			    const \$bar = combine(\$foo, x => x)
			    const scope = fork(\{values: [[\$foo, 2]]\})
			    expect(scope.getState(\$bar)).toBe(2)
			  \})
			  test('effect without sid should be supported', async () => \{
			    const fooFx = createEffect(\{
			      handler(): any \{
			        throw Error('default handler')
			      \},
			      //@ts-expect-error
			      sid: null,
			    \})
			    expect(() => \{
			      fork(\{handlers: [[fooFx, () => 1]]\})
			    \}).not.toThrow()
			    const fn = jest.fn()
			    const scope = fork(\{handlers: [[fooFx, fn]]\})
			    await allSettled(fooFx, \{scope\})
			    expect(fn).toBeCalled()
			  \})
			  test('mixed sid and no-sid case should work for tests', async () => \{
			    //@ts-expect-error
			    const \$foo = createStore(0, \{sid: null\})
			    const \$bar = \$foo.map(x => x * 2)
			
			    const \$sid = createStore(0, \{sid: '\$sid'\})
			    const \$sidBar = \$sid.map(x => x * 2)
			
			    const scope = fork(\{
			      values: [
			        [\$foo, 1],
			        [\$sid, 2],
			      ],
			    \})
			
			    expect(scope.getState(\$bar)).toBe(2)
			    expect(scope.getState(\$sidBar)).toBe(4)
			  \})
			  test('edge-case: mixed sid and no-sid case should work for tests, even there are build-in sids in factory', async () => \{
			    const libFactory = () => \{
			      return createStore(0, \{sid: '\$sid'\})
			    \}
			
			    //@ts-expect-error
			    const \$foo = createStore(0, \{sid: null\})
			    const \$bar = \$foo.map(x => x * 2)
			
			    const \$sid = libFactory()
			    const \$sidBar = \$sid.map(x => x * 2)
			
			    const \$sidOther = libFactory()
			    const \$sidBarOther = \$sidOther.map(x => x * 2)
			
			    const scope = fork(\{
			      values: [
			        [\$foo, 1],
			        [\$sid, 2],
			        [\$sidOther, 4],
			      ],
			    \})
			
			    expect(scope.getState(\$bar)).toBe(2)
			    expect(scope.getState(\$sidBar)).toBe(4)
			    expect(scope.getState(\$sidBarOther)).toBe(8)
			  \})
			\})
			describe('fork values support', () => \{
			  test('values as js Map', async () => \{
			    const app = createDomain()
			
			    const logsCache = app.createStore<string[]>([])
			    const settings = app.createStore(\{
			      MAX_COUNT_CACHED_LOGS: 12,
			    \})
			
			    const scope = fork(app, \{
			      values: new Map()
			        .set(settings, \{MAX_COUNT_CACHED_LOGS: 2\})
			        .set(logsCache, ['LOG_MSG_MOCK']),
			    \})
			
			    hydrate(app, \{
			      values: serialize(scope),
			    \})
			
			    expect(settings.getState()).toEqual(\{MAX_COUNT_CACHED_LOGS: 2\})
			    expect(logsCache.getState()).toEqual(['LOG_MSG_MOCK'])
			  \})
			  test('values as tuple list', async () => \{
			    const app = createDomain()
			
			    const logsCache = app.createStore<string[]>([])
			    const settings = app.createStore(\{
			      MAX_COUNT_CACHED_LOGS: 12,
			    \})
			
			    const scope = fork(app, \{
			      values: [
			        [settings, \{MAX_COUNT_CACHED_LOGS: 2\}],
			        [logsCache, ['LOG_MSG_MOCK']],
			      ],
			    \})
			
			    hydrate(app, \{
			      values: serialize(scope),
			    \})
			
			    expect(settings.getState()).toEqual(\{MAX_COUNT_CACHED_LOGS: 2\})
			    expect(logsCache.getState()).toEqual(['LOG_MSG_MOCK'])
			  \})
			  test('values as sid map', async () => \{
			    const app = createDomain()
			
			    const logsCache = app.createStore([])
			    const settings = app.createStore(\{
			      MAX_COUNT_CACHED_LOGS: 12,
			    \})
			
			    const scope = fork(app, \{
			      values: \{
			        [logsCache.sid!]: ['LOG_MSG_MOCK'],
			        [settings.sid!]: \{MAX_COUNT_CACHED_LOGS: 2\},
			      \},
			    \})
			
			    hydrate(app, \{
			      values: serialize(scope),
			    \})
			
			    expect(settings.getState()).toEqual(\{MAX_COUNT_CACHED_LOGS: 2\})
			    expect(logsCache.getState()).toEqual(['LOG_MSG_MOCK'])
			  \})
			  test('values validation', async () => \{
			    expect(() => \{
			      fork(\{
			        values: new Map().set(null, () => \{\}),
			      \})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"Map key should be a unit"\`)
			  \})
			  test('passed non store to values map should throw', () => \{
			    const app = createDomain()
			    const unit = createEvent()
			    expect(() => \{
			      fork(app, \{
			        values: new Map().set(unit, 0),
			      \})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"Values map can contain only stores as keys"\`,
			    )
			  \})
			  describe('consistency simple', () => \{
			    test('consistency simple with getState', async () => \{
			      const secondOne1 = createStore(1, \{sid: \`1.2\`\})
			      const both1 = combine(secondOne1, y => 2 * y)
			
			      const finalStore = combine([secondOne1, both1], ([secondOne, both]) => (\{
			        secondOne,
			        both,
			      \}))
			      const scope = fork(\{
			        values: [[secondOne1, 0]],
			      \})
			      expect(scope.getState(secondOne1)).toEqual(0)
			      expect(scope.getState(finalStore)).toEqual(\{secondOne: 0, both: 0\})
			    \})
			  \})
			  test('values initialization consistency', async () => \{
			    /**
			     * goal of this test is to create a lot of stores to pass to values
			     * and ensure that combined stores will work as expected
			     * */
			    let sumStore = createStore([0, []] as [number, any[]], \{sid: 'sum'\})
			    const stores: Store<number>[] = []
			    const storesToShow: Store<number>[] = []
			    function fab(n: number) \{
			      const store = createStore(n, \{sid: \`\$\{n\}.1\`\})
			      sumStore = combine(
			        sumStore,
			        store,
			        (prevVal, x) => [x, prevVal] as [number, any[]],
			      )
			      const secondOne = createStore(n, \{sid: \`\$\{n\}.2\`\})
			      const third = store.map(x => x + 1)
			      const both = combine(third, secondOne, (x, y) => x * y)
			      sumStore = combine(
			        sumStore,
			        both,
			        (prevVal, x) => [x, prevVal] as [number, any[]],
			      )
			      stores.push(store, secondOne)
			      storesToShow.push(store, secondOne, third, both)
			    \}
			    for (let i = 0; i < 10; i++) fab(i)
			    const finalStore = combine(storesToShow, items => \{
			      const results: Array<\{
			        store: number
			        secondOne: number
			        third: number
			        both: number
			      \}> = []
			      for (let i = 0; i < items.length; i += 4) \{
			        results.push(\{
			          store: items[i],
			          secondOne: items[i + 1],
			          third: items[i + 2],
			          both: items[i + 3],
			        \})
			      \}
			      return results
			    \})
			    const scope = fork(\{
			      values: stores.filter((_, i) => i % 3 === 0).map(store => [store, 0]),
			    \})
			    const basicCase = serialize(scope)
			    expect(scope.getState(finalStore)).toMatchInlineSnapshot(\`
			Array [
			  Object \{
			    "both": 0,
			    "secondOne": 0,
			    "store": 0,
			    "third": 1,
			  \},
			  Object \{
			    "both": 0,
			    "secondOne": 0,
			    "store": 1,
			    "third": 2,
			  \},
			  Object \{
			    "both": 6,
			    "secondOne": 2,
			    "store": 2,
			    "third": 3,
			  \},
			  Object \{
			    "both": 3,
			    "secondOne": 3,
			    "store": 0,
			    "third": 1,
			  \},
			  Object \{
			    "both": 0,
			    "secondOne": 0,
			    "store": 4,
			    "third": 5,
			  \},
			  Object \{
			    "both": 30,
			    "secondOne": 5,
			    "store": 5,
			    "third": 6,
			  \},
			  Object \{
			    "both": 6,
			    "secondOne": 6,
			    "store": 0,
			    "third": 1,
			  \},
			  Object \{
			    "both": 0,
			    "secondOne": 0,
			    "store": 7,
			    "third": 8,
			  \},
			  Object \{
			    "both": 72,
			    "secondOne": 8,
			    "store": 8,
			    "third": 9,
			  \},
			  Object \{
			    "both": 9,
			    "secondOne": 9,
			    "store": 0,
			    "third": 1,
			  \},
			]
			\`)
			    expect(basicCase).toMatchInlineSnapshot(\`
			Object \{
			  "0.1": 0,
			  "1.2": 0,
			  "3.1": 0,
			  "4.2": 0,
			  "6.1": 0,
			  "7.2": 0,
			  "9.1": 0,
			\}
			\`)
			    expect(scope.getState(sumStore)).toMatchInlineSnapshot(\`
			Array [
			  9,
			  Array [
			    0,
			    Array [
			      72,
			      Array [
			        8,
			        Array [
			          0,
			          Array [
			            7,
			            Array [
			              6,
			              Array [
			                0,
			                Array [
			                  30,
			                  Array [
			                    5,
			                    Array [
			                      0,
			                      Array [
			                        4,
			                        Array [
			                          3,
			                          Array [
			                            0,
			                            Array [
			                              6,
			                              Array [
			                                2,
			                                Array [
			                                  0,
			                                  Array [
			                                    1,
			                                    Array [
			                                      0,
			                                      Array [
			                                        0,
			                                        Array [
			                                          0,
			                                          Array [],
			                                        ],
			                                      ],
			                                    ],
			                                  ],
			                                ],
			                              ],
			                            ],
			                          ],
			                        ],
			                      ],
			                    ],
			                  ],
			                ],
			              ],
			            ],
			          ],
			        ],
			      ],
			    ],
			  ],
			]
			\`)
			  \})
			\})
			
			describe('fork handlers support', () => \{
			  test('handlers as js Map', async () => \{
			    const fx = createEffect(() => 'not to call')
			
			    const acc = createStore<string[]>([]).on(fx.doneData, (list, val) => [
			      ...list,
			      val,
			    ])
			
			    const scope = fork(\{handlers: [[fx, () => 'fn']]\})
			
			    await allSettled(fx, \{scope\})
			
			    expect(scope.getState(acc)).toEqual(['fn'])
			  \})
			  test('handlers as tuple list', async () => \{
			    const fx = createEffect(() => 'not to call')
			
			    const acc = createStore<string[]>([]).on(fx.doneData, (list, val) => [
			      ...list,
			      val,
			    ])
			
			    const scope = fork(\{handlers: [[fx, () => 'fn']]\})
			
			    await allSettled(fx, \{scope\})
			
			    expect(scope.getState(acc)).toEqual(['fn'])
			  \})
			  test('handlers as sid map', async () => \{
			    const fx = createEffect(() => 'not to call')
			
			    const acc = createStore<string[]>([]).on(fx.doneData, (list, val) => [
			      ...list,
			      val,
			    ])
			
			    const scope = fork(\{
			      handlers: \{
			        [fx.sid!]: () => 'fn',
			      \},
			    \})
			
			    await allSettled(fx, \{scope\})
			
			    expect(scope.getState(acc)).toEqual(['fn'])
			  \})
			  test('handlers as a tuple list, but with sid doubles', async () => \{
			    const h1 = jest.fn()
			    const h2 = jest.fn()
			    const fx1 = createEffect(\{
			      sid: 'fx',
			      handler: () => \{\},
			    \})
			    const fx2 = createEffect(\{
			      sid: 'fx',
			      handler: () => \{\},
			    \})
			
			    const scope = fork(\{
			      handlers: [
			        [fx1, h1],
			        [fx2, h2],
			      ],
			    \})
			
			    await Promise.all([allSettled(fx1, \{scope\}), allSettled(fx2, \{scope\})])
			
			    expect(h1).toBeCalledTimes(1)
			    expect(h2).toBeCalledTimes(1)
			  \})
			\})
			
			describe('handlers validation', () => \{
			  test('passing non-unit value to handlers should throw', async () => \{
			    expect(() => \{
			      fork(\{
			        handlers: new Map().set(null, () => \{\}),
			      \})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"Map key should be a unit"\`)
			  \})
			  test('passing non-effect unit to handlers should throw', () => \{
			    const unit = createEvent()
			    expect(() => \{
			      fork(\{
			        handlers: new Map().set(unit, () => \{\}),
			      \})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"Handlers map can contain only effects as keys"\`,
			    )
			  \})
			  test('passing attached effect to handlers should throw', () => \{
			    const fx = createEffect((n: number) => \{\})
			    const source = createStore(0)
			    const attached = attach(\{
			      effect: fx,
			      source,
			    \})
			    expect(() => \{
			      fork(\{
			        handlers: new Map().set(attached, () => \{\}),
			      \})
			    \}).not.toThrow()
			  \})
			\})
			
			describe('passing attach async effect to handlers should work', () => \{
			  test('function in effect, function in handlers', async () => \{
			    const fn = jest.fn()
			    const \$user = createStore('guest')
			    const sendMessageFx = attach(\{
			      source: \$user,
			      async effect(user, message: \{text: string\}) \{\},
			    \})
			
			    let scope: Scope
			    expect(() => \{
			      scope = fork(\{
			        values: [[\$user, 'alice']],
			        handlers: [
			          [
			            sendMessageFx,
			            (user: string, message: \{text: string\}) => \{
			              fn(\{user, message\})
			            \},
			          ],
			        ],
			      \})
			    \}).not.toThrow()
			    await allSettled(sendMessageFx, \{
			      scope: scope!,
			      params: \{text: 'hello'\},
			    \})
			    expect(argumentHistory(fn)[0]).toEqual(\{
			      user: 'alice',
			      message: \{text: 'hello'\},
			    \})
			  \})
			  test('function in effect, effect in handlers', async () => \{
			    const fn = jest.fn()
			    const \$user = createStore('guest')
			    const fx = createEffect((user: string) => \{
			      fn(\{user\})
			    \})
			    const sendMessageFx = attach(\{
			      source: \$user,
			      async effect(user, message: \{text: string\}) \{\},
			    \})
			
			    let scope: Scope
			    expect(() => \{
			      scope = fork(\{
			        values: [[\$user, 'alice']],
			        handlers: [[sendMessageFx, fx]],
			      \})
			    \}).not.toThrow()
			    await allSettled(sendMessageFx, \{
			      scope: scope!,
			      params: \{text: 'hello'\},
			    \})
			    expect(argumentHistory(fn)[0]).toEqual(\{user: 'alice'\})
			  \})
			  test('effect in effect, function in handlers', async () => \{
			    const fn = jest.fn()
			    const \$user = createStore('guest')
			    const fx = createEffect((user: string) => \{\})
			    const sendMessageFx = attach(\{
			      source: \$user,
			      effect: fx,
			    \})
			
			    let scope: Scope
			    expect(() => \{
			      scope = fork(\{
			        values: [[\$user, 'alice']],
			        handlers: [
			          [
			            sendMessageFx,
			            (user: string) => \{
			              fn(\{user\})
			            \},
			          ],
			        ],
			      \})
			    \}).not.toThrow()
			    await allSettled(sendMessageFx, \{
			      scope: scope!,
			    \})
			    expect(argumentHistory(fn)[0]).toEqual(\{user: 'alice'\})
			  \})
			  test('effect in effect, effect in handlers', async () => \{
			    const fn = jest.fn()
			    const \$user = createStore('guest')
			    const fx1 = createEffect((user: string) => \{\})
			    const fx2 = createEffect((user: string) => \{
			      fn(\{user\})
			    \})
			    const sendMessageFx = attach(\{
			      source: \$user,
			      effect: fx1,
			    \})
			
			    let scope: Scope
			    expect(() => \{
			      scope = fork(\{
			        values: [[\$user, 'alice']],
			        handlers: [[sendMessageFx, fx2]],
			      \})
			    \}).not.toThrow()
			    await allSettled(sendMessageFx, \{
			      scope: scope!,
			    \})
			    expect(argumentHistory(fn)[0]).toEqual(\{user: 'alice'\})
			  \})
			\})
			
			test('edge case', async () => \{
			  const enableFeature = createEvent()
			
			  const \$isCountryPage = createStore(false, \{sid: 'country'\})
			  const \$isFeatureEnabled = createStore(false, \{sid: 'feature'\}).on(
			    enableFeature,
			    () => true,
			  )
			
			  const \$isWidgetEnabled = combine([\$isCountryPage, \$isFeatureEnabled], s =>
			    s.every(Boolean),
			  )
			
			  const scope = fork(\{values: [[\$isCountryPage, true]]\})
			  await allSettled(enableFeature, \{scope\})
			
			  expect(scope.getState(\$isWidgetEnabled)).toBe(true)
			\})
			
			describe('scope watch calls', () => \{
			  test('without values', async () => \{
			    const aWatchFn = jest.fn()
			    const aUpdWatchFn = jest.fn()
			    const mappedWatchFn = jest.fn()
			    const mappedUpdWatchFn = jest.fn()
			    const combinedWatchFn = jest.fn()
			    const combinedUpdWatchFn = jest.fn()
			
			    const trigger = createEvent()
			
			    const src = createStore(0).on(trigger, n => n + 1)
			    const tag = createStore('a')
			    const mapped = src.map(n => n + 1)
			    const combined = combine([src, tag])
			
			    addWatch(src, aWatchFn, aUpdWatchFn)
			    addWatch(mapped, mappedWatchFn, mappedUpdWatchFn)
			    addWatch(combined, combinedWatchFn, combinedUpdWatchFn)
			
			    const scope = fork()
			
			    await allSettled(trigger, \{scope\})
			    await allSettled(trigger, \{scope\})
			
			    expect(\{
			      watch: argumentHistory(aWatchFn),
			      updates: argumentHistory(aUpdWatchFn),
			    \}).toEqual(\{watch: [1, 2], updates: [1, 2]\})
			    expect(\{
			      watch: argumentHistory(mappedWatchFn),
			      updates: argumentHistory(mappedUpdWatchFn),
			    \}).toEqual(\{watch: [2, 3], updates: [2, 3]\})
			    expect(\{
			      watch: argumentHistory(combinedWatchFn),
			      updates: argumentHistory(combinedUpdWatchFn),
			    \}).toEqual(\{
			      watch: [
			        [1, 'a'],
			        [2, 'a'],
			      ],
			      updates: [
			        [1, 'a'],
			        [2, 'a'],
			      ],
			    \})
			  \})
			  test('with updated values', async () => \{
			    const aWatchFn = jest.fn()
			    const aUpdWatchFn = jest.fn()
			    const mappedWatchFn = jest.fn()
			    const mappedUpdWatchFn = jest.fn()
			    const combinedWatchFn = jest.fn()
			    const combinedUpdWatchFn = jest.fn()
			
			    const trigger = createEvent()
			
			    const src = createStore(0).on(trigger, n => n + 1)
			    const tag = createStore('a')
			    const mapped = src.map(n => n + 1)
			    const combined = combine([src, tag])
			
			    addWatch(src, aWatchFn, aUpdWatchFn)
			    addWatch(mapped, mappedWatchFn, mappedUpdWatchFn)
			    addWatch(combined, combinedWatchFn, combinedUpdWatchFn)
			
			    const scope = fork(\{values: [[src, 1]]\})
			
			    await allSettled(trigger, \{scope\})
			    await allSettled(trigger, \{scope\})
			
			    expect(\{
			      watch: argumentHistory(aWatchFn),
			      updates: argumentHistory(aUpdWatchFn),
			    \}).toEqual(\{watch: [2, 3], updates: [2, 3]\})
			    expect(\{
			      watch: argumentHistory(mappedWatchFn),
			      updates: argumentHistory(mappedUpdWatchFn),
			    \}).toEqual(\{watch: [3, 4], updates: [3, 4]\})
			    expect(\{
			      watch: argumentHistory(combinedWatchFn),
			      updates: argumentHistory(combinedUpdWatchFn),
			    \}).toEqual(\{
			      watch: [
			        [2, 'a'],
			        [3, 'a'],
			      ],
			      updates: [
			        [2, 'a'],
			        [3, 'a'],
			      ],
			    \})
			  \})
			
			  test('with sibling values', async () => \{
			    const aWatchFn = jest.fn()
			    const aUpdWatchFn = jest.fn()
			    const mappedWatchFn = jest.fn()
			    const mappedUpdWatchFn = jest.fn()
			    const combinedWatchFn = jest.fn()
			    const combinedUpdWatchFn = jest.fn()
			
			    const trigger = createEvent()
			
			    const src = createStore(0).on(trigger, n => n + 1)
			    const tag = createStore('a')
			    const mapped = src.map(n => n + 1)
			    const combined = combine([src, tag])
			
			    addWatch(src, aWatchFn, aUpdWatchFn)
			    addWatch(mapped, mappedWatchFn, mappedUpdWatchFn)
			    addWatch(combined, combinedWatchFn, combinedUpdWatchFn)
			
			    const scope = fork(\{values: [[tag, 'b']]\})
			
			    await allSettled(trigger, \{scope\})
			    await allSettled(trigger, \{scope\})
			
			    expect(\{
			      watch: argumentHistory(aWatchFn),
			      updates: argumentHistory(aUpdWatchFn),
			    \}).toEqual(\{watch: [1, 2], updates: [1, 2]\})
			    expect(\{
			      watch: argumentHistory(mappedWatchFn),
			      updates: argumentHistory(mappedUpdWatchFn),
			    \}).toEqual(\{watch: [2, 3], updates: [2, 3]\})
			    expect(\{
			      watch: argumentHistory(combinedWatchFn),
			      updates: argumentHistory(combinedUpdWatchFn),
			    \}).toEqual(\{
			      watch: [
			        [1, 'b'],
			        [2, 'b'],
			      ],
			      updates: [
			        [1, 'b'],
			        [2, 'b'],
			      ],
			    \})
			  \})
			
			  test('with sibling values & nested combine', async () => \{
			    const aWatchFn = jest.fn()
			    const aUpdWatchFn = jest.fn()
			    const mappedWatchFn = jest.fn()
			    const mappedUpdWatchFn = jest.fn()
			    const combinedWatchFn = jest.fn()
			    const combinedUpdWatchFn = jest.fn()
			
			    const trigger = createEvent()
			
			    const src = createStore(0).on(trigger, n => n + 1)
			    const tag = createStore('a')
			    const mapped = src.map(n => n + 1)
			    const combinedA = combine([src, tag])
			    const combinedB = combine([tag])
			    const combined = combine(combinedA, combinedB, ([src], [tag]) => [src, tag])
			
			    addWatch(src, aWatchFn, aUpdWatchFn)
			    addWatch(mapped, mappedWatchFn, mappedUpdWatchFn)
			    addWatch(combined, combinedWatchFn, combinedUpdWatchFn)
			
			    const scope = fork(\{values: [[tag, 'b']]\})
			
			    await allSettled(trigger, \{scope\})
			    await allSettled(trigger, \{scope\})
			
			    expect(\{
			      watch: argumentHistory(aWatchFn),
			      updates: argumentHistory(aUpdWatchFn),
			    \}).toEqual(\{watch: [1, 2], updates: [1, 2]\})
			    expect(\{
			      watch: argumentHistory(mappedWatchFn),
			      updates: argumentHistory(mappedUpdWatchFn),
			    \}).toEqual(\{watch: [2, 3], updates: [2, 3]\})
			    expect(\{
			      watch: argumentHistory(combinedWatchFn),
			      updates: argumentHistory(combinedUpdWatchFn),
			    \}).toEqual(\{
			      watch: [
			        [1, 'b'],
			        [2, 'b'],
			      ],
			      updates: [
			        [1, 'b'],
			        [2, 'b'],
			      ],
			    \})
			  \})
			
			  function addWatch(
			    store: Store<any>,
			    fnA: (value: any) => any,
			    fnB: (value: any) => any,
			  ) \{
			    let inited = false
			    store.watch(upd => \{
			      if (!inited) \{
			        inited = true
			        return
			      \}
			      fnA(upd)
			    \})
			    store.updates.watch(upd => fnB(upd))
			  \}
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\fork\\fork.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(31)
    });
    it('effector_effector\\src\\effector\\__tests__\\fork\\hydrate.test.ts', () => {
        const sourceCode = `
			import \{argumentHistory\} from 'effector/fixtures'
			import \{
			  createDomain,
			  forward,
			  combine,
			  fork,
			  allSettled,
			  serialize,
			  hydrate,
			  Store,
			  Event,
			\} from 'effector'
			
			describe('sidless stores support', () => \{
			  test('with scope', () => \{
			    //@ts-expect-error
			    const app = createDomain(\{sid: null\})
			    //@ts-expect-error
			    const \$foo = app.createStore(0, \{sid: null\})
			    const scope = fork(app)
			    hydrate(scope, \{values: [[\$foo, 2]]\})
			    expect(scope.getState(\$foo)).toBe(2)
			  \})
			  test('with domain', () => \{
			    //@ts-expect-error
			    const app = createDomain(\{sid: null\})
			    //@ts-expect-error
			    const \$foo = app.createStore(0, \{sid: null\})
			    hydrate(app, \{values: [[\$foo, 2]]\})
			    expect(\$foo.getState()).toBe(2)
			  \})
			\})
			
			test('watch calls during hydration', async () => \{
			  const fxHandlerFn = jest.fn()
			  const storeWatchFn = jest.fn()
			  const eventWatchFn = jest.fn()
			  const combineWatchFn = jest.fn()
			  const combineUpdatesWatchFn = jest.fn()
			  const combineFnWatchFn = jest.fn()
			  const combineFnUpdatesWatchFn = jest.fn()
			  const mapWatchFn = jest.fn()
			  const mapUpdatesWatchFn = jest.fn()
			
			  const app = createDomain()
			  const start = app.createEvent()
			  const fx = app.createEffect(\{
			    handler: fxHandlerFn,
			  \})
			
			  const store = app.store(-1).on(start, x => x + 1)
			
			  forward(\{
			    from: store,
			    to: fx,
			  \})
			
			  const combined = combine(\{a: store, b: store\})
			  const combinedFn = combine(store, store, (a, b) => (\{a, b\}))
			
			  const mapped = store.map(x => \`'\$\{x\}'\`)
			
			  store.watch(storeWatchFn)
			  store.updates.watch(eventWatchFn)
			  combined.watch(combineWatchFn)
			  combined.updates.watch(combineUpdatesWatchFn)
			  combinedFn.watch(combineFnWatchFn)
			  combinedFn.updates.watch(combineFnUpdatesWatchFn)
			  mapped.watch(mapWatchFn)
			  mapped.updates.watch(mapUpdatesWatchFn)
			
			  hydrate(app, \{values: [[store, 0]]\})
			  await allSettled(start, \{scope: fork(app)\})
			  /** store */
			  expect(\{
			    watch: argumentHistory(storeWatchFn),
			    updates: argumentHistory(eventWatchFn),
			  \}).toEqual(\{watch: [-1, 0, 1], updates: [0, 1]\})
			  /** mapped */
			  expect(\{
			    watch: argumentHistory(mapWatchFn),
			    updates: argumentHistory(mapUpdatesWatchFn),
			  \}).toEqual(\{watch: ["'-1'", "'0'", "'1'"], updates: ["'0'", "'1'"]\})
			  expect(\{
			    fxHandlerFn: argumentHistory(fxHandlerFn),
			  \}).toEqual(\{fxHandlerFn: [0, 1]\})
			  /** combined */
			  expect(\{
			    watch: argumentHistory(combineWatchFn),
			    updates: argumentHistory(combineUpdatesWatchFn),
			  \}).toEqual(\{
			    watch: [
			      \{a: -1, b: -1\},
			      \{a: 0, b: 0\},
			      \{a: 1, b: 1\},
			    ],
			    updates: [
			      \{a: 0, b: 0\},
			      \{a: 1, b: 1\},
			    ],
			  \})
			  /** combined with fn */
			  expect(\{
			    watch: argumentHistory(combineFnWatchFn),
			    updates: argumentHistory(combineFnUpdatesWatchFn),
			  \}).toEqual(\{
			    watch: [
			      \{a: -1, b: -1\},
			      \{a: 0, b: 0\},
			      \{a: 1, b: 1\},
			    ],
			    updates: [
			      \{a: 0, b: 0\},
			      \{a: 1, b: 1\},
			    ],
			  \})
			\})
			
			describe('multiple hydrate calls', () => \{
			  test('reference: no hydrate calls', () => \{
			    const fn = jest.fn()
			    const app = createDomain()
			    const setN = app.createEvent<number>()
			    const \$n = app.createStore(0).on(setN, (_, n) => n)
			    const combined = combine(\{n: \$n\})
			    const combfn = combine(\$n, n => n)
			    storeWatch('\$n', \$n, fn)
			    storeWatch('combined', combined, fn)
			    storeWatch('combfn', combfn, fn)
			    unitWatch('setN', setN, fn)
			    fn(\`## setN(2)\`)
			    setN(2)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "\$n: 0",
			        "combined: \{n:0\}",
			        "combfn: 0",
			        "## setN(2)",
			        "setN: 2",
			        "\$n: 2",
			        "\$n.updates: 2",
			        "combined: \{n:2\}",
			        "combined.updates: \{n:2\}",
			        "combfn: 2",
			        "combfn.updates: 2",
			      ]
			    \`)
			  \})
			  describe('with same value', () => \{
			    test('domain', () => \{
			      const fn = jest.fn()
			      const app = createDomain()
			      const setN = app.createEvent<number>()
			      const \$n = app.createStore(0).on(setN, (_, n) => n)
			      const combined = combine(\{n: \$n\})
			      const combfn = combine(\$n, n => n)
			      storeWatch('\$n', \$n, fn)
			      storeWatch('combined', combined, fn)
			      storeWatch('combfn', combfn, fn)
			      unitWatch('setN', setN, fn)
			      fn(\`## first hydration, \$n = 1\`)
			      hydrate(app, \{
			        values: [[\$n, 1]],
			      \})
			      fn(\`## second hydration, \$n = 1\`)
			      hydrate(app, \{
			        values: [[\$n, 1]],
			      \})
			      fn(\`## setN(2)\`)
			      setN(2)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$n: 0",
			          "combined: \{n:0\}",
			          "combfn: 0",
			          "## first hydration, \$n = 1",
			          "\$n: 1",
			          "\$n.updates: 1",
			          "combined: \{n:1\}",
			          "combined.updates: \{n:1\}",
			          "combfn: 1",
			          "combfn.updates: 1",
			          "## second hydration, \$n = 1",
			          "## setN(2)",
			          "setN: 2",
			          "\$n: 2",
			          "\$n.updates: 2",
			          "combined: \{n:2\}",
			          "combined.updates: \{n:2\}",
			          "combfn: 2",
			          "combfn.updates: 2",
			        ]
			      \`)
			    \})
			    test('scope', async () => \{
			      const fn = jest.fn()
			      const app = createDomain()
			      const setN = app.createEvent<number>()
			      const \$n = app.createStore(0).on(setN, (_, n) => n)
			      const combined = combine(\{n: \$n\})
			      const combfn = combine(\$n, n => n)
			      storeWatch('\$n', \$n, fn)
			      storeWatch('combined', combined, fn)
			      storeWatch('combfn', combfn, fn)
			      unitWatch('setN', setN, fn)
			      fn(\`## forking, \$n = -2\`)
			      const scope = fork(app, \{
			        values: [[\$n, -2]],
			      \})
			      fn(\`## first hydration, \$n = 1\`)
			      hydrate(scope, \{
			        values: [[\$n, 1]],
			      \})
			      fn(\`## second hydration, \$n = 1\`)
			      hydrate(scope, \{
			        values: [[\$n, 1]],
			      \})
			      fn(\`## setN(2)\`)
			      await allSettled(setN, \{
			        params: 2,
			        scope,
			      \})
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$n: 0",
			          "combined: \{n:0\}",
			          "combfn: 0",
			          "## forking, \$n = -2",
			          "## first hydration, \$n = 1",
			          "\$n: 1",
			          "\$n.updates: 1",
			          "combined: \{n:1\}",
			          "combined.updates: \{n:1\}",
			          "combfn: 1",
			          "combfn.updates: 1",
			          "## second hydration, \$n = 1",
			          "## setN(2)",
			          "setN: 2",
			          "\$n: 2",
			          "\$n.updates: 2",
			          "combined: \{n:2\}",
			          "combined.updates: \{n:2\}",
			          "combfn: 2",
			          "combfn.updates: 2",
			        ]
			      \`)
			    \})
			  \})
			  describe('with different values', () => \{
			    test('domain', () => \{
			      const fn = jest.fn()
			      const app = createDomain()
			      const setN = app.createEvent<number>()
			      const \$n = app.createStore(0).on(setN, (_, n) => n)
			      const combined = combine(\{n: \$n\})
			      const combfn = combine(\$n, n => n)
			      storeWatch('\$n', \$n, fn)
			      storeWatch('combined', combined, fn)
			      storeWatch('combfn', combfn, fn)
			      unitWatch('setN', setN, fn)
			      fn(\`## first hydration, \$n = 1\`)
			      hydrate(app, \{
			        values: [[\$n, 1]],
			      \})
			      fn(\`## second hydration, \$n = -1\`)
			      hydrate(app, \{
			        values: [[\$n, -1]],
			      \})
			      fn(\`## setN(2)\`)
			      setN(2)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$n: 0",
			          "combined: \{n:0\}",
			          "combfn: 0",
			          "## first hydration, \$n = 1",
			          "\$n: 1",
			          "\$n.updates: 1",
			          "combined: \{n:1\}",
			          "combined.updates: \{n:1\}",
			          "combfn: 1",
			          "combfn.updates: 1",
			          "## second hydration, \$n = -1",
			          "\$n: -1",
			          "\$n.updates: -1",
			          "combined: \{n:-1\}",
			          "combined.updates: \{n:-1\}",
			          "combfn: -1",
			          "combfn.updates: -1",
			          "## setN(2)",
			          "setN: 2",
			          "\$n: 2",
			          "\$n.updates: 2",
			          "combined: \{n:2\}",
			          "combined.updates: \{n:2\}",
			          "combfn: 2",
			          "combfn.updates: 2",
			        ]
			      \`)
			    \})
			    test('scope', async () => \{
			      const fn = jest.fn()
			      const app = createDomain()
			      const setN = app.createEvent<number>()
			      const \$n = app.createStore(0).on(setN, (_, n) => n)
			      const combined = combine(\{n: \$n\})
			      const combfn = combine(\$n, n => n)
			      storeWatch('\$n', \$n, fn)
			      storeWatch('combined', combined, fn)
			      storeWatch('combfn', combfn, fn)
			      unitWatch('setN', setN, fn)
			      fn(\`## forking, \$n = -2\`)
			      const scope = fork(app, \{
			        values: [[\$n, -2]],
			      \})
			      fn(\`## first hydration, \$n = 1\`)
			      hydrate(scope, \{
			        values: [[\$n, 1]],
			      \})
			      fn(\`## second hydration, \$n = -1\`)
			      hydrate(scope, \{
			        values: [[\$n, -1]],
			      \})
			      fn(\`## setN(2)\`)
			      await allSettled(setN, \{
			        params: 2,
			        scope,
			      \})
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$n: 0",
			          "combined: \{n:0\}",
			          "combfn: 0",
			          "## forking, \$n = -2",
			          "## first hydration, \$n = 1",
			          "\$n: 1",
			          "\$n.updates: 1",
			          "combined: \{n:1\}",
			          "combined.updates: \{n:1\}",
			          "combfn: 1",
			          "combfn.updates: 1",
			          "## second hydration, \$n = -1",
			          "\$n: -1",
			          "\$n.updates: -1",
			          "combined: \{n:-1\}",
			          "combined.updates: \{n:-1\}",
			          "combfn: -1",
			          "combfn.updates: -1",
			          "## setN(2)",
			          "setN: 2",
			          "\$n: 2",
			          "\$n.updates: 2",
			          "combined: \{n:2\}",
			          "combined.updates: \{n:2\}",
			          "combfn: 2",
			          "combfn.updates: 2",
			        ]
			      \`)
			    \})
			  \})
			  function storeWatch<T>(
			    tag: string,
			    store: Store<T>,
			    fn: jest.Mock<any, any>,
			  ) \{
			    unitWatch(\`\$\{tag\}\`, store, fn)
			    unitWatch(\`\$\{tag\}.updates\`, store.updates, fn)
			  \}
			  function unitWatch<T>(
			    tag: string,
			    unit: Store<T> | Event<T>,
			    fn: jest.Mock<any, any>,
			    log: boolean = false,
			  ) \{
			    unit.watch(value => \{
			      let text: string
			      if (typeof value === 'object' && value !== null) \{
			        text = \`\{n:\$\{(value as any).n\}\}\`
			      \} else \{
			        text = \`\$\{value\}\`
			      \}
			      fn(\`\$\{tag\}: \$\{text\}\`)
			      if (log) \{
			        console.log(tag, text)
			      \}
			    \})
			  \}
			\})
			
			describe('hydrate edge cases', () => \{
			  test('#1', async () => \{
			    const app = createDomain()
			
			    const listsContainer\$ = app.createStore(\{
			      a: [],
			      b: [],
			    \})
			
			    const greaterThan\$ = app.createStore(2)
			
			    const listA\$ = listsContainer\$.map(x => x.a)
			    const filteredA\$ = combine(listA\$, greaterThan\$, (xs, gt) =>
			      xs.filter(x => x > gt),
			    )
			    const listB\$ = listsContainer\$.map(x => x.b)
			    const filteredB\$ = combine(listB\$, greaterThan\$, (xs, gt) =>
			      xs.filter(x => x > gt),
			    )
			
			    hydrate(app, \{
			      values: \{
			        ...serialize(fork(app)),
			        [listsContainer\$.sid!]: \{
			          a: [0, 1, 2, 3],
			          b: [1, 8, 5],
			        \},
			      \},
			    \})
			    expect(filteredA\$.getState()).toMatchInlineSnapshot(\`
			      Array [
			        3,
			      ]
			    \`)
			    expect(filteredB\$.getState()).toMatchInlineSnapshot(\`
			      Array [
			        8,
			        5,
			      ]
			    \`)
			  \})
			  test('#2', async () => \{
			    const app = createDomain()
			
			    const greaterThan = app.createStore(2)
			
			    const listsContainer = app.createStore(\{
			      a: [],
			      b: [],
			    \})
			
			    const byType = listsContainer.map(val => val.a)
			    const filtered = combine(byType, greaterThan, (map, gt) =>
			      map.filter(x => x > gt),
			    )
			
			    const forked = fork(app)
			
			    hydrate(app, \{
			      values: \{
			        [listsContainer.sid!]: \{
			          a: [0, 1, 2, 3],
			          b: [1, 8, 5],
			        \},
			      \},
			    \})
			
			    expect(filtered.getState()).toMatchInlineSnapshot(\`
			      Array [
			        3,
			      ]
			    \`)
			  \})
			\})
			
			test('scope support', async () => \{
			  const fn = jest.fn()
			
			  const app = createDomain()
			  const name = app.createStore('guest')
			  name.updates.watch(fn)
			
			  const scope = fork(app, \{values: [[name, 'alice']]\})
			
			  hydrate(scope, \{values: [[name, 'bob']]\})
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      "bob",
			    ]
			  \`)
			  expect(scope.getState(name)).toMatchInlineSnapshot(\`"bob"\`)
			  expect(name.getState()).toMatchInlineSnapshot(\`"guest"\`)
			\})
			
			test('scope without domain should throw an error', () => \{
			  const scope = fork()
			  expect(() => \{
			    hydrate(scope, \{values: []\})
			  \}).toThrowErrorMatchingInlineSnapshot(\`"scope should be created from domain"\`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\fork\\hydrate.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\effector\\__tests__\\fork\\index.test.ts', () => {
        const sourceCode = `
			import \{
			  createEvent,
			  forward,
			  attach,
			  fork,
			  allSettled,
			  launch,
			  createEffect,
			  createStore,
			  combine,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('imperative call support', () => \{
			  it('support imperative event calls in watchers', async () => \{
			    const inc = createEvent()
			    const count = createStore(0).on(inc, x => x + 1)
			
			    const start = createEvent()
			    start.watch(() => \{
			      inc()
			    \})
			
			    const scope = fork()
			
			    await allSettled(start, \{scope\})
			
			    expect(scope.getState(count)).toBe(1)
			    expect(count.getState()).toBe(0)
			  \})
			  describe('support imperative effect calls in watchers', () => \{
			    test('with sync effects', async () => \{
			      const inc = createEffect(() => \{\})
			      const count = createStore(0).on(inc.done, x => x + 1)
			
			      const start = createEvent()
			      start.watch(() => \{
			        inc()
			      \})
			
			      const scope = fork()
			
			      await allSettled(start, \{scope\})
			
			      expect(scope.getState(count)).toBe(1)
			      expect(count.getState()).toBe(0)
			    \})
			    test('with async effects', async () => \{
			      const inc = createEffect(async () => \{
			        await new Promise(rs => setTimeout(rs, 100))
			      \})
			      const count = createStore(0).on(inc.done, x => x + 1)
			
			      const start = createEvent()
			      start.watch(() => \{
			        inc()
			      \})
			
			      const scope = fork()
			
			      await allSettled(start, \{scope\})
			
			      expect(scope.getState(count)).toBe(1)
			      expect(count.getState()).toBe(0)
			    \})
			  \})
			  describe('support imperative event calls in effects', () => \{
			    test('sync effects', async () => \{
			      const inc = createEvent()
			      const count = createStore(0).on(inc, x => x + 1)
			
			      const start = createEffect(() => \{
			        inc()
			      \})
			
			      const scope = fork()
			
			      await allSettled(start, \{scope\})
			
			      expect(scope.getState(count)).toBe(1)
			      expect(count.getState()).toBe(0)
			    \})
			    test('start of async effects', async () => \{
			      const inc = createEvent()
			      const count = createStore(0).on(inc, x => x + 1)
			
			      const start = createEffect(async () => \{
			        inc()
			      \})
			
			      const scope = fork()
			
			      await allSettled(start, \{scope\})
			
			      expect(scope.getState(count)).toBe(1)
			      expect(count.getState()).toBe(0)
			    \})
			  \})
			  describe('support imperative effect calls in effects', () => \{
			    test('simple case', async () => \{
			      const inc = createEffect<void, void>(() => \{\})
			      const count = createStore(0).on(inc.done, x => x + 1)
			
			      const start = createEffect(async () => \{
			        await inc()
			      \})
			
			      const scope = fork()
			
			      await allSettled(start, \{scope\})
			
			      expect(scope.getState(count)).toBe(1)
			      expect(count.getState()).toBe(0)
			    \})
			    describe('sequential', () => \{
			      test('with sync inner effect', async () => \{
			        const inc = createEffect(() => \{\})
			        const count = createStore(0).on(inc.done, x => x + 1)
			
			        const start = createEffect(async () => \{
			          await inc()
			          await inc()
			        \})
			
			        const scope = fork()
			
			        await allSettled(start, \{scope\})
			
			        expect(scope.getState(count)).toBe(2)
			        expect(count.getState()).toBe(0)
			      \})
			      test('with async inner effect', async () => \{
			        const inc = createEffect(async () => \{\})
			        const count = createStore(0).on(inc.done, x => x + 1)
			
			        const start = createEffect(async () => \{
			          await inc()
			          await inc()
			        \})
			
			        const scope = fork()
			
			        await allSettled(start, \{scope\})
			
			        expect(scope.getState(count)).toBe(2)
			        expect(count.getState()).toBe(0)
			      \})
			    \})
			    describe('parallel', () => \{
			      test('with sync inner effect', async () => \{
			        const inc = createEffect(() => \{\})
			        const count = createStore(0).on(inc.done, x => x + 1)
			
			        const start = createEffect(async () => \{
			          await Promise.all([inc(), inc()])
			        \})
			
			        const scope = fork()
			
			        await allSettled(start, \{scope\})
			
			        expect(scope.getState(count)).toBe(2)
			        expect(count.getState()).toBe(0)
			      \})
			      test('with async inner effect', async () => \{
			        const inc = createEffect(async () => \{\})
			        const count = createStore(0).on(inc.done, x => x + 1)
			
			        const start = createEffect(async () => \{
			          await Promise.all([inc(), inc()])
			        \})
			
			        const scope = fork()
			
			        await allSettled(start, \{scope\})
			
			        expect(scope.getState(count)).toBe(2)
			        expect(count.getState()).toBe(0)
			      \})
			    \})
			    test('with forward', async () => \{
			      const inc = createEffect(async () => \{\})
			      const count = createStore(0).on(inc.done, x => x + 1)
			
			      const start = createEffect(async () => \{
			        await inc()
			      \})
			
			      const next = createEffect(async () => \{
			        await inc()
			      \})
			
			      forward(\{from: start.doneData, to: next\})
			
			      const scope = fork()
			
			      await allSettled(start, \{scope\})
			
			      expect(scope.getState(count)).toBe(2)
			      expect(count.getState()).toBe(0)
			    \})
			    test('attach imperative call', async () => \{
			      const add = createEffect((_: number) => _)
			
			      const count = createStore(2).on(add.doneData, (x, y) => x + y)
			
			      const addWithCurrent = attach(\{
			        source: count,
			        effect: add,
			        mapParams: (params: number, current) => params + current,
			      \})
			
			      const start = createEffect(async (val: number) => \{
			        await addWithCurrent(val)
			      \})
			
			      const scope = fork()
			
			      await allSettled(start, \{
			        scope,
			        params: 3,
			      \})
			
			      expect(scope.getState(count)).toBe(7)
			      expect(count.getState()).toBe(2)
			    \})
			    test('scope isolation', async () => \{
			      const pushWord = createEvent<string>()
			      const addWord = createEffect(async (word: string) => word)
			      const words = createStore<string[]>([]).on(
			        [addWord.doneData, pushWord],
			        (list, word) => [...list, word],
			      )
			
			      const start = createEffect(async (word: string) => \{
			        await addWord(\`\$\{word\} 1\`)
			        pushWord(\`\$\{word\} 1.5\`)
			        await addWord(\`\$\{word\} 2\`)
			        return word
			      \})
			
			      const next = createEffect(async (word: string) => \{
			        await addWord(\`\$\{word\} 3\`)
			        pushWord(\`\$\{word\} 3.5\`)
			        await addWord(\`\$\{word\} 4\`)
			      \})
			
			      forward(\{from: start.doneData, to: next\})
			
			      const scopeA = fork()
			      const scopeB = fork()
			      const scopeC = fork()
			
			      await Promise.all([
			        allSettled(start, \{
			          scope: scopeA,
			          params: 'A',
			        \}),
			        allSettled(start, \{
			          scope: scopeB,
			          params: 'B',
			        \}),
			      ])
			
			      await allSettled(start, \{
			        scope: scopeC,
			        params: 'C',
			      \})
			
			      expect(scopeA.getState(words)).toMatchInlineSnapshot(\`
			        Array [
			          "A 1",
			          "A 1.5",
			          "A 2",
			          "A 3",
			          "A 3.5",
			          "A 4",
			        ]
			      \`)
			      expect(scopeB.getState(words)).toMatchInlineSnapshot(\`
			        Array [
			          "B 1",
			          "B 1.5",
			          "B 2",
			          "B 3",
			          "B 3.5",
			          "B 4",
			        ]
			      \`)
			      expect(scopeC.getState(words)).toMatchInlineSnapshot(\`
			        Array [
			          "C 1",
			          "C 1.5",
			          "C 2",
			          "C 3",
			          "C 3.5",
			          "C 4",
			        ]
			      \`)
			      expect(words.getState()).toEqual([])
			    \})
			    test('concurrency', async () => \{
			      let i = 0
			      const inc = createEffect(async () => \{
			        await new Promise(rs => \{
			          switch (i++) \{
			            case 0:
			              return setTimeout(rs, 100)
			            case 1:
			              return setTimeout(rs, 10)
			            case 2:
			              return setTimeout(rs, 50)
			            default:
			              i = 1
			              return setTimeout(rs, 100)
			          \}
			        \})
			      \})
			      const count = createStore(0).on(inc.done, x => x + 1)
			
			      const start = createEvent()
			      start.watch(() => \{
			        inc()
			      \})
			
			      const scopeA = fork()
			      const scopeB = fork()
			      const scopeC = fork()
			      await Promise.all([
			        allSettled(start, \{scope: scopeA\}).then(() =>
			          allSettled(start, \{scope: scopeC\}),
			        ),
			        allSettled(start, \{scope: scopeA\}).then(() =>
			          allSettled(start, \{scope: scopeB\}),
			        ),
			      ])
			      await Promise.all([
			        allSettled(start, \{scope: scopeA\}),
			        allSettled(start, \{scope: scopeB\}).then(() =>
			          allSettled(start, \{scope: scopeC\}),
			        ),
			      ])
			      await Promise.all([
			        allSettled(start, \{scope: scopeB\}),
			        allSettled(start, \{scope: scopeA\}),
			        allSettled(start, \{scope: scopeC\}),
			      ])
			
			      expect(scopeA.getState(count)).toBe(4)
			      expect(scopeB.getState(count)).toBe(3)
			      expect(scopeC.getState(count)).toBe(3)
			      expect(count.getState()).toBe(0)
			    \})
			    test('concurrency 2', async () => \{
			      const delay = createEffect(async (n: number) => \{
			        await new Promise(rs => setTimeout(rs, n))
			      \})
			      const timeout = createEffect((n: number) => \{
			        return new Promise((rs, rj) => \{
			          setTimeout(rj, n, Error('timeout'))
			        \})
			      \})
			      const fx = createEffect(async () => \{
			        await Promise.race([delay(50), timeout(100)])
			      \})
			      const count = createStore(0).on(fx.finally, x => x + 1)
			      const delayCount = createStore(0).on(delay.finally, x => x + 1)
			      const timeoutCount = createStore(0).on(timeout.finally, x => x + 1)
			
			      const scopeA = fork()
			      await allSettled(fx, \{scope: scopeA\})
			
			      expect(\{
			        a: \{
			          count: scopeA.getState(count),
			          delayCount: scopeA.getState(delayCount),
			          timeoutCount: scopeA.getState(timeoutCount),
			        \},
			
			        __: \{
			          count: count.getState(),
			          delayCount: delayCount.getState(),
			          timeoutCount: timeoutCount.getState(),
			        \},
			      \}).toMatchInlineSnapshot(\`
			        Object \{
			          "__": Object \{
			            "count": 0,
			            "delayCount": 0,
			            "timeoutCount": 0,
			          \},
			          "a": Object \{
			            "count": 1,
			            "delayCount": 1,
			            "timeoutCount": 1,
			          \},
			        \}
			      \`)
			    \})
			    test('concurrency 3', async () => \{
			      const delay = createEffect(async (n: number) => \{
			        await new Promise(rs => setTimeout(rs, n))
			      \})
			      const timeout = createEffect((n: number) => \{
			        const errPromise = new Promise((_, rj) => \{
			          setTimeout(rj, n, Error('timeout'))
			        \})
			        return errPromise
			      \})
			      const fx = createEffect(async () => \{
			        await Promise.race([delay(50), timeout(100)])
			        await Promise.race([delay(50), timeout(100)])
			        timeout(10)
			      \})
			      const count = createStore(0).on(fx.finally, x => x + 1)
			      const delayCount = createStore(0).on(delay.finally, x => x + 1)
			      const timeoutCount = createStore(0).on(timeout.finally, x => x + 1)
			
			      const scopeA = fork()
			      const scopeB = fork()
			      const scopeC = fork()
			      await Promise.all([
			        allSettled(fx, \{scope: scopeA\}),
			        allSettled(fx, \{scope: scopeB\}),
			        allSettled(fx, \{scope: scopeC\}),
			      ])
			      await Promise.all([
			        allSettled(fx, \{scope: scopeA\}).then(() =>
			          allSettled(fx, \{scope: scopeC\}),
			        ),
			        allSettled(fx, \{scope: scopeA\}).then(() =>
			          allSettled(fx, \{scope: scopeB\}),
			        ),
			      ])
			      await Promise.all([
			        allSettled(fx, \{scope: scopeA\}),
			        allSettled(fx, \{scope: scopeB\}).then(() =>
			          allSettled(fx, \{scope: scopeC\}),
			        ),
			      ])
			      await Promise.all([
			        allSettled(fx, \{scope: scopeB\}),
			        allSettled(fx, \{scope: scopeA\}),
			        allSettled(fx, \{scope: scopeC\}),
			      ])
			
			      expect(\{
			        a: \{
			          count: scopeA.getState(count),
			          delayCount: scopeA.getState(delayCount),
			          timeoutCount: scopeA.getState(timeoutCount),
			        \},
			
			        b: \{
			          count: scopeB.getState(count),
			          delayCount: scopeB.getState(delayCount),
			          timeoutCount: scopeB.getState(timeoutCount),
			        \},
			
			        c: \{
			          count: scopeC.getState(count),
			          delayCount: scopeC.getState(delayCount),
			          timeoutCount: scopeC.getState(timeoutCount),
			        \},
			
			        __: \{
			          count: count.getState(),
			          delayCount: delayCount.getState(),
			          timeoutCount: timeoutCount.getState(),
			        \},
			      \}).toMatchInlineSnapshot(\`
			        Object \{
			          "__": Object \{
			            "count": 0,
			            "delayCount": 0,
			            "timeoutCount": 0,
			          \},
			          "a": Object \{
			            "count": 5,
			            "delayCount": 10,
			            "timeoutCount": 15,
			          \},
			          "b": Object \{
			            "count": 4,
			            "delayCount": 8,
			            "timeoutCount": 12,
			          \},
			          "c": Object \{
			            "count": 4,
			            "delayCount": 8,
			            "timeoutCount": 12,
			          \},
			        \}
			      \`)
			    \})
			  \})
			\})
			
			test('call fx().catch(() => \{\}) from effect should not be unhandled', async () => \{
			  const timeout = createEffect((n: number) => \{
			    const errPromise = new Promise((rs, rj) => \{
			      setTimeout(rj, n, Error('timeout'))
			    \})
			    return errPromise
			  \})
			  const delay = createEffect(async (n: number) => \{
			    await new Promise(rs => setTimeout(rs, n))
			  \})
			  const fx = createEffect(async () => \{
			    await Promise.race([delay(50), timeout(100).catch(() => \{\})])
			  \})
			  const scope = fork()
			  await allSettled(fx, \{scope\})
			\})
			
			test('getState support', async () => \{
			  const fn = jest.fn()
			  const start = createEvent()
			  const store = createStore(0)
			  start.watch(() => \{
			    fn(store.getState())
			  \})
			  await allSettled(start, \{
			    scope: fork(\{values: [[store, 2]]\}),
			  \})
			  expect(fn).toHaveBeenLastCalledWith(2)
			\})
			
			test('setState support', async () => \{
			  const start = createEvent()
			  const store = createStore(0)
			  start.watch(() => \{
			    //@ts-expect-error
			    store.setState(1)
			  \})
			  const scope = fork()
			  await allSettled(start, \{scope\})
			  expect(scope.getState(store)).toBe(1)
			  expect(store.getState()).not.toBe(1)
			\})
			
			describe('watch on unit inside effect handler', () => \{
			  test('resolve effect by calling event from outside', async () => \{
			    const early = createEvent<string>()
			    const fx = createEffect(
			      (fxPayload: any) =>
			        new Promise(resolve => \{
			          const timeout = setTimeout(resolve, 50, fxPayload)
			          const unsub = early.watch(eventPayload => \{
			            unsub()
			            clearTimeout(timeout)
			            resolve(eventPayload)
			          \})
			        \}),
			    )
			    const \$state = createStore(0).on(fx.doneData, (_, payload: any) => payload)
			    const scope = fork()
			    await Promise.all([
			      allSettled(fx, \{scope, params: 'EFFECT_RESOLVED'\}),
			      allSettled(early, \{scope, params: 'EARLY_BY_EVENT'\}),
			    ])
			    expect(scope.getState(\$state)).toBe('EARLY_BY_EVENT')
			  \})
			
			  test('do not affect different forks', async () => \{
			    const early = createEvent<string>()
			    const fx = createEffect(
			      (fxPayload: any) =>
			        new Promise(resolve => \{
			          const timeout = setTimeout(resolve, 50, fxPayload)
			          const unsub = early.watch(eventPayload => \{
			            unsub()
			            clearTimeout(timeout)
			            resolve(eventPayload)
			          \})
			        \}),
			    )
			    const \$state = createStore(0).on(fx.doneData, (_, payload: any) => payload)
			    const scope1 = fork()
			    const scope2 = fork()
			    const promise1 = allSettled(fx, \{
			      scope: scope1,
			      params: '1_RESOLVED_EFFECT',
			    \})
			    const promise1early = allSettled(early, \{
			      scope: scope1,
			      params: '1_EARLY_BY_EVENT',
			    \})
			    const promise2 = allSettled(fx, \{
			      scope: scope2,
			      params: '2_RESOLVED_EFFECT',
			    \})
			    await Promise.all([promise1, promise1early, promise2])
			    expect(scope1.getState(\$state)).toBe('1_EARLY_BY_EVENT')
			    expect(scope2.getState(\$state)).toBe('2_RESOLVED_EFFECT')
			  \})
			\})
			
			test('forked scope update itself on new domain units access', async () => \{
			  const fn = jest.fn()
			  const scope = fork()
			  const newEvent = createEvent()
			  newEvent.watch(() => \{
			    fn()
			  \})
			  launch(\{
			    target: newEvent,
			    params: undefined,
			    scope,
			  \})
			  expect(fn).toBeCalledTimes(1)
			\})
			
			test('fork should pass through attach', () => \{
			  const source = createEvent()
			
			  const timer = createStore(0)
			  const fx = attach(\{
			    source: timer,
			    mapParams: (param, timeout) => [param, timeout],
			    effect: createEffect(() => 0),
			  \})
			  forward(\{from: source, to: fx\})
			  expect(() => \{
			    fork()
			  \}).not.toThrow()
			\})
			
			describe('getState with same sids', () => \{
			  test('reading values from stores with same sid is correct', async () => \{
			    const touchedDirect = createEvent()
			    const \$directValue = createStore(false, \{sid: 'sameSid'\}).on(
			      touchedDirect,
			      v => !v,
			    )
			
			    const convenientTouched = createEvent()
			
			    const \$convenientValue = createStore(false, \{sid: 'sameSid'\})
			      .on(\$directValue, (value, directValue) => (directValue ? false : value))
			      .on(convenientTouched, v => !v)
			
			    const scope = fork()
			
			    await allSettled(convenientTouched, \{scope\})
			
			    await allSettled(touchedDirect, \{scope\})
			
			    expect(scope.getState(\$convenientValue)).toEqual(false)
			  \})
			\})
			
			describe('diamond deps (issue #613)', () => \{
			  test('with getState (should pass)', async () => \{
			    const fn = jest.fn()
			    const historyChanged = createEvent<\{path: string; search: string\}>()
			    const \$history = createStore<\{path: string; search: string\} | null>(
			      null,
			    ).on(historyChanged, (_, upd) => upd)
			    const \$path = \$history.map(location => location?.path ?? '')
			    const \$search = \$history.map(location => location?.search ?? '')
			    const \$href = combine(\$path, \$search, (path, search) => \`\$\{path\}/\$\{search\}\`)
			    \$search.watch(s => fn(s))
			    const scope = fork()
			    scope.getState(\$search)
			    await allSettled(historyChanged, \{
			      scope,
			      params: \{
			        path: 'path',
			        search: 'search',
			      \},
			    \})
			    expect(argumentHistory(fn)).toEqual(['', 'search'])
			  \})
			  test('without getState (should pass)', async () => \{
			    const fn = jest.fn()
			    const historyChanged = createEvent<\{path: string; search: string\}>()
			    const \$history = createStore<\{path: string; search: string\} | null>(
			      null,
			    ).on(historyChanged, (_, upd) => upd)
			    const \$path = \$history.map(location => location?.path ?? '')
			    const \$search = \$history.map(location => location?.search ?? '')
			    const \$href = combine(\$path, \$search, (path, search) => \`\$\{path\}/\$\{search\}\`)
			    \$search.watch(s => fn(s))
			    const scope = fork()
			    await allSettled(historyChanged, \{
			      scope,
			      params: \{
			        path: 'path',
			        search: 'search',
			      \},
			    \})
			    expect(argumentHistory(fn)).toEqual(['', 'search'])
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\fork\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(26)
    });
    it('effector_effector\\src\\effector\\__tests__\\fork\\scopeBind.test.ts', () => {
        const sourceCode = `
			import \{
			  createEvent,
			  createStore,
			  createEffect,
			  scopeBind,
			  fork,
			  allSettled,
			\} from 'effector'
			
			it('bind result to current promise when called from watch', async () => \{
			  const trigger = createEvent()
			  const inc = createEvent()
			  const \$count = createStore(0).on(inc, x => x + 1)
			
			  let fn: () => void
			
			  trigger.watch(() => \{
			    fn = scopeBind(inc)
			  \})
			
			  const scope = fork()
			  await allSettled(trigger, \{scope\})
			  fn!()
			  expect(scope.getState(\$count)).toBe(1)
			  expect(\$count.getState()).toBe(0)
			\})
			
			it('will throw an error when used without watch nor explicit \{scope\}', () => \{
			  const trigger = createEvent()
			
			  expect(() => \{
			    scopeBind(trigger)
			  \}).toThrowErrorMatchingInlineSnapshot(
			    \`"scopeBind cannot be called outside of forked .watch"\`,
			  )
			\})
			
			it('support explicit \{scope\}', async () => \{
			  const inc = createEvent()
			  const \$count = createStore(0).on(inc, x => x + 1)
			
			  const scope = fork()
			
			  const scopeInc = scopeBind(inc, \{scope\})
			
			  scopeInc()
			
			  expect(scope.getState(\$count)).toBe(1)
			  expect(\$count.getState()).toBe(0)
			\})
			
			it('returns promise when used with effect', async () => \{
			  const fx = createEffect(() => 'ok')
			
			  const scope = fork()
			  const scopeFx = scopeBind(fx, \{scope\})
			
			  const req = scopeFx()
			  expect(req instanceof Promise).toBe(true)
			\})
			
			it('does not throw on calls without scope, if called in safe mode', () => \{
			  const trigger = createEvent()
			
			  expect(() => \{
			    scopeBind(trigger, \{safe: true\})
			  \}).not.toThrow()
			\})
			
			it('allows calls without scope, if called in safe mode', async () => \{
			  const trigger = createEvent()
			  const inc = createEvent()
			  const \$count = createStore(0).on(inc, x => x + 1)
			
			  let fn: () => void
			
			  trigger.watch(() => \{
			    fn = scopeBind(inc, \{safe: true\})
			  \})
			
			  trigger()
			  await Promise.resolve()
			  fn!()
			  expect(\$count.getState()).toBe(1)
			\})
			
			it('catches scope, if called with scope in safe mode', async () => \{
			  const trigger = createEvent()
			  const inc = createEvent()
			  const \$count = createStore(0).on(inc, x => x + 1)
			
			  let fn: () => void
			
			  trigger.watch(() => \{
			    fn = scopeBind(inc, \{safe: true\})
			  \})
			
			  const scope = fork()
			  await allSettled(trigger, \{scope\})
			  fn!()
			  expect(scope.getState(\$count)).toBe(1)
			  expect(\$count.getState()).toBe(0)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\fork\\scopeBind.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('effector_effector\\src\\effector\\__tests__\\fork\\serialize.test.ts', () => {
        const sourceCode = `
			import \{
			  Scope,
			  createStore,
			  createEvent,
			  createDomain,
			  allSettled,
			  combine,
			  fork,
			  hydrate,
			  serialize,
			  sample,
			  createEffect,
			  attach,
			\} from 'effector'
			
			it('serialize stores to object of sid as keys', () => \{
			  const \$a = createStore('value', \{sid: 'a'\})
			  const \$b = createStore([], \{sid: 'b'\})
			  const \$c = createStore(null as null | number, \{sid: 'c'\})
			  const \$d = createStore(false, \{sid: 'd'\})
			
			  const scope = fork(\{
			    values: [
			      [\$a, 'value2'],
			      [\$b, []],
			      [\$c, 0],
			      [\$d, true],
			    ],
			  \})
			  expect(serialize(scope)).toEqual(\{
			    a: 'value2',
			    b: [],
			    c: 0,
			    d: true,
			  \})
			\})
			
			it('serialize stores with ignore parameter', () => \{
			  const \$a = createStore('value', \{sid: 'a'\})
			  const \$b = createStore([], \{sid: 'b'\})
			  const \$c = createStore(null as null | number, \{sid: 'c'\})
			  const \$d = createStore(false, \{sid: 'd'\})
			
			  const scope = fork(\{
			    values: [
			      [\$a, 'value2'],
			      [\$b, []],
			      [\$c, 0],
			      [\$d, true],
			    ],
			  \})
			  expect(serialize(scope, \{ignore: [\$b, \$d]\})).toEqual(\{
			    a: 'value2',
			    c: 0,
			  \})
			\})
			
			test('serialize: ignore', async () => \{
			  const inc = createEvent()
			  const \$a = createStore(0, \{sid: 'a', serialize: 'ignore'\})
			  const \$b = createStore(0, \{sid: 'b'\})
			  \$a.on(inc, x => x + 1)
			  \$b.on(inc, x => x + 1)
			
			  const scope = fork()
			
			  await allSettled(inc, \{scope\})
			
			  expect(serialize(scope)).toEqual(\{b: 1\})
			\})
			
			test('serialize: ignore with fork(values)', async () => \{
			  const inc = createEvent()
			  const \$a = createStore(0, \{sid: 'a', serialize: 'ignore'\})
			  const \$b = createStore(0, \{sid: 'b'\})
			  \$a.on(inc, x => x + 1)
			  \$b.on(inc, x => x + 1)
			
			  const scope = fork(\{
			    values: [[\$a, 100]],
			  \})
			
			  await allSettled(inc, \{scope\})
			
			  expect(serialize(scope)).toEqual(\{b: 1\})
			\})
			
			describe('serialize: custom', () => \{
			  test('base case', async () => \{
			    expect.assertions(4)
			    let currentScope: Scope
			    const aToStr = (v: number) => \`\$\{v\}\`
			    const inc = createEvent()
			    const \$a = createStore(0, \{
			      sid: 'a',
			      serialize: \{
			        write: value => \{
			          expect(currentScope.getState(\$a)).toEqual(value)
			          return aToStr(value)
			        \},
			        read: json => \{
			          expect(aToStr(currentScope.getState(\$a))).toEqual(json)
			          return Number(json)
			        \},
			      \},
			    \})
			    const \$b = createStore(0, \{sid: 'b'\})
			    \$a.on(inc, x => x + 1)
			    \$b.on(inc, x => x + 1)
			
			    const scope = fork()
			
			    await allSettled(inc, \{scope\})
			
			    currentScope = scope
			    const values = serialize(scope)
			
			    expect(values).toEqual(\{a: '1', b: 1\})
			
			    const clientScope = fork(\{
			      values,
			    \})
			    expect(clientScope.getState(\$a)).toEqual(1)
			  \})
			
			  test('Map usecase', () => \{
			    const \$map = createStore(new Map<number, number>(), \{
			      sid: 'map',
			      serialize: \{
			        write: map => [...map.entries()],
			        read: jsonMap => new Map(jsonMap),
			      \},
			    \})
			
			    const scope = fork()
			
			    allSettled(\$map, \{scope, params: new Map().set(1, 2).set(2, 3)\})
			
			    const values = serialize(scope)
			
			    expect(values).toEqual(\{
			      map: [...new Map().set(1, 2).set(2, 3)],
			    \})
			
			    const clientScope = fork(\{
			      values,
			    \})
			
			    expect(clientScope.getState(\$map)).toEqual(new Map().set(1, 2).set(2, 3))
			  \})
			
			  test('hydrate case', () => \{
			    const domain = createDomain()
			    const \$map = domain.createStore(new Map<number, number>(), \{
			      sid: 'map',
			      serialize: \{
			        write: map => [...map.entries()],
			        read: jsonMap => new Map(jsonMap),
			      \},
			    \})
			
			    const scope = fork(domain)
			
			    allSettled(\$map, \{scope, params: new Map().set(1, 2).set(2, 3)\})
			
			    const values = serialize(scope)
			
			    expect(values).toEqual(\{
			      map: [...new Map().set(1, 2).set(2, 3)],
			    \})
			
			    const clientScope = fork(domain)
			
			    hydrate(clientScope, \{values\})
			
			    expect(clientScope.getState(\$map)).toEqual(new Map().set(1, 2).set(2, 3))
			  \})
			  test('does not affect normal ref initialization', () => \{
			    const parser = jest.fn()
			    const up = createEvent()
			    const \$a = createStore(0, \{
			      serialize: \{
			        write: value => \{
			          return \`\$\{value\}\`
			        \},
			        read: _json => \{
			          parser()
			          return 42
			        \},
			      \},
			    \}).on(up, s => s + 1)
			
			    const scopeA = fork()
			    allSettled(up, \{scope: scopeA\})
			    expect(scopeA.getState(\$a)).toEqual(1)
			
			    const scopeB = fork(\{
			      values: [[\$a, 6]],
			    \})
			    allSettled(up, \{scope: scopeB\})
			    expect(scopeB.getState(\$a)).toEqual(7)
			
			    expect(parser).toBeCalledTimes(0)
			  \})
			\})
			
			it('serialize stores in nested domain', () => \{
			  const app = createDomain()
			  const first = app.createDomain()
			  const second = app.createDomain()
			  const third = second.createDomain()
			  const \$a = first.createStore('value', \{sid: 'a'\})
			  const \$b = second.createStore([], \{sid: 'b'\})
			  const \$c = third.createStore(null as null | number, \{sid: 'c'\})
			  const \$d = app.createStore(false, \{sid: 'd'\})
			
			  const scope = fork(app, \{
			    values: [
			      [\$a, 'value2'],
			      [\$b, []],
			      [\$c, 0],
			      [\$d, true],
			    ],
			  \})
			  expect(serialize(scope, \{ignore: [\$d, \$a]\})).toEqual(\{
			    b: [],
			    c: 0,
			  \})
			\})
			
			describe('onlyChanges: true', () => \{
			  it('avoid serializing combined stores when they are not changed', async () => \{
			    const newMessage = createEvent()
			    const messages = createStore(0, \{sid: 'messages'\}).on(
			      newMessage,
			      x => x + 1,
			    )
			    const stats = combine(\{messages\})
			    const scope = fork()
			    expect(serialize(scope)).toEqual(\{\})
			    await allSettled(newMessage, \{scope\})
			    expect(serialize(scope)).toEqual(\{messages: 1\})
			  \})
			  it('skip unchanged objects', async () => \{
			    const newMessage = createEvent()
			    const messages = createStore(0, \{sid: 'messages'\}).on(
			      newMessage,
			      x => x + 1,
			    )
			    const scope = fork()
			    expect(serialize(scope)).toEqual(\{\})
			    await allSettled(newMessage, \{scope\})
			    expect(serialize(scope)).toEqual(\{messages: 1\})
			  \})
			
			  it('keep store in serialization when it returns to default state', async () => \{
			    const newMessage = createEvent()
			    const resetMessages = createEvent()
			    const messages = createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			      .reset(resetMessages)
			    const scope = fork()
			    await allSettled(newMessage, \{scope\})
			    await allSettled(resetMessages, \{scope\})
			    expect(serialize(scope)).toEqual(\{messages: 0\})
			  \})
			  it('keep store in serialization when it filled with fork values', async () => \{
			    const newMessage = createEvent()
			    const resetMessages = createEvent()
			    const messages = createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			      .reset(resetMessages)
			    const scope = fork(\{
			      values: [[messages, 1]],
			    \})
			    expect(serialize(scope)).toEqual(\{messages: 1\})
			    await allSettled(resetMessages, \{scope\})
			    expect(serialize(scope)).toEqual(\{messages: 0\})
			  \})
			  it('keep store in serialization when it filled with hydrate values', async () => \{
			    const app = createDomain()
			    const newMessage = app.createEvent()
			    const resetMessages = app.createEvent()
			    const messages = app
			      .createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			      .reset(resetMessages)
			    const scope = fork(app)
			    hydrate(scope, \{
			      values: [[messages, 0]],
			    \})
			    expect(serialize(scope)).toEqual(\{messages: 0\})
			    await allSettled(newMessage, \{scope\})
			    expect(serialize(scope)).toEqual(\{messages: 1\})
			  \})
			
			  describe('serializing combine', () => \{
			    it('should not serialize combine in default case', async () => \{
			      const trigger = createEvent()
			      const foo = createStore(0, \{sid: 'foo'\}).on(trigger, x => x + 1)
			      const bar = createStore(0, \{sid: 'bar'\}).on(trigger, x => x + 1)
			      const combined = combine(\{foo, bar\})
			      const scope = fork()
			      await allSettled(trigger, \{scope\})
			      expect(serialize(scope)).toEqual(\{foo: 1, bar: 1\})
			    \})
			    it('should serialize combine when it updated by on', async () => \{
			      const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			      const trigger = createEvent()
			      const foo = createStore(0, \{sid: 'foo'\})
			      const bar = createStore(0, \{sid: 'bar'\})
			      const combined = combine(\{foo, bar\}).on(trigger, (\{foo, bar\}) => (\{
			        foo: foo + 1,
			        bar: bar + 1,
			      \}))
			      warn.mockRestore()
			      const sid = String(combined.sid)
			      const scope = fork()
			      await allSettled(trigger, \{scope\})
			      expect(serialize(scope)).toEqual(\{
			        [sid]: \{foo: 1, bar: 1\},
			      \})
			    \})
			    describe('don\`t reuse values from user', () => \{
			      test('with sample (more convenient)', async () => \{
			        const triggerA = createEvent()
			        const triggerB = createEvent()
			        const foo = createStore(0, \{sid: 'foo'\})
			        const bar = createStore(0, \{sid: 'bar'\}).on(triggerB, x => x + 10)
			        const combined = combine(\{foo, bar\})
			        sample(\{
			          clock: triggerA,
			          source: combined,
			          target: combined,
			          fn: (\{foo, bar\}) => (\{
			            foo: foo + 1,
			            bar: bar + 1,
			          \}),
			        \})
			
			        const sid = String(combined.sid)
			
			        const scope = fork()
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope)).toEqual(\{[sid]: \{foo: 1, bar: 1\}\})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope)).toEqual(\{bar: 10, [sid]: \{foo: 0, bar: 10\}\})
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope)).toEqual(\{bar: 10, [sid]: \{foo: 1, bar: 11\}\})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope)).toEqual(\{bar: 20, [sid]: \{foo: 0, bar: 20\}\})
			      \})
			      test('with on (less convenient)', async () => \{
			        const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			        const triggerA = createEvent()
			        const triggerB = createEvent()
			        const foo = createStore(0, \{sid: 'foo'\})
			        const bar = createStore(0, \{sid: 'bar'\}).on(triggerB, x => x + 10)
			        const combined = combine(\{foo, bar\})
			        combined.on(triggerA, (\{foo, bar\}) => (\{
			          foo: foo + 1,
			          bar: bar + 1,
			        \}))
			        warn.mockRestore()
			
			        const sid = String(combined.sid)
			
			        const scope = fork()
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope)).toEqual(\{[sid]: \{foo: 1, bar: 1\}\})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope)).toEqual(\{bar: 10, [sid]: \{foo: 0, bar: 10\}\})
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope)).toEqual(\{bar: 10, [sid]: \{foo: 1, bar: 11\}\})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope)).toEqual(\{bar: 20, [sid]: \{foo: 0, bar: 20\}\})
			      \})
			    \})
			  \})
			
			  test('serialize: ignore', async () => \{
			    const app = createDomain()
			    const inc = app.createEvent()
			    const \$a = app.createStore(0, \{sid: 'a', serialize: 'ignore'\})
			    const \$b = app.createStore(0, \{sid: 'b'\})
			    \$a.on(inc, x => x + 1)
			    \$b.on(inc, x => x + 1)
			
			    const scope = fork(app)
			
			    await allSettled(inc, \{scope\})
			
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{b: 1\})
			  \})
			\})
			
			describe('onlyChanges: false', () => \{
			  it('avoid serializing combined stores when they are not changed', async () => \{
			    const app = createDomain()
			    const newMessage = app.createEvent()
			    const messages = app
			      .createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			    const stats = combine(\{messages\})
			    const scope = fork(app)
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 0\})
			    await allSettled(newMessage, \{scope\})
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 1\})
			  \})
			  it('keep unchanged objects', async () => \{
			    const app = createDomain()
			    const newMessage = app.createEvent()
			    const messages = app
			      .createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			    const scope = fork(app)
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 0\})
			    await allSettled(newMessage, \{scope\})
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 1\})
			  \})
			
			  it('keep store in serialization when it returns to default state', async () => \{
			    const app = createDomain()
			    const newMessage = app.createEvent()
			    const resetMessages = app.createEvent()
			    const messages = app
			      .createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			      .reset(resetMessages)
			    const scope = fork(app)
			    await allSettled(newMessage, \{scope\})
			    await allSettled(resetMessages, \{scope\})
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 0\})
			  \})
			  it('keep store in serialization when it filled with fork values', async () => \{
			    const app = createDomain()
			    const newMessage = app.createEvent()
			    const resetMessages = app.createEvent()
			    const messages = app
			      .createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			      .reset(resetMessages)
			    const scope = fork(app, \{
			      values: [[messages, 1]],
			    \})
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 1\})
			    await allSettled(resetMessages, \{scope\})
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 0\})
			  \})
			  it('keep store in serialization when it filled with hydrate values', async () => \{
			    const app = createDomain()
			    const newMessage = app.createEvent()
			    const resetMessages = app.createEvent()
			    const messages = app
			      .createStore(0, \{sid: 'messages'\})
			      .on(newMessage, x => x + 1)
			      .reset(resetMessages)
			    const scope = fork(app)
			    hydrate(scope, \{
			      values: [[messages, 0]],
			    \})
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 0\})
			    await allSettled(newMessage, \{scope\})
			    expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{messages: 1\})
			  \})
			
			  describe('serializing combine', () => \{
			    it('should not serialize combine in default case', async () => \{
			      const app = createDomain()
			      const trigger = app.createEvent()
			      const foo = app.createStore(0, \{sid: 'foo'\}).on(trigger, x => x + 1)
			      const bar = app.createStore(0, \{sid: 'bar'\}).on(trigger, x => x + 1)
			      const combined = combine(\{foo, bar\})
			      const scope = fork(app)
			      await allSettled(trigger, \{scope\})
			      expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{foo: 1, bar: 1\})
			    \})
			    it('should serialize combine when it updated by on', async () => \{
			      const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			      const app = createDomain()
			      const trigger = app.createEvent()
			      const foo = app.createStore(0, \{sid: 'foo'\})
			      const bar = app.createStore(0, \{sid: 'bar'\})
			      const combined = combine(\{foo, bar\}).on(trigger, (\{foo, bar\}) => (\{
			        foo: foo + 1,
			        bar: bar + 1,
			      \}))
			      warn.mockRestore()
			      const sid = String(combined.sid)
			      const scope = fork(app)
			      await allSettled(trigger, \{scope\})
			      expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			        foo: 0,
			        bar: 0,
			        [sid]: \{foo: 1, bar: 1\},
			      \})
			    \})
			    describe('don\`t reuse values from user', () => \{
			      test('with sample (more convenient)', async () => \{
			        const app = createDomain()
			        const triggerA = app.createEvent()
			        const triggerB = app.createEvent()
			        const foo = app.createStore(0, \{sid: 'foo'\})
			        const bar = app.createStore(0, \{sid: 'bar'\}).on(triggerB, x => x + 10)
			        const combined = combine(\{foo, bar\})
			        sample(\{
			          clock: triggerA,
			          source: combined,
			          target: combined,
			          fn: (\{foo, bar\}) => (\{
			            foo: foo + 1,
			            bar: bar + 1,
			          \}),
			        \})
			
			        const sid = String(combined.sid)
			
			        const scope = fork(app)
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 0,
			          [sid]: \{foo: 1, bar: 1\},
			        \})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 10,
			          [sid]: \{foo: 0, bar: 10\},
			        \})
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 10,
			          [sid]: \{foo: 1, bar: 11\},
			        \})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 20,
			          [sid]: \{foo: 0, bar: 20\},
			        \})
			      \})
			      test('with on (less convenient)', async () => \{
			        const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			        const app = createDomain()
			        const triggerA = app.createEvent()
			        const triggerB = app.createEvent()
			        const foo = app.createStore(0, \{sid: 'foo'\})
			        const bar = app.createStore(0, \{sid: 'bar'\}).on(triggerB, x => x + 10)
			        const combined = combine(\{foo, bar\})
			        combined.on(triggerA, (\{foo, bar\}) => (\{
			          foo: foo + 1,
			          bar: bar + 1,
			        \}))
			        warn.mockRestore()
			
			        const sid = String(combined.sid)
			
			        const scope = fork(app)
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 0,
			          [sid]: \{foo: 1, bar: 1\},
			        \})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 10,
			          [sid]: \{foo: 0, bar: 10\},
			        \})
			        await allSettled(triggerA, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 10,
			          [sid]: \{foo: 1, bar: 11\},
			        \})
			        await allSettled(triggerB, \{scope\})
			        expect(serialize(scope, \{onlyChanges: false\})).toEqual(\{
			          foo: 0,
			          bar: 20,
			          [sid]: \{foo: 0, bar: 20\},
			        \})
			      \})
			    \})
			  \})
			\})
			
			test('onlyChanges: false supported only in domain-based scopes', () => \{
			  const scope = fork()
			  expect(() => \{
			    serialize(scope, \{onlyChanges: false\})
			  \}).toThrowErrorMatchingInlineSnapshot(\`"scope should be created from domain"\`)
			\})
			
			describe('serialize: missing sids', () => \{
			  const consoleError = console.error
			  beforeEach(() => \{
			    console.error = jest.fn()
			  \})
			
			  afterEach(() => \{
			    console.error = consoleError
			  \})
			
			  test('serialize: warns about missing sids', () => \{
			    // forcing missing sid
			    // equals to situation, if user forgot to configure babel-plugin
			    // or did not install the sid manually
			    const \$store = createStore('value', \{sid: ''\})
			
			    const scope = fork()
			
			    allSettled(\$store, \{scope, params: 'scope value'\})
			
			    const result = serialize(scope)
			    expect(result).toEqual(\{\})
			    expect(scope.getState(\$store)).toEqual('scope value')
			    expect(console.error).toHaveBeenCalledWith(
			      'There is a store without sid in this scope, its value is omitted',
			    )
			  \})
			  test('serialize: throws if duplicated sids', () => \{
			    const a = createStore(0, \{sid: 'sameSid'\})
			    const b = createStore(0, \{sid: 'sameSid'\})
			
			    const scope = fork(\{
			      values: [
			        [a, 1],
			        [b, 1],
			      ],
			    \})
			
			    expect(() => serialize(scope)).toThrowErrorMatchingInlineSnapshot(
			      \`"duplicate sid found in this scope"\`,
			    )
			  \})
			  test('serialize: doesn not warn, if no sid is missing', () => \{
			    const \$store = createStore('value')
			
			    const scope = fork()
			
			    allSettled(\$store, \{scope, params: 'scope value'\})
			
			    const result = serialize(scope)
			    expect(result).toEqual(\{
			      [\$store.sid as string]: 'scope value',
			    \})
			    expect(scope.getState(\$store)).toEqual('scope value')
			    expect(console.error).toHaveBeenCalledTimes(0)
			  \})
			  test('serialize: doesn not warn on mapped or combined stores', () => \{
			    const \$store = createStore('value')
			    const \$mapped = \$store.map(s => s)
			    // combined stores have sids, but not used in serialize
			    // this trick is needed to hide combine call from plugin
			    const \$combine = \{_: combine\}._(\$store, \$mapped, (_, m) => m)
			
			    const scope = fork()
			
			    allSettled(\$store, \{scope, params: 'scope value'\})
			
			    const result = serialize(scope)
			    expect(\$combine.sid).toEqual(null)
			    expect(scope.getState(\$store)).toEqual('scope value')
			    expect(scope.getState(\$combine)).toEqual('scope value')
			    expect(result).toEqual(\{
			      [\$store.sid as string]: 'scope value',
			    \})
			    expect(console.error).toHaveBeenCalledTimes(0)
			  \})
			  test('serialize: does not warn on internal store changes', async () => \{
			    const sleep = (p: number) => new Promise(r => setTimeout(r, p))
			    const sleepFx = createEffect(sleep)
			    const \$sleep = createStore(1)
			    const sleepAttachedFx = attach(\{
			      source: \$sleep,
			      effect: sleep,
			    \})
			    const start = createEvent<number>()
			
			    sample(\{
			      clock: start,
			      target: [sleepFx, sleepAttachedFx],
			    \})
			
			    const scope = fork()
			
			    await allSettled(start, \{scope, params: 1\})
			
			    const result = serialize(scope)
			    expect(result).toMatchObject(\{\})
			    expect(console.error).toBeCalledTimes(0)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\fork\\serialize.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(34)
    });
    it('effector_effector\\src\\effector\\__tests__\\forward.test.ts', () => {
        const sourceCode = `
			import \{forward, createEvent, createStore, createNode\} from 'effector'
			
			it('should forward data from one event to another', () => \{
			  const fn = jest.fn()
			  const source1 = createEvent<string>()
			  const source2 = createEvent<string>()
			  const target = createEvent<string>()
			
			  target.watch(e => fn(e))
			  const unsubscribe = forward(\{
			    from: source1,
			    to: target,
			  \})
			  forward(\{
			    from: source2,
			    to: target,
			  \})
			  source1('should been forwarded [1]')
			  source2('should been forwarded [2]')
			  expect(fn.mock.calls).toEqual([
			    ['should been forwarded [1]'],
			    ['should been forwarded [2]'],
			  ])
			\})
			
			describe('raw nodes support', () => \{
			  test('single ones', () => \{
			    const from = createNode()
			    const to = createNode()
			    expect(() => \{
			      //@ts-expect-error
			      forward(\{from, to\})
			    \}).not.toThrow()
			  \})
			  test('arrays', () => \{
			    const from = createNode()
			    const to = createNode()
			    expect(() => \{
			      //@ts-expect-error
			      forward(\{from: [from], to: [to]\})
			    \}).not.toThrow()
			  \})
			\})
			
			it('should stop forwarding after unsubscribe', () => \{
			  const fn = jest.fn()
			  const source1 = createEvent<string>()
			  const source2 = createEvent<string>()
			  const target = createEvent<string>()
			
			  target.watch(e => fn(e))
			  const unsubscribe = forward(\{
			    from: source1,
			    to: target,
			  \})
			  forward(\{
			    from: source2,
			    to: target,
			  \})
			  source1('should been forwarded [1]')
			  source2('should been forwarded [2]')
			  expect(fn.mock.calls).toEqual([
			    ['should been forwarded [1]'],
			    ['should been forwarded [2]'],
			  ])
			  unsubscribe()
			  source1('should not been forwarded')
			  expect(fn.mock.calls).toEqual([
			    ['should been forwarded [1]'],
			    ['should been forwarded [2]'],
			  ])
			\})
			
			it('should unsubscribe only from relevant watchers', async () => \{
			  const dispatch = createEvent<string>()
			  const store = createStore<string[]>([])
			  store.on(dispatch, (state, text) => [...state, text])
			  function subscribe(fn: Function) \{
			    let first = true
			    return store.watch(data => \{
			      if (first) \{
			        first = false
			        return
			      \}
			      fn(data)
			    \})
			  \}
			  const listenerA = jest.fn()
			  const listenerB = jest.fn()
			  const listenerC = jest.fn()
			
			  subscribe(listenerA)
			  const unSubB = subscribe((data: any) => \{
			    listenerB(data)
			    unSubB()
			  \})
			  subscribe(listenerC)
			
			  dispatch('item 1')
			  dispatch('item 2')
			
			  expect(listenerA.mock.calls.length).toBe(2)
			  expect(listenerB.mock.calls.length).toBe(1)
			  expect(listenerC.mock.calls.length).toBe(2)
			\})
			
			describe('array forwarding support', () => \{
			  it('support forwarding to arrays', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const s1 = createEvent()
			    const t1 = createEvent()
			    const t2 = createEvent()
			    t1.watch(fn1)
			    t2.watch(fn2)
			    forward(\{
			      from: s1,
			      to: [t1, t2],
			    \})
			    s1()
			    expect(fn1).toBeCalledTimes(1)
			    expect(fn2).toBeCalledTimes(1)
			  \})
			  it('support forwarding from arrays', () => \{
			    const fn = jest.fn()
			    const s1 = createEvent()
			    const s2 = createEvent()
			    const t1 = createEvent()
			    t1.watch(fn)
			    forward(\{
			      from: [s1, s2],
			      to: t1,
			    \})
			    s1()
			    s2()
			    expect(fn).toBeCalledTimes(2)
			  \})
			  it('support forwarding from arrays to arrays', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const s1 = createEvent()
			    const s2 = createEvent()
			    const t1 = createEvent()
			    const t2 = createEvent()
			    t1.watch(fn1)
			    t2.watch(fn2)
			    forward(\{
			      from: [s1, s2],
			      to: [t1, t2],
			    \})
			    s1()
			    s2()
			    expect(fn1).toBeCalledTimes(2)
			    expect(fn2).toBeCalledTimes(2)
			  \})
			\})
			it('should validate arguments', () => \{
			  expect(() => \{
			    //@ts-expect-error
			    forward(\{\})
			  \}).toThrowErrorMatchingInlineSnapshot(
			    \`"forward: expect \\\\"from\\\\" to be a unit (store, event or effect) or array of units"\`,
			  )
			  expect(() => \{
			    //@ts-expect-error
			    forward(\{from: createStore(null)\})
			  \}).toThrowErrorMatchingInlineSnapshot(
			    \`"forward: expect \\\\"to\\\\" to be a unit (store, event or effect) or array of units"\`,
			  )
			  expect(() => \{
			    //@ts-expect-error
			    forward(\{to: createStore(null)\})
			  \}).toThrowErrorMatchingInlineSnapshot(
			    \`"forward: expect \\\\"from\\\\" to be a unit (store, event or effect) or array of units"\`,
			  )
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\forward.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\effector\\__tests__\\guard.test.ts', () => {
        const sourceCode = `
			import \{
			  guard,
			  createEvent,
			  createStore,
			  createApi,
			  is,
			  createEffect,
			  sample,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('use case', () => \{
			  const clickRequest = createEvent()
			  const fetchRequest = createEffect<number, number>(
			    n => new Promise(rs => setTimeout(rs, 500, n)),
			  )
			  const clicks = createStore(0).on(clickRequest, x => x + 1)
			
			  const isIdle = fetchRequest.pending.map(pending => !pending)
			
			  guard(\{
			    source: sample(clicks, clickRequest),
			    filter: isIdle,
			    target: fetchRequest,
			  \})
			
			  // or
			
			  sample(\{
			    source: clicks,
			    clock: guard(clickRequest, \{
			      filter: isIdle,
			    \}),
			    target: fetchRequest,
			  \})
			
			  // or
			
			  sample(\{
			    source: clicks,
			    clock: guard(\{
			      source: sample(fetchRequest.pending, clickRequest),
			      filter: pending => !pending,
			    \}),
			    target: fetchRequest,
			  \})
			\})
			
			describe('without target', () => \{
			  it('returns event', () => \{
			    const trigger = createEvent()
			    const unlocked = createStore(true)
			    const target = guard(trigger, \{
			      filter: unlocked,
			    \})
			    expect(is.event(target)).toBe(true)
			  \})
			  it('supports store guards', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<string>()
			    const unlocked = createStore(true)
			    const \{lock, unlock\} = createApi(unlocked, \{
			      lock: () => false,
			      unlock: () => true,
			    \})
			    const target = guard(trigger, \{
			      filter: unlocked,
			    \})
			
			    target.watch(fn)
			    trigger('A')
			    lock()
			    trigger('B')
			    unlock()
			    trigger('C')
			
			    expect(argumentHistory(fn)).toEqual(['A', 'C'])
			  \})
			
			  it('supports function predicate', () => \{
			    const fn = jest.fn()
			    const source = createEvent<number>()
			    const target = guard(source, \{
			      filter: x => x > 0,
			    \})
			
			    target.watch(fn)
			
			    source(0)
			    source(1)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			\})
			
			describe('with target', () => \{
			  it('supports store guards', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<string>()
			    const target = createEvent()
			    const unlocked = createStore(true)
			    const \{lock, unlock\} = createApi(unlocked, \{
			      lock: () => false,
			      unlock: () => true,
			    \})
			
			    guard(\{
			      source: trigger,
			      filter: unlocked,
			      target,
			    \})
			
			    target.watch(fn)
			    trigger('A')
			    lock()
			    trigger('B')
			    unlock()
			    trigger('C')
			
			    expect(argumentHistory(fn)).toEqual(['A', 'C'])
			  \})
			
			  it('supports function predicate', () => \{
			    const fn = jest.fn()
			    const source = createEvent<number>()
			    const target = createEvent()
			    target.watch(fn)
			
			    guard(\{
			      source,
			      filter: x => x > 0,
			      target,
			    \})
			
			    source(0)
			    source(1)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			\})
			
			describe('source as object support', () => \{
			  test('with store guard', () => \{
			    expect(() => \{
			      guard(\{
			        source: \{
			          a: createStore(0),
			          b: createStore(0),
			        \},
			        filter: createStore(true),
			      \})
			    \}).not.toThrow()
			  \})
			  test('with function guard', () => \{
			    expect(() => \{
			      guard(\{
			        source: \{
			          a: createStore(0),
			          b: createStore(0),
			        \},
			        filter: () => true,
			      \})
			    \}).not.toThrow()
			  \})
			\})
			
			test('temporal consistency', () => \{
			  const fn = jest.fn()
			  const trigger = createEvent<number>()
			  const target = createEvent<number>()
			  const filter = trigger.map(x => x > 0)
			  guard(\{
			    source: trigger,
			    //@ts-expect-error
			    filter,
			    target,
			  \})
			
			  target.watch(fn)
			  // trigger(1)
			  trigger(0)
			  trigger(2)
			
			  expect(argumentHistory(fn)).toEqual([2])
			\})
			
			describe('clock support', () => \{
			  it('support event as clock', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent()
			    const target = createEvent<number>()
			    const source = createStore(1).on(target, x => x + 1)
			    target.watch(fn)
			    guard(\{
			      source,
			      clock: trigger,
			      filter: createStore(true),
			      target,
			    \})
			    trigger()
			    trigger()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			  it('support arrays as clock', () => \{
			    const fn = jest.fn()
			    const trigger1 = createEvent()
			    const trigger2 = createEvent()
			    const target = createEvent<number>()
			    const source = createStore(1).on(target, x => x + 1)
			    target.watch(fn)
			    guard(\{
			      source,
			      clock: [trigger1, trigger2],
			      filter: createStore(true),
			      target,
			    \})
			    trigger1()
			    trigger2()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			  test('value from clock will be passed to second argument of filter', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<\{n: number\}>()
			    const target = createEvent<\{n: number\}>()
			    const source = createStore(\{n: 0\}).on(target, (src, \{n\}) => (\{
			      n: src.n + n,
			    \}))
			    source.updates.watch(fn)
			    sample(\{
			      source: trigger,
			      clock: guard(\{
			        source,
			        clock: trigger,
			        filter: (source, clock) => (source.n + clock.n) % 2 === 0,
			      \}),
			      target,
			    \})
			    trigger(\{n: 6\})
			    trigger(\{n: 5\})
			    trigger(\{n: 4\})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "n": 6,
			        \},
			        Object \{
			          "n": 10,
			        \},
			      ]
			    \`)
			  \})
			\})
			
			describe('support clock without source', () => \{
			  test('it works with clock unit', () => \{
			    const fn = jest.fn()
			    const clockA = createEvent<number>()
			    const target = createEvent<number>()
			    target.watch(fn)
			    const result = guard(\{
			      clock: clockA,
			      filter: n => n % 2 !== 0,
			      target,
			    \})
			    clockA(1)
			    clockA(2)
			    clockA(3)
			    expect(result === target).toBe(true)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        3,
			      ]
			    \`)
			  \})
			  test('it works with clock array', () => \{
			    const fn = jest.fn()
			    const clockA = createEvent<number>()
			    const clockB = createEvent<number>()
			    const target = createEvent<number>()
			    target.watch(fn)
			    const result = guard(\{
			      clock: [clockA, clockB],
			      filter: n => n % 2 !== 0,
			      target,
			    \})
			    clockA(1)
			    clockB(4)
			    clockB(5)
			    expect(result === target).toBe(true)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        5,
			      ]
			    \`)
			  \})
			\})
			
			describe('validation', () => \{
			  test('valid case without clock', () => \{
			    const source = createEvent<any>()
			    const filter = createStore(true)
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      guard(\{source, filter, target\})
			    \}).not.toThrow()
			  \})
			  test('valid case without source', () => \{
			    const clock = createEvent<any>()
			    const filter = createStore(true)
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      guard(\{clock, filter, target\})
			    \}).not.toThrow()
			  \})
			  test('source validation', () => \{
			    const filter = createStore(true)
			    const target = createEffect((_: any) => \{\})
			    expect(() => \{
			      guard(\{source: undefined, filter, target\})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"guard: source should be defined"\`)
			  \})
			  test('clock validation', () => \{
			    const filter = createStore(true)
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      guard(\{clock: undefined, filter, target\})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"guard: clock should be defined"\`)
			  \})
			  test('no source no clock', () => \{
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      //@ts-expect-error
			      guard(\{target\})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"guard: either source or clock should be defined"\`,
			    )
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\guard.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(19)
    });
    it('effector_effector\\src\\effector\\__tests__\\imperativeCalls.test.ts', () => {
        const sourceCode = `
			import \{createEvent, sample, createStore, combine\} from 'effector'
			
			let warn: jest.SpyInstance<void, [message?: any, ...optionalParams: any[]]>
			beforeEach(() => \{
			  warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			\})
			afterEach(() => \{
			  warn.mockRestore()
			\})
			
			function getWarning() \{
			  return warn.mock.calls.map(([msg]) => msg)[0]
			\}
			
			describe('store', () => \{
			  test('.on', () => \{
			    const trigger = createEvent()
			    const event = createEvent()
			    const \$x = createStore(0).on(trigger, x => \{
			      event()
			    \})
			    trigger()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			  test('.map', () => \{
			    const trigger = createEvent()
			    const event = createEvent()
			    const \$x = createStore(0).on(trigger, x => x + 1)
			    const \$y = \$x.map(x => \{
			      event()
			      return x
			    \})
			    trigger()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			  test('updateFilter', () => \{
			    const trigger = createEvent()
			    const event = createEvent()
			    const \$x = createStore(0, \{
			      updateFilter() \{
			        event()
			        return true
			      \},
			    \}).on(trigger, x => x + 1)
			    trigger()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			\})
			
			describe('event', () => \{
			  test('.map', () => \{
			    const event = createEvent()
			    const x = createEvent()
			    const y = x.map(() => \{
			      event()
			    \})
			    x()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			  test('.prepend', () => \{
			    const event = createEvent()
			    const y = createEvent()
			    const x = y.prepend(() => \{
			      event()
			    \})
			    x()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			  test('.filterMap', () => \{
			    const event = createEvent()
			    const x = createEvent()
			    const y = x.filterMap(() => \{
			      event()
			    \})
			    x()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			\})
			
			test('combine', () => \{
			  const trigger = createEvent()
			  const event = createEvent()
			  const \$x = createStore(0).on(trigger, x => x + 1)
			  const \$comb = combine(\$x, x => \{
			    event()
			    return x
			  \})
			  trigger()
			  expect(getWarning()).toMatchInlineSnapshot(
			    \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			  )
			\})
			
			describe('sample', () => \{
			  test('fn', () => \{
			    const trigger = createEvent()
			    const event = createEvent()
			    sample(\{
			      clock: trigger,
			      fn() \{
			        event()
			      \},
			    \})
			    trigger()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			  test('filter', () => \{
			    const trigger = createEvent()
			    const event = createEvent()
			    sample(\{
			      clock: trigger,
			      filter() \{
			        event()
			        return true
			      \},
			    \})
			    trigger()
			    expect(getWarning()).toMatchInlineSnapshot(
			      \`"unit call from pure function is deprecated, use operators like sample instead"\`,
			    )
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\imperativeCalls.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\effector\\__tests__\\index.test.ts', () => {
        const sourceCode = `
			import \{from\} from 'most'
			
			import \{
			  createStore,
			  Store,
			  combine,
			  createEvent,
			  createEffect,
			  Event,
			\} from 'effector'
			//@ts-expect-error
			import \{show\} from 'effector/fixtures/showstep'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('graphite', () => \{
			  const fn = jest.fn()
			  const fn1 = jest.fn()
			  const foo: Event<number> = createEvent('foo')
			  const bar = foo.map(x => (fn(x), x + 1))
			  const store1: Store<string> = createStore('foo').on(bar, (state, bar) =>
			    [state, bar].join(' | '),
			  )
			  const store2 = store1.map(e => e.length)
			  const unsub1 = bar.watch(fn1)
			  foo(0)
			  foo(10)
			  expect(fn).toHaveBeenCalledTimes(2)
			  expect(store1.getState()).toBe('foo | 1 | 11')
			  //@ts-expect-error
			  const showBar = show(bar.graphite)
			
			  expect(showBar).toMatchSnapshot('show bar')
			  unsub1()
			  //@ts-expect-error
			  const showBar2 = show(bar.graphite)
			  expect(showBar2).toMatchSnapshot('show bar')
			  foo(100)
			  expect(fn1).toHaveBeenCalledTimes(2)
			  //@ts-expect-error
			  const showFoo = show(foo.graphite)
			  //@ts-expect-error
			  const showStore = show(store1.graphite)
			  //@ts-expect-error
			  const showStore2 = show(store2.graphite)
			  expect(showFoo).toMatchSnapshot('show foo')
			  expect(showStore).toMatchSnapshot('show store1')
			  expect(showStore2).toMatchSnapshot('show store2')
			\})
			
			test('showcase', () => \{
			  const fn = jest.fn()
			  const foo = createEvent('foo')
			  const bar = createEvent('bar')
			
			  const a = createStore(1)
			  const b = createStore(2)
			  const bigStore = combine(\{a, b\})
			  const mapped = bigStore.map(s => s.a)
			
			  a.on(foo, n => n + 1)
			  b.on(bar, n => n + 1)
			
			  mapped.watch(fn)
			
			  foo()
			  foo()
			
			  bar()
			  bar()
			  bar()
			  bar()
			
			  //@ts-expect-error
			  expect(show(a.graphite)).toMatchSnapshot('store a')
			  //@ts-expect-error
			  expect(show(foo.graphite)).toMatchSnapshot('event foo')
			  //@ts-expect-error
			  expect(show(mapped.graphite)).toMatchSnapshot('mapped')
			  expect(fn).toHaveBeenCalledTimes(3)
			  const first = createStore('s')
			  const second = createStore('h')
			  const third = createStore('i')
			  const status = combine(first, second, third, (a, b, c) => [a, b, c].join(''))
			  expect(status.getState()).toBe('shi')
			\})
			
			describe('symbol-observable support', () => \{
			  test('from(store)', async () => \{
			    const fn = jest.fn()
			    expect(() => \{
			      from(createStore(0))
			    \}).not.toThrow()
			    const store1 = createStore(-1)
			    const ev1 = createEvent<string>()
			    const ev2 = createEvent<string>()
			    const store1\$ = from(store1)
			    store1\$.observe(fn)
			    store1.on(ev1, state => state + 1)
			    ev1('foo')
			    ev1('bar')
			    ev1('baz')
			    ev2('should ignore')
			
			    expect(argumentHistory(fn)).toEqual([-1, 0, 1, 2])
			    expect(fn).toHaveBeenCalledTimes(4)
			    expect(store1.getState()).toBe(2)
			  \})
			  describe('from(effect)', () => \{
			    test('without implementation', async () => \{
			      const fn = jest.fn()
			      expect(() => \{
			        from(createEffect())
			      \}).not.toThrow()
			      const ev1 = createEffect((_: number) => \{\})
			      const ev2 = createEffect((_: string) => \{\})
			      const ev1\$ = from(ev1)
			      ev1\$.observe(fn)
			      ev1(0)
			      ev1(1)
			      ev1(2)
			      ev2('should ignore')
			      expect(fn).toHaveBeenCalledTimes(3)
			
			      expect(argumentHistory(fn)).toEqual([0, 1, 2])
			    \})
			
			    test('with implementation', async () => \{
			      const fn = jest.fn()
			      expect(() => \{
			        async function impl() \{\}
			        const eff1 = createEffect()
			        eff1.use(impl)
			        from(eff1)
			      \}).not.toThrow()
			      const ev1 = createEffect((_: number) => \{\})
			      const ev2 = createEffect((_: string) => \{\})
			      async function impl() \{\}
			      ev1.use(impl)
			      const ev1\$ = from(ev1)
			      ev1\$.observe(fn)
			      ev1(0)
			      ev1(1)
			      ev1(2)
			      ev2('should ignore')
			      expect(fn).toHaveBeenCalledTimes(3)
			
			      expect(argumentHistory(fn)).toEqual([0, 1, 2])
			    \})
			  \})
			\})
			
			test('attt', () => \{
			  const state = createStore(\{
			    foo: 1,
			    bar: [0],
			  \})
			  const e1 = createEvent<string>()
			  expect(state.getState()).toMatchObject(\{
			    foo: 1,
			    bar: [0],
			  \})
			  state.on(e1, (state, payload) => (\{
			    foo: parseInt(payload, 36),
			    bar: [...state.bar, parseInt(payload, 36)],
			  \}))
			  e1('10')
			  expect(state.getState()).toMatchObject(\{
			    foo: 36,
			    bar: [0, 36],
			  \})
			  e1('11')
			  expect(state.getState()).toMatchObject(\{
			    foo: 37,
			    bar: [0, 36, 37],
			  \})
			\})
			
			test('createStore', () => \{
			  const counter = createStore(0)
			  const text = createStore('')
			  const store = combine(\{counter, text, foo: 'bar'\})
			  expect(store.getState()).toMatchObject(\{counter: 0, text: '', foo: 'bar'\})
			\})
			
			describe('store.on', () => \{
			  test('store.on(event)', () => \{
			    const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			    const counter = createStore(0)
			    const text = createStore('')
			    const store = combine(\{counter, text, foo: 'bar'\})
			
			    const e1 = createEvent<string>()
			    store.on(e1, (state, payload) => (\{
			      ...state,
			      foo: payload,
			    \}))
			    warn.mockRestore()
			
			    expect(store.getState()).toMatchObject(\{counter: 0, text: '', foo: 'bar'\})
			    e1('baz')
			    expect(store.getState()).toMatchObject(\{counter: 0, text: '', foo: 'baz'\})
			  \})
			  test('store.on(effect)', async () => \{
			    const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			    const counter = createStore(0)
			    const text = createStore('')
			    const store = combine(\{counter, text, foo: 0\})
			    const e1 = createEffect<number, number>(
			      n => new Promise(_ => setTimeout(_, n, n)),
			    )
			    store.on(e1.done, (state, \{result\}) => (\{
			      ...state,
			      foo: result,
			    \}))
			    warn.mockRestore()
			
			    expect(store.getState()).toMatchObject(\{counter: 0, text: '', foo: 0\})
			    const result = await e1(50)
			    expect(result).toBe(50)
			    expect(store.getState()).toMatchObject(\{counter: 0, text: '', foo: 50\})
			  \})
			\})
			
			test('store.watch', () => \{
			  const click = createEvent<string | void>()
			  const store1 = createStore(-1)
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  store1.watch(fn1)
			  store1.on(click, (state, e) => (fn2(state, e), state))
			  click()
			  click('a')
			  click('b')
			  expect(store1.getState()).toBe(-1)
			
			  expect(fn1).not.toHaveBeenCalledTimes(2)
			  expect(fn2).toHaveBeenCalledTimes(3)
			
			  expect(fn1).toHaveBeenCalledTimes(1)
			  expect(fn2.mock.calls).toEqual([
			    [-1, undefined],
			    [-1, 'a'],
			    [-1, 'b'],
			  ])
			  expect(argumentHistory(fn1)).toEqual([-1])
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(10)
    });
    it('effector_effector\\src\\effector\\__tests__\\inspect.test.ts', () => {
        const sourceCode = `
			import \{inspect, Message, inspectGraph, Declaration\} from 'effector/inspect'
			import \{
			  createEvent,
			  createStore,
			  sample,
			  fork,
			  allSettled,
			  createEffect,
			  combine,
			  withRegion,
			  createNode,
			  split,
			  attach,
			  guard,
			  forward,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			import \{performance\} from 'perf_hooks'
			import \{withFactory\} from '../region'
			
			function compactMessage(m: Message) \{
			  return \`\$\{m.type\} of '\$\{m.name\}' [\$\{m.kind\}] to value of '\$\{
			    m.value
			  \}' (id:\$\{typeof m.id\}, sid:\$\{typeof m.sid\}, loc:\$\{typeof m.loc\}, meta:\$\{typeof m.meta\}, meta.id:\$\{typeof m
			    .meta.id\}, meta.rootStateRefId:\$\{typeof m.meta.rootStateRefId\})\`
			\}
			
			describe('inspect API', () => \{
			  test('should be possible to track chain of events', async () => \{
			    const start = createEvent()
			    const \$a = createStore(0).on(start, s => s + 1)
			    const \$b = \$a.map(s => s + 1)
			    const myFx = createEffect(async () => \{
			      // ok
			    \})
			    const attachedFx = attach(\{
			      effect: myFx,
			    \})
			    const attachedFnFx = attach(\{
			      source: \$a,
			      effect: async () => \{
			        // ok
			      \},
			    \})
			
			    const end = createEvent()
			
			    sample(\{
			      source: [\$a, \$b],
			      clock: start,
			      fn: ([a, b]) => a + b,
			      target: [end, myFx, attachedFx, attachedFnFx],
			    \})
			
			    const evs = split(myFx.doneData, \{
			      a: () => true,
			    \})
			
			    guard(\{
			      clock: attachedFnFx.doneData,
			      filter: () => true,
			      target: end,
			    \})
			    forward(\{
			      from: attachedFnFx.done,
			      to: end,
			    \})
			
			    const trackMock = jest.fn()
			    inspect(\{
			      fn: m => trackMock(compactMessage(m)),
			    \})
			
			    start()
			
			    await new Promise(r => setTimeout(r))
			
			    expect(argumentHistory(trackMock).length).toBeGreaterThan(0)
			    expect(argumentHistory(trackMock)).toMatchInlineSnapshot(\`
			      Array [
			        "update of 'start' [event] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of '\$a' [store] to value of '1' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '2' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of '\$a → *' [store] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [combine] to value of '1,2' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'combine(\$a, \$a → *)' [store] to value of '1,2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1,2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [sample] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'end' [event] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'myFx' [effect] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'myFx.inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'true' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'attachedFx' [effect] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'attachedFx.inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'true' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'attachedFnFx' [effect] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'attachedFnFx.inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'true' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [fx] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [fx] to value of '[object Object]' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'myFx' [effect] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '2' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'myFx.inFlight' [store] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '2' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'true' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'undefined' [fx] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [fx] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'finally' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of '[object Object]' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'done' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'doneData' [event] to value of 'undefined' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [split] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'cases.a' [event] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'myFx.inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'true' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'true' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'undefined' [fx] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'finally' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of '[object Object]' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'done' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [forward] to value of '[object Object]' (id:string, sid:undefined, loc:object, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'doneData' [event] to value of 'undefined' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'end' [event] to value of '[object Object]' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [guard] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '0' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'attachedFnFx.inFlight' [store] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '0' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'false' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'false' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of 'false' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [guard] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'end' [event] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [fx] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'finally' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of '[object Object]' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'done' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'doneData' [event] to value of 'undefined' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [split] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'cases.a' [event] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '0' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'myFx.inFlight' [store] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '0' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'false' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'false' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of 'false' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [fx] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'finally' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of '[object Object]' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [filterMap] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'done' [event] to value of '[object Object]' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'doneData' [event] to value of 'undefined' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '0' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'attachedFx.inFlight' [store] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '0' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'inFlight' [store] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '0' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of 'false' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'pending' [store] to value of 'false' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of 'false' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [fx] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			      ]
			    \`)
			  \})
			
			  test('should be possible to track chain of events in specific scope', () => \{
			    const start = createEvent<string>()
			    const \$a = createStore(0).on(start, s => s + 1)
			    const \$b = \$a.map(s => s + 1)
			
			    const end = createEvent()
			
			    sample(\{
			      source: [\$a, \$b],
			      clock: start,
			      fn: ([a, b]) => a + b,
			      target: end,
			    \})
			
			    const scopeToTrack = fork()
			    const anotherScope = fork()
			
			    const trackMock = jest.fn()
			    inspect(\{
			      scope: scopeToTrack,
			      fn: m => trackMock(compactMessage(m)),
			    \})
			
			    start('SHOULD_NOT_BE_TRACKED')
			    allSettled(start, \{scope: scopeToTrack, params: 'MUST_BE_TRACKED'\})
			    allSettled(start, \{scope: anotherScope, params: 'SHOULD_NOT_BE_TRACKED'\})
			
			    expect(argumentHistory(trackMock).length).toBeGreaterThan(0)
			    // We explicitly said, which scope computes we want to track
			    expect(
			      argumentHistory(trackMock).join(',').includes('SHOULD_NOT_BE_TRACKED'),
			    ).toBe(false)
			    expect(
			      argumentHistory(trackMock).join(',').includes('MUST_BE_TRACKED'),
			    ).toBe(true)
			    expect(argumentHistory(trackMock)).toMatchInlineSnapshot(\`
			      Array [
			        "update of 'start' [event] to value of 'MUST_BE_TRACKED' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '2' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of '\$a' [store] to value of '2' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [undefined] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [map] to value of '3' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of '\$a → *' [store] to value of '3' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '3' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [combine] to value of '2,3' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'combine(\$a, \$a → *)' [store] to value of '2,3' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '2,3' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [sample] to value of '5' (id:string, sid:string, loc:object, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of 'end' [event] to value of '5' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [undefined] to value of 'undefined' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			      ]
			    \`)
			  \})
			
			  test('unsub should work', () => \{
			    const up = createEvent()
			    const \$count = createStore(0).on(up, s => s + 1)
			
			    const trackMock = jest.fn()
			    const unsub = inspect(\{
			      fn: m => trackMock(compactMessage(m)),
			    \})
			
			    up()
			    up()
			    const currentHistory = [...argumentHistory(trackMock)]
			    expect(currentHistory).toMatchInlineSnapshot(\`
			      Array [
			        "update of 'up' [event] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '1' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of '\$count' [store] to value of '1' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '1' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'up' [event] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "update of 'undefined' [on] to value of '2' (id:string, sid:undefined, loc:undefined, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "update of '\$count' [store] to value of '2' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:string)",
			        "update of 'updates' [event] to value of '2' (id:string, sid:object, loc:undefined, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			      ]
			    \`)
			
			    unsub()
			
			    up()
			
			    const nextHistory = [...argumentHistory(trackMock)]
			    expect(nextHistory).toEqual(currentHistory)
			    expect(\$count.getState()).toEqual(3)
			  \})
			
			  test('trace should work', () => \{
			    const start = createEvent()
			    const \$a = createStore(0).on(start, s => s + 1)
			    const \$b = \$a.map(s => s + 1)
			
			    const end = createEvent()
			
			    sample(\{
			      source: [\$a, \$b],
			      clock: start,
			      fn: ([a, b]) => a + b,
			      target: end,
			    \})
			
			    const trackMock = jest.fn()
			    inspect(\{
			      trace: true,
			      fn: m => \{
			        if (m.sid === end.sid) \{
			          trackMock(compactMessage(m))
			          m.trace!.forEach(trace => \{
			            trackMock(\`<- \$\{compactMessage(trace)\}\`)
			          \})
			        \}
			      \},
			    \})
			
			    start()
			
			    expect(argumentHistory(trackMock).length).toBeGreaterThan(0)
			    expect(argumentHistory(trackMock)).toMatchInlineSnapshot(\`
			      Array [
			        "update of 'end' [event] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			        "<- update of 'undefined' [sample] to value of '3' (id:string, sid:string, loc:object, meta:object, meta.id:undefined, meta.rootStateRefId:undefined)",
			        "<- update of 'start' [event] to value of 'undefined' (id:string, sid:string, loc:object, meta:object, meta.id:string, meta.rootStateRefId:undefined)",
			      ]
			    \`)
			  \})
			\})
			
			function compactDeclaration(d: Declaration) \{
			  if (d.type === 'region') return \`region, parent: \$\{typeof d.region\}\`
			  if (d.type === 'factory')
			    return \`factory, \$\{d.method\}, \$\{d.sid\}, \$\{
			      d.name
			    \}, parent: \$\{typeof d.region\}\`
			
			  return \`\$\{d.derived ? 'derived ' : ''\}\$\{d.type\} \$\{d.name\} (\$\{
			    d.kind
			  \}) created (sid \$\{typeof d.sid\}, parent region: \$\{typeof d.region\}, id: \$\{typeof d.id\}, loc: \$\{typeof d.loc\}, meta.id:\$\{typeof d
			    .meta.id\}, meta.rootStateRefId:\$\{typeof d.meta.rootStateRefId\})\`
			\}
			
			describe('inspectGraph API', () => \{
			  test('should work', () => \{
			    const declMock = jest.fn()
			    const unsub = inspectGraph(\{
			      fn: d => declMock(compactDeclaration(d)),
			    \})
			
			    const event1 = createEvent()
			    const \$store2 = createStore(0)
			    const effectFx = createEffect(() => \{\})
			    const \$store3 = \$store2.map(x => x)
			    const event4 = event1.map(x => x)
			    const event5 = event1.prepend(x => x)
			    const \$store6 = combine([\$store2, \$store3])
			
			    expect(argumentHistory(declMock).length).toBeGreaterThan(0)
			    const history = [...argumentHistory(declMock)]
			    expect(history).toMatchInlineSnapshot(\`
			      Array [
			        "unit event1 (event) created (sid string, parent region: undefined, id: string, loc: object, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit updates (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "unit reinit (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "unit \$store2 (store) created (sid string, parent region: undefined, id: string, loc: object, meta.id:string, meta.rootStateRefId:string)",
			        "unit effectFx (effect) created (sid string, parent region: undefined, id: string, loc: object, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit finally (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit done (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit fail (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit doneData (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit failData (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit updates (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "unit reinit (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "unit effectFx.inFlight (store) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:string)",
			        "derived unit updates (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit inFlight (store) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:string)",
			        "derived unit updates (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit pending (store) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:string)",
			        "derived unit updates (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit \$store2 → * (store) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:string)",
			        "derived unit event1 → * (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "unit * → event1 (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit updates (event) created (sid object, parent region: undefined, id: string, loc: undefined, meta.id:string, meta.rootStateRefId:undefined)",
			        "derived unit \$store6 (store) created (sid string, parent region: undefined, id: string, loc: object, meta.id:string, meta.rootStateRefId:string)",
			      ]
			    \`)
			
			    unsub()
			
			    const event2 = createEvent()
			    const \$store1 = createStore(0)
			    const effFx = createEffect(() => \{\})
			
			    expect(argumentHistory(declMock)).toEqual(history)
			  \})
			  describe('region support', () => \{
			    test('one-level withRegion', () => \{
			      function customOperator(config: Record<string, unknown>) \{
			        withRegion(
			          createNode(\{
			            meta: \{
			              myLibType: 'customOperator',
			              myLibConfig: config,
			            \},
			          \}),
			          () => \{
			            const internalEvent = createEvent()
			          \},
			        )
			      \}
			
			      const declared = jest.fn()
			      const nonRegionalUnitDeclared = jest.fn()
			      const regionalUnitDeclared = jest.fn()
			      inspectGraph(\{
			        fn: d => \{
			          declared(\`\$\{d.type\} \$\{d.name\} created\`)
			          if (!d.region) \{
			            nonRegionalUnitDeclared()
			          \} else \{
			            regionalUnitDeclared(d.region.meta)
			          \}
			        \},
			      \})
			
			      const \$source = createStore(0)
			      const targetEvent = createEvent()
			
			      customOperator(\{
			        source: \$source,
			        target: targetEvent,
			      \})
			
			      expect(regionalUnitDeclared).toHaveBeenCalledTimes(1)
			      expect(regionalUnitDeclared).toHaveBeenCalledWith(\{
			        myLibType: 'customOperator',
			        myLibConfig: \{
			          source: \$source,
			          target: targetEvent,
			        \},
			      \})
			      expect(argumentHistory(declared)).toMatchInlineSnapshot(\`
			        Array [
			          "unit updates created",
			          "unit reinit created",
			          "unit \$source created",
			          "unit targetEvent created",
			          "unit internalEvent created",
			          "region undefined created",
			        ]
			      \`)
			    \})
			    test('one-level withFactory', () => \{
			      function customOperator(config: Record<string, unknown>) \{
			        const internalEvent = createEvent()
			      \}
			
			      const declared = jest.fn()
			      const nonRegionalUnitDeclared = jest.fn()
			      const regionalUnitDeclared = jest.fn()
			      inspectGraph(\{
			        fn: d => \{
			          declared(\`\$\{d.type\} \$\{d.name\} created\`)
			          if (!d.region) \{
			            nonRegionalUnitDeclared()
			          \} else \{
			            regionalUnitDeclared(d.region.meta)
			          \}
			        \},
			      \})
			
			      const \$source = createStore(0)
			      const targetEvent = createEvent()
			
			      withFactory(\{
			        sid: 'customOperator-call-1',
			        method: 'customOperator',
			        name: 'test-name',
			        fn: () =>
			          customOperator(\{
			            source: \$source,
			            target: targetEvent,
			          \}),
			      \})
			      expect(regionalUnitDeclared).toHaveBeenCalledTimes(1)
			      expect(regionalUnitDeclared).toHaveBeenCalledWith(
			        expect.objectContaining(\{
			          sid: 'customOperator-call-1',
			          method: 'customOperator',
			        \}),
			      )
			      expect(argumentHistory(declared)).toMatchInlineSnapshot(\`
			        Array [
			          "unit updates created",
			          "unit reinit created",
			          "unit \$source created",
			          "unit targetEvent created",
			          "unit internalEvent created",
			          "factory test-name created",
			        ]
			      \`)
			    \})
			    test('nested regions', () => \{
			      function customOperator(config: Record<string, unknown>) \{
			        withRegion(createNode(\{meta: \{region: 'outer'\}\}), () => \{
			          withRegion(createNode(\{meta: \{region: 'inner'\}\}), () => \{
			            const internalEvent = createEvent()
			          \})
			        \})
			      \}
			
			      const declared = jest.fn()
			      const nonRegionalUnitDeclared = jest.fn()
			      const regionalUnitDeclared = jest.fn()
			      inspectGraph(\{
			        fn: d => \{
			          declared(\`\$\{d.type\} \$\{d.name\} created\`)
			          if (d.type === 'unit') \{
			            if (!d.region) \{
			              nonRegionalUnitDeclared()
			            \} else \{
			              regionalUnitDeclared(d.region)
			            \}
			          \}
			        \},
			      \})
			
			      const \$source = createStore(0)
			      const targetEvent = createEvent()
			
			      withFactory(\{
			        sid: 'customOperator-call-1',
			        method: 'customOperator',
			        name: 'test-name',
			        fn: () =>
			          customOperator(\{
			            source: \$source,
			            target: targetEvent,
			          \}),
			      \})
			
			      expect(regionalUnitDeclared).toHaveBeenCalledTimes(1)
			      expect(regionalUnitDeclared).toHaveBeenCalledWith(\{
			        type: 'region',
			        id: expect.any(String),
			        meta: \{
			          region: 'inner',
			        \},
			        region: \{
			          type: 'region',
			          id: expect.any(String),
			          meta: \{region: 'outer'\},
			          region: \{
			            type: 'factory',
			            id: expect.any(String),
			            region: undefined,
			            sid: 'customOperator-call-1',
			            method: 'customOperator',
			            name: 'test-name',
			            meta: expect.objectContaining(\{
			              sid: 'customOperator-call-1',
			              method: 'customOperator',
			            \}),
			          \},
			        \},
			      \})
			      expect(argumentHistory(declared)).toMatchInlineSnapshot(\`
			        Array [
			          "unit updates created",
			          "unit reinit created",
			          "unit \$source created",
			          "unit targetEvent created",
			          "unit internalEvent created",
			          "region undefined created",
			          "region undefined created",
			          "factory test-name created",
			        ]
			      \`)
			    \})
			  \})
			\})
			
			describe('real use cases', () => \{
			  test('measure effect timings', async () => \{
			    const start = createEvent()
			
			    const fx1 = createEffect(() => new Promise(r => setTimeout(r, 12)))
			    const fx2 = createEffect(() => new Promise(r => setTimeout(r, 22)))
			    const fx3 = createEffect(() => new Promise(r => setTimeout(r, 32)))
			
			    sample(\{
			      clock: start,
			      target: [fx1, fx2, fx3],
			    \})
			
			    const scope = fork()
			
			    const times: Record<string, number> = \{\}
			    const startRecord = (name: string) => \{
			      const start = Date.now()
			
			      return () => \{
			        times[name] = Date.now() - start
			      \}
			    \}
			
			    const timers = new Map<string, () => void>()
			
			    const unsub = inspect(\{
			      scope,
			      fn: m => \{
			        if (m.kind === 'effect') \{
			          timers.set(m.stack.fxID as string, startRecord(m.name!))
			        \}
			        if (m.kind === 'event' && m.meta.named === 'finally') \{
			          const stop = timers.get(m.stack.fxID as string)
			          stop?.()
			        \}
			      \},
			    \})
			
			    await allSettled(start, \{scope\})
			
			    const floor = (n: number) => Math.floor(n / 10) * 10
			
			    expect(floor(times.fx1)).toEqual(10)
			    expect(floor(times.fx2)).toEqual(20)
			    expect(floor(times.fx3)).toEqual(30)
			
			    unsub()
			  \})
			  test('monitor out-of-scope computations', async () => \{
			    const start = createEvent()
			
			    const scope = fork()
			
			    const outOfScope = jest.fn()
			    inspect(\{
			      fn: () => outOfScope(),
			    \})
			
			    allSettled(start, \{scope\})
			
			    expect(outOfScope).not.toBeCalled()
			
			    start()
			
			    expect(outOfScope).toBeCalled()
			  \})
			  test('monitor sid-less stores', async () => \{
			    const missingSid = jest.fn()
			
			    inspectGraph(\{
			      fn: d => \{
			        if (d.kind === 'store' && !d.sid) missingSid(d.name)
			      \},
			    \})
			
			    const \$a = createStore(null)
			    const \$b = createStore(null, \{sid: null as unknown as string\})
			    const \$c = createStore(null)
			
			    expect(missingSid).toBeCalledTimes(1)
			    expect(missingSid).toBeCalledWith('\$b')
			  \})
			  test('monitor stores with duplicated sid\`s', async () => \{
			    const duplicatedSid = jest.fn()
			
			    const sidMap: Record<string, boolean> = \{\}
			
			    inspectGraph(\{
			      fn: d => \{
			        if (d.kind === 'store' && d.sid) \{
			          if (sidMap[d.sid]) \{
			            duplicatedSid(d.name)
			          \} else \{
			            sidMap[d.sid] = true
			          \}
			        \}
			      \},
			    \})
			
			    const \$a = createStore(null, \{sid: '\$a'\})
			    const \$b = createStore(null)
			    const \$c = createStore(null, \{sid: '\$a'\})
			
			    expect(duplicatedSid).toBeCalledTimes(1)
			  \})
			  test('profile computations', async () => \{
			    const start = createEvent()
			
			    const end = sample(\{
			      clock: start,
			      fn: () => \{
			        let c = 0
			        while (c < 10_000) \{
			          c++
			        \}
			      \},
			    \})
			
			    const timeLog = jest.fn()
			    let time = 0
			    let tracking = false
			
			    const scope = fork()
			
			    inspect(\{
			      scope,
			      fn: m => \{
			        if (!tracking) \{
			          tracking = true
			          time = performance.now()
			          queueMicrotask(() => \{
			            tracking = false
			            timeLog(\{starter: m.name, ms: performance.now() - time\})
			          \})
			        \}
			      \},
			    \})
			
			    await allSettled(start, \{scope\})
			
			    expect(tracking).toBe(false)
			    expect(timeLog).toBeCalledTimes(1)
			    expect(timeLog).toBeCalledWith(\{starter: 'start', ms: expect.any(Number)\})
			    expect(argumentHistory(timeLog)[0].ms).toBeGreaterThan(0)
			  \})
			  test('list units by file', () => \{
			    const unitsByFile: Record<string, string[]> = \{\}
			    inspectGraph(\{
			      fn: d => \{
			        if (d.loc) \{
			          const file = d.loc.file.split('/').at(-1) || ''
			          const units = unitsByFile[file] || []
			          units.push(d.name!)
			          unitsByFile[file] = units
			        \}
			      \},
			    \})
			    const \$a = createStore(null)
			    const \$b = createStore(null)
			    const \$c = createStore(null)
			
			    expect(unitsByFile).toEqual(\{
			      'inspect.test.ts': ['\$a', '\$b', '\$c'],
			    \})
			  \})
			  test('track pure function errors in custom way', () => \{
			    // something that logs errors directly into our monitoring systems
			    // providing additional context
			    const appLogger = \{
			      log: jest.fn(message => (\{
			        message,
			        logContext: \{
			          appName: 'my-app',
			          appVersion: '1.0.0',
			        \},
			      \})),
			    \}
			
			    const start = createEvent()
			    const started = sample(\{
			      clock: start,
			      fn: () => \{
			        throw new Error('unexpected error, branch computation stopped')
			      \},
			    \})
			
			    const scope = fork()
			
			    inspect(\{
			      scope,
			      fn: m => \{
			        if (m.type === 'error') \{
			          appLogger.log(\`name: \$\{m.name\}, error: \$\{(m.error as Error).message\}\`)
			        \}
			      \},
			    \})
			
			    allSettled(start, \{scope\})
			
			    expect(argumentHistory(appLogger.log)[0]).toEqual(
			      'name: started, error: unexpected error, branch computation stopped',
			    )
			  \})
			  test('list both units and custom stuff by file', () => \{
			    function createQuery(config: Record<string, unknown>) \{
			      return withRegion(
			        createNode(\{
			          meta: \{
			            config,
			          \},
			        \}),
			        () => \{
			          const start = createEvent()
			          const \$data = createStore(0)
			
			          return \{
			            start,
			            \$data,
			          \}
			        \},
			      )
			    \}
			
			    const unitsByFile: Record<
			      string,
			      \{
			        name: string
			        value: unknown
			      \}[]
			    > = \{\}
			    inspectGraph(\{
			      fn: d => \{
			        if (d.loc) \{
			          const file = d.loc.file.split('/').at(-1) || ''
			          const units = unitsByFile[file] || []
			          const name = d.region
			            ? \`\$\{d.region.region?.meta.name!\}/\$\{d.name!\}\`
			            : d.name!
			
			          units.push(\{
			            name: name,
			            value: d.meta.defaultState,
			          \})
			          unitsByFile[file] = units
			        \}
			      \},
			    \})
			    const \$a = createStore(0)
			    const \$b = createStore('1')
			    const \$c = createStore(2)
			
			    const myQuery = withFactory(\{
			      sid: 'some-sid',
			      name: 'myQuery',
			      method: 'createQuery',
			      fn: () => createQuery(\{a: 1, b: 2\}),
			    \})
			
			    expect(unitsByFile).toEqual(\{
			      'inspect.test.ts': [
			        \{
			          name: '\$a',
			          value: 0,
			        \},
			        \{
			          name: '\$b',
			          value: '1',
			        \},
			        \{
			          name: '\$c',
			          value: 2,
			        \},
			        \{
			          name: 'myQuery/start',
			          value: undefined,
			        \},
			        \{
			          name: 'myQuery/\$data',
			          value: 0,
			        \},
			      ],
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\inspect.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(16)
    });
    it('effector_effector\\src\\effector\\__tests__\\is.test.ts', () => {
        const sourceCode = `
			import \{is, createDomain, createEffect, attach, createStore, createEvent\} from 'effector'
			
			it('should return false for common effects', () => \{
			  const domain = createDomain()
			  const domainFx = domain.createEffect()
			  const commonFx = createEffect()
			
			  expect(is.attached(domainFx)).toBeFalsy()
			  expect(is.attached(commonFx)).toBeFalsy()
			\})
			
			it('should return false for another units', () => \{
			  const domain = createDomain()
			  const \$store = createStore(0)
			  const event = createEvent()
			
			  expect(is.attached(domain)).toBeFalsy()
			  expect(is.attached(event)).toBeFalsy()
			  expect(is.attached(\$store)).toBeFalsy()
			\})
			
			it('should return true for really attached effects', () => \{
			  const \$source = createStore(0)
			  const fx = createEffect()
			  const copyFx = attach(\{ effect: fx \})
			  const withSourceFx = attach(\{ source: \$source, effect: fx \})
			  const noParentFx = attach(\{
			    source: \$source,
			    async effect(_: number) \{
			      return 1
			    \}
			  \});
			
			  expect(is.attached(copyFx)).toBeTruthy()
			  expect(is.attached(withSourceFx)).toBeTruthy()
			  expect(is.attached(noParentFx)).toBeTruthy()
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\is.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\effector\\__tests__\\kernelEdgeCases.test.ts', () => {
        const sourceCode = `
			import \{
			  createEvent,
			  createStore,
			  sample,
			  step,
			  createNode,
			  createEffect,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			it('should call watcher as many times, as many store updates occured', () => \{
			  const fn = jest.fn()
			  const e1 = createEvent<string>()
			  const e2 = e1.map(() => 'e2')
			  const st1 = createStore('str')
			    .on(e1, (_, x) => x)
			    .on(e2, (_, x) => x)
			
			  st1.watch(fn)
			  e1('first call')
			  e1('second call')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      "str",
			      "first call",
			      "e2",
			      "second call",
			      "e2",
			    ]
			  \`)
			\})
			it('should call sampled watcher once during a walk', () => \{
			  const fn = jest.fn()
			  const e1 = createEvent<string>()
			  const e2 = e1.map(() => 'e2')
			  const st1 = createStore('str')
			    .on(e1, (_, x) => x)
			    .on(e2, (_, x) => x)
			
			  sample(st1).watch(fn)
			  e1('first call')
			  e1('second call')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      "str",
			      "e2",
			    ]
			  \`)
			\})
			
			it('should avoid data races', () => \{
			  const fn = jest.fn()
			  const routePush = createEvent<string>()
			
			  const history = createStore<string[]>([]).on(routePush, (state, route) => [
			    ...state,
			    route,
			  ])
			  const currentIdx = createStore(-2).on(
			    routePush,
			    () => history.getState().length - 1,
			  )
			
			  history.watch(() => \{\})
			  currentIdx.watch(fn)
			
			  routePush('v 1')
			  routePush('v 2')
			  expect(argumentHistory(fn)).toEqual([-2, 0, 1])
			\})
			
			it('should not erase sibling branches', () => \{
			  const fooFn = jest.fn()
			  const trigger = createEvent<number>()
			  const foo = createStore(0)
			  foo.on(trigger, (state, payload) => payload)
			  let skipped = false
			  foo.watch(val => \{
			    if (!skipped) \{
			      skipped = true
			      return
			    \}
			    //@ts-expect-error
			    foo.setState(val)
			  \})
			
			  foo.watch(fooFn)
			  trigger(30)
			  expect(argumentHistory(fooFn)).toEqual([0, 30])
			\})
			
			test('watch behavior should be consistent', () => \{
			  const fn = jest.fn()
			  const trigger = createEvent<number>()
			
			  createNode(\{
			    node: [step.run(\{fn: () => fn(\`watch A\`)\})],
			    parent: [trigger],
			  \})
			  createNode(\{
			    node: [step.compute(\{fn: n => n\}), step.run(\{fn: () => fn(\`watch B\`)\})],
			    parent: [trigger],
			  \})
			  createNode(\{
			    node: [step.run(\{fn: () => fn(\`watch C\`)\})],
			    parent: [trigger],
			  \})
			  createNode(\{
			    node: [step.compute(\{fn: n => fn(\`compute\`)\})],
			    parent: [trigger],
			  \})
			
			  trigger(1)
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      "compute",
			      "watch A",
			      "watch B",
			      "watch C",
			    ]
			  \`)
			\})
			
			test('stale reads', async () => \{
			  const fn = jest.fn()
			  const fx = createEffect((tag: string) => \`\$\{tag\}/end\`)
			  const x = createStore([] as (string | boolean)[])
			    .on(fx, (words, x) => [...words, x])
			    .on(fx.pending, (words, x) => [...words, x])
			    .on(fx.doneData, (words, x) => [...words, x])
			
			  x.watch(upd => fn(upd.join(', ')))
			
			  await fx('a')
			  await fx('b')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      "",
			      "a",
			      "a, true",
			      "a, true, a/end",
			      "a, true, a/end, false",
			      "a, true, a/end, false, b",
			      "a, true, a/end, false, b, true",
			      "a, true, a/end, false, b, true, b/end",
			      "a, true, a/end, false, b, true, b/end, false",
			    ]
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\kernelEdgeCases.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\effector\\__tests__\\merge.test.ts', () => {
        const sourceCode = `
			import \{merge, createEvent\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('merge', () => \{
			  const fn = jest.fn()
			  const foo = createEvent<number>()
			  const bar = createEvent<number>()
			
			  const baz = merge([foo, bar])
			
			  baz.watch(v => fn(v))
			
			  foo(1)
			  bar(2)
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      1,
			      2,
			    ]
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\merge.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\effector\\__tests__\\multiPass.test.ts', () => {
        const sourceCode = `
			import \{
			  attach,
			  combine,
			  createDomain,
			  createEffect,
			  createEvent,
			  createStore,
			  createApi,
			  forward,
			  guard,
			  merge,
			  restore,
			  sample,
			  split,
			\} from 'effector'
			
			test('attach', () => \{
			  expect(() => \{
			    const korben = createEffect()
			    const dallas = attach(\{effect: korben\})
			  \}).not.toThrow()
			\})
			test('combine', () => \{
			  expect(() => \{
			    const b = combine(\{\}, () => \{\})
			  \}).not.toThrow()
			\})
			test('createDomain', () => \{
			  expect(() => \{
			    const c = createDomain()
			  \}).not.toThrow()
			\})
			test('createEffect', () => \{
			  expect(() => \{
			    const d = createEffect()
			  \}).not.toThrow()
			\})
			test('createEvent', () => \{
			  expect(() => \{
			    const e = createEvent()
			  \}).not.toThrow()
			\})
			test('createStore', () => \{
			  expect(() => \{
			    const f = createStore(null)
			  \}).not.toThrow()
			\})
			test('createApi', () => \{
			  expect(() => \{
			    const \$store = createStore(null)
			    const g = createApi(\$store, \{\})
			  \}).not.toThrow()
			\})
			test('forward', () => \{
			  expect(() => \{
			    const event = createEvent()
			    const h = forward(\{from: event, to: event\})
			  \}).not.toThrow()
			\})
			test('guard', () => \{
			  expect(() => \{
			    const event = createEvent()
			    const i = guard(event, \{filter: Boolean\})
			  \}).not.toThrow()
			\})
			test('merge', () => \{
			  expect(() => \{
			    const event = createEvent()
			    const j = merge([event])
			  \}).not.toThrow()
			\})
			test('restore', () => \{
			  expect(() => \{
			    const event = createEvent()
			    const k = restore(event, null)
			  \}).not.toThrow()
			\})
			test('sample', () => \{
			  expect(() => \{
			    const event = createEvent()
			    const m = sample(\{clock: event, source: event\})
			  \}).not.toThrow()
			\})
			test('split', () => \{
			  expect(() => \{
			    const event = createEvent()
			    const n = split(event, \{\})
			  \}).not.toThrow()
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\multiPass.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(13)
    });
    it('effector_effector\\src\\effector\\__tests__\\naming.test.ts', () => {
        const sourceCode = `
			import \{createEvent, createStore, createDomain, combine, sample\} from 'effector'
			import \{unitObjectName\} from '../naming'
			
			const rootDomain = createDomain('')
			
			describe('.map support', () => \{
			  it('should support event.map', () => \{
			    const foo = createEvent()
			    const bar = foo.map(\{
			      name: 'Bar',
			      fn: x => x,
			    \})
			    expect(bar.shortName).toBe('Bar')
			  \})
			  it('should support store.map', () => \{
			    const foo = createStore(0)
			    const bar = foo.map(\{
			      name: 'Bar',
			      fn: x => x + 1,
			    \})
			    expect(bar.shortName).toBe('Bar')
			  \})
			\})
			
			describe('naming', () => \{
			  describe('domain', () => \{
			    test('value store', () => \{
			      const domain = rootDomain.createDomain('form')
			      const firstName = domain.createStore('')
			      const lastName = domain.createStore('')
			
			      expect(firstName.compositeName?.fullName).toBe('form/firstName')
			      expect(lastName.compositeName?.fullName).toBe('form/lastName')
			    \})
			  \})
			
			  test('value store', () => \{
			    const firstName = createStore('')
			    const lastName = createStore('')
			
			    expect(firstName.compositeName?.fullName).toBe('firstName')
			    expect(lastName.compositeName?.fullName).toBe('lastName')
			  \})
			
			  test('unnamed object store', () => \{
			    const firstName = createStore('')
			    const lastName = createStore('')
			    const form = \{combine\}.combine(\{firstName, lastName\})
			    const app = \{combine\}.combine(\{form\})
			
			    expect(app.compositeName?.fullName).toBe(
			      'combine(combine(firstName, lastName))',
			    )
			    expect(form.compositeName?.fullName).toBe('combine(firstName, lastName)')
			    expect(firstName.compositeName?.fullName).toBe('firstName')
			    expect(lastName.compositeName?.fullName).toBe('lastName')
			  \})
			\})
			
			describe('naming scheme', () => \{
			  test('storeObjectArrayName', () => \{
			    expect(unitObjectName([1, 2, 3])).toBe('combine(1, 2, 3)')
			  \})
			
			  test('storeObjectName', () => \{
			    expect(
			      unitObjectName(\{
			        a: 1,
			        b: 2,
			        c: 3,
			      \}),
			    ).toBe('combine(1, 2, 3)')
			  \})
			
			  test('storeObjectArrayName doesnt breaks maximum', () => \{
			    const mock = Array.from(\{length: 100\}, (_, i) => i.toString(36))
			    const obj2 = mock.slice(0, 25)
			    expect(unitObjectName(mock)).toBe(\`combine(\$\{obj2.join(', ')\})\`)
			  \})
			
			  test('storeObjectName doesnt breaks maximum', () => \{
			    const mock = Array.from(\{length: 100\}, (_, i) => i.toString(36))
			    const obj = mock.reduce((acc, v) => (\{...acc, [v]: v\}), \{\})
			    const obj2 = Object.values(obj).slice(0, 25)
			    expect(unitObjectName(obj)).toBe(\`combine(\$\{obj2.join(', ')\})\`)
			  \})
			\})
			
			it('support combine', () => \{
			  const a = createStore(0)
			  const b = createStore(1)
			  const ab = combine([a, b])
			  expect(ab.shortName).toBe('ab')
			  expect(ab.getState()).toEqual([0, 1])
			\})
			
			describe('sample support', () => \{
			  test('sample(source, clock)', () => \{
			    const source = createStore(0)
			    const clock = createEvent()
			    const sampled = sample(source, clock)
			    expect(sampled.shortName).toBe('sampled')
			  \})
			  test('sample(config)', () => \{
			    const source = createStore(0)
			    const clock = createEvent()
			    const sampled = sample(\{source, clock\})
			    expect(sampled.shortName).toBe('sampled')
			  \})
			  test('sample(config) with explicit name', () => \{
			    const source = createStore(0)
			    const clock = createEvent()
			    const sampled = sample(\{source, clock, name: 'foo'\})
			    expect(sampled.shortName).toBe('foo')
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\naming.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(13)
    });
    it('effector_effector\\src\\effector\\__tests__\\observable.test.ts', () => {
        const sourceCode = `
			import * as redux from 'redux'
			import \{from, periodic\} from 'most'
			import \{from as rxjsFrom\} from 'rxjs'
			import \{
			  fromObservable,
			  createEvent,
			  createStore,
			  createEffect,
			  createDomain,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('fromObservable', () => \{
			  it('works with typical Symbol.observable library: redux', () => \{
			    const fn = jest.fn()
			    const reduxStore = redux.createStore((state = 1, action) => \{
			      switch (action.type) \{
			        case 'inc':
			          return state + 1
			        default:
			          return state
			      \}
			    \})
			    const effectorEvent = fromObservable(reduxStore)
			    effectorEvent.watch(e => \{
			      fn(e)
			    \})
			    reduxStore.dispatch(\{type: 'inc'\})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        2,
			      ]
			    \`)
			  \})
			
			  describe('works with itself', () => \{
			    test('event support', () => \{
			      const fn = jest.fn()
			      const trigger = createEvent()
			      const target = fromObservable(trigger)
			      target.watch(fn)
			      trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			        ]
			      \`)
			    \})
			    test('effect support', async () => \{
			      const fn = jest.fn()
			      const trigger = createEffect(\{
			        handler() \{\},
			      \})
			      const target = fromObservable(trigger)
			      target.watch(fn)
			      await trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			        ]
			      \`)
			    \})
			    test('store support', () => \{
			      const fn = jest.fn()
			      const trigger = createEvent()
			      const store = createStore(0).on(trigger, x => x + 1)
			      const target = fromObservable(store)
			      target.watch(fn)
			      trigger()
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          1,
			        ]
			      \`)
			    \})
			  \})
			\})
			
			describe('.subscribe', () => \{
			  describe('observer support', () => \{
			    test('event support', () => \{
			      const fn = jest.fn()
			      const trigger = createEvent()
			      trigger.subscribe(\{next: fn\})
			      trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			        ]
			      \`)
			    \})
			    test('effect support', async () => \{
			      const fn = jest.fn()
			      const trigger = createEffect(\{
			        handler() \{\},
			      \})
			      trigger.subscribe(\{next: fn\})
			      await trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			        ]
			      \`)
			    \})
			    test('store support', () => \{
			      const fn = jest.fn()
			      const trigger = createEvent()
			      const store = createStore(0).on(trigger, x => x + 1)
			      store.subscribe(\{next: fn\})
			      trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			          1,
			        ]
			      \`)
			    \})
			  \})
			  describe('function support', () => \{
			    test('event support', () => \{
			      const fn = jest.fn()
			      const trigger = createEvent()
			      trigger.subscribe(fn)
			      trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			        ]
			      \`)
			    \})
			    test('effect support', async () => \{
			      const fn = jest.fn()
			      const trigger = createEffect(\{
			        handler() \{\},
			      \})
			      trigger.subscribe(fn)
			      await trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			        ]
			      \`)
			    \})
			    test('store support', () => \{
			      const fn = jest.fn()
			      const trigger = createEvent()
			      const store = createStore(0).on(trigger, x => x + 1)
			      store.subscribe(fn)
			      trigger(0)
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			          1,
			        ]
			      \`)
			    \})
			  \})
			\})
			
			describe('port', () => \{
			  test('port should work correctly', async () => \{
			    const used = jest.fn()
			    const usedEff = jest.fn()
			    const domain = createDomain()
			    const event = domain.createEvent()
			    const eff = domain.createEvent()
			    event.watch(used)
			    eff.watch(usedEff)
			    const str\$ = periodic(50)
			      .scan(a => a + 1, 0)
			      .take(5)
			    await Promise.all([str\$.map(event).drain(), str\$.map(eff).drain()])
			    expect(used).toHaveBeenCalledTimes(5)
			    expect(usedEff).toHaveBeenCalledTimes(5)
			  \})
			\})
			
			it('works with most use cases', async () => \{
			  const fn = jest.fn()
			  const timeout = createEvent()
			  timeout.watch(fn)
			
			  await periodic(300)
			    .take(5)
			    .observe(() => timeout())
			
			  expect(fn).toHaveBeenCalledTimes(5)
			\})
			
			test('subscription', async () => \{
			  const fn = jest.fn()
			
			  const domain = createDomain()
			
			  const eff = domain.createEffect()
			  eff.use(() => \{\})
			  expect(() => \{
			    from(eff).observe(fn)
			  \}).not.toThrow()
			  const event = domain.createEvent()
			  expect(() => \{
			    from(event).observe(fn)
			  \}).not.toThrow()
			  event()
			  await eff('')
			  expect(fn).toHaveBeenCalledTimes(2)
			\})
			
			test('rxjs support', async () => \{
			  const fn = jest.fn()
			  const event = createEvent<string>()
			  const event\$ = rxjsFrom(event)
			  const targetEvent = fromObservable(event\$)
			  targetEvent.watch(fn)
			  event('a')
			  event('b')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      "a",
			      "b",
			    ]
			  \`)
			\})
			
			test('most support', async () => \{
			  const fn = jest.fn()
			  const event = createEvent<string>()
			  const event\$ = from(event)
			  const targetEvent = fromObservable(event\$)
			  targetEvent.watch(fn)
			  event('a')
			  event('b')
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      "a",
			      "b",
			    ]
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\observable.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(15)
    });
    it('effector_effector\\src\\effector\\__tests__\\perf.test.ts', () => {
        const sourceCode = `
			import \{performance, PerformanceObserver\} from 'perf_hooks'
			
			import \{
			  createDomain,
			  combine,
			  sample,
			  attach,
			  guard,
			  //@ts-expect-error
			  withFactory,
			  fork,
			  serialize,
			\} from 'effector'
			
			test('perf', async () => \{
			  const app = createDomain()
			
			  const stores = [] as any[]
			  let factoryACalls = 0
			  factoryC()
			  const combined = combine(stores)
			  await runTestCase(\{
			    name: \`factoryA() x\$\{factoryACalls\} getState\`,
			    warmTimes: 5,
			    repeatTimes: 50,
			    fn: () => \{
			      const scope = fork(app)
			      scope.getState(combined)
			      // const scope = fork(app, \{values: new Map()\})
			    \},
			  \})
			  await runTestCase(\{
			    name: \`factoryA() x\$\{factoryACalls\} serialize\`,
			    warmTimes: 5,
			    repeatTimes: 50,
			    fn: () => \{
			      const scope = fork(app)
			      serialize(scope)
			    \},
			  \})
			
			  function factoryA() \{
			    factoryACalls += 1
			    const a = app.createStore(0)
			    const b = a.map(x => x + 1)
			    const c = a.map(x => x.toString())
			    const d = combine([a, b, c], lst => lst)
			    const fx = app.createEffect(\{
			      handler: (params: [number, number, string]) => \{\},
			    \})
			    const attached = attach(\{source: d, effect: fx\})
			    const sampled = sample(\{source: fx, clock: d\})
			    const ea = app.createEvent()
			    const eb = ea.map(x => x)
			    const ec = guard(\{source: sampled, clock: d, filter: Boolean\})
			    stores.push(d)
			  \}
			
			  function factoryB() \{
			    withFactory(\{
			      sid: 'a',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'b',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'c',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'd',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'e',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'f',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'g',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'h',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'i',
			      fn: () => factoryA(),
			    \})
			    withFactory(\{
			      sid: 'j',
			      fn: () => factoryA(),
			    \})
			  \}
			
			  function factoryC() \{
			    withFactory(\{
			      sid: 'Ca',
			      fn: () => factoryB(),
			    \})
			    withFactory(\{
			      sid: 'Cb',
			      fn: () => factoryB(),
			    \})
			    withFactory(\{
			      sid: 'Cc',
			      fn: () => factoryB(),
			    \})
			    withFactory(\{
			      sid: 'Cd',
			      fn: () => factoryB(),
			    \})
			    withFactory(\{
			      sid: 'Ce',
			      fn: () => factoryB(),
			    \})
			  \}
			\})
			
			async function runTestCase(\{
			  name,
			  fn,
			  warmTimes,
			  repeatTimes,
			\}: \{
			  name: string
			  fn(): void
			  warmTimes: number
			  repeatTimes: number
			\}) \{
			  const measuredFn = performance.timerify(fn)
			  for (let i = 0; i < warmTimes; i++) \{
			    fn()
			  \}
			  const results = await measure(() => \{
			    for (let i = 0; i < repeatTimes; i++) \{
			      measuredFn()
			    \}
			  \})
			  const filtered = percentile(results, avg(results), 0.95)
			  /** typical is 50-70ms */
			  console.log(
			    \`\$\{name\}: avg \$\{avg(filtered).toFixed(2)\} median \$\{median(filtered).toFixed(
			      2,
			    )\}\`,
			  )
			
			  function avg(list: number[]) \{
			    return list.reduce((acc, val) => acc + val, 0) / list.length
			  \}
			  function percentile(list: number[], avg: number, percentile: number) \{
			    const z = list
			      .map((n, i) => [Math.abs(n - avg), i])
			      .sort((a, b) => a[0] - b[0])
			    const upto = Math.ceil(list.length * percentile)
			    return z.slice(0, upto).map(([, i]) => list[i])
			  \}
			  function median(values: number[]) \{
			    if (values.length === 0) return 0
			    const sorted = [...values].sort((a, b) => a - b)
			
			    const half = Math.floor(sorted.length / 2)
			
			    if (sorted.length % 2) return sorted[half]
			
			    return (sorted[half - 1] + sorted[half]) / 2
			  \}
			  function measure(cb: () => void) \{
			    const results: number[] = []
			    let obs: PerformanceObserver
			    const req = new Promise<number[]>(rs => \{
			      obs = new PerformanceObserver(list => \{
			        const entries = list.getEntries()
			        entries.forEach(entry => \{
			          results.push(entry.duration)
			        \})
			        rs(results)
			      \})
			      obs.observe(\{entryTypes: ['function'], buffered: true\})
			    \})
			    cb()
			    req.finally(() => \{
			      obs.disconnect()
			    \})
			    return req
			  \}
			\}
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\perf.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\effector\\__tests__\\region.test.ts', () => {
        const sourceCode = `
			import \{
			  createStore,
			  createEvent,
			  createDomain,
			  withRegion,
			  clearNode,
			  createNode,
			  forward,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			it('binds watchers to region lifetime', () => \{
			  const fn = jest.fn()
			  const trigger = createEvent()
			
			  const domain = createDomain()
			
			  withRegion(domain, () => \{
			    trigger.watch(fn)
			  \})
			
			  trigger(0)
			  // => 0
			  clearNode(domain)
			  trigger(1)
			  // no reaction
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      0,
			    ]
			  \`)
			\})
			
			it('binds units to region lifetime', () => \{
			  const fn = jest.fn()
			  const inc = createEvent()
			  const count = createStore(0).on(inc, x => x + 1)
			
			  const domain = createDomain()
			
			  withRegion(domain, () => \{
			    const countText = count.map(x => \{
			      fn(x)
			      return x.toString()
			    \})
			    // => 0 (initial value)
			  \})
			
			  inc()
			  // => 1
			  clearNode(domain)
			  inc()
			  // no reaction
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      0,
			      1,
			    ]
			  \`)
			\})
			
			describe('api features support', () => \{
			  it('support on', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const store = createStore(0).on(inc, x => x + 1)
			    const target = createStore(0)
			    const region = createNode(\{\})
			
			    withRegion(region, () => \{
			      target.on(store, x => \{
			        fn(x)
			        return x + 1
			      \})
			    \})
			    inc()
			    clearNode(region)
			    inc()
			    expect(argumentHistory(fn)).toEqual([0])
			  \})
			  it('support forward', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const store = createStore(0).on(inc, x => x + 1)
			    const target = createEvent()
			    target.watch(fn)
			    const region = createNode(\{\})
			    withRegion(region, () => \{
			      forward(\{
			        from: store,
			        to: target,
			      \})
			    \})
			    inc()
			    clearNode(region)
			    inc()
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			\})
			
			describe('protect external units from destroy', () => \{
			  test('with on', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const store = createStore(0).on(inc, x => x + 1)
			
			    store.updates.watch(fn)
			    inc()
			
			    const region = createNode(\{\})
			
			    withRegion(region, () => \{
			      createStore(0).on(store.updates, x => x + 1)
			    \})
			    clearNode(region)
			    inc()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			  test('with watch', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const store = createStore(0).on(inc, x => x + 1)
			
			    store.updates.watch(fn)
			    inc()
			
			    const region = createNode(\{\})
			
			    withRegion(region, () => \{
			      store.updates.watch(() => \{\})
			    \})
			    clearNode(region)
			    inc()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        2,
			      ]
			    \`)
			  \})
			
			  describe('difference in behavior with domains', () => \{
			    test('reference behavior', () => \{
			      const fn = jest.fn()
			
			      function apply(fn) \{
			        const unit = createNode() // <- node
			        withRegion(unit, fn)
			        return () => clearNode(unit)
			      \}
			
			      const update = createEvent()
			      const reset = createEvent()
			      const increment = createEvent()
			      const decrement = createEvent()
			      const counter = createStore(0).reset(reset)
			
			      counter.watch(fn)
			
			      const stopUpdating = apply(() => \{
			        counter.on(update, (_, payload) => payload)
			      \})
			      const stopCounting = apply(() => \{
			        counter.on(increment, state => state + 1)
			        counter.on(decrement, state => state - 1)
			      \})
			
			      increment()
			      update(10)
			      stopUpdating()
			      decrement()
			      update(20) // nothing
			      increment()
			      reset()
			      decrement()
			      stopCounting()
			      increment() // nothing
			      decrement() // nothing
			      reset()
			
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			          1,
			          10,
			          9,
			          10,
			          0,
			          -1,
			          0,
			        ]
			      \`)
			    \})
			    test('domain behavior', () => \{
			      const fn = jest.fn()
			
			      function apply(fn: () => void) \{
			        const unit = createDomain() // <- domain
			        withRegion(unit, fn)
			        return () => clearNode(unit)
			      \}
			
			      const update = createEvent<number>()
			      const reset = createEvent()
			      const increment = createEvent()
			      const decrement = createEvent()
			      const counter = createStore(0).reset(reset)
			
			      counter.watch(fn)
			
			      const stopUpdating = apply(() => \{
			        counter.on(update, (_, payload) => payload)
			      \})
			      const stopCounting = apply(() => \{
			        counter.on(increment, state => state + 1)
			        counter.on(decrement, state => state - 1)
			      \})
			
			      increment()
			      update(10)
			      stopUpdating()
			      decrement()
			      update(20) // nothing
			      increment()
			      reset()
			      decrement()
			      stopCounting()
			      increment() // nothing
			      decrement() // nothing
			      reset()
			
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          0,
			          1,
			          10,
			          9,
			          10,
			          0,
			          -1,
			          0,
			        ]
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\region.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('effector_effector\\src\\effector\\__tests__\\restore.test.ts', () => {
        const sourceCode = `
			import \{restore, createEvent, createEffect, Effect\} from 'effector'
			
			describe('restore object', () => \{
			  test('shape', () => \{
			    const shape = restore(\{
			      foo: 'foo',
			      bar: 0,
			    \})
			    expect(shape.foo.getState()).toBe('foo')
			    expect(shape.bar.getState()).toBe(0)
			  \})
			  test('array', () => \{
			    const arr = restore(['foo', 0] as const)
			    expect(arr[0].getState()).toBe('foo')
			    expect(arr[1].getState()).toBe(0)
			    expect(Array.isArray(arr)).toBe(true)
			  \})
			\})
			
			test('restore event', () => \{
			  const event = createEvent<string>()
			
			  const shape = restore(event, 'def')
			  expect(shape.getState()).toBe('def')
			  event('foo')
			  expect(shape.getState()).toBe('foo')
			\})
			
			test('restore effect', async () => \{
			  const fn = jest.fn()
			  const fx: Effect<string, number, string> = createEffect()
			  fx.use(text => text.length)
			  const shape = restore(fx, -1)
			  shape.watch(fn)
			  expect(shape.getState()).toBe(-1)
			  await fx('foo')
			  expect(shape.getState()).toBe(3)
			  expect(fn).toHaveBeenCalledTimes(2)
			  fx.use(() => \{
			    throw 'err'
			  \})
			  await expect(fx('bar')).rejects.toBe('err')
			  expect(fn).toHaveBeenCalledTimes(2)
			\})
			test('all together', () => \{
			  const keyPressed = createEvent<string>()
			
			  const calculate = createEffect<number, string>()
			  const shape = restore(\{
			    index: 0,
			    press: restore(keyPressed, ' '),
			    sqrt: restore(calculate, '0'),
			  \})
			  calculate.use(n => Promise.resolve((n * n).toString()))
			  expect(shape.index.getState()).toBe(0)
			\})
			
			test('babel plugin naming', () => \{
			  const event = createEvent()
			  const foo = restore(event, null)
			  //@ts-expect-error
			  const bar = restore(event, null, \{name: 'baz'\})
			  expect(foo.shortName).toBe('foo')
			  expect(bar.shortName).toBe('baz')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\restore.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\effector\\__tests__\\sample\\order.test.ts', () => {
        const sourceCode = `
			import \{
			  sample,
			  createStore,
			  createEvent,
			  combine,
			  guard,
			  createEffect,
			  restore,
			  is,
			  Store,
			  Event,
			  Effect,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('store update will always performs before sampling', () => \{
			  const fn = jest.fn()
			  const int = createStore(0)
			  const trigger = createEvent()
			  sample(\{
			    source: int,
			    clock: trigger,
			  \}).watch(x => \{
			    fn(x)
			  \})
			  int.on(trigger, x => x + 1)
			  trigger()
			  expect(argumentHistory(fn)).toEqual([1])
			\})
			
			test('store combination will always updates before sampling', () => \{
			  const fn = jest.fn()
			  const int = createStore(0)
			  const shape = combine(\{int\})
			  const trigger = createEvent()
			  sample(\{
			    source: shape,
			    clock: trigger,
			  \}).watch(x => \{
			    fn(x)
			  \})
			  int.on(trigger, x => x + 1)
			  trigger()
			  expect(argumentHistory(fn)).toEqual([\{int: 1\}])
			\})
			
			describe('clock should use the last update', () => \{
			  describe('with guard', () => \{
			    test('reference case', async () => \{
			      const fn = jest.fn()
			      const fetchCities = createEffect(async () => ['msk', 'spb'])
			
			      const \$selectedCities = restore(fetchCities, [])
			      const \$areCitiesSelected = \$selectedCities.map(c => c.length > 0)
			
			      const \$filterValues = createStore<string | null>(null).on(
			        \$selectedCities,
			        (_, cities) => \{
			          if (cities.length) \{
			            return 'result'
			          \}
			        \},
			      )
			
			      const \$requestData = combine(\{
			        city: \$selectedCities,
			        filter: \$filterValues,
			      \})
			
			      const bugHere = guard(\{
			        source: \$requestData,
			        filter: \$areCitiesSelected,
			      \})
			
			      const noBugHere = guard(\{
			        clock: \$requestData,
			        filter: \$areCitiesSelected,
			      \})
			
			      watchAll(fn, [
			        fetchCities,
			        \$selectedCities,
			        \$areCitiesSelected,
			        \$filterValues,
			        \$requestData,
			        bugHere,
			        noBugHere,
			      ])
			
			      fn(\`## init complete\`)
			
			      await fetchCities()
			
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$selectedCities: []",
			          "\$selectedCities → *: false",
			          "\$filterValues: null",
			          "\$requestData: \{city:[],filter:null\}",
			          "## init complete",
			          "fetchCities: void",
			          "fetchCities.done: [msk,spb]",
			          "\$selectedCities: [msk,spb]",
			          "\$selectedCities → *: true",
			          "\$filterValues: result",
			          "\$requestData: \{city:[msk,spb],filter:result\}",
			          "bugHere: \{city:[msk,spb],filter:result\}",
			          "noBugHere: \{city:[msk,spb],filter:result\}",
			        ]
			      \`)
			    \})
			    test('guard case', async () => \{
			      const fn = jest.fn()
			      const fetchCities = createEffect(async () => ['msk', 'spb'])
			
			      const \$selectedCities = restore(fetchCities, [])
			      const \$areCitiesSelected = \$selectedCities.map(c => c.length > 0)
			
			      const \$filterValues = createStore<string | null>(null)
			
			      sample(\{
			        source: guard(\{
			          source: \$selectedCities,
			          filter: \$areCitiesSelected,
			        \}),
			        fn: () => 'result',
			        target: \$filterValues,
			      \})
			
			      const \$requestData = combine(\{
			        city: \$selectedCities,
			        filter: \$filterValues,
			      \})
			
			      const bugHere = guard(\{
			        source: \$requestData,
			        filter: \$areCitiesSelected,
			      \})
			
			      const noBugHere = guard(\{
			        clock: \$requestData,
			        filter: \$areCitiesSelected,
			      \})
			
			      watchAll(fn, [
			        fetchCities,
			        \$selectedCities,
			        \$areCitiesSelected,
			        \$filterValues,
			        \$requestData,
			        bugHere,
			        noBugHere,
			      ])
			
			      fn(\`## init complete\`)
			
			      await fetchCities()
			
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$selectedCities: []",
			          "\$selectedCities → *: false",
			          "\$filterValues: null",
			          "\$requestData: \{city:[],filter:null\}",
			          "## init complete",
			          "fetchCities: void",
			          "fetchCities.done: [msk,spb]",
			          "\$selectedCities: [msk,spb]",
			          "\$selectedCities → *: true",
			          "\$requestData: \{city:[msk,spb],filter:null\}",
			          "\$filterValues: result",
			          "\$requestData: \{city:[msk,spb],filter:result\}",
			          "bugHere: \{city:[msk,spb],filter:result\}",
			          "noBugHere: \{city:[msk,spb],filter:result\}",
			        ]
			      \`)
			    \})
			  \})
			  describe('with sample', () => \{
			    test('reference case', async () => \{
			      const fn = jest.fn()
			      const trigger = createEffect(async () => true)
			
			      const \$selected = restore(trigger, false)
			      const \$result = createStore<string | null>(null)
			      sample(\{
			        source: \$selected,
			        greedy: true,
			        fn: () => 'result',
			        target: \$result,
			      \})
			
			      const \$combine = combine(\{\$selected, \$result\})
			
			      //clockParams have an outdated \$combine value
			      const withBug = sample(\{
			        source: \$selected,
			        clock: \$combine,
			        fn: (_, clockParams) => clockParams,
			      \})
			
			      const noBug = sample(\{
			        source: \$selected,
			        clock: sample(\{clock: \$combine\}),
			        fn: (_, clockParams) => clockParams,
			      \})
			
			      const bugAgain = sample(\{
			        source: \$selected,
			        clock: sample(\{clock: \$combine, greedy: true\}),
			        fn: (_, clockParams) => clockParams,
			      \})
			
			      watchAll(fn, [
			        trigger,
			        \$combine,
			        \$selected,
			        \$result,
			        withBug,
			        noBug,
			        bugAgain,
			      ])
			
			      fn(\`## init complete\`)
			
			      await trigger()
			
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$combine: \{\$selected:false,\$result:null\}",
			          "\$selected: false",
			          "\$result: null",
			          "withBug: \{\$selected:false,\$result:null\}",
			          "noBug: \{\$selected:false,\$result:null\}",
			          "bugAgain: \{\$selected:false,\$result:null\}",
			          "## init complete",
			          "trigger: void",
			          "trigger.done: true",
			          "\$selected: true",
			          "\$result: result",
			          "\$combine: \{\$selected:true,\$result:result\}",
			          "withBug: \{\$selected:true,\$result:result\}",
			          "noBug: \{\$selected:true,\$result:result\}",
			          "bugAgain: \{\$selected:true,\$result:result\}",
			        ]
			      \`)
			    \})
			    test('sample case', async () => \{
			      const fn = jest.fn()
			      const trigger = createEffect(async () => true)
			
			      const \$selected = restore(trigger, false)
			      const \$result = createStore<string | null>(null)
			      sample(\{
			        source: \$selected,
			        fn: () => 'result',
			        target: \$result,
			      \})
			
			      const \$combine = combine(\{\$selected, \$result\})
			
			      //clockParams have an outdated \$combine value
			      const withBug = sample(\{
			        source: \$selected,
			        clock: \$combine,
			        fn: (_, clockParams) => clockParams,
			      \})
			
			      const noBug = sample(\{
			        source: \$selected,
			        clock: sample(\{clock: \$combine\}),
			        fn: (_, clockParams) => clockParams,
			      \})
			
			      const bugAgain = sample(\{
			        source: \$selected,
			        clock: sample(\{clock: \$combine, greedy: true\}),
			        fn: (_, clockParams) => clockParams,
			      \})
			      watchAll(fn, [
			        trigger,
			        \$combine,
			        \$selected,
			        \$result,
			        withBug,
			        noBug,
			        bugAgain,
			      ])
			
			      fn(\`## init complete\`)
			
			      await trigger()
			
			      expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "\$combine: \{\$selected:false,\$result:null\}",
			          "\$selected: false",
			          "\$result: null",
			          "withBug: \{\$selected:false,\$result:null\}",
			          "noBug: \{\$selected:false,\$result:null\}",
			          "bugAgain: \{\$selected:false,\$result:null\}",
			          "## init complete",
			          "trigger: void",
			          "trigger.done: true",
			          "\$selected: true",
			          "\$combine: \{\$selected:true,\$result:null\}",
			          "\$result: result",
			          "\$combine: \{\$selected:true,\$result:result\}",
			          "withBug: \{\$selected:true,\$result:result\}",
			          "noBug: \{\$selected:true,\$result:result\}",
			          "bugAgain: \{\$selected:true,\$result:result\}",
			        ]
			      \`)
			    \})
			  \})
			
			  function watchAll(
			    fn: jest.Mock<any, any>,
			    units: Array<Store<any> | Event<any> | Effect<any, any>>,
			  ) \{
			    for (const unit of units) \{
			      const tag = unit.shortName
			      unitWatch(\`\$\{tag\}\`, unit, fn)
			      if (is.effect(unit)) \{
			        unitWatch(\`\$\{tag\}.done\`, unit.doneData, fn)
			        unitWatch(\`\$\{tag\}.fail\`, unit.failData, fn)
			      \}
			    \}
			  \}
			
			  function unitWatch<T>(
			    tag: string,
			    unit: Store<T> | Event<T> | Effect<T, any, any>,
			    fn: jest.Mock<any, any>,
			    log: boolean = false,
			  ) \{
			    unit.watch(value => \{
			      let text: string
			      if (typeof value === 'object' && value !== null) \{
			        text = JSON.stringify(value).replace(/"/gi, '')
			      \} else if (value === undefined) \{
			        text = 'void'
			      \} else \{
			        text = \`\$\{value\}\`
			      \}
			      fn(\`\$\{tag\}: \$\{text\}\`)
			      if (log) \{
			        console.log(tag, text)
			      \}
			    \})
			  \}
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\sample\\order.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\effector\\__tests__\\sample\\sample.test.ts', () => {
        const sourceCode = `
			import \{
			  sample,
			  guard,
			  createEvent,
			  createStore,
			  createEffect,
			  is,
			  Node,
			  Event,
			\} from 'effector'
			
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('sid support', () => \{
			  const source = createStore(null)
			  const sampled = sample(\{source, sid: 'foo'\})
			
			  expect(sampled.sid).toBe('foo')
			\})
			
			describe('loc support', () => \{
			  function getNode(value: Event<any>): Node \{
			    // @ts-expect-error graphite property is not in public typings yet
			    return value.graphite
			  \}
			  function getLoc(\{meta\}: Node): void | \{line: number; column: number\} \{
			    return 'config' in meta ? meta.config.loc : meta.loc
			  \}
			  function findJointLoc(targetNode: Node) \{
			    if (targetNode.family.links.length === 0)
			      throw Error(\`this node didn't used in sample\`)
			    let jointNode: Node
			    for (let i = targetNode.family.links.length - 1; i >= 0; i--) \{
			      const node = targetNode.family.links[i]
			      if (node.meta.joint) \{
			        jointNode = node
			        break
			      \}
			    \}
			    if (!jointNode!) throw Error(\`this node didn't used in sample\`)
			    return getLoc(jointNode)
			  \}
			  test('sample without target', () => \{
			    const clock = createEvent()
			    const result = sample(\{clock\})
			    const loc = getLoc(getNode(result))
			    expect(loc).toHaveProperty('line')
			  \})
			  describe('sample with target', () => \{
			    test('basic case', () => \{
			      const clock = createEvent()
			      const target = createEvent()
			      sample(\{clock: [clock], target: [target]\})
			      const loc = findJointLoc(getNode(target))
			      expect(loc).toHaveProperty('line')
			    \})
			    test('target-clock feedback loop', () => \{
			      const trigger = createEvent()
			      sample(\{clock: trigger, target: trigger\})
			      const loc = findJointLoc(getNode(trigger))
			      expect(loc).toHaveProperty('line')
			      expect(loc!.line).toBe(getLoc(getNode(trigger))!.line + 1)
			    \})
			  \})
			\})
			
			describe('temporal consistency', () => \{
			  test('in combination with guard, pass immediately', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<number>()
			    const target = createEvent()
			    sample(\{
			      source: trigger,
			      clock: guard(trigger, \{
			        filter: x => x > 0,
			      \}),
			      target,
			    \})
			    target.watch(fn)
			    trigger(1)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			  test('in combination with guard, pass on second call', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<number>()
			    const target = createEvent()
			    sample(\{
			      source: trigger,
			      clock: guard(trigger, \{
			        filter: x => x > 0,
			      \}),
			      target,
			    \})
			    target.watch(fn)
			    trigger(0)
			    trigger(1)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			  test('in combination with .filter, pass immediately', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<number>()
			    const target = createEvent()
			    sample(\{
			      source: trigger,
			      clock: trigger.filter(\{
			        fn: x => x > 0,
			      \}),
			      target,
			    \})
			    target.watch(fn)
			    trigger(1)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			  test('in combination with .filter, pass on second call', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<number>()
			    const target = createEvent()
			    sample(\{
			      source: trigger,
			      clock: trigger.filter(\{
			        fn: x => x > 0,
			      \}),
			      target,
			    \})
			    target.watch(fn)
			    trigger(0)
			    trigger(1)
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			  test('source & clock is a same event', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<number>()
			    const target = createEvent()
			    sample(\{
			      source: trigger,
			      clock: trigger,
			      target,
			    \})
			    target.watch(fn)
			    trigger(0)
			    trigger(1)
			    expect(argumentHistory(fn)).toEqual([0, 1])
			  \})
			  test('clock triggers earlier than source during same pure phase', () => \{
			    const fn = jest.fn()
			    const trigger = createEvent<number>()
			    const source = trigger.map(x => x)
			    const target = createEvent()
			    sample(\{
			      source,
			      clock: trigger,
			      target,
			    \})
			    target.watch(fn)
			    trigger(0)
			    trigger(1)
			    //note that during first trigger call, source is not called yet
			    //in general, users should avoid such a backward-clocking
			    expect(argumentHistory(fn)).toEqual([1])
			  \})
			\})
			
			it('should not accept undefined clocks', () => \{
			  expect(() => \{
			    sample(\{
			      //@ts-expect-error
			      source: createStore(null),
			      clock: undefined,
			    \})
			  \}).toThrowErrorMatchingInlineSnapshot(\`"sample: clock should be defined"\`)
			\})
			
			describe('sample type', () => \{
			  test.each\`
			    source            | clock             | kind
			    \$\{createStore(0)\} | \$\{createStore(0)\} | \$\{'store'\}
			    \$\{createStore(0)\} | \$\{createEvent()\}  | \$\{'event'\}
			    \$\{createEvent()\}  | \$\{createStore(0)\} | \$\{'event'\}
			    \$\{createEvent()\}  | \$\{createEvent()\}  | \$\{'event'\}
			  \`(\`\$kind <- \$source.kind by \$clock.kind\`, (\{source, clock, kind\}) => \{
			    //@ts-expect-error
			    expect(sample(source, clock).kind).toBe(kind)
			  \})
			  test.each\`
			    source            | clock             | kind
			    \$\{createStore(0)\} | \$\{createStore(0)\} | \$\{'store'\}
			    \$\{createStore(0)\} | \$\{createEvent()\}  | \$\{'event'\}
			    \$\{createEvent()\}  | \$\{createStore(0)\} | \$\{'event'\}
			    \$\{createEvent()\}  | \$\{createEvent()\}  | \$\{'event'\}
			  \`(
			    \`\$kind <- \$source.kind by \$clock.kind with handler\`,
			    (\{source, clock, kind\}) => \{
			      expect(
			        //@ts-expect-error
			        sample(source, clock, (source, clock) => (\{source, clock\})).kind,
			      ).toBe(kind)
			    \},
			  )
			\})
			
			describe('sample', () => \{
			  it('works with config', () => \{
			    const foo = createStore('')
			    const bar = createStore('')
			    sample(\{clock: foo, source: foo, target: bar\})
			  \})
			  it('handles object combination', () => \{
			    const foo = createStore('')
			    //@ts-expect-error
			    sample(\{foo\})
			  \})
			  it('works with single source', () => \{
			    const foo = createStore('')
			
			    sample(foo)
			  \})
			  describe('sample with event as source', () => \{
			    describe.each\`
			      greedy   | resultDirect                | resultBacktracking
			      \$\{false\} | \$\{[\{x: 1\}, \{x: 2\}, \{x: 3\}]\} | \$\{[\{x: 2\}, \{x: 3\}]\}
			      \$\{true\}  | \$\{[\{x: 1\}, \{x: 2\}, \{x: 3\}]\} | \$\{[\{x: 1\}, \{x: 2\}]\}
			    \`(
			      'depended on order of execution (greedy = \$greedy)',
			      (\{greedy, resultDirect, resultBacktracking\}) => \{
			        test('direct order', () => \{
			          const fn = jest.fn()
			          const A = createEvent<number>()
			          const B = A.map(x => (\{x\}))
			
			          sample(\{
			            source: A,
			            clock: B,
			            fn: (A, B) => B,
			            greedy,
			          \}).watch(e => fn(e))
			
			          A(1)
			          A(2)
			          A(3)
			
			          expect(argumentHistory(fn)).toEqual(resultDirect)
			        \})
			        test('backtracking', () => \{
			          const fn = jest.fn()
			          const A = createEvent<number>()
			          const B = A.map(x => (\{x\}))
			
			          sample(\{
			            source: B,
			            clock: A,
			            fn: B => B,
			            greedy,
			          \}).watch(e => fn(e))
			
			          A(1)
			          A(2)
			          A(3)
			
			          expect(argumentHistory(fn)).toEqual(resultBacktracking)
			        \})
			      \},
			    )
			
			    it('works with sibling events', () => \{
			      const fn1 = jest.fn()
			      const fn2 = jest.fn()
			      const A = createEvent<number>()
			      const B = A.map(b => (\{b\}))
			      const C = A.filterMap(x => \{
			        if (x > 5) return \`\$\{x\} > 5\`
			      \})
			
			      sample(B, C, (\{b\}, c) => (\{b, c\})).watch(e => fn1(e))
			      sample(C, B, (c, \{b\}) => (\{b, c\})).watch(e => fn2(e))
			
			      A(2)
			      A(6)
			      A(3)
			      A(4)
			      A(10)
			      expect(argumentHistory(fn1)).toEqual([
			        \{b: 6, c: \`6 > 5\`\},
			        \{b: 10, c: \`10 > 5\`\},
			      ])
			      expect(argumentHistory(fn2)).toEqual([
			        \{b: 3, c: \`6 > 5\`\},
			        \{b: 4, c: \`6 > 5\`\},
			        \{b: 10, c: \`10 > 5\`\},
			      ])
			    \})
			    test('event', () => \{
			      const fn = jest.fn()
			      const data = createEvent<any>()
			      const stop = createEvent()
			
			      const lastData = sample(data, stop)
			
			      lastData.watch(value => fn(value))
			
			      data(\{foo: 'bar'\})
			      data(true)
			      data(false)
			      data(\{x: 'baz'\})
			
			      stop()
			
			      expect(argumentHistory(fn)).toEqual([\{x: 'baz'\}])
			      expect(fn).toHaveBeenCalledTimes(1)
			    \})
			    test('no updates until first source update', () => \{
			      const fn = jest.fn()
			      const data = createEvent<any>()
			      const stop = createEvent()
			
			      const lastData = sample(data, stop)
			
			      lastData.watch(value => fn(value))
			
			      stop()
			      stop()
			      expect(fn).not.toHaveBeenCalled()
			      data(\{x: 'baz'\})
			      expect(fn).not.toHaveBeenCalled()
			      stop()
			      expect(argumentHistory(fn)).toEqual([\{x: 'baz'\}])
			      expect(fn).toHaveBeenCalledTimes(1)
			    \})
			    test(
			      'edge case: no updates until first source update ' +
			        'even when clock is store',
			      () => \{
			        const fn = jest.fn()
			        const data = createEvent<any>()
			        const add = createEvent<number>()
			        const stop = createStore(0).on(add, (x, n) => x + n)
			
			        const lastData = sample(data, stop)
			
			        lastData.watch(value => fn(value))
			
			        add(1)
			        add(2)
			        expect(fn).not.toHaveBeenCalled()
			        data(\{x: 'baz'\})
			        add(0) //edge case: store will not be updated
			        expect(fn).not.toHaveBeenCalled()
			        add(3)
			        expect(argumentHistory(fn)).toEqual([\{x: 'baz'\}])
			        expect(fn).toHaveBeenCalledTimes(1)
			        add(4)
			        expect(argumentHistory(fn)).toEqual([\{x: 'baz'\}, \{x: 'baz'\}])
			        expect(fn).toHaveBeenCalledTimes(2)
			      \},
			    )
			    test('handler works', () => \{
			      const fn = jest.fn()
			      const release = createEvent<number>()
			      const emit = createEvent<number>()
			      const received = sample(emit, release, (last, payload) => [last, payload])
			      received.watch(value => fn(value))
			      release(0)
			      emit(1)
			      emit(2)
			      release(3)
			      release(4)
			      emit(5)
			      expect(argumentHistory(fn)).toEqual([
			        [2, 3],
			        [2, 4],
			      ])
			    \})
			    test('store as clock', () => \{
			      const fn = jest.fn()
			      const source = createEvent<string>()
			      const clock = createStore(0)
			      const result = sample(source, clock)
			      result.watch(value => fn(value))
			      //@ts-expect-error
			      clock.setState(1)
			      expect(fn).not.toHaveBeenCalled()
			      source('run')
			      expect(fn).not.toHaveBeenCalled()
			      //@ts-expect-error
			      clock.setState(2)
			      expect(argumentHistory(fn)).toEqual(['run'])
			    \})
			    test('store as clock with handler', () => \{
			      const fn = jest.fn()
			      const handler = jest.fn(x => x)
			      const source = createEvent<string>()
			      const clock = createStore(0)
			      const result = sample(source, clock, (source, clock) =>
			        handler(\{
			          source,
			          clock,
			        \}),
			      )
			      result.watch(value => fn(value))
			      //@ts-expect-error
			      clock.setState(1)
			      expect(fn).not.toHaveBeenCalled()
			      expect(handler).not.toHaveBeenCalled()
			      source('run')
			      expect(fn).not.toHaveBeenCalled()
			      expect(handler).not.toHaveBeenCalled()
			      //@ts-expect-error
			      clock.setState(2)
			      expect(argumentHistory(fn)).toEqual([\{source: 'run', clock: 2\}])
			      expect(argumentHistory(handler)).toEqual([\{source: 'run', clock: 2\}])
			    \})
			
			    test('event source with store as target', () => \{\})
			    test('event source with effect as target', () => \{\})
			  \})
			  describe('sample with effect as source', () => \{
			    test('effect', () => \{
			      const fn = jest.fn()
			      const data = createEffect(\{
			        handler(_: any) \{
			          return 'resolved'
			        \},
			      \})
			      const stop = createEvent()
			
			      const lastData = sample(data, stop)
			
			      lastData.watch(value => fn(value))
			
			      data(\{foo: 'bar'\})
			      data(true)
			      data(false)
			      data(\{x: 'baz'\})
			
			      stop()
			
			      expect(argumentHistory(fn)).toEqual([\{x: 'baz'\}])
			      expect(fn).toHaveBeenCalledTimes(1)
			    \})
			    it('support watchers as usual', async () => \{
			      const fn1 = jest.fn()
			      const fn2 = jest.fn()
			      const hello = createEffect(\{
			        handler(_: any) \{
			          return Promise.resolve(200)
			        \},
			      \})
			      const run = createEvent()
			
			      sample(hello, run).watch(e => fn1(e))
			      sample(hello.done, run).watch(e => fn2(e))
			
			      await hello('test')
			
			      run()
			      expect(fn1).toHaveBeenCalledTimes(1)
			      expect(fn2).toHaveBeenCalledTimes(1)
			    \})
			    describe('event call will not break watchers', () => \{
			      it.each\`
			        greedy
			        \$\{false\}
			        \$\{true\}
			      \`(
			        'event call will not break watchers (greedy = \$greedy)',
			        async (\{greedy\}) => \{
			          const fn1 = jest.fn()
			          const hello = createEvent<string>()
			          const run = createEvent<string>()
			
			          sample(\{
			            source: hello,
			            clock: run,
			            fn: (a, b) => (\{a, b\}),
			            greedy,
			          \}).watch(() => \{\})
			
			          sample(\{
			            source: hello,
			            clock: run,
			            fn: (a, b) => (\{a, b\}),
			            greedy,
			          \}).watch(e => fn1(e))
			
			          run('R')
			          hello('hello')
			
			          run('RR')
			          expect(fn1).toHaveBeenCalledTimes(1)
			        \},
			      )
			    \})
			    test('effect source with store as target', () => \{\})
			    test('effect source with effect as target', () => \{\})
			  \})
			  describe('sample with store as source', () => \{
			    test('store', () => \{
			      const fn = jest.fn()
			      const inc = createEvent()
			      const dec = createEvent()
			      const stop = createEvent()
			
			      const s1 = createStore(0)
			      const s2 = sample(s1, stop)
			
			      s2.watch(value => fn(value))
			
			      s1.on(inc, n => n + 1).on(dec, n => n - 1)
			
			      inc()
			      dec()
			      inc()
			      inc()
			
			      stop()
			
			      expect(argumentHistory(fn)).toEqual([2])
			    \})
			    test('store has the same state as source', () => \{
			      const fn = jest.fn()
			      const stop = createEvent()
			
			      const s1 = createStore(0)
			      //@ts-expect-error
			      s1.setState(1)
			
			      const s2 = sample(s1, stop)
			      s2.watch(e => fn(e))
			      stop()
			      expect(argumentHistory(fn)).toEqual([1])
			    \})
			
			    test('store has its own defaultState', () => \{
			      const stop = createStore(0)
			
			      const s1 = createStore(0)
			      //@ts-expect-error
			      s1.setState(1)
			
			      const s2 = sample(s1, stop)
			
			      expect(s2.defaultState).toEqual(1)
			    \})
			
			    test('store source with event as target plain', () => \{
			      const foo = createStore([1, 2, 3])
			      const bar = createStore([4, 5, 6])
			      const stop = createEvent<string[]>()
			
			      const baz = sample(bar, stop)
			
			      foo.on(baz, (store1, store2) => [...store1, ...store2])
			
			      stop(['stop'])
			      expect(foo.getState()).toEqual([1, 2, 3, 4, 5, 6])
			    \})
			    test('store source with effect as target', () => \{\})
			  \})
			  test('store with handler', () => \{
			    const fn = jest.fn()
			    const stop = createEvent<string>()
			
			    const s1 = createStore(0)
			    //@ts-expect-error
			    s1.setState(1)
			
			    const s2 = sample(s1, stop, (s1, stop) => (\{s1, stop\}))
			
			    s2.watch(value => fn(value))
			    expect(fn).toHaveBeenCalledTimes(0)
			    //@ts-expect-error
			    s1.setState(2)
			
			    stop('x')
			    expect(argumentHistory(fn)).toEqual([\{s1: 2, stop: 'x'\}])
			    expect(fn).toHaveBeenCalledTimes(1)
			  \})
			  test('store x store x handler', () => \{
			    const fn = jest.fn()
			    const stop = createStore(false)
			
			    const s1 = createStore(0)
			    //@ts-expect-error
			    s1.setState(1)
			
			    const s2 = sample(s1, stop, (s1, stop) => (\{s1, stop\}))
			
			    s2.watch(value => fn(value))
			    expect(argumentHistory(fn)).toEqual([\{s1: 1, stop: false\}])
			    //@ts-expect-error
			    s1.setState(2)
			    //@ts-expect-error
			    s1.setState(0)
			
			    //@ts-expect-error
			    stop.setState(true)
			    expect(argumentHistory(fn)).toEqual([
			      \{s1: 1, stop: false\},
			      \{s1: 0, stop: true\},
			    ])
			    expect(fn).toHaveBeenCalledTimes(2)
			  \})
			\})
			
			test('array target', () => \{
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  const store = createStore(0)
			  const trigger = createEvent()
			  const t1 = createEvent()
			  const t2 = createEvent()
			  t1.watch(fn1)
			  t2.watch(fn2)
			  sample(\{
			    source: store,
			    clock: trigger,
			    target: [t1, t2],
			  \})
			  trigger()
			  expect(argumentHistory(fn1)).toEqual([0])
			  expect(argumentHistory(fn2)).toEqual([0])
			\})
			
			test('validate shape', () => \{
			  expect(() => \{
			    const clock = createEvent()
			    //@ts-expect-error
			    sample(0, clock)
			  \}).toThrowErrorMatchingInlineSnapshot(\`"expect first argument be an object"\`)
			\})
			
			test('source shape support', () => \{
			  const sampled = sample(\{
			    source: \{
			      source: createStore(0),
			    \},
			    clock: createEvent(),
			  \})
			  expect(is.event(sampled)).toBe(true)
			\})
			
			describe('it works without source', () => \{
			  test('it works with clock unit', () => \{
			    const fn = jest.fn()
			    const clockA = createEvent<number>()
			    const target = createEvent<number>()
			    target.watch(fn)
			    const result = sample(\{
			      clock: clockA,
			      target,
			    \})
			    clockA(1)
			    expect(result === target).toBe(true)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			      ]
			    \`)
			  \})
			  test('it works with clock array', () => \{
			    const fn = jest.fn()
			    const clockA = createEvent<number>()
			    const clockB = createEvent<number>()
			    const target = createEvent<number>()
			    target.watch(fn)
			    const result = sample(\{
			      clock: [clockA, clockB],
			      target,
			    \})
			    clockA(1)
			    clockB(4)
			    expect(result === target).toBe(true)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        1,
			        4,
			      ]
			    \`)
			  \})
			\})
			
			describe('validation', () => \{
			  test('valid case without clock', () => \{
			    const source = createEvent<any>()
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      sample(\{source, target\})
			    \}).not.toThrow()
			  \})
			  test('valid case without source', () => \{
			    const clock = createEvent<any>()
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      sample(\{clock, target\})
			    \}).not.toThrow()
			  \})
			  test('source validation', () => \{
			    const target = createEffect((_: any) => \{\})
			    expect(() => \{
			      //@ts-expect-error
			      sample(\{source: undefined, target\})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"sample: source should be defined"\`)
			  \})
			  test('clock validation', () => \{
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      //@ts-expect-error
			      sample(\{clock: undefined, target\})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"sample: clock should be defined"\`)
			  \})
			  test('no source no clock', () => \{
			    const target = createEffect((_: any) => \{\})
			
			    expect(() => \{
			      //@ts-expect-error
			      sample(\{target\})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"sample: either source or clock should be defined"\`,
			    )
			  \})
			\})
			
			describe('event/effect sampling behavior (issue #633)', () => \{
			  test('event behavior', () => \{
			    const fn = jest.fn()
			    const triggerEvent = createEvent()
			
			    const targetFx = createEffect(() => \{\})
			    const initEvent = createEvent()
			
			    sample(\{
			      clock: triggerEvent,
			      target: [initEvent.prepend(() => 1), initEvent.prepend(() => 2)],
			    \})
			
			    sample(\{
			      clock: initEvent,
			      filter: targetFx.pending.map(val => !val),
			      target: targetFx,
			    \})
			
			    targetFx.watch(params => fn(params))
			
			    triggerEvent()
			    /*
			    [effect] targetFx 2
			    [effect] targetFx.done \{params: 2, result: undefined\}
			    */
			    expect(argumentHistory(fn)).toEqual([2])
			  \})
			  test('effect behavior', () => \{
			    const fn = jest.fn()
			    const triggerEffect = createEvent()
			
			    const targetFx = createEffect(() => \{\})
			    const initFx = createEffect(() => \{\})
			
			    sample(\{
			      clock: triggerEffect,
			      target: [initFx.prepend(() => 1), initFx.prepend(() => 2)],
			    \})
			
			    sample(\{
			      clock: initFx,
			      filter: targetFx.pending.map(val => !val),
			      target: targetFx,
			    \})
			
			    targetFx.watch(params => fn(params))
			
			    triggerEffect()
			    /*
			    [effect] targetFx 1
			    [effect] targetFx 2
			    [effect] targetFx.done \{params: 1, result: undefined\}
			    [effect] targetFx.done \{params: 2, result: undefined\}
			    */
			    expect(argumentHistory(fn)).toEqual([1, 2])
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\sample\\sample.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(48)
    });
    it('effector_effector\\src\\effector\\__tests__\\split.test.ts', () => {
        const sourceCode = `
			import \{
			  createEvent,
			  split,
			  createEffect,
			  createStore,
			  createApi,
			  Event,
			\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('split(source, match)', () => \{
			  it('split event by matching conditions', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const source: Event<string[]> = createEvent()
			    const \{emptyList, oneElement, commonList\} = split(source, \{
			      emptyList: list => list.length === 0,
			      oneElement: list => list.length === 1,
			      commonList: list => list.length > 1,
			    \})
			    emptyList.watch(list => fn1(list))
			    commonList.watch(list => fn2(list))
			    source([])
			    expect(fn1).toBeCalledTimes(1)
			    expect(fn2).not.toBeCalled()
			    source(['1'])
			    expect(fn1).toBeCalledTimes(1)
			    expect(fn2).not.toBeCalled()
			    source(['foo', 'bar'])
			    expect(fn1).toBeCalledTimes(1)
			    expect(fn2).toBeCalledTimes(1)
			  \})
			
			  it('has default case __', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const source: Event<string[]> = createEvent()
			    const \{
			      emptyList,
			      oneElement,
			      __: commonList,
			    \} = split(source, \{
			      emptyList: list => list.length === 0,
			      oneElement: list => list.length === 1,
			    \})
			    emptyList.watch(list => fn1(list))
			    commonList.watch(list => fn2(list))
			    source([])
			    expect(fn1).toBeCalledTimes(1)
			    expect(fn2).not.toBeCalled()
			    source(['1'])
			    expect(fn1).toBeCalledTimes(1)
			    expect(fn2).not.toBeCalled()
			    source(['foo', 'bar'])
			    expect(fn1).toBeCalledTimes(1)
			    expect(fn2).toBeCalledTimes(1)
			  \})
			\})
			
			describe('split(config)', () => \{
			  test('array targets', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			
			    const anyCase = createEvent<Message>()
			
			    const messageReceived = createEvent<Message>()
			    const showTextPopup = createEvent<Text>()
			    const playAudio = createEvent<Audio>()
			    const reportUnknownMessageType = createEffect<Message, void>()
			
			    const textIsSelected = createStore(false).on(
			      messageReceived,
			      (_, msg) => msg.type === 'text',
			    )
			    const audioIsSelected = createStore(false).on(
			      messageReceived,
			      (_, msg) => msg.type === 'audio',
			    )
			
			    split(\{
			      source: messageReceived,
			      match: \{
			        text: textIsSelected,
			        audio: audioIsSelected,
			      \},
			      cases: \{
			        text: [showTextPopup, anyCase],
			        audio: [playAudio, anyCase],
			        __: [reportUnknownMessageType, anyCase],
			      \},
			    \})
			
			    showTextPopup.watch(fn1)
			    playAudio.watch(fn1)
			    reportUnknownMessageType.use(fn1)
			    anyCase.watch(fn2)
			
			    messageReceived(\{
			      type: 'text',
			      value: 'Hello',
			    \})
			    messageReceived(\{
			      type: 'image',
			      imageUrl: '...',
			    \})
			    messageReceived(\{
			      type: 'audio',
			      duration: 500,
			    \})
			
			    expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			        Object \{
			          "imageUrl": "...",
			          "type": "image",
			        \},
			        Object \{
			          "duration": 500,
			          "type": "audio",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			        Object \{
			          "imageUrl": "...",
			          "type": "image",
			        \},
			        Object \{
			          "duration": 500,
			          "type": "audio",
			        \},
			      ]
			    \`)
			  \})
			  test('match by condition functions', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const fn3 = jest.fn()
			
			    const messageReceived = createEvent<Message>()
			    const showTextPopup = createEvent<Text>()
			    const playAudio = createEvent<Audio>()
			    const reportUnknownMessageType = createEffect<Message, void>()
			
			    split(\{
			      source: messageReceived,
			      match: \{
			        text: (msg): msg is Text => msg.type === 'text',
			        audio: (msg): msg is Audio => msg.type === 'audio',
			      \},
			      cases: \{
			        text: showTextPopup,
			        audio: playAudio,
			        __: reportUnknownMessageType,
			      \},
			    \})
			
			    showTextPopup.watch(fn1)
			    playAudio.watch(fn2)
			    reportUnknownMessageType.use(fn3)
			
			    messageReceived(\{
			      type: 'text',
			      value: 'Hello',
			    \})
			    messageReceived(\{
			      type: 'image',
			      imageUrl: '...',
			    \})
			    messageReceived(\{
			      type: 'audio',
			      duration: 500,
			    \})
			
			    expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "duration": 500,
			          "type": "audio",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "imageUrl": "...",
			          "type": "image",
			        \},
			      ]
			    \`)
			  \})
			  test('match by condition stores', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const fn3 = jest.fn()
			
			    const messageReceived = createEvent<Message>()
			    const showTextPopup = createEvent<Text>()
			    const playAudio = createEvent<Audio>()
			    const reportUnknownMessageType = createEffect<Message, void>()
			
			    const textIsSelected = createStore(false).on(
			      messageReceived,
			      (_, msg) => msg.type === 'text',
			    )
			    const audioIsSelected = createStore(false).on(
			      messageReceived,
			      (_, msg) => msg.type === 'audio',
			    )
			
			    split(\{
			      source: messageReceived,
			      match: \{
			        text: textIsSelected,
			        audio: audioIsSelected,
			      \},
			      cases: \{
			        text: showTextPopup,
			        audio: playAudio,
			        __: reportUnknownMessageType,
			      \},
			    \})
			
			    showTextPopup.watch(fn1)
			    playAudio.watch(fn2)
			    reportUnknownMessageType.use(fn3)
			
			    messageReceived(\{
			      type: 'text',
			      value: 'Hello',
			    \})
			    messageReceived(\{
			      type: 'image',
			      imageUrl: '...',
			    \})
			    messageReceived(\{
			      type: 'audio',
			      duration: 500,
			    \})
			
			    expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "duration": 500,
			          "type": "audio",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "imageUrl": "...",
			          "type": "image",
			        \},
			      ]
			    \`)
			  \})
			  test('match by case function', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const fn3 = jest.fn()
			
			    const messageReceived = createEvent<Message>()
			    const showTextPopup = createEvent<Text>()
			    const playAudio = createEvent<Audio>()
			    const reportUnknownMessageType = createEffect<Message, void>()
			
			    split(\{
			      source: messageReceived,
			      match: msg => msg.type,
			      cases: \{
			        text: showTextPopup,
			        audio: playAudio,
			        __: reportUnknownMessageType,
			      \},
			    \})
			
			    showTextPopup.watch(fn1)
			    playAudio.watch(fn2)
			    reportUnknownMessageType.use(fn3)
			
			    messageReceived(\{
			      type: 'text',
			      value: 'Hello',
			    \})
			    messageReceived(\{
			      type: 'image',
			      imageUrl: '...',
			    \})
			    messageReceived(\{
			      type: 'audio',
			      duration: 500,
			    \})
			
			    expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "duration": 500,
			          "type": "audio",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "imageUrl": "...",
			          "type": "image",
			        \},
			      ]
			    \`)
			  \})
			  test('match by case store', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const fn3 = jest.fn()
			
			    const messageReceived = createEvent<Message>()
			    const showTextPopup = createEvent<Text>()
			    const playAudio = createEvent<Audio>()
			    const reportUnknownMessageType = createEffect<Message, void>()
			
			    const messageType = createStore<Message['type']>('system').on(
			      messageReceived,
			      (_, \{type\}) => type,
			    )
			
			    split(\{
			      source: messageReceived,
			      match: messageType,
			      cases: \{
			        text: showTextPopup,
			        audio: playAudio,
			        __: reportUnknownMessageType,
			      \},
			    \})
			
			    showTextPopup.watch(fn1)
			    playAudio.watch(fn2)
			    reportUnknownMessageType.use(fn3)
			
			    messageReceived(\{
			      type: 'text',
			      value: 'Hello',
			    \})
			    messageReceived(\{
			      type: 'image',
			      imageUrl: '...',
			    \})
			    messageReceived(\{
			      type: 'audio',
			      duration: 500,
			    \})
			
			    expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "duration": 500,
			          "type": "audio",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "imageUrl": "...",
			          "type": "image",
			        \},
			      ]
			    \`)
			  \})
			  it('allow to use inline api', () => \{
			    const fn = jest.fn()
			
			    const textContent = createStore<string[]>([])
			
			    const messageReceived = createEvent<Message>()
			
			    split(\{
			      source: messageReceived,
			      match: \{
			        text: (msg): msg is Text => msg.type === 'text',
			        audio: (msg): msg is Audio => msg.type === 'audio',
			      \},
			      cases: createApi(textContent, \{
			        text: (list, \{value\}: Text) => [...list, value],
			        audio: (list, \{duration\}: Audio) => [...list, \`audio \$\{duration\}\`],
			        __: (list, msg: Message) => [...list, 'unknown message'],
			      \}),
			    \})
			
			    textContent.watch(fn)
			
			    messageReceived(\{
			      type: 'text',
			      value: 'Hello',
			    \})
			    messageReceived(\{
			      type: 'image',
			      imageUrl: '...',
			    \})
			    messageReceived(\{
			      type: 'audio',
			      duration: 500,
			    \})
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Array [],
			        Array [
			          "Hello",
			        ],
			        Array [
			          "Hello",
			          "unknown message",
			        ],
			        Array [
			          "Hello",
			          "unknown message",
			          "audio 500",
			        ],
			      ]
			    \`)
			  \})
			
			  test('clock support', () => \{
			    const fn1 = jest.fn()
			    const fn2 = jest.fn()
			    const fn3 = jest.fn()
			
			    const messageReceived = createEvent<Message>()
			    const refresh = createEvent()
			    const showTextPopup = createEvent<Text>()
			    const playAudio = createEvent<Audio>()
			    const reportUnknownMessageType = createEffect<Message, void>(fn3)
			
			    const messageType = createStore<Message['type']>('system').on(
			      messageReceived,
			      (_, \{type\}) => type,
			    )
			
			    split(\{
			      clock: refresh,
			      source: messageReceived,
			      match: messageType,
			      cases: \{
			        text: showTextPopup,
			        audio: playAudio,
			        __: reportUnknownMessageType,
			      \},
			    \})
			
			    showTextPopup.watch(fn1)
			    playAudio.watch(fn2)
			
			    messageReceived(\{
			      type: 'text',
			      value: 'Hello',
			    \})
			    refresh()
			    refresh()
			    messageReceived(\{
			      type: 'image',
			      imageUrl: '...',
			    \})
			    refresh()
			    messageReceived(\{
			      type: 'audio',
			      duration: 500,
			    \})
			    refresh()
			
			    expect(argumentHistory(fn1)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			        Object \{
			          "type": "text",
			          "value": "Hello",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "duration": 500,
			          "type": "audio",
			        \},
			      ]
			    \`)
			    expect(argumentHistory(fn3)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "imageUrl": "...",
			          "type": "image",
			        \},
			      ]
			    \`)
			  \})
			  test('source with object', () => \{
			    const \$a = createStore(0)
			    const \$b = createStore(1)
			    const \$matcher = createStore<'a' | 'b'>('a')
			    const whenA = createEvent<\{a: number; b: number\}>()
			    const whenB = createEvent<\{a: number; b: number\}>()
			
			    expect(() => \{
			      split(\{
			        // @ts-expect-error
			        source: \{a: \$a, b: \$b\},
			        match: \$matcher,
			        target: \{
			          a: whenA,
			          b: whenB,
			        \},
			      \})
			    \}).toThrowError(/source must be a unit/)
			  \})
			\})
			
			type Message = Text | Image | Audio | System
			
			type System = \{
			  type: 'system'
			\}
			type Text = \{
			  type: 'text'
			  value: string
			\}
			type Image = \{
			  type: 'image'
			  imageUrl: string
			\}
			type Audio = \{
			  type: 'audio'
			  duration: number
			\}
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\split.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(10)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\diamond-deps.test.ts', () => {
        const sourceCode = `
			import \{createStore, createEvent, forward, combine\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('diamonds', async () => \{
			  const fn = jest.fn()
			  const trigger = createEvent()
			  const nodeA = createStore(1).on(trigger, x => x + 1)
			  const nodeB = nodeA.map(x => x + 1)
			  const nodeC = nodeB.map(x => x + 1)
			  const nodeD = nodeA.map(x => x + 1)
			  const nodeE = combine(nodeC, nodeD, (c, d) => [c, d])
			  nodeE.watch(x => fn(x))
			  trigger()
			  expect(fn.mock.calls).toEqual([[[3, 2]], [[4, 3]]])
			\})
			/*
			
			                     ┌────┐
			                     │ A  │──────────┐
			                     └────┘          ▼
			                                  ┌────┐
			                        ┌─────────│ B  │──────┐
			                        │         └────┘      │
			in case, when event     │                     ▼
			trigger certain         │                  ┌────┐
			separate branches       │                  │ C  │
			with different amount   │                  └────┘
			of steps, there         │                     │
			should be no            ▼                     ▼
			intermediate steps   ┌────┐                ┌────┐
			with partially       │ F  │                │ D  │
			updated branches     └────┘                └────┘
			                        │                     │
			                        ▼                     ▼
			                     ┌────┐                ┌────┐
			                     │ G  │                │ E  │
			                     └────┘                └────┘
			                        │       ┌────┐        │
			                        └──────▶│ H  │◀───────┘
			                                └────┘
			                                   │
			                                   ▼
			                                ┌────┐
			                                │ I  │
			                                └────┘
			
			*/
			test('olympic', async () => \{
			  const fn = jest.fn()
			  const A = createEvent<string>()
			  const B = createStore('text')
			  const C = B.map(text => text.length)
			  const D = C.map(ln => (\{isEmpty: ln === 0, ln\}))
			  const E = D.map(
			    (\{isEmpty, ln\}) => \`length: \$\{ln\} empty: \$\{isEmpty.toString()\}\`,
			  )
			  const F = B.map(text => text.trim())
			  const G = F.map(text => \`text: "\$\{text\}"\`)
			  const H = combine(G, E, (text, stats) => \`\$\{text\} \$\{stats\}\`)
			  const I = H.map(result => result)
			  I.watch(result => \{
			    fn(result)
			  \})
			  forward(\{
			    from: A,
			    to: B,
			  \})
			  A('word')
			  A('')
			  A(' ')
			  A('end')
			
			  expect(argumentHistory(fn)).toEqual([
			    'text: "text" length: 4 empty: false',
			    'text: "word" length: 4 empty: false',
			    'text: "" length: 0 empty: true',
			    'text: "" length: 1 empty: false',
			    'text: "end" length: 3 empty: false',
			  ])
			
			  /*
			
			    wonder why it called "olympic"?
			
			      C   D   E
			        F   G
			
			  */
			\})
			
			test('display name', () => \{
			  const isFirstNameShortMap = jest.fn()
			  const fullNameMap = jest.fn()
			  const displayNameMap = jest.fn()
			  const view = jest.fn()
			
			  /*
			    Short description: \`displayName = isFirstNameShort ? fullName : firstName\`
			    \`isFirstNameShort\` and \`fullName\` depends by \`firstName\`
			    so \`displayName\` has three depends from \`firstName\`
			    and in "classic" EE \`displayName\` must updates
			    three times (what unnecessary) if \`firstName\` was updated
			  */
			  const updateFirstName = createEvent<string>()
			
			  const firstName = createStore('John').on(updateFirstName, (_, name) => name)
			  const lastName = createStore('Doe')
			
			  const IsFirstNameShort = firstName.map(v => \{
			    isFirstNameShortMap(v)
			    return v.length < 10
			  \})
			
			  const fullName = combine(firstName, lastName, (fn, ln) => \{
			    fullNameMap(fn, ln)
			
			    return \`\$\{fn\} \$\{ln\}\`
			  \})
			
			  const displayName = combine(
			    firstName,
			    IsFirstNameShort,
			    fullName,
			    (firstName, isFirstNameShort, fullName) => \{
			      displayNameMap(firstName, isFirstNameShort, fullName)
			      return isFirstNameShort ? fullName : firstName
			    \},
			  )
			
			  displayName.watch(view)
			
			  expect(isFirstNameShortMap.mock.calls.length).toBe(1)
			  expect(fullNameMap.mock.calls.length).toBe(1)
			  expect(displayNameMap.mock.calls.length).toBe(1)
			  expect(view.mock.calls.length).toBe(1)
			
			  updateFirstName('Joseph')
			  expect(displayName.getState()).toBe('Joseph Doe')
			  expect(isFirstNameShortMap.mock.calls.length).toBe(2)
			  expect(fullNameMap.mock.calls.length).toBe(2)
			  expect(displayNameMap.mock.calls.length).toBe(2)
			  expect(view.mock.calls.length).toBe(2)
			
			  updateFirstName('Jooooooooooooooseph')
			  expect(displayName.getState()).toBe('Jooooooooooooooseph')
			  expect(isFirstNameShortMap.mock.calls.length).toBe(3)
			  expect(fullNameMap.mock.calls.length).toBe(3)
			  expect(displayNameMap.mock.calls.length).toBe(3)
			  expect(view.mock.calls.length).toBe(3)
			\})
			
			test('combine edge case', () => \{
			  const fn = jest.fn()
			  const event = createEvent()
			  const eA = createStore(0).on(event, s => s + 1)
			  //prettier-ignore
			  const combined = combine([
			    eA,
			    combine([
			      eA.map(d => d + 1)
			    ])
			  ])
			  combined.watch(e => fn(e))
			  event()
			  expect(argumentHistory(fn)).toEqual([
			    [0, [1]],
			    [1, [2]],
			  ])
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\diamond-deps.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\index.test.ts', () => {
        const sourceCode = `
			import \{createStore, createEvent, createEffect\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			test('createStore throw on undefined', () => \{
			  expect(() => createStore(undefined)).toThrowErrorMatchingInlineSnapshot(
			    \`"current state can't be undefined, use null instead"\`,
			  )
			\})
			
			describe('.map', () => \{
			  let warn: jest.SpyInstance<void, [message?: any, ...optionalParams: any[]]>
			  beforeEach(() => \{
			    warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			  \})
			  afterEach(() => \{
			    warn.mockRestore()
			  \})
			  it('supports basic mapping', () => \{
			    const fn = jest.fn()
			    const newWord = createEvent<string>()
			    const a = createStore('word').on(newWord, (_, word) => word)
			
			    const b = a.map(word => word.length)
			
			    const sum = b.map((ln, prevLn) => ln + prevLn, 0)
			
			    sum.watch(fn)
			
			    expect(a.getState()).toBe('word')
			    expect(b.getState()).toBe(4)
			    expect(sum.getState()).toBe(4)
			
			    newWord('lol')
			
			    expect(a.getState()).toBe('lol')
			    expect(b.getState()).toBe(3)
			    expect(sum.getState()).toBe(7)
			
			    newWord('long word')
			
			    expect(a.getState()).toBe('long word')
			    expect(b.getState()).toBe(9)
			    expect(sum.getState()).toBe(16)
			
			    expect(fn).toHaveBeenCalledTimes(3)
			
			    newWord('')
			
			    expect(fn).toHaveBeenCalledTimes(3)
			  \})
			  it('calls given handler with current state as second argument', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const store = createStore(0).on(inc, x => x + 1)
			    const computed = store.map((x, state) => \`(\$\{x\}, \$\{state\})\`)
			    computed.watch(fn)
			    inc()
			    inc()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "(0, undefined)",
			        "(1, (0, undefined))",
			        "(2, (1, (0, undefined)))",
			      ]
			    \`)
			  \})
			  it('accepts initial state as second argument', () => \{
			    const fn = jest.fn()
			    const inc = createEvent()
			    const store = createStore(0).on(inc, x => x + 1)
			    const computed = store.map((x, state) => \`(\$\{x\}, \$\{state\})\`, 'initial')
			    computed.watch(fn)
			    inc()
			    inc()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "(0, initial)",
			        "(1, (0, initial))",
			        "(2, (1, (0, initial)))",
			      ]
			    \`)
			  \})
			
			  test('second argument is deprecated', () => \{
			    const \$a = createStore(10)
			    const \$b = \$a.map((x, y) => x + y, 2)
			    expect(warn.mock.calls.map(([msg]) => msg)).toMatchInlineSnapshot(\`
			      Array [
			        "second argument of store.map is deprecated, use updateFilter instead",
			      ]
			    \`)
			  \})
			
			  it('supports nested mapping with updates skipping', () => \{
			    const a = createStore(null)
			    const f = jest.fn(a => \{
			      if (a) return a.id
			    \})
			    const g = jest.fn(a => a.nice)
			    const b = a.map(f)
			    const c = b.map(g)
			
			    expect(c.getState()).toBe(undefined)
			    expect(g).toHaveBeenCalledTimes(0)
			  \})
			\})
			
			describe('.watch', () => \{
			  it('supports functions', () => \{
			    const fn = jest.fn()
			    const newWord = createEvent<string>()
			    const a = createStore('word').on(newWord, (_, word) => word)
			
			    const b = a.map(word => word.length)
			
			    const sum = createStore(4).on(b, (ln, prevLn) => ln + prevLn)
			
			    sum.watch(fn)
			
			    newWord('lol')
			
			    newWord('long word')
			
			    expect(fn).toHaveBeenCalledTimes(3)
			
			    newWord('')
			
			    expect(fn).toHaveBeenCalledTimes(3)
			  \})
			  it('returns unsubscribe function', () => \{
			    const fn = jest.fn()
			    const newWord = createEvent<string>()
			    const a = createStore('word').on(newWord, (_, word) => word)
			
			    const b = a.map(word => word.length)
			
			    const sum = createStore(4).on(b, (ln, prevLn) => ln + prevLn)
			
			    const unsub = sum.watch(sum => \{
			      fn(sum)
			    \})
			
			    newWord('lol')
			
			    newWord('long word [1]')
			    expect(fn).toHaveBeenCalledTimes(3)
			
			    unsub()
			
			    newWord('long word _ [2]')
			    expect(fn).toHaveBeenCalledTimes(3)
			  \})
			  it('supports events', () => \{
			    const fn = jest.fn()
			    const newWord = createEvent<string>('new word')
			    const spyEvent = createEvent<number>()
			    const a = createStore('word').on(newWord, (_, word) => word)
			
			    const b = a.map(word => word.length)
			
			    const sum = createStore(4).on(b, (ln, prevLn) => ln + prevLn)
			
			    sum.watch(spyEvent, (store, event) => fn(\{store, event\}))
			
			    newWord('lol')
			    expect(fn).toHaveBeenCalledTimes(0)
			    spyEvent(1)
			    spyEvent(2)
			    expect(fn).toHaveBeenCalledTimes(2)
			
			    newWord('')
			    expect(fn).toHaveBeenCalledTimes(2)
			    newWord(' ')
			    expect(fn).toHaveBeenCalledTimes(2)
			
			    spyEvent(3)
			    newWord('long word')
			    expect(fn).toHaveBeenCalledTimes(3)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "event": 1,
			          "store": 7,
			        \},
			        Object \{
			          "event": 2,
			          "store": 7,
			        \},
			        Object \{
			          "event": 3,
			          "store": 8,
			        \},
			      ]
			    \`)
			  \})
			  it('supports effects', () => \{
			    const fn = jest.fn()
			    const newWord = createEvent<string>('new word')
			    const spyEvent = createEffect()
			    spyEvent.use(args => args)
			    const a = createStore('word').on(newWord, (_, word) => word)
			
			    const b = a.map(word => word.length)
			
			    const sum = createStore(4).on(b, (ln, prevLn) => ln + prevLn)
			
			    sum.watch(spyEvent, (store, event) => fn(\{store, event\}))
			
			    newWord('lol')
			    expect(fn).toHaveBeenCalledTimes(0)
			    spyEvent(1)
			    spyEvent(2)
			    expect(fn).toHaveBeenCalledTimes(2)
			
			    newWord('')
			    expect(fn).toHaveBeenCalledTimes(2)
			    newWord(' ')
			    expect(fn).toHaveBeenCalledTimes(2)
			
			    spyEvent(3)
			    newWord('long word')
			    expect(fn).toHaveBeenCalledTimes(3)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "event": 1,
			          "store": 7,
			        \},
			        Object \{
			          "event": 2,
			          "store": 7,
			        \},
			        Object \{
			          "event": 3,
			          "store": 8,
			        \},
			      ]
			    \`)
			  \})
			\})
			
			describe('.off', () => \{
			  it('allows to unsubscribe store from event', () => \{
			    const fn = jest.fn()
			    const newWord = createEvent<string>()
			    const a = createStore('word').on(newWord, (_, word) => word)
			
			    const b = a.map(word => word.length)
			
			    const sum = createStore(4).on(b, (ln, prevLn) => ln + prevLn)
			
			    sum.watch(fn)
			
			    expect(a.getState()).toBe('word')
			    expect(b.getState()).toBe(4)
			    expect(sum.getState()).toBe(4)
			
			    newWord('lol')
			
			    expect(a.getState()).toBe('lol')
			    expect(b.getState()).toBe(3)
			    expect(sum.getState()).toBe(7)
			
			    a.off(newWord)
			
			    newWord('long word')
			
			    expect(a.getState()).toBe('lol')
			    expect(b.getState()).toBe(3)
			    expect(sum.getState()).toBe(7)
			
			    expect(fn).toHaveBeenCalledTimes(2)
			
			    newWord('')
			
			    expect(fn).toHaveBeenCalledTimes(2)
			  \})
			  it('returns store itself', () => \{
			    const newWord = createEvent()
			    const a = createStore('word').on(newWord, (_, word) => word)
			    expect(a.off(newWord)).toBe(a)
			  \})
			\})
			
			describe('updateFilter', () => \{
			  let consoleError: any
			  beforeEach(() => \{
			    consoleError = console.error
			    console.error = () => \{\}
			  \})
			  afterEach(() => \{
			    console.error = consoleError
			  \})
			  it('prevent store from updates when returns false', () => \{
			    const fn = jest.fn()
			    const moveTo = createEvent<\{x: number; y: number\}>()
			    const position = createStore(
			      \{x: 0, y: 0\},
			      \{
			        updateFilter: (upd, \{x, y\}) => upd.x !== x || upd.y !== y,
			      \},
			    ).on(moveTo, (_, upd) => upd)
			    position.updates.watch(fn)
			    moveTo(\{x: 1, y: 1\})
			    moveTo(\{x: 1, y: 1\})
			    moveTo(\{x: 1, y: 2\})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "x": 1,
			          "y": 1,
			        \},
			        Object \{
			          "x": 1,
			          "y": 2,
			        \},
			      ]
			    \`)
			  \})
			  it('prevent store from updates when throws', () => \{
			    const fn = jest.fn()
			    const moveTo = createEvent<\{x: number; y: number\}>()
			    const position = createStore(
			      \{x: 0, y: 0\},
			      \{
			        updateFilter(upd, \{x, y\}) \{
			          if (upd.x === x && upd.y === y) throw Error('failure')
			          return true
			        \},
			      \},
			    ).on(moveTo, (_, upd) => upd)
			    position.updates.watch(fn)
			    moveTo(\{x: 1, y: 1\})
			    moveTo(\{x: 1, y: 1\})
			    moveTo(\{x: 1, y: 2\})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "x": 1,
			          "y": 1,
			        \},
			        Object \{
			          "x": 1,
			          "y": 2,
			        \},
			      ]
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(14)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\lists.test.ts', () => {
        const sourceCode = `
			import \{createStore, createApi, Event, Store, createEvent\} from 'effector'
			
			test('list', () => \{
			  const done = createEvent()
			  const list = storeList([' >'])
			  const acc = createStore<string[][]>([])
			  acc.watch(list.self, (acc, list) => \{
			    acc.push(list)
			  \})
			  acc.watch(done, lists => \{
			    // console.log(lists.map(list => list.join(' ')).join(\`\\n\`))
			  \})
			
			  list.insert([
			    \{
			      offset: 0,
			      entries: ['⚫️', '⚫️', '⚫️'],
			    \},
			  ])
			  list.insert([
			    \{
			      offset: 1,
			      entries: ['🔴', '🔴', '🔴'],
			    \},
			  ])
			  list.insert([
			    \{
			      offset: 0,
			      entries: ['0️⃣', '   '],
			    \},
			    \{
			      offset: -1,
			      entries: ['🔟'],
			    \},
			  ])
			
			  list.replace([
			    \{
			      offset: 0,
			      entries: ['🔵', '🔵'],
			    \},
			    \{
			      offset(list, entries) \{
			        return list.length - Math.min(entries.length, list.length)
			      \},
			      entries: ['✳️ ', '✳️ '],
			    \},
			  ])
			
			  list.delete([
			    \{
			      offset: 3,
			      amount: 2,
			    \},
			    \{
			      offset: -1,
			      amount: 1,
			    \},
			  ])
			
			  done()
			
			  function storeList<T>(initials: Array<T>): \{
			    self: Store<Array<T>>
			    watch: Store<Array<T>>['watch']
			    on: Store<Array<T>>['on']
			    swap: Event<
			      Array<
			        [
			          number | ((list: Array<T>) => number),
			          number | ((list: Array<T>) => number),
			        ]
			      >
			    >
			    move: Event<
			      Array<
			        [
			          number | ((list: Array<T>) => number),
			          number | ((list: Array<T>) => number),
			        ]
			      >
			    >
			    insert: Event<
			      Array<\{
			        offset: number | ((list: Array<T>, entries: Array<T>) => number)
			        entries: Array<T>
			      \}>
			    >
			    replace: Event<
			      Array<\{
			        offset: number | ((list: Array<T>, entries: Array<T>) => number)
			        entries: Array<T>
			      \}>
			    >
			    update: Event<
			      Array<\{
			        index: number | ((list: Array<T>) => number)
			        updater: (value: T) => T
			      \}>
			    >
			    delete: Event<
			      Array<\{
			        offset: number | ((list: Array<T>) => number)
			        amount: number
			      \}>
			    >
			
			    // Simple actions
			    push: Event<Array<T>>
			    unshift: Event<Array<T>>
			    reverse: Event<void>
			    shift: Event<void>
			    pop: Event<void>
			    clear: Event<void>
			  \} \{
			    const store = createStore(initials)
			    const reducers = \{
			      insert(
			        state: Array<T>,
			        segments: Array<\{
			          offset: number | ((list: Array<T>, entries: Array<T>) => number)
			          entries: Array<T>
			        \}>,
			      ) \{
			        if (segments.length === 0) return state
			        const store = []
			        const newSegments = sortSegments(segments, state)
			        for (let i = 0; i < state.length; i++) \{
			          const item = state[i]
			          for (let j = 0; j < newSegments.length; j++) \{
			            if (newSegments[j].offset !== i) continue
			            store.push(...newSegments[j].entries)
			          \}
			          store.push(item)
			        \}
			        for (let i = 0; i < newSegments.length; i++) \{
			          if (newSegments[i].offset >= state.length) \{
			            store.push(...newSegments[i].entries)
			          \}
			        \}
			        return store
			      \},
			      replace(
			        state: Array<T>,
			        segments: Array<\{
			          offset: number | ((list: Array<T>, entries: Array<T>) => number)
			          entries: Array<T>
			        \}>,
			      ) \{
			        if (segments.length === 0) return state
			        const store = [...state]
			        const newSegments = sortSegments(segments, state)
			        for (let i = 0; i < newSegments.length; i++) \{
			          const \{entries, offset\} = newSegments[i]
			          for (let j = 0; j < entries.length; j++) \{
			            store[j + offset] = entries[j]
			          \}
			        \}
			        return store
			      \},
			      update(
			        state: Array<T>,
			        segments: Array<\{
			          index: number | ((list: Array<T>) => number)
			          updater: (value: T) => T
			        \}>,
			      ) \{
			        if (segments.length === 0) return state
			        const store = [...state]
			        const newSegments: Array<\{
			          index: number
			          updater(value: T): T
			        \}> = segments
			          .map((\{updater, index\}) => (\{
			            updater,
			            index: normalizeOffset<T>(index, state, []),
			          \}))
			          .sort((a, b) => a.index - b.index)
			        for (let i = 0; i < newSegments.length; i++) \{
			          const \{updater, index\} = newSegments[i]
			          store[index] = updater(store[index])
			        \}
			        return store
			      \},
			      delete(
			        state: Array<T>,
			        segments: Array<\{
			          offset: number | ((list: Array<T>) => number)
			          amount: number
			        \}>,
			      ) \{
			        if (segments.length === 0) return state
			        const store = [...state]
			        const newSegments = []
			        for (let j = 0; j < segments.length; j++) \{
			          const segment = segments[j]
			          newSegments.push(\{
			            offset: normalizeOffset(segment.offset, state, []),
			            amount: segment.amount,
			          \})
			        \}
			        newSegments.sort((a, b) => a.offset - b.offset)
			        const ids = Array(store.length).fill(true)
			        for (let i = 0; i < newSegments.length; i++) \{
			          const \{amount, offset\} = newSegments[i]
			          for (let j = 0; j < amount; j++) \{
			            ids[j + offset] = false
			          \}
			        \}
			        return store.filter((_, i) => ids[i])
			      \},
			      move(
			        state: Array<T>,
			        segments: Array<
			          [
			            number | ((list: Array<T>) => number),
			            number | ((list: Array<T>) => number),
			          ]
			        >,
			      ) \{
			        if (segments.length === 0) return state
			        const store = [...state]
			        const newSegments: Array<\{
			          from: number
			          to: number
			        \}> = segments
			          .map(([indexA, indexB]) => (\{
			            from: normalizeOffset<T>(indexA, state, []),
			            to: normalizeOffset<T>(indexB, state, []),
			          \}))
			          .sort((a, b) => a.from - b.from)
			        for (let i = 0; i < newSegments.length; i++) \{
			          const \{from, to\} = newSegments[i]
			          const value = store[from]
			          store.splice(from, 1)
			          store.splice(to, 0, value)
			        \}
			        return store
			      \},
			      swap(
			        state: Array<T>,
			        segments: Array<
			          [
			            number | ((list: Array<T>) => number),
			            number | ((list: Array<T>) => number),
			          ]
			        >,
			      ) \{
			        if (segments.length === 0) return state
			        const store = [...state]
			        const newSegments: Array<\{
			          from: number
			          to: number
			        \}> = segments
			          .map(([indexA, indexB]) => (\{
			            from: normalizeOffset<T>(indexA, state, []),
			            to: normalizeOffset<T>(indexB, state, []),
			          \}))
			          .sort((a, b) => a.from - b.from)
			        for (let i = 0; i < newSegments.length; i++) \{
			          const \{from, to\} = newSegments[i]
			          const value = store[from]
			          store[from] = store[to]
			          store[to] = value
			        \}
			        return store
			      \},
			
			      // Simple actions
			      reverse(state: Array<T>, payload: void) \{
			        const store = [...state]
			        store.reverse()
			        return store
			      \},
			      shift(state: Array<T>, payload: void) \{
			        const store = [...state]
			        store.shift()
			        return store
			      \},
			      pop(state: Array<T>, payload: void) \{
			        const store = [...state]
			        store.pop()
			        return store
			      \},
			      clear(state: Array<T>, payload: void) \{
			        return []
			      \},
			    \}
			    const model = \{
			      store,
			      api: createApi(store, reducers),
			    \}
			
			    return \{
			      delete: model.api.delete,
			      insert: model.api.insert,
			      update: model.api.update,
			      replace: model.api.replace,
			      move: model.api.move,
			      swap: model.api.swap,
			
			      // Simple actions
			      push: model.api.insert.prepend(entries => [
			        \{
			          offset: -1,
			          entries,
			        \},
			      ]),
			      unshift: model.api.insert.prepend(entries => [
			        \{
			          offset: 0,
			          entries,
			        \},
			      ]),
			      clear: model.api.clear,
			      pop: model.api.pop,
			      reverse: model.api.reverse,
			      shift: model.api.shift,
			
			      watch: model.store.watch,
			      on: model.store.on,
			      //@ts-expect-error
			      self: model.store,
			    \}
			  \}
			  function normalizeOffset<T>(
			    offsetRaw: number | ((list: Array<T>, entries: Array<T>) => number),
			    list: Array<T>,
			    entries: Array<T>,
			  ): number \{
			    let offset
			    if (typeof offsetRaw === 'function') offset = offsetRaw(list, entries)
			    else offset = offsetRaw
			    if (offset < 0) offset = list.length + offset + 1
			    return offset
			  \}
			  function sortSegments<T>(
			    segments: Array<\{
			      entries: Array<T>
			      offset: number | ((list: Array<T>, entries: Array<T>) => number)
			    \}>,
			    list: Array<T>,
			  ): Array<\{entries: Array<T>; offset: number\}> \{
			    return segments
			      .map(
			        (\{
			          entries,
			          offset,
			        \}): \{
			          entries: Array<T>
			          offset: number
			        \} => (\{
			          entries,
			          offset: normalizeOffset<T>(offset, list, entries),
			        \}),
			      )
			      .sort((a, b) => a.offset - b.offset)
			  \}
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\lists.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\on.test.ts', () => {
        const sourceCode = `
			import \{argumentHistory\} from 'effector/fixtures'
			import \{combine, createEvent, createStore\} from 'effector'
			
			it('supports stores', () => \{
			  const fn = jest.fn()
			  const newWord = createEvent<string>()
			  const a = createStore('word').on(newWord, (_, word) => word)
			
			  const b = createStore(['word'])
			
			  b.on(a, (b, a) => \{
			    fn(\{b, a\})
			    return [...b, a]
			  \})
			
			  newWord('lol')
			  expect(fn).toHaveBeenCalledTimes(1)
			
			  newWord('')
			  expect(fn).toHaveBeenCalledTimes(2)
			  newWord(' ')
			  expect(fn).toHaveBeenCalledTimes(3)
			
			  newWord('long word')
			  expect(fn).toHaveBeenCalledTimes(4)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "a": "lol",
			        "b": Array [
			          "word",
			        ],
			      \},
			      Object \{
			        "a": "",
			        "b": Array [
			          "word",
			          "lol",
			        ],
			      \},
			      Object \{
			        "a": " ",
			        "b": Array [
			          "word",
			          "lol",
			          "",
			        ],
			      \},
			      Object \{
			        "a": "long word",
			        "b": Array [
			          "word",
			          "lol",
			          "",
			          " ",
			        ],
			      \},
			    ]
			  \`)
			\})
			it('supports events', () => \{
			  const fn = jest.fn()
			  const trigger = createEvent<string>()
			
			  const b = createStore(0)
			
			  b.on(trigger, (b, trigger) => \{
			    fn(\{b, trigger\})
			    return b + 1
			  \})
			
			  trigger('lol')
			  expect(fn).toHaveBeenCalledTimes(1)
			
			  trigger('')
			  expect(fn).toHaveBeenCalledTimes(2)
			  trigger(' ')
			  expect(fn).toHaveBeenCalledTimes(3)
			
			  trigger('long word')
			  expect(fn).toHaveBeenCalledTimes(4)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "b": 0,
			        "trigger": "lol",
			      \},
			      Object \{
			        "b": 1,
			        "trigger": "",
			      \},
			      Object \{
			        "b": 2,
			        "trigger": " ",
			      \},
			      Object \{
			        "b": 3,
			        "trigger": "long word",
			      \},
			    ]
			  \`)
			\})
			it('replace old links', () => \{
			  const event = createEvent()
			
			  const store = createStore('')
			    .on(event, () => 'a')
			    .on(event, () => 'b')
			
			  event()
			
			  expect(store.getState()).toBe('b')
			
			  store.off(event)
			
			  //@ts-expect-error
			  store.setState('x')
			
			  event()
			
			  expect(store.getState()).toBe('x')
			\})
			
			it('supports array of events', () => \{
			  const fn = jest.fn()
			  const triggerA = createEvent<string>()
			  const triggerB = createEvent<string>()
			
			  const b = createStore(0)
			
			  b.on([triggerA, triggerB], (b, payload) => \{
			    fn(\{b, payload\})
			    return b + 1
			  \})
			
			  triggerA('lol')
			  expect(fn).toHaveBeenCalledTimes(1)
			
			  triggerB('')
			  expect(fn).toHaveBeenCalledTimes(2)
			  triggerA(' ')
			  expect(fn).toHaveBeenCalledTimes(3)
			
			  triggerB('long word')
			  expect(fn).toHaveBeenCalledTimes(4)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "b": 0,
			        "payload": "lol",
			      \},
			      Object \{
			        "b": 1,
			        "payload": "",
			      \},
			      Object \{
			        "b": 2,
			        "payload": " ",
			      \},
			      Object \{
			        "b": 3,
			        "payload": "long word",
			      \},
			    ]
			  \`)
			\})
			it('supports array of stores', () => \{
			  const fn = jest.fn()
			  const hello = createEvent<string>()
			  const world = createEvent<string>()
			  const \$clockA = createStore('hello').on(hello, (_, word) => word)
			  const \$clockB = createStore('world').on(world, (_, word) => word)
			
			  const \$source = createStore(['word'])
			
			  \$source.on([\$clockA, \$clockB], (state, payload) => \{
			    fn(\{state, payload\})
			    return [...state, payload]
			  \})
			
			  hello('lol')
			  expect(fn).toHaveBeenCalledTimes(1)
			
			  world('')
			  expect(fn).toHaveBeenCalledTimes(2)
			  hello(' ')
			  expect(fn).toHaveBeenCalledTimes(3)
			
			  world('long word')
			  expect(fn).toHaveBeenCalledTimes(4)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "payload": "lol",
			        "state": Array [
			          "word",
			        ],
			      \},
			      Object \{
			        "payload": "",
			        "state": Array [
			          "word",
			          "lol",
			        ],
			      \},
			      Object \{
			        "payload": " ",
			        "state": Array [
			          "word",
			          "lol",
			          "",
			        ],
			      \},
			      Object \{
			        "payload": "long word",
			        "state": Array [
			          "word",
			          "lol",
			          "",
			          " ",
			        ],
			      \},
			    ]
			  \`)
			\})
			
			it('supports array of stores and events', () => \{
			  const fn = jest.fn()
			  const hello = createEvent<string>()
			  const world = createEvent<string>()
			  const \$clockA = createStore('hello').on(hello, (_, word) => word)
			
			  const \$source = createStore(['word'])
			
			  \$source.on([\$clockA, world], (state, payload) => \{
			    fn(\{state, payload\})
			    return [...state, payload]
			  \})
			
			  hello('lol')
			  expect(fn).toHaveBeenCalledTimes(1)
			
			  world('')
			  expect(fn).toHaveBeenCalledTimes(2)
			  hello(' ')
			  expect(fn).toHaveBeenCalledTimes(3)
			
			  world('long word')
			  expect(fn).toHaveBeenCalledTimes(4)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "payload": "lol",
			        "state": Array [
			          "word",
			        ],
			      \},
			      Object \{
			        "payload": "",
			        "state": Array [
			          "word",
			          "lol",
			        ],
			      \},
			      Object \{
			        "payload": " ",
			        "state": Array [
			          "word",
			          "lol",
			          "",
			        ],
			      \},
			      Object \{
			        "payload": "long word",
			        "state": Array [
			          "word",
			          "lol",
			          "",
			          " ",
			        ],
			      \},
			    ]
			  \`)
			\})
			describe('validation', () => \{
			  test('validation of first argument', () => \{
			    const foo = createStore(0)
			    expect(() => \{
			      //@ts-expect-error
			      foo.on(x => x + 1)
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`".on: expect first argument to be a unit (store, event or effect) or array of units"\`,
			    )
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\on.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\reset.test.ts', () => {
        const sourceCode = `
			import \{createStore, createEvent, forward\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			it('support spread of units', () => \{
			  const fn = jest.fn()
			  const set = createEvent<number>()
			  const a = createEvent()
			  const b = createEvent()
			  const store = createStore(0)
			    .on(set, (_, x) => x)
			    .reset(a, b)
			
			  store.updates.watch(fn)
			
			  set(1)
			  a()
			  set(2)
			  b()
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      1,
			      0,
			      2,
			      0,
			    ]
			  \`)
			\})
			
			it('support array of units', () => \{
			  const fn = jest.fn()
			  const set = createEvent<number>()
			  const a = createEvent()
			  const b = createEvent()
			  const store = createStore(0)
			    .on(set, (_, x) => x)
			    .reset([a, b])
			
			  store.updates.watch(fn)
			
			  set(1)
			  a()
			  set(2)
			  b()
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      1,
			      0,
			      2,
			      0,
			    ]
			  \`)
			\})
			
			describe('reset before computation', () => \{
			  test('reset before computation', () => \{
			    const fn = jest.fn()
			    const A = createEvent<string>()
			    const B = A.map(d => \`\$\{d\}->B\`)
			
			    const target = createStore('init')
			      .reset(B)
			      .on(A, (state, d) => \`\$\{state\} + \$\{d\}\`)
			
			    target.watch(e => \{
			      fn(e)
			    \})
			
			    A('[1]')
			    A('[2]')
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "init",
			        "init + [1]",
			        "init",
			        "init + [2]",
			        "init",
			      ]
			    \`)
			  \})
			
			  it("doesnt depend on methods' ordering", () => \{
			    const fn = jest.fn()
			    const A = createEvent<string>()
			    const B = A.map(d => \`\$\{d\}->B\`)
			
			    const target = createStore('init')
			      .on(A, (state, d) => \`\$\{state\} + \$\{d\}\`)
			      .reset(B)
			
			    target.watch(e => \{
			      fn(e)
			    \})
			
			    A('[1]')
			    A('[2]')
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "init",
			        "init + [1]",
			        "init",
			        "init + [2]",
			        "init",
			      ]
			    \`)
			  \})
			\})
			
			describe('computation before reset', () => \{
			  test('computation before reset', () => \{
			    const fn = jest.fn()
			    const A = createEvent<string>()
			    const B = A.map(d => \`\$\{d\}->B\`)
			
			    const target = createStore('init')
			      .reset(A)
			      .on(B, (state, d) => \`\$\{state\} + \$\{d\}\`)
			
			    target.watch(e => \{
			      fn(e)
			    \})
			
			    A('[1]')
			    A('[2]')
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "init",
			        "init + [1]->B",
			        "init",
			        "init + [2]->B",
			      ]
			    \`)
			  \})
			
			  it("doesnt depend on methods' ordering", () => \{
			    const fn = jest.fn()
			    const A = createEvent<string>()
			    const B = A.map(d => \`\$\{d\}->B\`)
			
			    const target = createStore('init')
			      .on(B, (state, d) => \`\$\{state\} + \$\{d\}\`)
			      .reset(A)
			
			    target.watch(e => \{
			      fn(e)
			    \})
			
			    A('[1]')
			    A('[2]')
			
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "init",
			        "init + [1]->B",
			        "init",
			        "init + [2]->B",
			      ]
			    \`)
			  \})
			\})
			
			test('late forwarding', () => \{
			  const A = createStore('A')
			  const B = createStore('B')
			  const reset = createEvent()
			
			  A.reset(reset)
			  B.reset(reset)
			
			  forward(\{from: A, to: B\})
			
			  //@ts-expect-error
			  A.setState('C')
			  reset() // reset
			
			  expect(A.getState()).toMatchInlineSnapshot(\`"A"\`)
			  expect(B.getState()).toMatchInlineSnapshot(\`"B"\`)
			
			  reset() // reset again
			
			  expect(A.getState()).toMatchInlineSnapshot(\`"A"\`)
			  expect(B.getState()).toMatchInlineSnapshot(\`"B"\`)
			\})
			
			describe('dependencies of resettable stores', () => \{
			  test('dependencies of resettable stores', () => \{
			    const warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			    const fnA = jest.fn()
			    const fnB = jest.fn()
			    const run = createEvent<string>()
			    const reset = run.map(d => \`\$\{d\}->reset\`)
			    const A = createStore('A')
			    const B = A.map(d => \`B(\$\{d\})\`)
			
			    A.on(run, (state, d) => \`\$\{d\}(\$\{state\})\`).reset(reset)
			    B.on(run, (state, d) => \`\$\{d\}(\$\{state\})\`).reset(reset)
			    warn.mockRestore()
			
			    A.watch(e => \{
			      fnA(e)
			    \})
			    B.watch(e => \{
			      fnB(e)
			    \})
			    run('run')
			    run('run')
			
			    expect(argumentHistory(fnA)).toMatchInlineSnapshot(\`
			      Array [
			        "A",
			        "run(A)",
			        "A",
			        "run(A)",
			        "A",
			      ]
			    \`)
			
			    expect(argumentHistory(fnB)).toMatchInlineSnapshot(\`
			      Array [
			        "B(A)",
			        "run(B(A))",
			        "B(A)",
			        "B(run(A))",
			        "B(A)",
			        "run(B(A))",
			        "B(A)",
			        "B(run(A))",
			        "B(A)",
			      ]
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\reset.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\stackSafety.test.ts', () => {
        const sourceCode = `
			import \{createStore\} from 'effector'
			
			it('stack safe', () => \{
			  const DEPTH = 10000
			  const src = createStore(0)
			  let current = src
			  for (let i = 0; i < DEPTH; i++) \{
			    current = current.map(n => n + 1)
			  \}
			  expect(current.getState()).toBe(DEPTH)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\stackSafety.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\updates.test.ts', () => {
        const sourceCode = `
			import \{createStore, is\} from 'effector'
			
			test('store.updates is event', () => \{
			  const store = createStore(0)
			  expect(is.event(store.updates)).toBe(true)
			\})
			
			it('triggers after each store update', () => \{
			  const fn = jest.fn()
			  const store = createStore(0)
			  store.updates.watch(e => fn(e))
			
			  /*
			    unlike store.watch, store.updates.watch will not been called immediately
			  */
			  expect(fn).not.toBeCalled()
			  //@ts-expect-error
			  store.setState(1)
			  expect(fn).toBeCalledTimes(1)
			  //@ts-expect-error
			  store.setState(1) // state will not change, as store.getState() === 1
			  expect(fn).toBeCalledTimes(1)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\updates.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\effector\\__tests__\\store\\watcher.test.ts', () => {
        const sourceCode = `
			import \{createStore, createEvent\} from 'effector'
			import \{argumentHistory\} from 'effector/fixtures'
			
			it('support watchers for event', () => \{
			  const fn = jest.fn()
			  const event = createEvent()
			  const watcher = event.watch(e => \{
			    fn(e)
			  \})
			
			  event(3)
			  event()
			  event(1)
			
			  expect(fn).toBeCalledTimes(3)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          3,
			          undefined,
			          1,
			        ]
			    \`)
			
			  watcher()
			
			  event(4)
			  expect(fn).toBeCalledTimes(3)
			\})
			
			it('support watchers for storages', () => \{
			  const fn = jest.fn()
			  const event = createEvent()
			  const store = createStore('none').on(event, (_, e) => e.toString())
			  const watcher = store.watch(e => \{
			    fn(e)
			  \})
			
			  event(3)
			  event(1)
			
			  expect(fn).toBeCalledTimes(3)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "none",
			          "3",
			          "1",
			        ]
			    \`)
			
			  watcher()
			
			  event(4)
			  expect(fn).toBeCalledTimes(3)
			\})
			
			it('support event watchers for storages', () => \{
			  const fn = jest.fn()
			  const event = createEvent()
			  const update = createEvent()
			  const store = createStore(0).on(update, (s, fn) => fn(s))
			
			  const watcher = event.watch(e => fn(e))
			
			  const watcher2 = store.watch(event)
			
			  update(a => a + 2)
			  update(a => a + 10)
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      0,
			      2,
			      12,
			    ]
			  \`)
			
			  watcher()
			  watcher2()
			\})
			
			it('support event watchers for storages', () => \{
			  const fn = jest.fn()
			  const sample = createEvent()
			  const store = createStore(0)
			
			  const watcher = store.watch(sample, fn)
			
			  sample()
			  sample()
			  sample()
			
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      0,
			      0,
			      0,
			    ]
			  \`)
			
			  watcher()
			\})
			
			it('support watchers for mapped storages', () => \{
			  const addMetaTag = (tag, unit: any) => \{
			    unit.graphite.scope.tag = tag
			  \}
			  const fn = jest.fn()
			  const event = createEvent()
			  const storeFirst = createStore('none').on(event, (_, e) => e.toString())
			  const store = storeFirst.map(e => \`/\$\{e\}\`)
			
			  addMetaTag('event', event)
			  addMetaTag('storeFirst', storeFirst)
			  addMetaTag('store', store)
			
			  const watcher = store.watch(e => \{
			    fn(e)
			  \})
			
			  event(3)
			
			  expect(fn).toBeCalledTimes(2)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			        Array [
			          "/none",
			          "/3",
			        ]
			    \`)
			
			  watcher()
			
			  event(4)
			  expect(fn).toBeCalledTimes(2)
			\})
			
			test('watch validation', () => \{
			  const store = createStore(null)
			  expect(() => \{
			    store.watch(NaN)
			  \}).toThrowErrorMatchingInlineSnapshot(
			    \`".watch argument should be a function"\`,
			  )
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\effector\\__tests__\\store\\watcher.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\forest\\__tests__\\classList.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{createEvent, createStore, restore\} from 'effector'
			import \{h, spec, using\} from 'forest'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			it('supports setting static object class without class attr', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: \{example: true, another: true\},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='example another'>content</div>
			      "
			    \`)
			\})
			
			it('supports setting static object class without class attr', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: ['example', 'another'],
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='example another'>content</div>
			      "
			    \`)
			\})
			it('supports setting static object class with class attr', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: \{example: true, another: true\},
			        attr: \{class: 'foreign'\},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='foreign example another'>content</div>
			      "
			    \`)
			\})
			it('supports setting static object class with class attr', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: ['example', 'another'],
			        attr: \{class: 'foreign'\},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='foreign example another'>content</div>
			      "
			    \`)
			\})
			it('supports setting static list of classes in a single string', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: ['example another', 'first second'],
			        attr: \{class: 'foreign'\},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div class='foreign example another first second'>
			      content
			    </div>
			    "
			  \`)
			\})
			it('supports setting dynamic object class', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const setClass = createEvent<boolean>()
			    const \$class = restore(setClass, false)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: \{example: \$class\},
			        attr: \{class: 'foreign'\},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      setClass(true)
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='foreign'>content</div>
			      "
			    \`)
			  expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div class='foreign example'>content</div>
			      "
			    \`)
			\})
			it('supports setting dynamic array class', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const setClass = createEvent<string>()
			    const \$class = restore(setClass, null)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: [\$class],
			        attr: \{class: 'foreign'\},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      setClass('example')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='foreign'>content</div>
			      "
			    \`)
			  expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div class='foreign example'>content</div>
			      "
			    \`)
			\})
			it('supports setting dynamic object class without class property', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const setClass = createEvent<boolean>()
			    const \$class = restore(setClass, false)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: \{example: \$class\},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      setClass(true)
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			  expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div class='example'>content</div>
			      "
			    \`)
			\})
			it('supports setting dynamic array class without class property', async () => \{
			  const [s1, s2, s3, s4] = await exec(async () => \{
			    const setClass = createEvent<string | null>()
			    const \$class = restore(setClass, null)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: [\$class],
			      \})
			    \})
			    await act()
			    await act(() => \{
			      setClass('example')
			    \})
			    await act(() => \{
			      setClass('another')
			    \})
			    await act(() => \{
			      setClass(null)
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			  expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div class='example'>content</div>
			      "
			    \`)
			  expect(s3).toMatchInlineSnapshot(\`
			      "
			      <div class='another'>content</div>
			      "
			    \`)
			  expect(s4).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			\})
			
			it('supports merging static classList h with spec', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: ['first'],
			        fn() \{
			          spec(\{classList: ['second']\})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='second first'>content</div>
			      "
			    \`)
			\})
			
			it('supports merging static classList h with spec of different types', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: ['first'],
			        fn() \{
			          spec(\{classList: ['second']\})
			          spec(\{classList: \{third: true\}\})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='second third first'>content</div>
			      "
			    \`)
			\})
			
			it('allows to set many classes at the same property', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        classList: ['first'],
			        fn() \{
			          spec(\{classList: \{'second third': true\}\})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='second third first'>content</div>
			      "
			    \`)
			\})
			
			it('supports merging dynamic spec classList', async () => \{
			  const [s1, s2, s3] = await exec(async () => \{
			    const setClassA = createEvent<string>()
			    const \$classA = restore(setClassA, null)
			    const setClassB = createEvent<boolean>()
			    const \$classB = restore(setClassB, false)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        fn() \{
			          spec(\{classList: [\$classA]\})
			          spec(\{classList: \{third: \$classB\}\})
			        \},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      setClassA('demo')
			    \})
			    await act(() => \{
			      setClassB(true)
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			  expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div class='demo'>content</div>
			      "
			    \`)
			  expect(s3).toMatchInlineSnapshot(\`
			      "
			      <div class='demo third'>content</div>
			      "
			    \`)
			\})
			
			it('allows to dynamically set many classes at the one property', async () => \{
			  const [s1, s2, s3, s4, s5] = await exec(async () => \{
			    const setClassA = createEvent<string | null>()
			    const \$classA = restore(setClassA, null)
			    const setClassB = createEvent<boolean>()
			    const \$classB = restore(setClassB, false)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        fn() \{
			          spec(\{classList: [\$classA]\})
			          spec(\{classList: \{'first second third': \$classB\}\})
			        \},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      setClassA('demo foo bar')
			    \})
			    await act(() => \{
			      setClassB(true)
			    \})
			    await act(() => \{
			      setClassA(null)
			    \})
			    await act(() => \{
			      setClassB(false)
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			  expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div class='demo foo bar'>content</div>
			      "
			    \`)
			  expect(s3).toMatchInlineSnapshot(\`
			      "
			      <div class='demo foo bar first second third'>content</div>
			      "
			    \`)
			  expect(s4).toMatchInlineSnapshot(\`
			      "
			      <div class='first second third'>content</div>
			      "
			    \`)
			  expect(s5).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			\})
			
			it('supports merging dynamic and static spec classList', async () => \{
			  const [s1, s2, s3, s4, s5] = await exec(async () => \{
			    const cleanup = createEvent()
			    const setClass3 = createEvent<boolean>()
			    const \$class3 = restore(setClass3, false).reset(cleanup)
			    const setClass4 = createEvent<string>()
			    const \$class4 = restore(setClass4, null).reset(cleanup)
			    const setClass5 = createEvent<boolean>()
			    const \$class5 = restore(setClass5, false).reset(cleanup)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        attr: \{class: 'first'\},
			        classList: \{second: true, third: \$class3\},
			        fn() \{
			          spec(\{classList: [\$class4]\})
			          spec(\{classList: \{fifth: \$class5\}\})
			        \},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      setClass3(true)
			    \})
			    await act(() => \{
			      setClass4('fourth')
			    \})
			    await act(() => \{
			      setClass5(true)
			    \})
			    await act(() => \{
			      cleanup()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='first second'>content</div>
			      "
			    \`)
			  expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div class='first second third'>content</div>
			      "
			    \`)
			  expect(s3).toMatchInlineSnapshot(\`
			      "
			      <div class='first second third fourth'>content</div>
			      "
			    \`)
			  expect(s4).toMatchInlineSnapshot(\`
			      "
			      <div class='first second third fourth fifth'>content</div>
			      "
			    \`)
			  expect(s5).toMatchInlineSnapshot(\`
			      "
			      <div class='first second'>content</div>
			      "
			    \`)
			\})
			
			it('example from proposal #599 with overriding false values', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        fn() \{
			          spec(\{attr: \{class: 'zero'\}\})
			          spec(\{classList: \{first: true, second: false\}\})
			          spec(\{classList: ['second', 'third']\})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div class='zero first second third'>content</div>
			      "
			    \`)
			\})
			
			it('do not set static class if value is false', async () => \{
			  const [s1] = await exec(async () => \{
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        fn() \{
			          spec(\{classList: \{first: false, second: false\}\})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			\})
			
			it('do not set dynamic class if value is false', async () => \{
			  const [s1] = await exec(async () => \{
			    const \$class = createStore(false)
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        fn() \{
			          spec(\{classList: \{first: \$class, second: false\}\})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>content</div>
			      "
			    \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\classList.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(18)
    });
    it('effector_effector\\src\\forest\\__tests__\\handler.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{createStore, createEvent, restore, combine, sample\} from 'effector'
			import \{h, using, list, remap, spec, variant, node, handler\} from 'forest'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			test('click', async () => \{
			  const clicked = await execFunc(async () => \{
			    const click = createEvent<MouseEvent>()
			    let clicked = false
			    click.watch(e => \{
			      clicked = true
			    \})
			    using(el, () => \{
			      h('button', () => \{
			        spec(\{
			          attr: \{id: 'btn'\},
			          handler: \{click\},
			        \})
			      \})
			    \})
			    await act()
			    document.getElementById('btn')!.click()
			    return clicked
			  \})
			
			  expect(clicked).toMatchInlineSnapshot(\`true\`)
			\})
			test('prevented event', async () => \{
			  const prevented = await execFunc(async () => \{
			    const click = createEvent<MouseEvent>()
			    let isPrevented = false
			
			    click.watch(e => \{
			      isPrevented = e.defaultPrevented
			    \})
			
			    using(el, () => \{
			      h('button', () => \{
			        handler(\{prevent: true\}, \{click\})
			        spec(\{attr: \{id: 'btn'\}\})
			      \})
			    \})
			    await act()
			    document.getElementById('btn')!.click()
			    return isPrevented
			  \})
			
			  expect(prevented).toMatchInlineSnapshot(\`true\`)
			\})
			test('change passive property if prevent is [true]', async () => \{
			  const prevented = await execFunc(async () => \{
			    const click = createEvent<MouseEvent>()
			    let isPrevented = false
			
			    click.watch(e => \{
			      isPrevented = e.defaultPrevented
			    \})
			
			    using(el, () => \{
			      h('button', () => \{
			        handler(\{prevent: true, passive: true\}, \{click\})
			        spec(\{attr: \{id: 'btn'\}\})
			      \})
			    \})
			    await act()
			    document.getElementById('btn')!.click()
			    return isPrevented
			  \})
			
			  expect(prevented).toMatchInlineSnapshot(\`true\`)
			\})
			
			it('should support imperative preventDefault calls', async () => \{
			  const prevented = await execFunc(async () => \{
			    const click = createEvent<MouseEvent>()
			    let isPrevented = false
			
			    click.watch(e => \{
			      e.preventDefault()
			      isPrevented = e.defaultPrevented
			    \})
			
			    using(el, () => \{
			      h('button', \{
			        attr: \{id: 'btn'\},
			        handler: \{click\},
			      \})
			    \})
			    await act()
			    document.getElementById('btn')!.click()
			    return isPrevented
			  \})
			
			  expect(prevented).toBe(true)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\handler.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('effector_effector\\src\\forest\\__tests__\\index.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{createEvent, createStore, restore, sample\} from 'effector'
			import \{block, h, list, node, rec, remap, spec, text, using\} from 'forest'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			it('works', async () => \{
			  const [s1] = await exec(async () => \{
			    const store = createStore([\{name: 'alice'\}, \{name: 'bob'\}, \{name: 'carol'\}])
			    using(el, () => \{
			      h('header', () => \{
			        h('h1', \{
			          text: 'App title',
			        \})
			      \})
			      h('ul', () => \{
			        list(store, (\{store\}) => \{
			          h('li', \{
			            text: remap(store, 'name'),
			          \})
			        \})
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <header><h1>App title</h1></header>
			    <ul>
			      <li>alice</li>
			      <li>bob</li>
			      <li>carol</li>
			    </ul>
			    "
			  \`)
			\})
			
			it('update content after store update', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const updateText = createEvent<string>()
			    const text = restore(updateText, 'text value')
			    using(el, () => \{
			      h('div', \{
			        text,
			      \})
			    \})
			    await act()
			    await act(() => \{
			      updateText('updated')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div>text value</div>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div>updated</div>
			    "
			  \`)
			\})
			
			it('support reactive style properties', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const updateAlign = createEvent<string>()
			    const align = restore(updateAlign, 'start')
			
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        style: \{
			          justifySelf: align,
			        \},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      updateAlign('center')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div style='justify-self: start'>content</div>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div style='justify-self: center'>content</div>
			    "
			  \`)
			\})
			
			describe('node(event) + upward store update', () => \{
			  test('with units inside using', async () => \{
			    const result = await execFunc(async () => \{
			      let result = '--'
			      using(el, () => \{
			        const update = createEvent<string>()
			        const target = createStore('--').on(update, (_, upd) => upd)
			        target.watch(value => \{
			          result = value
			        \})
			        h('div', () => \{
			          node(node => \{
			            update(node.tagName)
			          \})
			        \})
			      \})
			      await act()
			      return result
			    \})
			    expect(result).toMatchInlineSnapshot(\`"DIV"\`)
			  \})
			  test('with units in root', async () => \{
			    const result = await execFunc(async () => \{
			      let result = '--'
			      const update = createEvent<string>()
			      const target = createStore('--').on(update, (_, upd) => upd)
			      target.watch(value => \{
			        result = value
			      \})
			      using(el, () => \{
			        h('div', () => \{
			          node(node => \{
			            update(node.tagName)
			          \})
			        \})
			      \})
			      await act()
			      return result
			    \})
			    expect(result).toMatchInlineSnapshot(\`"DIV"\`)
			  \})
			\})
			test('node() is called exactly once', async () => \{
			  const result = await execFunc(async () => \{
			    let result = 0
			    using(el, () => \{
			      h('div', () => \{
			        node(() => \{
			          result += 1
			        \})
			      \})
			    \})
			    await act()
			    return result
			  \})
			  expect(result).toBe(1)
			\})
			
			it('support reactive style variables', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const updateAlign = createEvent<string>()
			    const align = restore(updateAlign, 'start')
			
			    using(el, () => \{
			      h('div', \{
			        text: 'content',
			        style: \{
			          justifySelf: 'var(--align)',
			        \},
			        styleVar: \{
			          align,
			        \},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      updateAlign('center')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div style='justify-self: var(--align); --align: start'>
			      content
			    </div>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div style='justify-self: var(--align); --align: center'>
			      content
			    </div>
			    "
			  \`)
			\})
			
			it.skip('remove watch calls after node removal', async () => \{
			  const [s1, s2, s3, s4] = await exec(async () => \{
			    const tick = createEvent<number>()
			    const logRecord = createEvent<string>()
			    const removeUser = createEvent<string>()
			    let id = 0
			    const log = createStore<\{id: number; value: string\}[]>([]).on(
			      logRecord,
			      (list, rec) => [...list, \{value: rec, id: ++id\}],
			    )
			
			    const users = createStore(['alice', 'bob', 'carol']).on(
			      removeUser,
			      (list, user) => list.filter(e => e !== user),
			    )
			
			    using(el, () => \{
			      h('section', () => \{
			        list(users, (\{store\}) => \{
			          h('div', \{text: store\})
			          sample(\{
			            source: store,
			            clock: tick,
			            fn: (user, tick) => (\{user, tick\}),
			          \}).watch((\{user, tick\}) => \{
			            logRecord(\`[\$\{tick\}] \$\{user\}\`)
			          \})
			        \})
			      \})
			      h('section', () => \{
			        list(
			          \{source: log, key: 'id', fields: ['value']\},
			          (\{fields: [value]\}) => \{
			            h('div', \{text: value\})
			          \},
			        )
			      \})
			    \})
			    await act()
			    await act(() => \{
			      tick(0)
			    \})
			    await act(() => \{
			      removeUser('bob')
			    \})
			    await act(() => \{
			      tick(1)
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <section>
			      <div>alice</div>
			      <div>bob</div>
			      <div>carol</div>
			    </section>
			    <section></section>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <section>
			      <div>alice</div>
			      <div>bob</div>
			      <div>carol</div>
			    </section>
			    <section>
			      <div>[0] alice</div>
			      <div>[0] bob</div>
			      <div>[0] carol</div>
			    </section>
			    "
			  \`)
			  expect(s3).toMatchInlineSnapshot(\`
			    "
			    <section>
			      <div>alice</div>
			      <div>carol</div>
			    </section>
			    <section>
			      <div>[0] alice</div>
			      <div>[0] bob</div>
			      <div>[0] carol</div>
			    </section>
			    "
			  \`)
			  expect(s4).toMatchInlineSnapshot(\`
			    "
			    <section>
			      <div>alice</div>
			      <div>carol</div>
			    </section>
			    <section>
			      <div>[0] alice</div>
			      <div>[0] bob</div>
			      <div>[0] carol</div>
			      <div>[1] alice</div>
			      <div>[1] carol</div>
			    </section>
			    "
			  \`)
			\})
			
			describe('node reader', () => \{
			  it('called after dom node mounting', async () => \{
			    const [s1] = await exec(async () => \{
			      type Log = \{
			        id: number
			        key: string
			        value: string
			      \}
			      const addLog = createEvent<\{key: any; value: any\}>()
			      const logs = createStore<Log[]>([]).on(addLog, (list, \{key, value\}) => [
			        ...list,
			        \{
			          id: list.length,
			          key: String(key),
			          value: String(value),
			        \},
			      ])
			
			      using(el, () => \{
			        h('div', () => \{
			          node(node => \{
			            addLog(\{
			              key: 'is connected',
			              value: node.isConnected,
			            \})
			            addLog(\{
			              key: 'has parent',
			              value: !!node.parentElement,
			            \})
			          \})
			        \})
			        h('dl', () => \{
			          list(
			            \{source: logs, key: 'id', fields: ['key', 'value']\},
			            (\{fields: [key, value]\}) => \{
			              h('dt', \{text: key\})
			              h('dd', \{text: value\})
			            \},
			          )
			        \})
			      \})
			      await act()
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div></div>
			      <dl>
			        <dt>is connected</dt>
			        <dd>true</dd>
			        <dt>has parent</dt>
			        <dd>true</dd>
			      </dl>
			      "
			    \`)
			  \})
			\})
			
			it('support multiply text nodes', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const trigger = createEvent()
			    const foo = createStore('aaa').on(trigger, () => 'cccc')
			    const bar = createStore('bbb').on(trigger, () => 'dddd')
			    using(el, () => \{
			      h('div', () => \{
			        spec(\{text: foo\})
			        spec(\{text: bar\})
			      \})
			    \})
			    await act()
			    await act(() => \{
			      trigger()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div>aaabbb</div>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div>ccccdddd</div>
			    "
			  \`)
			\})
			
			describe('dom namespaces', () => \{
			  test('svg support', async () => \{
			    const [s1] = await exec(async () => \{
			      using(el, () => \{
			        h('div', () => \{
			          h('svg', \{
			            attr: \{width: 500\},
			            fn() \{
			              h('g', \{
			                attr: \{transform: 'translate(5 10)'\},
			              \})
			            \},
			          \})
			        \})
			      \})
			      await act()
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <svg xmlns='http://www.w3.org/2000/svg' width='500'>
			          <g transform='translate(5 10)'></g>
			        </svg>
			      </div>
			      "
			    \`)
			  \})
			  test('foreignObject support', async () => \{
			    const [s1] = await exec(async () => \{
			      using(el, () => \{
			        h('div', () => \{
			          h('svg', \{
			            attr: \{width: 500\},
			            fn() \{
			              h('g', \{
			                attr: \{transform: 'translate(5 10)'\},
			                fn() \{
			                  h('foreignObject', () => \{
			                    h('div', \{
			                      attr: \{title: 'foreign child'\},
			                      fn() \{
			                        h('div', \{
			                          attr: \{title: 'nested child'\},
			                        \})
			                      \},
			                    \})
			                  \})
			                \},
			              \})
			            \},
			          \})
			        \})
			      \})
			      await act()
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <svg xmlns='http://www.w3.org/2000/svg' width='500'>
			          <g transform='translate(5 10)'>
			            <foreignObject
			              ><div
			                xmlns='http://www.w3.org/1999/xhtml'
			                title='foreign child'
			              >
			                <div title='nested child'></div></div
			            ></foreignObject>
			          </g>
			        </svg>
			      </div>
			      "
			    \`)
			  \})
			\})
			
			test('hydrate', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const inc = createEvent()
			    const count = createStore(0).on(inc, x => x + 1)
			    const rootItem = createStore(null)
			    const Item = rec<any>(\{
			      fn() \{
			        h('div', \{
			          text: 'root',
			        \})
			      \},
			    \})
			    const Tag = block(\{
			      fn() \{
			        h('span', \{
			          text: 'SPAN',
			        \})
			      \},
			    \})
			    const App = block(\{
			      fn() \{
			        Tag()
			        h('h1', \{text: 'List'\})
			        Item(\{store: rootItem\})
			        h('p', \{
			          text: ['count = ', count],
			        \})
			      \},
			    \})
			
			    el.innerHTML = \`
			      <span>SPAN</span>
			      <h1>List</h1>
			      <div>root</div>
			      <p>count = 0</p>
			    \`
			    using(el, \{
			      fn: App,
			      hydrate: true,
			    \})
			    await act()
			    await act(async () => \{
			      inc()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <span>SPAN</span>
			    <h1>List</h1>
			    <div>root</div>
			    <p>count = 0</p>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <span>SPAN</span>
			    <h1>List</h1>
			    <div>root</div>
			    <p>count = 1</p>
			    "
			  \`)
			\})
			
			test('template match bug', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const initial = Array.from(\{length: 15\}, (_, id) => (\{
			      id: \`id_\$\{id\}\`,
			      data: (id * 1000).toString(36),
			    \}))
			
			    const patch = createEvent<\{id: string; data: string\}>()
			    const \$list = createStore(initial).on(patch, (list, \{id, data\}) => \{
			      return list.map(item => \{
			        if (item.id === id) return \{id, data\}
			        return item
			      \})
			    \})
			
			    using(el, () => \{
			      h('ul', () => \{
			        list(\$list, (\{store\}) => \{
			          const click = createEvent<MouseEvent>()
			          sample(\{
			            source: store,
			            clock: click,
			            fn: (\{id\}) => (\{id, data: 'PATCHED'\}),
			            target: patch,
			          \})
			          const [id, data] = remap(store, ['id', 'data'] as const)
			          h('li', \{
			            attr: \{id\},
			            handler: \{click\},
			            fn() \{
			              h('u', \{text: data\})
			            \},
			          \})
			        \})
			      \})
			    \})
			    await act()
			    await act(async () => \{
			      const li = el.querySelector('#id_0')! as HTMLElement
			      li.click()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <ul>
			      <li id='id_0'><u>0</u></li>
			      <li id='id_1'><u>rs</u></li>
			      <li id='id_2'><u>1jk</u></li>
			      <li id='id_3'><u>2bc</u></li>
			      <li id='id_4'><u>334</u></li>
			      <li id='id_5'><u>3uw</u></li>
			      <li id='id_6'><u>4mo</u></li>
			      <li id='id_7'><u>5eg</u></li>
			      <li id='id_8'><u>668</u></li>
			      <li id='id_9'><u>6y0</u></li>
			      <li id='id_10'><u>7ps</u></li>
			      <li id='id_11'><u>8hk</u></li>
			      <li id='id_12'><u>99c</u></li>
			      <li id='id_13'><u>a14</u></li>
			      <li id='id_14'><u>asw</u></li>
			    </ul>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <ul>
			      <li id='id_0'><u>PATCHED</u></li>
			      <li id='id_1'><u>rs</u></li>
			      <li id='id_2'><u>1jk</u></li>
			      <li id='id_3'><u>2bc</u></li>
			      <li id='id_4'><u>334</u></li>
			      <li id='id_5'><u>3uw</u></li>
			      <li id='id_6'><u>4mo</u></li>
			      <li id='id_7'><u>5eg</u></li>
			      <li id='id_8'><u>668</u></li>
			      <li id='id_9'><u>6y0</u></li>
			      <li id='id_10'><u>7ps</u></li>
			      <li id='id_11'><u>8hk</u></li>
			      <li id='id_12'><u>99c</u></li>
			      <li id='id_13'><u>a14</u></li>
			      <li id='id_14'><u>asw</u></li>
			    </ul>
			    "
			  \`)
			\})
			
			describe('text\`\`', () => \{
			  it('support template literals', async () => \{
			    const [s1] = await exec(async () => \{
			      const name = createStore('alice')
			      const nbsp = '\\u00A0'
			      using(el, () => \{
			        h('span', () => \{
			          text\`username\$\{nbsp\}: \$\{name\}\`
			        \})
			      \})
			      await act()
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <span>username&nbsp;: alice</span>
			      "
			    \`)
			  \})
			  test('text(store) edge case', async () => \{
			    const [s1] = await exec(async () => \{
			      const name = createStore('alice')
			      using(el, () => \{
			        h('span', () => \{
			          //@ts-expect-error
			          text(name)
			        \})
			      \})
			      await act()
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <span>alice</span>
			      "
			    \`)
			  \})
			  test('text(string) edge case', async () => \{
			    const [s1] = await exec(async () => \{
			      using(el, () => \{
			        h('span', () => \{
			          //@ts-expect-error
			          text('alice')
			        \})
			      \})
			      await act()
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <span>alice</span>
			      "
			    \`)
			  \})
			  test('text(array) edge case', async () => \{
			    const [s1] = await exec(async () => \{
			      const name = createStore('alice')
			      using(el, () => \{
			        h('span', () => \{
			          //@ts-expect-error
			          text(['username: ', name])
			        \})
			      \})
			      await act()
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <span>username: alice</span>
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(17)
    });
    it('effector_effector\\src\\forest\\__tests__\\list.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{createStore, createEvent, restore, combine\} from 'effector'
			import \{h, using, list, remap, spec, variant, rec\} from 'forest'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			test('edge case with duplicated keys', async () => \{
			  const [initial, s1, s2, s3] = await exec(async () => \{
			    const \$list = createStore<(string | number)[]>(['green', 'yellow', 'red'])
			    const add = createEvent<MouseEvent>()
			
			    \$list.on(add, list => [1, ...list])
			
			    using(el, () => \{
			      list(\{
			        source: \$list,
			        //@ts-expect-error
			        key: item => item,
			        fn: (\{store\}) => \{
			          store.watch(console.log)
			          h('div', \{text: store\})
			        \},
			      \})
			      h('button', \{text: '+', handler: \{click: add\}, attr: \{id: 'click'\}\})
			    \})
			    await act()
			    await act(async () => \{
			      document.getElementById('click')!.click()
			    \})
			    await act(async () => \{
			      document.getElementById('click')!.click()
			    \})
			    await act(async () => \{
			      document.getElementById('click')!.click()
			    \})
			  \})
			  expect(initial).toMatchInlineSnapshot(\`
			    "
			    <div>green</div>
			    <div>yellow</div>
			    <div>red</div>
			    <button id='click'>+</button>
			    "
			  \`)
			  /**
			   * TODO: Wrong behavior!
			   *
			   * 1 should be first item, not last
			   */
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div>green</div>
			    <div>yellow</div>
			    <div>red</div>
			    <div>1</div>
			    <button id='click'>+</button>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div>green</div>
			    <div>yellow</div>
			    <div>red</div>
			    <div>1</div>
			    <div>1</div>
			    <button id='click'>+</button>
			    "
			  \`)
			  /**
			   * TODO: Wrong behavior!
			   *
			   * click should add one item, not two
			   */
			  expect(s3).toMatchInlineSnapshot(\`
			    "
			    <div>green</div>
			    <div>yellow</div>
			    <div>red</div>
			    <div>1</div>
			    <div>1</div>
			    <div>1</div>
			    <div>1</div>
			    <button id='click'>+</button>
			    "
			  \`)
			\})
			
			it('support list sequences without keys', async () => \{
			  const [s1, s2, s3, s4] = await exec(async () => \{
			    const addTeamAMember = createEvent<string>()
			    const removeTeamAMember = createEvent<string>()
			    const teamA = createStore([\{name: 'alice'\}, \{name: 'bob'\}])
			    const teamB = createStore([\{name: 'carol'\}])
			
			    teamA
			      .on(addTeamAMember, (list, name) => [...list, \{name\}])
			      .on(removeTeamAMember, (list, name) => list.filter(e => e.name !== name))
			
			    using(el, () => \{
			      list(teamA, (\{store\}) => \{
			        h('div', \{
			          text: remap(store, 'name'),
			        \})
			      \})
			      list(teamB, (\{store\}) => \{
			        h('div', \{
			          text: remap(store, 'name'),
			        \})
			      \})
			    \})
			    await act()
			    await act(() => \{
			      addTeamAMember('carol')
			    \})
			    await act(() => \{
			      addTeamAMember('charlie')
			    \})
			    await act(() => \{
			      removeTeamAMember('carol')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>carol</div>
			    "
			  \`)
			
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>carol</div>
			    <div>carol</div>
			    "
			  \`)
			
			  expect(s3).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>carol</div>
			    <div>charlie</div>
			    <div>carol</div>
			    "
			  \`)
			
			  expect(s4).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>charlie</div>
			    <div>carol</div>
			    "
			  \`)
			\})
			it('support list sequences with keys', async () => \{
			  const [s1, s2, s3, s4] = await exec(async () => \{
			    const addTeamAMember = createEvent<string>()
			    const removeTeamAMember = createEvent<string>()
			    const teamA = createStore([\{name: 'alice'\}, \{name: 'bob'\}])
			    const teamB = createStore([\{name: 'carol'\}])
			
			    teamA
			      .on(addTeamAMember, (list, name) => [...list, \{name\}])
			      .on(removeTeamAMember, (list, name) => list.filter(e => e.name !== name))
			
			    using(el, () => \{
			      list(
			        \{source: teamA, key: 'name', fields: ['name']\},
			        (\{fields: [name]\}) => \{
			          h('div', \{text: name\})
			        \},
			      )
			      list(
			        \{source: teamB, key: 'name', fields: ['name']\},
			        (\{fields: [name]\}) => \{
			          h('div', \{text: name\})
			        \},
			      )
			    \})
			    await act()
			    await act(() => \{
			      addTeamAMember('carol')
			    \})
			    await act(() => \{
			      addTeamAMember('charlie')
			    \})
			    await act(() => \{
			      removeTeamAMember('carol')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>carol</div>
			    "
			  \`)
			
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>carol</div>
			    <div>carol</div>
			    "
			  \`)
			
			  expect(s3).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>carol</div>
			    <div>charlie</div>
			    <div>carol</div>
			    "
			  \`)
			
			  expect(s4).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    <div>charlie</div>
			    <div>carol</div>
			    "
			  \`)
			\})
			it('support text nodes', async () => \{
			  const [s1] = await exec(async () => \{
			    const text = createStore(['foo', 'bar'])
			    using(el, () => \{
			      list(text, (\{store\}) => \{
			        spec(\{text: store\})
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			
			    "
			  \`)
			\})
			describe('support visible changes', () => \{
			  it('works with non-keyed list', async () => \{
			    const [s1, s2] = await exec(async () => \{
			      const setTeam = createEvent<'a' | 'b'>()
			      const currentTeam = restore(setTeam, 'a')
			      const users = createStore([
			        \{name: 'alice', team: 'a'\},
			        \{name: 'bob', team: 'b'\},
			        \{name: 'carol', team: 'b'\},
			        \{name: 'dave', team: 'a'\},
			        \{name: 'eve', team: 'a'\},
			      ])
			
			      using(el, () => \{
			        list(users, (\{store\}) => \{
			          h('p', () => \{
			            spec(\{
			              visible: combine(
			                currentTeam,
			                store,
			                (current, \{team\}) => team === current,
			              ),
			            \})
			            h('div', \{
			              text: remap(store, 'name'),
			            \})
			            h('div', \{
			              text: remap(store, 'team'),
			            \})
			          \})
			        \})
			      \})
			      await act()
			      await act(() => \{
			        setTeam('b')
			      \})
			    \})
			    expect(s1).toMatchInlineSnapshot(
			      \`"<p><div>alice</div><div>a</div></p><p><div>dave</div><div>a</div></p><p><div>eve</div><div>a</div></p>"\`,
			    )
			    expect(s2).toMatchInlineSnapshot(
			      \`"<p><div>bob</div><div>b</div></p><p><div>carol</div><div>b</div></p>"\`,
			    )
			  \})
			  it('works with keyed list', async () => \{
			    const [s1, s2] = await exec(async () => \{
			      type User = \{
			        team: 'a' | 'b'
			        name: string
			      \}
			      const setTeam = createEvent<'a' | 'b'>()
			      const currentTeam = restore(setTeam, 'a')
			      const users = createStore<User[]>([
			        \{name: 'alice', team: 'a'\},
			        \{name: 'bob', team: 'b'\},
			        \{name: 'carol', team: 'b'\},
			        \{name: 'dave', team: 'a'\},
			        \{name: 'eve', team: 'a'\},
			      ])
			
			      using(el, () => \{
			        list(
			          \{source: users, key: 'name', fields: ['name', 'team']\},
			          (\{fields: [name, team]\}) => \{
			            h('p', () => \{
			              spec(\{
			                visible: combine(
			                  currentTeam,
			                  team,
			                  (current, team) => team === current,
			                ),
			              \})
			              h('div', \{text: name\})
			              h('div', \{text: team\})
			            \})
			          \},
			        )
			      \})
			      await act()
			      await act(() => \{
			        setTeam('b')
			      \})
			    \})
			    expect(s1).toMatchInlineSnapshot(
			      \`"<p><div>alice</div><div>a</div></p><p><div>dave</div><div>a</div></p><p><div>eve</div><div>a</div></p>"\`,
			    )
			    expect(s2).toMatchInlineSnapshot(
			      \`"<p><div>bob</div><div>b</div></p><p><div>carol</div><div>b</div></p>"\`,
			    )
			  \})
			\})
			it('create list from [fn] option', async () => \{
			  const [s1] = await exec(async () => \{
			    const users = createStore([
			      \{name: 'alice', id: 1\},
			      \{name: 'bob', id: 2\},
			    ])
			
			    using(el, () => \{
			      list(\{
			        source: users,
			        key: 'id',
			        fn: (\{store\}) => \{
			          h('li', \{text: store.map(v => v.name)\})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <li>alice</li>
			    <li>bob</li>
			    "
			  \`)
			\})
			it('insert its items before sibling nodes', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const addUser = createEvent<string>()
			    const users = createStore(['alice', 'bob']).on(addUser, (list, user) => [
			      ...list,
			      user,
			    ])
			    using(el, () => \{
			      list(users, (\{store\}) => \{
			        h('p', \{text: store\})
			      \})
			      h('footer', \{text: 'Users'\})
			    \})
			    await act()
			    await act(() => \{
			      addUser('carol')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <p>alice</p>
			    <p>bob</p>
			    <footer>Users</footer>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <p>alice</p>
			    <p>bob</p>
			    <p>carol</p>
			    <footer>Users</footer>
			    "
			  \`)
			\})
			
			it('support node unmounting', async () => \{
			  //prettier-ignore
			  type User =
			    | \{
			      id: number
			      name: string
			      status: 'user'
			    \}
			    | \{
			      id: number
			      name: string
			      status: 'admin'
			      roles: string[]
			    \};
			  await execFunc(async () => \{
			    const removeUser = createEvent<number>()
			    const removeUserRole = createEvent<\{userId: number; role: string\}>()
			    const users = createStore<User[]>([
			      \{
			        id: 1,
			        name: 'alice',
			        status: 'user',
			      \},
			      \{
			        id: 2,
			        name: 'bob',
			        status: 'admin',
			        roles: ['moderator', 'qa'],
			      \},
			      \{
			        id: 3,
			        name: 'carol',
			        status: 'admin',
			        roles: ['qa'],
			      \},
			      \{
			        id: 4,
			        name: 'charlie',
			        status: 'user',
			      \},
			    ])
			      .on(removeUser, (list, id) => list.filter(user => user.id !== id))
			      .on(removeUserRole, (list, \{userId, role\}) =>
			        list.map(user => \{
			          if (user.status !== 'admin') return user
			          if (user.id !== userId) return user
			          return \{
			            id: user.id,
			            name: user.name,
			            status: user.status,
			            roles: user.roles.filter(r => r !== role),
			          \}
			        \}),
			      )
			    const UserRec = rec<User>((\{store\}) => \{
			      h('article', () => \{
			        h('h2', \{
			          text: remap(store, 'name'),
			        \})
			        variant(\{
			          source: store,
			          key: 'status',
			          cases: \{
			            user() \{
			              h('div', \{text: 'user'\})
			            \},
			            admin(\{store\}) \{
			              const roles = remap(store, 'roles')
			              h('div', \{text: 'roles'\})
			              h('ul', () => \{
			                list(roles, (\{store\}) => \{
			                  h('li', \{text: store\})
			                \})
			              \})
			            \},
			          \},
			        \})
			      \})
			    \})
			
			    using(el, \{
			      fn() \{
			        list(\{
			          source: users,
			          key: 'id',
			          fn(\{store\}) \{
			            UserRec(\{store\})
			          \},
			        \})
			      \},
			    \})
			    await act()
			    await act(async () => \{
			      removeUserRole(\{
			        userId: 2,
			        role: 'qa',
			      \})
			    \})
			    await act(async () => \{
			      removeUser(4)
			    \})
			    await act(async () => \{
			      removeUser(1)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\list.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\forest\\__tests__\\reactiveTreeLaws.test.ts', () => {
        const sourceCode = `
			import \{
			  createStore,
			  createEvent,
			  sample,
			  combine,
			  forward,
			  Event,
			  Store,
			\} from 'effector'
			import \{h, using, list, node, spec, remap\} from 'forest'
			
			import prettyHtml from 'effector/fixtures/prettyHtml'
			
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			describe('update store from nested block', () => \{
			  describe('by sample', () => \{
			    test('with shared store', async () => \{
			      const [s1, s2, s3] = await exec(async () => \{
			        const title = createStore('clicked:')
			        const items = createStore(['a', 'b'])
			        await new Promise((rs: any) => \{
			          using(el, \{
			            fn() \{
			              list(items, (\{store\}) => \{
			                const click = createEvent<MouseEvent>()
			                sample(\{
			                  source: \{title, id: store\},
			                  clock: click,
			                  fn: (\{title, id\}) => \`\$\{title\} \$\{id\}\`,
			                  target: title,
			                \})
			                h('b', \{
			                  text: combine(store, title, (id, title) => \`\$\{id\} \$\{title\}\`),
			                  handler: \{click\},
			                  attr: \{id: store\},
			                \})
			              \})
			            \},
			            onComplete: rs,
			          \})
			        \})
			        await act()
			        const firstItem = el.querySelector('#a') as HTMLDivElement
			        const secondItem = el.querySelector('#b') as HTMLDivElement
			        await act(async () => \{
			          firstItem.click()
			        \})
			        await act(async () => \{
			          secondItem.click()
			        \})
			      \})
			      expect(s1).toMatchInlineSnapshot(\`
			        "
			        <b id='a'>a clicked:</b><b id='b'>b clicked:</b>
			        "
			      \`)
			      expect(s2).toMatchInlineSnapshot(\`
			        "
			        <b id='a'>a clicked: a</b><b id='b'>b clicked:</b>
			        "
			      \`)
			      expect(s3).toMatchInlineSnapshot(\`
			        "
			        <b id='a'>a clicked: a</b><b id='b'>b clicked: b</b>
			        "
			      \`)
			    \})
			    test('with templated store', async () => \{
			      const [s1, s2, s3] = await exec(async () => \{
			        const blocks = createStore(['A', 'B'])
			        const items = createStore(['a', 'b'])
			        await new Promise((rs: any) => \{
			          using(el, \{
			            fn() \{
			              list(blocks, (\{store: block\}) => \{
			                const title = createStore('clicked:')
			                list(items, (\{store\}) => \{
			                  const click = createEvent<MouseEvent>()
			                  sample(\{
			                    source: \{title, id: store, block\},
			                    clock: click,
			                    fn: (\{title, id, block\}) => \`\$\{title\} \$\{block\}\$\{id\}\`,
			                    target: title,
			                  \})
			                  h('b', \{
			                    text: combine(
			                      block,
			                      store,
			                      title,
			                      (block, id, title) => \`\$\{block\}\$\{id\} \$\{title\}\`,
			                    ),
			                    handler: \{click\},
			                    attr: \{
			                      id: combine(block, store, (block, id) => \`\$\{block\}\$\{id\}\`),
			                    \},
			                  \})
			                \})
			              \})
			            \},
			            onComplete: rs,
			          \})
			        \})
			        await act()
			        const firstItem = el.querySelector('#Aa') as HTMLDivElement
			        const secondItem = el.querySelector('#Bb') as HTMLDivElement
			        await act(async () => \{
			          firstItem.click()
			        \})
			        await act(async () => \{
			          secondItem.click()
			        \})
			      \})
			      expect(s1).toMatchInlineSnapshot(\`
			        "
			        <b id='Aa'>Aa clicked:</b><b id='Ab'>Ab clicked:</b
			        ><b id='Ba'>Ba clicked:</b><b id='Bb'>Bb clicked:</b>
			        "
			      \`)
			      expect(s2).toMatchInlineSnapshot(\`
			        "
			        <b id='Aa'>Aa clicked: Aa</b><b id='Ab'>Ab clicked: Aa</b
			        ><b id='Ba'>Ba clicked:</b><b id='Bb'>Bb clicked:</b>
			        "
			      \`)
			      expect(s3).toMatchInlineSnapshot(\`
			        "
			        <b id='Aa'>Aa clicked: Aa</b><b id='Ab'>Ab clicked: Aa</b
			        ><b id='Ba'>Ba clicked: Bb</b><b id='Bb'>Bb clicked: Bb</b>
			        "
			      \`)
			    \})
			  \})
			  describe('by on', () => \{
			    test('with shared store', async () => \{
			      const [s1, s2, s3] = await exec(async () => \{
			        const title = createStore('clicked:')
			        const items = createStore(['a', 'b'])
			        await new Promise((rs: any) => \{
			          using(el, \{
			            fn() \{
			              list(items, (\{store\}) => \{
			                const click = createEvent<MouseEvent>()
			                title.on(sample(store, click), (title, id) => \`\$\{title\} \$\{id\}\`)
			                h('b', \{
			                  text: combine(store, title, (id, title) => \`\$\{id\} \$\{title\}\`),
			                  handler: \{click\},
			                  attr: \{id: store\},
			                \})
			              \})
			            \},
			            onComplete: rs,
			          \})
			        \})
			        await act()
			        const firstItem = el.querySelector('#a') as HTMLDivElement
			        const secondItem = el.querySelector('#b') as HTMLDivElement
			        await act(async () => \{
			          firstItem.click()
			        \})
			        await act(async () => \{
			          secondItem.click()
			        \})
			      \})
			      expect(s1).toMatchInlineSnapshot(\`
			        "
			        <b id='a'>a clicked:</b><b id='b'>b clicked:</b>
			        "
			      \`)
			      expect(s2).toMatchInlineSnapshot(\`
			        "
			        <b id='a'>a clicked: a</b><b id='b'>b clicked:</b>
			        "
			      \`)
			      expect(s3).toMatchInlineSnapshot(\`
			        "
			        <b id='a'>a clicked: a</b><b id='b'>b clicked: a b</b>
			        "
			      \`)
			    \})
			    test('with templated store', async () => \{
			      const [s1, s2, s3] = await exec(async () => \{
			        const blocks = createStore(['A', 'B'])
			        const items = createStore(['a', 'b'])
			        await new Promise((rs: any) => \{
			          using(el, \{
			            fn() \{
			              list(blocks, (\{store: block\}) => \{
			                const title = createStore('clicked:')
			                list(items, (\{store\}) => \{
			                  const id = combine(
			                    block,
			                    store,
			                    (block, id) => \`\$\{block\}\$\{id\}\`,
			                  )
			                  const click = createEvent<MouseEvent>()
			                  title.on(sample(id, click), (title, id) => \`\$\{title\} \$\{id\}\`)
			                  h('b', \{
			                    text: combine(
			                      block,
			                      store,
			                      title,
			                      (block, id, title) => \`\$\{block\}\$\{id\} \$\{title\}\`,
			                    ),
			                    handler: \{click\},
			                    attr: \{id\},
			                  \})
			                \})
			              \})
			            \},
			            onComplete: rs,
			          \})
			        \})
			        await act()
			        const firstItem = el.querySelector('#Aa') as HTMLDivElement
			        const secondItem = el.querySelector('#Bb') as HTMLDivElement
			        await act(async () => \{
			          firstItem.click()
			        \})
			        await act(async () => \{
			          secondItem.click()
			        \})
			      \})
			      expect(s1).toMatchInlineSnapshot(\`
			        "
			        <b id='Aa'>Aa clicked:</b><b id='Ab'>Ab clicked:</b
			        ><b id='Ba'>Ba clicked:</b><b id='Bb'>Bb clicked:</b>
			        "
			      \`)
			      expect(s2).toMatchInlineSnapshot(\`
			        "
			        <b id='Aa'>Aa clicked: Aa</b><b id='Ab'>Ab clicked: Aa</b
			        ><b id='Ba'>Ba clicked:</b><b id='Bb'>Bb clicked:</b>
			        "
			      \`)
			      expect(s3).toMatchInlineSnapshot(\`
			        "
			        <b id='Aa'>Aa clicked: Aa</b><b id='Ab'>Ab clicked: Aa</b
			        ><b id='Ba'>Ba clicked: Bb</b><b id='Bb'>Bb clicked: Bb</b>
			        "
			      \`)
			    \})
			    describe('handler + on edge cases', () => \{
			      test('#1', async () => \{
			        const updates = await execFunc(async () => \{
			          const updates = [] as number[]
			          const count = createStore(0)
			
			          count.watch(upd => \{
			            updates.push(upd)
			          \})
			          await new Promise((rs: any) => \{
			            using(el, \{
			              onComplete: rs,
			              fn() \{
			                const click = createEvent<any>()
			                count.on(click, x => x + 1)
			                h('button', \{
			                  text: 'Store',
			                  handler: \{click\},
			                  attr: \{id: 'click'\},
			                \})
			              \},
			            \})
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#click')!.click()
			          \})
			          return updates
			        \})
			        expect(updates).toEqual([0, 1])
			      \})
			      describe('#2', () => \{
			        test('units in root', async () => \{
			          const [s1, s2, s3, s4] = await exec(async () => \{
			            const inc = createEvent<any>()
			            const \$counter = createStore(0)
			            \$counter.on(inc, count => count + 1)
			            await new Promise((rs: any) => \{
			              using(el, \{
			                fn() \{
			                  /**
			                    model-bound component
			                    same external \$counter
			                  */
			                  h('p', () => \{
			                    h('button', \{
			                      handler: \{click: inc\},
			                      text: \$counter,
			                      attr: \{id: 'a'\},
			                    \})
			                  \})
			                  h('p', () => \{
			                    h('button', \{
			                      handler: \{click: inc\},
			                      text: \$counter,
			                      attr: \{id: 'b'\},
			                    \})
			                  \})
			                  /**
			                    With internal units bounded to external units
			                    \$counter -> \$myCount, inc <- u
			                  */
			                  h('p', () => \{
			                    const up = createEvent<any>()
			                    const \$myCount = createStore(0)
			                    forward(\{from: \$counter, to: \$myCount\})
			                    forward(\{from: up, to: inc\})
			                    h('button', \{
			                      handler: \{click: up\},
			                      text: \$myCount,
			                      attr: \{id: 'c'\},
			                    \})
			                  \})
			                  h('p', () => \{
			                    const up = createEvent<any>()
			                    const \$myCount = createStore(0)
			                    forward(\{from: \$counter, to: \$myCount\})
			                    forward(\{from: up, to: inc\})
			                    h('button', \{
			                      handler: \{click: up\},
			                      text: \$myCount,
			                      attr: \{id: 'd'\},
			                    \})
			                  \})
			                \},
			                onComplete: rs,
			              \})
			            \})
			            await act()
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#a')!.click()
			            \})
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#c')!.click()
			            \})
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#b')!.click()
			            \})
			          \})
			          expect(s1).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>0</button></p>
			            <p><button id='b'>0</button></p>
			            <p><button id='c'>0</button></p>
			            <p><button id='d'>0</button></p>
			            "
			          \`)
			          expect(s2).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>1</button></p>
			            <p><button id='b'>1</button></p>
			            <p><button id='c'>1</button></p>
			            <p><button id='d'>1</button></p>
			            "
			          \`)
			          expect(s3).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>2</button></p>
			            <p><button id='b'>2</button></p>
			            <p><button id='c'>2</button></p>
			            <p><button id='d'>2</button></p>
			            "
			          \`)
			          expect(s4).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>3</button></p>
			            <p><button id='b'>3</button></p>
			            <p><button id='c'>3</button></p>
			            <p><button id='d'>3</button></p>
			            "
			          \`)
			        \})
			        test('units in using', async () => \{
			          const [s1, s2, s3, s4] = await exec(async () => \{
			            await new Promise((rs: any) => \{
			              using(el, \{
			                fn() \{
			                  const inc = createEvent<any>()
			                  const \$counter = createStore(0)
			                  \$counter.on(inc, count => count + 1)
			                  /**
			                    model-bound component
			                    same external \$counter
			                  */
			                  h('p', () => \{
			                    h('button', \{
			                      handler: \{click: inc\},
			                      text: \$counter,
			                      attr: \{id: 'a'\},
			                    \})
			                  \})
			                  h('p', () => \{
			                    h('button', \{
			                      handler: \{click: inc\},
			                      text: \$counter,
			                      attr: \{id: 'b'\},
			                    \})
			                  \})
			                  /**
			                    With internal units bounded to external units
			                    \$counter -> \$myCount, inc <- u
			                  */
			                  h('p', () => \{
			                    const up = createEvent<any>()
			                    const \$myCount = createStore(0)
			                    forward(\{from: \$counter, to: \$myCount\})
			                    forward(\{from: up, to: inc\})
			                    h('button', \{
			                      handler: \{click: up\},
			                      text: \$myCount,
			                      attr: \{id: 'c'\},
			                    \})
			                  \})
			                  h('p', () => \{
			                    const up = createEvent<any>()
			                    const \$myCount = createStore(0)
			                    forward(\{from: \$counter, to: \$myCount\})
			                    forward(\{from: up, to: inc\})
			                    h('button', \{
			                      handler: \{click: up\},
			                      text: \$myCount,
			                      attr: \{id: 'd'\},
			                    \})
			                  \})
			                \},
			                onComplete: rs,
			              \})
			            \})
			            await act()
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#a')!.click()
			            \})
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#c')!.click()
			            \})
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#b')!.click()
			            \})
			          \})
			          expect(s1).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>0</button></p>
			            <p><button id='b'>0</button></p>
			            <p><button id='c'>0</button></p>
			            <p><button id='d'>0</button></p>
			            "
			          \`)
			          expect(s2).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>1</button></p>
			            <p><button id='b'>1</button></p>
			            <p><button id='c'>1</button></p>
			            <p><button id='d'>1</button></p>
			            "
			          \`)
			          expect(s3).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>2</button></p>
			            <p><button id='b'>2</button></p>
			            <p><button id='c'>2</button></p>
			            <p><button id='d'>2</button></p>
			            "
			          \`)
			          expect(s4).toMatchInlineSnapshot(\`
			            "
			            <p><button id='a'>3</button></p>
			            <p><button id='b'>3</button></p>
			            <p><button id='c'>3</button></p>
			            <p><button id='d'>3</button></p>
			            "
			          \`)
			        \})
			      \})
			      describe('#3', () => \{
			        test('external store and event', async () => \{
			          const [s1, s2, s3] = await exec(async () => \{
			            const enable = createEvent<any>()
			            const disable = createEvent<any>()
			            const enabled = createStore(false)
			              .on(enable, () => true)
			              .on(disable, () => false)
			            const disabled = enabled.map(is => !is)
			            await new Promise((rs: any) => \{
			              using(el, \{
			                fn() \{
			                  h('button', \{
			                    text: 'Enable',
			                    attr: \{disabled: enabled, id: 'a'\},
			                    handler: \{click: enable\},
			                  \})
			                  h('button', \{
			                    text: 'Disable',
			                    attr: \{disabled, id: 'b'\},
			                    handler: \{click: disable\},
			                  \})
			                  h('button', \{
			                    text: 'Disable',
			                    attr: \{disabled, id: 'c'\},
			                    handler: \{click: disable\},
			                  \})
			                \},
			                onComplete: rs,
			              \})
			            \})
			            await act()
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#a')!.click()
			            \})
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#b')!.click()
			            \})
			          \})
			          expect(s1).toMatchInlineSnapshot(\`
			            "
			            <button id='a'>Enable</button
			            ><button id='b' disabled='true'>Disable</button
			            ><button id='c' disabled='true'>Disable</button>
			            "
			          \`)
			          expect(s2).toMatchInlineSnapshot(\`
			            "
			            <button id='a' disabled='true'>Enable</button
			            ><button id='b'>Disable</button
			            ><button id='c'>Disable</button>
			            "
			          \`)
			          expect(s3).toMatchInlineSnapshot(\`
			            "
			            <button id='a'>Enable</button
			            ><button id='b' disabled='true'>Disable</button
			            ><button id='c' disabled='true'>Disable</button>
			            "
			          \`)
			        \})
			        test('internal store and event', async () => \{
			          const [s1, s2, s3] = await exec(async () => \{
			            await new Promise((rs: any) => \{
			              using(el, \{
			                fn() \{
			                  const enable = createEvent<any>()
			                  const disable = createEvent<any>()
			                  const enabled = createStore(false)
			                    .on(enable, () => true)
			                    .on(disable, () => false)
			                  const disabled = enabled.map(is => !is)
			                  h('button', \{
			                    text: 'Enable',
			                    attr: \{disabled: enabled, id: 'a'\},
			                    handler: \{click: enable\},
			                  \})
			                  h('button', \{
			                    text: 'Disable',
			                    attr: \{disabled, id: 'b'\},
			                    handler: \{click: disable\},
			                  \})
			                  h('button', \{
			                    text: 'Disable',
			                    attr: \{disabled, id: 'c'\},
			                    handler: \{click: disable\},
			                  \})
			                \},
			                onComplete: rs,
			              \})
			            \})
			            await act()
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#a')!.click()
			            \})
			            await act(async () => \{
			              el.querySelector<HTMLButtonElement>('#b')!.click()
			            \})
			          \})
			          expect(s1).toMatchInlineSnapshot(\`
			            "
			            <button id='a'>Enable</button
			            ><button id='b' disabled='true'>Disable</button
			            ><button id='c' disabled='true'>Disable</button>
			            "
			          \`)
			          expect(s2).toMatchInlineSnapshot(\`
			            "
			            <button id='a' disabled='true'>Enable</button
			            ><button id='b'>Disable</button
			            ><button id='c'>Disable</button>
			            "
			          \`)
			          expect(s3).toMatchInlineSnapshot(\`
			            "
			            <button id='a'>Enable</button
			            ><button id='b' disabled='true'>Disable</button
			            ><button id='c' disabled='true'>Disable</button>
			            "
			          \`)
			        \})
			      \})
			    \})
			  \})
			\})
			
			describe('watchers support', () => \{
			  test('from global store', async () => \{
			    const updates = await execFunc(async () => \{
			      const updates = [] as number[]
			      const inc = createEvent()
			      const count = createStore(0).on(inc, x => x + 1)
			      using(el, \{
			        fn() \{
			          count.watch(e => \{
			            updates.push(e)
			          \})
			        \},
			      \})
			      await act(async () => \{
			        inc()
			      \})
			      return updates
			    \})
			    expect(updates).toEqual([0, 1])
			  \})
			\})
			
			describe('store and event on a same level', () => \{
			  test('on support', async () => \{
			    const updates = await execFunc(async () => \{
			      const updates = [] as number[]
			      await new Promise((rs: any) => \{
			        using(el, \{
			          onComplete: rs,
			          fn() \{
			            const delta = createStore(0)
			            const gotHeight = createEvent<number>()
			            delta.on(gotHeight, (_, x) => x)
			            delta.watch(x => \{
			              updates.push(x)
			            \})
			            h('div', \{
			              text: '~/ - /~',
			              fn() \{
			                node(() => \{
			                  gotHeight(10)
			                \})
			              \},
			            \})
			          \},
			        \})
			      \})
			      return updates
			    \})
			    expect(updates).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        10,
			      ]
			    \`)
			  \})
			  test('forward support', async () => \{
			    const updates = await execFunc(async () => \{
			      const updates = [] as number[]
			      await new Promise((rs: any) => \{
			        using(el, \{
			          onComplete: rs,
			          fn() \{
			            const delta = createStore(0)
			            const gotHeight = createEvent<number>()
			            forward(\{
			              from: gotHeight,
			              to: delta,
			            \})
			            delta.watch(x => \{
			              updates.push(x)
			            \})
			            h('div', \{
			              text: '~/ - /~',
			              fn() \{
			                node(() => \{
			                  gotHeight(10)
			                \})
			              \},
			            \})
			          \},
			        \})
			      \})
			      return updates
			    \})
			    expect(updates).toMatchInlineSnapshot(\`
			      Array [
			        0,
			        10,
			      ]
			    \`)
			  \})
			\})
			describe('event from root, sample and nested store', () => \{
			  it('works when nested store is used', async () => \{
			    const \{itemUpdates\} = await execFunc(async () => \{
			      const itemUpdates = [] as string[]
			      const htmlSnapshots = [] as string[]
			      const selectItem = createEvent<string>()
			
			      const currentFile = createStore('foo').on(selectItem, (_, file) => file)
			
			      const openFile = createEvent<any>()
			
			      const files = createStore([\{id: 'foo'\}, \{id: 'bar'\}, \{id: 'baz'\}])
			
			      selectItem.watch(e => \{
			        itemUpdates.push(e)
			      \})
			      await new Promise((rs: any) => \{
			        using(el, \{
			          fn() \{
			            h('ul', () => \{
			              list(\{
			                source: files,
			                key: 'id',
			                fields: ['id'],
			                fn(\{fields: [id]\}) \{
			                  h('li', () => \{
			                    spec(\{text: id\})
			                    sample(\{
			                      source: id,
			                      clock: openFile,
			                      target: selectItem,
			                    \})
			                    const selected = combine(
			                      id,
			                      currentFile,
			                      (file, selectedFile) => file === selectedFile,
			                    )
			                    h('button', \{
			                      handler: \{click: openFile\},
			                      attr: \{disabled: selected, id\},
			                      text: 'open',
			                    \})
			                    h('span', \{
			                      visible: selected,
			                      text: 'selected',
			                    \})
			                  \})
			                \},
			              \})
			            \})
			          \},
			          onComplete: rs,
			        \})
			      \})
			
			      await act(async () => \{
			        el.querySelector<HTMLButtonElement>('#baz')!.click()
			      \})
			      htmlSnapshots.push(el.innerHTML)
			      await act(async () => \{
			        el.querySelector<HTMLButtonElement>('#baz')!.click()
			      \})
			      htmlSnapshots.push(el.innerHTML)
			
			      return \{itemUpdates, htmlSnapshots\}
			    \})
			    expect(itemUpdates).toMatchInlineSnapshot(\`
			      Array [
			        "foo",
			        "baz",
			        "bar",
			      ]
			    \`)
			  \})
			  it('works when nested store is not used', async () => \{
			    const \{itemUpdates, htmlSnapshots\} = await execFunc(async () => \{
			      const itemUpdates = [] as string[]
			      const htmlSnapshots = [] as string[]
			      const selectItem = createEvent<string>()
			
			      const currentFile = createStore('foo').on(selectItem, (_, file) => file)
			
			      const openFile = createEvent<any>()
			
			      const files = createStore([\{id: 'foo'\}, \{id: 'bar'\}, \{id: 'baz'\}])
			
			      selectItem.watch(e => \{
			        itemUpdates.push(e)
			      \})
			      await new Promise((rs: any) => \{
			        using(el, \{
			          fn() \{
			            h('ul', () => \{
			              list(\{
			                source: files,
			                key: 'id',
			                fields: ['id'],
			                fn(\{fields: [id]\}) \{
			                  h('li', \{
			                    fn() \{
			                      spec(\{text: id\})
			                      sample(\{
			                        source: id,
			                        clock: openFile,
			                        target: selectItem,
			                      \})
			
			                      const selected = combine(
			                        id,
			                        currentFile,
			                        (file, selectedFile) => file === selectedFile,
			                      )
			                      h('button', \{
			                        handler: \{click: openFile\},
			                        attr: \{disabled: selected\},
			                        text: 'open',
			                      \})
			                      h('span', \{
			                        visible: selected,
			                        text: [id, ' selected'],
			                      \})
			                    \},
			                  \})
			                \},
			              \})
			            \})
			          \},
			          onComplete: rs,
			        \})
			      \})
			      const [, , baz] = [...el.querySelectorAll('button')]
			      await act(async () => \{
			        baz.click()
			      \})
			      htmlSnapshots.push(el.innerHTML)
			      await act(async () => \{
			        baz.click()
			      \})
			      htmlSnapshots.push(el.innerHTML)
			
			      return \{itemUpdates, htmlSnapshots\}
			    \})
			    expect(itemUpdates).toMatchInlineSnapshot(\`
			      Array [
			        "foo",
			        "baz",
			        "bar",
			      ]
			    \`)
			    /**
			     *  TODO improve meaningless html code
			     */
			    expect(prettyHtml(htmlSnapshots[0])).toMatchInlineSnapshot(\`
			      "
			      <ul>
			        <li>
			          foo<button disabled='true'>open</button
			          ><span>foo selected</span>
			        </li>
			        <li>
			          bar<button disabled='true'>open</button
			          ><span>bar selected</span>
			        </li>
			        <li>
			          baz<button disabled='true'>open</button
			          ><span>baz selected</span>
			        </li>
			      </ul>
			      "
			    \`)
			  \})
			\})
			describe('getState support', () => \{
			  test('store from same level', async () => \{
			    expect(
			      await execFunc(async () => \{
			        const results = [] as string[]
			        const users = createStore([
			          \{id: 1, name: 'alice'\},
			          \{id: 2, name: 'bob'\},
			          \{id: 3, name: 'carol'\},
			        ])
			        using(el, () => \{
			          h('ul', () => \{
			            list(\{
			              source: users,
			              key: 'id',
			              fn(\{store\}) \{
			                h('li', () => \{
			                  const name = remap(store, 'name')
			                  spec(\{text: name\})
			                  node(() => \{
			                    results.push(name.getState())
			                  \})
			                \})
			              \},
			            \})
			          \})
			        \})
			        await act()
			        return results
			      \}),
			    ).toMatchInlineSnapshot(\`
			      Array [
			        "alice",
			        "bob",
			        "carol",
			      ]
			    \`)
			  \})
			  test('store from parent level', async () => \{
			    expect(
			      await execFunc(async () => \{
			        const results = [] as string[]
			        const users = createStore([
			          \{id: 1, name: 'alice'\},
			          \{id: 2, name: 'bob'\},
			          \{id: 3, name: 'carol'\},
			        ])
			        using(el, () => \{
			          h('ul', () => \{
			            list(\{
			              source: users,
			              key: 'id',
			              fn(\{store\}) \{
			                const name = remap(store, 'name')
			                h('li', () => \{
			                  node(() => \{
			                    results.push(name.getState())
			                  \})
			                \})
			              \},
			            \})
			          \})
			        \})
			        await act()
			        return results
			      \}),
			    ).toMatchInlineSnapshot(\`
			      Array [
			        "alice",
			        "bob",
			        "carol",
			      ]
			    \`)
			  \})
			\})
			
			describe('imperative calls support', () => \{
			  test('event from same level', async () => \{
			    expect(
			      await execFunc(async () => \{
			        const results = [] as string[]
			        const users = createStore([
			          \{id: 1, name: 'alice'\},
			          \{id: 2, name: 'bob'\},
			          \{id: 3, name: 'carol'\},
			        ])
			        using(el, () => \{
			          h('ul', () => \{
			            list(\{
			              source: users,
			              key: 'id',
			              fn(\{store\}) \{
			                h('li', () => \{
			                  const name = remap(store, 'name')
			                  const trigger = createEvent()
			                  trigger.watch(() => \{
			                    results.push(name.getState())
			                  \})
			                  node(() => \{
			                    trigger()
			                  \})
			                \})
			              \},
			            \})
			          \})
			        \})
			        await act()
			        return results
			      \}),
			    ).toMatchInlineSnapshot(\`
			      Array [
			        "alice",
			        "bob",
			        "carol",
			      ]
			    \`)
			  \})
			  test('event from parent level', async () => \{
			    expect(
			      await execFunc(async () => \{
			        const results = [] as string[]
			        const users = createStore([
			          \{id: 1, name: 'alice'\},
			          \{id: 2, name: 'bob'\},
			          \{id: 3, name: 'carol'\},
			        ])
			        using(el, () => \{
			          h('ul', () => \{
			            list(\{
			              source: users,
			              key: 'id',
			              fn(\{store\}) \{
			                const name = remap(store, 'name')
			                const trigger = createEvent()
			                trigger.watch(() => \{
			                  results.push(name.getState())
			                \})
			                h('li', () => \{
			                  node(() => \{
			                    trigger()
			                  \})
			                \})
			              \},
			            \})
			          \})
			        \})
			        await act()
			        return results
			      \}),
			    ).toMatchInlineSnapshot(\`
			      Array [
			        "alice",
			        "bob",
			        "carol",
			      ]
			    \`)
			  \})
			  test('event from parent level watched on single child', async () => \{
			    expect(
			      await execFunc(async () => \{
			        const results = [] as string[]
			        const users = createStore([
			          \{id: 1, name: 'alice'\},
			          \{id: 2, name: 'bob'\},
			          \{id: 3, name: 'carol'\},
			        ])
			        using(el, () => \{
			          h('ul', () => \{
			            list(\{
			              source: users,
			              key: 'id',
			              fn(\{store\}) \{
			                const name = remap(store, 'name')
			                const trigger = createEvent()
			                h('li', () => \{
			                  trigger.watch(() => \{
			                    results.push(name.getState())
			                  \})
			                  node(() => \{
			                    trigger()
			                  \})
			                \})
			              \},
			            \})
			          \})
			        \})
			        await act()
			        return results
			      \}),
			    ).toMatchInlineSnapshot(\`
			      Array [
			        "alice",
			        "bob",
			        "carol",
			      ]
			    \`)
			  \})
			  test('event from root level', async () => \{
			    expect(
			      await execFunc(async () => \{
			        const results = [] as string[]
			        const users = createStore([
			          \{id: 1, name: 'alice'\},
			          \{id: 2, name: 'bob'\},
			          \{id: 3, name: 'carol'\},
			        ])
			        const trigger = createEvent()
			        using(el, () => \{
			          h('ul', () => \{
			            list(\{
			              source: users,
			              key: 'id',
			              fn(\{store\}) \{
			                const name = remap(store, 'name')
			                trigger.watch(() => \{
			                  results.push(name.getState())
			                \})
			                h('li', () => \{
			                  node(() => \{
			                    trigger()
			                  \})
			                \})
			              \},
			            \})
			          \})
			        \})
			        await act()
			        trigger()
			        return results
			      \}),
			    ).toMatchInlineSnapshot(\`
			      Array [
			        null,
			        null,
			        null,
			        null,
			      ]
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\reactiveTreeLaws.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(20)
    });
    it('effector_effector\\src\\forest\\__tests__\\rec.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{createStore, createEvent, combine, sample\} from 'effector'
			import \{using, h, spec, text, list, rec, remap\} from 'forest'
			import \{Leaf\} from '../index.h'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			test('rec visible support', async () => \{
			  const [s1, s2, s3] = await exec(async () => \{
			    const toggleNestedRows = createEvent()
			    const nestedRowsVisible = createStore(true).on(
			      toggleNestedRows,
			      visible => !visible,
			    )
			    type Item = \{
			      value: string
			      child: Item[]
			    \}
			    type FlatItem = \{
			      value: string
			      child: string[]
			    \}
			    const items = createStore([
			      \{
			        value: 'a',
			        child: [
			          \{
			            value: 'a_a',
			            child: [],
			          \},
			          \{
			            value: 'a_b',
			            child: [
			              \{
			                value: 'a_b_a',
			                child: [],
			              \},
			            ],
			          \},
			        ],
			      \},
			      \{
			        value: 'b',
			        child: [
			          \{
			            value: 'b_a',
			            child: [],
			          \},
			          \{
			            value: 'b_b',
			            child: [],
			          \},
			        ],
			      \},
			    ])
			    const flatItems = items.map(list => \{
			      const result = [] as FlatItem[]
			      list.forEach(processValue)
			      function processValue(\{value, child\}: Item) \{
			        result.push(\{value, child: child.map((\{value\}) => value)\})
			        child.forEach(processValue)
			      \}
			      return result
			    \})
			    const topLevelFlatItems = flatItems.map(list =>
			      list
			        .filter((\{value\}) => value.length === 1)
			        .map(item => (\{item, level: 0\})),
			    )
			    let rootLeaf: Leaf
			    //@ts-expect-error
			    using(el, \{
			      fn() \{
			        const Row = rec<\{item: FlatItem; level: number\}>((\{store\}) => \{
			          const [level, item] = remap(store, ['level', 'item'] as const)
			          const visible = combine(
			            level,
			            nestedRowsVisible,
			            (level, visible) => \{
			              if (level === 0) return true
			              return visible
			            \},
			          )
			          const childs = combine(
			            flatItems,
			            item,
			            level,
			            (list, \{child\}, level) =>
			              list
			                .filter((\{value\}) => child.includes(value))
			                .map(item => (\{item, level: level + 1\})),
			          )
			          h('div', \{
			            // style: \{marginLeft: '1em'\},
			            visible,
			            fn() \{
			              spec(\{text: [remap(item, 'value'), ' ', level]\})
			
			              list(childs, (\{store\}) => \{
			                Row(\{store\})
			              \})
			            \},
			          \})
			        \})
			        list(topLevelFlatItems, (\{store\}) => \{
			          Row(\{store\})
			        \})
			      \},
			      onRoot(\{leaf\}: \{leaf: Leaf\}) \{
			        rootLeaf = leaf
			      \},
			    \})
			    await act()
			    // printLeaf(rootLeaf)
			    await act(() => \{
			      toggleNestedRows()
			    \})
			    await act(() => \{
			      toggleNestedRows()
			    \})
			    // printLeaf(rootLeaf)
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div>
			      a 0
			      <div>a_a 1</div>
			      <div>
			        a_b 1
			        <div>a_b_a 2</div>
			      </div>
			    </div>
			    <div>
			      b 0
			      <div>b_a 1</div>
			      <div>b_b 1</div>
			    </div>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div>a 0</div>
			    <div>b 0</div>
			    "
			  \`)
			  expect(s3).toBe(s1)
			\})
			
			test('rec style update support', async () => \{
			  const [s1, s2, s3] = await exec(async () => \{
			    const toggleNestedRows = createEvent()
			    const nestedRowsVisible = createStore(true).on(
			      toggleNestedRows,
			      visible => !visible,
			    )
			    type Item = \{
			      value: string
			      child: Item[]
			    \}
			    type FlatItem = \{
			      value: string
			      child: string[]
			    \}
			    const items = createStore([
			      \{
			        value: 'a',
			        child: [
			          \{
			            value: 'a_a',
			            child: [],
			          \},
			          \{
			            value: 'a_b',
			            child: [
			              \{
			                value: 'a_b_a',
			                child: [],
			              \},
			            ],
			          \},
			        ],
			      \},
			      \{
			        value: 'b',
			        child: [
			          \{
			            value: 'b_a',
			            child: [],
			          \},
			          \{
			            value: 'b_b',
			            child: [],
			          \},
			        ],
			      \},
			    ])
			    const flatItems = items.map(list => \{
			      const result = [] as FlatItem[]
			      list.forEach(processValue)
			      function processValue(\{value, child\}: Item) \{
			        result.push(\{value, child: child.map((\{value\}) => value)\})
			        child.forEach(processValue)
			      \}
			      return result
			    \})
			    const topLevelFlatItems = flatItems.map(list =>
			      list
			        .filter((\{value\}) => value.length === 1)
			        .map(item => (\{item, level: 0\})),
			    )
			    let rootLeaf: Leaf
			    //@ts-expect-error
			    using(el, \{
			      fn() \{
			        const Row = rec<\{item: FlatItem; level: number\}>((\{store\}) => \{
			          const [level, item] = remap(store, ['level', 'item'] as const)
			          const visible = combine(
			            level,
			            nestedRowsVisible,
			            (level, visible): string => \{
			              if (level === 0) return 'yes'
			              return visible ? 'yes' : 'no'
			            \},
			          )
			          h('div', \{
			            style: \{marginLeft: level.map(value => \`\$\{value\}em\`)\},
			            data: \{visible\},
			            fn() \{
			              const value = remap(item, 'value')
			              const status = visible.map(
			                vis => (vis === 'yes' ? 'visible' : 'hidden') as string,
			              )
			              text\`\$\{value\} \$\{level\} \$\{status\}\`
			            \},
			          \})
			          const childs = combine(
			            flatItems,
			            store,
			            (list, \{item: \{child\}, level\}) =>
			              list
			                .filter((\{value\}) => child.includes(value))
			                .map(item => (\{item, level: level + 1\})),
			          )
			          list(childs, (\{store\}) => \{
			            Row(\{store\})
			          \})
			        \})
			        list(topLevelFlatItems, (\{store\}) => \{
			          Row(\{store\})
			        \})
			      \},
			      onRoot(\{leaf\}: \{leaf: Leaf\}) \{
			        rootLeaf = leaf
			      \},
			    \})
			    await act()
			    // printLeaf(rootLeaf)
			    await act(() => \{
			      toggleNestedRows()
			    \})
			    await act(() => \{
			      toggleNestedRows()
			    \})
			    // printLeaf(rootLeaf)
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			"
			<div data-visible='yes' style='margin-left: 0em'>
			  a 0 visible
			</div>
			<div data-visible='yes' style='margin-left: 1em'>
			  a_a 1 visible
			</div>
			<div data-visible='yes' style='margin-left: 1em'>
			  a_b 1 visible
			</div>
			<div data-visible='yes' style='margin-left: 2em'>
			  a_b_a 2 visible
			</div>
			<div data-visible='yes' style='margin-left: 0em'>
			  b 0 visible
			</div>
			<div data-visible='yes' style='margin-left: 1em'>
			  b_a 1 visible
			</div>
			<div data-visible='yes' style='margin-left: 1em'>
			  b_b 1 visible
			</div>
			"
			\`)
			  expect(s2).toMatchInlineSnapshot(\`
			"
			<div data-visible='yes' style='margin-left: 0em'>
			  a 0 visible
			</div>
			<div data-visible='no' style='margin-left: 1em'>
			  a_a 1 hidden
			</div>
			<div data-visible='no' style='margin-left: 1em'>
			  a_b 1 hidden
			</div>
			<div data-visible='no' style='margin-left: 2em'>
			  a_b_a 2 hidden
			</div>
			<div data-visible='yes' style='margin-left: 0em'>
			  b 0 visible
			</div>
			<div data-visible='no' style='margin-left: 1em'>
			  b_a 1 hidden
			</div>
			<div data-visible='no' style='margin-left: 1em'>
			  b_b 1 hidden
			</div>
			"
			\`)
			  expect(s3).toBe(s1)
			\})
			
			function printLeaf(leaf: Leaf) \{
			  const rows = [] as string[]
			  parse(leaf, \{level: 0\})
			  function parse(leaf: Leaf, \{level\}: \{level: number\}) \{
			    const \{data\} = leaf
			    const tab = ' '.repeat(level * 2)
			    rows.push(\`\$\{tab\}id: \$\{leaf.fullID\}\`)
			    rows.push(\`\$\{tab\}type: \$\{data.type\}\`)
			    switch (data.type) \{
			      case 'using': \{
			        break
			      \}
			      case 'element': \{
			        const \{value, index\} = data.block
			        rows.push(\`\$\{tab\}index: \$\{index\}\`)
			        rows.push(\`\$\{tab\}text: \$\{value.textContent\}\`)
			        break
			      \}
			      case 'list': \{
			        break
			      \}
			      case 'list item': \{
			        break
			      \}
			      case 'route': \{
			        break
			      \}
			      case 'rec item': \{
			        break
			      \}
			      case 'rec': \{
			        break
			      \}
			    \}
			    let hasChilds = false
			    iterateChildLeafs(leaf, child => \{
			      parse(child, \{level: level + 1\})
			      rows.push(\`\$\{tab\}  --\`)
			      hasChilds = true
			    \})
			    if (hasChilds) \{
			      rows.pop()
			    \}
			  \}
			  console.log(rows.join(\`\\n\`))
			  function iterateChildLeafs(leaf: Leaf, cb: (child: Leaf) => void) \{
			    for (const key in leaf.root.childSpawns[leaf.fullID]) \{
			      const childs = leaf.root.childSpawns[leaf.fullID][key]
			      for (let i = 0; i < childs.length; i++) \{
			        cb(childs[i])
			      \}
			    \}
			  \}
			\}
			
			test('top level rec suppot', async () => \{
			  //prettier-ignore
			  type Item = \{id: number; title: string; child: Item[]\};
			  const [s1] = await exec(async () => \{
			    const Article = rec<Item>((\{store\}) => \{
			      const [title, child] = remap(store, ['title', 'child'] as const)
			      h('div', () => \{
			        h('header', \{text: title\})
			        list(\{
			          source: child,
			          key: 'id',
			          fn(\{store\}) \{
			            Article(\{store\})
			          \},
			        \})
			      \})
			    \})
			    const item = createStore<Item>(\{
			      id: 0,
			      title: 'root',
			      child: [
			        \{
			          id: 1,
			          title: 'a',
			          child: [],
			        \},
			        \{
			          id: 2,
			          title: 'b',
			          child: [
			            \{
			              id: 3,
			              title: 'c',
			              child: [],
			            \},
			          ],
			        \},
			      ],
			    \})
			    using(el, () => \{
			      h('section', () => \{
			        Article(\{store: item\})
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <section>
			      <div>
			        <header>root</header>
			        <div><header>a</header></div>
			        <div>
			          <header>b</header>
			          <div><header>c</header></div>
			        </div>
			      </div>
			    </section>
			    "
			  \`)
			\})
			
			describe('recursion', () => \{
			  /**
			   * TODO wrong behavior!
			   * infinite loop during #c click
			   */
			  test.skip('store update #1', async () => \{
			    type ValueType = \{id: string; child: ValueType[]\}
			    const [initial, cClicked, bClicked, dClicked, aClicked] = await exec(
			      async () => \{
			        const Value = rec<ValueType & \{parentValues: number[]\}>((\{store\}) => \{
			          const [id, child, inputValues] = remap(store, [
			            'id',
			            'child',
			            'parentValues',
			          ])
			          const click = createEvent<any>()
			          const count = createStore(0).on(click, x => x + 1)
			          const parentValues = combine(inputValues, count, (items, n) => [
			            ...items,
			            n,
			          ])
			          h('div', () => \{
			            h('button', \{
			              attr: \{id\},
			              handler: \{click\},
			              text: ['Click ', id],
			            \})
			            h('b', \{text: count\})
			            list(inputValues, (\{store\}) => \{
			              h('i', \{text: store\})
			            \})
			            list(child, (\{store\}) => \{
			              Value(\{
			                store: combine(
			                  store,
			                  parentValues,
			                  (\{id, child\}, parentValues) => (\{id, child, parentValues\}),
			                ),
			              \})
			            \})
			          \})
			        \})
			        const root = createStore<ValueType & \{parentValues: number[]\}>(\{
			          id: 'a',
			          child: [
			            \{id: 'b', child: [\{id: 'c', child: []\}]\},
			            \{id: 'd', child: [\{id: 'e', child: []\}]\},
			            \{id: 'f', child: []\},
			          ],
			          parentValues: [],
			        \})
			        using(el, \{
			          fn() \{
			            Value(\{store: root\})
			          \},
			        \})
			        await act()
			        await act(async () => \{
			          el.querySelector<HTMLButtonElement>('#c')!.click()
			        \})
			        await act(async () => \{
			          el.querySelector<HTMLButtonElement>('#b')!.click()
			        \})
			        await act(async () => \{
			          el.querySelector<HTMLButtonElement>('#d')!.click()
			        \})
			        await act(async () => \{
			          el.querySelector<HTMLButtonElement>('#a')!.click()
			        \})
			      \},
			    )
			
			    expect(initial).toMatchInlineSnapshot()
			    expect(cClicked).toMatchInlineSnapshot()
			    expect(bClicked).toMatchInlineSnapshot()
			    expect(dClicked).toMatchInlineSnapshot()
			     expect(aClicked).toMatchInlineSnapshot()
			  \})
			  describe('store update #2', () => \{
			    //prettier-ignore
			    type ValueType = \{id: string; child: ValueType[]\};
			    test('with on', async () => \{
			      const [initial, cClicked, bClicked, dClicked, aClicked] = await exec(
			        async () => \{
			          const Value = rec<ValueType>((\{store\}) => \{
			            const [id, child] = remap(store, ['id', 'child'])
			            const click = createEvent<any>()
			            const count = createStore(0).on(click, x => x + 1)
			            h('div', () => \{
			              h('button', \{
			                attr: \{id\},
			                handler: \{click\},
			                text: ['Click ', id],
			              \})
			              h('b', \{text: count\})
			              list(child, (\{store\}) => \{
			                Value(\{store\})
			              \})
			            \})
			          \})
			          const root = createStore<ValueType>(\{
			            id: 'a',
			            child: [
			              \{id: 'b', child: [\{id: 'c', child: []\}]\},
			              \{id: 'd', child: [\{id: 'e', child: []\}]\},
			              \{id: 'f', child: []\},
			            ],
			          \})
			          using(el, \{
			            fn() \{
			              Value(\{store: root\})
			            \},
			          \})
			          await act()
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#c')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#b')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#d')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#a')!.click()
			          \})
			        \},
			      )
			
			      expect(initial).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>0</b>
			      <div><button id='c'>Click c</button><b>0</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(cClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>0</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(bClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(dClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>1</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(aClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>1</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>1</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			    \})
			    test('with sample single target', async () => \{
			      const [initial, cClicked, bClicked, dClicked, aClicked] = await exec(
			        async () => \{
			          const Value = rec<ValueType>((\{store\}) => \{
			            const [id, child] = remap(store, ['id', 'child'])
			            const click = createEvent<any>()
			            const count = createStore(0)
			            sample(\{
			              clock: click,
			              source: count,
			              target: count,
			              fn: x => x + 1,
			            \})
			            h('div', () => \{
			              h('button', \{
			                attr: \{id\},
			                handler: \{click\},
			                text: ['Click ', id],
			              \})
			              h('b', \{text: count\})
			              list(child, (\{store\}) => \{
			                Value(\{store\})
			              \})
			            \})
			          \})
			          const root = createStore<ValueType>(\{
			            id: 'a',
			            child: [
			              \{id: 'b', child: [\{id: 'c', child: []\}]\},
			              \{id: 'd', child: [\{id: 'e', child: []\}]\},
			              \{id: 'f', child: []\},
			            ],
			          \})
			          using(el, \{
			            fn() \{
			              Value(\{store: root\})
			            \},
			          \})
			          await act()
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#c')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#b')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#d')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#a')!.click()
			          \})
			        \},
			      )
			
			      expect(initial).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>0</b>
			      <div><button id='c'>Click c</button><b>0</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(cClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>0</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(bClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(dClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>1</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(aClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>1</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>1</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			    \})
			    test('with sample array target', async () => \{
			      const [initial, cClicked, bClicked, dClicked, aClicked] = await exec(
			        async () => \{
			          const Value = rec<ValueType>((\{store\}) => \{
			            const [id, child] = remap(store, ['id', 'child'])
			            const click = createEvent<any>()
			            const count = createStore(0)
			            sample(\{
			              clock: click,
			              source: count,
			              target: [count],
			              fn: x => x + 1,
			            \})
			            h('div', () => \{
			              h('button', \{
			                attr: \{id\},
			                handler: \{click\},
			                text: ['Click ', id],
			              \})
			              h('b', \{text: count\})
			              list(child, (\{store\}) => \{
			                Value(\{store\})
			              \})
			            \})
			          \})
			          const root = createStore<ValueType>(\{
			            id: 'a',
			            child: [
			              \{id: 'b', child: [\{id: 'c', child: []\}]\},
			              \{id: 'd', child: [\{id: 'e', child: []\}]\},
			              \{id: 'f', child: []\},
			            ],
			          \})
			          using(el, \{
			            fn() \{
			              Value(\{store: root\})
			            \},
			          \})
			          await act()
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#c')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#b')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#d')!.click()
			          \})
			          await act(async () => \{
			            el.querySelector<HTMLButtonElement>('#a')!.click()
			          \})
			        \},
			      )
			
			      expect(initial).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>0</b>
			      <div><button id='c'>Click c</button><b>0</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(cClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>0</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(bClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>0</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(dClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>0</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>1</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			      expect(aClicked).toMatchInlineSnapshot(\`
			  "
			  <div>
			    <button id='a'>Click a</button><b>1</b>
			    <div>
			      <button id='b'>Click b</button><b>1</b>
			      <div><button id='c'>Click c</button><b>1</b></div>
			    </div>
			    <div>
			      <button id='d'>Click d</button><b>1</b>
			      <div><button id='e'>Click e</button><b>0</b></div>
			    </div>
			    <div><button id='f'>Click f</button><b>0</b></div>
			  </div>
			  "
			  \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\rec.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\forest\\__tests__\\ssr\\block.test.ts', () => {
        const sourceCode = `
			import \{argumentHistory\} from 'effector/fixtures'
			import \{createStore, createEvent, createEffect, forward, fork\} from 'effector'
			import \{h, using, list, spec, rec, variant, remap, block\} from 'forest'
			import \{renderStatic\} from 'forest/server'
			import prettyHtml from 'effector/fixtures/prettyHtml'
			//@ts-expect-error
			import \{provideGlobals\} from 'effector/fixtures/dom'
			
			test('block nesting', async () => \{
			  const scopeName = createStore('--')
			  const click = createEvent<MouseEvent>()
			  const fetchContent = createEffect(async () => \{
			    return \{title: 'dashboard'\}
			  \})
			  const link = createStore('#').on(
			    fetchContent.doneData,
			    (_, \{title\}) => \`/\$\{title\}\`,
			  )
			  const linkText = createStore('-').on(
			    fetchContent.doneData,
			    (_, \{title\}) => title,
			  )
			  forward(\{
			    from: click,
			    to: fetchContent,
			  \})
			
			  const client = provideGlobals()
			
			  const SameLink = block(\{
			    fn() \{
			      h('a', \{
			        attr: \{href: link\},
			        text: ['Open ', linkText],
			      \})
			    \},
			  \})
			  const Nav = block(\{
			    fn() \{
			      h('svg', () => \{
			        SameLink()
			      \})
			    \},
			  \})
			
			  const App = block(\{
			    fn() \{
			      SameLink()
			      h('nav', \{
			        fn: Nav,
			      \})
			      h('button', \{
			        attr: \{id: 'click'\},
			        handler: \{click\},
			        text: scopeName,
			      \})
			    \},
			  \})
			
			  const scopeA = fork(\{
			    values: [
			      [link, '/'],
			      [scopeName, 'A'],
			    ],
			    handlers: [[fetchContent, async () => (\{title: 'contacts'\})]],
			  \})
			
			  using(client.el, \{
			    scope: scopeA,
			    fn: App,
			    env: \{
			      document: client.document,
			    \},
			  \})
			
			  await new Promise(rs => setTimeout(rs, 200))
			
			  client.el.querySelector('#click')?.click()
			
			  await new Promise(rs => setTimeout(rs, 200))
			
			  expect(prettyHtml(client.el.innerHTML)).toMatchInlineSnapshot(\`
			    "
			    <a href='/contacts'>Open contacts</a>
			    <nav>
			      <svg xmlns='http://www.w3.org/2000/svg'>
			        <a href='/contacts'>Open contacts</a>
			      </svg>
			    </nav>
			    <button id='click'>A</button>
			    "
			  \`)
			\})
			
			test('block with list', async () => \{
			  type NestedList = \{
			    id: number
			    title: string
			    child: NestedList[]
			  \}
			  const rootItem = createStore<NestedList>(\{
			    id: 0,
			    title: 'root',
			    child: [
			      \{
			        id: 1,
			        title: 'foo',
			        child: [],
			      \},
			      \{
			        id: 2,
			        title: 'bar',
			        child: [],
			      \},
			    ],
			  \})
			
			  const App = block(\{
			    fn() \{
			      const Item = rec<NestedList>((\{store\}) => \{
			        const [title, child] = remap(store, ['title', 'child'] as const)
			        const typedChild = child.map(list =>
			          list.length === 0
			            ? (\{type: 'empty'\} as const)
			            : (\{type: 'list', list\} as const),
			        )
			        h('div', () => \{
			          spec(\{text: title\})
			          variant(\{
			            source: typedChild,
			            key: 'type',
			            cases: \{
			              empty() \{
			                h('span', \{text: '...'\})
			              \},
			              list(\{store\}) \{
			                const items = remap(store, 'list')
			                h('ul', () => \{
			                  list(\{
			                    source: items,
			                    key: 'id',
			                    fn(\{store\}) \{
			                      Item(\{store\})
			                    \},
			                  \})
			                \})
			              \},
			            \},
			          \})
			        \})
			      \})
			      h('h1', \{text: 'List'\})
			      Item(\{store: rootItem\})
			    \},
			  \})
			
			  const scope = fork()
			
			  const result = await renderStatic(\{
			    scope,
			    fn: App,
			  \})
			
			  expect(prettyHtml(result)).toMatchInlineSnapshot(\`
			    "
			    <h1>List</h1>
			    <div>
			      root
			      <ul>
			        <div>foo<span>...</span></div>
			        <div>bar<span>...</span></div>
			      </ul>
			    </div>
			    "
			  \`)
			\})
			
			test('block with rec and list', async () => \{
			  //prettier-ignore
			  type User = \{id: number; login: string\};
			
			  const fn = jest.fn()
			
			  const users = createStore<User[]>([\{id: 0, login: 'alice'\}])
			
			  const App = block(\{
			    fn() \{
			      list(\{
			        source: users,
			        key: 'id',
			        fn(\{store\}) \{
			          const login = store.map(val => \{
			            fn(val)
			            return val ? val.login : ''
			          \})
			          h('div', \{text: login\})
			        \},
			      \})
			    \},
			  \})
			
			  const scope = fork(\{
			    values: [
			      [
			        users,
			        [
			          \{id: 0, login: 'alice'\},
			          \{id: 1, login: 'bob'\},
			        ],
			      ],
			    ],
			  \})
			
			  const renderedRaw = await renderStatic(\{
			    scope,
			    fn: App,
			  \})
			  expect(prettyHtml(renderedRaw)).toMatchInlineSnapshot(\`
			    "
			    <div>alice</div>
			    <div>bob</div>
			    "
			  \`)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 0,
			        "login": "alice",
			      \},
			      Object \{
			        "id": 0,
			        "login": "alice",
			      \},
			      Object \{
			        "id": 1,
			        "login": "bob",
			      \},
			      Object \{
			        "id": 1,
			        "login": "bob",
			      \},
			    ]
			  \`)
			\})
			
			test('block order', async () => \{
			  const Meta = block(\{
			    fn() \{
			      h('meta', \{
			        attr: \{
			          charset: 'utf-8',
			        \},
			      \})
			    \},
			  \})
			  const Title = block(\{
			    fn() \{
			      h('title', \{
			        text: 'Title',
			      \})
			    \},
			  \})
			  const Head = block(\{
			    fn() \{
			      h('head', () => \{
			        Meta()
			        Title()
			      \})
			    \},
			  \})
			
			  const result = await renderStatic(\{
			    scope: fork(),
			    fn: Head,
			  \})
			  expect(prettyHtml(result)).toMatchInlineSnapshot(\`
			    "
			    <head>
			      <meta charset='utf-8' />
			      <title>Title</title>
			    </head>
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\ssr\\block.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('effector_effector\\src\\forest\\__tests__\\ssr\\index.test.ts', () => {
        const sourceCode = `
			import \{
			  createEvent,
			  createStore,
			  createEffect,
			  createDomain,
			  forward,
			  fork,
			  allSettled,
			  serialize,
			  hydrate,
			\} from 'effector'
			import \{h, using, block, text, rec\} from 'forest'
			import \{renderStatic\} from 'forest/server'
			import prettyHtml from 'effector/fixtures/prettyHtml'
			//@ts-expect-error
			import \{provideGlobals\} from 'effector/fixtures/dom'
			
			test('fork support', async () => \{
			  const fetchContent = createEffect(async () => \{
			    return \{title: 'dashboard'\}
			  \})
			  const title = createStore('-').on(
			    fetchContent.doneData,
			    (_, \{title\}) => title,
			  )
			
			  const scope = fork(\{
			    values: [[title, 'loading...']],
			    handlers: [[fetchContent, async () => (\{title: 'contacts'\})]],
			  \})
			
			  await allSettled(fetchContent, \{scope\})
			
			  const htmlResult = await renderStatic(\{
			    scope,
			    fn() \{
			      h('h1', \{text: title\})
			    \},
			  \})
			  expect(prettyHtml(htmlResult)).toMatchInlineSnapshot(\`
			    "
			    <h1>contacts</h1>
			    "
			  \`)
			\})
			
			test('hydration support (without html hydration)', async () => \{
			  const app = createDomain()
			  const fetchContent = app.createEffect(async () => \{
			    return \{title: 'dashboard'\}
			  \})
			  const title = app
			    .createStore('-')
			    .on(fetchContent.doneData, (_, \{title\}) => title)
			
			  const scope = fork(app, \{
			    values: [[title, 'loading...']],
			    handlers: [[fetchContent, async () => (\{title: 'contacts'\})]],
			  \})
			
			  await allSettled(fetchContent, \{scope\})
			
			  hydrate(app, \{
			    values: serialize(scope),
			  \})
			
			  const htmlResult = await renderStatic(\{
			    scope,
			    fn() \{
			      h('h1', \{text: title\})
			    \},
			  \})
			
			  expect(prettyHtml(htmlResult)).toMatchInlineSnapshot(\`
			    "
			    <h1>contacts</h1>
			    "
			  \`)
			\})
			
			test('hydration support (with html hydration)', async () => \{
			  const app = createDomain()
			  const fetchContent = app.createEffect(\{
			    async handler() \{
			      return \{title: 'dashboard'\}
			    \},
			  \})
			  const title = app
			    .createStore('-')
			    .on(fetchContent.doneData, (_, \{title\}) => title)
			
			  function App() \{
			    h('h1', \{text: title\})
			  \}
			
			  const scope = fork(app, \{
			    values: new Map([[title, 'loading...']]),
			    handlers: new Map([[fetchContent, async () => (\{title: 'contacts'\})]]),
			  \})
			
			  await allSettled(fetchContent, \{
			    scope,
			  \})
			
			  const htmlSource = await renderStatic(\{
			    scope,
			    fn: App,
			  \})
			
			  hydrate(app, \{
			    values: serialize(scope),
			  \})
			
			  const client = provideGlobals()
			
			  client.el.innerHTML = htmlSource
			
			  // await new Promise(rs => \{
			  using(client.el, \{
			    // onComplete: rs,
			    hydrate: true,
			    fn: App,
			    env: \{
			      document: client.document,
			    \},
			  \})
			  // \})
			
			  await new Promise(rs => setTimeout(rs, 200))
			
			  expect(prettyHtml(client.el.innerHTML)).toMatchInlineSnapshot(\`
			    "
			    <h1>contacts</h1>
			    "
			  \`)
			
			  await fetchContent()
			
			  await new Promise(rs => setTimeout(rs, 200))
			
			  expect(prettyHtml(client.el.innerHTML)).toMatchInlineSnapshot(\`
			    "
			    <h1>dashboard</h1>
			    "
			  \`)
			\})
			
			test('hydrate', async () => \{
			  const rootItem = createStore(null)
			  const Item = rec<any>(\{
			    fn() \{
			      h('div', \{
			        text: 'root',
			      \})
			    \},
			  \})
			  const Tag = block(\{
			    fn() \{
			      h('span', \{
			        text: 'SPAN',
			      \})
			    \},
			  \})
			  const App = block(\{
			    fn() \{
			      Tag()
			      h('h1', \{text: 'List'\})
			      Item(\{store: rootItem\})
			    \},
			  \})
			
			  const htmlSource = await renderStatic(\{
			    scope: fork(),
			    fn: App,
			  \})
			  const client = provideGlobals()
			
			  client.el.innerHTML = htmlSource
			  await new Promise(rs => \{
			    //@ts-expect-error
			    using(client.el, \{
			      scope: fork(),
			      onComplete: rs,
			      fn: App,
			      env: \{
			        document: client.document,
			      \},
			      hydrate: true,
			    \})
			  \})
			  expect(prettyHtml(client.el.innerHTML)).toMatchInlineSnapshot(\`
			    "
			    <span>SPAN</span>
			    <h1>List</h1>
			    <div>root</div>
			    "
			  \`)
			\})
			
			describe('text content escaping', () => \{
			  it('escape text content in common tags', async () => \{
			    const scriptText = createStore('\{"foo": "bar"\}')
			    const result = await renderStatic(() => \{
			      h('span', () => \{
			        text\`window.__INITIAL_STATE__ = \$\{scriptText\}\`
			      \})
			    \})
			    expect(result).toMatchInlineSnapshot(
			      \`"<span>window.__INITIAL_STATE__ = \{&quot;foo&quot;: &quot;bar&quot;\}</span>"\`,
			    )
			  \})
			  it('not escape text content in script tag', async () => \{
			    const scriptText = createStore('\{"foo": "bar"\}')
			    const result = await renderStatic(() => \{
			      h('script', () => \{
			        text\`window.__INITIAL_STATE__ = \$\{scriptText\}\`
			      \})
			    \})
			    expect(result).toMatchInlineSnapshot(
			      \`"<script>window.__INITIAL_STATE__ = \{\\\\"foo\\\\": \\\\"bar\\\\"\}</script>"\`,
			    )
			  \})
			  it('still escape "</script>" in script tag', async () => \{
			    const scriptText = createStore(JSON.stringify(\{foo: \`</\\nscript>\`\}))
			    const result = await renderStatic(() => \{
			      h('script', () => \{
			        text\`window.__INITIAL_STATE__ = \$\{scriptText\}; console.log('</script>')\`
			      \})
			    \})
			    expect(result).toMatchInlineSnapshot(
			      \`"<script>window.__INITIAL_STATE__ = \{\\\\"foo\\\\":\\\\"<\\\\\\\\/script>\\\\"\}; console.log('<\\\\\\\\/script>')</script>"\`,
			    )
			  \})
			\})
			
			test('fork isolation', async () => \{
			  const scopeName = createStore('--')
			  const click = createEvent<MouseEvent>()
			  const fetchContent = createEffect(async () => \{
			    return \{title: 'dashboard'\}
			  \})
			  const title = createStore('-').on(
			    fetchContent.doneData,
			    (_, \{title\}) => title,
			  )
			
			  forward(\{
			    from: click,
			    to: fetchContent,
			  \})
			
			  const client = provideGlobals()
			
			  const App = block(\{
			    fn() \{
			      h('h1', \{text: title\})
			      h('button', \{
			        attr: \{id: 'click'\},
			        handler: \{click\},
			        text: scopeName,
			      \})
			    \},
			  \})
			
			  const scopeA = fork(\{
			    values: [
			      [title, 'loading...'],
			      [scopeName, 'A'],
			    ],
			    handlers: [[fetchContent, async () => (\{title: 'contacts'\})]],
			  \})
			
			  const scopeB = fork(\{
			    values: [
			      [title, 'loading...'],
			      [scopeName, 'B'],
			    ],
			    handlers: [[fetchContent, async () => (\{title: 'profile'\})]],
			  \})
			
			  const elA = client.document.createElement('div')
			  const elB = client.document.createElement('div')
			  client.el.appendChild(elA)
			  client.el.appendChild(elB)
			
			  //@ts-expect-error
			  using(elA, \{
			    scope: scopeA,
			    fn: App,
			    env: \{
			      document: client.document,
			    \},
			    onRoot(\{template, leaf\}: any) \{\},
			  \})
			  using(elB, \{
			    scope: scopeB,
			    fn: App,
			    env: \{
			      document: client.document,
			    \},
			  \})
			
			  await new Promise(rs => setTimeout(rs, 200))
			
			  elA.querySelector('#click').click()
			
			  await new Promise(rs => setTimeout(rs, 200))
			
			  expect(prettyHtml(elA.innerHTML)).toMatchInlineSnapshot(\`
			    "
			    <h1>contacts</h1>
			    <button id='click'>A</button>
			    "
			  \`)
			  expect(prettyHtml(elB.innerHTML)).toMatchInlineSnapshot(\`
			    "
			    <h1>loading...</h1>
			    <button id='click'>B</button>
			    "
			  \`)
			  expect(title.getState()).toBe('-')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\ssr\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('effector_effector\\src\\forest\\__tests__\\ssr\\renderStatic.test.ts', () => {
        const sourceCode = `
			import \{createStore\} from 'effector'
			import \{h, list, remap\} from 'forest'
			import \{renderStatic\} from 'forest/server'
			import prettyHtml from 'effector/fixtures/prettyHtml'
			
			it('works', async () => \{
			  const store = createStore([\{name: 'alice'\}, \{name: 'bob'\}, \{name: 'carol'\}])
			  const htmlResult = await renderStatic(\{
			    fn() \{
			      h('header', () => \{
			        h('h1', \{
			          text: 'App title',
			        \})
			      \})
			      h('ul', () => \{
			        list(store, (\{store\}) => \{
			          h('li', \{
			            text: remap(store, 'name'),
			          \})
			        \})
			      \})
			    \},
			  \})
			
			  expect(prettyHtml(htmlResult)).toMatchInlineSnapshot(\`
			    "
			    <header><h1>App title</h1></header>
			    <ul>
			      <li>alice</li>
			      <li>bob</li>
			      <li>carol</li>
			    </ul>
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\ssr\\renderStatic.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\forest\\__tests__\\tree.test.ts', () => {
        const sourceCode = `
			import \{createStore, createEvent, restore, combine, sample\} from 'effector'
			import \{h, using, list, remap, spec, variant, node, handler, tree\} from 'forest'
			
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			type MDNode =
			  | \{
			      type: 'text'
			      value: string
			    \}
			  | \{
			      type: 'bold'
			    \}
			  | \{
			      type: 'header'
			      level: '1' | '2' | '3'
			    \}
			  | \{
			      type: 'list'
			      listType: 'ordered' | 'unordered'
			    \}
			  | \{
			      type: 'listItem'
			    \}
			
			//prettier-ignore
			type MD = \{
			  value: MDNode
			  child: MD[]
			\};
			
			test('tree', async () => \{
			  const [s1] = await exec(async () => \{
			    function mdText(text: string): MD \{
			      return \{
			        value: \{
			          type: 'text',
			          value: text,
			        \},
			        child: [],
			      \}
			    \}
			    function listItem(child: MD[]): MD \{
			      return \{
			        value: \{
			          type: 'listItem',
			        \},
			        child,
			      \}
			    \}
			    const mdAST = createStore<MD[]>([
			      \{
			        value: \{
			          type: 'header',
			          level: '1',
			        \},
			        child: [mdText('Title')],
			      \},
			      \{
			        value: \{
			          type: 'list',
			          listType: 'unordered',
			        \},
			        child: [
			          listItem([
			            \{
			              value: \{
			                type: 'bold',
			              \},
			              child: [mdText('Foo')],
			            \},
			            mdText(': '),
			            mdText('item one'),
			          ]),
			          listItem([
			            \{
			              value: \{
			                type: 'bold',
			              \},
			              child: [mdText('Bar')],
			            \},
			            mdText(': '),
			            mdText('item two'),
			          ]),
			        ],
			      \},
			    ])
			    using(el, () => \{
			      tree(\{
			        source: mdAST,
			        child: 'child',
			        fn(\{store, child\}) \{
			          variant(\{
			            source: remap(store, 'value'),
			            key: 'type',
			            cases: \{
			              text(\{store\}) \{
			                h('span', \{
			                  text: remap(store, 'value'),
			                \})
			              \},
			              bold: () => h('b', child),
			              list(\{store\}) \{
			                variant(\{
			                  source: store,
			                  key: 'listType',
			                  cases: \{
			                    ordered: () => h('ol', child),
			                    unordered: () => h('ul', child),
			                  \},
			                \})
			              \},
			              listItem: () => h('li', child),
			              header(\{store\}) \{
			                variant(\{
			                  source: store,
			                  key: 'level',
			                  cases: \{
			                    1: () => h('h1', child),
			                    2: () => h('h2', child),
			                    3: () => h('h3', child),
			                  \},
			                \})
			              \},
			            \},
			          \})
			        \},
			      \})
			    \})
			    await act()
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <h1><span>Title</span></h1>
			    <ul>
			      <li>
			        <b><span>Foo</span></b
			        ><span>: </span><span>item one</span>
			      </li>
			      <li>
			        <b><span>Bar</span></b
			        ><span>: </span><span>item two</span>
			      </li>
			    </ul>
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\tree.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\forest\\__tests__\\variant.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{createStore, createEvent, createApi, restore\} from 'effector'
			import \{h, using, list, remap, variant\} from 'forest'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			test('with string key', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    type Text = \{
			      type: 'plain' | 'bold' | 'italic'
			      text: string
			    \}
			    const toItalic = createEvent()
			    const text = createStore<Text[]>([
			      \{type: 'plain', text: 'Bold: '\},
			      \{type: 'bold', text: 'text'\},
			    ])
			    text.on(toItalic, list =>
			      list.map(e => (e.type === 'bold' ? \{type: 'italic', text: e.text\} : e)),
			    )
			    using(el, () => \{
			      h('p', () => \{
			        list(\{source: text, key: 'text'\}, (\{store\}) => \{
			          h('div', () => \{
			            const text = remap(store, 'text')
			            variant(\{
			              source: store,
			              key: 'type',
			              cases: \{
			                plain() \{
			                  h('span', \{text\})
			                \},
			                bold() \{
			                  h('b', \{text\})
			                \},
			                italic() \{
			                  h('i', \{text\})
			                \},
			              \},
			            \})
			          \})
			        \})
			      \})
			    \})
			    await act()
			    await act(() => \{
			      toItalic()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(
			    \`"<p><div><span>Bold: </span></div><div><b>text</b></div></p>"\`,
			  )
			  expect(s2).toMatchInlineSnapshot(
			    \`"<p><div><span>Bold: </span></div><div><i>text</i></div></p>"\`,
			  )
			\})
			test('with key function', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    type Text = \{
			      type: 'plain' | 'bold' | 'italic'
			      text: string
			    \}
			    const toItalic = createEvent()
			    const text = createStore<Text[]>([
			      \{type: 'plain', text: 'Bold: '\},
			      \{type: 'bold', text: 'text'\},
			    ])
			    text.on(toItalic, list =>
			      list.map(e => (e.type === 'bold' ? \{type: 'italic', text: e.text\} : e)),
			    )
			    using(el, () => \{
			      h('p', () => \{
			        list(\{source: text, key: 'text'\}, (\{store\}) => \{
			          h('div', () => \{
			            const text = remap(store, 'text')
			            variant(\{
			              source: store,
			              //@ts-expect-error
			              key: (\{type\}) => type,
			              cases: \{
			                plain() \{
			                  h('span', \{text\})
			                \},
			                bold() \{
			                  h('b', \{text\})
			                \},
			                italic() \{
			                  h('i', \{text\})
			                \},
			              \},
			            \})
			          \})
			        \})
			      \})
			    \})
			    await act()
			    await act(() => \{
			      toItalic()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(
			    \`"<p><div><span>Bold: </span></div><div><b>text</b></div></p>"\`,
			  )
			  expect(s2).toMatchInlineSnapshot(
			    \`"<p><div><span>Bold: </span></div><div><i>text</i></div></p>"\`,
			  )
			\})
			
			test('nested variants', async () => \{
			  const [s1, s2, s3] = await exec(async () => \{
			    const currentRoute = createStore(\{name: 'main'\})
			    const \{goMain, goLogin\} = createApi(currentRoute, \{
			      goMain: () => (\{name: 'main'\}),
			      goLogin: () => (\{name: 'login'\}),
			    \})
			
			    const step = createStore(\{name: 'email'\})
			
			    using(el, () => \{
			      h('header', () => \{
			        h('button', \{
			          attr: \{id: 'go_main'\},
			          text: 'Go /main',
			          handler: \{click: goMain as any\},
			        \})
			        h('button', \{
			          attr: \{id: 'go_login'\},
			          text: 'Go /login',
			          handler: \{click: goLogin as any\},
			        \})
			      \})
			      variant(\{
			        source: currentRoute,
			        key: 'name',
			        cases: \{
			          main() \{
			            h('h1', \{text: 'Main page'\})
			          \},
			          login() \{
			            h('header', () => \{
			              h('h1', \{text: 'Login page'\})
			            \})
			            variant(\{
			              source: step,
			              key: 'name',
			              cases: \{
			                email() \{
			                  h('div', \{text: 'email'\})
			                \},
			                pass() \{
			                  h('div', \{text: 'pass'\})
			                \},
			              \},
			            \})
			          \},
			        \},
			      \})
			    \})
			    await act()
			    await act(() => \{
			      document.getElementById('go_login')!.click()
			    \})
			    await act(() => \{
			      document.getElementById('go_main')!.click()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <header>
			      <button id='go_main'>Go /main</button
			      ><button id='go_login'>Go /login</button>
			    </header>
			    <h1>Main page</h1>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <header>
			      <button id='go_main'>Go /main</button
			      ><button id='go_login'>Go /login</button>
			    </header>
			    <header><h1>Login page</h1></header>
			    <div>email</div>
			    "
			  \`)
			  expect(s3).toMatchInlineSnapshot(\`
			    "
			    <header>
			      <button id='go_main'>Go /main</button
			      ><button id='go_login'>Go /login</button>
			    </header>
			    <h1>Main page</h1>
			    "
			  \`)
			\})
			
			describe('list in variant', () => \{
			  test('#1', async () => \{
			    const [s1, s2, s3] = await exec(async () => \{
			      const messages = createStore(['first message', 'second message'])
			      const currentRoute = createStore(\{name: 'main'\})
			      const \{goMain, goChat\} = createApi(currentRoute, \{
			        goMain: () => (\{name: 'main'\}),
			        goChat: () => (\{name: 'chat'\}),
			      \})
			
			      using(el, () => \{
			        h('header', () => \{
			          h('button', \{
			            attr: \{id: 'go_main'\},
			            text: 'Go /main',
			            handler: \{click: goMain as any\},
			          \})
			          h('button', \{
			            attr: \{id: 'go_chat'\},
			            text: 'Go /chat',
			            handler: \{click: goChat as any\},
			          \})
			        \})
			        variant(\{
			          source: currentRoute,
			          key: 'name',
			          cases: \{
			            main() \{
			              h('h1', \{text: 'Main page'\})
			            \},
			            chat() \{
			              h('h1', \{text: 'Chat page'\})
			              list(messages, (\{store\}) => \{
			                h('div', \{text: store\})
			              \})
			            \},
			          \},
			        \})
			      \})
			      await act()
			      await act(() => \{
			        document.getElementById('go_chat')!.click()
			      \})
			      await act(() => \{
			        document.getElementById('go_main')!.click()
			      \})
			    \})
			    expect(s1).toMatchInlineSnapshot(\`
			      "
			      <header>
			        <button id='go_main'>Go /main</button
			        ><button id='go_chat'>Go /chat</button>
			      </header>
			      <h1>Main page</h1>
			      "
			    \`)
			    expect(s2).toMatchInlineSnapshot(\`
			      "
			      <header>
			        <button id='go_main'>Go /main</button
			        ><button id='go_chat'>Go /chat</button>
			      </header>
			      <h1>Chat page</h1>
			      <div>first message</div>
			      <div>second message</div>
			      "
			    \`)
			    expect(s3).toMatchInlineSnapshot(\`
			      "
			      <header>
			        <button id='go_main'>Go /main</button
			        ><button id='go_chat'>Go /chat</button>
			      </header>
			      <h1>Main page</h1>
			      "
			    \`)
			  \})
			\})
			
			describe('dom node insertion', () => \{
			  test('update list items', async () => \{
			    const [initial, s2, s3, s4] = await exec(async () => \{
			      using(el, () => \{
			        const kindChange = createEvent<'days' | 'months'>()
			        const kind\$ = restore(kindChange, 'days')
			        h('div', () => \{
			          h('button', \{
			            text: 'Days',
			            handler: \{
			              click: kindChange.prepend(() => 'days'),
			            \},
			            attr: \{id: 'days'\},
			          \})
			          h('button', \{
			            text: 'Months',
			            handler: \{
			              click: kindChange.prepend(() => 'months'),
			            \},
			            attr: \{id: 'months'\},
			          \})
			          const change = createEvent<MouseEvent>()
			          const \$source = createStore(7).on(change, () => 3)
			          const \$items = \$source.map(length =>
			            Array.from(\{length\}, (_, i) => (\{key: i\})),
			          )
			
			          h('div', () => \{
			            variant(\{
			              source: kind\$.map(view => (\{view\})),
			              key: 'view',
			              cases: \{
			                days() \{
			                  h('h1', \{text: 'Days'\})
			                  list(\{
			                    source: \$items,
			                    key: 'key',
			                    fields: ['key'],
			                    fn: (\{fields: [key]\}) => h('div', \{text: key\}),
			                  \})
			                \},
			                months() \{
			                  h('h1', \{text: 'Months'\})
			                  h('button', \{
			                    text: 'Click here',
			                    handler: \{click: change\},
			                    attr: \{id: 'change'\},
			                  \})
			                \},
			              \},
			            \})
			          \})
			        \})
			      \})
			      await act()
			      await act(async () => \{
			        document.getElementById('months')!.click()
			      \})
			      await act(async () => \{
			        document.getElementById('change')!.click()
			      \})
			      await act(async () => \{
			        document.getElementById('days')!.click()
			      \})
			    \})
			    expect(initial).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Days</h1>
			          <div>0</div>
			          <div>1</div>
			          <div>2</div>
			          <div>3</div>
			          <div>4</div>
			          <div>5</div>
			          <div>6</div>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Months</h1>
			          <button id='change'>Click here</button>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s3).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Months</h1>
			          <button id='change'>Click here</button>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s4).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Days</h1>
			          <div>0</div>
			          <div>1</div>
			          <div>2</div>
			        </div>
			      </div>
			      "
			    \`)
			  \})
			  test('add new list items', async () => \{
			    const [initial, s2, s3, s4] = await exec(async () => \{
			      using(el, () => \{
			        const kindChange = createEvent<'days' | 'months'>()
			        const kind\$ = restore(kindChange, 'days')
			        h('div', () => \{
			          h('button', \{
			            text: 'Days',
			            handler: \{
			              click: kindChange.prepend(() => 'days'),
			            \},
			            attr: \{id: 'days'\},
			          \})
			          h('button', \{
			            text: 'Months',
			            handler: \{
			              click: kindChange.prepend(() => 'months'),
			            \},
			            attr: \{id: 'months'\},
			          \})
			          const change = createEvent<MouseEvent>()
			          const \$source = createStore(7).on(change, () => 0)
			          const \$items = \$source.map(month => [
			            \{day: '1-' + month\},
			            \{day: '2-' + month\},
			          ])
			
			          h('div', () => \{
			            variant(\{
			              source: kind\$.map(view => (\{view\})),
			              key: 'view',
			              cases: \{
			                days() \{
			                  h('h1', \{text: 'Days'\})
			                  list(\{
			                    source: \$items,
			                    key: 'day',
			                    fields: ['day'],
			                    fn: (\{fields: [day]\}) => h('div', \{text: day\}),
			                  \})
			                \},
			                months() \{
			                  h('h1', \{text: 'Months'\})
			                  h('button', \{
			                    text: 'change',
			                    handler: \{click: change\},
			                    attr: \{id: 'change'\},
			                  \})
			                \},
			              \},
			            \})
			          \})
			        \})
			      \})
			      await act()
			      await act(async () => \{
			        document.getElementById('months')!.click()
			      \})
			      await act(async () => \{
			        document.getElementById('change')!.click()
			      \})
			      await act(async () => \{
			        document.getElementById('days')!.click()
			      \})
			    \})
			    expect(initial).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Days</h1>
			          <div>1-7</div>
			          <div>2-7</div>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Months</h1>
			          <button id='change'>change</button>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s3).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Months</h1>
			          <button id='change'>change</button>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s4).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='days'>Days</button
			        ><button id='months'>Months</button>
			        <div>
			          <h1>Days</h1>
			          <div>1-0</div>
			          <div>2-0</div>
			        </div>
			      </div>
			      "
			    \`)
			  \})
			  test('add new nodes by variant', async () => \{
			    const [initial, s2, s3, s4] = await exec(async () => \{
			      using(el, () => \{
			        const firstLevelChange = createEvent<'A' | 'B'>()
			        const \$firstLevel = restore(firstLevelChange, 'A')
			        h('div', () => \{
			          h('button', \{
			            text: 'A',
			            handler: \{
			              click: firstLevelChange.prepend(() => 'A'),
			            \},
			            attr: \{id: 'btA'\},
			          \})
			          h('button', \{
			            text: 'B',
			            handler: \{
			              click: firstLevelChange.prepend(() => 'B'),
			            \},
			            attr: \{id: 'btB'\},
			          \})
			          const change = createEvent<MouseEvent>()
			          const \$secondLevel = createStore<\{level: 'a' | 'b'\}>(\{level: 'a'\}).on(
			            change,
			            () => (\{level: 'b'\}),
			          )
			          h('div', () => \{
			            variant(\{
			              source: \$firstLevel.map(level => (\{level\})),
			              key: 'level',
			              cases: \{
			                A() \{
			                  h('h1', \{text: 'A'\})
			                  variant(\{
			                    source: \$secondLevel,
			                    key: 'level',
			                    cases: \{
			                      a: () => h('div', \{text: 'a'\}),
			                      b: () => h('div', \{text: 'b'\}),
			                    \},
			                  \})
			                \},
			                B() \{
			                  h('h1', \{text: 'B'\})
			                  h('button', \{
			                    text: 'change',
			                    handler: \{click: change\},
			                    attr: \{id: 'change'\},
			                  \})
			                \},
			              \},
			            \})
			          \})
			        \})
			      \})
			      await act()
			      await act(async () => \{
			        document.getElementById('btB')!.click()
			      \})
			      await act(async () => \{
			        document.getElementById('change')!.click()
			      \})
			      await act(async () => \{
			        document.getElementById('btA')!.click()
			      \})
			    \})
			    expect(initial).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='btA'>A</button><button id='btB'>B</button>
			        <div>
			          <h1>A</h1>
			          <div>a</div>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s2).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='btA'>A</button><button id='btB'>B</button>
			        <div>
			          <h1>B</h1>
			          <button id='change'>change</button>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s3).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='btA'>A</button><button id='btB'>B</button>
			        <div>
			          <h1>B</h1>
			          <button id='change'>change</button>
			        </div>
			      </div>
			      "
			    \`)
			    expect(s4).toMatchInlineSnapshot(\`
			      "
			      <div>
			        <button id='btA'>A</button><button id='btB'>B</button>
			        <div>
			          <h1>A</h1>
			          <div>b</div>
			        </div>
			      </div>
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\variant.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('effector_effector\\src\\forest\\__tests__\\visible.test.ts', () => {
        const sourceCode = `
			import type \{BrowserObject\} from 'webdriverio'
			import \{createStore, createEvent\} from 'effector'
			import \{h, using, list, spec\} from 'forest'
			
			// let addGlobals: Function
			declare const act: (cb?: () => any) => Promise<void>
			declare const initBrowser: () => Promise<void>
			declare const el: HTMLElement
			// let execFun: <T>(cb: (() => Promise<T> | T) | string) => Promise<T>
			// let readHTML: () => string
			declare const browser: BrowserObject
			declare const exec: (cb: () => any) => Promise<string[]>
			declare const execFunc: <T>(cb: () => Promise<T>) => Promise<T>
			
			beforeEach(async () => \{
			  await initBrowser()
			\}, 10e3)
			
			it('support visible as dom node property', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const toggleVisible = createEvent<string>()
			    const text = createStore([
			      \{text: 'a', visible: true\},
			      \{text: 'b', visible: false\},
			      \{text: 'c', visible: true\},
			    ]).on(toggleVisible, (list, text) =>
			      list.map(e =>
			        e.text === text ? \{text: e.text, visible: !e.visible\} : e,
			      ),
			    )
			
			    using(el, () => \{
			      list(
			        \{
			          source: text,
			          key: 'text',
			          fields: ['text', 'visible'],
			        \},
			        (\{fields: [text, visible]\}) => \{
			          h('p', \{text, visible\})
			        \},
			      )
			    \})
			    await act()
			    await act(() => \{
			      toggleVisible('b')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <p>a</p>
			    <p>c</p>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <p>a</p>
			    <p>b</p>
			    <p>c</p>
			    "
			  \`)
			\})
			it('support visible as list item property', async () => \{
			  const [s1, s2] = await exec(async () => \{
			    const toggleVisible = createEvent<string>()
			    const text = createStore([
			      \{text: 'a', visible: true\},
			      \{text: 'b', visible: false\},
			      \{text: 'c', visible: true\},
			    ]).on(toggleVisible, (list, text) =>
			      list.map(e =>
			        e.text === text ? \{text: e.text, visible: !e.visible\} : e,
			      ),
			    )
			
			    using(el, () => \{
			      h('div', () => \{
			        list(
			          \{
			            source: text,
			            key: 'text',
			            fields: ['text', 'visible'],
			          \},
			          (\{fields: [text, visible]\}) => \{
			            spec(\{visible\})
			            h('p', \{text\})
			          \},
			        )
			      \})
			    \})
			    await act()
			    await act(() => \{
			      toggleVisible('b')
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <div>
			      <p>a</p>
			      <p>c</p>
			    </div>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <div>
			      <p>a</p>
			      <p>b</p>
			      <p>c</p>
			    </div>
			    "
			  \`)
			\})
			test('re-insertion order', async () => \{
			  const [s1, s2, s3] = await exec(async () => \{
			    const toggleVisible = createEvent()
			    const visible = createStore(true).on(toggleVisible, visible => !visible)
			    using(el, () => \{
			      h('section', () => \{
			        h('div', () => \{
			          spec(\{
			            visible,
			            text: 'aside',
			          \})
			        \})
			        h('div', () => \{
			          spec(\{
			            text: 'content',
			          \})
			        \})
			      \})
			    \})
			    await act()
			    await act(() => \{
			      toggleVisible()
			    \})
			    await act(() => \{
			      toggleVisible()
			    \})
			  \})
			  expect(s1).toMatchInlineSnapshot(\`
			    "
			    <section>
			      <div>aside</div>
			      <div>content</div>
			    </section>
			    "
			  \`)
			  expect(s2).toMatchInlineSnapshot(\`
			    "
			    <section><div>content</div></section>
			    "
			  \`)
			  expect(s3).toMatchInlineSnapshot(\`
			    "
			    <section>
			      <div>aside</div>
			      <div>content</div>
			    </section>
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\forest\\__tests__\\visible.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\createComponent.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			import \{argumentHistory\} from 'effector/fixtures'
			import \{act, render, cleanup, container\} from 'effector/fixtures/react'
			import \{createStore, combine, createEvent, createApi\} from 'effector'
			import \{createComponent\} from 'effector-react'
			
			describe('createComponent', () => \{
			  test('combine', async () => \{
			    const a = createStore(0)
			    const b = createStore('bar')
			    const c = combine(\{a, b\})
			    const fn = jest.fn()
			    const Foo = createComponent(c, (_, state) => (
			      <>
			        <div>\{state.b\}</div>
			        <select value=\{state.b\} onChange=\{() => \{\}\}>
			          <option value="bar">bar</option>
			          <option value="foo">foo</option>
			        </select>
			      </>
			    ))
			    await render(<Foo />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        bar
			      </div>
			    \`)
			    await act(async () => \{
			      //@ts-ignore
			      a.setState(2)
			      //@ts-ignore
			      b.setState('foo')
			      c.watch(fn)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        foo
			      </div>
			    \`)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "a": 2,
			          "b": "foo",
			        \},
			      ]
			    \`)
			  \})
			
			  test('should throw', () => \{
			    expect(() => \{
			      //@ts-ignore
			      createComponent(50, (_, \{a, b\}) => a * b)
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"shape should be a store or object with stores"\`,
			    )
			  \})
			
			  test('combine', async () => \{
			    const a = createStore(2)
			    const b = createStore(2)
			    const ObjectComponent = createComponent(\{a, b\}, (_, \{a, b\}) => a * b)
			    await render(<ObjectComponent />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`4\`)
			  \})
			
			  test('mounted/unmounted events', async () => \{
			    const text = createStore('foo')
			    const fn = jest.fn()
			    const Component = createComponent(text, () => null)
			    Component.mounted.watch(fn)
			    Component.unmounted.watch(fn)
			    await render(<Component foo=\{1\} />)
			    await act(async () => \{
			      //@ts-ignore
			      text.setState('bar')
			    \})
			    await cleanup()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "props": Object \{
			            "foo": 1,
			          \},
			          "state": "foo",
			        \},
			        Object \{
			          "props": Object \{
			            "foo": 1,
			          \},
			          "state": "bar",
			        \},
			      ]
			    \`)
			  \})
			
			  test('mount event', async () => \{
			    const a = createStore(1)
			    const b = createStore('bar')
			    const \{add\} = createApi(a, \{
			      add: (x, y) => x + y,
			    \})
			    const updateValue = createEvent()
			    const c = combine(\{a, b\})
			    const fn = jest.fn()
			    const Foo = createComponent(c, (_, state) => (
			      <>
			        <div>\{state.b\}</div>
			        <select value=\{state.b\} onChange=\{updateValue\}>
			          <option value="bar">bar</option>
			          <option value="foo">foo</option>
			        </select>
			      </>
			    ))
			    Foo.mounted.watch(fn)
			    await render(<Foo a="A" />)
			    await act(async () => \{
			      add(5)
			    \})
			    await render(<Foo b="B" />)
			    await cleanup()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "props": Object \{
			            "a": "A",
			          \},
			          "state": Object \{
			            "a": 1,
			            "b": "bar",
			          \},
			        \},
			      ]
			    \`)
			  \})
			  test('unmount event', async () => \{
			    const a = createStore(1)
			    const b = createStore('bar')
			    const \{add\} = createApi(a, \{
			      add: (x, y) => x + y,
			    \})
			    const updateValue = createEvent()
			    const c = combine(\{a, b\})
			    const fn = jest.fn()
			    const Foo = createComponent(c, (_, state) => (
			      <>
			        <div>\{state.b\}</div>
			        <select value=\{state.b\} onChange=\{updateValue\}>
			          <option value="bar">bar</option>
			          <option value="foo">foo</option>
			        </select>
			      </>
			    ))
			    Foo.unmounted.watch(fn)
			    await render(<Foo a="A" />)
			    await act(async () => \{
			      add(5)
			    \})
			    await render(<Foo b="B" />)
			    await cleanup()
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "props": Object \{
			            "b": "B",
			          \},
			          "state": Object \{
			            "a": 6,
			            "b": "bar",
			          \},
			        \},
			      ]
			    \`)
			  \})
			
			  test('hooks', async () => \{
			    const text = createStore('foo')
			    const HookComponent = createComponent(text, (_, text) => \{
			      const [count, setCount] = React.useState(0)
			      return (
			        <div>
			          <div>Text: \{text\}</div>
			          <div>Counter: \{count\}</div>
			          <button id="increment" onClick=\{() => setCount(count + 1)\}>
			            incr
			          </button>
			        </div>
			      )
			    \})
			    await render(<HookComponent />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			<div>
			  <div>
			    Text: 
			    foo
			  </div>
			  <div>
			    Counter: 
			    0
			  </div>
			  <button
			    id="increment"
			  >
			    incr
			  </button>
			</div>
			\`)
			    await act(async () => \{
			      container.firstChild.querySelector('#increment').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			<div>
			  <div>
			    Text: 
			    foo
			  </div>
			  <div>
			    Counter: 
			    1
			  </div>
			  <button
			    id="increment"
			  >
			    incr
			  </button>
			</div>
			\`)
			  \})
			  it('should not use props from failed renders', async () => \{
			    const fn = jest.fn()
			    const text = createStore('foo')
			    const Foo = createComponent(text, (props, text) => \{
			      if (props.shouldFail) \{
			        throw Error('[expect error]')
			      \}
			      return (
			        <div>
			          \{props.field\} \{text\}
			        </div>
			      )
			    \})
			    Foo.unmounted.watch(fn)
			    const error = console.error
			    //@ts-ignore
			    console.error = function errorMock(...args) \{
			      args
			    \}
			    try \{
			      await render(<Foo shouldFail=\{false\} field="init" />)
			      await render(<Foo shouldFail=\{false\} field="correct" />)
			      await render(<Foo shouldFail=\{true\} field="incorrect" />).catch(() => \{\})
			      await cleanup()
			    \} finally \{
			      //@ts-ignore
			      console.error = error
			    \}
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "props": Object \{
			            "field": "correct",
			            "shouldFail": false,
			          \},
			          "state": "foo",
			        \},
			      ]
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\createComponent.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\createContextComponent.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			import \{createEvent, createStore\} from 'effector'
			import \{createContextComponent\} from 'effector-react'
			//@ts-expect-error
			import \{render, container, act\} from 'effector/fixtures/react'
			
			let warn: jest.SpyInstance<void, [message?: any, ...optionalParams: any[]]>
			
			beforeEach(() => \{
			  warn = jest.spyOn(console, 'error').mockImplementation(() => \{\})
			\})
			afterEach(() => \{
			  warn.mockRestore()
			\})
			
			test('createContextComponent', async () => \{
			  const store = createStore('foo')
			  const changeText = createEvent()
			  store.on(changeText, (_, e) => e)
			  const Context = React.createContext('bar')
			
			  const Display = createContextComponent(
			    store,
			    Context,
			    (props, store, context) => (
			      <span>
			        Store text: \{store\}
			        <br />
			        Context text: \{context\}
			      </span>
			    ),
			  )
			
			  expect(warn.mock.calls.map(([msg]) => msg)).toEqual([
			    'createContextComponent is deprecated',
			  ])
			
			  await render(<Display />)
			  expect(container.textContent).toMatchInlineSnapshot(
			    \`"Store text: fooContext text: bar"\`,
			  )
			  await act(async () => \{
			    changeText('bar')
			  \})
			  expect(container.textContent).toMatchInlineSnapshot(
			    \`"Store text: barContext text: bar"\`,
			  )
			
			  await render(
			    <Context.Provider value="test">
			      <Display />
			    </Context.Provider>,
			  )
			  expect(container.textContent).toMatchInlineSnapshot(
			    \`"Store text: barContext text: test"\`,
			  )
			  await act(async () => \{
			    changeText('foo')
			  \})
			  expect(container.textContent).toMatchInlineSnapshot(
			    \`"Store text: fooContext text: test"\`,
			  )
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\createContextComponent.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\createGate.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			//@ts-expect-error
			import \{render, cleanup, container, act\} from 'effector/fixtures/react'
			import \{createGate, useGate, useStore, Provider\} from 'effector-react'
			import \{createGate as createGateScope\} from 'effector-react/scope'
			
			import \{argumentHistory\} from 'effector/fixtures'
			import \{
			  allSettled,
			  createEffect,
			  createEvent,
			  createStore,
			  fork,
			  forward,
			  sample,
			  serialize,
			\} from 'effector'
			
			test('plain gate', async () => \{
			  const Gate = createGate('plain gate')
			  expect(Gate.status.getState()).toBe(false)
			  await render(
			    <section>
			      <div>div</div>
			      <Gate />
			    </section>,
			  )
			  expect(Gate.status.getState()).toBe(true)
			  await cleanup()
			  expect(Gate.status.getState()).toBe(false)
			\})
			
			test('plain gate hook', async () => \{
			  const Gate = createGate('plain gate')
			  expect(Gate.status.getState()).toBe(false)
			  const Component = () => \{
			    useGate(Gate)
			    return (
			      <section>
			        <div>div</div>
			      </section>
			    )
			  \}
			  await render(<Component />)
			
			  expect(Gate.status.getState()).toBe(true)
			  await cleanup()
			  expect(Gate.status.getState()).toBe(false)
			\})
			
			test('gate with props', async () => \{
			  const Gate = createGate('gate with props')
			  await render(
			    <section>
			      <Gate foo="bar" />
			    </section>,
			  )
			  expect(Gate.state.getState()).toMatchObject(\{foo: 'bar'\})
			  expect(container.firstChild).toMatchInlineSnapshot(\`<section />\`)
			  await cleanup()
			  expect(Gate.state.getState()).toMatchObject(\{\})
			\})
			
			test('gate with props hook', async () => \{
			  const Gate = createGate('gate with props')
			  const Component = () => \{
			    useGate(Gate, \{foo: 'bar'\})
			    return <section />
			  \}
			  await render(<Component />)
			  expect(Gate.state.getState()).toMatchObject(\{foo: 'bar'\})
			  expect(container.firstChild).toMatchInlineSnapshot(\`<section />\`)
			  await cleanup()
			  expect(Gate.state.getState()).toMatchObject(\{\})
			\})
			
			describe('updates deduplication', () => \{
			  test('with component', async () => \{
			    const fn = jest.fn()
			    const Gate = createGate()
			    const update = createEvent()
			    const count = createStore(0).on(update, x => x + 1)
			
			    Gate.state.updates.watch(fn)
			
			    const Component = () => \{
			      const x = useStore(count)
			      return (
			        <section>
			          <Gate field=\{x === 2\} />
			          \{x\}
			        </section>
			      )
			    \}
			    await render(<Component />)
			    await act(async () => \{
			      update()
			    \})
			    await act(async () => \{
			      update()
			    \})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "field": false,
			        \},
			        Object \{
			          "field": true,
			        \},
			      ]
			    \`)
			  \})
			  test('with hook', async () => \{
			    const fn = jest.fn()
			    const Gate = createGate()
			    const update = createEvent()
			    const count = createStore(0).on(update, x => x + 1)
			
			    Gate.state.updates.watch(fn)
			
			    const Component = () => \{
			      const x = useStore(count)
			      useGate(Gate, \{field: x === 2\})
			      return <section>\{x\}</section>
			    \}
			    await render(<Component />)
			    await act(async () => \{
			      update()
			    \})
			    await act(async () => \{
			      update()
			    \})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "field": false,
			        \},
			        Object \{
			          "field": true,
			        \},
			      ]
			    \`)
			  \})
			\})
			
			test('gate properties', async () => \{
			  const Gate = createGate('gate properties')
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  Gate.status.watch(isOpen => fn1(isOpen))
			  Gate.state.watch(props => fn2(props))
			  await render(
			    <section>
			      <Gate foo="bar" />
			    </section>,
			  )
			  await cleanup()
			  expect(argumentHistory(fn1)).toEqual([false, true, false])
			  expect(argumentHistory(fn2)).toEqual([\{\}, \{foo: 'bar'\}, \{\}])
			\})
			
			test('Gate.state should have sid', () => \{
			  const Gate = createGate('default')
			  expect(Gate.state.sid).toBeDefined()
			  expect(Gate.state.sid).toBeTruthy()
			  expect(Gate.state.sid!.length > 0).toBe(true)
			\})
			
			test('Gate events should have sid', () => \{
			  const Gate = createGate('default')
			  expect(Gate.open.sid).toBeDefined()
			  expect(Gate.close.sid).toBeDefined()
			  expect(Gate.open.sid!.match(/.*\\|open/)?.length === 1).toBe(true)
			  expect(Gate.close.sid!.match(/.*\\|close/)?.length === 1).toBe(true)
			\})
			
			test('Gate name set from variable name', () => \{
			  const exampleGate = createGate()
			  expect(exampleGate.state.compositeName.fullName).toMatchInlineSnapshot(
			    \`"exampleGate.state"\`,
			  )
			\})
			
			test('allows to pass defaultState with the name', async () => \{
			  const Gate = createGate('default', \{counter: 0\})
			  const scope = fork()
			  await allSettled(Gate.open, \{scope, params: \{counter: 1\}\})
			
			  const states = serialize(scope)
			  expect(states[Gate.state.sid!]).toEqual(\{counter: 1\})
			\})
			
			test('works without babel plugin', () => \{
			  const Gate1 = \{_: createGate\}._('name')
			  const Gate2 = \{_: createGate\}._('name', \{state: 1\})
			  const Gate3 = \{_: createGate\}._(\{name: 'name', defaultState: \{state: 1\}\})
			  const Gate4 = \{_: createGate\}._(\{
			    name: 'name',
			    defaultState: \{state: 1\},
			    sid: 'custom-sid',
			  \})
			
			  expect(Gate1.state.shortName).toMatchInlineSnapshot(\`"name.state"\`)
			  expect(Gate2.state.shortName).toMatchInlineSnapshot(\`"name.state"\`)
			  expect(Gate2.state.getState()).toEqual(\{state: 1\})
			
			  expect(Gate3.state.shortName).toMatchInlineSnapshot(\`"name.state"\`)
			  expect(Gate3.state.getState()).toEqual(\{state: 1\})
			
			  expect(Gate4.state.shortName).toMatchInlineSnapshot(\`"name.state"\`)
			  expect(Gate4.state.sid).toMatchInlineSnapshot(\`"custom-sid"\`)
			\})
			
			test('gate should be correctly serialized via fork #672', async () => \{
			  const Gate = createGate('default')
			  const scope = fork()
			  await allSettled(Gate.open, \{scope, params: 'another'\})
			
			  const states = serialize(scope)
			  expect(states[Gate.state.sid!]).toBe('another')
			\})
			
			test('gate component should be isomorphic to scope', async () => \{
			  const Gate = createGate('default')
			  const logged = jest.fn()
			  const logFx = createEffect(() => \{\})
			
			  sample(\{
			    clock: Gate.open,
			    target: logFx,
			  \})
			
			  const scope = fork(\{
			    handlers: [[logFx, () => logged('scoped')]],
			  \})
			
			  await render(
			    <Provider value=\{scope\}>
			      <Gate />
			    </Provider>,
			  )
			
			  expect(logged).toBeCalledTimes(1)
			  expect(logged).toBeCalledWith('scoped')
			\})
			
			test('gate properties hook', async () => \{
			  const Gate = createGate('gate properties')
			  const fn1 = jest.fn()
			  const fn2 = jest.fn()
			  Gate.status.watch(isOpen => fn1(isOpen))
			  Gate.state.watch(props => fn2(props))
			  const Component = () => \{
			    useGate(Gate, \{foo: 'bar'\})
			    return <section />
			  \}
			  await render(<Component />)
			  await cleanup()
			  expect(argumentHistory(fn1)).toEqual([false, true, false])
			  expect(argumentHistory(fn2)).toEqual([\{\}, \{foo: 'bar'\}, \{\}])
			\})
			
			test('setState warning', async () => \{
			  const oldConsoleError = console.error
			  const fn = jest.fn()
			  console.error = (...args: any[]) => \{
			    fn(args.slice(0, -1).join(', '))
			  \}
			  const setText = createEvent<string>()
			  const gate = createGate<string>()
			  const store = createStore('').on(setText, (_, text) => text)
			  forward(\{
			    from: gate.state,
			    to: setText,
			  \})
			  function Test(\{changeText\}: \{changeText: Function\}) \{
			    const text = useStore(store)
			    return (
			      <div>
			        <button
			          id="button"
			          onClick=\{() => \{
			            changeText(Math.random().toString(16))
			          \}\}>
			          update
			        </button>
			        \{text\}
			      </div>
			    )
			  \}
			  function App() \{
			    const [text, setText] = React.useState(Math.random().toString(16))
			    useGate(gate, text)
			
			    return (
			      <div className="App">
			        <h1>Hello CodeSandbox</h1>
			        <h2>Start editing to see some magic happen!</h2>
			        <Test changeText=\{setText\} />
			      </div>
			    )
			  \}
			  await render(
			    <React.StrictMode>
			      <App />
			    </React.StrictMode>,
			  )
			  await act(async () => \{
			    container.querySelector('#button').click()
			  \})
			  console.error = oldConsoleError
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`Array []\`)
			\})
			
			describe('createGate without arguments', () => \{
			  test('common createGate', () => \{
			    expect(() => \{
			      ;(\{_: createGate\}._())
			    \}).not.toThrow()
			  \})
			
			  test('common createGate with babel-plugin', () => \{
			    expect(() => \{
			      createGate()
			    \}).not.toThrow()
			  \})
			
			  test('scope createGate', () => \{
			    expect(() => \{
			      //@ts-expect-error
			      ;(\{_: createGateScope\}._())
			    \}).not.toThrow()
			  \})
			
			  test('scope createGate with babel-plugin', () => \{
			    expect(() => \{
			      //@ts-expect-error
			      createGateScope()
			    \}).not.toThrow()
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\createGate.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(20)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\createStoreConsumer.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			import \{act, render, cleanup, container\} from 'effector/fixtures/react'
			import \{argumentHistory\} from 'effector/fixtures'
			import \{createEvent, createStore, combine\} from 'effector'
			import \{createStoreConsumer\} from 'effector-react'
			
			test('createStoreComponent attempt', async() => \{
			  const store1 = createStore('foo')
			  const changeText = createEvent()
			  store1.on(changeText, (_, payload) => payload)
			  const Store1 = createStoreConsumer(store1)
			  await render(<Store1>\{state => <span>Current state: \{state\}</span>\}</Store1>)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Current state: 
			      foo
			    </span>
			  \`)
			  await act(async() => \{
			    changeText('bar')
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Current state: 
			      bar
			    </span>
			  \`)
			\})
			
			test('no dull re-renders', async() => \{
			  const fn = jest.fn()
			  const reset = createEvent()
			  const inc = createEvent()
			  const listSize = createStore(3)
			    .on(inc, n => n + 1)
			    .reset(reset)
			  const currentList = createStore(
			    Array.from(\{length: listSize.getState()\}, (_, n) => n),
			  )
			    .on(inc, list => [...list, list.length])
			    .reset(reset)
			  const selected = createStore([])
			
			  const fullStore = combine(\{listSize, currentList, selected\})
			
			  const CurrentList = createStoreConsumer(currentList)
			
			  await render(
			    <CurrentList>
			      \{state => \{
			        fn(state)
			        return <span>Current state: \{String(state)\}</span>
			      \}\}
			    </CurrentList>,
			  )
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Current state: 
			      0,1,2
			    </span>
			  \`)
			  await act(async() => \{
			    inc()
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Current state: 
			      0,1,2,3
			    </span>
			  \`)
			  await act(async() => \{
			    reset()
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Current state: 
			      0,1,2
			    </span>
			  \`)
			  await cleanup()
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        0,
			        1,
			        2,
			      ],
			      Array [
			        0,
			        1,
			        2,
			        3,
			      ],
			      Array [
			        0,
			        1,
			        2,
			      ],
			    ]
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\createStoreConsumer.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\index.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			import \{act, render, container\} from 'effector/fixtures/react'
			import \{createStore, createEvent\} from 'effector'
			import \{connect\} from 'effector-react'
			
			test('connect api', async() => \{
			  const text = createStore('foo')
			  const store = text.map(text => (\{text\}))
			  const changeText = createEvent()
			  text.on(changeText, (_, e) => e)
			
			  class Display extends React.Component<\{
			    text: string,
			    count: number,
			  \}> \{
			    render() \{
			      return (
			        <span>
			          Text: \{this.props.text\}/ Counter: \{this.props.count\}
			        </span>
			      )
			    \}
			  \}
			  const ConnectedDisplay = connect(Display)(store)
			
			  await render(<ConnectedDisplay count=\{1\} />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Text: 
			      foo
			      / Counter: 
			      1
			    </span>
			  \`)
			  await act(async() => \{
			    changeText('bar')
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Text: 
			      bar
			      / Counter: 
			      1
			    </span>
			  \`)
			\})
			
			test('click counter', async() => \{
			  const count = createStore(0)
			  const store = count.map(text => (\{text\}))
			  const increment = createEvent()
			
			  count.on(increment, state => state + 1)
			
			  class Display extends React.Component<\{count: number\}> \{
			    render() \{
			      return (
			        <span>
			          Counter: \{this.props.count\}
			          <button id="increment" onClick=\{() => increment()\}>
			            Increment
			          </button>
			        </span>
			      )
			    \}
			  \}
			  const ConnectedDisplay = connect(Display)(store)
			
			  await render(<ConnectedDisplay />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Counter: 
			      <button
			        id="increment"
			      >
			        Increment
			      </button>
			    </span>
			  \`)
			  await act(async() => \{
			    container.firstChild.querySelector('#increment').click()
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <span>
			      Counter: 
			      <button
			        id="increment"
			      >
			        Increment
			      </button>
			    </span>
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\rerendering.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			import \{render\} from 'effector/fixtures/react'
			
			import \{createStore, createEffect, combine\} from 'effector'
			import \{useStore\} from 'effector-react'
			import \{argumentHistory\} from 'effector/fixtures/index'
			
			it('should rerender only once', async() => \{
			  const fn = jest.fn()
			  const getPresentation = createEffect(\{
			    async handler() \{
			      await 1
			      return 'ok'
			    \},
			  \})
			  const presentation = createStore(null).on(
			    getPresentation.done,
			    (_, \{result\}) => result,
			  )
			  const loading = createStore(true)
			    .on(getPresentation, () => true)
			    .on(getPresentation.finally, () => false)
			  const presentationStore = combine(\{
			    loading,
			    presentation,
			  \})
			
			  const View = () => \{
			    const presentation = useStore(presentationStore)
			    React.useEffect(() => \{
			      getPresentation()
			    \}, [])
			    fn(presentation)
			    return (
			      <div>
			        <p>is loading: \{presentation.loading.toString()\}</p>
			        <p>presentation: \{presentation.presentation\}</p>
			      </div>
			    )
			  \}
			  await render(<View />)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "loading": true,
			        "presentation": null,
			      \},
			      Object \{
			        "loading": false,
			        "presentation": "ok",
			      \},
			    ]
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\rerendering.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\rfc1.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			import \{from\} from 'most'
			
			import \{createStore, combine, createEvent, createEffect\} from 'effector'
			import \{useStore\} from 'effector-react'
			
			import \{render, act, renderHTML\} from 'effector/fixtures/react'
			
			test('rfc1 example implementation', async () => \{
			  const fnWait = jest.fn()
			  const fnClick = jest.fn()
			  const clickEpicFn = jest.fn()
			
			  const inputText = createEvent()
			  const click = createEvent()
			  const resetForm = createEvent()
			  const increment = createEvent()
			
			  const counter = createStore(0)
			  const text = createStore('')
			  const store = combine(\{counter, text\})
			
			  const waitIncrement = createEffect(\{
			    async handler() \{
			      await new Promise(rs => \{
			        const unsub = increment.watch(() => \{
			          unsub()
			          rs()
			        \})
			      \})
			    \},
			  \})
			  click.watch(() => waitIncrement())
			  waitIncrement.done.watch(fnWait)
			  counter.reset(resetForm)
			  text.reset(resetForm)
			  const trimmedInput = inputText.map(text => text.trim())
			
			  text.on(trimmedInput, (_, text) => text)
			
			  counter.watch(() => \{\})
			  counter.on(increment, state => state + 1)
			  click.watch(() => \{\})
			  const click\$ = from(click).tap(clickEpicFn)
			
			  click\$.observe(() => \{\})
			  click\$.observe(async () => \{
			    await new Promise(rs => setTimeout(rs, 500))
			    fnClick()
			    increment()
			  \})
			  store.watch(() => \{\})
			
			  const messageStore = store.map((\{counter\}) => \`Clicked: \$\{counter\} times\`)
			  const ClickedTimes = () => \{
			    const state = useStore(messageStore)
			    expect(state).not.toBe(text)
			    expect(typeof state).toBe('string')
			    return <span>\{state\}</span>
			  \}
			  const CurrentText = (\{prefix\}) => \{
			    const \{text\} = useStore(store)
			    return (
			      <div>
			        <p>\{prefix\}</p>
			        <p>\{text\}</p>
			      </div>
			    )
			  \}
			
			  const App = () => (
			    <>
			      <ClickedTimes />
			      <CurrentText prefix="Current text: " />
			    </>
			  )
			  await expect(
			    (async () => \{
			      await render(<ClickedTimes />)
			      await render(<CurrentText prefix="Current text: " />)
			      await render(<App />)
			    \})(),
			  ).resolves.not.toThrow()
			  expect(await renderHTML(<ClickedTimes />)).toMatchInlineSnapshot(\`
			    <span>
			      Clicked: 0 times
			    </span>
			  \`)
			  expect(await renderHTML(<CurrentText prefix="Current text: " />))
			    .toMatchInlineSnapshot(\`
			    <div>
			      <p>
			        Current text: 
			      </p>
			      <p />
			    </div>
			  \`)
			  expect(await renderHTML(<App />)).toMatchInlineSnapshot(\`
			    <span>
			      Clicked: 0 times
			    </span>
			  \`)
			  expect(fnWait).not.toHaveBeenCalled()
			  expect(fnClick).not.toHaveBeenCalled()
			  await act(async () => \{
			    click()
			    click()
			    expect(fnWait).not.toHaveBeenCalled()
			    await new Promise(_ => setTimeout(_, 2200))
			  \})
			  expect(counter.getState()).toBe(2)
			  expect(fnWait).toHaveBeenCalledTimes(2)
			  expect(fnClick).toHaveBeenCalledTimes(2)
			  expect(store.getState()).toMatchObject(\{
			    counter: 2,
			    text: '',
			  \})
			  expect(await renderHTML(<App />)).toMatchInlineSnapshot(\`
			    <span>
			      Clicked: 2 times
			    </span>
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\rfc1.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\scopes.test.tsx', () => {
        const sourceCode = `
			import React from 'react'
			//@ts-ignore
			import \{render, container, act\} from 'effector/fixtures/react'
			import \{argumentHistory\} from 'effector/fixtures'
			import \{
			  createDomain,
			  createEvent,
			  createStore,
			  createEffect,
			  forward,
			  sample,
			  attach,
			  combine,
			  fork,
			  allSettled,
			  serialize,
			  hydrate,
			  Scope,
			\} from 'effector'
			import \{
			  Provider,
			  useStore,
			  useList,
			  useGate,
			  useEvent,
			  useStoreMap,
			  createGate,
			  useUnit,
			\} from 'effector-react/scope'
			
			async function request(url: string) \{
			  const users: Record<string, \{name: string; friends: string[]\}> = \{
			    alice: \{
			      name: 'alice',
			      friends: ['bob', 'carol'],
			    \},
			    bob: \{
			      name: 'bob',
			      friends: ['alice'],
			    \},
			    carol: \{
			      name: 'carol',
			      friends: ['alice'],
			    \},
			    charlie: \{
			      name: 'charlie',
			      friends: [],
			    \},
			  \}
			  const user = url.replace('https://ssr.effector.dev/api/', '')
			  const result = users[user]
			  await new Promise(rs => setTimeout(rs, 30))
			  return result
			\}
			
			it('works', async () => \{
			  const indirectCallFn = jest.fn()
			
			  const start = createEvent<string>()
			  const indirectCall = createEvent()
			  const sendStats = createEffect(async (user: any) => \{
			    await new Promise(resolve => \{
			      // let bob loading longer
			      setTimeout(resolve, user === 'bob' ? 500 : 100)
			    \})
			  \})
			
			  const fetchUser = createEffect(async (user: any) => \{
			    return request('https://ssr.effector.dev/api/' + user)
			  \})
			  //assume that calling start() will trigger some effects
			  forward(\{
			    from: start,
			    to: fetchUser,
			  \})
			
			  const user = createStore('guest', \{sid: 'user'\})
			  const friends = createStore<string[]>([], \{sid: 'friends'\})
			  const friendsTotal = friends.map(list => list.length)
			
			  user.on(fetchUser.doneData, (_, result) => result.name)
			  friends.on(fetchUser.doneData, (_, result) => result.friends)
			
			  sample(\{
			    source: user,
			    clock: fetchUser.done,
			    target: sendStats,
			  \})
			  sample(\{
			    source: user,
			    clock: indirectCall,
			  \}).watch(indirectCallFn)
			
			  sendStats.done.watch(() => \{
			    indirectCall()
			  \})
			
			  const aliceScope = fork()
			  const bobScope = fork()
			  const carolScope = fork()
			  await Promise.all([
			    allSettled(start, \{
			      scope: aliceScope,
			      params: 'alice',
			    \}),
			    allSettled(start, \{
			      scope: bobScope,
			      params: 'bob',
			    \}),
			    allSettled(start, \{
			      scope: carolScope,
			      params: 'carol',
			    \}),
			  ])
			  const User = () => <h2>\{useStore(user)\}</h2>
			  const Friends = () => useList(friends, friend => <li>\{friend\}</li>)
			  const Total = () => <small>Total: \{useStore(friendsTotal)\}</small>
			
			  const App = (\{root\}: \{root: Scope\}) => (
			    <Provider value=\{root\}>
			      <User />
			      <b>Friends:</b>
			      <ol>
			        <Friends />
			      </ol>
			      <Total />
			    </Provider>
			  )
			
			  await render(<App root=\{bobScope\} />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <h2>
			      bob
			    </h2>
			  \`)
			
			  expect(serialize(aliceScope)).toMatchInlineSnapshot(\`
			    Object \{
			      "friends": Array [
			        "bob",
			        "carol",
			      ],
			      "user": "alice",
			    \}
			  \`)
			  expect(serialize(bobScope)).toMatchInlineSnapshot(\`
			    Object \{
			      "friends": Array [
			        "alice",
			      ],
			      "user": "bob",
			    \}
			  \`)
			  expect(indirectCallFn).toBeCalled()
			\})
			
			test('attach support', async () => \{
			  const indirectCallFn = jest.fn()
			
			  const start = createEvent<string>()
			  const indirectCall = createEvent()
			  const sendStats = createEffect(async (user: string) => \{
			    await new Promise(resolve => \{
			      // let bob loading longer
			      setTimeout(resolve, user === 'bob' ? 500 : 100)
			    \})
			  \})
			
			  const baseUrl = createStore('https://ssr.effector.dev/api')
			
			  const fetchJson = createEffect<string, any>(async url => await request(url))
			
			  const fetchUser = attach(\{
			    source: \{baseUrl\},
			    effect: fetchJson,
			    mapParams: (user, \{baseUrl\}) => \`\$\{baseUrl\}/\$\{user\}\`,
			  \})
			
			  //assume that calling start() will trigger some effects
			  forward(\{
			    from: start,
			    to: fetchUser,
			  \})
			
			  const user = createStore('guest', \{sid: 'user'\})
			  const friends = createStore([], \{sid: 'friends'\})
			  const friendsTotal = friends.map(list => list.length)
			
			  user.on(fetchUser.doneData, (_, result) => result.name)
			  friends.on(fetchUser.doneData, (_, result) => result.friends)
			
			  sample(\{
			    source: user,
			    clock: fetchUser.done,
			    target: sendStats,
			  \})
			  sample(\{
			    source: user,
			    clock: indirectCall,
			  \}).watch(indirectCallFn)
			
			  sendStats.done.watch(() => \{
			    indirectCall()
			  \})
			
			  const aliceScope = fork()
			  const bobScope = fork()
			  const carolScope = fork()
			  await Promise.all([
			    allSettled(start, \{
			      scope: aliceScope,
			      params: 'alice',
			    \}),
			    allSettled(start, \{
			      scope: bobScope,
			      params: 'bob',
			    \}),
			    allSettled(start, \{
			      scope: carolScope,
			      params: 'carol',
			    \}),
			  ])
			  const User = () => <h2>\{useStore(user)\}</h2>
			  const Friends = () => useList(friends, friend => <li>\{friend\}</li>)
			  const Total = () => <small>Total: \{useStore(friendsTotal)\}</small>
			
			  const App = (\{root\}: \{root: Scope\}) => (
			    <Provider value=\{root\}>
			      <User />
			      <b>Friends:</b>
			      <ol>
			        <Friends />
			      </ol>
			      <Total />
			    </Provider>
			  )
			
			  await render(<App root=\{bobScope\} />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <h2>
			      bob
			    </h2>
			  \`)
			  expect(serialize(aliceScope)).toMatchInlineSnapshot(\`
			    Object \{
			      "friends": Array [
			        "bob",
			        "carol",
			      ],
			      "user": "alice",
			    \}
			  \`)
			  expect(serialize(bobScope)).toMatchInlineSnapshot(\`
			    Object \{
			      "friends": Array [
			        "alice",
			      ],
			      "user": "bob",
			    \}
			  \`)
			  expect(indirectCallFn).toBeCalled()
			\})
			
			test('computed values support', async () => \{
			  const app = createDomain()
			
			  const fetchUser = app.createEffect<string, \{name: string; friends: string[]\}>(
			    async user => await request(\`https://ssr.effector.dev/api/\$\{user\}\`),
			  )
			  const start = app.createEvent<string>()
			  forward(\{from: start, to: fetchUser\})
			  const name = app
			    .createStore('guest')
			    .on(fetchUser.done, (_, \{result\}) => result.name)
			
			  const friends = app
			    .createStore<string[]>([])
			    .on(fetchUser.done, (_, \{result\}) => result.friends)
			  const friendsTotal = friends.map(list => list.length)
			
			  const Total = () => <small>Total:\{useStore(friendsTotal)\}</small>
			  const User = () => <b>User:\{useStore(name)\}</b>
			  const App = (\{root\}: \{root: Scope\}) => (
			    <Provider value=\{root\}>
			      <section>
			        <User />
			        <Total />
			      </section>
			    </Provider>
			  )
			
			  const serverScope = fork(app)
			  await allSettled(start, \{
			    scope: serverScope,
			    params: 'alice',
			  \})
			  const serialized = serialize(serverScope)
			
			  hydrate(app, \{
			    values: serialized,
			  \})
			
			  const clientScope = fork(app)
			
			  await render(<App root=\{clientScope\} />)
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <section>
			      <b>
			        User:
			        alice
			      </b>
			      <small>
			        Total:
			        2
			      </small>
			    </section>
			  \`)
			\})
			
			test('useGate support', async () => \{
			  const getMessagesFx = createEffect<\{chatId: string\}, string[]>(
			    async (\{chatId\}) => \{
			      return ['hi bob!', 'Hello, Alice']
			    \},
			  )
			
			  const messagesAmount = createStore(0).on(
			    getMessagesFx.doneData,
			    (_, messages) => messages.length,
			  )
			
			  const activeChatGate = createGate<\{chatId: string\}>(\{\})
			
			  forward(\{from: activeChatGate.open, to: getMessagesFx\})
			
			  const ChatPage = (\{chatId\}: \{chatId: string\}) => \{
			    useGate(activeChatGate, \{chatId\})
			    return (
			      <div>
			        <header>Chat:\{chatId\}</header>
			        <p>Messages total:\{useStore(messagesAmount)\}</p>
			      </div>
			    )
			  \}
			  const App = (\{root\}: \{root: Scope\}) => (
			    <Provider value=\{root\}>
			      <ChatPage chatId="chat01" />
			    </Provider>
			  )
			
			  const serverScope = fork()
			  await render(<App root=\{serverScope\} />)
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <header>
			        Chat:
			        chat01
			      </header>
			      <p>
			        Messages total:
			        2
			      </p>
			    </div>
			  \`)
			
			  const clientScope = fork(\{
			    values: serialize(serverScope),
			  \})
			
			  await render(<App root=\{clientScope\} />)
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <header>
			        Chat:
			        chat01
			      </header>
			      <p>
			        Messages total:
			        2
			      </p>
			    </div>
			  \`)
			\})
			
			test('allSettled effect calls', async () => \{
			  const fn = jest.fn()
			
			  const fetchUser = createEffect<string, \{name: string; friends: string[]\}>(
			    async user => await request(\`https://ssr.effector.dev/api/\$\{user\}\`),
			  )
			
			  const serverScope = fork()
			
			  await allSettled(fetchUser, \{
			    scope: serverScope,
			    params: 'alice',
			  \})
			    .then(fn)
			    .catch(err => \{
			      console.error(err)
			    \})
			  expect(fn).toBeCalled()
			\})
			describe('useEvent', () => \{
			  test('useEvent and effect calls', async () => \{
			    const inc = createEvent()
			    const count = createStore(0).on(inc, x => x + 1)
			    const fx = createEffect(async () => \{
			      inc()
			    \})
			    const scope = fork()
			    const App = () => \{
			      const fxe = useEvent(fx)
			      const x = useStore(count)
			      return (
			        <div>
			          <button id="btn" onClick=\{() => fxe()\}>
			            clicked-\{x\}-times
			          </button>
			        </div>
			      )
			    \}
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          clicked-
			          0
			          -times
			        </button>
			      </div>
			    \`)
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          clicked-
			          1
			          -times
			        </button>
			      </div>
			    \`)
			    expect(count.getState()).toBe(0)
			    expect(scope.getState(count)).toBe(1)
			  \})
			  test('useEvent function return value', async () => \{
			    const fn = jest.fn()
			    const fx = createEffect(() => 'ok')
			    const scope = fork()
			    const App = () => \{
			      const fxe = useEvent(fx)
			      return (
			        <div>
			          <button id="btn" onClick=\{() => fxe().then(fn)\}>
			            click
			          </button>
			        </div>
			      )
			    \}
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(argumentHistory(fn)).toEqual(['ok'])
			  \})
			
			  test('object in useEvent', async () => \{
			    const inc = createEvent()
			    const dec = createEvent()
			    const fx = createEffect(async () => 100)
			    const count = createStore(0)
			      .on(inc, x => x + 1)
			      .on(dec, x => x - 1)
			      .on(fx.doneData, (x, v) => x + v)
			    const scope = fork()
			    const App = () => \{
			      const hndl = useEvent(\{fx, inc, dec\})
			      const x = useStore(count)
			      return (
			        <div>
			          <span id="value">current value:\{x\}</span>
			          <button id="fx" onClick=\{() => hndl.fx()\}>
			            fx
			          </button>
			          <button id="inc" onClick=\{() => hndl.inc()\}>
			            inc
			          </button>
			          <button id="dec" onClick=\{() => hndl.dec()\}>
			            dec
			          </button>
			        </div>
			      )
			    \}
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          0
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    await act(async () => \{
			      container.firstChild.querySelector('#fx').click()
			      container.firstChild.querySelector('#inc').click()
			      container.firstChild.querySelector('#inc').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          102
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    await act(async () => \{
			      container.firstChild.querySelector('#dec').click()
			    \})
			    expect(count.getState()).toBe(0)
			    expect(scope.getState(count)).toBe(101)
			  \})
			
			  test('array in useEvent', async () => \{
			    const inc = createEvent()
			    const dec = createEvent()
			    const fx = createEffect(async () => 100)
			    const count = createStore(0)
			      .on(inc, x => x + 1)
			      .on(dec, x => x - 1)
			      .on(fx.doneData, (x, v) => x + v)
			    const scope = fork()
			    const App = () => \{
			      const [a, b, c] = useEvent([fx, inc, dec])
			      const x = useStore(count)
			      return (
			        <div>
			          <span id="value">current value:\{x\}</span>
			          <button id="fx" onClick=\{() => a()\}>
			            fx
			          </button>
			          <button id="inc" onClick=\{() => b()\}>
			            inc
			          </button>
			          <button id="dec" onClick=\{() => c()\}>
			            dec
			          </button>
			        </div>
			      )
			    \}
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          0
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    await act(async () => \{
			      container.firstChild.querySelector('#fx').click()
			      container.firstChild.querySelector('#inc').click()
			      container.firstChild.querySelector('#inc').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          102
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    await act(async () => \{
			      container.firstChild.querySelector('#dec').click()
			    \})
			    expect(count.getState()).toBe(0)
			    expect(scope.getState(count)).toBe(101)
			  \})
			\})
			describe('useStoreMap', () => \{
			  it('should render', async () => \{
			    const userRemove = createEvent<string>()
			    const userAgeChange = createEvent<\{nickname: string; age: number\}>()
			    const \$users = createStore<Record<string, \{age: number; name: string\}>>(\{
			      alex: \{age: 20, name: 'Alex'\},
			      john: \{age: 30, name: 'John'\},
			    \})
			    const \$userNames = createStore(['alex', 'john'])
			
			    \$userNames.on(userRemove, (list, username) =>
			      list.filter(item => item !== username),
			    )
			    \$users
			      .on(userRemove, (users, nickname) => \{
			        const upd = \{...users\}
			        delete upd[nickname]
			        return upd
			      \})
			      .on(userAgeChange, (users, \{nickname, age\}) => (\{
			        ...users,
			        [nickname]: \{...users[nickname], age\},
			      \}))
			
			    const Card = (\{nickname\}: \{nickname: string\}) => \{
			      const \{name, age\} = useStoreMap(\{
			        store: \$users,
			        keys: [nickname],
			        fn: (users, [nickname]) => users[nickname],
			      \})
			      return (
			        <li>
			          \{name\}: \{age\}
			        </li>
			      )
			    \}
			
			    const Cards = () => (
			      <ul>
			        \{useList(\$userNames, name => (
			          <Card nickname=\{name\} key=\{name\} />
			        ))\}
			      </ul>
			    )
			
			    const App = (\{root\}: \{root: Scope\}) => (
			      <Provider value=\{root\}>
			        <Cards />
			      </Provider>
			    )
			
			    const scope = fork()
			
			    await render(<App root=\{scope\} />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          Alex
			          : 
			          20
			        </li>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			    await act(async () => \{
			      await allSettled(userAgeChange, \{
			        scope,
			        params: \{nickname: 'alex', age: 21\},
			      \})
			    \})
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          Alex
			          : 
			          21
			        </li>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			    await act(async () => \{
			      await allSettled(userRemove, \{scope, params: 'alex'\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			  \})
			  it('should support domains', async () => \{
			    const app = createDomain()
			    const toggle = app.createEvent()
			    const inc = app.createEvent()
			    const \$show = app
			      .createStore('A')
			      .on(toggle, current => (current === 'A' ? 'B' : 'A'))
			    const \$a = app.createStore(10).on(inc, x => x + 1)
			    const \$b = app.createStore(20).on(inc, x => x + 1)
			    const View = () => \{
			      const current = useStore(\$show)
			      const selectedStore = current === 'A' ? \$a : \$b
			      const value = useStoreMap(\{
			        store: selectedStore,
			        keys: [selectedStore],
			        fn: x => x,
			      \})
			      return <div>\{value\}</div>
			    \}
			    const App = (\{root\}: \{root: Scope\}) => (
			      <Provider value=\{root\}>
			        <View />
			      </Provider>
			    )
			
			    const scope = fork(app)
			    await render(<App root=\{scope\} />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        10
			      </div>
			    \`)
			    await act(async () => \{
			      await allSettled(inc, \{scope\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        11
			      </div>
			    \`)
			    await act(async () => \{
			      await allSettled(toggle, \{scope\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        21
			      </div>
			    \`)
			    await act(async () => \{
			      await allSettled(inc, \{scope\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        22
			      </div>
			    \`)
			    await act(async () => \{
			      await allSettled(toggle, \{scope\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        12
			      </div>
			    \`)
			  \})
			  test('updateFilter support', async () => \{
			    const setValue = createEvent<number>()
			    const \$store = createStore(0).on(setValue, (_, x) => x)
			
			    const View = () => \{
			      const x = useStoreMap(\{
			        store: \$store,
			        keys: [],
			        fn: x => x,
			        updateFilter: (update: number, current: number) => update % 2 === 0,
			      \})
			      return <div>\{x\}</div>
			    \}
			    const App = (\{root\}: \{root: Scope\}) => (
			      <Provider value=\{root\}>
			        <View />
			      </Provider>
			    )
			    const scope = fork()
			
			    await render(<App root=\{scope\} />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        0
			      </div>
			    \`)
			    await act(async () => \{
			      await allSettled(setValue, \{scope, params: 2\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        2
			      </div>
			    \`)
			    await act(async () => \{
			      await allSettled(setValue, \{scope, params: 3\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        2
			      </div>
			    \`)
			  \})
			\})
			
			describe('behavior on scope changes', () => \{
			  test('useStore should not stale', async () => \{
			    const inc = createEvent()
			    const \$store = createStore(0).on(inc, x => x + 1)
			    const Count = () => <p>\{useStore(\$store)\}</p>
			    const Inc = () => \{
			      const boundInc = useEvent(inc)
			      return (
			        <button id="click" onClick=\{() => boundInc()\}>
			          click
			        </button>
			      )
			    \}
			    const App = (\{scope\}: \{scope: Scope\}) => (
			      <Provider value=\{scope\}>
			        <div>
			          <Count />
			          <Inc />
			        </div>
			      </Provider>
			    )
			    const firstScope = fork()
			    const secondScope = fork(\{values: [[\$store, 2]]\})
			
			    await render(<App scope=\{firstScope\} />)
			    await render(<App scope=\{secondScope\} />)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#click').click()
			    \})
			
			    expect(secondScope.getState(\$store)).toBe(3)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <p>
			          3
			        </p>
			        <button
			          id="click"
			        >
			          click
			        </button>
			      </div>
			    \`)
			  \})
			  test('useStoreMap should not stale', async () => \{
			    const inc = createEvent()
			    const \$store = createStore(0).on(inc, x => x + 1)
			    const Count = () => \{
			      const value = useStoreMap(\$store, n => n)
			      return <p>\{value\}</p>
			    \}
			    const Inc = () => \{
			      const boundInc = useEvent(inc)
			      return (
			        <button id="click" onClick=\{() => boundInc()\}>
			          click
			        </button>
			      )
			    \}
			    const App = (\{scope\}: \{scope: Scope\}) => (
			      <Provider value=\{scope\}>
			        <div>
			          <Count />
			          <Inc />
			        </div>
			      </Provider>
			    )
			    const firstScope = fork()
			    const secondScope = fork(\{values: [[\$store, 2]]\})
			
			    await render(<App scope=\{firstScope\} />)
			    await render(<App scope=\{secondScope\} />)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#click').click()
			    \})
			
			    expect(secondScope.getState(\$store)).toBe(3)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <p>
			          3
			        </p>
			        <button
			          id="click"
			        >
			          click
			        </button>
			      </div>
			    \`)
			  \})
			  test('useList should not stale', async () => \{
			    const inc = createEvent()
			    const \$store = createStore([0]).on(inc, ([x]) => [x + 1])
			    const Count = () => useList(\$store, value => <p>\{value\}</p>)
			    const Inc = () => \{
			      const boundInc = useEvent(inc)
			      return (
			        <button id="click" onClick=\{() => boundInc()\}>
			          click
			        </button>
			      )
			    \}
			    const App = (\{scope\}: \{scope: Scope\}) => (
			      <Provider value=\{scope\}>
			        <div>
			          <Count />
			          <Inc />
			        </div>
			      </Provider>
			    )
			    const firstScope = fork()
			    const secondScope = fork(\{values: [[\$store, [2]]]\})
			
			    await render(<App scope=\{firstScope\} />)
			    await render(<App scope=\{secondScope\} />)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#click').click()
			    \})
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <p>
			          3
			        </p>
			        <button
			          id="click"
			        >
			          click
			        </button>
			      </div>
			    \`)
			  \})
			  test('useUnit should not stale', async () => \{
			    const inc = createEvent()
			    const \$store = createStore(0).on(inc, x => x + 1)
			    const Count = () => \{
			      const value = useUnit(\$store)
			      return <p>\{value\}</p>
			    \}
			    const Inc = () => \{
			      const boundInc = useUnit(inc)
			      return (
			        <button id="click" onClick=\{() => boundInc()\}>
			          click
			        </button>
			      )
			    \}
			    const App = (\{scope\}: \{scope: Scope\}) => (
			      <Provider value=\{scope\}>
			        <div>
			          <Count />
			          <Inc />
			        </div>
			      </Provider>
			    )
			    const firstScope = fork()
			    const secondScope = fork(\{values: [[\$store, 2]]\})
			
			    await render(<App scope=\{firstScope\} />)
			    await render(<App scope=\{secondScope\} />)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#click').click()
			    \})
			
			    expect(secondScope.getState(\$store)).toBe(3)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <p>
			          3
			        </p>
			        <button
			          id="click"
			        >
			          click
			        </button>
			      </div>
			    \`)
			  \})
			\})
			
			test('useUnit should bind stores to scope', async () => \{
			  const \$a = createStore(0)
			
			  const A = () => \{
			    const \{a\} = useUnit(\{a: \$a\})
			    return a
			  \}
			  const App = (\{scope\}: \{scope: Scope\}) => (
			    <Provider value=\{scope\}>
			      <div>
			        <A />
			      </div>
			    </Provider>
			  )
			
			  const scopeA = fork(\{
			    values: [[\$a, 42]],
			  \})
			  const scopeB = fork()
			
			  await render(<App scope=\{scopeA\} />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      42
			    </div>
			  \`)
			
			  await render(<App scope=\{scopeB\} />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      0
			    </div>
			  \`)
			\})
			
			test('useUnit should bind units to scope', async () => \{
			  const up = createEvent()
			  const \$a = createStore(0).on(up, s => s + 1)
			
			  const A = (\{id\}: \{id: string\}) => \{
			    const \{a, inc\} = useUnit(\{a: \$a, inc: up\})
			
			    return (
			      <button id=\{id\} onClick=\{() => inc()\}>
			        \{a\}
			      </button>
			    )
			  \}
			  const App = (\{scope, id\}: \{scope: Scope; id: string\}) => (
			    <Provider value=\{scope\}>
			      <A id=\{id\} />
			    </Provider>
			  )
			  const Page = (\{A, B\}: \{A: Scope; B: Scope\}) => \{
			    return (
			      <div>
			        <App scope=\{A\} id="a" />
			        <App scope=\{B\} id="b" />
			      </div>
			    )
			  \}
			
			  const VALUE = 42
			
			  const scopeA = fork(\{
			    values: [[\$a, VALUE]],
			  \})
			  const scopeB = fork()
			
			  await render(<Page A=\{scopeA\} B=\{scopeB\} />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <button
			        id="a"
			      >
			        42
			      </button>
			      <button
			        id="b"
			      >
			        0
			      </button>
			    </div>
			  \`)
			
			  await act(async () => \{
			    container.firstChild.querySelector('#a').click()
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <button
			        id="a"
			      >
			        43
			      </button>
			      <button
			        id="b"
			      >
			        0
			      </button>
			    </div>
			  \`)
			  expect(scopeA.getState(\$a)).toEqual(VALUE + 1)
			  expect(scopeB.getState(\$a)).toEqual(0)
			  expect(\$a.getState()).toEqual(0)
			\})
			
			describe('hooks throw errors, if Provider is not found', () => \{
			  test('useUnit from \`effector-react/scope\` throws error, if no Provider', () => \{
			    const \$a = createStore(42)
			
			    const View = () => \{
			      const a = useUnit(\$a)
			
			      return <div>\{a\}</div>
			    \}
			
			    expect(() => render(<View />)).rejects.toThrow(
			      'No scope found, consider adding <Provider> to app root',
			    )
			  \})
			
			  test('useStore from \`effector-react/scope\` throws error, if no Provider', () => \{
			    const \$a = createStore(42)
			
			    const View = () => \{
			      const a = useStore(\$a)
			
			      return <div>\{a\}</div>
			    \}
			
			    expect(() => render(<View />)).rejects.toThrow(
			      'No scope found, consider adding <Provider> to app root',
			    )
			  \})
			
			  test('useEvent from \`effector-react/scope\` throws error, if no Provider', () => \{
			    const ev = createEvent()
			
			    const View = () => \{
			      const a = useEvent(ev)
			
			      return <div onClick=\{a\}></div>
			    \}
			
			    expect(() => render(<View />)).rejects.toThrow(
			      'No scope found, consider adding <Provider> to app root',
			    )
			  \})
			
			  test('useStoreMap from \`effector-react/scope\` throws error, if no Provider', () => \{
			    const \$a = createStore(42)
			
			    const View = () => \{
			      const a = useStoreMap(\{
			        store: \$a,
			        keys: [],
			        fn: () => 42,
			        defaultValue: 77,
			      \})
			
			      return <div>\{a\}</div>
			    \}
			
			    expect(() => render(<View />)).rejects.toThrow(
			      'No scope found, consider adding <Provider> to app root',
			    )
			  \})
			
			  test('useList from \`effector-react/scope\` throws error, if no Provider', () => \{
			    const \$a = createStore([42])
			
			    const View = () => \{
			      const a = useList(\$a, \{
			        fn: () => <div>42</div>,
			      \})
			
			      return <div>\{a\}</div>
			    \}
			
			    expect(() => render(<View />)).rejects.toThrow(
			      'No scope found, consider adding <Provider> to app root',
			    )
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\scopes.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(23)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\shapeProtocol.test.tsx', () => {
        const sourceCode = `
			import React from 'react'
			import \{allSettled, createEvent, createStore, fork, sample\} from 'effector'
			import \{useUnit, Provider\} from 'effector-react'
			//@ts-expect-error
			import \{render, container, act\} from 'effector/fixtures/react'
			
			describe('useUnit uses @@unitShape', () => \{
			  it('resolves custom shape of stores', async () => \{
			    const \{entity, internals\} = createCustomEntity()
			
			    const scope = fork()
			
			    const View = () => \{
			      const \{someStore\} = useUnit(entity)
			
			      return <p>\{someStore\}</p>
			    \}
			
			    await render(
			      <Provider value=\{scope\}>
			        <View />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <p>
			        initial value
			      </p>
			    \`)
			
			    await allSettled(internals.someEvent, \{scope, params: 'new value'\})
			
			    await render(
			      <Provider value=\{scope\}>
			        <View />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <p>
			        new value
			      </p>
			    \`)
			  \})
			
			  it('resolves binds events from shape correctly', async () => \{
			    const \{entity\} = createCustomEntity()
			
			    const scope = fork()
			
			    const View = () => \{
			      const \{someStore, someEvent\} = useUnit(entity)
			
			      return (
			        <div>
			          <p>\{someStore\}</p>
			          <button id="btn" onClick=\{() => someEvent('value from ui')\}>
			            click me
			          </button>
			        </div>
			      )
			    \}
			
			    await render(
			      <Provider value=\{scope\}>
			        <View />
			      </Provider>,
			    )
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <p>
			          value from ui
			        </p>
			        <button
			          id="btn"
			        >
			          click me
			        </button>
			      </div>
			    \`)
			  \})
			\})
			
			function createCustomEntity() \{
			  const \$someStore = createStore('initial value')
			  const someEvent = createEvent<string>()
			
			  sample(\{clock: someEvent, fn: value => value, target: \$someStore\})
			
			  return \{
			    entity: \{
			      '@@unitShape': () => \{
			        return \{someStore: \$someStore, someEvent\}
			      \},
			    \},
			    internals: \{
			      \$someStore,
			      someEvent,
			    \},
			  \}
			\}
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\shapeProtocol.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\useEvent.test.tsx', () => {
        const sourceCode = `
			import React from 'react'
			//@ts-ignore
			import \{render, container, act\} from 'effector/fixtures/react'
			import \{createEvent, fork, createWatch\} from 'effector'
			import \{Provider, useEvent\} from 'effector-react'
			
			describe('useEvent', () => \{
			  test('bind event to scope if Provider is used', async () => \{
			    const event = createEvent()
			
			    const scope = fork()
			
			    const watcher = jest.fn()
			
			    createWatch(\{unit: event, fn: watcher, scope\})
			
			    function App() \{
			      const handler = useEvent(event)
			
			      return <button onClick=\{handler\}>Click me</button>
			    \}
			
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			
			    await act(async () => \{
			      container.firstChild?.click()
			    \})
			
			    expect(watcher).toHaveBeenCalledTimes(1)
			  \})
			
			  test('throw error if Provider is not used with forceScope', async () => \{
			    const event = createEvent()
			
			    function App() \{
			      const handler = useEvent(event, \{forceScope: true\})
			
			      return <button onClick=\{handler\}>Click me</button>
			    \}
			
			    expect(() => render(<App />)).rejects.toMatchInlineSnapshot(
			      \`[Error: No scope found, consider adding <Provider> to app root]\`,
			    )
			  \})
			
			  test('return event as is for no Provider', async () => \{
			    const event = createEvent()
			
			    const watcher = jest.fn()
			
			    createWatch(\{unit: event, fn: watcher\})
			
			    function App() \{
			      const handler = useEvent(event)
			
			      return <button onClick=\{handler\}>Click me</button>
			    \}
			
			    await render(<App />)
			
			    await act(async () => \{
			      container.firstChild?.click()
			    \})
			
			    expect(watcher).toHaveBeenCalledTimes(1)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\useEvent.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\useList.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			//@ts-expect-error
			import \{render, container, act\} from 'effector/fixtures/react'
			
			import \{
			  createStore,
			  createEvent,
			  restore,
			  createApi,
			  createEffect,
			  fork,
			\} from 'effector'
			
			import \{Provider, useList, useStore\} from 'effector-react'
			import \{argumentHistory\} from 'effector/fixtures'
			
			it('should render store items', async () => \{
			  const list = createStore(['foo', 'bar', 'baz'])
			
			  const List = () => (
			    <div>
			      \{useList(list, (item, index) => (
			        <div>
			          \{item\}
			          \{index\}
			        </div>
			      ))\}
			    </div>
			  )
			
			  await render(<List />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        foo
			        0
			      </div>
			      <div>
			        bar
			        1
			      </div>
			      <div>
			        baz
			        2
			      </div>
			    </div>
			  \`)
			\})
			
			it('should handle updates without dull re-renders', async () => \{
			  const fn = jest.fn()
			  const update = createEvent<\{key: number; value: string\}>()
			  const list = createStore(['foo', 'bar', 'baz']).on(
			    update,
			    (list, \{key, value\}) => \{
			      const upd = [...list]
			      upd[key] = value
			      return upd
			    \},
			  )
			
			  const List = () => (
			    <div>
			      \{useList(list, (item, index) => \{
			        fn(item)
			        return (
			          <div>
			            \{item\}
			            \{index\}
			          </div>
			        )
			      \})\}
			    </div>
			  )
			  await render(<List />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        foo
			        0
			      </div>
			      <div>
			        bar
			        1
			      </div>
			      <div>
			        baz
			        2
			      </div>
			    </div>
			  \`)
			  expect(fn).toBeCalledTimes(3)
			  await act(async () => \{
			    update(\{key: 1, value: 'update'\})
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        foo
			        0
			      </div>
			      <div>
			        update
			        1
			      </div>
			      <div>
			        baz
			        2
			      </div>
			    </div>
			  \`)
			  expect(fn).toBeCalledTimes(4)
			\})
			
			it('should handle inserts without dull re-renders', async () => \{
			  const fn = jest.fn()
			  const insert = createEvent<string>()
			  const list = createStore(['foo', 'bar', 'baz']).on(insert, (list, value) => [
			    ...list,
			    value,
			  ])
			
			  const List = () => (
			    <div>
			      \{useList(list, (item, index) => \{
			        fn(item)
			        return (
			          <div>
			            \{item\}
			            \{index\}
			          </div>
			        )
			      \})\}
			    </div>
			  )
			
			  await render(<List />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        foo
			        0
			      </div>
			      <div>
			        bar
			        1
			      </div>
			      <div>
			        baz
			        2
			      </div>
			    </div>
			  \`)
			  expect(fn).toBeCalledTimes(3)
			  await act(async () => \{
			    insert('update')
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        foo
			        0
			      </div>
			      <div>
			        bar
			        1
			      </div>
			      <div>
			        baz
			        2
			      </div>
			      <div>
			        update
			        3
			      </div>
			    </div>
			  \`)
			  expect(fn).toBeCalledTimes(4)
			\})
			
			it('should update when keys are changed', async () => \{
			  const changeDependency = createEvent<string>()
			  const list = createStore(['foo', 'bar', 'baz'])
			  const dependency = restore(changeDependency, 'dep')
			
			  const List = () => \{
			    const dep = useStore(dependency)
			    return (
			      <div>
			        \{useList(list, \{
			          keys: [dep],
			          fn: item => (
			            <div>
			              \{item\} \{dep\}
			            </div>
			          ),
			        \})\}
			      </div>
			    )
			  \}
			
			  await render(<List />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        foo
			         
			        dep
			      </div>
			      <div>
			        bar
			         
			        dep
			      </div>
			      <div>
			        baz
			         
			        dep
			      </div>
			    </div>
			  \`)
			  await act(async () => \{
			    changeDependency('changed')
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        foo
			         
			        changed
			      </div>
			      <div>
			        bar
			         
			        changed
			      </div>
			      <div>
			        baz
			         
			        changed
			      </div>
			    </div>
			  \`)
			\})
			
			describe('zombie childrens are not allowed', () => \{
			  test('fast remount', async () => \{
			    const fn = jest.fn()
			    const members = createStore([\{name: 'alice'\}, \{name: 'bob'\}])
			    const \{removeMember, addMember\} = createApi(members, \{
			      addMember: (list, name: string) => [...list, \{name\}],
			      removeMember: (list, name: string) =>
			        list.filter(item => item.name !== name),
			    \})
			    const sendWelcomeMessage = createEffect(fn)
			
			    const List = () => (
			      <div>
			        \{useList(members, \{
			          getKey: (\{name\}) => name,
			          fn(\{name\}) \{
			            React.useLayoutEffect(() => \{
			              sendWelcomeMessage(name)
			            \}, [])
			            return <div>\{name\}</div>
			          \},
			        \})\}
			      </div>
			    )
			
			    await render(<List />)
			    await act(async () => \{
			      removeMember('bob')
			      addMember('carol')
			      // await 0
			      addMember('bob')
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <div>
			          alice
			        </div>
			        <div>
			          carol
			        </div>
			        <div>
			          bob
			        </div>
			      </div>
			    \`)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "alice",
			        "bob",
			        "carol",
			      ]
			    \`)
			  \})
			\})
			
			test('getKey', async () => \{
			  const fn = jest.fn()
			  const fn2 = jest.fn()
			  const renameUser = createEvent<\{id: number; name: string\}>()
			  const removeUser = createEvent<number>()
			  const sortById = createEvent()
			  const \$members = createStore([
			    \{name: 'alice', id: 1\},
			    \{name: 'bob', id: 3\},
			    \{name: 'carol', id: 2\},
			  ])
			    .on(renameUser, (list, \{id, name\}) =>
			      list.map(e => (e.id === id ? \{id, name\} : e)),
			    )
			    .on(removeUser, (list, id) => list.filter(e => e.id !== id))
			    .on(sortById, list => [...list].sort((a, b) => a.id - b.id))
			
			  const PlainComponent = React.memo(
			    (\{name, id\}: \{name: string; id: number\}) => \{
			      fn2(\{name, id\})
			      return <p>\{name\}</p>
			    \},
			  )
			  const ListPlain = () => (
			    <div>
			      \{useStore(\$members).map((\{name, id\}) => \{
			        return <PlainComponent key=\{id\} name=\{name\} id=\{id\} />
			      \})\}
			    </div>
			  )
			  const List = () => (
			    <div>
			      \{useList(\$members, \{
			        fn(\{name\}, id) \{
			          fn(\{name, id\})
			          return <p>\{name\}</p>
			        \},
			        getKey: e => e.id,
			      \})\}
			    </div>
			  )
			  const App = () => (
			    <>
			      <List />
			      <ListPlain />
			    </>
			  )
			
			  await render(<App />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <p>
			        alice
			      </p>
			      <p>
			        bob
			      </p>
			      <p>
			        carol
			      </p>
			    </div>
			  \`)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			    ]
			  \`)
			  expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			    ]
			  \`)
			  await act(async () => \{
			    sortById()
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <p>
			        alice
			      </p>
			      <p>
			        carol
			      </p>
			      <p>
			        bob
			      </p>
			    </div>
			  \`)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			    ]
			  \`)
			  expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			    ]
			  \`)
			  await act(async () => \{
			    renameUser(\{id: 2, name: 'charlie'\})
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <p>
			        alice
			      </p>
			      <p>
			        charlie
			      </p>
			      <p>
			        bob
			      </p>
			    </div>
			  \`)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			      Object \{
			        "id": 2,
			        "name": "charlie",
			      \},
			    ]
			  \`)
			  expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			      Object \{
			        "id": 2,
			        "name": "charlie",
			      \},
			    ]
			  \`)
			  await act(async () => \{
			    removeUser(2)
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <p>
			        alice
			      </p>
			      <p>
			        bob
			      </p>
			    </div>
			  \`)
			  expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			      Object \{
			        "id": 2,
			        "name": "charlie",
			      \},
			    ]
			  \`)
			  expect(argumentHistory(fn2)).toMatchInlineSnapshot(\`
			    Array [
			      Object \{
			        "id": 1,
			        "name": "alice",
			      \},
			      Object \{
			        "id": 3,
			        "name": "bob",
			      \},
			      Object \{
			        "id": 2,
			        "name": "carol",
			      \},
			      Object \{
			        "id": 2,
			        "name": "charlie",
			      \},
			    ]
			  \`)
			\})
			
			test('placeholder', async () => \{
			  const addItem = createEvent<string>()
			  const \$items = createStore<string[]>([])
			  \$items.on(addItem, (list, item) => [...list, item])
			  const Placeholder = () => <div>No items in list</div>
			  const List = () => (
			    <div>
			      \{useList(\$items, \{
			        fn: item => <div>Item \{item\}</div>,
			        placeholder: <Placeholder />,
			      \})\}
			    </div>
			  )
			  const App = () => (
			    <>
			      <List />
			    </>
			  )
			
			  await render(<App />)
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        No items in list
			      </div>
			    </div>
			  \`)
			  await act(() => \{
			    addItem('foo')
			  \})
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div>
			        Item 
			        foo
			      </div>
			    </div>
			  \`)
			\})
			
			test('get value from scope if it is available', async () => \{
			  const \$store = createStore(['original'])
			
			  const scope = fork(\{values: [[\$store, ['scoped']]]\})
			
			  function App() \{
			    const value = useList(\$store, t => <li>\{t\}</li>)
			
			    return <ol>\{value\}</ol>
			  \}
			
			  await render(
			    <Provider value=\{scope\}>
			      <App />
			    </Provider>,
			  )
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <ol>
			      <li>
			        scoped
			      </li>
			    </ol>
			  \`)
			\})
			
			test('throw error on forceScope if it is not available', async () => \{
			  const \$store = createStore(['original'])
			
			  function App() \{
			    const value = useList(\$store, t => <li>\{t\}</li>, \{forceScope: true\})
			
			    return <ol>\{value\}</ol>
			  \}
			
			  expect(() => render(<App />)).rejects.toMatchInlineSnapshot(
			    \`[Error: No scope found, consider adding <Provider> to app root]\`,
			  )
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\useList.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\useStore.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			//@ts-expect-error
			import \{render, container, act\} from 'effector/fixtures/react'
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  createDomain,
			  Store,
			  Event,
			  restore,
			  fork,
			\} from 'effector'
			import \{Provider, useStore, useStoreMap\} from 'effector-react'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('useStore', () => \{
			  it('should render', async () => \{
			    const store = createStore('foo')
			    const changeText = createEvent<string>()
			    store.on(changeText, (_, e) => e)
			
			    const Display = () => \{
			      const state = useStore(store)
			      return <span>Store text: \{state\}</span>
			    \}
			
			    await render(<Display />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        Store text: 
			        foo
			      </span>
			    \`)
			    await act(async () => \{
			      changeText('bar')
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        Store text: 
			        bar
			      </span>
			    \`)
			  \})
			
			  it('should throw', async () => \{
			    const fn = jest.fn()
			    const ErrorDisplay = () => \{
			      try \{
			        //@ts-expect-error
			        useStore(undefined)
			      \} catch (error) \{
			        fn((error as any).message)
			      \}
			      return <span>Store text</span>
			    \}
			
			    await render(<ErrorDisplay />)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "expect useStore argument to be a store",
			      ]
			    \`)
			  \})
			
			  it('should retrigger only once after store change', async () => \{
			    const fn = jest.fn()
			    const storeA = createStore('A')
			    const storeB = createStore('B')
			    const changeCurrentStore = createEvent<Store<string>>()
			    const currentStore = createStore(storeA).on(
			      changeCurrentStore,
			      (_, store) => store,
			    )
			
			    const Target = (\{store\}: \{store: Store<string>\}) => \{
			      const state = useStore(store)
			      fn(state)
			      return <span>Store text: \{state\}</span>
			    \}
			
			    const Display = () => \{
			      const store = useStore(currentStore)
			      return <Target store=\{store\} />
			    \}
			
			    await render(<Display />)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "A",
			      ]
			    \`)
			    await act(async () => \{
			      changeCurrentStore(storeB)
			    \})
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "A",
			        "B",
			      ]
			    \`)
			  \})
			  it('should correct work, when store contains function', async () => \{
			    const fn = jest.fn()
			    const changeStore = createEvent<Record<string, string>>()
			    const \$store = createStore<(e: string) => string>(() => 'initial').on(
			      changeStore,
			      (_, data) => p => data[p] || 'initial',
			    )
			
			    const Display = () => \{
			      const store = useStore(\$store)
			      fn(store('key'))
			      return <>\{store('key')\}</>
			    \}
			
			    await render(<Display />)
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`initial\`)
			    await act(async () => \{
			      changeStore(\{key: 'value'\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`value\`)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "initial",
			        "value",
			      ]
			    \`)
			  \})
			  it('should subscribe before any react hook will change store', async () => \{
			    const fn = jest.fn()
			    const fx = createEffect(\{
			      handler: () => new Promise(rs => setTimeout(rs, 200)),
			    \})
			    const count = createStore(0).on(fx, x => x + 1)
			    const Inner = () => \{
			      React.useLayoutEffect(() => \{
			        fx()
			      \}, [])
			
			      return null
			    \}
			    const App = () => \{
			      const value = useStore(count)
			      fn(value)
			      return (
			        <p>
			          Final value: \{value\}
			          <Inner />
			        </p>
			      )
			    \}
			
			    await act(async () => \{
			      await render(<App />)
			      await new Promise(rs => setTimeout(rs, 500))
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <p>
			        Final value: 
			        1
			      </p>
			    \`)
			    expect(argumentHistory(fn)).toEqual([0, 1])
			  \})
			  it('should support domains', async () => \{
			    const domain = createDomain()
			    const toggle = domain.createEvent()
			    const inc = domain.createEvent()
			    const show = domain
			      .createStore('A')
			      .on(toggle, current => (current === 'A' ? 'B' : 'A'))
			    const a = domain.createStore(10).on(inc, x => x + 1)
			    const b = domain.createStore(20).on(inc, x => x + 1)
			    const View = () => \{
			      const current = useStore(show)
			      const selectedStore = current === 'A' ? a : b
			      const value = useStore(selectedStore)
			      return <div>\{value\}</div>
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        10
			      </div>
			    \`)
			    await act(async () => \{
			      inc()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        11
			      </div>
			    \`)
			    await act(async () => \{
			      toggle()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        21
			      </div>
			    \`)
			    await act(async () => \{
			      inc()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        22
			      </div>
			    \`)
			    await act(async () => \{
			      toggle()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        12
			      </div>
			    \`)
			  \})
			  it('should be in sync in case of store change', async () => \{
			    const toggleS0 = createEvent<unknown>()
			    const toggleS1 = createEvent<unknown>()
			    const s0 = createStore(false).on(toggleS0, v => !v)
			    const s1 = createStore(false).on(toggleS1, v => !v)
			
			    const stores = [s0, s1]
			    const events = [toggleS0, toggleS1]
			    const toggleMetaStore = createEvent<unknown>()
			    const metaStore = createStore([s0, toggleS0, 0 as 0 | 1] as const).on(
			      toggleMetaStore,
			      v => \{
			        const nv = v[2] === 0 ? 1 : 0
			        return [stores[nv], events[nv], nv] as const
			      \},
			    )
			
			    const Meta = (props: \{
			      store: Store<boolean>
			      toggle: Event<unknown>
			      v: 0 | 1
			    \}) => \{
			      const v = useStore(props.store)
			      return (
			        <>
			          <span>
			            store \{props.v\} = \{JSON.stringify(v)\}
			          </span>
			          <button type="button" onClick=\{props.toggle\} id="toggle">
			            toggle value
			          </button>
			        </>
			      )
			    \}
			
			    const App = () => \{
			      const [meta, toggle, v] = useStore(metaStore)
			      return (
			        <>
			          <Meta store=\{meta\} toggle=\{toggle\} v=\{v\} />
			          <button type="button" onClick=\{toggleMetaStore\} id="meta">
			            toggle store
			          </button>
			        </>
			      )
			    \}
			    await render(<App />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        store 
			        0
			         = 
			        false
			      </span>
			    \`)
			    await act(async () => \{
			      container.querySelector('#toggle').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        store 
			        0
			         = 
			        true
			      </span>
			    \`)
			    await act(async () => \{
			      container.querySelector('#meta').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        store 
			        1
			         = 
			        false
			      </span>
			    \`)
			    await act(async () => \{
			      container.querySelector('#toggle').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        store 
			        1
			         = 
			        true
			      </span>
			    \`)
			  \})
			  describe('strict mode support', () => \{
			    test('no strict mode', async () => \{
			      const fetchItem = createEffect(\{
			        handler: () =>
			          new Promise<string>(rs => \{
			            setTimeout(() => \{
			              rs('item')
			            \}, 100)
			          \}),
			      \})
			      const item = createStore<string | null>(null).on(
			        fetchItem.doneData,
			        (_, value) => value,
			      )
			      const setActiveItem = createEvent<string | null>()
			      const activeItem = createStore<string | null>(null).on(
			        setActiveItem,
			        (_, val) => val,
			      )
			
			      const App = () => \{
			        const val = useStore(item)
			        React.useEffect(() => \{
			          setActiveItem(val)
			        \}, [val])
			        React.useEffect(() => \{
			          fetchItem()
			        \}, [])
			        return (
			          <div>
			            <p>\{useStore(item)\}</p>
			            <p>\{useStore(activeItem)\}</p>
			          </div>
			        )
			      \}
			
			      await render(<App />)
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          <p />
			          <p />
			        </div>
			      \`)
			      await act(async () => \{
			        await new Promise(rs => setTimeout(rs, 100))
			      \})
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          <p>
			            item
			          </p>
			          <p>
			            item
			          </p>
			        </div>
			      \`)
			    \})
			    test('strict mode', async () => \{
			      const fetchItem = createEffect(\{
			        handler: () =>
			          new Promise<string>(rs => \{
			            setTimeout(() => \{
			              rs('item')
			            \}, 100)
			          \}),
			      \})
			      const item = createStore<string | null>(null).on(
			        fetchItem.doneData,
			        (_, value) => value,
			      )
			      const setActiveItem = createEvent<string | null>()
			      const activeItem = createStore<string | null>(null).on(
			        setActiveItem,
			        (_, val) => val,
			      )
			
			      const App = () => \{
			        const val = useStore(item)
			        React.useEffect(() => \{
			          setActiveItem(val)
			        \}, [val])
			        React.useEffect(() => \{
			          fetchItem()
			        \}, [])
			        return (
			          <div>
			            <p>\{useStore(item)\}</p>
			            <p>\{useStore(activeItem)\}</p>
			          </div>
			        )
			      \}
			
			      await render(
			        <React.StrictMode>
			          <App />
			        </React.StrictMode>,
			      )
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          <p />
			          <p />
			        </div>
			      \`)
			      await act(async () => \{
			        await new Promise(rs => setTimeout(rs, 100))
			      \})
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          <p>
			            item
			          </p>
			          <p>
			            item
			          </p>
			        </div>
			      \`)
			    \})
			  \})
			
			  test('get value from scope if it is available', async () => \{
			    const \$store = createStore('original')
			
			    const scope = fork(\{values: [[\$store, 'scoped']]\})
			
			    function App() \{
			      const value = useStore(\$store)
			
			      return <p>\{value\}</p>
			    \}
			
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <p>
			        scoped
			      </p>
			    \`)
			  \})
			
			  test('throw error on forceScope if it is not available', async () => \{
			    const \$store = createStore('original')
			
			    function App() \{
			      const value = useStore(\$store, \{forceScope: true\})
			
			      return <p>\{value\}</p>
			    \}
			
			    expect(() => render(<App />)).rejects.toMatchInlineSnapshot(
			      \`[Error: No scope found, consider adding <Provider> to app root]\`,
			    )
			  \})
			\})
			describe('useStoreMap', () => \{
			  it('should render', async () => \{
			    const removeUser = createEvent<string>()
			    const changeUserAge = createEvent<\{nickname: string; age: number\}>()
			    const users = createStore<Record<string, \{age: number; name: string\}>>(\{
			      alex: \{age: 20, name: 'Alex'\},
			      john: \{age: 30, name: 'John'\},
			    \})
			    const userNames = createStore(['alex', 'john']).on(
			      removeUser,
			      (list, username) => list.filter(item => item !== username),
			    )
			    users.on(removeUser, (users, nickname) => \{
			      const upd = \{...users\}
			      delete upd[nickname]
			      return upd
			    \})
			    users.on(changeUserAge, (users, \{nickname, age\}) => (\{
			      ...users,
			      [nickname]: \{...users[nickname], age\},
			    \}))
			
			    const Card = (\{nickname\}: \{nickname: string\}) => \{
			      const \{name, age\} = useStoreMap(\{
			        store: users,
			        keys: [nickname],
			        fn: (users, [nickname]) => users[nickname],
			      \})
			      return (
			        <li>
			          \{name\}: \{age\}
			        </li>
			      )
			    \}
			
			    const Cards = () => \{
			      const userList = useStore(userNames)
			      return (
			        <ul>
			          \{userList.map(name => (
			            <Card nickname=\{name\} key=\{name\} />
			          ))\}
			        </ul>
			      )
			    \}
			    await render(<Cards />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          Alex
			          : 
			          20
			        </li>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			    await act(async () => \{
			      changeUserAge(\{nickname: 'alex', age: 21\})
			    \})
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          Alex
			          : 
			          21
			        </li>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			    await act(async () => \{
			      removeUser('alex')
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			  \})
			  it('should support domains', async () => \{
			    const domain = createDomain()
			    const toggle = domain.createEvent()
			    const inc = domain.createEvent()
			    const show = domain
			      .createStore('A')
			      .on(toggle, current => (current === 'A' ? 'B' : 'A'))
			    const a = domain.createStore(10).on(inc, x => x + 1)
			    const b = domain.createStore(20).on(inc, x => x + 1)
			    const View = () => \{
			      const current = useStore(show)
			      const selectedStore = current === 'A' ? a : b
			      const value = useStoreMap(\{
			        store: selectedStore,
			        keys: [selectedStore],
			        fn: x => x,
			      \})
			      return <div>\{value\}</div>
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        10
			      </div>
			    \`)
			    await act(async () => \{
			      inc()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        11
			      </div>
			    \`)
			    await act(async () => \{
			      toggle()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        21
			      </div>
			    \`)
			    await act(async () => \{
			      inc()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        22
			      </div>
			    \`)
			    await act(async () => \{
			      toggle()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        12
			      </div>
			    \`)
			  \})
			  test('updateFilter support', async () => \{
			    const update = createEvent<number>()
			    const store = createStore(0).on(update, (_, x) => x)
			
			    const View = () => \{
			      const x = useStoreMap(\{
			        store,
			        keys: [],
			        fn: x => x,
			        updateFilter: (x: number, y) => x % 2 === 0,
			      \})
			      return <div>\{x\}</div>
			    \}
			    const App = () => <View />
			    await render(<App />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        0
			      </div>
			    \`)
			    await act(async () => \{
			      update(2)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        2
			      </div>
			    \`)
			    await act(async () => \{
			      update(3)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        2
			      </div>
			    \`)
			  \})
			  it('should not hold obsolete fn', async () => \{
			    const update = createEvent<number>()
			    const store = createStore(0).on(update, (_, x) => x)
			    let count = 0
			    const View = () => \{
			      const storeValue = useStore(store)
			      const n = count
			      const x = useStoreMap(\{
			        store,
			        keys: [count],
			        fn: x => x + n,
			      \})
			      return (
			        <div>
			          \{storeValue\}/\{x\}/\{count\}
			        </div>
			      )
			    \}
			    const App = () => <View />
			    await render(<App />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        0
			        /
			        0
			        /
			        0
			      </div>
			    \`)
			    await act(async () => \{
			      count += 1
			      update(2)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        2
			        /
			        3
			        /
			        1
			      </div>
			    \`)
			    await act(async () => \{
			      count += 1
			      update(3)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        3
			        /
			        5
			        /
			        2
			      </div>
			    \`)
			  \})
			  test('issue #643: should return the same result as useStore, when used with the same mapper', async () => \{
			    const update = createEvent<number>()
			    const store = createStore(0).on(update, (_, x) => x)
			    const mapper = (x: number) => x + 1
			
			    const View = () => \{
			      const baseX = mapper(useStore(store))
			      const x = useStoreMap(store, mapper)
			      return <div>\{x === baseX ? 'equal' : 'not_equal'\}</div>
			    \}
			    const App = () => <View />
			    await render(<App />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        equal
			      </div>
			    \`)
			    await act(async () => \{
			      update(2)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        equal
			      </div>
			    \`)
			    await act(async () => \{
			      update(3)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        equal
			      </div>
			    \`)
			  \})
			  test('change in one of the keys should trigger \`fn\` computation', async () => \{
			    const trigger = createEvent<any>()
			    const \$trigger = restore(trigger, null)
			
			    const store = createStore(0)
			
			    const fn = jest.fn()
			
			    const View = () => \{
			      const someChangingKey = useStore(\$trigger)
			      const value = useStoreMap(\{
			        store,
			        keys: [someChangingKey],
			        fn: () => \{
			          fn()
			          return 42
			        \},
			      \})
			
			      return <div>\{value\}</div>
			    \}
			    const App = () => <View />
			
			    await render(<App />)
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			    expect(fn).toBeCalledTimes(1)
			
			    await act(async () => \{
			      trigger(1)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			    expect(fn).toBeCalledTimes(2)
			
			    // change in the key should not trigger computation
			    await act(async () => \{
			      trigger(1)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			    expect(fn).toBeCalledTimes(2)
			
			    await act(async () => \{
			      trigger(2)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			    expect(fn).toBeCalledTimes(3)
			  \})
			  test('re-render by external reason shoud not trigger \`fn\` computation if it is unaffected', async () => \{
			    const trigger = createEvent<any>()
			    const \$trigger = restore(trigger, null)
			
			    const store = createStore(0)
			
			    const fn = jest.fn()
			    const rendered = jest.fn()
			
			    const View = () => \{
			      useStore(\$trigger)
			      const value = useStoreMap(\{
			        store,
			        keys: [],
			        fn: () => \{
			          fn()
			          return 42
			        \},
			      \})
			
			      rendered()
			
			      return <div>\{value\}</div>
			    \}
			    const App = () => <View />
			
			    await render(<App />)
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			    expect(fn).toBeCalledTimes(1)
			    expect(rendered).toBeCalledTimes(1)
			
			    await act(async () => \{
			      trigger(1)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			    expect(fn).toBeCalledTimes(1)
			    expect(rendered).toBeCalledTimes(2)
			
			    await act(async () => \{
			      trigger(2)
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			    expect(fn).toBeCalledTimes(1)
			    expect(rendered).toBeCalledTimes(3)
			  \})
			  test('defaultValue support', async () => \{
			    const addItem = createEvent<\{id: string; value: string\}>()
			    const \$items = createStore([\{id: 'user1', value: 'Alice'\}])
			    \$items.on(addItem, (items, item) => [...items, item])
			
			    const App = (\{id\}: \{id: string\}) => \{
			      const \{value\} = useStoreMap(\{
			        store: \$items,
			        keys: [id],
			        fn: items => items.find(e => e.id === id),
			        defaultValue: \{id: 'guest', value: 'Guest'\},
			      \})
			      return <div>Hello \{value\}</div>
			    \}
			    await render(<App id="user2" />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        Hello 
			        Guest
			      </div>
			    \`)
			    await act(() => \{
			      addItem(\{id: 'user2', value: 'Bob'\})
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        Hello 
			        Bob
			      </div>
			    \`)
			  \})
			  test('defaultValue rerendering', async () => \{
			    const fn = jest.fn()
			    const addItem = createEvent<\{id: string; value: string\}>()
			    const removeItem = createEvent<string>()
			    const \$items = createStore([\{id: 'user1', value: 'Alice'\}])
			    \$items.on(addItem, (items, item) => [...items, item])
			    \$items.on(removeItem, (items, id) => \{
			      const idx = items.findIndex(e => e.id === id)
			      if (idx === -1) return
			      items = [...items]
			      items.splice(idx, 1)
			      return items
			    \})
			
			    const App = (\{id\}: \{id: string\}) => \{
			      const \{value\} = useStoreMap(\{
			        store: \$items,
			        keys: [id],
			        fn: items => items.find(e => e.id === id),
			        defaultValue: \{id: 'guest', value: 'Guest'\},
			      \})
			      fn(value)
			      return <div>Hello \{value\}</div>
			    \}
			    await render(<App id="user2" />)
			    await act(() => \{
			      addItem(\{id: 'user3', value: 'Carol'\})
			    \})
			    await act(() => \{
			      removeItem('user3')
			    \})
			    await act(() => \{
			      addItem(\{id: 'user2', value: 'Bob'\})
			    \})
			    await act(() => \{
			      removeItem('user2')
			    \})
			    expect(argumentHistory(fn)).toEqual(['Guest', 'Bob', 'Guest'])
			  \})
			
			  test('get value from scope if it is available', async () => \{
			    const \$store = createStore('original')
			
			    const scope = fork(\{values: [[\$store, 'scoped']]\})
			
			    function App() \{
			      const value = useStoreMap(\{
			        store: \$store,
			        fn: t => t + 'mapped',
			        keys: [],
			      \})
			
			      return <p>\{value\}</p>
			    \}
			
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <p>
			        scopedmapped
			      </p>
			    \`)
			  \})
			
			  test('throw error on forceScope if it is not available', async () => \{
			    const \$store = createStore('original')
			
			    function App() \{
			      const value = useStoreMap(\{
			        store: \$store,
			        fn: t => t + 'mapped',
			        keys: [],
			        forceScope: true,
			      \})
			
			      return <p>\{value\}</p>
			    \}
			
			    expect(() => render(<App />)).rejects.toMatchInlineSnapshot(
			      \`[Error: No scope found, consider adding <Provider> to app root]\`,
			    )
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\useStore.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(22)
    });
    it('effector_effector\\src\\react\\__tests__\\base\\useUnit.test.tsx', () => {
        const sourceCode = `
			import * as React from 'react'
			//@ts-expect-error
			import \{render, container, act\} from 'effector/fixtures/react'
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  combine,
			  sample,
			  attach,
			  Store,
			  fork,
			  allSettled,
			  serialize,
			\} from 'effector'
			import \{useUnit\} from 'effector-react'
			import \{
			  useUnit as useUnitScope,
			  createGate,
			  useGate,
			  useEvent,
			  useStore,
			  Provider,
			\} from 'effector-react/scope'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('useUnit', () => \{
			  it('should bind single store', async () => \{
			    const \$a = createStore(42)
			
			    const View = () => \{
			      const a = useUnit(\$a)
			
			      return <div>\{a\}</div>
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			  \})
			  it('should bind single event', async () => \{
			    const initialValue = 42
			    const inc = createEvent()
			    const \$a = createStore(initialValue).on(inc, s => s + 1)
			
			    const View = () => \{
			      const up = useUnit(inc)
			
			      return (
			        <div>
			          <button id="btn" onClick=\{up\}>
			            up!
			          </button>
			        </div>
			      )
			    \}
			
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          up!
			        </button>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(\$a.getState()).toEqual(initialValue + 1)
			  \})
			  it('should bind single effect', async () => \{
			    const initialValue = 42
			    const incFx = createEffect(() => \{\})
			    const \$a = createStore(initialValue).on(incFx.done, s => s + 1)
			
			    const View = () => \{
			      const up = useUnit(incFx)
			
			      return (
			        <div>
			          <button
			            id="btn"
			            onClick=\{() => \{
			              const promise = up()
			
			              expect(promise).toBeInstanceOf(Promise)
			            \}\}>
			            up!
			          </button>
			        </div>
			      )
			    \}
			
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          up!
			        </button>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(\$a.getState()).toEqual(initialValue + 1)
			  \})
			  it('should bind stores shape', async () => \{
			    const \$a = createStore(30)
			    const \$b = createStore(10)
			    const \$c = createStore(2)
			
			    const View = () => \{
			      const state = useUnit(\{a: \$a, b: \$b, c: \$c\})
			
			      return <div>\{state.a + state.b + state.c\}</div>
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			  \})
			  it('should bind stores array shape', async () => \{
			    const \$a = createStore(30)
			    const \$b = createStore(10)
			    const \$c = createStore(2)
			
			    const View = () => \{
			      const [a, b, c] = useUnit([\$a, \$b, \$c])
			
			      return <div>\{a + b + c\}</div>
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			      </div>
			    \`)
			  \})
			  it('should bind events shape', async () => \{
			    const initialValue = 42
			    const inc = createEvent()
			    const dec = createEvent()
			    const \$a = createStore(initialValue)
			      .on(inc, s => s + 1)
			      .on(dec, s => s - 1)
			
			    const View = () => \{
			      const up = useUnit(\{inc, dec\})
			
			      return (
			        <div>
			          <button
			            id="btn"
			            onClick=\{() => \{
			              up.inc()
			              up.dec()
			            \}\}>
			            up!
			          </button>
			        </div>
			      )
			    \}
			
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          up!
			        </button>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(\$a.getState()).toEqual(initialValue)
			  \})
			  it('should bind effects shape', async () => \{
			    const initialValue = 42
			    const incFx = createEffect(() => \{\})
			    const decFx = createEffect(() => \{\})
			    const \$a = createStore(initialValue)
			      .on(incFx.done, s => s + 1)
			      .on(decFx.done, s => s - 1)
			
			    const View = () => \{
			      const up = useUnit(\{incFx, decFx\})
			
			      return (
			        <div>
			          <button
			            id="btn"
			            onClick=\{() => \{
			              expect(up.incFx()).toBeInstanceOf(Promise)
			              expect(up.decFx()).toBeInstanceOf(Promise)
			            \}\}>
			            up!
			          </button>
			        </div>
			      )
			    \}
			
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          up!
			        </button>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(\$a.getState()).toEqual(initialValue)
			  \})
			  it('should bind mixed shape', async () => \{
			    const initialValue = 42
			    const inc = createEvent()
			    const decFx = createEffect(() => \{\})
			    const \$a = createStore(initialValue)
			      .on(inc, s => s + 1)
			      .on(decFx.done, s => s - 1)
			
			    const View = () => \{
			      const \{a, b, c\} = useUnit(\{a: \$a, b: inc, c: decFx\})
			
			      return (
			        <div>
			          \{a\}
			          <button
			            id="btn"
			            onClick=\{() => \{
			              b()
			              expect(c()).toBeInstanceOf(Promise)
			            \}\}>
			            up
			          </button>
			        </div>
			      )
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			        <button
			          id="btn"
			        >
			          up
			        </button>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			        <button
			          id="btn"
			        >
			          up
			        </button>
			      </div>
			    \`)
			  \})
			  it('should bind mixed array', async () => \{
			    const initialValue = 42
			    const inc = createEvent()
			    const decFx = createEffect(() => \{\})
			    const \$a = createStore(initialValue)
			      .on(inc, s => s + 1)
			      .on(decFx.done, s => s - 1)
			
			    const View = () => \{
			      const [a, b, c] = useUnit([\$a, inc, decFx])
			
			      return (
			        <div>
			          \{a\}
			          <button
			            id="btn"
			            onClick=\{() => \{
			              b()
			              expect(c()).toBeInstanceOf(Promise)
			            \}\}>
			            up
			          </button>
			        </div>
			      )
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        42
			        <button
			          id="btn"
			        >
			          up
			        </button>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          42
			          <button
			            id="btn"
			          >
			            up
			          </button>
			        </div>
			      \`)
			  \})
			  it('should batch multiple updates', async () => \{
			    const up = createEvent()
			    const \$a = createStore(29).on(up, s => s + 1)
			    const \$b = createStore(9).on(up, s => s + 1)
			    const \$c = createStore(1).on(up, s => s + 1)
			    const \$d = combine(\$b, \$c, (b, c) => b + c)
			
			    const rendered = jest.fn()
			
			    const View = () => \{
			      const state = useUnit(\{a: \$a, d: \$d\})
			
			      rendered()
			
			      return <div>\{state.a + state.d\}</div>
			    \}
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        39
			      </div>
			    \`)
			
			    act(() => \{
			      up()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			          <div>
			            42
			          </div>
			      \`)
			    expect(rendered).toBeCalledTimes(2)
			  \})
			  it('should support dynamic change of store', async () => \{
			    const upA = createEvent()
			    const upB = createEvent()
			    const \$a = createStore(42)
			    const \$b = createStore(37)
			
			    \$a.on(upA, s => s + 1)
			    \$b.on(upB, s => s - 1)
			
			    const fn = jest.fn()
			
			    const StoreRenderer: React.FC<\{store: Store<number>\}> = props => \{
			      const \{a\} = useUnit(\{a: props.store\})
			      fn(\{a\})
			      return <div>\{a\}</div>
			    \}
			    const View = () => \{
			      const [left, setLeft] = React.useState(true)
			
			      return (
			        <div>
			          <button
			            id="btn"
			            onClick=\{() => \{
			              setLeft(s => !s)
			            \}\}>
			            switch
			          </button>
			          <StoreRenderer store=\{left ? \$a : \$b\} />
			        </div>
			      )
			    \}
			
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          42
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      upB()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          42
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          36
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      upB()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          35
			        </div>
			      </div>
			    \`)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "a": 42,
			        \},
			        Object \{
			          "a": 36,
			        \},
			        Object \{
			          "a": 35,
			        \},
			      ]
			    \`)
			  \})
			  it('should support dynamic change of event', async () => \{
			    const fnL = jest.fn()
			    const fnR = jest.fn()
			    const left = createEvent()
			    const right = createEvent()
			    left.watch(() => fnL())
			    right.watch(() => fnR())
			
			    const View = () => \{
			      const [which, setWhich] = React.useState(true)
			      const event = which ? left : right
			      const testUnit = useUnit(event)
			      const onSwitch = () => setWhich(!which)
			      return (
			        <div>
			          <button id="run" onClick=\{testUnit\}>
			            run
			          </button>
			          <button id="switch" onClick=\{onSwitch\}>
			            Switch
			          </button>
			        </div>
			      )
			    \}
			    await render(<View />)
			    await act(async () => \{
			      container.firstChild.querySelector('#run').click()
			    \})
			    await act(async () => \{
			      container.firstChild.querySelector('#switch').click()
			    \})
			    await act(async () => \{
			      container.firstChild.querySelector('#run').click()
			    \})
			    expect(fnL).toBeCalledTimes(1)
			    expect(fnR).toBeCalledTimes(1)
			  \})
			  it('should support dynamic change of store positions', async () => \{
			    const upA = createEvent()
			    const upB = createEvent()
			    const \$a = createStore(42).on(upA, s => s + 1)
			    const \$b = createStore(37).on(upB, s => s - 1)
			
			    const fn = jest.fn()
			
			    const StoreRenderer: React.FC<\{leftFirst: boolean\}> = props => \{
			      const [a, b] = useUnit(props.leftFirst ? [\$a, \$b] : [\$b, \$a])
			      fn(\{a, b\})
			      return (
			        <div>
			          \{a\}
			          \{b\}
			        </div>
			      )
			    \}
			    const View = () => \{
			      const [left, setLeft] = React.useState(true)
			
			      return (
			        <div>
			          <button
			            id="btn"
			            onClick=\{() => \{
			              setLeft(s => !s)
			            \}\}>
			            switch
			          </button>
			          <StoreRenderer leftFirst=\{left\} />
			        </div>
			      )
			    \}
			
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          42
			          37
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      upB()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          42
			          36
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          36
			          42
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      upB()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          35
			          42
			        </div>
			      </div>
			    \`)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "a": 42,
			          "b": 37,
			        \},
			        Object \{
			          "a": 42,
			          "b": 36,
			        \},
			        Object \{
			          "a": 36,
			          "b": 42,
			        \},
			        Object \{
			          "a": 35,
			          "b": 42,
			        \},
			      ]
			    \`)
			  \})
			  it('should support dynamic change of store keys', async () => \{
			    const upA = createEvent()
			    const upB = createEvent()
			    const \$a = createStore(42).on(upA, s => s + 1)
			    const \$b = createStore(37).on(upB, s => s - 1)
			
			    const fn = jest.fn()
			
			    const StoreRenderer: React.FC<\{leftFirst: boolean\}> = props => \{
			      const \{a, b, c, d\} = useUnit(
			        props.leftFirst ? \{a: \$a, b: \$b\} : \{c: \$b, d: \$a\},
			      )
			      const x = a ?? c
			      const y = b ?? d
			      fn(a ? \{a, b\} : \{c, d\})
			      return (
			        <div>
			          \{a ?? c\}
			          \{b ?? d\}
			        </div>
			      )
			    \}
			    const View = () => \{
			      const [left, setLeft] = React.useState(true)
			
			      return (
			        <div>
			          <button
			            id="btn"
			            onClick=\{() => \{
			              setLeft(s => !s)
			            \}\}>
			            switch
			          </button>
			          <StoreRenderer leftFirst=\{left\} />
			        </div>
			      )
			    \}
			
			    await render(<View />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          42
			          37
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      upB()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          42
			          36
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      container.firstChild.querySelector('#btn').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          36
			          42
			        </div>
			      </div>
			    \`)
			
			    await act(async () => \{
			      upB()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          switch
			        </button>
			        <div>
			          35
			          42
			        </div>
			      </div>
			    \`)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "a": 42,
			          "b": 37,
			        \},
			        Object \{
			          "a": 42,
			          "b": 36,
			        \},
			        Object \{
			          "c": 36,
			          "d": 42,
			        \},
			        Object \{
			          "c": 35,
			          "d": 42,
			        \},
			      ]
			    \`)
			  \})
			  it('should support dynamic change of scope', async () => \{
			    const activeChanged = createEvent<'a' | 'b'>()
			    const \$active = createStore<'a' | 'b'>('a').on(
			      activeChanged,
			      (_, upd) => upd,
			    )
			    let clientScope = fork()
			
			    const ref: \{fn(): any\} = \{
			      fn() \{
			        throw Error('noop fn')
			      \},
			    \}
			    const triggerTopRender = () => \{
			      ref.fn()
			    \}
			
			    function Page() \{
			      const \{acive, changeActive\} = useUnitScope(\{
			        acive: \$active,
			        changeActive: activeChanged,
			      \})
			
			      return (
			        <div>
			          <button id="a" disabled=\{acive !== 'a'\}>
			            a
			          </button>
			          <button id="b" disabled=\{acive !== 'b'\}>
			            b
			          </button>
			          <button
			            id="value"
			            onClick=\{() => \{
			              changeActive(acive === 'a' ? 'b' : 'a')
			            \}\}>
			            Val
			          </button>
			          <button id="scope" onClick=\{triggerTopRender\}>
			            Scp
			          </button>
			        </div>
			      )
			    \}
			
			    function AppBase(\{page, data\}: \{data: any; page: JSX.Element\}) \{
			      const scope = React.useMemo(() => \{
			        const scope = fork(\{
			          values: \{
			            ...serialize(clientScope),
			            ...data,
			          \},
			        \})
			        clientScope = scope
			
			        return scope
			      \}, [data])
			      return <Provider value=\{scope\}>\{page\}</Provider>
			    \}
			
			    function App() \{
			      const [s, setS] = React.useState(\{\})
			      ref.fn = () => setS(\{\})
			
			      return <AppBase data=\{s\} page=\{<Page />\} />
			    \}
			
			    await render(<App />)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="a"
			        >
			          a
			        </button>
			        <button
			          disabled=""
			          id="b"
			        >
			          b
			        </button>
			        <button
			          id="value"
			        >
			          Val
			        </button>
			        <button
			          id="scope"
			        >
			          Scp
			        </button>
			      </div>
			    \`)
			    await act(async () => \{
			      container.firstChild.querySelector('#value').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          disabled=""
			          id="a"
			        >
			          a
			        </button>
			        <button
			          id="b"
			        >
			          b
			        </button>
			        <button
			          id="value"
			        >
			          Val
			        </button>
			        <button
			          id="scope"
			        >
			          Scp
			        </button>
			      </div>
			    \`)
			    await act(async () => \{
			      container.firstChild.querySelector('#scope').click()
			    \})
			    await act(async () => \{
			      container.firstChild.querySelector('#value').click()
			    \})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="a"
			        >
			          a
			        </button>
			        <button
			          disabled=""
			          id="b"
			        >
			          b
			        </button>
			        <button
			          id="value"
			        >
			          Val
			        </button>
			        <button
			          id="scope"
			        >
			          Scp
			        </button>
			      </div>
			    \`)
			  \})
			  describe('useUnit + useGate edge case', () => \{
			    const getDataRawFx = createEffect(
			      () =>
			        new Promise<\{id: number\}[]>(rs => \{
			          setTimeout(() => rs([\{id: 1\}]), 1000)
			        \}),
			    )
			    test('useUnit + useGate', async () => \{
			      const event = createEvent()
			      const getDataFx = attach(\{effect: getDataRawFx\})
			      const \$data = createStore<\{id: number\}[]>([])
			
			      const Gate = createGate(\{defaultState: 0\})
			
			      sample(\{clock: Gate.open, target: getDataFx\})
			
			      \$data.on(getDataFx.doneData, (_, upd) => upd)
			
			      const Component = () => \{
			        useGate(Gate, 0)
			        const [data, pending] = useUnitScope([\$data, getDataFx.pending])
			        if (pending) return <div>Loading....</div>
			        return <div>\{JSON.stringify(data)\}</div>
			      \}
			
			      const scope = fork()
			
			      await render(
			        <React.StrictMode>
			          <Provider value=\{scope\}>
			            <Component />
			          </Provider>
			        </React.StrictMode>,
			      )
			      // @ ts-expect-error
			      // if (globalThis.REACT_17) \{
			      //   expect(container.firstChild).toMatchInlineSnapshot(\`
			      //     <div>
			      //       []
			      //     </div>
			      //   \`)
			      // \} else \{
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          Loading....
			        </div>
			      \`)
			      // \}
			      await act(async () => \{
			        await allSettled(event, \{scope\})
			      \})
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          [\{"id":1\}]
			        </div>
			      \`)
			    \})
			    test('useStore + useGate', async () => \{
			      const event = createEvent()
			      const getDataFx = attach(\{effect: getDataRawFx\})
			      const \$data = createStore<\{id: number\}[]>([])
			
			      const Gate = createGate(\{defaultState: 0\})
			
			      sample(\{clock: Gate.open, target: getDataFx\})
			
			      \$data.on(getDataFx.doneData, (_, upd) => upd)
			
			      const Component = () => \{
			        useGate(Gate, 0)
			        const data = useStore(\$data)
			        const pending = useStore(getDataFx.pending)
			        if (pending) return <div>Loading....</div>
			        return <div>\{JSON.stringify(data)\}</div>
			      \}
			
			      const scope = fork()
			
			      await render(
			        <React.StrictMode>
			          <Provider value=\{scope\}>
			            <Component />
			          </Provider>
			        </React.StrictMode>,
			      )
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          Loading....
			        </div>
			      \`)
			      await act(async () => \{
			        await allSettled(event, \{scope\})
			      \})
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          [\{"id":1\}]
			        </div>
			      \`)
			    \})
			    test('useUnit + useEffect', async () => \{
			      const event = createEvent()
			      const getData = createEvent()
			      const getDataFx = attach(\{effect: getDataRawFx\})
			      const \$data = createStore<\{id: number\}[]>([])
			
			      sample(\{clock: getData, target: getDataFx\})
			
			      \$data.on(getDataFx.doneData, (_, upd) => upd)
			
			      const Component = () => \{
			        const run = useEvent(getData)
			        const [data, pending] = useUnitScope([\$data, getDataFx.pending])
			        React.useEffect(() => \{
			          run()
			        \}, [])
			        if (pending) return <div>Loading....</div>
			        return <div>\{JSON.stringify(data)\}</div>
			      \}
			
			      const scope = fork()
			
			      await render(
			        <React.StrictMode>
			          <Provider value=\{scope\}>
			            <Component />
			          </Provider>
			        </React.StrictMode>,
			      )
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          Loading....
			        </div>
			      \`)
			      await act(async () => \{
			        await allSettled(event, \{scope\})
			      \})
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          [\{"id":1\}]
			        </div>
			      \`)
			    \})
			  \})
			  describe('useUnit with force scope', () => \{
			    let consoleError: any
			    beforeEach(() => \{
			      consoleError = console.error
			      console.error = () => \{\}
			    \})
			    afterEach(() => \{
			      console.error = consoleError
			    \})
			    describe('forceScope options not set', () => \{
			      it('without context', async () => \{
			        const \$a = createStore(42)
			
			        const View = () => \{
			          const a = useUnit(\$a)
			
			          return <div>\{a\}</div>
			        \}
			
			        expect(() =>
			          render(<View />).toMatchInlineSnapshot(\`
			            <div>
			              42
			            </div>
			          \`),
			        )
			      \})
			      test('with context', async () => \{
			        const \$value = createStore('value')
			
			        const Component = () => \{
			          const value = useUnit(\$value)
			          return <div>\{value\}</div>
			        \}
			
			        const scope = fork(\{values: [[\$value, 'scoped value']]\})
			
			        await render(
			          <React.StrictMode>
			            <Provider value=\{scope\}>
			              <Component />
			            </Provider>
			          </React.StrictMode>,
			        )
			
			        expect(container.firstChild).toMatchInlineSnapshot(\`
			            <div>
			              scoped value
			            </div>
			          \`)
			      \})
			    \})
			    describe('forceScope disabled', () => \{
			      it('without context', async () => \{
			        const \$a = createStore(42)
			
			        const View = () => \{
			          const a = useUnit(\$a, \{forceScope: false\})
			
			          return <div>\{a\}</div>
			        \}
			
			        expect(() =>
			          render(<View />).toMatchInlineSnapshot(\`
			            <div>
			              42
			            </div>
			          \`),
			        )
			      \})
			      test('with context', async () => \{
			        const \$value = createStore('value')
			
			        const Component = () => \{
			          const value = useUnit(\$value, \{forceScope: false\})
			          return <div>\{value\}</div>
			        \}
			
			        const scope = fork(\{values: [[\$value, 'scoped value']]\})
			
			        await render(
			          <React.StrictMode>
			            <Provider value=\{scope\}>
			              <Component />
			            </Provider>
			          </React.StrictMode>,
			        )
			
			        expect(container.firstChild).toMatchInlineSnapshot(\`
			            <div>
			              scoped value
			            </div>
			          \`)
			      \})
			    \})
			    describe('forceScope enabled', () => \{
			      it('without context', async () => \{
			        const \$a = createStore(42)
			
			        const View = () => \{
			          const a = useUnit(\$a, \{forceScope: true\})
			
			          return <div>\{a\}</div>
			        \}
			
			        expect(() => render(<View />)).rejects.toThrow(
			          'No scope found, consider adding <Provider> to app root',
			        )
			      \})
			      test('with context', async () => \{
			        const \$value = createStore('value')
			
			        const Component = () => \{
			          const value = useUnit(\$value, \{forceScope: true\})
			          return <div>\{value\}</div>
			        \}
			
			        const scope = fork(\{values: [[\$value, 'scoped value']]\})
			
			        await render(
			          <React.StrictMode>
			            <Provider value=\{scope\}>
			              <Component />
			            </Provider>
			          </React.StrictMode>,
			        )
			
			        expect(container.firstChild).toMatchInlineSnapshot(\`
			            <div>
			              scoped value
			            </div>
			          \`)
			      \})
			    \})
			  \})
			  it('should not trigger too often', async () => \{
			    const \$value = createStore('initial')
			    const change = createEvent<string>()
			
			    \$value.on(change, (_, next) => next)
			
			    const shape = \{
			      '@@unitShape': () => (\{
			        value: \$value,
			        onChange: change,
			      \}),
			    \}
			    let failed = false
			    let count = 0
			    const App = () => \{
			      const \{onChange, value\} = useUnit(shape)
			      React.useEffect(() => \{
			        count += 1
			        if (count >= 100) \{
			          failed = true
			          return
			        \}
			        onChange('test')
			
			        return () => \{
			          onChange('')
			        \}
			      \}, [onChange])
			      return <div>\{value\}</div>
			    \}
			    const scope = fork()
			    await render(
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    expect(failed).toBe(false)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\react\\__tests__\\base\\useUnit.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(25)
    });
    it('effector_effector\\src\\solid\\__tests__\\scopes.test.tsx', () => {
        const sourceCode = `
			import \{render\} from 'solid-testing-library'
			import \{argumentHistory\} from 'effector/fixtures'
			import \{
			  createDomain,
			  createEvent,
			  createStore,
			  createEffect,
			  forward,
			  sample,
			  attach,
			  combine,
			  fork,
			  allSettled,
			  serialize,
			  hydrate,
			  Scope,
			\} from 'effector'
			import \{
			  Provider,
			  useUnit,
			  useGate,
			  useStoreMap,
			  createGate,
			\} from 'effector-solid/scope'
			import \{createSignal\} from "solid-js";
			
			async function request(url: string) \{
			  const users: Record<string, \{name: string; friends: string[]\}> = \{
			    alice: \{
			      name: 'alice',
			      friends: ['bob', 'carol'],
			    \},
			    bob: \{
			      name: 'bob',
			      friends: ['alice'],
			    \},
			    carol: \{
			      name: 'carol',
			      friends: ['alice'],
			    \},
			    charlie: \{
			      name: 'charlie',
			      friends: [],
			    \},
			  \}
			  const user = url.replace('https://ssr.effector.dev/api/', '')
			  const result = users[user]
			  await new Promise(rs => setTimeout(rs, 30))
			  return result
			\}
			
			test('computed values support', async () => \{
			  const app = createDomain()
			
			  const fetchUser = app.createEffect<string, \{name: string; friends: string[]\}>(
			    async user => await request(\`https://ssr.effector.dev/api/\$\{user\}\`),
			  )
			  const start = app.createEvent<string>()
			  forward(\{from: start, to: fetchUser\})
			  const name = app
			    .createStore('guest')
			    .on(fetchUser.done, (_, \{result\}) => result.name)
			
			  const friends = app
			    .createStore<string[]>([])
			    .on(fetchUser.done, (_, \{result\}) => result.friends)
			  const friendsTotal = friends.map(list => list.length)
			
			  const Total = () => <small>Total:\{useUnit(friendsTotal)()\}</small>
			  const User = () => <b>User:\{useUnit(name)()\}</b>
			  const App = (props: \{root: Scope\}) => (
			    <Provider value=\{props.root\}>
			      <section>
			        <User />
			        <Total />
			      </section>
			    </Provider>
			  )
			
			  const serverScope = fork(app)
			  await allSettled(start, \{
			    scope: serverScope,
			    params: 'alice',
			  \})
			  const serialized = serialize(serverScope)
			
			  hydrate(app, \{
			    values: serialized,
			  \})
			
			  const clientScope = fork(app)
			
			  const \{ container \} = await render(() => <App root=\{clientScope\} />)
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <section>
			      <b>
			        User:
			        alice
			      </b>
			      <small>
			        Total:
			        2
			      </small>
			    </section>
			  \`)
			\})
			
			test('useGate support', async () => \{
			  const getMessagesFx = createEffect<\{chatId: string\}, string[]>(
			    async (\{chatId\}) => \{
			      return ['hi bob!', 'Hello, Alice']
			    \},
			  )
			
			  const messagesAmount = createStore(0).on(
			    getMessagesFx.doneData,
			    (_, messages) => messages.length,
			  )
			
			  const activeChatGate = createGate<\{chatId: string\}>(\{\})
			
			  forward(\{from: activeChatGate.open, to: getMessagesFx\})
			
			  const ChatPage = (props: \{chatId: string\}) => \{
			    useGate(activeChatGate, props)
			    const messages = useUnit(messagesAmount)
			    return (
			      <div>
			        <header>Chat:\{props.chatId\}</header>
			        <p>Messages total:\{messages\}</p>
			      </div>
			    )
			  \}
			  const App = (props: \{root: Scope\}) => (
			    <Provider value=\{props.root\}>
			      <ChatPage chatId="chat01" />
			    </Provider>
			  )
			
			  const [scope, setScope] = createSignal(fork(), \{ equals: false \})
			  const \{ container \} = await render(() => <App root=\{scope()\} />)
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <header>
			        Chat:
			        chat01
			      </header>
			      <p>
			        Messages total:
			        2
			      </p>
			    </div>
			  \`)
			
			  setScope(() => fork(\{
			    values: serialize(scope()),
			  \}))
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <header>
			        Chat:
			        chat01
			      </header>
			      <p>
			        Messages total:
			        2
			      </p>
			    </div>
			  \`)
			\})
			
			test('allSettled effect calls', async () => \{
			  const fn = jest.fn()
			
			  const fetchUser = createEffect<string, \{name: string; friends: string[]\}>(
			    async user => await request(\`https://ssr.effector.dev/api/\$\{user\}\`),
			  )
			
			  const serverScope = fork()
			
			  await allSettled(fetchUser, \{
			    scope: serverScope,
			    params: 'alice',
			  \})
			    .then(fn)
			    .catch(err => \{
			      console.error(err)
			    \})
			  expect(fn).toBeCalled()
			\})
			describe('useUnit', () => \{
			  test('useUnit and effect calls', async () => \{
			    const inc = createEvent()
			    const count = createStore(0).on(inc, x => x + 1)
			    const fx = createEffect(async () => \{
			      inc()
			    \})
			    const scope = fork()
			    const App = () => \{
			      const fxe = useUnit(fx)
			      const x = useUnit(count)
			      return (
			        <div>
			          <button id="btn" onClick=\{() => fxe()\}>
			            clicked-\{x\}-times
			          </button>
			        </div>
			      )
			    \}
			    const \{ container \} = await render(() =>
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          clicked-
			          0
			          <!---->
			          -times
			        </button>
			      </div>
			    \`)
			    container.firstChild.querySelector('#btn').click()
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <button
			          id="btn"
			        >
			          clicked-
			          1
			          <!---->
			          -times
			        </button>
			      </div>
			    \`)
			    expect(count.getState()).toBe(0)
			    expect(scope.getState(count)).toBe(1)
			  \})
			  test('useEvent function return value', async () => \{
			    const fn = jest.fn()
			    const fx = createEffect(() => 'ok')
			    const scope = fork()
			    const App = () => \{
			      const fxe = useUnit(fx)
			      return (
			        <div>
			          <button id="btn" onClick=\{() => fxe().then(fn)\}>
			            click
			          </button>
			        </div>
			      )
			    \}
			    const \{ container \} = await render(() =>
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    container.firstChild.querySelector('#btn').click()
			    await Promise.resolve()
			    expect(argumentHistory(fn)).toEqual(['ok'])
			  \})
			
			  test('object in useUnit', async () => \{
			    const inc = createEvent()
			    const dec = createEvent()
			    const fx = createEffect(async () => 100)
			    const count = createStore(0)
			      .on(inc, x => x + 1)
			      .on(dec, x => x - 1)
			      .on(fx.doneData, (x, v) => x + v)
			    const scope = fork()
			    const App = () => \{
			      const hndl = useUnit(\{fx, inc, dec\})
			      const x = useUnit(count)
			      return (
			        <div>
			          <span id="value">current value:\{x\}</span>
			          <button id="fx" onClick=\{() => hndl.fx()\}>
			            fx
			          </button>
			          <button id="inc" onClick=\{() => hndl.inc()\}>
			            inc
			          </button>
			          <button id="dec" onClick=\{() => hndl.dec()\}>
			            dec
			          </button>
			        </div>
			      )
			    \}
			    const \{ container \} = await render(() =>
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          0
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    container.firstChild.querySelector('#fx').click()
			    container.firstChild.querySelector('#inc').click()
			    container.firstChild.querySelector('#inc').click()
			    await Promise.resolve()
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          102
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    container.firstChild.querySelector('#dec').click()
			    await Promise.resolve()
			    expect(count.getState()).toBe(0)
			    expect(scope.getState(count)).toBe(101)
			  \})
			
			  test('array in useUnit', async () => \{
			    const inc = createEvent()
			    const dec = createEvent()
			    const fx = createEffect(async () => 100)
			    const count = createStore(0)
			      .on(inc, x => x + 1)
			      .on(dec, x => x - 1)
			      .on(fx.doneData, (x, v) => x + v)
			    const scope = fork()
			    const App = () => \{
			      const [a, b, c] = useUnit([fx, inc, dec])
			      const x = useUnit(count)
			      return (
			        <div>
			          <span id="value">current value:\{x\}</span>
			          <button id="fx" onClick=\{() => a()\}>
			            fx
			          </button>
			          <button id="inc" onClick=\{() => b()\}>
			            inc
			          </button>
			          <button id="dec" onClick=\{() => c()\}>
			            dec
			          </button>
			        </div>
			      )
			    \}
			    const \{ container \} = await render(() =>
			      <Provider value=\{scope\}>
			        <App />
			      </Provider>,
			    )
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          0
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    container.firstChild.querySelector('#fx').click()
			    container.firstChild.querySelector('#inc').click()
			    container.firstChild.querySelector('#inc').click()
			    await Promise.resolve()
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <span
			          id="value"
			        >
			          current value:
			          102
			        </span>
			        <button
			          id="fx"
			        >
			          fx
			        </button>
			        <button
			          id="inc"
			        >
			          inc
			        </button>
			        <button
			          id="dec"
			        >
			          dec
			        </button>
			      </div>
			    \`)
			    container.firstChild.querySelector('#dec').click()
			    await Promise.resolve()
			    expect(count.getState()).toBe(0)
			    expect(scope.getState(count)).toBe(101)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\solid\\__tests__\\scopes.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('effector_effector\\src\\solid\\__tests__\\shapeProtocol.test.tsx', () => {
        const sourceCode = `
			import \{allSettled, createEvent, createStore, fork, sample\} from 'effector'
			import \{useUnit, Provider\} from 'effector-solid'
			import \{render, fireEvent\} from 'solid-testing-library'
			
			describe('useUnit uses @@unitShape', () => \{
			  it('resolves custom shape of stores', async () => \{
			    const \{entity, internals\} = createCustomEntity()
			
			    const scope = fork()
			
			    const View = () => \{
			      const \{someStore\} = useUnit(entity)
			
			      return <p>\{someStore()\}</p>
			    \}
			
			    const \{container\} = render(() => (
			      <Provider value=\{scope\}>
			        <View />
			      </Provider>
			    ))
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <p>
			        initial value
			      </p>
			    \`)
			
			    await allSettled(internals.someEvent, \{scope, params: 'new value'\})
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <p>
			        new value
			      </p>
			    \`)
			  \})
			
			  it('resolves binds events from shape correctly', async () => \{
			    const \{entity\} = createCustomEntity()
			
			    const scope = fork()
			
			    const View = () => \{
			      const \{someStore, someEvent\} = useUnit(entity)
			
			      return (
			        <div>
			          <p>\{someStore()\}</p>
			          <button id="btn" onClick=\{() => someEvent('value from ui')\}>
			            click me
			          </button>
			        </div>
			      )
			    \}
			
			    const \{container\} = render(() => (
			      <Provider value=\{scope\}>
			        <View />
			      </Provider>
			    ))
			    fireEvent.click(container.querySelector('#btn')!)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        <p>
			          value from ui
			        </p>
			        <button
			          id="btn"
			        >
			          click me
			        </button>
			      </div>
			    \`)
			  \})
			\})
			
			function createCustomEntity() \{
			  const \$someStore = createStore('initial value')
			  const someEvent = createEvent<string>()
			
			  sample(\{clock: someEvent, fn: value => value, target: \$someStore\})
			
			  return \{
			    entity: \{
			      '@@unitShape': () => \{
			        return \{someStore: \$someStore, someEvent\}
			      \},
			    \},
			    internals: \{
			      \$someStore,
			      someEvent,
			    \},
			  \}
			\}
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\solid\\__tests__\\shapeProtocol.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\solid\\__tests__\\useUnit.test.tsx', () => {
        const sourceCode = `
			import \{render\} from 'solid-testing-library'
			import \{createStore, createEvent, createDomain, fork\} from 'effector'
			import \{useUnit, useStoreMap\} from 'effector-solid'
			import \{Provider\} from 'effector-solid/scope'
			import \{createEffect as createSolidEffect, createMemo, For\} from 'solid-js'
			import \{argumentHistory\} from 'effector/fixtures'
			
			describe('useUnit', () => \{
			  it('should render', async () => \{
			    const store = createStore('foo')
			    const changeText = createEvent<string>()
			    store.on(changeText, (_, e) => e)
			
			    const Display = () => \{
			      const state = useUnit(store)
			      return <span>Store text: \{state\}</span>
			    \}
			
			    const \{container\} = await render(Display)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        Store text: 
			        foo
			      </span>
			    \`)
			    changeText('bar')
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <span>
			        Store text: 
			        bar
			      </span>
			    \`)
			  \})
			  it('should throw', async () => \{
			    const fn = jest.fn()
			    const ErrorDisplay = () => \{
			      try \{
			        //@ts-expect-error
			        useUnit(undefined)
			      \} catch (error) \{
			        fn(error.message)
			      \}
			      return <span>Store text</span>
			    \}
			
			    await render(ErrorDisplay)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "expected useUnit argument to be a unit",
			      ]
			    \`)
			  \})
			  it('should work as intended when store contains function', async () => \{
			    const fn = jest.fn()
			    const changeStore = createEvent<Record<string, string>>()
			    const \$store = createStore<(e: string) => string>(() => 'initial').on(
			      changeStore,
			      (_, data) => p => data[p] || 'initial',
			    )
			
			    const Display = () => \{
			      const store = useUnit(\$store)
			      createSolidEffect(() => fn(store()('key')))
			      return <>\{store()('key')\}</>
			    \}
			
			    const \{container\} = await render(Display)
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`initial\`)
			    changeStore(\{key: 'value'\})
			    expect(container.firstChild).toMatchInlineSnapshot(\`value\`)
			    expect(argumentHistory(fn)).toMatchInlineSnapshot(\`
			      Array [
			        "initial",
			        "value",
			      ]
			    \`)
			  \})
			  it('should support domains', async () => \{
			    const domain = createDomain()
			    const toggle = domain.createEvent()
			    const inc = domain.createEvent()
			    const show = domain
			      .createStore('A')
			      .on(toggle, current => (current === 'A' ? 'B' : 'A'))
			    const a = domain.createStore(10).on(inc, x => x + 1)
			    const b = domain.createStore(20).on(inc, x => x + 1)
			    const View = () => \{
			      const current = useUnit(show)
			      const selectedStore = createMemo(() => (current() === 'A' ? a : b))
			      const value = createMemo(() => useUnit(selectedStore()))
			      return <div>\{value\}</div>
			    \}
			    const \{container\} = await render(View)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        10
			      </div>
			    \`)
			    inc()
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        11
			      </div>
			    \`)
			    toggle()
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        21
			      </div>
			    \`)
			    inc()
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        22
			      </div>
			    \`)
			    toggle()
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        12
			      </div>
			    \`)
			  \})
			\})
			describe('useStoreMap', () => \{
			  it('should render', async () => \{
			    const removeUser = createEvent<string>()
			    const changeUserAge = createEvent<\{nickname: string; age: number\}>()
			    const users = createStore<Record<string, \{age: number; name: string\}>>(\{
			      alex: \{age: 20, name: 'Alex'\},
			      john: \{age: 30, name: 'John'\},
			    \})
			    const userNames = createStore(['alex', 'john']).on(
			      removeUser,
			      (list, username) => list.filter(item => item !== username),
			    )
			    users.on(removeUser, (users, nickname) => \{
			      const upd = \{...users\}
			      delete upd[nickname]
			      return upd
			    \})
			    users.on(changeUserAge, (users, \{nickname, age\}) => (\{
			      ...users,
			      [nickname]: \{...users[nickname], age\},
			    \}))
			
			    const Card = (\{nickname\}: \{nickname: string\}) => \{
			      const user = useStoreMap(\{
			        store: users,
			        keys: [nickname],
			        fn: (users, [nickname]) => users[nickname],
			      \})
			      return (
			        <li>
			          \{user().name\}: \{user().age\}
			        </li>
			      )
			    \}
			
			    const Cards = () => \{
			      const userList = useUnit(userNames)
			      return (
			        <ul>
			          <For each=\{userList()\}>\{name => <Card nickname=\{name\} />\}</For>
			        </ul>
			      )
			    \}
			    const \{container\} = await render(Cards)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          Alex
			          : 
			          20
			        </li>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			
			    changeUserAge(\{nickname: 'alex', age: 21\})
			
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          Alex
			          : 
			          21
			        </li>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			    removeUser('alex')
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <ul>
			        <li>
			          John
			          : 
			          30
			        </li>
			      </ul>
			    \`)
			  \})
			  test('updateFilter support', async () => \{
			    const update = createEvent<number>()
			    const store = createStore(0).on(update, (_, x) => x)
			
			    const View = () => \{
			      const x = useStoreMap(\{
			        store,
			        keys: [],
			        fn: x => x,
			        updateFilter: (x: number, y) => x % 2 === 0,
			      \})
			      return <div>\{x\}</div>
			    \}
			    const App = () => <View />
			    const \{container\} = await render(App)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        0
			      </div>
			    \`)
			    update(2)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        2
			      </div>
			    \`)
			    update(3)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        2
			      </div>
			    \`)
			  \})
			  test('issue #643: should return the same result as useStore, when used with the same mapper', async () => \{
			    const update = createEvent<number>()
			    const store = createStore(0).on(update, (_, x) => x)
			    const mapper = (x: number) => x + 1
			
			    const View = () => \{
			      const baseX = createMemo(() => mapper(useUnit(store)()))
			      const x = useStoreMap(store, mapper)
			      return <div>\{x() === baseX() ? 'equal' : 'not_equal'\}</div>
			    \}
			    const App = () => <View />
			    const \{container\} = await render(App)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        equal
			      </div>
			    \`)
			    update(2)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        equal
			      </div>
			    \`)
			    update(3)
			    expect(container.firstChild).toMatchInlineSnapshot(\`
			      <div>
			        equal
			      </div>
			    \`)
			  \})
			\})
			describe('useUnit with force scope', () => \{
			  let consoleError: any
			  beforeEach(() => \{
			    consoleError = console.error
			    console.error = () => \{\}
			  \})
			  afterEach(() => \{
			    console.error = consoleError
			  \})
			  describe('forceScope options not set', () => \{
			    it('without context', async () => \{
			      const \$a = createStore(42)
			
			      const View = () => \{
			        const a = useUnit(\$a)
			
			        return <div>\{a\}</div>
			      \}
			
			      const \{container\} = await render(View)
			
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          42
			        </div>
			      \`)
			    \})
			    test('with context', async () => \{
			      const \$value = createStore('value')
			
			      const Component = () => \{
			        const value = useUnit(\$value)
			
			        return <div>\{value\}</div>
			      \}
			
			      const scope = fork(\{values: [[\$value, 'scoped value']]\})
			
			      const \{container\} = await render(() => (
			        <Provider value=\{scope\}>
			          <Component />
			        </Provider>
			      ))
			
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          scoped value
			        </div>
			      \`)
			    \})
			  \})
			  describe('forceScope disabled', () => \{
			    it('without context', async () => \{
			      const \$a = createStore(42)
			
			      const View = () => \{
			        const a = useUnit(\$a, \{forceScope: false\})
			
			        return <div>\{a\}</div>
			      \}
			
			      const \{container\} = await render(View)
			
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          42
			        </div>
			      \`)
			    \})
			    test('with context', async () => \{
			      const \$value = createStore('value')
			
			      const Component = () => \{
			        const value = useUnit(\$value, \{forceScope: false\})
			
			        return <div>\{value\}</div>
			      \}
			
			      const scope = fork(\{values: [[\$value, 'scoped value']]\})
			
			      const \{container\} = await render(() => (
			        <Provider value=\{scope\}>
			          <Component />
			        </Provider>
			      ))
			
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          scoped value
			        </div>
			      \`)
			    \})
			  \})
			  describe('forceScope enabled', () => \{
			    it('without context', async () => \{
			      const \$a = createStore(42)
			
			      const View = () => \{
			        const a = useUnit(\$a, \{forceScope: true\})
			
			        return <div>\{a\}</div>
			      \}
			
			      expect(async () => await render(View)).rejects.toThrow(
			        'No scope found, consider adding <Provider> to app root',
			      )
			    \})
			    test('with context', async () => \{
			      const \$value = createStore('value')
			
			      const Component = () => \{
			        const value = useUnit(\$value, \{forceScope: true\})
			
			        return <div>\{value\}</div>
			      \}
			
			      const scope = fork(\{values: [[\$value, 'scoped value']]\})
			
			      const \{container\} = await render(() => (
			        <Provider value=\{scope\}>
			          <Component />
			        </Provider>
			      ))
			
			      expect(container.firstChild).toMatchInlineSnapshot(\`
			        <div>
			          scoped value
			        </div>
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\solid\\__tests__\\useUnit.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(13)
    });
    it('effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\boolAndFlag.test.ts', () => {
        const sourceCode = `
			import \{suiteGenerator\} from '../generateCases'
			import \{
			  computeFn,
			  union,
			  value,
			  separate,
			  flag,
			  config,
			  bool,
			\} from '../operators'
			
			describe('flag', () => \{
			  test('basic case', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['event', 'store'], 'source')
			      const clock = union(['store', 'event', 'none '], 'clock')
			      const feature = flag(\{
			        name: 'feature',
			      \})
			
			      const tag = separate(\{
			        name: 'tag',
			        source: \{source, clock, feature\},
			        variant: \{
			          base: \{
			            events: \{source: 'event', clock: 'event'\},
			            noClock: \{clock: 'none '\},
			            sourceStore: \{source: 'store'\},
			            rest: \{\},
			          \} as const,
			          byFeature: \{
			            aBranch: \{feature: true\},
			            bBranch: \{feature: false\},
			          \} as const,
			        \},
			        cases: \{
			          events: value('events only'),
			          noClock: \{
			            aBranch: value('no a clock'),
			            bBranch: value('no b clock'),
			          \},
			          sourceStore: value('source store'),
			          rest: \{
			            aBranch: value('rest a'),
			            bBranch: value('rest b'),
			          \},
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source, clock, feature],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, clock, feature, tag],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * source * clock * feature * tag          * 
			      | event  | store | false   | rest b       | 
			      | event  | store | true    | rest a       | 
			      | event  | event | false   | events only  | 
			      | event  | event | true    | events only  | 
			      | event  | none  | false   | no b clock   | 
			      | event  | none  | true    | no a clock   | 
			      | store  | store | false   | source store | 
			      | store  | store | true    | source store | 
			      | store  | event | false   | source store | 
			      | store  | event | true    | source store | 
			      | store  | none  | false   | no b clock   | 
			      | store  | none  | true    | no a clock   | 
			      "
			    \`)
			  \})
			  test('avoid', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['event', 'store'], 'source')
			      const clock = union(['store', 'event', 'none '], 'clock')
			      const featureA = flag(\{
			        name: 'featureA',
			      \})
			      const featureB = flag(\{
			        name: 'featureB',
			        avoid: [featureA],
			      \})
			
			      const tag = separate(\{
			        name: 'tag',
			        source: \{source, clock, featureA, featureB\},
			        variant: \{
			          base: \{
			            events: \{source: 'event', clock: 'event'\},
			            noClock: \{clock: 'none '\},
			            sourceStore: \{source: 'store'\},
			            rest: \{\},
			          \},
			          byFeature: \{
			            aBranch: \{featureA: true\},
			            bBranch: \{featureB: true\},
			            none: \{featureA: false, featureB: false\},
			          \},
			        \} as const,
			        cases: \{
			          events: value('events only'),
			          noClock: \{
			            aBranch: value('no a clock'),
			            bBranch: value('no b clock'),
			            none: value('no a|b none'),
			          \},
			          sourceStore: value('source store'),
			          rest: \{
			            aBranch: value('rest a'),
			            bBranch: value('rest b'),
			            none: value('rest none'),
			          \},
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source, clock, featureA, featureB],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, clock, featureA, featureB, tag],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			"
			## pass
			* source * clock * featureA * featureB * tag          * 
			| event  | store | false    | false    | rest none    | 
			| event  | store | false    | true     | rest b       | 
			| event  | store | true     | false    | rest a       | 
			| event  | store | true     | true     | rest a       | 
			| event  | event | false    | false    | events only  | 
			| event  | event | false    | true     | events only  | 
			| event  | event | true     | false    | events only  | 
			| event  | event | true     | true     | events only  | 
			| event  | none  | false    | false    | no a|b none  | 
			| event  | none  | false    | true     | no b clock   | 
			| event  | none  | true     | false    | no a clock   | 
			| event  | none  | true     | true     | no a clock   | 
			| store  | store | false    | false    | source store | 
			| store  | store | false    | true     | source store | 
			| store  | store | true     | false    | source store | 
			| store  | store | true     | true     | source store | 
			| store  | event | false    | false    | source store | 
			| store  | event | false    | true     | source store | 
			| store  | event | true     | false    | source store | 
			| store  | event | true     | true     | source store | 
			| store  | none  | false    | false    | no a|b none  | 
			| store  | none  | false    | true     | no b clock   | 
			| store  | none  | true     | false    | no a clock   | 
			| store  | none  | true     | true     | no a clock   | 
			"
			\`)
			  \})
			\})
			
			describe('bool', () => \{
			  test('basic case', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b', 'c'], 'union')
			      const tag = bool(\{
			        name: 'tag',
			        source: \{source\},
			        true: \{source: 'a'\},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, tag],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * union * tag   * 
			      | a     | true  | 
			      | b     | false | 
			      | c     | false | 
			      "
			    \`)
			  \})
			  test('array support', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b', 'c'], 'union')
			      const tag = bool(\{
			        name: 'tag',
			        source: \{source\},
			        true: [\{source: 'a'\}, \{source: 'b'\}],
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, tag],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * union * tag   * 
			      | a     | true  | 
			      | b     | true  | 
			      | c     | false | 
			      "
			    \`)
			  \})
			  test('non-exhaustive', () => \{
			    expect(() => \{
			      suiteGenerator(() => \{
			        const source = union(['a', 'b', 'c'], 'source')
			        const pass = bool(\{
			          name: 'pass',
			          source: \{source\},
			          true: \{source: 'a'\},
			          false: \{source: 'b'\},
			        \})
			
			        const failed = computeFn(\{
			          source: \{pass\},
			          name: 'failed',
			          fn: (\{pass\}) => !pass,
			        \})
			
			        config(\{
			          grouping: \{
			            getHash: [source, failed],
			            describeGroup: value(''),
			            pass,
			            createTestLines: \{
			              method: 'method',
			              shape: \{source\},
			              addExpectError: failed,
			            \},
			          \},
			        \})
			      \})
			    \}).toThrowErrorMatchingInlineSnapshot(
			      \`"either true or false should be defined but not both"\`,
			    )
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\boolAndFlag.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\computeVariants.test.ts', () => {
        const sourceCode = `
			import \{suiteGenerator\} from '../generateCases'
			import \{union, value, computeVariants, config\} from '../operators'
			
			test('basic case', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b'], 'feature')
			
			    const tag = computeVariants(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          bBranch: \{feature: 'b'\},
			        \},
			      \},
			      cases: \{
			        events: 'events only',
			        noClock: \{
			          aBranch: 'no a clock',
			          bBranch: 'no b clock',
			        \},
			        sourceStore: 'source store',
			        rest: \{
			          aBranch: 'rest a',
			          bBranch: 'rest b',
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b       | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b clock   | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b clock   | 
			    "
			  \`)
			\})
			test('unused match group', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b'], 'feature')
			
			    const tag = computeVariants(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          bBranch: \{feature: 'b'\},
			        \},
			      \},
			      cases: \{
			        events: 'events only',
			        noClock: 'no clock',
			        sourceStore: 'source store',
			        rest: 'rest',
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest         | 
			    | event  | store | b       | rest         | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | none  | a       | no clock     | 
			    | event  | none  | b       | no clock     | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | none  | a       | no clock     | 
			    | store  | none  | b       | no clock     | 
			    "
			  \`)
			\})
			test('unused match', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b', 'c'], 'feature')
			
			    const tag = computeVariants(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          bBranch: \{feature: 'b'\},
			        \},
			      \},
			      cases: \{
			        events: 'events only',
			        noClock: \{
			          aBranch: 'no a clock',
			          bBranch: 'no b clock',
			        \},
			        sourceStore: 'source store',
			        rest: \{
			          aBranch: 'rest a',
			          bBranch: 'rest b',
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b       | 
			    | event  | store | c       |              | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | event | c       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b clock   | 
			    | event  | none  | c       |              | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | store | c       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | event | c       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b clock   | 
			    | store  | none  | c       | source store | 
			    "
			  \`)
			\})
			test('rest match', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b', 'c'], 'feature')
			
			    const tag = computeVariants(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          restBranch: \{\},
			        \},
			      \},
			      cases: \{
			        events: 'events only',
			        noClock: \{
			          aBranch: 'no a clock',
			          restBranch: 'no b|c clock',
			        \},
			        sourceStore: 'source store',
			        rest: \{
			          aBranch: 'rest a',
			          restBranch: 'rest b|c',
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b|c     | 
			    | event  | store | c       | rest b|c     | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | event | c       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b|c clock | 
			    | event  | none  | c       | no b|c clock | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | store | c       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | event | c       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b|c clock | 
			    | store  | none  | c       | no b|c clock | 
			    "
			  \`)
			\})
			test('array match', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b', 'c'], 'feature')
			
			    const tag = computeVariants(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          restBranch: [\{feature: 'b'\}, \{feature: 'c'\}],
			        \},
			      \},
			      cases: \{
			        events: 'events only',
			        noClock: \{
			          aBranch: 'no a clock',
			          restBranch: 'no b|c clock',
			        \},
			        sourceStore: 'source store',
			        rest: \{
			          aBranch: 'rest a',
			          restBranch: 'rest b|c',
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b|c     | 
			    | event  | store | c       | rest b|c     | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | event | c       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b|c clock | 
			    | event  | none  | c       | no b|c clock | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | store | c       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | event | c       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b|c clock | 
			    | store  | none  | c       | no b|c clock | 
			    "
			  \`)
			\})
			// test('field validation')
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\computeVariants.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\separate.test.ts', () => {
        const sourceCode = `
			import \{suiteGenerator\} from '../generateCases'
			import \{
			  computeFn,
			  union,
			  value,
			  computeVariant,
			  computeVariants,
			  separate,
			  flag,
			  config,
			  bool,
			\} from '../operators'
			
			test('basic case', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b'], 'feature')
			
			    const tag = separate(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          bBranch: \{feature: 'b'\},
			        \},
			      \} as const,
			      cases: \{
			        events: value('events only'),
			        noClock: \{
			          aBranch: value('no a clock'),
			          bBranch: value('no b clock'),
			        \},
			        sourceStore: value('source store'),
			        rest: \{
			          aBranch: value('rest a'),
			          bBranch: value('rest b'),
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b       | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b clock   | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b clock   | 
			    "
			  \`)
			\})
			test('unused match group', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b'], 'feature')
			
			    const tag = separate(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          bBranch: \{feature: 'b'\},
			        \},
			      \} as const,
			      cases: \{
			        events: value('events only'),
			        noClock: value('no clock'),
			        sourceStore: value('source store'),
			        rest: value('rest'),
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest         | 
			    | event  | store | b       | rest         | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | none  | a       | no clock     | 
			    | event  | none  | b       | no clock     | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | none  | a       | no clock     | 
			    | store  | none  | b       | no clock     | 
			    "
			  \`)
			\})
			test('unused match', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b', 'c'], 'feature')
			
			    const tag = separate(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          bBranch: \{feature: 'b'\},
			        \},
			      \} as const,
			      cases: \{
			        events: value('events only'),
			        noClock: \{
			          aBranch: value('no a clock'),
			          bBranch: value('no b clock'),
			        \},
			        sourceStore: value('source store'),
			        rest: \{
			          aBranch: value('rest a'),
			          bBranch: value('rest b'),
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b       | 
			    | event  | store | c       |              | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | event | c       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b clock   | 
			    | event  | none  | c       |              | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | store | c       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | event | c       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b clock   | 
			    | store  | none  | c       | source store | 
			    "
			  \`)
			\})
			test('rest match', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b', 'c'], 'feature')
			
			    const tag = separate(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          restBranch: \{\},
			        \},
			      \} as const,
			      cases: \{
			        events: value('events only'),
			        noClock: \{
			          aBranch: value('no a clock'),
			          restBranch: value('no b|c clock'),
			        \},
			        sourceStore: value('source store'),
			        rest: \{
			          aBranch: value('rest a'),
			          restBranch: value('rest b|c'),
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b|c     | 
			    | event  | store | c       | rest b|c     | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | event | c       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b|c clock | 
			    | event  | none  | c       | no b|c clock | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | store | c       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | event | c       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b|c clock | 
			    | store  | none  | c       | no b|c clock | 
			    "
			  \`)
			\})
			test('array match', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store'], 'source')
			    const clock = union(['store', 'event', 'none '], 'clock')
			    const feature = union(['a', 'b', 'c'], 'feature')
			
			    const tag = separate(\{
			      name: 'tag',
			      source: \{source, clock, feature\},
			      variant: \{
			        base: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \} as const,
			        byFeature: \{
			          aBranch: \{feature: 'a'\},
			          restBranch: [\{feature: 'b'\}, \{feature: 'c'\}],
			        \} as const,
			      \},
			      cases: \{
			        events: value('events only'),
			        noClock: \{
			          aBranch: value('no a clock'),
			          restBranch: value('no b|c clock'),
			        \},
			        sourceStore: value('source store'),
			        rest: \{
			          aBranch: value('rest a'),
			          restBranch: value('rest b|c'),
			        \},
			      \},
			    \})
			    config(\{
			      grouping: \{
			        getHash: [source, clock, feature],
			        describeGroup: value(''),
			        pass: value(true),
			        createTestLines: \{
			          type: 'table',
			          fields: [source, clock, feature, tag],
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "
			    ## pass
			    * source * clock * feature * tag          * 
			    | event  | store | a       | rest a       | 
			    | event  | store | b       | rest b|c     | 
			    | event  | store | c       | rest b|c     | 
			    | event  | event | a       | events only  | 
			    | event  | event | b       | events only  | 
			    | event  | event | c       | events only  | 
			    | event  | none  | a       | no a clock   | 
			    | event  | none  | b       | no b|c clock | 
			    | event  | none  | c       | no b|c clock | 
			    | store  | store | a       | source store | 
			    | store  | store | b       | source store | 
			    | store  | store | c       | source store | 
			    | store  | event | a       | source store | 
			    | store  | event | b       | source store | 
			    | store  | event | c       | source store | 
			    | store  | none  | a       | no a clock   | 
			    | store  | none  | b       | no b|c clock | 
			    | store  | none  | c       | no b|c clock | 
			    "
			  \`)
			\})
			describe('branching', () => \{
			  test('execution of cases', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b'])
			      const clock = union(['A', 'B'])
			      const feature = flag(\{\})
			      const fn = computeVariant(\{
			        source: \{source\},
			        variant: \{
			          hasFn: \{source: 'a'\},
			          noFn: \{\},
			        \},
			        cases: \{
			          hasFn: 'function',
			          noFn: null,
			        \},
			      \})
			
			      const tag = separate(\{
			        source: \{feature\},
			        variant: \{
			          byFeature: \{
			            aBranch: \{feature: true\},
			            none: \{feature: false\},
			          \},
			        \} as const,
			        cases: \{
			          aBranch: separate(\{
			            source: \{clock\},
			            variant: \{
			              _: \{
			                a: \{clock: 'A'\},
			                b: \{\},
			              \},
			            \} as const,
			            cases: \{
			              a: union(['a1', 'a2']),
			              b: union(['b1', 'b2']),
			            \},
			          \}),
			          none: union(['c1', 'c2']),
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source, feature, clock, tag],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: \{source, feature, clock, tag\},
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * source * feature * clock * tag * 
			      | a      | false   | A     | c1  | 
			      | a      | false   | A     | c2  | 
			      | a      | true    | A     | a1  | 
			      | a      | true    | A     | a2  | 
			      | a      | false   | B     | c1  | 
			      | a      | false   | B     | c2  | 
			      | a      | true    | B     | b1  | 
			      | a      | true    | B     | b2  | 
			      | b      | false   | A     | c1  | 
			      | b      | false   | A     | c2  | 
			      | b      | true    | A     | a1  | 
			      | b      | true    | A     | a2  | 
			      | b      | false   | B     | c1  | 
			      | b      | false   | B     | c2  | 
			      | b      | true    | B     | b1  | 
			      | b      | true    | B     | b2  | 
			      "
			    \`)
			  \})
			  test('case safety (cases executed only when they are choosen)', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b'])
			      const fn = computeVariant(\{
			        source: \{source\},
			        variant: \{
			          hasFn: \{source: 'a'\},
			          noFn: \{\},
			        \},
			        cases: \{
			          hasFn: 'fn',
			          noFn: null,
			        \},
			      \})
			
			      const tag = separate(\{
			        source: \{source\},
			        variant: \{
			          byFeature: \{
			            hasFn: \{source: 'a'\},
			            none: \{\},
			          \},
			        \} as const,
			        cases: \{
			          hasFn: computeFn(\{
			            source: \{fn\},
			            fn: (\{fn\}) => fn!.toUpperCase(),
			          \}),
			          none: value(null),
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: \{source, fn, tag\},
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * source * fn   * tag  * 
			      | a      | fn   | FN   | 
			      | b      | null | null | 
			      "
			    \`)
			  \})
			  test.skip('source safety (source executed only when result is needed for something else)', () => \{
			    const jestFn = jest.fn((\{fn\}: \{fn: string | null\}) => fn!.toUpperCase())
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b'])
			      const fn = computeVariant(\{
			        source: \{source\},
			        variant: \{
			          hasFn: \{source: 'a'\},
			          noFn: \{\},
			        \},
			        cases: \{
			          hasFn: 'fn',
			          noFn: null,
			        \},
			      \})
			
			      const tag = separate(\{
			        source: \{source\},
			        variant: \{
			          byFeature: \{
			            hasFn: \{source: 'a'\},
			            none: \{\},
			          \},
			        \} as const,
			        cases: \{
			          hasFn: computeFn(\{
			            source: \{
			              uppercased: computeFn(\{
			                source: \{fn\},
			                fn: jestFn,
			              \}),
			            \},
			            fn: (\{uppercased\}) => uppercased,
			          \}),
			          none: value(null),
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: \{source, fn, tag\},
			          \},
			        \},
			      \})
			    \})
			    expect(jestFn.mock.results.map((\{type\}) => type)).not.toContain('throw')
			  \})
			\})
			// test('field validation')
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\separate.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\suiteGenerator.test.ts', () => {
        const sourceCode = `
			import \{printArray\} from '../../text'
			import \{suiteGenerator\} from '../generateCases'
			import \{
			  computeFn,
			  union,
			  value,
			  computeVariant,
			  computeVariants,
			  separate,
			  flag,
			  config,
			  bool,
			  permute,
			\} from '../operators'
			
			test('it works', () => \{
			  const suite = suiteGenerator(() => \{
			    const source = union(['event', 'store', 'combinable'], 'source')
			    const clock = union(['none', 'event', 'store', 'tuple'], 'clock')
			
			    config(\{
			      grouping: \{
			        getHash: [source, clock],
			        describeGroup: source,
			        pass: value(true),
			        createTestLines: \{
			          method: 'method',
			          shape: \{
			            src: source,
			            clk: clock,
			          \},
			        \},
			      \},
			    \})
			  \})
			  expect(suite).toMatchInlineSnapshot(\`
			    "test('event (should pass)', () => \{
			      //prettier-ignore
			      \{
			        method(\{src:event, clk:none \})
			        method(\{src:event, clk:event\})
			        method(\{src:event, clk:store\})
			        method(\{src:event, clk:tuple\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot()
			    \})
			    test('store (should pass)', () => \{
			      //prettier-ignore
			      \{
			        method(\{src:store, clk:none \})
			        method(\{src:store, clk:event\})
			        method(\{src:store, clk:store\})
			        method(\{src:store, clk:tuple\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot()
			    \})
			    test('combinable (should pass)', () => \{
			      //prettier-ignore
			      \{
			        method(\{src:combinable, clk:none \})
			        method(\{src:combinable, clk:event\})
			        method(\{src:combinable, clk:store\})
			        method(\{src:combinable, clk:tuple\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot()
			    \})"
			  \`)
			\})
			describe('group', () => \{
			  test('group by union value', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['event', 'store', 'combinable'], 'source')
			      const clock = union(['none', 'event', 'store', 'tuple'], 'clock')
			
			      const pass = value(true, 'pass')
			      config(\{
			        grouping: \{
			          getHash: [source, clock],
			          describeGroup: value(''),
			          pass,
			          createTestLines: \{
			            method: 'method',
			            shape: \{
			              src: source,
			              clk: clock,
			            \},
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "test(' (should pass)', () => \{
			        //prettier-ignore
			        \{
			          method(\{src:event     , clk:none \})
			          method(\{src:event     , clk:event\})
			          method(\{src:event     , clk:store\})
			          method(\{src:event     , clk:tuple\})
			          method(\{src:store     , clk:none \})
			          method(\{src:store     , clk:event\})
			          method(\{src:store     , clk:store\})
			          method(\{src:store     , clk:tuple\})
			          method(\{src:combinable, clk:none \})
			          method(\{src:combinable, clk:event\})
			          method(\{src:combinable, clk:store\})
			          method(\{src:combinable, clk:tuple\})
			        \}
			        expect(typecheck).toMatchInlineSnapshot()
			      \})"
			    \`)
			  \})
			  describe('pass', () => \{
			    test('pass by union value', () => \{
			      const suite = suiteGenerator(() => \{
			        const source = union(['event', 'store'], 'source')
			        const clock = union(['none', 'event'], 'clock')
			
			        config(\{
			          grouping: \{
			            getHash: [source, clock],
			            describeGroup: source,
			            pass: computeFn(\{
			              name: 'pass',
			              source: \{source\},
			              fn: (\{source\}) => source === 'event',
			            \}),
			            createTestLines: \{
			              method: 'method',
			              shape: \{
			                src: source,
			                clk: clock,
			              \},
			            \},
			          \},
			        \})
			      \})
			      expect(suite).toMatchInlineSnapshot(\`
			        "test('event (should pass)', () => \{
			          //prettier-ignore
			          \{
			            method(\{src:event, clk:none \})
			            method(\{src:event, clk:event\})
			          \}
			          expect(typecheck).toMatchInlineSnapshot()
			        \})
			        test('store (should fail)', () => \{
			          //prettier-ignore
			          \{
			            //@ts-expect-error
			            method(\{src:store, clk:none \})
			            //@ts-expect-error
			            method(\{src:store, clk:event\})
			          \}
			          expect(typecheck).toMatchInlineSnapshot()
			        \})"
			      \`)
			    \})
			    test('edge case when pass field split groups', () => \{
			      const suite = suiteGenerator(() => \{
			        const source = union(['event', 'store'], 'source')
			        const clock = union(['none', 'event'], 'clock')
			
			        config(\{
			          grouping: \{
			            getHash: [source, clock],
			            describeGroup: source,
			            pass: computeFn(\{
			              name: 'pass',
			              source: \{clock\},
			              fn: (\{clock\}) => clock === 'event',
			            \}),
			            createTestLines: \{
			              method: 'method',
			              shape: \{
			                src: source,
			                clk: clock,
			              \},
			            \},
			          \},
			        \})
			      \})
			      expect(suite).toMatchInlineSnapshot(\`
			        "describe('event', () => \{
			          test('event (should pass)', () => \{
			            //prettier-ignore
			            method(\{src:event, clk:event\})
			            expect(typecheck).toMatchInlineSnapshot()
			          \})
			          test('event (should fail)', () => \{
			            //prettier-ignore
			            //@ts-expect-error
			            method(\{src:event, clk:none\})
			            expect(typecheck).toMatchInlineSnapshot()
			          \})
			        \})
			        describe('store', () => \{
			          test('store (should pass)', () => \{
			            //prettier-ignore
			            method(\{src:store, clk:event\})
			            expect(typecheck).toMatchInlineSnapshot()
			          \})
			          test('store (should fail)', () => \{
			            //prettier-ignore
			            //@ts-expect-error
			            method(\{src:store, clk:none\})
			            expect(typecheck).toMatchInlineSnapshot()
			          \})
			        \})"
			      \`)
			    \})
			  \})
			\})
			
			describe('config', () => \{
			  it('throw error when config is not called', () => \{
			    expect(() => \{
			      suiteGenerator(() => \{
			        union(['event', 'store', 'combinable'], 'source')
			      \})
			    \}).toThrowErrorMatchingInlineSnapshot(\`"no config() used"\`)
			  \})
			  it('throw error when required fields are missed', () => \{
			    expect(() => \{
			      suiteGenerator(() => \{
			        union(['event', 'store', 'combinable'], 'source')
			        config(\{
			          grouping: \{getHash: () => ''\},
			        \})
			      \})
			    \}).toThrowErrorMatchingInlineSnapshot(\`
			      "required config items are missed:
			      grouping.describeGroup
			      grouping.createTestLines"
			    \`)
			  \})
			  describe('getHash', () => \{
			    test('function', () => \{
			      const suite = suiteGenerator(() => \{
			        const source = union(['event', 'store'], 'source')
			        const clock = union(['store', 'event', 'none '], 'clock')
			        const tag = computeVariant(\{
			          name: 'tag',
			          source: \{source, clock\},
			          variant: \{
			            events: \{source: 'event', clock: 'event'\},
			            noClock: \{clock: 'none '\},
			            sourceStore: \{source: 'store'\},
			            rest: \{\},
			          \},
			          cases: \{
			            events: 'events only',
			            noClock: 'no clock',
			            sourceStore: 'source store',
			            rest: 'rest',
			          \},
			        \})
			        config(\{
			          grouping: \{
			            getHash: [source, clock],
			            describeGroup: value(''),
			            pass: value(true),
			            createTestLines: \{
			              type: 'table',
			              fields: [source, clock, tag],
			            \},
			          \},
			        \})
			      \})
			      expect(suite).toMatchInlineSnapshot(\`
			        "
			        ## pass
			        * source * clock * tag          * 
			        | event  | store | rest         | 
			        | event  | event | events only  | 
			        | event  | none  | no clock     | 
			        | store  | store | source store | 
			        | store  | event | source store | 
			        | store  | none  | no clock     | 
			        "
			      \`)
			    \})
			    test('silent hash clash', () => \{
			      const suite = suiteGenerator(() => \{
			        const source = union(['event', 'store'], 'source')
			        const clock = union(['store', 'event', 'none '], 'clock')
			        const tag = computeVariant(\{
			          name: 'tag',
			          source: \{source, clock\},
			          variant: \{
			            events: \{source: 'event', clock: 'event'\},
			            noClock: \{clock: 'none '\},
			            sourceStore: \{source: 'store'\},
			            rest: \{\},
			          \},
			          cases: \{
			            events: 'events only',
			            noClock: 'no clock',
			            sourceStore: 'source store',
			            rest: 'rest',
			          \},
			        \})
			        config(\{
			          grouping: \{
			            getHash: [source],
			            describeGroup: value(''),
			            pass: value(true),
			            createTestLines: \{
			              type: 'table',
			              fields: [source, clock, tag],
			            \},
			          \},
			        \})
			      \})
			      expect(suite).toMatchInlineSnapshot(\`
			        "
			        ## pass
			        * source * clock * tag          * 
			        | event  | store | rest         | 
			        | event  | event | events only  | 
			        | event  | none  | no clock     | 
			        | store  | store | source store | 
			        | store  | event | source store | 
			        | store  | none  | no clock     | 
			        "
			      \`)
			    \})
			    test('real hash clash', () => \{
			      const suite = suiteGenerator(() => \{
			        const source = union(['event', 'store'], 'source')
			        const clock = union(['store', 'event', 'none '], 'clock')
			        const tag = computeVariant(\{
			          name: 'tag',
			          source: \{source, clock\},
			          variant: \{
			            events: \{source: 'event', clock: 'event'\},
			            noClock: \{clock: 'none '\},
			            sourceStore: \{source: 'store'\},
			            rest: \{\},
			          \},
			          cases: \{
			            events: 'events only',
			            noClock: 'no clock',
			            sourceStore: 'source store',
			            rest: 'rest',
			          \},
			        \})
			        config(\{
			          grouping: \{
			            getHash: [source],
			            describeGroup: source,
			            pass: value(true),
			            createTestLines: \{
			              type: 'table',
			              fields: [source, clock, tag],
			            \},
			          \},
			        \})
			      \})
			      expect(suite).toMatchInlineSnapshot(\`
			        "
			        ## event (pass)
			        * source * clock * tag         * 
			        | event  | store | rest        | 
			        | event  | event | events only | 
			        | event  | none  | no clock    | 
			
			        ## store (pass)
			        * source * clock * tag          * 
			        | store  | store | source store | 
			        | store  | event | source store | 
			        | store  | none  | no clock     | 
			        "
			      \`)
			    \})
			    test('real hash/describeGroup clash', () => \{
			      const suite = suiteGenerator(() => \{
			        const source = union(['event', 'store'], 'source')
			        const clock = union(['store', 'event', 'none '], 'clock')
			        const tag = computeVariant(\{
			          name: 'tag',
			          source: \{source, clock\},
			          variant: \{
			            events: \{source: 'event', clock: 'event'\},
			            noClock: \{clock: 'none '\},
			            sourceStore: \{source: 'store'\},
			            rest: \{\},
			          \},
			          cases: \{
			            events: 'events only',
			            noClock: 'no clock',
			            sourceStore: 'source store',
			            rest: 'rest',
			          \},
			        \})
			        config(\{
			          grouping: \{
			            getHash: [source],
			            describeGroup: clock,
			            pass: value(true),
			            createTestLines: \{
			              type: 'table',
			              fields: [source, clock, tag],
			            \},
			          \},
			        \})
			      \})
			      expect(suite).toMatchInlineSnapshot(\`
			        "
			        ## none  (pass)
			        * source * clock * tag          * 
			        | event  | store | rest         | 
			        | event  | event | events only  | 
			        | event  | none  | no clock     | 
			        | store  | store | source store | 
			        | store  | event | source store | 
			        | store  | none  | no clock     | 
			        "
			      \`)
			    \})
			  \})
			\})
			
			describe('computeVariant', () => \{
			  test('basic case', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['event', 'store'], 'source')
			      const clock = union(['store', 'event', 'none '], 'clock')
			      const tag = computeVariant(\{
			        name: 'tag',
			        source: \{source, clock\},
			        variant: \{
			          events: \{source: 'event', clock: 'event'\},
			          noClock: \{clock: 'none '\},
			          sourceStore: \{source: 'store'\},
			          rest: \{\},
			        \},
			        cases: \{
			          events: 'events only',
			          noClock: 'no clock',
			          sourceStore: 'source store',
			          rest: 'rest',
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source, clock],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, clock, tag],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * source * clock * tag          * 
			      | event  | store | rest         | 
			      | event  | event | events only  | 
			      | event  | none  | no clock     | 
			      | store  | store | source store | 
			      | store  | event | source store | 
			      | store  | none  | no clock     | 
			      "
			    \`)
			  \})
			\})
			
			describe('name usage', () => \{
			  test('inline operator with name', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b'], 'source')
			      const feature = flag(\{
			        name: 'feature',
			      \})
			
			      const tag = separate(\{
			        name: 'tag',
			        source: \{feature\},
			        variant: \{
			          byFeature: \{
			            aBranch: \{feature: true\},
			            none: \{feature: false\},
			          \},
			        \} as const,
			        cases: \{
			          aBranch: value('-'),
			          none: union(['A', 'B'], 'clock'),
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source, feature],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, feature, tag],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * source * feature * tag * 
			      | a      | false   | A   | 
			      | a      | false   | B   | 
			      | a      | false   | A   | 
			      | a      | false   | B   | 
			      | a      | true    | -   | 
			      | a      | true    | -   | 
			      | b      | false   | A   | 
			      | b      | false   | B   | 
			      | b      | false   | A   | 
			      | b      | false   | B   | 
			      | b      | true    | -   | 
			      | b      | true    | -   | 
			      "
			    \`)
			  \})
			  test('inline operator without name', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b'], 'source')
			      const feature = flag(\{
			        name: 'feature',
			      \})
			
			      const tag = separate(\{
			        name: 'tag',
			        source: \{feature\},
			        variant: \{
			          byFeature: \{
			            aBranch: \{feature: true\},
			            none: \{feature: false\},
			          \},
			        \} as const,
			        cases: \{
			          aBranch: value('-'),
			          none: union(['A', 'B']),
			        \},
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source, feature],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, feature, tag],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			      "
			      ## pass
			      * source * feature * tag * 
			      | a      | false   | A   | 
			      | a      | false   | B   | 
			      | a      | true    | -   | 
			      | b      | false   | A   | 
			      | b      | false   | B   | 
			      | b      | true    | -   | 
			      "
			    \`)
			  \})
			  test('flag edge case', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = union(['a', 'b', 'c'], 'source')
			      const feature = flag(\{
			        name: 'feature',
			        needs: [
			          computeVariants(\{
			            source: \{source\},
			            variant: \{
			              src: \{
			                a: \{source: 'a'\},
			                b: \{source: 'b'\},
			              \},
			            \},
			            cases: \{
			              a: false,
			              b: true,
			            \},
			          \}),
			        ],
			      \})
			      config(\{
			        grouping: \{
			          getHash: [source, feature],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: [source, feature],
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			"
			## pass
			* source * feature * 
			| a      | false   | 
			| b      | false   | 
			| b      | true    | 
			| c      | false   | 
			"
			\`)
			  \})
			\})
			
			describe('permute', () => \{
			  test('basic case', () => \{
			    const suite = suiteGenerator(() => \{
			      const source = permute(\{
			        items: ['a', 'b', 'c', 'd'],
			        noReorder: true,
			        amount: \{min: 1, max: 2\},
			      \})
			      const result = computeFn(\{
			        source: \{source\},
			        fn: (\{source\}) => printArray(source),
			      \})
			      config(\{
			        grouping: \{
			          getHash: [result],
			          describeGroup: value(''),
			          pass: value(true),
			          createTestLines: \{
			            type: 'table',
			            fields: \{result\},
			          \},
			        \},
			      \})
			    \})
			    expect(suite).toMatchInlineSnapshot(\`
			"
			## pass
			* result * 
			| [a]    | 
			| [b]    | 
			| [c]    | 
			| [d]    | 
			| [a,b]  | 
			| [a,c]  | 
			| [a,d]  | 
			| [b,d]  | 
			| [c,b]  | 
			| [c,d]  | 
			| [d,b]  | 
			"
			\`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\src\\runner\\manifold\\__tests__\\suiteGenerator.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(15)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\attach.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEffect, attach, Effect\} from 'effector'
			
			const typecheck = '\{global\}'
			
			describe('explicit generics', () => \{
			  test('attach<params, source, effect>', () => \{
			    const source = createStore(0)
			    const effect = createEffect((\{foo\}: \{foo: number\}) => foo)
			    const fx = attach<number, typeof source, typeof effect>(\{
			      source,
			      effect,
			      mapParams: (params, source) => (\{foo: params + source\}),
			    \})
			    const assert: Effect<number, number> = fx
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('attach<params, effect>', () => \{
			    const effect = createEffect((\{foo\}: \{foo: number\}) => foo)
			    const fx = attach<number, typeof effect>(\{
			      effect,
			      mapParams: params => (\{foo: params\}),
			    \})
			    const assert: Effect<number, number> = fx
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('with source', () => \{
			  test('with single store (should pass)', () => \{
			    const foo = createStore<string>('foo')
			    //prettier-ignore
			    const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			    const fx: Effect<string, string, \{message: string\}> = attach(\{
			      effect,
			      source: foo,
			      mapParams: (text, foo: string) => (\{foo: \`\$\{text\}\$\{foo\}\`\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('with shape (should pass)', () => \{
			    const foo = createStore<string>('foo')
			    //prettier-ignore
			    const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			    const fx: Effect<string, string, \{message: string\}> = attach(\{
			      effect,
			      source: \{foo\},
			      mapParams: (text, \{foo\}) => (\{foo: \`\$\{text\}\$\{foo\}\`\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			test('without source (should pass)', () => \{
			  //prettier-ignore
			  const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			  const fx: Effect<string, string, \{message: string\}> = attach(\{
			    effect,
			    mapParams: text => (\{foo: text\}),
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			describe('params type mismatch', () => \{
			  test('params type mismatch [with source] (should fail)', () => \{
			    const source = createStore(8900)
			    //prettier-ignore
			    const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			    const fx: Effect<string, string, \{message: string\}> = attach(\{
			      source,
			      effect,
			      //@ts-expect-error
			      mapParams: (text: number, source) => (\{foo: text\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type '(text: number, source: number) => \{ foo: number; \}' is not assignable to type '(params: any, source: number) => \{ foo: string; \}'.
			            Call signature return types '\{ foo: number; \}' and '\{ foo: string; \}' are incompatible.
			              The types of 'foo' are incompatible between these types.
			                Type 'number' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			
			  test('params type mismatch [without source] (should fail)', () => \{
			    //prettier-ignore
			    const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			    //@ts-expect-error
			    const fx: Effect<string, string, \{message: string\}> = attach(\{
			      effect,
			      //@ts-expect-error
			      mapParams: (text: number) => (\{foo: text\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Effect<number, string, \{ message: string; \}>' is not assignable to type 'Effect<string, string, \{ message: string; \}>'.
			        The types of 'done.watch' are incompatible between these types.
			          Type '(watcher: (payload: \{ params: number; result: string; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ params: string; result: string; \}) => any) => Subscription'.
			            Types of parameters 'watcher' and 'watcher' are incompatible.
			              Types of parameters 'payload' and 'payload' are incompatible.
			                Type '\{ params: number; result: string; \}' is not assignable to type '\{ params: string; result: string; \}'.
			      No overload matches this call.
			        The last overload gave the following error.
			          Type '(text: number) => \{ foo: number; \}' is not assignable to type '(params: any, source: any) => \{ foo: string; \}'.
			            Call signature return types '\{ foo: number; \}' and '\{ foo: string; \}' are incompatible.
			              The types of 'foo' are incompatible between these types.
			                Type 'number' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			\})
			
			test('mapParams without arguments (should pass)', () => \{
			  const effect = createEffect((word: string) => word.length)
			  const fx = attach(\{
			    effect,
			    mapParams: () => 'foo',
			  \})
			  const assert_type: Effect<void, number> = fx
			  fx()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('without source and mapParams (should pass)', () => \{
			  const effect: Effect<number, string, boolean> = createEffect()
			  const fx: Effect<number, string, boolean> = attach(\{effect\})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			describe('unknown params type', () => \{
			  test('unknown params type [with source] (?)', () => \{
			    const source = createStore(0)
			    //prettier-ignore
			    const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			    const fx = attach(\{
			      source,
			      effect,
			      //@ts-expect-error
			      mapParams: (text, source) => (\{foo: text\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'unknown' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			  test('unknown params type [without source] (?)', () => \{
			    //prettier-ignore
			    const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			    const fx = attach(\{
			      effect,
			      mapParams: text => (\{foo: text\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unknown params type [with source shape] (?)', () => \{
			    const a = createStore('')
			    const b = createStore(0)
			    //prettier-ignore
			    const effect: Effect<\{foo: string\}, string, \{message: string\}> = createEffect()
			    const fx = attach(\{
			      source: \{a, b\},
			      effect,
			      //@ts-expect-error
			      mapParams: (text, source) => (\{foo: text\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'unknown' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			\})
			
			describe('difference in message quality between inferred types and explicit generics', () => \{
			  test('type mismatch between original effect and mapParams [explicit] (should fail)', () => \{
			    const original = createEffect((params: string) => \{
			      console.log('Original effect called with', params)
			    \})
			
			    const data = createStore(8900)
			
			    const created = attach<number, typeof data, typeof original>(\{
			      effect: original,
			      source: data,
			      //@ts-expect-error
			      mapParams: (params, data) => \{
			        console.log('Created effect called with', params, 'and data', data)
			        return \{wrapped: params, data\}
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(params: number, data: number) => \{ wrapped: number; data: number; \}' is not assignable to type '(params: number, states: number) => string'.
			        Type '\{ wrapped: number; data: number; \}' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			  test('type mismatch between original effect and mapParams [inferred] (should fail)', () => \{
			    const original = createEffect((params: string) => \{
			      console.log('Original effect called with', params)
			    \})
			
			    const data = createStore(8900)
			
			    const created = attach(\{
			      effect: original,
			      source: data,
			      //@ts-expect-error
			      mapParams: (params, data) => \{
			        console.log('Created effect called with', params, 'and data', data)
			        return \{wrapped: params, data\}
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type '(params: unknown, data: number) => \{ wrapped: unknown; data: number; \}' is not assignable to type '(params: any, source: number) => string'.
			            Type '\{ wrapped: unknown; data: number; \}' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			\})
			describe('string subtyping', () => \{
			  test('valid case (should pass)', () => \{
			    const effectFx = createEffect(
			      (payload: \{string: 'one' | 'two' | 'three'\}) => 'response',
			    )
			
			    const attachedFx1: Effect<void, 'response'> = attach(\{
			      effect: effectFx,
			      mapParams: () => (\{
			        string: 'one',
			      \}),
			    \})
			    const attachedFx2: Effect<void, 'response'> = attach(\{
			      effect: effectFx,
			      mapParams: () => (\{
			        string: 'one' as const,
			      \}),
			    \})
			
			    function run() \{
			      effectFx(\{string: 'one'\})
			      attachedFx1()
			      attachedFx2()
			    \}
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'string' is not assignable to type '\\\\"one\\\\" | \\\\"two\\\\" | \\\\"three\\\\"'.
			      "
			    \`)
			  \})
			  test('type mismatch (should fail)', () => \{
			    const effectFx = createEffect(
			      (payload: \{string: 'one' | 'two' | 'three'\}) => 'response',
			    )
			
			    const attachedFx3 = attach(\{
			      effect: effectFx,
			      mapParams: () => (\{
			        //@ts-expect-error
			        string: 'ones',
			      \}),
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'string' is not assignable to type '\\\\"one\\\\" | \\\\"two\\\\" | \\\\"three\\\\"'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\attach.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(16)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\clearNode.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  createDomain,
			  clearNode,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('clearNode(store)', () => \{
			  const store = createStore(null)
			  clearNode(store)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('clearNode(event)', () => \{
			  const event = createEvent()
			  clearNode(event)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('clearNode(effect)', () => \{
			  const fx = createEffect()
			  clearNode(fx)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('clearNode(domain)', () => \{
			  const domain = createDomain()
			  clearNode(domain)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('clearNode(incorrect)', () => \{
			  try \{
			    //@ts-expect-error
			    clearNode(null)
			  \} catch (err) \{\}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type 'null' is not assignable to parameter of type 'Unit<any> | Node'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\clearNode.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\combine.test.ts', () => {
        const sourceCode = `
			import \{combine, createStore, Store\} from 'effector'
			
			const typecheck = '\{global\}'
			
			describe('combine cases (should pass)', () => \{
			  test('combine(\{R,G,B\})', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store: Store<\{R: number; G: number; B: number\}> = combine(\{R, G, B\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combine([R,G,B])', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store: Store<[number, number, number]> = combine([R, G, B])
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combine([Store<number>,Store<string>])', () => \{
			    const sn = createStore(0)
			    const ss = createStore('')
			    const store = combine([sn, ss]).map(([n, s]) => \{
			      n.toFixed // should have method on type
			      s.charAt // should have method on type
			      return null
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combine(\{Color\})', () => \{
			    const Color = createStore('#e95801')
			    const store: Store<\{Color: string\}> = combine(\{Color\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combine([Color])', () => \{
			    const Color = createStore('#e95801')
			    const store: Store<[string]> = combine([Color])
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test(\`combine(\{R,G,B\}, (\{R,G,B\}) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store: Store<string> = combine(
			      \{R, G, B\},
			      (\{R, G, B\}) =>
			        '#' +
			        R.toString(16).padStart(2, '0') +
			        G.toString(16).padStart(2, '0') +
			        B.toString(16).padStart(2, '0'),
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test(\`combine([R,G,B], ([R,G,B]) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store: Store<string> = combine(
			      [R, G, B],
			      ([R, G, B]) =>
			        '#' +
			        R.toString(16).padStart(2, '0') +
			        G.toString(16).padStart(2, '0') +
			        B.toString(16).padStart(2, '0'),
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test(\`combine([Store<number>,Store<string>], ([number,string]) => ...)\`, () => \{
			    const sn = createStore(0)
			    const ss = createStore('')
			    const store = combine([sn, ss], ([n, s]) => \{
			      n.toFixed // should have method on type
			      s.charAt // should have method on type
			      return null
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test(\`combine(\{Color\}, (\{Color\}) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    const store: Store<string> = combine(\{Color\}, (\{Color\}) => Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test(\`combine([Color], ([Color]) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    const store: Store<string> = combine([Color], ([Color]) => Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test(\`combine(Color, (Color) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    const store: Store<string> = combine(Color, Color => Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test(\`combine(R,G,B, (R,G,B) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store: Store<string> = combine(
			      R,
			      G,
			      B,
			      (R, G, B) =>
			        '#' +
			        R.toString(16).padStart(2, '0') +
			        G.toString(16).padStart(2, '0') +
			        B.toString(16).padStart(2, '0'),
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combine(R,G,B)', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    const store: Store<[number, number, number]> = combine(R, G, B)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combine(Color)', () => \{
			    const Color = createStore('#e95801')
			    const store: Store<[string]> = combine(Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('error inference (should fail with number -> string error)', () => \{
			  test('combine(\{R,G,B\})', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    //@ts-expect-error
			    const store: Store<\{R: string; G: string; B: string\}> = combine(\{R, G, B\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<\{ R: number; G: number; B: number; \}>' is not assignable to type 'Store<\{ R: string; G: string; B: string; \}>'.
			        The types returned by 'getState()' are incompatible between these types.
			          Type '\{ R: number; G: number; B: number; \}' is not assignable to type '\{ R: string; G: string; B: string; \}'.
			      "
			    \`)
			  \})
			  test('combine([R,G,B])', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    //@ts-expect-error
			    const store: Store<[string, string, string]> = combine([R, G, B])
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<[number, number, number]>' is not assignable to type 'Store<[string, string, string]>'.
			        The types returned by 'getState()' are incompatible between these types.
			          Type '[number, number, number]' is not assignable to type '[string, string, string]'.
			      "
			    \`)
			  \})
			  test('combine(\{Color\})', () => \{
			    const Color = createStore('#e95801')
			    //@ts-expect-error
			    const store: Store<\{Color: number\}> = combine(\{Color\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<\{ Color: string; \}>' is not assignable to type 'Store<\{ Color: number; \}>'.
			        The types returned by 'getState()' are incompatible between these types.
			          Type '\{ Color: string; \}' is not assignable to type '\{ Color: number; \}'.
			      "
			    \`)
			  \})
			  test('combine([Color])', () => \{
			    const Color = createStore('#e95801')
			    //@ts-expect-error
			    const store: Store<[number]> = combine([Color])
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<[string]>' is not assignable to type 'Store<[number]>'.
			        The types returned by 'getState()' are incompatible between these types.
			          Type '[string]' is not assignable to type '[number]'.
			      "
			    \`)
			  \})
			  test(\`combine(\{R,G,B\}, (\{R,G,B\}) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    //@ts-expect-error
			    const store: Store<number> = combine(
			      \{R, G, B\},
			      (\{R, G, B\}) =>
			        '#' +
			        R.toString(16).padStart(2, '0') +
			        G.toString(16).padStart(2, '0') +
			        B.toString(16).padStart(2, '0'),
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<string>' is not assignable to type 'Store<number>'.
			        The types returned by 'getState()' are incompatible between these types.
			          Type 'string' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			  test(\`combine([R,G,B], ([R,G,B]) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    //@ts-expect-error
			    const store: Store<number> = combine(
			      [R, G, B],
			      ([R, G, B]) =>
			        '#' +
			        R.toString(16).padStart(2, '0') +
			        G.toString(16).padStart(2, '0') +
			        B.toString(16).padStart(2, '0'),
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<string>' is not assignable to type 'Store<number>'.
			      "
			    \`)
			  \})
			  test(\`combine(\{Color\}, (\{Color\}) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    //@ts-expect-error
			    const store: Store<number> = combine(\{Color\}, (\{Color\}) => Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<string>' is not assignable to type 'Store<number>'.
			      "
			    \`)
			  \})
			  test(\`combine([Color], ([Color]) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    //@ts-expect-error
			    const store: Store<number> = combine([Color], ([Color]) => Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<string>' is not assignable to type 'Store<number>'.
			      "
			    \`)
			  \})
			  test(\`combine(Color, (Color) => '~')\`, () => \{
			    const Color = createStore('#e95801')
			    //@ts-expect-error
			    const store: Store<number> = combine(Color, Color => Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<string>' is not assignable to type 'Store<number>'.
			      "
			    \`)
			  \})
			  test(\`combine(R,G,B, (R,G,B) => '~')\`, () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    //@ts-expect-error
			    const store: Store<number> = combine(
			      R,
			      G,
			      B,
			      (R, G, B) =>
			        '#' +
			        R.toString(16).padStart(2, '0') +
			        G.toString(16).padStart(2, '0') +
			        B.toString(16).padStart(2, '0'),
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<string>' is not assignable to type 'Store<number>'.
			      "
			    \`)
			  \})
			  test('combine(R,G,B)', () => \{
			    const R = createStore(233)
			    const G = createStore(88)
			    const B = createStore(1)
			    //@ts-expect-error
			    const store: Store<[string, string, string]> = combine(R, G, B)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<[number, number, number]>' is not assignable to type 'Store<[string, string, string]>'.
			      "
			    \`)
			  \})
			  test('combine(Color)', () => \{
			    const Color = createStore('#e95801')
			    //@ts-expect-error
			    const store: Store<number> = combine(Color)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<[string]>' is not assignable to type 'Store<number>'.
			        The types returned by 'getState()' are incompatible between these types.
			          Type '[string]' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			\})
			
			test('possibly undefined store error message mismatch (should pass)', () => \{
			  const \$vacancyField = createStore<\{id: string\} | null>(null)
			  const \$hasNotActiveFunnels = createStore<boolean>(true)
			
			  const result = combine(\{
			    hasNotActiveFunnels: \$hasNotActiveFunnels,
			    vacancyId: \$vacancyField.map(v => \{
			      if (v) return v.id
			    \}),
			  \})
			
			  const resultType: Store<\{
			    hasNotActiveFunnels: boolean
			    vacancyId: string | undefined
			  \}> = result
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			describe('support optional parameters of explicit generic type', () => \{
			  test('basic case (should pass)', () => \{
			    type I = \{
			      foo?: string | number
			      bar: number
			    \}
			    const \$store = createStore<string | number>('')
			    const \$bar = createStore(0)
			    const result = combine<I>(\{
			      foo: \$store,
			      bar: \$bar,
			    \})
			    const resultType: Store<\{
			      foo?: string | number
			      bar: number
			    \}> = result
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('omit optional field (should pass)', () => \{
			    type I = \{
			      foo?: string | number
			      bar: number
			    \}
			    const \$bar = createStore(0)
			    const result: Store<I> = combine<I>(\{bar: \$bar\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('plain values support (should pass)', () => \{
			    type I = \{
			      foo?: string | number
			      bar: number
			    \}
			    const \$bar = createStore(0)
			    const result: Store<I> = combine<I>(\{
			      foo: 0,
			      bar: \$bar,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  /**
			   * wide input is not supported because if you explicitly define desired type
			   * then what's the point in passing more values?
			   */
			  test('wide input is not supported (should fail)', () => \{
			    type I = \{
			      foo?: string | number
			      bar: number
			    \}
			    const \$bar = createStore(0)
			    //@ts-expect-error
			    const result = combine<I>(\{
			      foo: 0,
			      bar: \$bar,
			      baz: \$bar,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        Overload 1 of 18, '(shape: \{ foo?: string | number | Store<string | number> | undefined; bar: number | Store<number>; \}): Store<I>', gave the following error.
			          Argument of type '\{ foo: number; bar: Store<number>; baz: Store<number>; \}' is not assignable to parameter of type '\{ foo?: string | number | Store<string | number> | undefined; bar: number | Store<number>; \}'.
			            Object literal may only specify known properties, and 'baz' does not exist in type '\{ foo?: string | number | Store<string | number> | undefined; bar: number | Store<number>; \}'.
			        Overload 2 of 18, '(shape: I): Store<\{ foo?: string | number | undefined; bar: number; \}>', gave the following error.
			          Type 'Store<number>' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			\})
			
			describe('support plain values as well as stores', () => \{
			  test('no errors in case of plain value', () => \{
			    const \$bar = createStore(0)
			    const result: Store<\{foo: number; bar: number\}> = combine(\{
			      foo: 0,
			      bar: \$bar,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('edge case with mapped store', () => \{
			    enum DirectionSource \{
			      Country = 'country',
			      Direction = 'direction',
			    \}
			
			    function getTravelInfoSource(destination: null) \{
			      if (!destination) \{
			        return null
			      \}
			
			      if (Math.random()) \{
			        return DirectionSource.Country
			      \}
			    \}
			
			    const \$a = createStore(false)
			    const \$b = createStore(null).map(getTravelInfoSource)
			
			    const \$c = combine(\$a, \$b, (a, b) => 1)
			    const \$d = combine(\$a, 4, (a, b) => 1)
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe("#531 large unions doesn't brake combine", () => \{
			  test('infinite type', () => \{
			    type Currency =
			      | 'usd'
			      | 'eur'
			      | 'cny'
			      | 'uah'
			      | 'byn'
			      | 'thb'
			      | 'rub'
			      | 'azn'
			      | 'kzt'
			      | 'kgs'
			      | 'uzs'
			      | 'tzs'
			      | 'kes'
			      | 'zar'
			      | 'ron'
			      | 'mdl'
			      | 'ils'
			      | 'inr'
			      | 'pln'
			      | 'chf'
			      | 'gbp'
			    const initial = 'usd' as Currency
			    const \$currency = createStore(initial)
			    const \$result = combine(\{
			      currency: \$currency,
			    \})
			    const \$_: Store<\{currency: Currency\}> = \$result
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no any', () => \{
			    type Currency =
			      | 'usd'
			      | 'eur'
			      | 'cny'
			      | 'uah'
			      | 'byn'
			      | 'thb'
			      | 'rub'
			      | 'azn'
			      | 'kzt'
			      | 'kgs'
			      | 'uzs'
			      | 'tzs'
			      | 'kes'
			      | 'zar'
			      | 'ron'
			      | 'mdl'
			      | 'ils'
			      | 'inr'
			      | 'pln'
			      | 'chf'
			      | 'gbp'
			    const initial = 'usd' as Currency
			    const \$currency = createStore(initial)
			    const \$result = combine(\{
			      currency: \$currency,
			    \})
			    //@ts-expect-error
			    const \$_: Store<\{currency: number\}> = \$result
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<\{ currency: Currency; \}>' is not assignable to type 'Store<\{ currency: number; \}>'.
			        The types returned by 'getState()' are incompatible between these types.
			          Type '\{ currency: Currency; \}' is not assignable to type '\{ currency: number; \}'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\combine.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(35)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\createApi.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createApi, Store, Event\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('check1', () => \{
			  const store: Store<number> = createStore(0)
			  const \{event\} = createApi(store, \{
			    event: (n, x: number) => x,
			  \})
			  const createApi_check1: Event<number> = event
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('check2', () => \{
			  const store: Store<number> = createStore(0)
			  const \{event\} = createApi(store, \{
			    event: (n, x: number) => x,
			  \})
			  //@ts-expect-error
			  const createApi_check2: Event<string> = event
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type 'Event<number>' is not assignable to type 'Event<string>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: number) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type 'number' is not assignable to type 'string'.
			    "
			  \`)
			\})
			test('check3', () => \{
			  const store: Store<number> = createStore(0)
			  const \{event\} = createApi(store, \{
			    event: (n, x) => x,
			  \})
			  //@ts-expect-error
			  const createApi_check3: Event<string> = event
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type 'Event<void>' is not assignable to type 'Event<string>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: void) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type 'void' is not assignable to type 'string'.
			    "
			  \`)
			\})
			test('createApi void calls', () => \{
			  const store = createStore(0)
			  const api = createApi(store, \{
			    increment: count => count + 1,
			    decrement: count => count - 1,
			    double: count => count * 2,
			    multiply: (count, mp = 2) => count * mp,
			  \})
			
			  api.double()
			  api.multiply()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('createApi unknown/void support', () => \{
			  const store = createStore(0)
			  const \{foo, bar, baz\} = createApi(store, \{
			    foo: (_, __: void) => 0,
			    bar: (_, __: unknown) => 0,
			    baz: (_, __) => 0,
			  \})
			  const unknownEvent: Event<unknown> = bar
			  const explicitVoid: Event<void> = foo
			  const implicitVoid: Event<void> = baz
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('createApi void calls edge case (should pass)', () => \{
			  const \$isLoading = createStore(false)
			  const \{start, end\} = createApi(\$isLoading, \{
			    start: () => true,
			    end: () => false,
			  \})
			
			  start()
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('createApi returns nothing from reducer (should pass)', () => \{
			  const \$isLoading = createStore(false)
			  const \{start\} = createApi(\$isLoading, \{
			    start: (_, p) => (p === 1 ? true : undefined),
			  \})
			
			  start()
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			describe('type validation', () => \{
			  test('correct call (should pass)', () => \{
			    const x = createStore(0)
			    const \{inc\} = createApi(x, \{
			      inc: (x, y: number) => x + y,
			    \})
			    inc(1)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('void instead of value (should fail)', () => \{
			    const x = createStore(0)
			    const \{inc\} = createApi(x, \{
			      inc: (x, y: number) => x + y,
			    \})
			    //@ts-expect-error
			    inc()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      The 'this' context of type 'void' is not assignable to method's 'this' of type '\\\\"Error: Expected 1 argument, but got 0\\\\"'.
			      "
			    \`)
			  \})
			  test('incorrect value (should fail)', () => \{
			    const x = createStore(0)
			    const \{inc\} = createApi(x, \{
			      inc: (x, y: number) => x + y,
			    \})
			    //@ts-expect-error
			    inc('no')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        Overload 1 of 2, '(payload: number): number', gave the following error.
			          Argument of type 'string' is not assignable to parameter of type 'number'.
			        Overload 2 of 2, '(this: \\\\"Error: Expected 1 argument, but got 0\\\\", payload?: number | undefined): void', gave the following error.
			          The 'this' context of type 'void' is not assignable to method's 'this' of type '\\\\"Error: Expected 1 argument, but got 0\\\\"'.
			      "
			    \`)
			  \})
			\})
			
			test('optional return (should pass)', () => \{
			  const playerPosition = createStore(0)
			
			  const api = createApi(playerPosition, \{
			    moveLeft: (pos, n: number) => pos - n,
			    moveRight(pos, n: number) \{
			      if (pos + n !== 7) return pos + n
			    \},
			    jump: pos => (pos === 7 ? undefined : 0),
			  \})
			
			  api.moveRight(10)
			  api.moveLeft(5)
			  api.moveRight(2)
			  api.jump()
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('optional return false-positive check (should fail)', () => \{
			  const playerPosition = createStore(0)
			  const api = createApi(playerPosition, \{
			    moveRight(pos, n: number) \{
			      if (pos + n !== 7) return pos + n
			    \},
			  \})
			
			  //@ts-expect-error
			  api.moveRight()
			  //@ts-expect-error
			  api.moveRight('no')
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    The 'this' context of type '\{ moveRight: Event<number>; \}' is not assignable to method's 'this' of type '\\\\"Error: Expected 1 argument, but got 0\\\\"'.
			    No overload matches this call.
			      Overload 1 of 2, '(payload: number): number', gave the following error.
			        Argument of type 'string' is not assignable to parameter of type 'number'.
			      Overload 2 of 2, '(this: \\\\"Error: Expected 1 argument, but got 0\\\\", payload?: number | undefined): void', gave the following error.
			        The 'this' context of type '\{ moveRight: Event<number>; \}' is not assignable to method's 'this' of type '\\\\"Error: Expected 1 argument, but got 0\\\\"'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\createApi.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\domain.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{combine, createDomain, clearNode, Effect\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('createDomain', () => \{
			  const domain = createDomain()
			  const domain2 = createDomain('hello')
			  //@ts-expect-error
			  const domain3 = createDomain(234)
			  //@ts-expect-error
			  const domain4 = createDomain(\{foo: true\})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      Overload 1 of 2, '(domainName?: string | undefined, config?: \{ domain?: Domain | undefined; \} | undefined): Domain', gave the following error.
			        Argument of type 'number' is not assignable to parameter of type 'string'.
			      Overload 2 of 2, '(config?: \{ name?: string | undefined; domain?: Domain | undefined; \} | undefined): Domain', gave the following error.
			        Type '234' has no properties in common with type '\{ name?: string | undefined; domain?: Domain | undefined; \}'.
			    No overload matches this call.
			      Overload 1 of 2, '(domainName?: string | undefined, config?: \{ domain?: Domain | undefined; \} | undefined): Domain', gave the following error.
			        Argument of type '\{ foo: boolean; \}' is not assignable to parameter of type 'string'.
			      Overload 2 of 2, '(config?: \{ name?: string | undefined; domain?: Domain | undefined; \} | undefined): Domain', gave the following error.
			        Argument of type '\{ foo: boolean; \}' is not assignable to parameter of type '\{ name?: string | undefined; domain?: Domain | undefined; \}'.
			          Object literal may only specify known properties, and 'foo' does not exist in type '\{ name?: string | undefined; domain?: Domain | undefined; \}'.
			    "
			  \`)
			\})
			
			describe('#event', () => \{
			  it('works without arguments', () => \{
			    const domain = createDomain()
			    const event = domain.event<string>()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with name', () => \{
			    const domain = createDomain()
			    const event = domain.event<string>('event')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with config', () => \{
			    const domain = createDomain()
			    const event = domain.event<string>(\{name: 'event'\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('#createEvent', () => \{
			  it('works without arguments', () => \{
			    const domain = createDomain()
			    const event = domain.createEvent<string>()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with name', () => \{
			    const domain = createDomain()
			    const event = domain.createEvent<string>('event')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with config', () => \{
			    const domain = createDomain()
			    const event = domain.createEvent<string>(\{name: 'event'\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('#effect', () => \{
			  test('type inference', () => \{
			    const domain = createDomain()
			    const effect1: Effect<string, number, Error> = domain.effect()
			    const effect2 = domain.effect('', \{
			      handler(params: string) \{
			        return 256
			      \},
			    \})
			    const handler: any = () => \{\}
			    effect1.use(handler)
			    //@ts-expect-error
			    effect2(20)
			    const effect3 = domain.effect('', \{
			      handler: effect1,
			    \})
			    //@ts-expect-error
			    effect3(20)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type 'number' is not assignable to parameter of type 'string'.
			      Argument of type 'number' is not assignable to parameter of type 'string'.
			      "
			    \`)
			  \})
			  it('works without arguments', () => \{
			    const domain = createDomain()
			    const fx = domain.effect()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with name', () => \{
			    const domain = createDomain()
			    const fx = domain.effect('fx')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with config', () => \{
			    const domain = createDomain()
			    const fx = domain.effect(\{
			      name: 'fx',
			      async handler(params) \{\},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with name and config', () => \{
			    const domain = createDomain()
			    const fx = domain.effect('fx', \{
			      async handler(params) \{\},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('#createEffect', () => \{
			  test('type inference', () => \{
			    const domain = createDomain()
			    const effect1: Effect<string, number, Error> = domain.createEffect()
			    const effect2 = domain.createEffect('', \{
			      handler(params: string) \{
			        return 256
			      \},
			    \})
			    const handler: any = () => \{\}
			    effect1.use(handler)
			    //@ts-expect-error
			    effect2(20)
			    const effect3 = domain.createEffect('', \{
			      handler: effect1,
			    \})
			    //@ts-expect-error
			    effect3(20)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type 'number' is not assignable to parameter of type 'string'.
			      Argument of type 'number' is not assignable to parameter of type 'string'.
			      "
			    \`)
			  \})
			  it('works without arguments', () => \{
			    const domain = createDomain()
			    const fx = domain.createEffect()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with name', () => \{
			    const domain = createDomain()
			    const fx = domain.createEffect('fx')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with config', () => \{
			    const domain = createDomain()
			    const fx = domain.createEffect(\{
			      name: 'fx',
			      async handler(params: number) \{\},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('works with name and config', () => \{
			    const domain = createDomain()
			    const fx = domain.createEffect('fx', \{
			      async handler(params) \{\},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			test('#onCreateStore', () => \{
			  const root = createDomain()
			  root.onCreateStore(store => \{
			    const snapshot = localStorage.getItem(store.shortName)
			    if (typeof snapshot === 'string') store.setState(JSON.parse(snapshot))
			
			    let isFirstSkiped = false
			    store.watch(newState => \{
			      if (isFirstSkiped) \{
			        localStorage.setItem(store.shortName, JSON.stringify(newState))
			      \}
			      isFirstSkiped = true
			    \})
			    return store
			  \})
			
			  root.onCreateStore(foo => \{
			    const object = combine(\{foo\})
			    object.watch(data => \{
			      data.foo
			    \})
			
			    clearNode(foo)
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\domain.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(18)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\effect.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createEffect,
			  Effect,
			  Event,
			  /*::type*/ CompositeName,
			  /*::type*/ kind,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('createEffect', () => \{
			  const createEffect_effect1: Effect<number, string> = createEffect()
			  const createEffect_effect2 = createEffect('', \{
			    handler: createEffect_effect1,
			  \})
			
			  const createEffect_effect3 = createEffect('', \{
			    handler() \{
			      return 'foo'
			    \},
			  \})
			  const createEffect_effect4: Effect<number, string> = createEffect('fx 4')
			  const createEffect_effect5: Effect<number, string> = createEffect(\{
			    name: 'fx 5',
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			describe('createEffect(handler)', () => \{
			  test('createEffect<P, D>(handler)', () => \{
			    const fx1: Effect<string, number> = createEffect<string, number>(
			      word => word.length,
			    )
			    const fx2: Effect<string, number> = createEffect<string, number>(
			      (word: string) => word.length,
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('createEffect<P, D, F>(handler)', () => \{
			    //prettier-ignore
			    const fx1: Effect<string, number, TypeError> = createEffect<string, number, TypeError>(word => word.length)
			    //prettier-ignore
			    const fx2: Effect<string, number, TypeError> = createEffect<string, number, TypeError>((word: string) => word.length)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('createEffect<typeof handler>(handler)', () => \{
			    const handler = (word: string) => word.length
			    const fx: Effect<string, number> = createEffect<typeof handler>(handler)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('createEffect<typeof handler, Error>(handler)', () => \{
			    const handler = (word: string) => word.length
			    //prettier-ignore
			    const fx: Effect<string, number, TypeError> = createEffect<typeof handler, TypeError>(handler)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('type inference support', () => \{
			    const fx: Effect<string, number> = createEffect(
			      (word: string) => word.length,
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('edge case with function in params', () => \{
			    type Params = (x: number) => string
			    const fx1: Effect<Params, string> = createEffect<Params, string>(fn =>
			      fn(0),
			    )
			    const fx2: Effect<Params, string> = createEffect<Params, string>(
			      (fn: Params) => fn(0),
			    )
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('single generic', () => \{
			  type SyncFn = (_: string) => number
			  type AsyncFn = (_: string) => Promise<number>
			  describe('with config', () => \{
			    describe('valid case', () => \{
			      test('use sync generic, give sync handler', () => \{
			        const foo: Effect<string, number> = createEffect<SyncFn>(\{
			          handler: (_: string) => 0,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('use sync generic, give async handler', () => \{
			        const foo: Effect<string, number> = createEffect<SyncFn>(\{
			          handler: async (_: string) => 0,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            Overload 1 of 7, '(handler: SyncFn): Effect<string, number, Error>', gave the following error.
			              Argument of type '\{ handler: (_: string) => Promise<number>; \}' is not assignable to parameter of type 'SyncFn'.
			                Object literal may only specify known properties, and 'handler' does not exist in type 'SyncFn'.
			            Overload 2 of 7, '(config: \{ name?: string | undefined; handler: SyncFn; sid?: string | undefined; domain?: Domain | undefined; \}): Effect<string, number, Error>', gave the following error.
			              Type '(_: string) => Promise<number>' is not assignable to type 'SyncFn'.
			                Type 'Promise<number>' is not assignable to type 'number'.
			          "
			        \`)
			      \})
			      test('use async generic, give sync handler', () => \{
			        const foo: Effect<string, number> = createEffect<AsyncFn>(\{
			          handler: (_: string) => 0,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            Overload 1 of 7, '(handler: AsyncFn): Effect<string, number, Error>', gave the following error.
			              Argument of type '\{ handler: (_: string) => number; \}' is not assignable to parameter of type 'AsyncFn'.
			                Object literal may only specify known properties, and 'handler' does not exist in type 'AsyncFn'.
			            Overload 2 of 7, '(config: \{ name?: string | undefined; handler: AsyncFn; sid?: string | undefined; domain?: Domain | undefined; \}): Effect<string, number, Error>', gave the following error.
			              Type '(_: string) => number' is not assignable to type 'AsyncFn'.
			                Type 'number' is not assignable to type 'Promise<number>'.
			          "
			        \`)
			      \})
			      test('use async generic, give async handler', () => \{
			        const foo: Effect<string, number> = createEffect<AsyncFn>(\{
			          handler: async (_: string) => 0,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			    \})
			    test('config type mismatch (should fail)', () => \{
			      const foo = createEffect<SyncFn>(\{
			        async handler(_: string) \{
			          return '--'
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          Overload 1 of 7, '(handler: SyncFn): Effect<string, number, Error>', gave the following error.
			            Argument of type '\{ handler(_: string): Promise<string>; \}' is not assignable to parameter of type 'SyncFn'.
			              Object literal may only specify known properties, and 'handler' does not exist in type 'SyncFn'.
			          Overload 2 of 7, '(config: \{ name?: string | undefined; handler: SyncFn; sid?: string | undefined; domain?: Domain | undefined; \}): Effect<string, number, Error>', gave the following error.
			            Type '(_: string) => Promise<string>' is not assignable to type 'SyncFn'.
			              Type 'Promise<string>' is not assignable to type 'number'.
			        "
			      \`)
			    \})
			    test('non-function generic', () => \{
			      const foo: Effect<string, number> = createEffect<string>(\{
			        async handler(_: string) \{
			          return '--'
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'string' does not satisfy the constraint 'Function'.
			        "
			      \`)
			    \})
			  \})
			  describe('without config', () => \{
			    test('function generic', () => \{
			      const foo: Effect<string, number> = createEffect<SyncFn>()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Expected 1-2 arguments, but got 0.
			        "
			      \`)
			    \})
			    test('non-function generic', () => \{
			      const foo = createEffect<string>()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Expected 1-2 arguments, but got 0.
			        "
			      \`)
			    \})
			  \})
			\})
			
			test('#(properties)', () => \{
			  const effect = createEffect()
			  const kind1: kind = effect.kind
			  const shortName: string = effect.shortName
			  const compositeName: CompositeName = effect.compositeName
			
			  const computed = effect.map(() => 'hello')
			  const kind2: kind = computed.kind
			  const shortName1: string = computed.shortName
			  const compositeName1: CompositeName = computed.compositeName
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#use', () => \{
			  const effect1 = createEffect()
			  const foo = createEffect<number, string, any>()
			
			  effect1.use(arg => Promise.resolve('foo'))
			  //@ts-expect-error
			  effect1.use(foo)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type 'Effect<number, string, any>' is not assignable to parameter of type '(params: unknown) => unknown'.
			      Types of parameters 'params' and 'params' are incompatible.
			        Type 'unknown' is not assignable to type 'number'.
			    "
			  \`)
			\})
			
			describe('#filter', () => \{
			  it('should filter values (should be ok)', () => \{
			    const fx = createEffect<number, string, any>()
			    fx.use(params => String(params))
			
			    const filteredEvent: Event<number> = fx.filter(\{
			      fn: params => params % 2 === 0,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('should return correct event type (should fail)', () => \{
			    const fx = createEffect<number, string, any>()
			    fx.use(params => String(params))
			
			    //@ts-expect-error
			    const filteredEvent: Event<boolean> = fx.filter(\{
			      fn: params => params % 2 === 0,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Event<number>' is not assignable to type 'Event<boolean>'.
			        Types of property 'watch' are incompatible.
			          Type '(watcher: (payload: number) => any) => Subscription' is not assignable to type '(watcher: (payload: boolean) => any) => Subscription'.
			            Types of parameters 'watcher' and 'watcher' are incompatible.
			              Types of parameters 'payload' and 'payload' are incompatible.
			                Type 'number' is not assignable to type 'boolean'.
			      "
			    \`)
			  \})
			\})
			
			describe('#filterMap', () => \{
			  it('should filter and map values (should be ok)', () => \{
			    const fx = createEffect<number | string | boolean, string, any>()
			    fx.use(params => String(params))
			
			    const filteredEvent: Event<string> = fx.filterMap(params => \{
			      if (params !== false) \{
			        return String(params)
			      \}
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('should return correct event type (should fail)', () => \{
			    const fx = createEffect<string, string, any>()
			    fx.use(params => String(params))
			
			    //@ts-expect-error
			    const filteredEvent: Event<number | void> = fx.filterMap(params => \{
			      if (params.length > 0) \{
			        return params.length
			      \}
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Event<number>' is not assignable to type 'Event<number | void>'.
			        Types of parameters 'payload' and 'payload' are incompatible.
			          Type 'number | void' is not assignable to type 'number'.
			            Type 'void' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			\})
			
			it('should pass', () => \{
			  const handler = (_: any) => \{\}
			  const effect = createEffect<any, any, any>(\{handler\})
			  effect(1)
			  effect('')
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			it('should allow any value', () => \{
			  const handler = (_: any) => \{\}
			  const effect = createEffect(\{handler\})
			  effect(1)
			  effect('')
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			describe('void params', () => \{
			  describe('should allow only calls without arguments', () => \{
			    test('createEffect(config)', () => \{
			      const handler = async () => 'ok'
			      const effect = createEffect(\{handler\})
			      //@ts-expect-error
			      effect(1)
			      effect()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type 'number' is not assignable to parameter of type 'void'.
			        "
			      \`)
			    \})
			    test('createEffect(name, config)', () => \{
			      const handler = async () => 'ok'
			      const effect = createEffect('effect', \{handler\})
			      //@ts-expect-error
			      effect(1)
			      effect()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type 'number' is not assignable to parameter of type 'void'.
			        "
			      \`)
			    \})
			  \})
			  describe('with handler', () => \{
			    test('handler returns void', () => \{
			      const handler = () => \{\}
			      const effect = createEffect(\{handler\})
			      effect()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('handler returns value', () => \{
			      const handler = () => 'ok'
			      const effect = createEffect(\{handler\})
			      const result: Promise<string> = effect()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			  test('with use', () => \{
			    const handler = () => \{\}
			    const effect = createEffect('').use(handler)
			    effect()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Expected 1 arguments, but got 0.
			      "
			    \`)
			  \})
			  describe('with createEffect(handler)', () => \{
			    test('void params should allow only call without arguments', () => \{
			      const fx = createEffect(() => 'ok')
			      fx()
			      //@ts-expect-error
			      fx(1)
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type 'number' is not assignable to parameter of type 'void'.
			        "
			      \`)
			    \})
			    test('optional params should allow call with and without arguments', () => \{
			      const fx = createEffect((params = 1) => 'ok')
			      const assert: Effect<number | void, 'ok'> = fx
			      fx()
			      fx(1)
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			  describe('with createEffect<P, D, F>(handler)', () => \{
			    test('void params should allow only call without arguments', () => \{
			      const fx = createEffect<void, string, TypeError>(() => 'ok')
			      fx()
			      //@ts-expect-error
			      fx(1)
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type 'number' is not assignable to parameter of type 'void'.
			        "
			      \`)
			    \})
			    test('optional params should allow call with and without arguments', () => \{
			      const fx = createEffect<number | void, 'ok', TypeError>(
			        (params = 1) => 'ok',
			      )
			      fx()
			      fx(1)
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			\})
			describe('nested effects', () => \{
			  describe('with handler', () => \{
			    it('support nesting (should be ok)', () => \{
			      const nestedEffect: Effect<string, string> = createEffect()
			      const parentEffect: Effect<string, string> = createEffect(\{
			        handler: nestedEffect,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('no false-positive (should be type error)', () => \{
			      const nestedEffect: Effect<string, string> = createEffect()
			      //@ts-expect-error
			      const parentEffect: Effect<number, number> = createEffect(
			        'should not throw',
			        \{
			          handler: nestedEffect,
			        \},
			      )
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Effect<string, string, Error>' is not assignable to type 'Effect<number, number, Error>'.
			          The types of 'done.watch' are incompatible between these types.
			            Type '(watcher: (payload: \{ params: string; result: string; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ params: number; result: number; \}) => any) => Subscription'.
			              Types of parameters 'watcher' and 'watcher' are incompatible.
			                Types of parameters 'payload' and 'payload' are incompatible.
			                  Type '\{ params: string; result: string; \}' is not assignable to type '\{ params: number; result: number; \}'.
			        "
			      \`)
			    \})
			  \})
			  test('with use', () => \{\})
			\})
			describe('optional params', () => \{
			  describe('inference of optional argument type from handler type', () => \{
			    it('should allow calls with and w/o arguments', () => \{
			      const handler = (params = 0) => params
			      const effect = createEffect(\{handler\})
			      effect(1)
			      effect()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    it('should allow calls with and w/o arguments in case of \`params?: any\`', () => \{
			      const handler = (params?: any) => params
			      const effect = createEffect(\{handler\})
			      effect('really anything')
			      effect()
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Expected 1 arguments, but got 0.
			        "
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\effect.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(37)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\event.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createEvent, Event, CompositeName, kind\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('createEvent', () => \{
			  const createEvent_event1: Event<number> = createEvent()
			  const createEvent_event2: Event<number> = createEvent('event name [1]')
			  const createEvent_event3: Event<number> = createEvent(\{
			    name: 'event name [2]',
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('#(properties)', () => \{
			  const event = createEvent()
			  const kind1: kind = event.kind
			  const shortName: string = event.shortName
			  const compositeName: CompositeName = event.compositeName
			
			  const computed = event.map(() => 'hello')
			  const kind2: kind = computed.kind
			  const shortName1: string = computed.shortName
			  const compositeName1: CompositeName = computed.compositeName
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('#map', () => \{
			  const event: Event<number> = createEvent()
			  const computed = event.map(() => 'foo')
			
			  //const check1: Event<string> = computed
			  //@ts-expect-error
			  const event_map_check2: Event<number> = computed
			  event(2)
			  computed('')
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type 'Event<string>' is not assignable to type 'Event<number>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: string) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			    "
			  \`)
			\})
			test('#watch', () => \{
			  const event: Event<number> = createEvent()
			  event.watch(state => \{
			    const check1: number = state
			    return state
			  \})
			  event.watch(state => 'foo')
			  event.watch(state => \{\})
			  event.watch(state => \{\})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			describe('#filterMap', () => \{
			  test('#filterMap ok', () => \{
			    const event: Event<number> = createEvent()
			    const filteredEvent_ok: Event<string> = event.filterMap(n => \{
			      if (n % 2) return n.toString()
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('#filterMap incorrect', () => \{
			    const event: Event<number> = createEvent()
			    //@ts-expect-error
			    const filteredEvent_error: Event<number> = event.filterMap(n => \{
			      if (n % 2) return n.toString()
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Event<string>' is not assignable to type 'Event<number>'.
			      "
			    \`)
			  \})
			\})
			describe('#prepend', () => \{
			  test('infer argument type', () => \{
			    const event = createEvent<string>()
			    const prepended = event.prepend((arg: number) => 'foo')
			    prepended(1)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('infer void type', () => \{
			    const event = createEvent<string>()
			    const prepended = event.prepend<void>(() => 'foo')
			    prepended()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('infer optional type', () => \{
			    const event = createEvent<string>()
			    const prepended = event.prepend((arg?: number) => 'foo')
			    prepended()
			    prepended(1)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('infer optional unknown type', () => \{
			    const event = createEvent<string>()
			    const prepended = event.prepend((arg?: unknown) => 'foo')
			    prepended()
			    prepended(1)
			    prepended('')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('argument type mismatch', () => \{
			    const event = createEvent<string>()
			    const prepended = event.prepend((arg: number) => 'foo')
			    //@ts-expect-error
			    prepended('')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        Overload 1 of 2, '(payload: number): number', gave the following error.
			          Argument of type 'string' is not assignable to parameter of type 'number'.
			        Overload 2 of 2, '(this: \\\\"Error: Expected 1 argument, but got 0\\\\", payload?: number | undefined): void', gave the following error.
			          The 'this' context of type 'void' is not assignable to method's 'this' of type '\\\\"Error: Expected 1 argument, but got 0\\\\"'.
			      "
			    \`)
			  \})
			  test('void type mismatch', () => \{
			    const event = createEvent<string>()
			    const prepended = event.prepend(() => 'foo')
			    //@ts-expect-error
			    prepended('')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        Overload 1 of 2, '(payload: void): void', gave the following error.
			          Argument of type 'string' is not assignable to parameter of type 'void'.
			        Overload 2 of 2, '(this: void, payload?: void | undefined): void', gave the following error.
			          Argument of type 'string' is not assignable to parameter of type 'void'.
			      "
			    \`)
			  \})
			  test('target event type mismatch', () => \{
			    const event = createEvent<number>()
			    //@ts-expect-error
			    const prepended = event.prepend((arg: boolean) => 'foo')
			    prepended(true)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '(arg: boolean) => string' is not assignable to parameter of type '(_: boolean) => number'.
			        Type 'string' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			  test('void target event edge case', () => \{
			    const event: Event<void> = createEvent()
			    const prepended = event.prepend((arg: number) => 'foo') // returns string
			    prepended(1)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			test('void function interop (should pass)', () => \{
			  const voidFn: () => void = createEvent<void>()
			  const voidFn1: () => void = createEvent<undefined>()
			  const voidFn2: () => void = createEvent<any>()
			  const voidFn3: () => void = createEvent<never>()
			  const voidFn4: () => void = createEvent<unknown>()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('call event without params (should pass)', () => \{
			  const event = createEvent()
			  event()
			  const event1 = createEvent<undefined>()
			  event1()
			  const event2 = createEvent<any>()
			  event2()
			  const event3 = createEvent<unknown>()
			  event3()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('call event without params (should fail)', () => \{
			  const event = createEvent<number>()
			  //@ts-expect-error
			  event()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    The 'this' context of type 'void' is not assignable to method's 'this' of type '\\\\"Error: Expected 1 argument, but got 0\\\\"'.
			    "
			  \`)
			\})
			test('call event without params (unknown) (should pass)', () => \{
			  const event = createEvent<unknown>()
			  event()
			  event(3)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('call event without params (never) (should fail)', () => \{
			  // Should never be called
			  const event = createEvent<never>()
			  //@ts-expect-error
			  event()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    The 'this' context of type 'void' is not assignable to method's 'this' of type 'never'.
			    "
			  \`)
			\})
			test('assign event to a function (should pass)', () => \{
			  const fn1: (event: number) => number = createEvent<number>()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('assign event to a function (should fail)', () => \{
			  //@ts-expect-error
			  const fn1: (event: number) => unknown = createEvent<string>()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type 'Event<string>' is not assignable to type '(event: number) => unknown'.
			      Types of parameters 'payload' and 'event' are incompatible.
			        Type 'number' is not assignable to type 'string'.
			    "
			  \`)
			\})
			describe('event as function argument', () => \{
			  test('direct pass', () => \{
			    function fn(arg: (_: number) => number) \{\}
			    const event = createEvent<string>()
			    //@ts-expect-error
			    fn(event)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type 'Event<string>' is not assignable to parameter of type '(_: number) => number'.
			        Types of parameters 'payload' and '_' are incompatible.
			          Type 'number' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			  test('indirect pass', () => \{
			    function fn(arg: (_: number) => number) \{\}
			    const event = createEvent<string>()
			    //@ts-expect-error
			    fn(e => event(e))
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        Overload 1 of 2, '(payload: string): string', gave the following error.
			          Argument of type 'number' is not assignable to parameter of type 'string'.
			        Overload 2 of 2, '(this: \\\\"Error: Expected 1 argument, but got 0\\\\", payload?: string | undefined): void', gave the following error.
			          The 'this' context of type 'void' is not assignable to method's 'this' of type '\\\\"Error: Expected 1 argument, but got 0\\\\"'.
			      "
			    \`)
			  \})
			\})
			test('createEvent edge case', () => \{
			  // Default type is inferred
			  const fn: (event: number) => number = createEvent()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('void function edge case (should fail)', () => \{
			  // Typed event is assignable to a void function
			  const voidFn: () => void = createEvent<number>()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\event.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(25)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\fork.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createDomain, Store, fork, serialize, allSettled, Json\} from 'effector'
			
			const typecheck = '\{global\}'
			
			describe('serialize cases (should pass)', () => \{
			  test('serialize(Scope): \{[sid: string]: any\}', () => \{
			    const app = createDomain()
			    const \$a = app.createStore('demo')
			
			    const scope = fork(app)
			    const values: \{[sid: string]: string\} = serialize(scope)
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('serialize(Scope, \{ignore:[Store<any>]\}): \{[sid: string]: any\}', () => \{
			    const app = createDomain()
			    const \$a = app.createStore('demo')
			    const \$b = app.createStore(5)
			
			    const scope = fork(app)
			    const values: \{[sid: string]: number\} = serialize(scope, \{ignore: [\$b]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('serialize cases (should fail)', () => \{
			  test('serialize(Scope, \{ignore:[Event<any>]\}): \{[sid: string]: any\}', () => \{
			    const app = createDomain()
			    const event = app.createEvent()
			
			    const scope = fork(app)
			    //@ts-expect-error
			    const values: \{[sid: string]: any\} = serialize(scope, \{ignore: [event]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Event<void>' is missing the following properties from type 'Store<any>': reset, getState, on, off, and 2 more.
			      "
			    \`)
			  \})
			\})
			
			describe('custom serialize for stores', () => \{
			  test('Correct case', () => \{
			    const d = createDomain()
			    const \$map = d.createStore<Map<number, number>, [number, number][]>(
			      new Map<number, number>(),
			      \{
			        serialize: \{
			          write: map => \{
			            const result = [...map.entries()]
			
			            return result
			          \},
			          read: jsonMap => \{
			            return new Map(jsonMap)
			          \},
			        \},
			      \},
			    )
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('Incorrect case', () => \{
			    const d = createDomain()
			    const \$map = d.createStore<Map<number, number>>(new Map<number, number>(), \{
			      serialize: \{
			        // @ts-expect-error
			        write: map => \{
			          return map // non-Json value
			        \},
			        // @ts-expect-error
			        read: jsonMap => \{
			          const serializedValue: typeof jsonMap extends Json
			            ? typeof jsonMap
			            : never = jsonMap
			
			          // @ts-expect-error
			          return new Map(serializedValue)
			        \},
			      \},
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(map: Map<number, number>) => Map<number, number>' is not assignable to type '(state: Map<number, number>) => Json'.
			        Type 'Map<number, number>' is not assignable to type 'Json'.
			          Type 'Map<number, number>' is not assignable to type '\{ [k: string]: Json; \}'.
			            Index signature for type 'string' is missing in type 'Map<number, number>'.
			      Type '(jsonMap: Json) => Map<string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined>' is not assignable to type '(json: Json) => Map<number, number>'.
			        Type 'Map<string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined>' is not assignable to type 'Map<number, number>'.
			          Type 'string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined' is not assignable to type 'number'.
			            Type 'undefined' is not assignable to type 'number'.
			      No overload matches this call.
			        Overload 1 of 4, '(iterable?: Iterable<readonly [string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined]> | null | undefined): Map<...>', gave the following error.
			          Argument of type 'Json' is not assignable to parameter of type 'Iterable<readonly [string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined]> | null | undefined'.
			            Type 'string' is not assignable to type 'Iterable<readonly [string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined]>'.
			        Overload 2 of 4, '(entries?: readonly (readonly [string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined])[] | null | undefined): Map<...>', gave the following error.
			          Argument of type 'Json' is not assignable to parameter of type 'readonly (readonly [string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined])[] | null | undefined'.
			            Type 'string' is not assignable to type 'readonly (readonly [string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined, string | number | boolean | Json[] | \{ [k: string]: Json; \} | null | undefined])[]'.
			      "
			    \`)
			  \})
			\})
			
			describe('fork values', () => \{
			  describe('without type annotations (should pass)', () => \{
			    test('fork values as js Map', () => \{
			      const app = createDomain()
			      const foo = app.createStore<number>(0)
			      const bar = app.createStore<string>('a')
			
			      const scope = fork(app, \{
			        values: new Map([
			          [foo, 1],
			          [bar, 'b'],
			        ]),
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          Overload 1 of 4, '(iterable?: Iterable<readonly [Store<number>, number]> | null | undefined): Map<Store<number>, number>', gave the following error.
			            Argument of type '([Store<number>, number] | [Store<string>, string])[]' is not assignable to parameter of type 'Iterable<readonly [Store<number>, number]>'.
			              The types returned by '[Symbol.iterator]().next(...)' are incompatible between these types.
			                Type 'IteratorResult<[Store<number>, number] | [Store<string>, string], any>' is not assignable to type 'IteratorResult<readonly [Store<number>, number], any>'.
			                  Type 'IteratorYieldResult<[Store<number>, number] | [Store<string>, string]>' is not assignable to type 'IteratorResult<readonly [Store<number>, number], any>'.
			                    Type 'IteratorYieldResult<[Store<number>, number] | [Store<string>, string]>' is not assignable to type 'IteratorYieldResult<readonly [Store<number>, number]>'.
			                      Type '[Store<number>, number] | [Store<string>, string]' is not assignable to type 'readonly [Store<number>, number]'.
			                        Type '[Store<string>, string]' is not assignable to type 'readonly [Store<number>, number]'.
			                          Type at position 0 in source is not compatible with type at position 0 in target.
			                            Type 'Store<string>' is not assignable to type 'Store<number>'.
			        "
			      \`)
			    \})
			    test('fork values as sid map', () => \{
			      const app = createDomain()
			      const foo = app.createStore<number>(0)
			      const bar = app.createStore<string>('a')
			
			      const scope = fork(app, \{
			        values: \{
			          [foo.sid]: 1,
			          [bar.sid]: 'b',
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        A computed property name must be of type 'string', 'number', 'symbol', or 'any'.
			        A computed property name must be of type 'string', 'number', 'symbol', or 'any'.
			        "
			      \`)
			    \})
			  \})
			  describe('with type annotations', () => \{
			    test('fork values as js Map', () => \{
			      const app = createDomain()
			      const foo = app.createStore<number>(0)
			      const bar = app.createStore<string>('a')
			
			      const scope = fork(app, \{
			        values: new Map<Store<any>, any>([
			          [foo, 1],
			          [bar, 'b'],
			        ]),
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('fork values as sid map', () => \{
			      const app = createDomain()
			      const foo = app.createStore<number>(0)
			      const bar = app.createStore<string>('a')
			
			      const scope = fork(app, \{
			        values: \{
			          [foo.sid!]: 1,
			          [bar.sid!]: 'b',
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			\})
			
			describe('fork handlers', () => \{
			  test('effect with custom error', () => \{
			    const app = createDomain()
			    const fooFx = app.createEffect<void, void, \{message: string\}>(() => \{\})
			
			    const scope = fork(app, \{
			      handlers: [[fooFx, () => \{\}]],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('allSettled', () => \{
			  test('event', () => \{
			    const app = createDomain()
			    const event = app.createEvent<number>()
			    const req: Promise<void> = allSettled(event, \{
			      scope: fork(app),
			      params: 0,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('void event', () => \{
			    const app = createDomain()
			    const event = app.createEvent()
			    const req: Promise<void> = allSettled(event, \{
			      scope: fork(app),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('effect', () => \{
			    const app = createDomain()
			    const fx = app.createEffect((x: number) => x.toString())
			    const req: Promise<
			      \{status: 'done'; value: string\} | \{status: 'fail'; value: Error\}
			    > = allSettled(fx, \{
			      scope: fork(app),
			      params: 0,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('void effect', () => \{
			    const app = createDomain()
			    const fx = app.createEffect(() => 'ok')
			    const req: Promise<
			      \{status: 'done'; value: string\} | \{status: 'fail'; value: Error\}
			    > = allSettled(fx, \{
			      scope: fork(app),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('scope', () => \{
			    const app = createDomain()
			    const fx = app.createEffect(() => 'ok')
			    const req: Promise<void> = allSettled(fork())
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\fork.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(15)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\forward.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, createEffect, Event, forward\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('forward between events', () => \{
			  const forward_event1 = createEvent<number>()
			  const forward_event2 = createEvent<number>()
			  forward(\{
			    from: forward_event1,
			    to: forward_event2,
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			describe('forward between effects', () => \{
			  test('start in parallel with the same payload', () => \{
			    const forward_effect_par1 = createEffect<number, string, string>()
			    const forward_effect_par2 = createEffect<number, string, string>()
			    forward(\{
			      from: forward_effect_par1,
			      to: forward_effect_par2,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('start sequentially', () => \{
			    const forward_effect_seq1 = createEffect<number, string, string>()
			    const forward_effect_seq2 = createEffect<string, boolean, boolean>()
			    forward(\{
			      from: forward_effect_seq1.done.map((\{result\}) => result),
			      to: forward_effect_seq2,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			test('forward between stores (should pass)', () => \{
			  const e = createStore(0)
			  const f = createStore(0)
			  forward(\{from: e, to: f\})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('from unknown to known type (should fail)', () => \{
			  const emitUnknown = createEvent<unknown>()
			  const receiveNumber = createEvent<number>()
			  forward(\{
			    //@ts-expect-error
			    from: emitUnknown,
			    to: receiveNumber,
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<unknown>' is not assignable to type 'Unit<number>'.
			          Types of property '__' are incompatible.
			            Type 'unknown' is not assignable to type 'number'.
			    "
			  \`)
			\})
			describe('forward with subtyping', () => \{
			  const str: Event<string> = createEvent()
			  const strOrNum: Event<string | number> = createEvent()
			  const num: Event<number> = createEvent()
			  it('incompatible (should fail)', () => \{
			    //@ts-expect-error
			    forward(\{from: str, to: num\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'Event<string>' is not assignable to type 'Unit<number>'.
			            Types of property '__' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			  it('same types (should pass)', () => \{
			    forward(\{from: str, to: str\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('more strict -> less strict type (should pass)', () => \{
			    forward(\{from: str, to: strOrNum\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('less strict -> more strict type (should fail)', () => \{
			    //@ts-expect-error
			    forward(\{from: strOrNum, to: str\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'Event<string | number>' is not assignable to type 'Unit<string>'.
			            Types of property '__' are incompatible.
			              Type 'string | number' is not assignable to type 'string'.
			                Type 'number' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			  it('generic from (?)', () => \{
			    forward<string | number>(\{from: strOrNum, to: str\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('generic to (should fail)', () => \{
			    //@ts-expect-error
			    forward<string>(\{from: strOrNum, to: str\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Event<string | number>' is not assignable to type 'Unit<string>'.
			      "
			    \`)
			  \})
			  it('generics \`to\` and \`from\` (should pass)', () => \{
			    forward<string | number, string>(\{to: strOrNum, from: str\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('generics \`to\` and \`from\` (should fail on providing generics)', () => \{
			    //@ts-expect-error
			    forward<string, string | number>(\{to: str, from: strOrNum\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'string | number' does not satisfy the constraint 'string'.
			        Type 'number' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			\})
			
			describe('any to void support', () => \{
			  it('should forward from \`Unit<*>\` to \`Unit<void>\` (should pass)', () => \{
			    const from = createEvent<string>()
			    const to = createEvent<void>()
			
			    forward(\{from, to\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('should forward from \`Unit<*>[]\` to \`Unit<void>[]\` (should pass)', () => \{
			    const from = createEvent<string>()
			    const to = createEvent<void>()
			
			    forward(\{from: [from], to: [to]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('should forward from \`Unit<*>\` to \`Unit<void>[]\` (should pass)', () => \{
			    const from = createEvent<string>()
			    const to = createEvent<void>()
			
			    forward(\{from, to: [to]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  it('should forward from \`Unit<*>\` to array with mixed units (should pass)', () => \{
			    const from = createEvent<string>()
			    const to1 = createEvent<void>()
			    const to2 = createEvent<string>()
			    forward(\{from, to: [to1, to2]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'Event<string>' is not assignable to type 'Unit<void>'.
			            Types of property '__' are incompatible.
			              Type 'string' is not assignable to type 'void'.
			                Type 'Event<string>' is not assignable to type 'Unit<void>'.
			      No overload matches this call.
			        The last overload gave the following error.
			          Type 'Event<string>' is not assignable to type 'Unit<void>'.
			            Types of property '__' are incompatible.
			              Type 'string' is not assignable to type 'void'.
			                Type 'Event<string>' is not assignable to type 'Unit<void>'.
			      "
			    \`)
			  \})
			  it('should forward from \`Unit<*>[]\` to \`Unit<void>\` (should pass)', () => \{
			    const from = createEvent<string>()
			    const to = createEvent<void>()
			
			    forward(\{from: [from], to\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			test('forward form event.map (should pass)', () => \{
			  const event1 = createEvent<string>()
			  const event2 = createEvent<\{value: string\}>()
			
			  forward(\{
			    from: event1.map(value => (\{value\})),
			    to: event2,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('forward to event.prepend (should pass)', () => \{
			  const event1 = createEvent<string>()
			  const event2 = createEvent<\{value: string\}>()
			
			  forward(\{
			    from: event1,
			    to: event2.prepend(value => (\{value\})),
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('edge case #1 (should fail)', () => \{
			  const event1 = createEvent<string>()
			  const event2 = createEvent<\{value: string\}>()
			
			  forward(\{
			    //@ts-expect-error
			    from: event1,
			    to: event2.map(value => (\{value\})),
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<string>' is not assignable to type 'Unit<\{ value: \{ value: string; \}; \}>'.
			          Types of property '__' are incompatible.
			            Type 'string' is not assignable to type '\{ value: \{ value: string; \}; \}'.
			    "
			  \`)
			\})
			
			describe('array support', () => \{
			  describe('forward to array', () => \{
			    test('valid (should pass)', () => \{
			      const s1 = createEvent<string>()
			      const t1 = createEvent<string>()
			      const t2 = createEvent<string>()
			      forward(\{
			        from: s1,
			        to: [t1, t2],
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    describe('invalid', () => \{
			      test('type mismatch (should fail)', () => \{
			        const s1 = createEvent<number>()
			        const t1 = createEvent<string>()
			        const t2 = createEvent<string>()
			        forward(\{
			          //@ts-expect-error
			          from: s1,
			          to: [t1, t2],
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Event<number>' is not assignable to type 'Unit<string>'.
			                Types of property '__' are incompatible.
			                  Type 'number' is not assignable to type 'string'.
			          "
			        \`)
			      \})
			      test('array mismatch (should fail)', () => \{
			        const s1 = createEvent<string>()
			        const t1 = createEvent<string>()
			        const t2 = createEvent<number>()
			        forward(\{
			          //@ts-expect-error
			          from: s1,
			          //@ts-expect-error
			          to: [t1, t2],
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Event<number>' is not assignable to type 'Unit<string>'.
			          "
			        \`)
			      \})
			    \})
			  \})
			  describe('forward from array', () => \{
			    test('valid (should pass)', () => \{
			      const s1 = createEvent<string>()
			      const s2 = createEvent<string>()
			      const t1 = createEvent<string>()
			      forward(\{
			        from: [s1, s2],
			        to: t1,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    describe('invalid', () => \{
			      test('type mismatch (should fail)', () => \{
			        const s1 = createEvent<string>()
			        const s2 = createEvent<string>()
			        const t1 = createEvent<number>()
			        forward(\{
			          //@ts-expect-error
			          from: [s1, s2],
			          to: t1,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Event<string>[]' is missing the following properties from type 'Unit<number>': kind, __
			          "
			        \`)
			      \})
			      test('array mismatch (should fail)', () => \{
			        const s1 = createEvent<string>()
			        const s2 = createEvent<number>()
			        const t1 = createEvent<string>()
			        forward(\{
			          //@ts-expect-error
			          from: [s1, s2],
			          to: t1,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type '(Event<string> | Event<number>)[]' is missing the following properties from type 'Unit<string>': kind, __
			          "
			        \`)
			      \})
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\forward.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(27)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\generated\\guard.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, guard\} from 'effector'
			const typecheck = '\{global\}'
			type Astr = \{a: string\}
			type AB = \{a: number; b: string\}
			type AoptB = \{a: number | null; b: string\}
			type ABN = \{a: number; b: number\}
			const \$filter = createStore(true)
			const a = createStore(0)
			const aOpt = createStore<number | null>(0)
			const b = createStore('')
			const voidt = createEvent()
			const anyt = createEvent<any>()
			const numt = createEvent<number>()
			const strt = createEvent<number>()
			const \$num = createStore(0)
			const ab = createEvent<AB>()
			const nullableAB = createEvent<AB | null>()
			const abNull = createEvent<\{a: number | null; b: string\}>()
			const aNum = createEvent<\{a: number\}>()
			const aStr = createEvent<\{a: string\}>()
			const lNum = createEvent<[number]>()
			const lStr = createEvent<[string]>()
			const lNumStr = createEvent<[number, string]>()
			const lNumNum = createEvent<[number, number]>()
			const abn = createEvent<ABN>()
			describe('unit source', () => \{
			  describe('unit -> unit same', () => \{
			    test('unit -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , target:ab   , filter:(val) => val.a > 0                \})
			        guard(\{source:ab        , target:anyt , filter:(val) => val.a > 0                \})
			        guard(\{source:ab        , target:voidt, filter:(val) => val.a > 0                \})
			        guard(\{source:ab        , target:ab   , filter:\$filter                           \})
			        guard(\{source:ab        , target:anyt , filter:\$filter                           \})
			        guard(\{source:ab        , target:voidt, filter:\$filter                           \})
			        guard(\{source:ab        , target:ab   , filter:Boolean                           \})
			        guard(\{source:ab        , target:anyt , filter:Boolean                           \})
			        guard(\{source:ab        , target:voidt, filter:Boolean                           \})
			        guard(\{source:abNull    , target:ab   , filter:(val): val is AB => val.a !== null\})
			        guard(\{source:nullableAB, target:ab   , filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , target:abn, filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:abn, filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:abn, filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:abNull    , target:abn, filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:abn, filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit -> unit wide', () => \{
			    test('unit -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , target:aNum, filter:(val) => val.a > 0\})
			        guard(\{source:ab        , target:aNum, filter:\$filter           \})
			        guard(\{source:ab        , target:aNum, filter:Boolean           \})
			        guard(\{source:nullableAB, target:aNum, filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , target:aStr, filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:aStr, filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:aStr, filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> unit same', () => \{
			    test('unit + clock -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , clock:anyt       , target:ab   , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:anyt       , target:anyt , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:anyt       , target:voidt, filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:numt       , target:ab   , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:numt       , target:anyt , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:numt       , target:voidt, filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:[anyt]     , target:ab   , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:[anyt]     , target:anyt , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:[anyt]     , target:voidt, filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:[numt,\$num], target:ab   , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:[numt,\$num], target:anyt , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:[numt,\$num], target:voidt, filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:anyt       , target:ab   , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:anyt       , target:anyt , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:anyt       , target:voidt, filter:\$filter                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:ab   , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:anyt , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:voidt, filter:\$filter                                      \})
			        guard(\{source:ab        , clock:anyt       , target:ab   , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:anyt       , target:anyt , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:anyt       , target:voidt, filter:Boolean                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:ab   , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:anyt , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:voidt, filter:Boolean                                      \})
			        guard(\{source:abNull    , clock:anyt       , target:ab   , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:numt       , target:ab   , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:[anyt]     , target:ab   , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:[numt,\$num], target:ab   , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:nullableAB, clock:anyt       , target:ab   , filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:ab   , filter:Boolean                                      \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:abn, filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:abn, filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:abn, filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:abn, filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:abn, filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:abn, filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:anyt  , target:abn, filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:[anyt], target:abn, filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:abn, filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:abn, filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> unit wide', () => \{
			    test('unit + clock -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , clock:anyt       , target:aNum, filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:numt       , target:aNum, filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:[anyt]     , target:aNum, filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:[numt,\$num], target:aNum, filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:anyt       , target:aNum, filter:\$filter             \})
			        guard(\{source:ab        , clock:[anyt]     , target:aNum, filter:\$filter             \})
			        guard(\{source:ab        , clock:anyt       , target:aNum, filter:Boolean             \})
			        guard(\{source:ab        , clock:[anyt]     , target:aNum, filter:Boolean             \})
			        guard(\{source:nullableAB, clock:anyt       , target:aNum, filter:Boolean             \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:aNum, filter:Boolean             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:aStr, filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:aStr, filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:aStr, filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:aStr, filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:aStr, filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:aStr, filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit -> array same', () => \{
			    test('unit -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , target:[ab]           , filter:(val) => val.a > 0                \})
			        guard(\{source:ab        , target:[ab,anyt]      , filter:(val) => val.a > 0                \})
			        guard(\{source:ab        , target:[ab,voidt]     , filter:(val) => val.a > 0                \})
			        guard(\{source:ab        , target:[ab,anyt,voidt], filter:(val) => val.a > 0                \})
			        guard(\{source:ab        , target:[ab]           , filter:\$filter                           \})
			        guard(\{source:ab        , target:[ab,anyt]      , filter:\$filter                           \})
			        guard(\{source:ab        , target:[ab,voidt]     , filter:\$filter                           \})
			        guard(\{source:ab        , target:[ab,anyt,voidt], filter:\$filter                           \})
			        guard(\{source:ab        , target:[ab]           , filter:Boolean                           \})
			        guard(\{source:ab        , target:[ab,anyt]      , filter:Boolean                           \})
			        guard(\{source:ab        , target:[ab,voidt]     , filter:Boolean                           \})
			        guard(\{source:ab        , target:[ab,anyt,voidt], filter:Boolean                           \})
			        guard(\{source:abNull    , target:[ab]           , filter:(val): val is AB => val.a !== null\})
			        guard(\{source:abNull    , target:[ab,anyt]      , filter:(val): val is AB => val.a !== null\})
			        guard(\{source:abNull    , target:[ab,voidt]     , filter:(val): val is AB => val.a !== null\})
			        guard(\{source:abNull    , target:[ab,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        guard(\{source:nullableAB, target:[ab]           , filter:Boolean                           \})
			        guard(\{source:nullableAB, target:[ab,anyt]      , filter:Boolean                           \})
			        guard(\{source:nullableAB, target:[ab,voidt]     , filter:Boolean                           \})
			        guard(\{source:nullableAB, target:[ab,anyt,voidt], filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn]           , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,anyt]      , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,voidt]     , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,anyt,voidt], filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn]           , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,anyt]      , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,voidt]     , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,anyt,voidt], filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[abn,anyt,voidt], filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:abNull    , target:[abn]           , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , target:[abn,anyt]      , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , target:[abn,voidt]     , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , target:[abn,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[abn,anyt,voidt], filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit -> array wide', () => \{
			    test('unit -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , target:[aNum]           , filter:(val) => val.a > 0\})
			        guard(\{source:ab        , target:[aNum,anyt]      , filter:(val) => val.a > 0\})
			        guard(\{source:ab        , target:[aNum,voidt]     , filter:(val) => val.a > 0\})
			        guard(\{source:ab        , target:[aNum,anyt,voidt], filter:(val) => val.a > 0\})
			        guard(\{source:ab        , target:[aNum]           , filter:\$filter           \})
			        guard(\{source:ab        , target:[aNum,anyt]      , filter:\$filter           \})
			        guard(\{source:ab        , target:[aNum,voidt]     , filter:\$filter           \})
			        guard(\{source:ab        , target:[aNum,anyt,voidt], filter:\$filter           \})
			        guard(\{source:ab        , target:[aNum]           , filter:Boolean           \})
			        guard(\{source:ab        , target:[aNum,anyt]      , filter:Boolean           \})
			        guard(\{source:ab        , target:[aNum,voidt]     , filter:Boolean           \})
			        guard(\{source:ab        , target:[aNum,anyt,voidt], filter:Boolean           \})
			        guard(\{source:nullableAB, target:[aNum]           , filter:Boolean           \})
			        guard(\{source:nullableAB, target:[aNum,anyt]      , filter:Boolean           \})
			        guard(\{source:nullableAB, target:[aNum,voidt]     , filter:Boolean           \})
			        guard(\{source:nullableAB, target:[aNum,anyt,voidt], filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , target:[aStr,anyt,voidt], filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, target:[aStr,anyt,voidt], filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> array same', () => \{
			    test('unit + clock -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , clock:anyt       , target:[ab]           , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,anyt]      , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,voidt]     , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,anyt,voidt], filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:numt       , target:[ab]           , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:numt       , target:[ab,anyt]      , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:numt       , target:[ab,voidt]     , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:numt       , target:[ab,anyt,voidt], filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab]           , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,anyt]      , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,voidt]     , filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,anyt,voidt], filter:(val) => val.a > 0                           \})
			        guard(\{source:ab        , clock:[numt,\$num], target:[ab]           , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:[numt,\$num], target:[ab,anyt]      , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:[numt,\$num], target:[ab,voidt]     , filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:[numt,\$num], target:[ab,anyt,voidt], filter:(val,n) => val.a > n                         \})
			        guard(\{source:ab        , clock:anyt       , target:[ab]           , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,anyt]      , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,voidt]     , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,anyt,voidt], filter:\$filter                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab]           , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,anyt]      , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,voidt]     , filter:\$filter                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,anyt,voidt], filter:\$filter                                      \})
			        guard(\{source:ab        , clock:anyt       , target:[ab]           , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,anyt]      , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,voidt]     , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:anyt       , target:[ab,anyt,voidt], filter:Boolean                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab]           , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,anyt]      , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,voidt]     , filter:Boolean                                      \})
			        guard(\{source:ab        , clock:[anyt]     , target:[ab,anyt,voidt], filter:Boolean                                      \})
			        guard(\{source:abNull    , clock:anyt       , target:[ab]           , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:anyt       , target:[ab,anyt]      , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:anyt       , target:[ab,voidt]     , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:anyt       , target:[ab,anyt,voidt], filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:numt       , target:[ab]           , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:numt       , target:[ab,anyt]      , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:numt       , target:[ab,voidt]     , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:numt       , target:[ab,anyt,voidt], filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:[anyt]     , target:[ab]           , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:[anyt]     , target:[ab,anyt]      , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:[anyt]     , target:[ab,voidt]     , filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:[anyt]     , target:[ab,anyt,voidt], filter:(val): val is AB => val.a !== null           \})
			        guard(\{source:abNull    , clock:[numt,\$num], target:[ab]           , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:[numt,\$num], target:[ab,anyt]      , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:[numt,\$num], target:[ab,voidt]     , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:abNull    , clock:[numt,\$num], target:[ab,anyt,voidt], filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        guard(\{source:nullableAB, clock:anyt       , target:[ab]           , filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:anyt       , target:[ab,anyt]      , filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:anyt       , target:[ab,voidt]     , filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:anyt       , target:[ab,anyt,voidt], filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[ab]           , filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[ab,anyt]      , filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[ab,voidt]     , filter:Boolean                                      \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[ab,anyt,voidt], filter:Boolean                                      \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn]           , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,anyt]      , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,voidt]     , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,anyt,voidt], filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn]           , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,anyt]      , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,voidt]     , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,anyt,voidt], filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn]           , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,anyt]      , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,voidt]     , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,anyt,voidt], filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn]           , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,anyt]      , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,voidt]     , filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,anyt,voidt], filter:\$filter                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[abn,anyt,voidt], filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[abn,anyt,voidt], filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:anyt  , target:[abn]           , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:anyt  , target:[abn,anyt]      , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:anyt  , target:[abn,voidt]     , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:anyt  , target:[abn,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:[anyt], target:[abn]           , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:[anyt], target:[abn,anyt]      , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:[anyt], target:[abn,voidt]     , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:abNull    , clock:[anyt], target:[abn,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[abn,anyt,voidt], filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[abn,anyt,voidt], filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> array wide', () => \{
			    test('unit + clock -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:ab        , clock:anyt       , target:[aNum]           , filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:numt       , target:[aNum]           , filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:numt       , target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:numt       , target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:numt       , target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum]           , filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        guard(\{source:ab        , clock:[numt,\$num], target:[aNum]           , filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:[numt,\$num], target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:[numt,\$num], target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:[numt,\$num], target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        guard(\{source:ab        , clock:anyt       , target:[aNum]           , filter:\$filter             \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,anyt]      , filter:\$filter             \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,voidt]     , filter:\$filter             \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,anyt,voidt], filter:\$filter             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum]           , filter:\$filter             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,anyt]      , filter:\$filter             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,voidt]     , filter:\$filter             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,anyt,voidt], filter:\$filter             \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum]           , filter:Boolean             \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,anyt]      , filter:Boolean             \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,voidt]     , filter:Boolean             \})
			        guard(\{source:ab        , clock:anyt       , target:[aNum,anyt,voidt], filter:Boolean             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum]           , filter:Boolean             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,anyt]      , filter:Boolean             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,voidt]     , filter:Boolean             \})
			        guard(\{source:ab        , clock:[anyt]     , target:[aNum,anyt,voidt], filter:Boolean             \})
			        guard(\{source:nullableAB, clock:anyt       , target:[aNum]           , filter:Boolean             \})
			        guard(\{source:nullableAB, clock:anyt       , target:[aNum,anyt]      , filter:Boolean             \})
			        guard(\{source:nullableAB, clock:anyt       , target:[aNum,voidt]     , filter:Boolean             \})
			        guard(\{source:nullableAB, clock:anyt       , target:[aNum,anyt,voidt], filter:Boolean             \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[aNum]           , filter:Boolean             \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[aNum,anyt]      , filter:Boolean             \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[aNum,voidt]     , filter:Boolean             \})
			        guard(\{source:nullableAB, clock:[anyt]     , target:[aNum,anyt,voidt], filter:Boolean             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:anyt  , target:[aStr,anyt,voidt], filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:ab        , clock:[anyt], target:[aStr,anyt,voidt], filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:anyt  , target:[aStr,anyt,voidt], filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        guard(\{source:nullableAB, clock:[anyt], target:[aStr,anyt,voidt], filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('object source', () => \{
			  describe('object -> array same', () => \{
			    test('object -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}, target:[ab]           , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[ab,anyt]      , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[ab,voidt]     , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[ab,anyt,voidt], filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[ab]           , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:[ab,anyt]      , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:[ab,voidt]     , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:[ab,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn]           , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn]           , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[abn,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('object -> array wide', () => \{
			    test('object -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}, target:[aNum]           , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[aNum,anyt]      , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[aNum,voidt]     , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[aNum,anyt,voidt], filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:[aNum]           , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:[aNum,anyt]      , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:[aNum,voidt]     , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:[aNum,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:[aStr,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> array same', () => \{
			    test('object + clock -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab]           , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab,anyt]      , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab,voidt]     , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab,anyt,voidt], filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:numt       , target:[ab]           , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:[ab,anyt]      , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:[ab,voidt]     , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:[ab,anyt,voidt], filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab]           , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt]      , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab,voidt]     , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt,voidt], filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[ab]           , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[ab,anyt]      , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[ab,voidt]     , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[ab,anyt,voidt], filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab]           , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab,anyt]      , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab,voidt]     , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[ab,anyt,voidt], filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab]           , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt]      , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab,voidt]     , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt,voidt], filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn]           , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn]           , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn]           , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[abn,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn]           , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> array wide', () => \{
			    test('object + clock -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum]           , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:numt       , target:[aNum]           , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum]           , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum]           , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum]           , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum,anyt]      , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum,voidt]     , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:[aNum,anyt,voidt], filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum]           , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt]      , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,voidt]     , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt,voidt], filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:[aStr,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('object -> unit same', () => \{
			    test('object -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}, target:ab   , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:anyt , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:voidt, filter:(val) => val.a > 0\})
			        guard(\{source:\{a\}  , target:aNum , filter:(val) => val.a > 0\})
			        guard(\{source:\{a,b\}, target:ab   , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:anyt , filter:\$filter           \})
			        guard(\{source:\{a,b\}, target:voidt, filter:\$filter           \})
			        guard(\{source:\{a\}  , target:aNum , filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:abn , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , target:ab  , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, target:abn , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , target:ab  , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , target:aStr, filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('object -> unit wide', () => \{
			    test('object -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}     , target:aNum, filter:(val) => val.a > 0                                        \})
			        guard(\{source:\{a,b\}     , target:aNum, filter:\$filter                                                   \})
			        guard(\{source:\{a:aOpt,b\}, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}     , target:aStr, filter:(val) => val.a > 0                             \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}     , target:aStr, filter:\$filter                                        \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, target:aNum, filter:\$filter                                        \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> unit same', () => \{
			    test('object + clock -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}, clock:anyt       , target:ab   , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:anyt , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:voidt, filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:numt       , target:ab   , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:anyt , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:numt       , target:voidt, filter:(val,n) => val.a > n\})
			        guard(\{source:\{a\}  , clock:anyt       , target:aNum , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a\}  , clock:numt       , target:aNum , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:ab   , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:anyt , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:voidt, filter:(val) => val.a > 0  \})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:ab   , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:anyt , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:[numt,\$num], target:voidt, filter:(val,n) => val.a > n\})
			        guard(\{source:\{a\}  , clock:[anyt]     , target:aNum , filter:(val) => val.a > 0  \})
			        guard(\{source:\{a\}  , clock:[numt,\$num], target:aNum , filter:(val,n) => val.a > n\})
			        guard(\{source:\{a,b\}, clock:anyt       , target:ab   , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:anyt , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:anyt       , target:voidt, filter:\$filter             \})
			        guard(\{source:\{a\}  , clock:anyt       , target:aNum , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:ab   , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:anyt , filter:\$filter             \})
			        guard(\{source:\{a,b\}, clock:[anyt]     , target:voidt, filter:\$filter             \})
			        guard(\{source:\{a\}  , clock:[anyt]     , target:aNum , filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:abn , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:anyt  , target:ab  , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:anyt  , target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:abn , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:[anyt], target:ab  , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:[anyt], target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:anyt  , target:abn , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:anyt  , target:ab  , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:anyt  , target:aStr, filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}, clock:[anyt], target:abn , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:[anyt], target:ab  , filter:\$filter           \})
			        //@ts-expect-error
			        guard(\{source:\{a\}  , clock:[anyt], target:aStr, filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> unit wide', () => \{
			    test('object + clock -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:\{a,b\}     , clock:anyt       , target:aNum, filter:(val) => val.a > 0                                          \})
			        guard(\{source:\{a,b\}     , clock:numt       , target:aNum, filter:(val,n) => val.a > n                                        \})
			        guard(\{source:\{a,b\}     , clock:[anyt]     , target:aNum, filter:(val) => val.a > 0                                          \})
			        guard(\{source:\{a,b\}     , clock:[numt,\$num], target:aNum, filter:(val,n) => val.a > n                                        \})
			        guard(\{source:\{a,b\}     , clock:anyt       , target:aNum, filter:\$filter                                                     \})
			        guard(\{source:\{a,b\}     , clock:[anyt]     , target:aNum, filter:\$filter                                                     \})
			        guard(\{source:\{a:aOpt,b\}, clock:anyt       , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  \})
			        guard(\{source:\{a:aOpt,b\}, clock:numt       , target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n\})
			        guard(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  \})
			        guard(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:\{a,b\}     , clock:anyt       , target:aStr, filter:(val) => val.a > 0                               \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, clock:anyt       , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0  \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, clock:numt       , target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}     , clock:[anyt]     , target:aStr, filter:(val) => val.a > 0                               \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0  \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n\})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}     , clock:anyt       , target:aStr, filter:\$filter                                          \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, clock:anyt       , target:aNum, filter:\$filter                                          \})
			        //@ts-expect-error
			        guard(\{source:\{a,b\}     , clock:[anyt]     , target:aStr, filter:\$filter                                          \})
			        //@ts-expect-error
			        guard(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:\$filter                                          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<\{ a: number; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('tuple source', () => \{
			  describe('tuple -> array same', () => \{
			    test('tuple -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:[a,b], target:[lNumStr]           , filter:(val) => val[0] > 0\})
			        guard(\{source:[a,b], target:[lNumStr,anyt]      , filter:(val) => val[0] > 0\})
			        guard(\{source:[a,b], target:[lNumStr,voidt]     , filter:(val) => val[0] > 0\})
			        guard(\{source:[a,b], target:[lNumStr,anyt,voidt], filter:(val) => val[0] > 0\})
			        guard(\{source:[a,b], target:[lNumStr]           , filter:\$filter            \})
			        guard(\{source:[a,b], target:[lNumStr,anyt]      , filter:\$filter            \})
			        guard(\{source:[a,b], target:[lNumStr,voidt]     , filter:\$filter            \})
			        guard(\{source:[a,b], target:[lNumStr,anyt,voidt], filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('tuple -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum]           , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum,anyt]      , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum,voidt]     , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum,anyt,voidt], filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum]           , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum,anyt]      , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum,voidt]     , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:[lNumNum,anyt,voidt], filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple + clock -> array same', () => \{
			    test('tuple + clock -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr]           , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr,anyt]      , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr,voidt]     , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr,anyt,voidt], filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:numt       , target:[lNumStr]           , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:numt       , target:[lNumStr,anyt]      , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:numt       , target:[lNumStr,voidt]     , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:numt       , target:[lNumStr,anyt,voidt], filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr]           , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt]      , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr,voidt]     , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt,voidt], filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:[numt,\$num], target:[lNumStr]           , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:[numt,\$num], target:[lNumStr,anyt]      , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:[numt,\$num], target:[lNumStr,voidt]     , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:[numt,\$num], target:[lNumStr,anyt,voidt], filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr]           , filter:\$filter               \})
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr,anyt]      , filter:\$filter               \})
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr,voidt]     , filter:\$filter               \})
			        guard(\{source:[a,b], clock:anyt       , target:[lNumStr,anyt,voidt], filter:\$filter               \})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr]           , filter:\$filter               \})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt]      , filter:\$filter               \})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr,voidt]     , filter:\$filter               \})
			        guard(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt,voidt], filter:\$filter               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('tuple + clock -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum]           , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum,anyt]      , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum,voidt]     , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum,anyt,voidt], filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum]           , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt]      , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum,voidt]     , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt,voidt], filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum]           , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum,anyt]      , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum,voidt]     , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:[lNumNum,anyt,voidt], filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum]           , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt]      , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum,voidt]     , filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt,voidt], filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple -> unit same', () => \{
			    test('tuple -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:[a,b], target:lNumStr, filter:(val) => val[0] > 0\})
			        guard(\{source:[a,b], target:anyt   , filter:(val) => val[0] > 0\})
			        guard(\{source:[a,b], target:voidt  , filter:(val) => val[0] > 0\})
			        guard(\{source:[a]  , target:lNum   , filter:(val) => val[0] > 0\})
			        guard(\{source:[a,b], target:lNumStr, filter:\$filter            \})
			        guard(\{source:[a,b], target:anyt   , filter:\$filter            \})
			        guard(\{source:[a,b], target:voidt  , filter:\$filter            \})
			        guard(\{source:[a]  , target:lNum   , filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('tuple -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:[a,b], target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a]  , target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a]  , target:lNumNum, filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple + clock -> unit same', () => \{
			    test('tuple + clock -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{source:[a,b], clock:anyt       , target:lNumStr, filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:anyt       , target:anyt   , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:anyt       , target:voidt  , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:numt       , target:lNumStr, filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:numt       , target:anyt   , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:numt       , target:voidt  , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a]  , clock:anyt       , target:lNum   , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a]  , clock:numt       , target:lNum   , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:[anyt]     , target:lNumStr, filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:[anyt]     , target:anyt   , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:[anyt]     , target:voidt  , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a,b], clock:[numt,\$num], target:lNumStr, filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:[numt,\$num], target:anyt   , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:[numt,\$num], target:voidt  , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a]  , clock:[anyt]     , target:lNum   , filter:(val) => val[0] > 0   \})
			        guard(\{source:[a]  , clock:[numt,\$num], target:lNum   , filter:(val, n) => val[0] > n\})
			        guard(\{source:[a,b], clock:anyt       , target:lNumStr, filter:\$filter               \})
			        guard(\{source:[a,b], clock:anyt       , target:anyt   , filter:\$filter               \})
			        guard(\{source:[a,b], clock:anyt       , target:voidt  , filter:\$filter               \})
			        guard(\{source:[a]  , clock:anyt       , target:lNum   , filter:\$filter               \})
			        guard(\{source:[a,b], clock:[anyt]     , target:lNumStr, filter:\$filter               \})
			        guard(\{source:[a,b], clock:[anyt]     , target:anyt   , filter:\$filter               \})
			        guard(\{source:[a,b], clock:[anyt]     , target:voidt  , filter:\$filter               \})
			        guard(\{source:[a]  , clock:[anyt]     , target:lNum   , filter:\$filter               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('tuple + clock -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a]  , clock:anyt  , target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a]  , clock:[anyt], target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:anyt  , target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a]  , clock:anyt  , target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a,b], clock:[anyt], target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        guard(\{source:[a]  , clock:[anyt], target:lNumNum, filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('no source', () => \{
			  test('clock -> unit same (should pass)', () => \{
			    //prettier-ignore
			    \{
			      guard(\{clock:anyt  , target:numt, filter:(n) => n > 0                                      \})
			      guard(\{clock:[anyt], target:numt, filter:(n) => n > 0                                      \})
			      guard(\{clock:anyt  , target:numt, filter:\$filter                                           \})
			      guard(\{clock:[anyt], target:numt, filter:\$filter                                           \})
			      guard(\{clock:anyt  , target:numt, filter:Boolean                                           \})
			      guard(\{clock:[anyt], target:numt, filter:Boolean                                           \})
			      guard(\{clock:anyt  , target:numt, filter:(n): n is number => typeof n === 'number' && n > 0\})
			      guard(\{clock:[anyt], target:numt, filter:(n): n is number => typeof n === 'number' && n > 0\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('clock -> array same (should pass)', () => \{
			    //prettier-ignore
			    \{
			      guard(\{clock:anyt  , filter:(n) => n > 0                                      \})
			      guard(\{clock:[anyt], filter:(n) => n > 0                                      \})
			      guard(\{clock:anyt  , filter:\$filter                                           \})
			      guard(\{clock:[anyt], filter:\$filter                                           \})
			      guard(\{clock:anyt  , filter:Boolean                                           \})
			      guard(\{clock:[anyt], filter:Boolean                                           \})
			      guard(\{clock:anyt  , filter:(n): n is number => typeof n === 'number' && n > 0\})
			      guard(\{clock:[anyt], filter:(n): n is number => typeof n === 'number' && n > 0\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\generated\\guard.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(42)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleArrayTarget.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample\} from 'effector'
			const typecheck = '\{global\}'
			\{
			  const voidt = createEvent()
			  const anyt = createEvent<any>()
			  const str = createEvent<string>()
			  const num = createEvent<number>()
			  const numStr = createEvent<number | string>()
			  const strBool = createEvent<string | boolean>()
			  describe('no fn', () => \{
			    test('no fn (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:num, target:[num]           \})
			        sample(\{source:num, target:[voidt]         \})
			        sample(\{source:num, target:[anyt]          \})
			        sample(\{source:num, target:[numStr]        \})
			        sample(\{source:num, target:[num,voidt]     \})
			        sample(\{source:num, target:[anyt,num]      \})
			        sample(\{source:num, target:[num,numStr]    \})
			        sample(\{source:num, target:[anyt,voidt]    \})
			        sample(\{source:num, target:[numStr,voidt]  \})
			        sample(\{source:num, target:[anyt,numStr]   \})
			        sample(\{source:str, target:[voidt]         \})
			        sample(\{source:str, target:[str]           \})
			        sample(\{source:str, target:[anyt]          \})
			        sample(\{source:str, target:[strBool]       \})
			        sample(\{source:str, target:[numStr]        \})
			        sample(\{source:str, target:[anyt,voidt]    \})
			        sample(\{source:str, target:[strBool,voidt] \})
			        sample(\{source:str, target:[numStr,voidt]  \})
			        sample(\{source:str, target:[str,voidt]     \})
			        sample(\{source:str, target:[anyt,str]      \})
			        sample(\{source:str, target:[numStr,str]    \})
			        sample(\{source:str, target:[anyt,numStr]   \})
			        sample(\{source:str, target:[anyt,strBool]  \})
			        sample(\{source:str, target:[numStr,strBool]\})
			        sample(\{clock:num, target:[num]           \})
			        sample(\{clock:num, target:[voidt]         \})
			        sample(\{clock:num, target:[anyt]          \})
			        sample(\{clock:num, target:[numStr]        \})
			        sample(\{clock:num, target:[num,voidt]     \})
			        sample(\{clock:num, target:[anyt,num]      \})
			        sample(\{clock:num, target:[num,numStr]    \})
			        sample(\{clock:num, target:[anyt,voidt]    \})
			        sample(\{clock:num, target:[numStr,voidt]  \})
			        sample(\{clock:num, target:[anyt,numStr]   \})
			        sample(\{clock:str, target:[voidt]         \})
			        sample(\{clock:str, target:[str]           \})
			        sample(\{clock:str, target:[anyt]          \})
			        sample(\{clock:str, target:[strBool]       \})
			        sample(\{clock:str, target:[numStr]        \})
			        sample(\{clock:str, target:[anyt,voidt]    \})
			        sample(\{clock:str, target:[strBool,voidt] \})
			        sample(\{clock:str, target:[numStr,voidt]  \})
			        sample(\{clock:str, target:[str,voidt]     \})
			        sample(\{clock:str, target:[anyt,str]      \})
			        sample(\{clock:str, target:[numStr,str]    \})
			        sample(\{clock:str, target:[anyt,numStr]   \})
			        sample(\{clock:str, target:[anyt,strBool]  \})
			        sample(\{clock:str, target:[numStr,strBool]\})
			        sample(\{source:num, clock:num, target:[num]           \})
			        sample(\{source:num, clock:num, target:[voidt]         \})
			        sample(\{source:num, clock:num, target:[anyt]          \})
			        sample(\{source:num, clock:num, target:[numStr]        \})
			        sample(\{source:num, clock:num, target:[num,voidt]     \})
			        sample(\{source:num, clock:num, target:[anyt,num]      \})
			        sample(\{source:num, clock:num, target:[num,numStr]    \})
			        sample(\{source:num, clock:num, target:[anyt,voidt]    \})
			        sample(\{source:num, clock:num, target:[numStr,voidt]  \})
			        sample(\{source:num, clock:num, target:[anyt,numStr]   \})
			        sample(\{source:num, clock:str, target:[num]           \})
			        sample(\{source:num, clock:str, target:[voidt]         \})
			        sample(\{source:num, clock:str, target:[anyt]          \})
			        sample(\{source:num, clock:str, target:[numStr]        \})
			        sample(\{source:num, clock:str, target:[num,voidt]     \})
			        sample(\{source:num, clock:str, target:[anyt,num]      \})
			        sample(\{source:num, clock:str, target:[num,numStr]    \})
			        sample(\{source:num, clock:str, target:[anyt,voidt]    \})
			        sample(\{source:num, clock:str, target:[numStr,voidt]  \})
			        sample(\{source:num, clock:str, target:[anyt,numStr]   \})
			        sample(\{source:str, clock:num, target:[voidt]         \})
			        sample(\{source:str, clock:num, target:[str]           \})
			        sample(\{source:str, clock:num, target:[anyt]          \})
			        sample(\{source:str, clock:num, target:[strBool]       \})
			        sample(\{source:str, clock:num, target:[numStr]        \})
			        sample(\{source:str, clock:num, target:[anyt,voidt]    \})
			        sample(\{source:str, clock:num, target:[strBool,voidt] \})
			        sample(\{source:str, clock:num, target:[numStr,voidt]  \})
			        sample(\{source:str, clock:num, target:[str,voidt]     \})
			        sample(\{source:str, clock:num, target:[anyt,str]      \})
			        sample(\{source:str, clock:num, target:[numStr,str]    \})
			        sample(\{source:str, clock:num, target:[anyt,numStr]   \})
			        sample(\{source:str, clock:num, target:[anyt,strBool]  \})
			        sample(\{source:str, clock:num, target:[numStr,strBool]\})
			        sample(\{source:str, clock:str, target:[voidt]         \})
			        sample(\{source:str, clock:str, target:[str]           \})
			        sample(\{source:str, clock:str, target:[anyt]          \})
			        sample(\{source:str, clock:str, target:[strBool]       \})
			        sample(\{source:str, clock:str, target:[numStr]        \})
			        sample(\{source:str, clock:str, target:[anyt,voidt]    \})
			        sample(\{source:str, clock:str, target:[strBool,voidt] \})
			        sample(\{source:str, clock:str, target:[numStr,voidt]  \})
			        sample(\{source:str, clock:str, target:[str,voidt]     \})
			        sample(\{source:str, clock:str, target:[anyt,str]      \})
			        sample(\{source:str, clock:str, target:[numStr,str]    \})
			        sample(\{source:str, clock:str, target:[anyt,numStr]   \})
			        sample(\{source:str, clock:str, target:[anyt,strBool]  \})
			        sample(\{source:str, clock:str, target:[numStr,strBool]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('no fn (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:num, target:[str]           \})
			        //@ts-expect-error
			        sample(\{source:num, target:[strBool]       \})
			        //@ts-expect-error
			        sample(\{source:num, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{source:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{source:num, target:[strBool,voidt] \})
			        //@ts-expect-error
			        sample(\{source:num, target:[str,voidt]     \})
			        //@ts-expect-error
			        sample(\{source:num, target:[anyt,str]      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[numStr,str]    \})
			        //@ts-expect-error
			        sample(\{source:num, target:[anyt,strBool]  \})
			        //@ts-expect-error
			        sample(\{source:num, target:[numStr,strBool]\})
			        //@ts-expect-error
			        sample(\{source:str, target:[num]           \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,voidt]     \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{source:str, target:[anyt,num]      \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,numStr]    \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[str]           \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[strBool]       \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[strBool,voidt] \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[str,voidt]     \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[anyt,str]      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[numStr,str]    \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[anyt,strBool]  \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[numStr,strBool]\})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num]           \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,voidt]     \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[anyt,num]      \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,numStr]    \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[str]           \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[strBool]       \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[strBool,voidt] \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[str,voidt]     \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[anyt,str]      \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[numStr,str]    \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[anyt,strBool]  \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[numStr,strBool]\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[str]           \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[strBool]       \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[strBool,voidt] \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[str,voidt]     \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,str]      \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[numStr,str]    \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,strBool]  \})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[numStr,strBool]\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num]           \})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,voidt]     \})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt,num]      \})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,numStr]    \})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num]           \})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,voidt]     \})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[anyt,num]      \})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,numStr]    \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<number>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: Event<string | boolean>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; target: Event<number>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; target: (Event<void> | Event<number>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: Event<string | boolean>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<string>; target: Event<number>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ clock: Event<string>; target: (Event<void> | Event<number>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: Event<string | boolean>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<string>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<string>; target: Event<string | boolean>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<string>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<string>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<number>; target: Event<number>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<number>; target: (Event<void> | Event<number>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<string>; target: Event<number>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<string>; target: (Event<void> | Event<number>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('untyped fn', () => \{
			    test('untyped fn (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:num, target:[num]           , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[voidt]         , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[anyt]          , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[numStr]        , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[num,voidt]     , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[anyt,num]      , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[num,numStr]    , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[anyt,voidt]    , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[numStr,voidt]  , fn:(src) => src + 1      \})
			        sample(\{source:num, target:[anyt,numStr]   , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[voidt]         , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[str]           , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[anyt]          , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[strBool]       , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[numStr]        , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[anyt,voidt]    , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[strBool,voidt] , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[numStr,voidt]  , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[str,voidt]     , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[anyt,str]      , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[numStr,str]    , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[anyt,numStr]   , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[anyt,strBool]  , fn:(src) => src + 1      \})
			        sample(\{source:str, target:[numStr,strBool], fn:(src) => src + 1      \})
			        sample(\{clock:num, target:[num]           , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[voidt]         , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[anyt]          , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[numStr]        , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[num,voidt]     , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[anyt,num]      , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[num,numStr]    , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[anyt,voidt]    , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[numStr,voidt]  , fn:(clk) => clk + 1      \})
			        sample(\{clock:num, target:[anyt,numStr]   , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[voidt]         , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[str]           , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[anyt]          , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[strBool]       , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[numStr]        , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[anyt,voidt]    , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[strBool,voidt] , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[numStr,voidt]  , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[str,voidt]     , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[anyt,str]      , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[numStr,str]    , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[anyt,numStr]   , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[anyt,strBool]  , fn:(clk) => clk + 1      \})
			        sample(\{clock:str, target:[numStr,strBool], fn:(clk) => clk + 1      \})
			        sample(\{source:num, clock:num, target:[num]           , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[voidt]         , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[anyt]          , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[numStr]        , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[num,voidt]     , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[anyt,num]      , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[num,numStr]    , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[anyt,voidt]    , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[numStr,voidt]  , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:num, target:[anyt,numStr]   , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[voidt]         , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[str]           , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[anyt]          , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[strBool]       , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[numStr]        , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[anyt,voidt]    , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[strBool,voidt] , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[numStr,voidt]  , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[str,voidt]     , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[anyt,str]      , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[numStr,str]    , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[anyt,numStr]   , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[anyt,strBool]  , fn:(src,clk) => src + clk\})
			        sample(\{source:num, clock:str, target:[numStr,strBool], fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[voidt]         , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[str]           , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[anyt]          , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[strBool]       , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[numStr]        , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[anyt,voidt]    , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[strBool,voidt] , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[numStr,voidt]  , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[str,voidt]     , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[anyt,str]      , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[numStr,str]    , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[anyt,numStr]   , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[anyt,strBool]  , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:num, target:[numStr,strBool], fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[voidt]         , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[str]           , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[anyt]          , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[strBool]       , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[numStr]        , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[anyt,voidt]    , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[strBool,voidt] , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[numStr,voidt]  , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[str,voidt]     , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[anyt,str]      , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[numStr,str]    , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[anyt,numStr]   , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[anyt,strBool]  , fn:(src,clk) => src + clk\})
			        sample(\{source:str, clock:str, target:[numStr,strBool], fn:(src,clk) => src + clk\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('untyped fn (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:num, target:[str]           , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[strBool]       , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[num,str]       , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[num,strBool]   , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[strBool,voidt] , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[str,voidt]     , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[anyt,str]      , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[numStr,str]    , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[anyt,strBool]  , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, target:[numStr,strBool], fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num]           , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,voidt]     , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,str]       , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:str, target:[anyt,num]      , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,strBool]   , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{source:str, target:[num,numStr]    , fn:(src) => src + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[str]           , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[strBool]       , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[num,str]       , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[num,strBool]   , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[strBool,voidt] , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[str,voidt]     , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[anyt,str]      , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[numStr,str]    , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[anyt,strBool]  , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[numStr,strBool], fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num]           , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,voidt]     , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,str]       , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[anyt,num]      , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,strBool]   , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{clock:str, target:[num,numStr]    , fn:(clk) => clk + 1      \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[str]           , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[strBool]       , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[num,str]       , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[num,strBool]   , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[strBool,voidt] , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[str,voidt]     , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[anyt,str]      , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[numStr,str]    , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[anyt,strBool]  , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[numStr,strBool], fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num]           , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,voidt]     , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,str]       , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,num]      , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,strBool]   , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,numStr]    , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num]           , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,voidt]     , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,str]       , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt,num]      , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,strBool]   , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,numStr]    , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num]           , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,voidt]     , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,str]       , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[anyt,num]      , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,strBool]   , fn:(src,clk) => src + clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:str, target:[num,numStr]    , fn:(src,clk) => src + clk\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<number>; target: Event<string>[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: Event<string | boolean>[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: (Event<void> | Event<string | boolean>)[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: (Event<void> | Event<string>)[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; target: Event<number>[]; fn: (src: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; target: (Event<void> | Event<number>)[]; fn: (src: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: Event<string>[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: Event<string | boolean>[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: (Event<void> | Event<string>)[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<string>; target: Event<number>[]; fn: (clk: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ clock: Event<string>; target: (Event<void> | Event<number>)[]; fn: (clk: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: Event<string>[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: Event<string | boolean>[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string>)[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<string>; target: Event<number>[]; fn: (src: number, clk: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<string>; target: (Event<void> | Event<number>)[]; fn: (src: number, clk: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<number>; target: Event<number>[]; fn: (src: string, clk: number) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<number>; target: (Event<void> | Event<number>)[]; fn: (src: string, clk: number) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<string>; target: Event<number>[]; fn: (src: string, clk: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ source: Event<string>; clock: Event<string>; target: (Event<void> | Event<number>)[]; fn: (src: string, clk: string) => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number | void; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('typed fn', () => \{
			    test('typed fn (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:num, target:[num]         , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[voidt]       , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[anyt]        , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[numStr]      , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[num,voidt]   , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[anyt,num]    , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[num,numStr]  , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[anyt,voidt]  , fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[numStr,voidt], fn:(src:number) => src+1             \})
			        sample(\{source:num, target:[anyt,numStr] , fn:(src:number) => src+1             \})
			        sample(\{clock:num, target:[num]         , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[voidt]       , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[anyt]        , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[numStr]      , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[num,voidt]   , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[anyt,num]    , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[num,numStr]  , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[anyt,voidt]  , fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[numStr,voidt], fn:(clk:number) => clk+1             \})
			        sample(\{clock:num, target:[anyt,numStr] , fn:(clk:number) => clk+1             \})
			        sample(\{source:num, clock:num, target:[num]         , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[voidt]       , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[anyt]        , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[numStr]      , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[num,voidt]   , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[anyt,num]    , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[num,numStr]  , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[anyt,voidt]  , fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[numStr,voidt], fn:(src:number,clk:number) => src+clk\})
			        sample(\{source:num, clock:num, target:[anyt,numStr] , fn:(src:number,clk:number) => src+clk\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('typed fn (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:num, target:[str]           , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[strBool]       , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[num,str]       , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[num,strBool]   , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[strBool,voidt] , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[str,voidt]     , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[anyt,str]      , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[numStr,str]    , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[anyt,strBool]  , fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{source:num, target:[numStr,strBool], fn:(src:number) => src+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[str]           , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[strBool]       , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[num,str]       , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[num,strBool]   , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[strBool,voidt] , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[str,voidt]     , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[anyt,str]      , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[numStr,str]    , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[anyt,strBool]  , fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{clock:num, target:[numStr,strBool], fn:(clk:number) => clk+1             \})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[str]           , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[strBool]       , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[num,str]       , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[num,strBool]   , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[strBool,voidt] , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[str,voidt]     , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[anyt,str]      , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[numStr,str]    , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[anyt,strBool]  , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:num, target:[numStr,strBool], fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num]           , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[voidt]         , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[str]           , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt]          , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[strBool]       , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[numStr]        , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,voidt]     , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,str]       , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,num]      , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,strBool]   , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[num,numStr]    , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,voidt]    , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[strBool,voidt] , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[numStr,voidt]  , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[str,voidt]     , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,str]      , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[numStr,str]    , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,numStr]   , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[anyt,strBool]  , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:num, clock:str, target:[numStr,strBool], fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num]           , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[voidt]         , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[str]           , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt]          , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[strBool]       , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[numStr]        , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,voidt]     , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,str]       , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt,num]      , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,strBool]   , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[num,numStr]    , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt,voidt]    , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[strBool,voidt] , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[numStr,voidt]  , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[str,voidt]     , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt,str]      , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[numStr,str]    , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt,numStr]   , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[anyt,strBool]  , fn:(src:number,clk:number) => src+clk\})
			        //@ts-expect-error
			        sample(\{source:str, clock:num, target:[numStr,strBool], fn:(src:number,clk:number) => src+clk\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<number>; target: Event<string>[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: Event<string | boolean>[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: (Event<void> | Event<string | boolean>)[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; target: (Event<void> | Event<string>)[]; fn: (src: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: Event<string>[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: Event<string | boolean>[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ clock: Event<number>; target: (Event<void> | Event<string>)[]; fn: (clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: Event<string>[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: Event<string | boolean>[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string>)[]; fn: (src: number, clk: number) => number; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: number; targetType: string | void; \}[]; \}'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: number, clk: string) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: number, clk: string) => any'.
			            Types of parameters 'clk' and 'clk' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        Type '(src: number, clk: number) => number' is not assignable to type '((src: string, clk: number) => any) & ((src: number, clk: number) => number)'.
			          Type '(src: number, clk: number) => number' is not assignable to type '(src: string, clk: number) => any'.
			            Types of parameters 'src' and 'src' are incompatible.
			              Type 'string' is not assignable to type 'number'.
			        "
			      \`)
			    \})
			  \})
			\}
			\{
			  /** used as valid source type */
			  type AN = \{a: number\}
			  /** used as invalid source type */
			  type AS = \{a: string\}
			  /** used as valid source type */
			  type AB = \{a: number; b: string\}
			  /** used as invalid source type */
			  type ABN = \{a: number; b: number\}
			  const num = createEvent<number>()
			  const \$num = createStore<number>(0)
			  const \$str = createStore<string>('')
			  const a_num = createEvent<AN>()
			  const a_str = createEvent<AS>()
			  const ab = createEvent<AB>()
			  const abn = createEvent<ABN>()
			  const l_num = createEvent<[number]>()
			  const l_str = createEvent<[string]>()
			  const l_num_str = createEvent<[number, string]>()
			  const l_num_num = createEvent<[number, number]>()
			
			  const fn = \{
			    noArgs: () => (\{a: 2, b: ''\}),
			    assertFirst: \{
			      object: \{
			        solo: (\{a\}: AS, cl: number) => (\{a: cl, b: a\}),
			        pair: (\{a, b\}: ABN, cl: number) => (\{a: b + cl, b: ''\}),
			      \},
			      tuple: \{
			        solo: ([a]: [string], cl: number) => (\{a: cl, b: a\}),
			        pair: ([a, b]: [number, number], cl: number) => (\{a: b + cl, b: ''\}),
			      \},
			    \},
			    assertFirstOnly: \{
			      object: \{
			        solo: (\{a\}: AS) => (\{a: 0, b: a\}),
			        pair: (\{b\}: ABN) => (\{a: b, b: ''\}),
			      \},
			      tuple: \{
			        solo: ([a]: [string]) => (\{a: 2, b: a\}),
			        pair: ([, b]: [number, number]) => (\{a: b, b: ''\}),
			      \},
			    \},
			    assertSecond: \{
			      object: \{
			        solo: (\{a\}: AN, cl: string) => (\{a, b: cl\}),
			        pair: (\{a\}: AB, cl: string) => (\{a, b: cl\}),
			      \},
			      tuple: \{
			        solo: ([a]: [number], cl: string) => (\{a, b: cl\}),
			        pair: ([a]: [number, string], cl: string) => (\{a, b: cl\}),
			      \},
			    \},
			    typedSrc: \{
			      object: \{
			        solo: (\{a\}: AN) => (\{a, b: ''\}),
			        pair: (\{a, b\}: AB) => (\{a, b\}),
			      \},
			      tuple: \{
			        solo: ([a]: [number]) => (\{a, b: ''\}),
			        pair: ([a, b]: [number, string]) => (\{a, b\}),
			      \},
			    \},
			    typedSrcClock: \{
			      object: \{
			        solo: (\{a\}: AN, cl: number) => (\{a: a + cl, b: ''\}),
			        pair: (\{a, b\}: AB, cl: number) => (\{a: a + cl, b\}),
			      \},
			      tuple: \{
			        solo: ([a]: [number], cl: number) => (\{a: a + cl, b: ''\}),
			        pair: ([a, b]: [number, string], cl: number) => (\{a: a + cl, b\}),
			      \},
			    \},
			  \}
			  describe('source:wide', () => \{
			    test('source:wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num]          \})
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[ab]             \})
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num,ab]       \})
			        sample(\{source:[\$num,\$str]         , target:[l_num]          \})
			        sample(\{source:[\$num,\$str]         , target:[l_num_str]      \})
			        sample(\{source:[\$num,\$str]         , target:[l_num,l_num_str]\})
			        sample(\{source:[\$num,\$str] as const, target:[l_num]          \})
			        sample(\{source:[\$num,\$str] as const, target:[l_num_str]      \})
			        sample(\{source:[\$num,\$str] as const, target:[l_num,l_num_str]\})
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num]          \})
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[ab]             \})
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num,ab]       \})
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num]          \})
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num_str]      \})
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num,l_num_str]\})
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num]          \})
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num_str]      \})
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num,l_num_str]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number]; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('source:wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[abn]                \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[abn]                \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[l_num_num,l_str]    \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number] | [string]; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('source:wide, fn:untyped', () => \{
			    test('source:wide, fn:untyped (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num]   , fn:(\{a,b\}) => (\{a,b\})\})
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[ab]      , fn:(\{a,b\}) => (\{a,b\})\})
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num,ab], fn:(\{a,b\}) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str]         , target:[a_num]   , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str]         , target:[ab]      , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str]         , target:[a_num,ab], fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str] as const, target:[a_num]   , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str] as const, target:[ab]      , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str] as const, target:[a_num,ab], fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num]   , fn:(\{a,b\}) => (\{a,b\})\})
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[ab]      , fn:(\{a,b\}) => (\{a,b\})\})
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num,ab], fn:(\{a,b\}) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str]         , clock:num, target:[a_num]   , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str]         , clock:num, target:[ab]      , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str]         , clock:num, target:[a_num,ab], fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[a_num]   , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[ab]      , fn:([a,b]) => (\{a,b\})\})
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[a_num,ab], fn:([a,b]) => (\{a,b\})\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<AN>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<AB>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<AN> | Event<AB>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<AN>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<AB>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<AN> | Event<AB>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('source:wide, fn:untyped (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_str]      , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[abn]        , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num,a_str], fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_num,abn]  , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[a_str,ab]   , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[abn,a_str]  , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[abn,ab]     , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , target:[ab,a_str]   , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[a_str]      , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[abn]        , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[a_num,a_str], fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[a_num,abn]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[a_str,ab]   , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[abn,a_str]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[abn,ab]     , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , target:[ab,a_str]   , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[a_str]      , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[abn]        , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[a_num,a_str], fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[a_num,abn]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[a_str,ab]   , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[abn,a_str]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[abn,ab]     , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, target:[ab,a_str]   , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_str]      , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[abn]        , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num,a_str], fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_num,abn]  , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[a_str,ab]   , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[abn,a_str]  , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[abn,ab]     , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num,b:\$str\}     , clock:num, target:[ab,a_str]   , fn:(\{a,b\}) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[a_str]      , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[abn]        , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[a_num,a_str], fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[a_num,abn]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[a_str,ab]   , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[abn,a_str]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[abn,ab]     , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str]         , clock:num, target:[ab,a_str]   , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[a_str]      , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[abn]        , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[a_num,a_str], fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[a_num,abn]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[a_str,ab]   , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[abn,a_str]  , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[abn,ab]     , fn:([a,b]) => (\{a,b\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num,\$str] as const, clock:num, target:[ab,a_str]   , fn:([a,b]) => (\{a,b\})\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<AS>[]; fn: (\{ a, b \}: \{ a: number; b: string; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<ABN>[]; fn: (\{ a, b \}: \{ a: number; b: string; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: (Event<AS> | Event<ABN>)[]; fn: (\{ a, b \}: \{ a: number; b: string; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<AS>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<ABN>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<AN> | Event<AS>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN | AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN | AS; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<AN> | Event<ABN>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<AS> | Event<AB>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<AS> | Event<ABN>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<AB> | Event<ABN>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<AS> | Event<AB>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: Event<AS>[]; fn: ([a, b]: readonly [number, string]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: Event<ABN>[]; fn: ([a, b]: readonly [number, string]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: (Event<AS> | Event<ABN>)[]; fn: ([a, b]: readonly [number, string]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: Event<AS>[]; fn: (\{ a, b \}: \{ a: number; b: string; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: Event<ABN>[]; fn: (\{ a, b \}: \{ a: number; b: string; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; fn: (\{ a, b \}: \{ a: number; b: string; \}) => \{ ...; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<AS>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<ABN>[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<AN> | Event<AS>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN | AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN | AS; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<AN> | Event<ABN>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<AS> | Event<AB>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<AB> | Event<ABN>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AB | ABN; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<AS> | Event<AB>)[]; fn: ([a, b]: (string | number)[]) => \{ a: string | number; b: string | number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string | number; b: string | number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: Event<AS>[]; fn: ([a, b]: readonly [number, string]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: Event<ABN>[]; fn: ([a, b]: readonly [number, string]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; fn: ([a, b]: readonly [number, string]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('source:same', () => \{
			    test('source:same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a:\$num\}       , target:[a_num]\})
			        sample(\{source:[\$num]         , target:[l_num]\})
			        sample(\{source:[\$num] as const, target:[l_num]\})
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num]\})
			        sample(\{source:[\$num]         , clock:num, target:[l_num]\})
			        sample(\{source:[\$num] as const, clock:num, target:[l_num]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Store<number>[]; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('source:same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[abn]                \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[ab]                 \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_num,ab]           \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num_str]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num_str]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[abn]                \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[ab]                 \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num,ab]           \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num_str]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num_str]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[l_num_num,l_str]    \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<AB>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: (Event<AB> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<AB>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AB> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number] | [string]; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('source:same, fn:untyped', () => \{
			    test('source:same, fn:untyped (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a:\$num\}       , target:[a_num]   , fn:(\{a\}) => (\{a,b:''\})\})
			        sample(\{source:\{a:\$num\}       , target:[ab]      , fn:(\{a\}) => (\{a,b:''\})\})
			        sample(\{source:\{a:\$num\}       , target:[a_num,ab], fn:(\{a\}) => (\{a,b:''\})\})
			        sample(\{source:[\$num]         , target:[a_num]   , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num]         , target:[ab]      , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num]         , target:[a_num,ab], fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num] as const, target:[a_num]   , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num] as const, target:[ab]      , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num] as const, target:[a_num,ab], fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num]   , fn:(\{a\}) => (\{a,b:''\})\})
			        sample(\{source:\{a:\$num\}       , clock:num, target:[ab]      , fn:(\{a\}) => (\{a,b:''\})\})
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num,ab], fn:(\{a\}) => (\{a,b:''\})\})
			        sample(\{source:[\$num]         , clock:num, target:[a_num]   , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num]         , clock:num, target:[ab]      , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num]         , clock:num, target:[a_num,ab], fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num] as const, clock:num, target:[a_num]   , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num] as const, clock:num, target:[ab]      , fn:([a]) => (\{a,b:''\})\})
			        sample(\{source:[\$num] as const, clock:num, target:[a_num,ab], fn:([a]) => (\{a,b:''\})\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('source:same, fn:untyped (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_str]      , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[abn]        , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_num,a_str], fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_num,abn]  , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[a_str,ab]   , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[abn,a_str]  , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[abn,ab]     , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , target:[ab,a_str]   , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[a_str]      , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[abn]        , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[a_num,a_str], fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[a_num,abn]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[a_str,ab]   , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[abn,a_str]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[abn,ab]     , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , target:[ab,a_str]   , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[a_str]      , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[abn]        , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[a_num,a_str], fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[a_num,abn]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[a_str,ab]   , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[abn,a_str]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[abn,ab]     , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, target:[ab,a_str]   , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_str]      , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[abn]        , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num,a_str], fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_num,abn]  , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[a_str,ab]   , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[abn,a_str]  , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[abn,ab]     , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:\$num\}       , clock:num, target:[ab,a_str]   , fn:(\{a\}) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[a_str]      , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[abn]        , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[a_num,a_str], fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[a_num,abn]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[a_str,ab]   , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[abn,a_str]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[abn,ab]     , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num]         , clock:num, target:[ab,a_str]   , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[a_str]      , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[abn]        , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[a_num,a_str], fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[a_num,abn]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[a_str,ab]   , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[abn,a_str]  , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[abn,ab]     , fn:([a]) => (\{a,b:''\})\})
			        //@ts-expect-error
			        sample(\{source:[\$num] as const, clock:num, target:[ab,a_str]   , fn:([a]) => (\{a,b:''\})\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<AS>[]; fn: (\{ a \}: \{ a: number; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<ABN>[]; fn: (\{ a \}: \{ a: number; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: (Event<AS> | Event<ABN>)[]; fn: (\{ a \}: \{ a: number; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<AS>[]; fn: ([a]: number[]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<ABN>[]; fn: ([a]: number[]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; target: (Event<AS> | Event<ABN>)[]; fn: ([a]: number[]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: Event<AS>[]; fn: ([a]: readonly [number]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: Event<ABN>[]; fn: ([a]: readonly [number]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: (Event<AS> | Event<ABN>)[]; fn: ([a]: readonly [number]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<AS>[]; fn: (\{ a \}: \{ a: number; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<ABN>[]; fn: (\{ a \}: \{ a: number; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; fn: (\{ a \}: \{ a: number; \}) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: Event<AS>[]; fn: ([a]: number[]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: Event<ABN>[]; fn: ([a]: number[]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; fn: ([a]: number[]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: Event<AS>[]; fn: ([a]: readonly [number]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: Event<ABN>[]; fn: ([a]: readonly [number]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; fn: ([a]: readonly [number]) => \{ a: number; b: string; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			\}
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleArrayTarget.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(14)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleClockArray.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample\} from 'effector'
			const typecheck = '\{global\}'
			type AB = \{a: string; b: number\}
			const voidt = createEvent()
			const anyt = createEvent<any>()
			const str = createEvent<string>()
			const strClk = createEvent<string>()
			const num = createEvent<number>()
			const a = createStore('')
			const b = createStore(0)
			const aTarget = createEvent<\{a: string\}>()
			const abTarget = createEvent<AB>()
			const aclock = createEvent<\{a: string; clock: any\}>()
			const abclock = createEvent<\{a: string; b: number; clock: any\}>()
			const fnAbClockString = (\{a, b\}: AB, clock: string) => (\{a, b, clock\})
			const fnAbClockAny = (\{a, b\}: AB, clock: any) => (\{a, b, clock\})
			const fnAString = (a: string) => (\{a\})
			const fnAStringClockString = (a: string, clock: string) => (\{a, clock\})
			const fnAStringClockAny = (a: string, clock: any) => (\{a, clock\})
			const fnAb = (\{a, b\}: AB) => (\{a, b\})
			describe('fn clock assertion', () => \{
			  test('plain, noTarget (should pass)', () => \{
			    //prettier-ignore
			    sample(\{source:a, clock:[anyt], fn:fnAStringClockString\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('plain, noTarget (should fail)', () => \{
			    //prettier-ignore
			    \{
			      //@ts-expect-error
			      sample(\{source:a, clock:[voidt]     , fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[num]       , fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[voidt,num] , fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[]          , fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[anyt,voidt], fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[anyt,num]  , fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[voidt,anyt], fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[num,anyt]  , fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[num,voidt] , fn:fnAStringClockString\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: void) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			        Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '(src: string, clk: void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'void' is not assignable to type 'string'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: number) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			        Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '(src: string, clk: number) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number' is not assignable to type 'string'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: number | void) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			        Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '(src: string, clk: number | void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number | void' is not assignable to type 'string'.
			              Type 'number' is not assignable to type 'string'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: unknown) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			        Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '(src: string, clk: unknown) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'unknown' is not assignable to type 'string'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: number | void) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			      "
			    \`)
			  \})
			  test('plain (should pass)', () => \{
			    //prettier-ignore
			    sample(\{source:a, clock:[anyt], target:aclock, fn:fnAStringClockString\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('plain (should fail)', () => \{
			    //prettier-ignore
			    \{
			      //@ts-expect-error
			      sample(\{source:a, clock:[voidt]     , target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[num]       , target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[voidt,num] , target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[]          , target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[anyt,voidt], target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[anyt,num]  , target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[voidt,anyt], target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[num,anyt]  , target:aclock, fn:fnAStringClockString\})
			      //@ts-expect-error
			      sample(\{source:a, clock:[num,voidt] , target:aclock, fn:fnAStringClockString\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: void) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: number) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: number | void) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: unknown) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			      Type '(a: string, clock: string) => \{ a: string; clock: string; \}' is not assignable to type '((src: string, clk: number | void) => any) & ((a: string, clock: string) => \{ a: string; clock: string; \})'.
			      "
			    \`)
			  \})
			  test('combinable, noTarget (should pass)', () => \{
			    //prettier-ignore
			    sample(\{source:\{a,b\}, clock:[anyt], fn:fnAbClockString\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combinable, noTarget (should fail)', () => \{
			    //prettier-ignore
			    \{
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[voidt]     , fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[num]       , fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[voidt,num] , fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[]          , fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[anyt,voidt], fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[anyt,num]  , fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[voidt,anyt], fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[num,anyt]  , fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[num,voidt] , fn:fnAbClockString\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: void) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'void' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: number) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: number) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: number | void) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: number | void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number | void' is not assignable to type 'string'.
			              Type 'number' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: unknown) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: unknown) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'unknown' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: number | void) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: number | void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number | void' is not assignable to type 'string'.
			              Type 'number' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			  test('combinable (should pass)', () => \{
			    //prettier-ignore
			    sample(\{source:\{a,b\}, clock:[anyt], target:abclock, fn:fnAbClockString\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('combinable (should fail)', () => \{
			    //prettier-ignore
			    \{
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[voidt]     , target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[num]       , target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[voidt,num] , target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[]          , target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[anyt,voidt], target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[anyt,num]  , target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[voidt,anyt], target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[num,anyt]  , target:abclock, fn:fnAbClockString\})
			      //@ts-expect-error
			      sample(\{source:\{a,b\}, clock:[num,voidt] , target:abclock, fn:fnAbClockString\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: void) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'void' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: number) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: number) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: number | void) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: number | void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number | void' is not assignable to type 'string'.
			              Type 'number' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: unknown) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: unknown) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'unknown' is not assignable to type 'string'.
			      Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '((src: \{ a: string; b: number; \}, clk: number | void) => any) & ((\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \})'.
			        Type '(\{ a, b \}: AB, clock: string) => \{ a: string; b: number; clock: string; \}' is not assignable to type '(src: \{ a: string; b: number; \}, clk: number | void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'number | void' is not assignable to type 'string'.
			              Type 'number' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			\})
			describe('clock only', () => \{
			  test('noSource (should pass)', () => \{
			    //prettier-ignore
			    \{
			      sample(\{clock:strClk       \})
			      sample(\{clock:anyt         \})
			      sample(\{clock:[strClk]     \})
			      sample(\{clock:[anyt]       \})
			      sample(\{clock:[strClk,anyt]\})
			      sample(\{clock:strClk       , target:str\})
			      sample(\{clock:anyt         , target:str\})
			      sample(\{clock:[strClk]     , target:str\})
			      sample(\{clock:[anyt]       , target:str\})
			      sample(\{clock:[strClk,anyt], target:str\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('noSource, fn (should pass)', () => \{
			    //prettier-ignore
			    \{
			      sample(\{clock:voidt         , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:num           , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:strClk        , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:anyt          , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:strClk        , fn:(a) => (\{a\})    \})
			      sample(\{clock:anyt          , fn:(a) => (\{a\})    \})
			      sample(\{clock:strClk        , fn:fnAString       \})
			      sample(\{clock:anyt          , fn:fnAString       \})
			      sample(\{clock:[voidt]       , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[num]         , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk]      , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[anyt]        , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[voidt,num]   , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[voidt,strClk], fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[voidt,anyt]  , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[num,anyt]    , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk,num]  , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk,anyt] , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[anyt,num]    , fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk]      , fn:(a) => (\{a\})    \})
			      sample(\{clock:[anyt]        , fn:(a) => (\{a\})    \})
			      sample(\{clock:[strClk,anyt] , fn:(a) => (\{a\})    \})
			      sample(\{clock:[strClk]      , fn:fnAString       \})
			      sample(\{clock:[anyt]        , fn:fnAString       \})
			      sample(\{clock:[strClk,anyt] , fn:fnAString       \})
			      sample(\{clock:voidt         , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:num           , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:strClk        , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:anyt          , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:strClk        , target:aTarget, fn:(a) => (\{a\})    \})
			      sample(\{clock:anyt          , target:aTarget, fn:(a) => (\{a\})    \})
			      sample(\{clock:strClk        , target:aTarget, fn:fnAString       \})
			      sample(\{clock:anyt          , target:aTarget, fn:fnAString       \})
			      sample(\{clock:[voidt]       , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[num]         , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk]      , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[anyt]        , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[voidt,num]   , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[voidt,strClk], target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[voidt,anyt]  , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[num,anyt]    , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk,num]  , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk,anyt] , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[anyt,num]    , target:aTarget, fn:()=>(\{a:'',b:2\})\})
			      sample(\{clock:[strClk]      , target:aTarget, fn:(a) => (\{a\})    \})
			      sample(\{clock:[anyt]        , target:aTarget, fn:(a) => (\{a\})    \})
			      sample(\{clock:[strClk,anyt] , target:aTarget, fn:(a) => (\{a\})    \})
			      sample(\{clock:[strClk]      , target:aTarget, fn:fnAString       \})
			      sample(\{clock:[anyt]        , target:aTarget, fn:fnAString       \})
			      sample(\{clock:[strClk,anyt] , target:aTarget, fn:fnAString       \})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			test('noClock (should pass)', () => \{
			  //prettier-ignore
			  \{
			    sample(\{source:a    \})
			    sample(\{source:\{a,b\}\})
			    sample(\{source:a    , target:str     \})
			    sample(\{source:\{a,b\}, target:abTarget\})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test(' (should pass)', () => \{
			  //prettier-ignore
			  \{
			    sample(\{source:a    , clock:[voidt]     \})
			    sample(\{source:a    , clock:[str]       \})
			    sample(\{source:a    , clock:[voidt,str] \})
			    sample(\{source:a    , clock:[]          \})
			    sample(\{source:a    , clock:[anyt]      \})
			    sample(\{source:a    , clock:[anyt,voidt]\})
			    sample(\{source:a    , clock:[anyt,str]  \})
			    sample(\{source:a    , clock:[voidt,anyt]\})
			    sample(\{source:a    , clock:[str,anyt]  \})
			    sample(\{source:a    , clock:[str,voidt] \})
			    sample(\{source:\{a,b\}, clock:[voidt]     \})
			    sample(\{source:\{a,b\}, clock:[str]       \})
			    sample(\{source:\{a,b\}, clock:[voidt,str] \})
			    sample(\{source:\{a,b\}, clock:[]          \})
			    sample(\{source:\{a,b\}, clock:[anyt]      \})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt]\})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  \})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt]\})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  \})
			    sample(\{source:\{a,b\}, clock:[str,voidt] \})
			    sample(\{source:a    , clock:[voidt]     , target:str     \})
			    sample(\{source:a    , clock:[str]       , target:str     \})
			    sample(\{source:a    , clock:[voidt,str] , target:str     \})
			    sample(\{source:a    , clock:[]          , target:str     \})
			    sample(\{source:a    , clock:[anyt]      , target:str     \})
			    sample(\{source:a    , clock:[anyt,voidt], target:str     \})
			    sample(\{source:a    , clock:[anyt,str]  , target:str     \})
			    sample(\{source:a    , clock:[voidt,anyt], target:str     \})
			    sample(\{source:a    , clock:[str,anyt]  , target:str     \})
			    sample(\{source:a    , clock:[str,voidt] , target:str     \})
			    sample(\{source:\{a,b\}, clock:[voidt]     , target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[str]       , target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[]          , target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[anyt]      , target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , target:abTarget\})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , target:abTarget\})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('noClock, fn (should pass)', () => \{
			  //prettier-ignore
			  \{
			    sample(\{source:a    , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , fn:fnAString         \})
			    sample(\{source:\{a,b\}, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, fn:fnAb              \})
			    sample(\{source:a    , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , target:aTarget , fn:fnAString         \})
			    sample(\{source:\{a,b\}, target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, target:abTarget, fn:fnAb              \})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('fn (should pass)', () => \{
			  //prettier-ignore
			  \{
			    sample(\{source:a    , clock:[voidt]     , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[str]       , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[voidt,str] , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[voidt]     , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[str]       , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[voidt,str] , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[voidt]     , fn:fnAString         \})
			    sample(\{source:a    , clock:[str]       , fn:fnAString         \})
			    sample(\{source:a    , clock:[voidt,str] , fn:fnAString         \})
			    sample(\{source:a    , clock:[]          , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[anyt]      , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[anyt,voidt], fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[anyt,str]  , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[voidt,anyt], fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[str,anyt]  , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[str,voidt] , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[]          , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[anyt]      , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[anyt,voidt], fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[anyt,str]  , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[voidt,anyt], fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[str,anyt]  , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[str,voidt] , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[]          , fn:fnAString         \})
			    sample(\{source:a    , clock:[anyt]      , fn:fnAString         \})
			    sample(\{source:a    , clock:[anyt,voidt], fn:fnAString         \})
			    sample(\{source:a    , clock:[anyt,str]  , fn:fnAString         \})
			    sample(\{source:a    , clock:[voidt,anyt], fn:fnAString         \})
			    sample(\{source:a    , clock:[str,anyt]  , fn:fnAString         \})
			    sample(\{source:a    , clock:[str,voidt] , fn:fnAString         \})
			    sample(\{source:\{a,b\}, clock:[voidt]     , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[str]       , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[voidt]     , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[str]       , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[voidt]     , fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[str]       , fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[]          , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[anyt]      , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[]          , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[anyt]      , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[]          , fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[anyt]      , fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , fn:fnAb              \})
			    sample(\{source:a    , clock:[voidt]     , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[str]       , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[voidt,str] , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[voidt]     , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[str]       , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[voidt,str] , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[voidt]     , target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[str]       , target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[voidt,str] , target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[]          , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[anyt]      , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[anyt,voidt], target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[anyt,str]  , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[voidt,anyt], target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[str,anyt]  , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[str,voidt] , target:aTarget , fn:()=>(\{a:''\})      \})
			    sample(\{source:a    , clock:[]          , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[anyt]      , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[anyt,voidt], target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[anyt,str]  , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[voidt,anyt], target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[str,anyt]  , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[str,voidt] , target:aTarget , fn:(a) => (\{a\})      \})
			    sample(\{source:a    , clock:[]          , target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[anyt]      , target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[anyt,voidt], target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[anyt,str]  , target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[voidt,anyt], target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[str,anyt]  , target:aTarget , fn:fnAString         \})
			    sample(\{source:a    , clock:[str,voidt] , target:aTarget , fn:fnAString         \})
			    sample(\{source:\{a,b\}, clock:[voidt]     , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[str]       , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[voidt]     , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[str]       , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[voidt]     , target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[str]       , target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[]          , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[anyt]      , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , target:abTarget, fn:()=>(\{a:'',b:2\})  \})
			    sample(\{source:\{a,b\}, clock:[]          , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[anyt]      , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , target:abTarget, fn:(\{a,b\}) => (\{a,b\})\})
			    sample(\{source:\{a,b\}, clock:[]          , target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[anyt]      , target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , target:abTarget, fn:fnAb              \})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , target:abTarget, fn:fnAb              \})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('fn, fnClock (should pass)', () => \{
			  //prettier-ignore
			  \{
			    sample(\{source:a    , clock:[voidt]     , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[str]       , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[voidt,str] , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[voidt]     , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[str]       , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[voidt,str] , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[]          , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[anyt]      , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[anyt,voidt], fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[anyt,str]  , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[voidt,anyt], fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[str,anyt]  , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[str,voidt] , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[]          , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[anyt]      , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[anyt,voidt], fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[anyt,str]  , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[voidt,anyt], fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[str,anyt]  , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[str,voidt] , fn:fnAStringClockAny              \})
			    sample(\{source:\{a,b\}, clock:[voidt]     , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[str]       , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[voidt]     , fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[str]       , fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[]          , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[anyt]      , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[]          , fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[anyt]      , fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , fn:fnAbClockAny                   \})
			    sample(\{source:a    , clock:[voidt]     , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[str]       , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[voidt,str] , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[voidt]     , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[str]       , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[voidt,str] , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[]          , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[anyt]      , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[anyt,voidt], target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[anyt,str]  , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[voidt,anyt], target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[str,anyt]  , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[str,voidt] , target:aclock , fn:(a,clock) => (\{a,clock\})       \})
			    sample(\{source:a    , clock:[]          , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[anyt]      , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[anyt,voidt], target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[anyt,str]  , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[voidt,anyt], target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[str,anyt]  , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:a    , clock:[str,voidt] , target:aclock , fn:fnAStringClockAny              \})
			    sample(\{source:\{a,b\}, clock:[voidt]     , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[str]       , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[voidt]     , target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[str]       , target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[voidt,str] , target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[]          , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[anyt]      , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , target:abclock, fn:(\{a,b\}, clock) => (\{a,b,clock\})\})
			    sample(\{source:\{a,b\}, clock:[]          , target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[anyt]      , target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[anyt,voidt], target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[anyt,str]  , target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[voidt,anyt], target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[str,anyt]  , target:abclock, fn:fnAbClockAny                   \})
			    sample(\{source:\{a,b\}, clock:[str,voidt] , target:abclock, fn:fnAbClockAny                   \})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleClockArray.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(15)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleFilter.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample\} from 'effector'
			const typecheck = '\{global\}'
			type Astr = \{a: string\}
			type AB = \{a: number; b: string\}
			type AoptB = \{a: number | null; b: string\}
			type ABN = \{a: number; b: number\}
			const \$filter = createStore(true)
			const a = createStore(0)
			const aOpt = createStore<number | null>(0)
			const b = createStore('')
			const voidt = createEvent()
			const anyt = createEvent<any>()
			const numt = createEvent<number>()
			const strt = createEvent<number>()
			const \$num = createStore(0)
			const ab = createEvent<AB>()
			const \$ab = createStore<AB>(\{a: 0, b: ''\})
			const nullableAB = createEvent<AB | null>()
			const abNull = createEvent<\{a: number | null; b: string\}>()
			const aNum = createEvent<\{a: number\}>()
			const aStr = createEvent<\{a: string\}>()
			const lNum = createEvent<[number]>()
			const lStr = createEvent<[string]>()
			const lNumStr = createEvent<[number, string]>()
			const lNumNum = createEvent<[number, number]>()
			const abn = createEvent<ABN>()
			describe('unit source', () => \{
			  describe('unit -> unit same', () => \{
			    test('unit -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , target:ab   , filter:(val) => val.a > 0                \})
			        sample(\{source:ab        , target:anyt , filter:(val) => val.a > 0                \})
			        sample(\{source:ab        , target:voidt, filter:(val) => val.a > 0                \})
			        sample(\{source:ab        , target:ab   , filter:\$filter                           \})
			        sample(\{source:ab        , target:anyt , filter:\$filter                           \})
			        sample(\{source:ab        , target:voidt, filter:\$filter                           \})
			        sample(\{source:ab        , target:ab   , filter:Boolean                           \})
			        sample(\{source:ab        , target:anyt , filter:Boolean                           \})
			        sample(\{source:ab        , target:voidt, filter:Boolean                           \})
			        sample(\{source:abNull    , target:ab   , filter:(val): val is AB => val.a !== null\})
			        sample(\{source:nullableAB, target:ab   , filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , target:abn, filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:abn, filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:abn, filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:abNull    , target:abn, filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:abn, filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; target: Event<ABN>; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB>; target: Event<ABN>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB>; target: Event<ABN>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; target: Event<ABN>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB | null>; target: Event<ABN>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit -> unit wide', () => \{
			    test('unit -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , target:aNum, filter:(val) => val.a > 0\})
			        sample(\{source:ab        , target:aNum, filter:\$filter           \})
			        sample(\{source:ab        , target:aNum, filter:Boolean           \})
			        sample(\{source:nullableAB, target:aNum, filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , target:aStr, filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:aStr, filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:aStr, filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; target: Event<\{ a: string; \}>; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB>; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB>; target: Event<\{ a: string; \}>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB | null>; target: Event<\{ a: string; \}>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> unit same', () => \{
			    test('unit + clock -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:anyt, target:ab   , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:anyt, target:anyt , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:anyt, target:voidt, filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:numt, target:ab   , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:numt, target:anyt , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:numt, target:voidt, filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:anyt, target:ab   , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:anyt, target:anyt , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:anyt, target:voidt, filter:\$filter                                      \})
			        sample(\{source:ab        , clock:anyt, target:ab   , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:anyt, target:anyt , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:anyt, target:voidt, filter:Boolean                                      \})
			        sample(\{source:abNull    , clock:anyt, target:ab   , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:numt, target:ab   , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:nullableAB, clock:anyt, target:ab   , filter:Boolean                                      \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:abn, filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:abn, filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:abn, filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:anyt, target:abn, filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:abn, filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<ABN>; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<ABN>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<ABN>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; clock: Event<any>; target: Event<ABN>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>; target: Event<ABN>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> unit wide', () => \{
			    test('unit + clock -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:anyt, target:aNum, filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:numt, target:aNum, filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:anyt, target:aNum, filter:\$filter             \})
			        sample(\{source:ab        , clock:anyt, target:aNum, filter:Boolean             \})
			        sample(\{source:nullableAB, clock:anyt, target:aNum, filter:Boolean             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:aStr, filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:aStr, filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:aStr, filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<\{ a: string; \}>; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<\{ a: string; \}>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>; target: Event<\{ a: string; \}>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + [clock] -> unit same', () => \{
			    test('unit + [clock] -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:[anyt]     , target:ab   , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:[anyt]     , target:anyt , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:[anyt]     , target:voidt, filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:[numt,\$num], target:ab   , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:[numt,\$num], target:anyt , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:[numt,\$num], target:voidt, filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:[anyt]     , target:ab   , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:anyt , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:voidt, filter:\$filter                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:ab   , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:anyt , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:voidt, filter:Boolean                                      \})
			        sample(\{source:abNull    , clock:[anyt]     , target:ab   , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:[numt,\$num], target:ab   , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:nullableAB, clock:[anyt]     , target:ab   , filter:Boolean                                      \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + [clock] -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:abn, filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:abn, filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:abn, filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:[anyt], target:abn, filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:abn, filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<ABN>; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<ABN>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<ABN>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; clock: Event<any>[]; target: Event<ABN>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>[]; target: Event<ABN>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + [clock] -> unit wide', () => \{
			    test('unit + [clock] -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:[anyt]     , target:aNum, filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:[numt,\$num], target:aNum, filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:[anyt]     , target:aNum, filter:\$filter             \})
			        sample(\{source:ab        , clock:[anyt]     , target:aNum, filter:Boolean             \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:aNum, filter:Boolean             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + [clock] -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:aStr, filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:aStr, filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:aStr, filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: \{ a: string; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit -> array same', () => \{
			    test('unit -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , target:[ab]           , filter:(val) => val.a > 0                \})
			        sample(\{source:ab        , target:[ab,anyt]      , filter:(val) => val.a > 0                \})
			        sample(\{source:ab        , target:[ab,voidt]     , filter:(val) => val.a > 0                \})
			        sample(\{source:ab        , target:[ab,anyt,voidt], filter:(val) => val.a > 0                \})
			        sample(\{source:ab        , target:[ab]           , filter:\$filter                           \})
			        sample(\{source:ab        , target:[ab,anyt]      , filter:\$filter                           \})
			        sample(\{source:ab        , target:[ab,voidt]     , filter:\$filter                           \})
			        sample(\{source:ab        , target:[ab,anyt,voidt], filter:\$filter                           \})
			        sample(\{source:ab        , target:[ab]           , filter:Boolean                           \})
			        sample(\{source:ab        , target:[ab,anyt]      , filter:Boolean                           \})
			        sample(\{source:ab        , target:[ab,voidt]     , filter:Boolean                           \})
			        sample(\{source:ab        , target:[ab,anyt,voidt], filter:Boolean                           \})
			        sample(\{source:abNull    , target:[ab]           , filter:(val): val is AB => val.a !== null\})
			        sample(\{source:abNull    , target:[ab,anyt]      , filter:(val): val is AB => val.a !== null\})
			        sample(\{source:abNull    , target:[ab,voidt]     , filter:(val): val is AB => val.a !== null\})
			        sample(\{source:abNull    , target:[ab,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        sample(\{source:nullableAB, target:[ab]           , filter:Boolean                           \})
			        sample(\{source:nullableAB, target:[ab,anyt]      , filter:Boolean                           \})
			        sample(\{source:nullableAB, target:[ab,voidt]     , filter:Boolean                           \})
			        sample(\{source:nullableAB, target:[ab,anyt,voidt], filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn]           , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,anyt]      , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,voidt]     , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,anyt,voidt], filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn]           , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,anyt]      , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,voidt]     , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,anyt,voidt], filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[abn,anyt,voidt], filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:abNull    , target:[abn]           , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , target:[abn,anyt]      , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , target:[abn,voidt]     , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , target:[abn,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[abn,anyt,voidt], filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; target: Event<ABN>[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; target: (Event<void> | Event<ABN>)[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; target: Event<ABN>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; target: (Event<void> | Event<ABN>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; target: Event<ABN>[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; target: (Event<void> | Event<ABN>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; target: Event<ABN>[]; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; target: (Event<void> | Event<ABN>)[]; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; target: Event<ABN>[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; target: (Event<void> | Event<ABN>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit -> array wide', () => \{
			    test('unit -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , target:[aNum]           , filter:(val) => val.a > 0\})
			        sample(\{source:ab        , target:[aNum,anyt]      , filter:(val) => val.a > 0\})
			        sample(\{source:ab        , target:[aNum,voidt]     , filter:(val) => val.a > 0\})
			        sample(\{source:ab        , target:[aNum,anyt,voidt], filter:(val) => val.a > 0\})
			        sample(\{source:ab        , target:[aNum]           , filter:\$filter           \})
			        sample(\{source:ab        , target:[aNum,anyt]      , filter:\$filter           \})
			        sample(\{source:ab        , target:[aNum,voidt]     , filter:\$filter           \})
			        sample(\{source:ab        , target:[aNum,anyt,voidt], filter:\$filter           \})
			        sample(\{source:ab        , target:[aNum]           , filter:Boolean           \})
			        sample(\{source:ab        , target:[aNum,anyt]      , filter:Boolean           \})
			        sample(\{source:ab        , target:[aNum,voidt]     , filter:Boolean           \})
			        sample(\{source:ab        , target:[aNum,anyt,voidt], filter:Boolean           \})
			        sample(\{source:nullableAB, target:[aNum]           , filter:Boolean           \})
			        sample(\{source:nullableAB, target:[aNum,anyt]      , filter:Boolean           \})
			        sample(\{source:nullableAB, target:[aNum,voidt]     , filter:Boolean           \})
			        sample(\{source:nullableAB, target:[aNum,anyt,voidt], filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , target:[aStr,anyt,voidt], filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, target:[aStr,anyt,voidt], filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> array same', () => \{
			    test('unit + clock -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:anyt, target:[ab]           , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:anyt, target:[ab,anyt]      , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:anyt, target:[ab,voidt]     , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:anyt, target:[ab,anyt,voidt], filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:numt, target:[ab]           , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:numt, target:[ab,anyt]      , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:numt, target:[ab,voidt]     , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:numt, target:[ab,anyt,voidt], filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:anyt, target:[ab]           , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:anyt, target:[ab,anyt]      , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:anyt, target:[ab,voidt]     , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:anyt, target:[ab,anyt,voidt], filter:\$filter                                      \})
			        sample(\{source:ab        , clock:anyt, target:[ab]           , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:anyt, target:[ab,anyt]      , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:anyt, target:[ab,voidt]     , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:anyt, target:[ab,anyt,voidt], filter:Boolean                                      \})
			        sample(\{source:abNull    , clock:anyt, target:[ab]           , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:anyt, target:[ab,anyt]      , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:anyt, target:[ab,voidt]     , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:anyt, target:[ab,anyt,voidt], filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:numt, target:[ab]           , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:abNull    , clock:numt, target:[ab,anyt]      , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:abNull    , clock:numt, target:[ab,voidt]     , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:abNull    , clock:numt, target:[ab,anyt,voidt], filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:nullableAB, clock:anyt, target:[ab]           , filter:Boolean                                      \})
			        sample(\{source:nullableAB, clock:anyt, target:[ab,anyt]      , filter:Boolean                                      \})
			        sample(\{source:nullableAB, clock:anyt, target:[ab,voidt]     , filter:Boolean                                      \})
			        sample(\{source:nullableAB, clock:anyt, target:[ab,anyt,voidt], filter:Boolean                                      \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn]           , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,anyt]      , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,voidt]     , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,anyt,voidt], filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn]           , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,anyt]      , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,voidt]     , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,anyt,voidt], filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[abn,anyt,voidt], filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:anyt, target:[abn]           , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:anyt, target:[abn,anyt]      , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:anyt, target:[abn,voidt]     , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:anyt, target:[abn,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[abn,anyt,voidt], filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<ABN>[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: (Event<void> | Event<ABN>)[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<ABN>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: (Event<void> | Event<ABN>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: Event<ABN>[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: (Event<void> | Event<ABN>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; clock: Event<any>; target: Event<ABN>[]; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; clock: Event<any>; target: (Event<void> | Event<ABN>)[]; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>; target: Event<ABN>[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>; target: (Event<void> | Event<ABN>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + clock -> array wide', () => \{
			    test('unit + clock -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:anyt, target:[aNum]           , filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:numt, target:[aNum]           , filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:numt, target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:numt, target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:numt, target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:anyt, target:[aNum]           , filter:\$filter             \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,anyt]      , filter:\$filter             \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,voidt]     , filter:\$filter             \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,anyt,voidt], filter:\$filter             \})
			        sample(\{source:ab        , clock:anyt, target:[aNum]           , filter:Boolean             \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,anyt]      , filter:Boolean             \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,voidt]     , filter:Boolean             \})
			        sample(\{source:ab        , clock:anyt, target:[aNum,anyt,voidt], filter:Boolean             \})
			        sample(\{source:nullableAB, clock:anyt, target:[aNum]           , filter:Boolean             \})
			        sample(\{source:nullableAB, clock:anyt, target:[aNum,anyt]      , filter:Boolean             \})
			        sample(\{source:nullableAB, clock:anyt, target:[aNum,voidt]     , filter:Boolean             \})
			        sample(\{source:nullableAB, clock:anyt, target:[aNum,anyt,voidt], filter:Boolean             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + clock -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:anyt, target:[aStr,anyt,voidt], filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:anyt, target:[aStr,anyt,voidt], filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + [clock] -> array same', () => \{
			    test('unit + [clock] -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:[anyt]     , target:[ab]           , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,anyt]      , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,voidt]     , filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,anyt,voidt], filter:(val) => val.a > 0                           \})
			        sample(\{source:ab        , clock:[numt,\$num], target:[ab]           , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:[numt,\$num], target:[ab,anyt]      , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:[numt,\$num], target:[ab,voidt]     , filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:[numt,\$num], target:[ab,anyt,voidt], filter:(val,n) => val.a > n                         \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab]           , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,anyt]      , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,voidt]     , filter:\$filter                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,anyt,voidt], filter:\$filter                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab]           , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,anyt]      , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,voidt]     , filter:Boolean                                      \})
			        sample(\{source:ab        , clock:[anyt]     , target:[ab,anyt,voidt], filter:Boolean                                      \})
			        sample(\{source:abNull    , clock:[anyt]     , target:[ab]           , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:[anyt]     , target:[ab,anyt]      , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:[anyt]     , target:[ab,voidt]     , filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:[anyt]     , target:[ab,anyt,voidt], filter:(val): val is AB => val.a !== null           \})
			        sample(\{source:abNull    , clock:[numt,\$num], target:[ab]           , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:abNull    , clock:[numt,\$num], target:[ab,anyt]      , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:abNull    , clock:[numt,\$num], target:[ab,voidt]     , filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:abNull    , clock:[numt,\$num], target:[ab,anyt,voidt], filter:(val,n): val is AB => n > 0 && val.a !== null\})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[ab]           , filter:Boolean                                      \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[ab,anyt]      , filter:Boolean                                      \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[ab,voidt]     , filter:Boolean                                      \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[ab,anyt,voidt], filter:Boolean                                      \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + [clock] -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn]           , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,anyt]      , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,voidt]     , filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,anyt,voidt], filter:(val) => val.a > 0                \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn]           , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,anyt]      , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,voidt]     , filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,anyt,voidt], filter:\$filter                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[abn,anyt,voidt], filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:[anyt], target:[abn]           , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:[anyt], target:[abn,anyt]      , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:[anyt], target:[abn,voidt]     , filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:abNull    , clock:[anyt], target:[abn,anyt,voidt], filter:(val): val is AB => val.a !== null\})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[abn]           , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[abn,anyt]      , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[abn,voidt]     , filter:Boolean                           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[abn,anyt,voidt], filter:Boolean                           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<ABN>[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: (Event<void> | Event<ABN>)[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<ABN>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: (Event<void> | Event<ABN>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: Event<ABN>[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: (Event<void> | Event<ABN>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; clock: Event<any>[]; target: Event<ABN>[]; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<\{ a: number | null; b: string; \}>; clock: Event<any>[]; target: (Event<void> | Event<ABN>)[]; filter: (val: \{ a: number | null; b: string; \}) => val is AB; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>[]; target: Event<ABN>[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>[]; target: (Event<void> | Event<ABN>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('unit + [clock] -> array wide', () => \{
			    test('unit + [clock] -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum]           , filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        sample(\{source:ab        , clock:[numt,\$num], target:[aNum]           , filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:[numt,\$num], target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:[numt,\$num], target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:[numt,\$num], target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum]           , filter:\$filter             \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,anyt]      , filter:\$filter             \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,voidt]     , filter:\$filter             \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,anyt,voidt], filter:\$filter             \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum]           , filter:Boolean             \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,anyt]      , filter:Boolean             \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,voidt]     , filter:Boolean             \})
			        sample(\{source:ab        , clock:[anyt]     , target:[aNum,anyt,voidt], filter:Boolean             \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[aNum]           , filter:Boolean             \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[aNum,anyt]      , filter:Boolean             \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[aNum,voidt]     , filter:Boolean             \})
			        sample(\{source:nullableAB, clock:[anyt]     , target:[aNum,anyt,voidt], filter:Boolean             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('unit + [clock] -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,anyt,voidt], filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:ab        , clock:[anyt], target:[aStr,anyt,voidt], filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[aStr,ab]        , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[aStr,anyt]      , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[aStr,voidt]     , filter:Boolean           \})
			        //@ts-expect-error
			        sample(\{source:nullableAB, clock:[anyt], target:[aStr,anyt,voidt], filter:Boolean           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: (val: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB>; clock: Event<any>[]; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: Event<AB | null>; clock: Event<any>[]; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: BooleanConstructor; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: AB; targetType: void | \{ a: string; \}; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('object source', () => \{
			  describe('object -> array same', () => \{
			    test('object -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, target:[ab]           , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[ab,anyt]      , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[ab,voidt]     , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[ab,anyt,voidt], filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[ab]           , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:[ab,anyt]      , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:[ab,voidt]     , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:[ab,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn]           , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn]           , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[abn,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<ABN>[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: (Event<void> | Event<ABN>)[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<ABN>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: (Event<void> | Event<ABN>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object -> array wide', () => \{
			    test('object -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, target:[aNum]           , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[aNum,anyt]      , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[aNum,voidt]     , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[aNum,anyt,voidt], filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:[aNum]           , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:[aNum,anyt]      , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:[aNum,voidt]     , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:[aNum,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:[aStr,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> array same', () => \{
			    test('object + clock -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab]           , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab,anyt]      , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab,voidt]     , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab,anyt,voidt], filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:numt, target:[ab]           , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:[ab,anyt]      , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:[ab,voidt]     , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:[ab,anyt,voidt], filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab]           , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab,anyt]      , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab,voidt]     , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[ab,anyt,voidt], filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn]           , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn]           , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[abn,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: Event<ABN>[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: (Event<void> | Event<ABN>)[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: Event<ABN>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: (Event<void> | Event<ABN>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> array wide', () => \{
			    test('object + clock -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum]           , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:numt, target:[aNum]           , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum]           , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum,anyt]      , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum,voidt]     , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:[aNum,anyt,voidt], filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:[aStr,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + [clock] -> array same', () => \{
			    test('object + [clock] -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab]           , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt]      , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab,voidt]     , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt,voidt], filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[ab]           , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[ab,anyt]      , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[ab,voidt]     , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[ab,anyt,voidt], filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab]           , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt]      , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab,voidt]     , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[ab,anyt,voidt], filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + [clock] -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn]           , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn]           , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[abn,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: Event<ABN>[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: (Event<void> | Event<ABN>)[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: Event<ABN>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: (Event<void> | Event<ABN>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | ABN; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + [clock] -> array wide', () => \{
			    test('object + [clock] -> array wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum]           , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt]      , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,voidt]     , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt,voidt], filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum]           , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum,anyt]      , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum,voidt]     , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:[aNum,anyt,voidt], filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum]           , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt]      , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,voidt]     , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:[aNum,anyt,voidt], filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + [clock] -> array wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,ab]        , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt]      , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,voidt]     , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt,voidt], filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,ab]        , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt]      , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,voidt]     , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:[aStr,anyt,voidt], filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: (Event<void> | Event<\{ a: string; \}>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: void | \{ a: string; \}; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object -> unit same', () => \{
			    test('object -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, target:ab   , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:anyt , filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:voidt, filter:(val) => val.a > 0\})
			        sample(\{source:\{a,b\}, target:ab   , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:anyt , filter:\$filter           \})
			        sample(\{source:\{a,b\}, target:voidt, filter:\$filter           \})
			        sample(\{source:\{a\}  , target:aNum , filter:(val) => val.a > 0\})
			        sample(\{source:\{a\}  , target:aNum , filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:abn , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, target:abn , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , target:ab  , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , target:ab  , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , target:aStr, filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<ABN>; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<ABN>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<AB>; filter: (val: \{ a: number; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<\{ a: string; \}>; filter: (val: \{ a: number; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<AB>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object -> unit wide', () => \{
			    test('object -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}     , target:aNum, filter:(val) => val.a > 0                                        \})
			        sample(\{source:\{a,b\}     , target:aNum, filter:\$filter                                                   \})
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}     , target:aStr, filter:(val) => val.a > 0                             \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}     , target:aStr, filter:\$filter                                        \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:\$filter                                        \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<\{ a: string; \}>; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> unit same', () => \{
			    test('object + clock -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, clock:anyt, target:ab   , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:anyt , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:anyt, target:voidt, filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:numt, target:ab   , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:anyt , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:numt, target:voidt, filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:anyt, target:ab   , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:anyt , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:anyt, target:voidt, filter:\$filter             \})
			        sample(\{source:\{a\}  , clock:anyt, target:aNum , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a\}  , clock:numt, target:aNum , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a\}  , clock:anyt, target:aNum , filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:abn , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:anyt, target:abn , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:anyt, target:ab  , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:anyt, target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:anyt, target:ab  , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:anyt, target:aStr, filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: Event<ABN>; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: Event<ABN>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>; target: Event<AB>; filter: (val: \{ a: number; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>; target: Event<\{ a: string; \}>; filter: (val: \{ a: number; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>; target: Event<AB>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock -> unit wide', () => \{
			    test('object + clock -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}     , clock:anyt, target:aNum, filter:(val) => val.a > 0                                          \})
			        sample(\{source:\{a,b\}     , clock:numt, target:aNum, filter:(val,n) => val.a > n                                        \})
			        sample(\{source:\{a,b\}     , clock:anyt, target:aNum, filter:\$filter                                                     \})
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  \})
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + clock -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}     , clock:anyt, target:aStr, filter:(val) => val.a > 0                               \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}     , clock:anyt, target:aStr, filter:\$filter                                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0  \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:\$filter                                          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: string; \}>; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<number>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + [clock] -> unit same', () => \{
			    test('object + [clock] -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:ab   , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:anyt , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:voidt, filter:(val) => val.a > 0  \})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:ab   , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:anyt , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[numt,\$num], target:voidt, filter:(val,n) => val.a > n\})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:ab   , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:anyt , filter:\$filter             \})
			        sample(\{source:\{a,b\}, clock:[anyt]     , target:voidt, filter:\$filter             \})
			        sample(\{source:\{a\}  , clock:[anyt]     , target:aNum , filter:(val) => val.a > 0  \})
			        sample(\{source:\{a\}  , clock:[numt,\$num], target:aNum , filter:(val,n) => val.a > n\})
			        sample(\{source:\{a\}  , clock:[anyt]     , target:aNum , filter:\$filter             \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + [clock] -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:abn , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}, clock:[anyt], target:abn , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:[anyt], target:ab  , filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:[anyt], target:aStr, filter:(val) => val.a > 0\})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:[anyt], target:ab  , filter:\$filter           \})
			        //@ts-expect-error
			        sample(\{source:\{a\}  , clock:[anyt], target:aStr, filter:\$filter           \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: Event<ABN>; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: Event<ABN>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>[]; target: Event<AB>; filter: (val: \{ a: number; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: (val: \{ a: number; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>[]; target: Event<AB>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object + [clock] -> unit wide', () => \{
			    test('object + [clock] -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a,b\}     , clock:[anyt]     , target:aNum, filter:(val) => val.a > 0                                          \})
			        sample(\{source:\{a,b\}     , clock:[numt,\$num], target:aNum, filter:(val,n) => val.a > n                                        \})
			        sample(\{source:\{a,b\}     , clock:[anyt]     , target:aNum, filter:\$filter                                                     \})
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  \})
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('object + [clock] -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a,b\}     , clock:[anyt]     , target:aStr, filter:(val) => val.a > 0                               \})
			        //@ts-expect-error
			        sample(\{source:\{a,b\}     , clock:[anyt]     , target:aStr, filter:\$filter                                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0  \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:\$filter                                          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: (val: \{ a: number; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: string; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: \{ a: string; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: (Store<number> | Event<number>)[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number | null; b: string; \}; targetType: \{ a: number; \}; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('object, fn -> unit wide', () => \{
			    test('object, fn -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0           , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0           , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:\$filter                                                   , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:\$filter                                                   , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0, fn:(val) => (\{a: val.a + 1, b: val.b\})           \})
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0, fn:(val: AB) => (\{a: val.a + 1, b: val.b\})       \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val.a' is possibly 'null'.
			        "
			      \`)
			    \})
			    test('object, fn -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0           , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0           , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0           , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:\$filter                                                   , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:\$filter                                                   , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:\$filter                                                   , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0, fn:(val) => (\{a: 1 + val.c, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0, fn:(val: ABN) => (\{a: val.a + 1, b: ''\})  \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0, fn:() => 'wrong'                          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val.a' is possibly 'null'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: (val: any) => boolean; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        'val.a' is possibly 'null'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: Store<boolean>; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Property 'c' does not exist on type '\{ a: number | null; b: string; \}'.
			        Argument of type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to parameter of type '[config: \{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock?: undefined; filter?: (((src: \{ a: number | null; b: string; \}) => src is \{ a: number | null; b: string; \}) & ((src: \{ a: number | null; b: string; \}) => src is \{ ...; \})) | undefined; fn?: (((src: \{ ...; \}) => any) & ((src: \{ ...; \}) => any)) ...'.
			          Type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to type '[config: \{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock?: undefined; filter?: ((src: \{ a: number | null; b: string; \}) => boolean) | undefined; fn?: ((src: \{ a: number | null; b: string; \}) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock?: undefined; filter?: ((src: \{ a: number | null; b: string; \}) => boolean) | undefined; fn?: ((src: \{ a: number | null; b: string; \}) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}) => any'.
			                  Types of parameters 'val' and 'src' are incompatible.
			                    Type '\{ a: number | null; b: string; \}' is not assignable to type 'ABN'.
			                      Types of property 'a' are incompatible.
			                        Type 'number | null' is not assignable to type 'number'.
			                          Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; target: Event<\{ a: number; \}>; filter: (val: any) => val is AB; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			  \})
			  describe('object + clock, fn -> unit wide', () => \{
			    test('object + clock, fn -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:\$filter                                                     , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:\$filter                                                     , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val) => (\{a: val.a + 1, b: val.b\})           \})
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val) => (\{a: val.a + 1, b: val.b\})           \})
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val: AB) => (\{a: val.a + 1, b: val.b\})       \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val.a' is possibly 'null'.
			        'val.a' is possibly 'null'.
			        "
			      \`)
			    \})
			    test('object + clock, fn -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:\$filter                                                     , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:\$filter                                                     , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:\$filter                                                     , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val) => (\{a: 1 + val.c, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val) => (\{a: 1 + val.c, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val: ABN) => (\{a: val.a + 1, b: ''\})  \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val: ABN) => (\{a: val.a + 1, b: ''\})  \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:anyt, target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:numt, target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:() => 'wrong'                          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val.a' is possibly 'null'.
			        'val.a' is possibly 'null'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}, clk: any) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: any) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}, clk: number) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: number) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: (val: any) => boolean; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<number>; target: Event<\{ a: number; \}>; filter: (val: any, n: any) => boolean; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Parameter 'n' implicitly has an 'any' type.
			        'val.a' is possibly 'null'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}, clk: any) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: any) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: Store<boolean>; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Property 'c' does not exist on type '\{ a: number | null; b: string; \}'.
			        Property 'c' does not exist on type '\{ a: number | null; b: string; \}'.
			        Argument of type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<any>; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: (((src: \{ a: number | null; b: string; \}, clk: any) => src is \{ a: number | null; b: string; \}) & ((src: \{ ...; \}, clk: any) => src is \{ ...; \})) | undefined; fn?: (((src: \{ ...; \}, clk: any) => any) & ((src: \{ ...; \}, clk...'.
			          Type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to type '[config: \{ clock: Event<any>; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: any) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: any) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}' is not assignable to type '\{ clock: Event<any>; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: any) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: any) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: any) => any'.
			                  Types of parameters 'val' and 'src' are incompatible.
			                    Type '\{ a: number | null; b: string; \}' is not assignable to type 'ABN'.
			                      Types of property 'a' are incompatible.
			                        Type 'number | null' is not assignable to type 'number'.
			                          Type 'null' is not assignable to type 'number'.
			        Argument of type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<number>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<number>; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: (((src: \{ a: number | null; b: string; \}, clk: number) => src is \{ a: number | null; b: string; \}) & ((src: \{ ...; \}, clk: number) => src is \{ ...; \})) | undefined; fn?: (((src: \{ ...; \}, clk: number) => any) & ((src: \{...'.
			          Type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<number>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to type '[config: \{ clock: Event<number>; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: number) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: number) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<number>; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => val is AB; fn: (val: ABN) => \{ ...; \}; \}' is not assignable to type '\{ clock: Event<number>; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: number) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: number) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: number) => any'.
			                  Types of parameters 'val' and 'src' are incompatible.
			                    Type '\{ a: number | null; b: string; \}' is not assignable to type 'ABN'.
			                      Types of property 'a' are incompatible.
			                        Type 'number | null' is not assignable to type 'number'.
			                          Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>; target: Event<\{ a: number; \}>; filter: (val: any) => val is AB; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<number>; target: Event<\{ a: number; \}>; filter: (val: any, n: any) => val is AB; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Parameter 'n' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			  \})
			  describe('object + [clock], fn -> unit wide', () => \{
			    test('object + [clock], fn -> unit wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:\$filter                                                     , fn:(val) => (\{a: 0, b: \`\$\{val.b.length\}\`\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:\$filter                                                     , fn:(val: AoptB) => (\{a: 0, b: \`\$\{val.b.length\}\`\})\})
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val) => (\{a: val.a + 1, b: val.b\})           \})
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val) => (\{a: val.a + 1, b: val.b\})           \})
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})       \})
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val: AB) => (\{a: val.a + 1, b: val.b\})       \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val.a' is possibly 'null'.
			        'val.a' is possibly 'null'.
			        "
			      \`)
			    \})
			    test('object + [clock], fn -> unit wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val) => typeof val.a === 'number' && val.a > 0             , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n) => typeof val.a === 'number' && val.a > n           , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:\$filter                                                     , fn:(val) => (\{a: val.a + 1, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:\$filter                                                     , fn:(val: AB) => (\{a: val.a + 1, b: val.b\})\})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:\$filter                                                     , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val) => (\{a: 1 + val.c, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val) => (\{a: 1 + val.c, b: val.b\})    \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:(val: ABN) => (\{a: val.a + 1, b: ''\})  \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:(val: ABN) => (\{a: val.a + 1, b: ''\})  \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[anyt]     , target:aNum, filter:(val): val is AB => typeof val.a === 'number' && val.a > 0  , fn:() => 'wrong'                          \})
			        //@ts-expect-error
			        sample(\{source:\{a:aOpt,b\}, clock:[numt,\$num], target:aNum, filter:(val,n): val is AB => typeof val.a === 'number' && val.a > n, fn:() => 'wrong'                          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val.a' is possibly 'null'.
			        'val.a' is possibly 'null'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}, clk: any) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: any) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}, clk: number) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: number) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: (val: any) => boolean; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: (Store<number> | Event<number>)[]; target: Event<\{ a: number; \}>; filter: (val: any, n: any) => boolean; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Parameter 'n' implicitly has an 'any' type.
			        'val.a' is possibly 'null'.
			        Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '((src: \{ a: number | null; b: string; \}, clk: any) => any) & ((val: AB) => \{ a: number; b: string; \})'.
			          Type '(val: AB) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: any) => any'.
			            Types of parameters 'val' and 'src' are incompatible.
			              Type '\{ a: number | null; b: string; \}' is not assignable to type 'AB'.
			                Types of property 'a' are incompatible.
			                  Type 'number | null' is not assignable to type 'number'.
			                    Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: Store<boolean>; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Property 'c' does not exist on type '\{ a: number | null; b: string; \}'.
			        Property 'c' does not exist on type '\{ a: number | null; b: string; \}'.
			        Argument of type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<any>[]; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: (((src: \{ a: number | null; b: string; \}, clk: any) => src is \{ a: number | null; b: string; \}) & ((src: \{ ...; \}, clk: any) => src is \{ ...; \})) | undefined; fn?: (((src: \{ ...; \}, clk: any) => any) & ((src: \{ ...; \}, c...'.
			          Type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to type '[config: \{ clock: Event<any>[]; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: any) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: any) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}) => val is AB; fn: (val: ABN) => \{ ...; \}; \}' is not assignable to type '\{ clock: Event<any>[]; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: any) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: any) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: any) => any'.
			                  Types of parameters 'val' and 'src' are incompatible.
			                    Type '\{ a: number | null; b: string; \}' is not assignable to type 'ABN'.
			                      Types of property 'a' are incompatible.
			                        Type 'number | null' is not assignable to type 'number'.
			                          Type 'null' is not assignable to type 'number'.
			        Argument of type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: (Store<number> | Event<number>)[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Store<number> | Event<number>)[]; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: (((src: \{ a: number | null; b: string; \}, clk: number) => src is \{ ...; \}) & ((src: \{ ...; \}, clk: number) => src is \{ ...; \})) | undefined; fn?: (((src: \{ ...; \}, clk: number) => any) & ((src: \{ ......'.
			          Type '[\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: (Store<number> | Event<number>)[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => val is AB; fn: (val: ABN) => \{ ...; \}; \}]' is not assignable to type '[config: \{ clock: (Store<number> | Event<number>)[]; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: number) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: number) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: (Store<number> | Event<number>)[]; target: Event<\{ a: number; \}>; filter: (val: \{ a: number | null; b: string; \}, n: number) => val is AB; fn: (val: ABN) => \{ ...; \}; \}' is not assignable to type '\{ clock: (Store<number> | Event<number>)[]; source: \{ a: Store<number | null>; b: Store<string>; \}; filter?: ((src: \{ a: number | null; b: string; \}, clk: number) => boolean) | undefined; fn?: ((src: \{ ...; \}, clk: number) => any) | undefined; target: Event<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: number; b: string; \}' is not assignable to type '(src: \{ a: number | null; b: string; \}, clk: number) => any'.
			                  Types of parameters 'val' and 'src' are incompatible.
			                    Type '\{ a: number | null; b: string; \}' is not assignable to type 'ABN'.
			                      Types of property 'a' are incompatible.
			                        Type 'number | null' is not assignable to type 'number'.
			                          Type 'null' is not assignable to type 'number'.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: Event<any>[]; target: Event<\{ a: number; \}>; filter: (val: any) => val is AB; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Argument of type '\{ source: \{ a: Store<number | null>; b: Store<string>; \}; clock: (Store<number> | Event<number>)[]; target: Event<\{ a: number; \}>; filter: (val: any, n: any) => val is AB; fn: () => string; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: \{ a: number; \}; \}; \}'.
			        Parameter 'val' implicitly has an 'any' type.
			        Parameter 'n' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('tuple source', () => \{
			  describe('tuple -> array same', () => \{
			    test('tuple -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:[a,b], target:[lNumStr]           , filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b], target:[lNumStr,anyt]      , filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b], target:[lNumStr,voidt]     , filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b], target:[lNumStr,anyt,voidt], filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b], target:[lNumStr]           , filter:\$filter            \})
			        sample(\{source:[a,b], target:[lNumStr,anyt]      , filter:\$filter            \})
			        sample(\{source:[a,b], target:[lNumStr,voidt]     , filter:\$filter            \})
			        sample(\{source:[a,b], target:[lNumStr,anyt,voidt], filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, string]>[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<void> | Event<[number, string]>)[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, string]>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<void> | Event<[number, string]>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('tuple -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum]           , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum,anyt]      , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum,voidt]     , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum,anyt,voidt], filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum]           , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum,anyt]      , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum,voidt]     , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], target:[lNumNum,anyt,voidt], filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, number]>[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<void> | Event<[number, number]>)[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, number]>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: (Event<void> | Event<[number, number]>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple + clock -> array same', () => \{
			    test('tuple + clock -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr]           , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr,anyt]      , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr,voidt]     , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr,anyt,voidt], filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:numt, target:[lNumStr]           , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:numt, target:[lNumStr,anyt]      , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:numt, target:[lNumStr,voidt]     , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:numt, target:[lNumStr,anyt,voidt], filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr]           , filter:\$filter               \})
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr,anyt]      , filter:\$filter               \})
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr,voidt]     , filter:\$filter               \})
			        sample(\{source:[a,b], clock:anyt, target:[lNumStr,anyt,voidt], filter:\$filter               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, string]>[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: (Event<void> | Event<[number, string]>)[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number, string]>[]; filter: (val: (string | number)[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<void> | Event<[number, string]>)[]; filter: (val: (string | number)[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, string]>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: (Event<void> | Event<[number, string]>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('tuple + clock -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum]           , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum,anyt]      , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum,voidt]     , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum,anyt,voidt], filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum]           , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum,anyt]      , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum,voidt]     , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:anyt, target:[lNumNum,anyt,voidt], filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, number]>[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: (Event<void> | Event<[number, number]>)[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, number]>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: (Event<void> | Event<[number, number]>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple + [clock] -> array same', () => \{
			    test('tuple + [clock] -> array same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr]           , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt]      , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr,voidt]     , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt,voidt], filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b], clock:[numt,\$num], target:[lNumStr]           , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:[numt,\$num], target:[lNumStr,anyt]      , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:[numt,\$num], target:[lNumStr,voidt]     , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:[numt,\$num], target:[lNumStr,anyt,voidt], filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr]           , filter:\$filter               \})
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt]      , filter:\$filter               \})
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr,voidt]     , filter:\$filter               \})
			        sample(\{source:[a,b], clock:[anyt]     , target:[lNumStr,anyt,voidt], filter:\$filter               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, string]>[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: (Event<void> | Event<[number, string]>)[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: (Store<number> | Event<number>)[]; target: Event<[number, string]>[]; filter: (val: (string | number)[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: (Store<number> | Event<number>)[]; target: (Event<void> | Event<[number, string]>)[]; filter: (val: (string | number)[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, string]>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: (Event<void> | Event<[number, string]>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, string]; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('tuple + [clock] -> array same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum]           , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt]      , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum,voidt]     , filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt,voidt], filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum]           , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt]      , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum,voidt]     , filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b], clock:[anyt], target:[lNumNum,anyt,voidt], filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, number]>[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: (Event<void> | Event<[number, number]>)[]; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, number]>[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: (Event<void> | Event<[number, number]>)[]; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: void | [number, number]; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple -> unit same', () => \{
			    test('tuple -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:[a,b]         , target:lNumStr, filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b]         , target:anyt   , filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b]         , target:voidt  , filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b] as const, target:lNumStr, filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b] as const, target:anyt   , filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b] as const, target:voidt  , filter:(val) => val[0] > 0\})
			        sample(\{source:[a,b]         , target:lNumStr, filter:\$filter            \})
			        sample(\{source:[a,b]         , target:anyt   , filter:\$filter            \})
			        sample(\{source:[a,b]         , target:voidt  , filter:\$filter            \})
			        sample(\{source:[a,b] as const, target:lNumStr, filter:\$filter            \})
			        sample(\{source:[a,b] as const, target:anyt   , filter:\$filter            \})
			        sample(\{source:[a,b] as const, target:voidt  , filter:\$filter            \})
			        sample(\{source:[a]           , target:lNum   , filter:(val) => val[0] > 0\})
			        sample(\{source:[a] as const  , target:lNum   , filter:(val) => val[0] > 0\})
			        sample(\{source:[a]           , target:lNum   , filter:\$filter            \})
			        sample(\{source:[a] as const  , target:lNum   , filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, string]>; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, string]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<[number]>; filter: (val: number[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<[number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        "
			      \`)
			    \})
			    test('tuple -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:[a,b]         , target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b] as const, target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b]         , target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b] as const, target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a]           , target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a] as const  , target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a]           , target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a] as const  , target:lNumNum, filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, number]>; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: Event<[number, number]>; filter: (val: readonly [number, string]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<[number, number]>; filter: (val: number[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: Event<[number, number]>; filter: (val: readonly [number]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple + clock -> unit same', () => \{
			    test('tuple + clock -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:[a,b]         , clock:anyt, target:lNumStr, filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b]         , clock:anyt, target:anyt   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b]         , clock:anyt, target:voidt  , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b]         , clock:numt, target:lNumStr, filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b]         , clock:numt, target:anyt   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b]         , clock:numt, target:voidt  , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b] as const, clock:anyt, target:lNumStr, filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b] as const, clock:anyt, target:anyt   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b] as const, clock:anyt, target:voidt  , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b] as const, clock:numt, target:lNumStr, filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b] as const, clock:numt, target:anyt   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b] as const, clock:numt, target:voidt  , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b]         , clock:anyt, target:lNumStr, filter:\$filter               \})
			        sample(\{source:[a,b]         , clock:anyt, target:anyt   , filter:\$filter               \})
			        sample(\{source:[a,b]         , clock:anyt, target:voidt  , filter:\$filter               \})
			        sample(\{source:[a,b] as const, clock:anyt, target:lNumStr, filter:\$filter               \})
			        sample(\{source:[a,b] as const, clock:anyt, target:anyt   , filter:\$filter               \})
			        sample(\{source:[a,b] as const, clock:anyt, target:voidt  , filter:\$filter               \})
			        sample(\{source:[a]           , clock:anyt, target:lNum   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a]           , clock:numt, target:lNum   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a] as const  , clock:anyt, target:lNum   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a] as const  , clock:numt, target:lNum   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a]           , clock:anyt, target:lNum   , filter:\$filter               \})
			        sample(\{source:[a] as const  , clock:anyt, target:lNum   , filter:\$filter               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, string]>; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number, string]>; filter: (val: (string | number)[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, string]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: Event<[number]>; filter: (val: number[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<number>; target: Event<[number]>; filter: (val: number[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: Event<[number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        "
			      \`)
			    \})
			    test('tuple + clock -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:[a,b]         , clock:anyt, target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b] as const, clock:anyt, target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b]         , clock:anyt, target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b] as const, clock:anyt, target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a]           , clock:anyt, target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a] as const  , clock:anyt, target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a]           , clock:anyt, target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a] as const  , clock:anyt, target:lNumNum, filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, number]>; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<any>; target: Event<[number, number]>; filter: (val: readonly [number, string]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<any>; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: Event<[number, number]>; filter: (val: number[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<any>; target: Event<[number, number]>; filter: (val: readonly [number]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<any>; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('tuple + [clock] -> unit same', () => \{
			    test('tuple + [clock] -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{source:[a,b]         , clock:[anyt]     , target:lNumStr, filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b]         , clock:[anyt]     , target:anyt   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b]         , clock:[anyt]     , target:voidt  , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b]         , clock:[numt,\$num], target:lNumStr, filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b]         , clock:[numt,\$num], target:anyt   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b]         , clock:[numt,\$num], target:voidt  , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b] as const, clock:[anyt]     , target:lNumStr, filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b] as const, clock:[anyt]     , target:anyt   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b] as const, clock:[anyt]     , target:voidt  , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a,b] as const, clock:[numt,\$num], target:lNumStr, filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b] as const, clock:[numt,\$num], target:anyt   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b] as const, clock:[numt,\$num], target:voidt  , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a,b]         , clock:[anyt]     , target:lNumStr, filter:\$filter               \})
			        sample(\{source:[a,b]         , clock:[anyt]     , target:anyt   , filter:\$filter               \})
			        sample(\{source:[a,b]         , clock:[anyt]     , target:voidt  , filter:\$filter               \})
			        sample(\{source:[a,b] as const, clock:[anyt]     , target:lNumStr, filter:\$filter               \})
			        sample(\{source:[a,b] as const, clock:[anyt]     , target:anyt   , filter:\$filter               \})
			        sample(\{source:[a,b] as const, clock:[anyt]     , target:voidt  , filter:\$filter               \})
			        sample(\{source:[a]           , clock:[anyt]     , target:lNum   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a]           , clock:[numt,\$num], target:lNum   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a] as const  , clock:[anyt]     , target:lNum   , filter:(val) => val[0] > 0   \})
			        sample(\{source:[a] as const  , clock:[numt,\$num], target:lNum   , filter:(val, n) => val[0] > n\})
			        sample(\{source:[a]           , clock:[anyt]     , target:lNum   , filter:\$filter               \})
			        sample(\{source:[a] as const  , clock:[anyt]     , target:lNum   , filter:\$filter               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, string]>; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: (Store<number> | Event<number>)[]; target: Event<[number, string]>; filter: (val: (string | number)[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, string]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>[]; target: Event<[number]>; filter: (val: number[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: (Store<number> | Event<number>)[]; target: Event<[number]>; filter: (val: number[], n: number) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>[]; target: Event<[number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}; \}'.
			        "
			      \`)
			    \})
			    test('tuple + [clock] -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{source:[a,b]         , clock:[anyt], target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b] as const, clock:[anyt], target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a,b]         , clock:[anyt], target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a,b] as const, clock:[anyt], target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a]           , clock:[anyt], target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a] as const  , clock:[anyt], target:lNumNum, filter:(val) => val[0] > 0\})
			        //@ts-expect-error
			        sample(\{source:[a]           , clock:[anyt], target:lNumNum, filter:\$filter            \})
			        //@ts-expect-error
			        sample(\{source:[a] as const  , clock:[anyt], target:lNumNum, filter:\$filter            \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, number]>; filter: (val: (string | number)[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<any>[]; target: Event<[number, number]>; filter: (val: readonly [number, string]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<any>[]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>, Store<string>]; clock: Event<any>[]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number, string]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>[]; target: Event<[number, number]>; filter: (val: number[]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<any>[]; target: Event<[number, number]>; filter: (val: readonly [number]) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: Store<number>[]; clock: Event<any>[]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}; \}'.
			        Argument of type '\{ source: readonly [Store<number>]; clock: Event<any>[]; target: Event<[number, number]>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: readonly [number]; targetType: [number, number]; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('no source', () => \{
			  describe('clock -> unit same', () => \{
			    test('clock -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:nullableAB, target:\$ab, filter:Boolean                         \})
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk): clk is AB => clk !== null\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('clock -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk !== null           \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB | null) => clk !== null\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk.a > 0              \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB) => clk.a > 0          \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:() => 1                         \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:\$filter                         \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        'clk' is possibly 'null'.
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('clock, fn -> unit same', () => \{
			    test('clock, fn -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk !== null           , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk !== null           , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:nullableAB, target:\$ab, filter:\$filter                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:nullableAB, target:\$ab, filter:\$filter                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:nullableAB, target:\$ab, filter:Boolean                         , fn:(val) => (\{a:val.a, b:val.b\})                   \})
			        sample(\{clock:nullableAB, target:\$ab, filter:Boolean                         , fn:(val: AB) => (\{a:val.a, b:val.b\})               \})
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val) => (\{a:val.a, b:val.b\})                   \})
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val: AB) => (\{a:val.a, b:val.b\})               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val' is possibly 'null'.
			        'val' is possibly 'null'.
			        "
			      \`)
			    \})
			    test('clock, fn -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk.a > 0              , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:() => 1                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk.a > 0              , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:() => 1                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk !== null           , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk.a > 0              , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:() => 1                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk !== null           , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk) => clk.a > 0              , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:() => 1                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:\$filter                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:\$filter                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:Boolean                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:Boolean                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val: ABN) => (\{a:val.a, b:val.b\})              \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:(clk): clk is AB => clk !== null, fn:() => (\{a:0, b:1\})                              \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:Boolean                         , fn:(val: ABN) => (\{a:val.a, b:val.b\})              \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, target:\$ab, filter:Boolean                         , fn:() => (\{a:0, b:1\})                              \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((val: AB | null) => \{ ...; \}) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((val: AB | null) => \{ ...; \}) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'clk' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        'clk' is possibly 'null'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        Property 'c' does not exist on type 'ABN'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Property 'c' does not exist on type 'AB'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB' is not assignable to type 'ABN'.
			                Types of property 'b' are incompatible.
			                  Type 'string' is not assignable to type 'number'.
			        Property 'c' does not exist on type 'ABN'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => clk is AB; fn: (val: ABN) => \{ a: number; b: number; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => clk is AB; fn: (val: ABN) => \{ a: number; b: number; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: AB | null) => clk is AB; fn: (val: ABN) => \{ a: number; b: number; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<AB>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: number; b: number; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: (clk: any) => clk is AB; fn: () => \{ a: number; b: number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			        Parameter 'clk' implicitly has an 'any' type.
			        Type '(val: ABN) => \{ a: number; b: number; \}' is not assignable to type '((clk: AB) => any) & ((val: ABN) => \{ a: number; b: number; \})'.
			          Type '(val: ABN) => \{ a: number; b: number; \}' is not assignable to type '(clk: AB) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB' is not assignable to type 'ABN'.
			        Argument of type '\{ clock: Event<AB | null>; target: Store<AB>; filter: BooleanConstructor; fn: () => \{ a: number; b: number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('[clock] -> unit same', () => \{
			    test('[clock] -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:Boolean                         \})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk): clk is AB => clk !== null\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('[clock] -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk !== null           \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB | null) => clk !== null\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk.a > 0              \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB) => clk.a > 0          \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:() => 1                         \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:\$filter                         \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        'clk' is possibly 'null'.
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: Store<boolean>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: AB | null; targetType: AB; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('[clock], fn -> unit same', () => \{
			    test('[clock], fn -> unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk !== null           , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk !== null           , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:\$filter                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:\$filter                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:Boolean                         , fn:(val) => (\{a:val.a, b:val.b\})                   \})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:Boolean                         , fn:(val: AB) => (\{a:val.a, b:val.b\})               \})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val) => (\{a:val.a, b:val.b\})                   \})
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val: AB) => (\{a:val.a, b:val.b\})               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'val' is possibly 'null'.
			        'val' is possibly 'null'.
			        "
			      \`)
			    \})
			    test('[clock], fn -> unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk.a > 0              , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:() => 1                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk.a > 0              , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:() => 1                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk !== null           , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk.a > 0              , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:() => 1                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk !== null           , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB | null) => clk !== null, fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk) => clk.a > 0              , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk: AB) => clk.a > 0          , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:() => 1                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:\$filter                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:\$filter                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:Boolean                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:Boolean                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk): clk is AB => clk !== null, fn:(val: ABN) => (\{a:val.a, b:val.b\})              \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:(clk): clk is AB => clk !== null, fn:() => (\{a:0, b:1\})                              \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:Boolean                         , fn:(val: ABN) => (\{a:val.a, b:val.b\})              \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], target:\$ab, filter:Boolean                         , fn:() => (\{a:0, b:1\})                              \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((val: AB | null) => \{ ...; \}) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}...'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((val: AB | null) => \{ ...; \}) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}...'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'clk' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        'clk' is possibly 'null'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}] | [...'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}] | [...'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        Property 'c' does not exist on type 'ABN'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Property 'c' does not exist on type 'AB'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => clk is AB; fn: (val: ABN) => \{ a: number; b: number; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: (((clk: AB | null) => clk is AB | null) & ((clk: AB | null) => clk is AB | null)) | undefined; fn?: (((clk: AB | null) => any) & ((clk: AB | null) => any)) | undefined; target: Store<...>; greedy?: boolean | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => clk is AB; fn: (val: ABN) => \{ a: number; b: number; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: AB | null) => clk is AB; fn: (val: ABN) => \{ a: number; b: number; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target: Store<...>; greedy?: boolean | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: number; b: number; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: (clk: any) => clk is AB; fn: () => \{ a: number; b: number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			        Parameter 'clk' implicitly has an 'any' type.
			        Type '(val: ABN) => \{ a: number; b: number; \}' is not assignable to type '((clk: AB) => any) & ((val: ABN) => \{ a: number; b: number; \})'.
			          Type '(val: ABN) => \{ a: number; b: number; \}' is not assignable to type '(clk: AB) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB' is not assignable to type 'ABN'.
			        Argument of type '\{ clock: (Event<AB> | Event<AB | null>)[]; target: Store<AB>; filter: BooleanConstructor; fn: () => \{ a: number; b: number; \}; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			          Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: number; b: number; \}; targetType: AB; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('clock -> new unit same', () => \{
			    test('clock -> new unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:nullableAB, filter:(clk) => clk !== null           \})
			        sample(\{clock:nullableAB, filter:(clk: AB | null) => clk !== null\})
			        sample(\{clock:nullableAB, filter:\$filter                         \})
			        sample(\{clock:nullableAB, filter:Boolean                         \})
			        sample(\{clock:nullableAB, filter:(clk): clk is AB => clk !== null\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('clock -> new unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk) => clk.a > 0    \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk: AB) => clk.a > 0\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:() => 1               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => clk is AB | null; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ clock: Event<...>; filter: (clk: AB) => boolean; \}'.
			              Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: () => number; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => clk is AB | null; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: () => number; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: () => number; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ clock: Event<...>; filter: () => number; \}'.
			              Type '\{ clock: Event<AB | null>; filter: () => number; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        "
			      \`)
			    \})
			  \})
			  describe('clock, fn -> new unit same', () => \{
			    test('clock, fn -> new unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:nullableAB, filter:(clk) => clk !== null           , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:nullableAB, filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:nullableAB, filter:(clk) => clk !== null           , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:nullableAB, filter:(clk: AB | null) => clk !== null, fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:nullableAB, filter:\$filter                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:nullableAB, filter:\$filter                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:nullableAB, filter:Boolean                         , fn:(val) => (\{a:val.a, b:val.b\})                   \})
			        sample(\{clock:nullableAB, filter:Boolean                         , fn:(val: AB) => (\{a:val.a, b:val.b\})               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('clock, fn -> new unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk) => clk.a > 0              , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:() => 1                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk) => clk.a > 0              , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk: AB) => clk.a > 0          , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:() => 1                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk) => clk !== null           , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk) => clk.a > 0              , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:() => 1                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk) => clk !== null           , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk: AB | null) => clk !== null, fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk) => clk.a > 0              , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:(clk: AB) => clk.a > 0          , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:() => 1                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:\$filter                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:\$filter                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:Boolean                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:nullableAB, filter:Boolean                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'clk' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        'clk' is possibly 'null'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: Event<AB | null>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: Event<AB | null>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: Event<AB | null>; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: Event<AB | null>; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        Property 'c' does not exist on type 'ABN'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Property 'c' does not exist on type 'AB'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        "
			      \`)
			    \})
			  \})
			  describe('[clock] -> new unit same', () => \{
			    test('[clock] -> new unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk !== null           \})
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB | null) => clk !== null\})
			        sample(\{clock:[ab,nullableAB], filter:\$filter                         \})
			        sample(\{clock:[ab,nullableAB], filter:Boolean                         \})
			        sample(\{clock:[ab,nullableAB], filter:(clk): clk is AB => clk !== null\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('[clock] -> new unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk.a > 0    \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB) => clk.a > 0\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:() => 1               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => clk is AB | null; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => clk is AB | null; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter: (clk: AB | null) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        "
			      \`)
			    \})
			  \})
			  describe('[clock], fn -> new unit same', () => \{
			    test('[clock], fn -> new unit same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk !== null           , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk !== null           , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB | null) => clk !== null, fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:[ab,nullableAB], filter:\$filter                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        sample(\{clock:[ab,nullableAB], filter:\$filter                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        sample(\{clock:[ab,nullableAB], filter:Boolean                         , fn:(val) => (\{a:val.a, b:val.b\})                   \})
			        sample(\{clock:[ab,nullableAB], filter:Boolean                         , fn:(val: AB) => (\{a:val.a, b:val.b\})               \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('[clock], fn -> new unit same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk.a > 0              , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:() => 1                         , fn:(val) => (\{a:1, b: val ? val.b : ''\})           \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk.a > 0              , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB) => clk.a > 0          , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:() => 1                         , fn:(val: AB | null) => (\{a:1, b: val ? val.b : ''\})\})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk !== null           , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB | null) => clk !== null, fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk.a > 0              , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB) => clk.a > 0          , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:() => 1                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk !== null           , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB | null) => clk !== null, fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk) => clk.a > 0              , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:(clk: AB) => clk.a > 0          , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:() => 1                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:\$filter                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:\$filter                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:Boolean                         , fn:(val) => (\{a:val.c, b:val.b\})                   \})
			        //@ts-expect-error
			        sample(\{clock:[ab,nullableAB], filter:Boolean                         , fn:(val: ABN) => (\{a:val.c, b:''\})                 \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'clk' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((val: AB | null) => \{ ...; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((val: AB | null) => \{ ...; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: number; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((val: AB | null) => \{ a: number; b: string; \}) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        'clk' is possibly 'null'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'filter' are incompatible.
			                Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                  Types of parameters 'clk' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'AB'.
			                      Type 'null' is not assignable to type 'AB'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: AB | null) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              The types returned by 'filter(...)' are incompatible between these types.
			                Type 'number' is not assignable to type 'boolean'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB | null) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			              Types of property 'fn' are incompatible.
			                Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			                  Types of parameters 'val' and 'clk' are incompatible.
			                    Type 'AB | null' is not assignable to type 'ABN'.
			                      Type 'null' is not assignable to type 'ABN'.
			        'clk' is possibly 'null'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: (clk: AB) => boolean; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                Types of property 'filter' are incompatible.
			                  Type '(clk: AB) => boolean' is not assignable to type '(clk: AB | null) => boolean'.
			                    Types of parameters 'clk' and 'clk' are incompatible.
			                      Type 'AB | null' is not assignable to type 'AB'.
			                        Type 'null' is not assignable to type 'AB'.
			        Property 'c' does not exist on type 'ABN'.
			        Argument of type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to parameter of type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => clk is AB | null) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}] | [config: ...]'.
			          Type '[\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}]' is not assignable to type '[config: \{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}]'.
			            Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ ...; \}'.
			              Type '\{ clock: (Event<AB> | Event<AB | null>)[]; filter: () => number; fn: (val: ABN) => \{ a: any; b: string; \}; \}' is not assignable to type '\{ clock: (Event<AB> | Event<AB | null>)[]; source?: undefined; filter?: ((clk: AB | null) => boolean) | undefined; fn?: ((clk: AB | null) => any) | undefined; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        Property 'c' does not exist on type 'ABN'.
			        'val' is possibly 'null'.
			        Property 'c' does not exist on type 'AB'.
			        'val' is possibly 'null'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB | null) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB | null) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB | null' is not assignable to type 'ABN'.
			                Type 'null' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        Property 'c' does not exist on type 'AB'.
			        Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '((clk: AB) => any) & ((val: ABN) => \{ a: any; b: string; \})'.
			          Type '(val: ABN) => \{ a: any; b: string; \}' is not assignable to type '(clk: AB) => any'.
			            Types of parameters 'val' and 'clk' are incompatible.
			              Type 'AB' is not assignable to type 'ABN'.
			        Property 'c' does not exist on type 'ABN'.
			        "
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleFilter.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(82)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleReturn.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample, Event, Store\} from 'effector'
			const typecheck = '\{global\}'
			type AN = \{a: number\}
			const \$num = createStore(0)
			const a = createStore(\{a: 0\})
			const \$aNull = createStore<AN | null>(\{a: 0\})
			const num = createEvent<number>()
			const aNum = createEvent<AN>()
			const aNumNull = createEvent<AN | null>()
			const aT = createStore(\{a: 0\})
			const aNumT = createEvent<AN>()
			const \$flag = createStore(true)
			const fn0 = () => (\{a: 0\})
			const fn1 = (\{a\}: AN) => (\{a\})
			const fn2 = (\{a\}: AN, c: number) => (\{a: a + c\})
			const filterFun = (val: AN | null) => val !== null
			const filterInf = (val: AN | null): val is AN => val !== null
			describe('no target', () => \{
			  test('no target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    \})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       \})\}
			      \{const result: Store<AN> = sample(\{source:a       , fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:(val: AN | null): val is AN => val !== null\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num]\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num]\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num]\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('no target, typed fn', () => \{
			  test('no target, typed fn, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , filter:\$flag, fn:fn1\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, typed fn, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, typed fn, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, typed fn, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('unit target', () => \{
			  test('unit target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:filterInf\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:filterInf\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:filterInf, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:filterInf, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:Boolean\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:Boolean\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:Boolean, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:Boolean, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aT   \})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aT   , fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aNumT, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aT   , fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aNumT, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aT   , fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aNumT, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:filterFun\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:filterFun\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:filterFun, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:filterFun, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:\$flag\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:\$flag\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:\$flag, fn:fn0\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:\$flag, fn:fn0\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('unit target, typed fn', () => \{
			  test('unit target, typed fn, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , target:aNumT, filter:\$flag, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , target:aNumT, filter:\$flag, fn:fn1\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, typed fn, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:filterInf, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:filterInf, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:num, target:aT   , filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:num, target:aNumT, filter:Boolean, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:num, target:aT   , filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:num, target:aNumT, filter:Boolean, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:num, target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:filterFun, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:filterFun, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:\$flag, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:num, target:aT   , filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:num, target:aNumT, filter:\$flag, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:\$flag, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:num, target:aT   , filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:num, target:aNumT, filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, typed fn, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:filterInf, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:filterInf, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:\$num, target:aT   , filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:\$num, target:aNumT, filter:Boolean, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:\$num, target:aT   , filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:\$num, target:aNumT, filter:Boolean, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:\$num, target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:filterFun, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:filterFun, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:\$flag, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:\$num, target:aT   , filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:\$num, target:aNumT, filter:\$flag, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:\$flag, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:\$num, target:aT   , filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:\$num, target:aNumT, filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, typed fn, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:filterInf, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:filterInf, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:filterInf, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:filterInf, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:filterInf, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aT   , filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNumNull, clock:[num,\$num], target:aNumT, filter:Boolean, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:Boolean, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:Boolean, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aT   , filter:Boolean, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\$aNull  , clock:[num,\$num], target:aNumT, filter:Boolean, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aT   , fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aNumT, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aT   , fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:aNumT, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:filterFun, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:filterFun, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:filterFun, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:filterFun, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:filterFun, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:\$flag, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aT   , filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:aNum    , clock:[num,\$num], target:aNumT, filter:\$flag, fn:fn2\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:\$flag, fn:fn1\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:\$flag, fn:fn1\})\}
			      \{const result: Store<AN> = sample(\{source:a       , clock:[num,\$num], target:aT   , filter:\$flag, fn:fn2\})\}
			      \{const result: Event<AN> = sample(\{source:a       , clock:[num,\$num], target:aNumT, filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('tuple target', () => \{
			  test('tuple target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			        Target requires 2 element(s) but source may have fewer.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:num, target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:num, target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:num, target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:\$num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:\$num, target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:\$num, target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:\$num, target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:filterInf\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:Boolean\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:(\{a\}:AN,c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT], fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT], fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT], fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:filterFun\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:\$flag\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:fn0\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:(\{a\}) => (\{a\})\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:(\{a\},c) => (\{a:a+c\})\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			\})
			describe('tuple target, typed fn', () => \{
			  test('tuple target, typed fn, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, typed fn, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:filterInf, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:filterInf, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:num, target:[aNumT,aT], filter:Boolean, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:num, target:[aNumT,aT], filter:Boolean, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:num, target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:num, target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:filterFun, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:filterFun, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:num, target:[aNumT,aT], filter:\$flag, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:num, target:[aNumT,aT], filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, typed fn, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:filterInf, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:filterInf, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:\$num, target:[aNumT,aT], filter:Boolean, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:\$num, target:[aNumT,aT], filter:Boolean, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:\$num, target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:\$num, target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:filterFun, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:\$num, target:[aNumT,aT], filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, typed fn, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:filterInf, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNumNull, clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\$aNull  , clock:[num,\$num], target:[aNumT,aT], filter:Boolean, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT], fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT], fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:filterFun, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:aNum    , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:fn2\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:fn1\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{source:a       , clock:[num,\$num], target:[aNumT,aT], filter:\$flag, fn:fn2\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\generated\\sampleReturn.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(24)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\guard\\guardArrayTarget.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, guard\} from 'effector'
			const typecheck = '\{global\}'
			
			/** used as valid source type */
			type AN = \{a: number\}
			/** used as invalid source type */
			type AS = \{a: string\}
			/** used as valid source type */
			type AB = \{a: number; b: string\}
			/** used as invalid source type */
			type ABN = \{a: number; b: number\}
			const voidt = createEvent()
			const anyt = createEvent<any>()
			const str = createEvent<string>()
			const num = createEvent<number>()
			const numStr = createEvent<number | string>()
			const strBool = createEvent<string | boolean>()
			const \$num = createStore<number>(0)
			const \$str = createStore<string>('')
			const a_num = createEvent<AN>()
			const a_str = createEvent<AS>()
			const ab = createEvent<AB>()
			const abn = createEvent<ABN>()
			const l_num = createEvent<[number]>()
			const l_str = createEvent<[string]>()
			const l_num_str = createEvent<[number, string]>()
			const l_num_num = createEvent<[number, number]>()
			
			const fn = \{
			  noArgs: () => (\{a: 2, b: ''\}),
			  assertFirst: \{
			    object: \{
			      solo: (\{a\}: AS, cl: number) => (\{a: cl, b: a\}),
			      pair: (\{a, b\}: ABN, cl: number) => (\{a: b + cl, b: ''\}),
			    \},
			    tuple: \{
			      solo: ([a]: [string], cl: number) => (\{a: cl, b: a\}),
			      pair: ([a, b]: [number, number], cl: number) => (\{a: b + cl, b: ''\}),
			    \},
			  \},
			  assertFirstOnly: \{
			    object: \{
			      solo: (\{a\}: AS) => (\{a: 0, b: a\}),
			      pair: (\{b\}: ABN) => (\{a: b, b: ''\}),
			    \},
			    tuple: \{
			      solo: ([a]: [string]) => (\{a: 2, b: a\}),
			      pair: ([, b]: [number, number]) => (\{a: b, b: ''\}),
			    \},
			  \},
			  assertSecond: \{
			    object: \{
			      solo: (\{a\}: AN, cl: string) => (\{a, b: cl\}),
			      pair: (\{a\}: AB, cl: string) => (\{a, b: cl\}),
			    \},
			    tuple: \{
			      solo: ([a]: [number], cl: string) => (\{a, b: cl\}),
			      pair: ([a]: [number, string], cl: string) => (\{a, b: cl\}),
			    \},
			  \},
			  typedSrc: \{
			    object: \{
			      solo: (\{a\}: AN) => (\{a, b: ''\}),
			      pair: (\{a, b\}: AB) => (\{a, b\}),
			    \},
			    tuple: \{
			      solo: ([a]: [number]) => (\{a, b: ''\}),
			      pair: ([a, b]: [number, string]) => (\{a, b\}),
			    \},
			  \},
			  typedSrcClock: \{
			    object: \{
			      solo: (\{a\}: AN, cl: number) => (\{a: a + cl, b: ''\}),
			      pair: (\{a, b\}: AB, cl: number) => (\{a: a + cl, b\}),
			    \},
			    tuple: \{
			      solo: ([a]: [number], cl: number) => (\{a: a + cl, b: ''\}),
			      pair: ([a, b]: [number, string], cl: number) => (\{a: a + cl, b\}),
			    \},
			  \},
			\}
			
			describe('basic cases', () => \{
			  describe('no fn', () => \{
			    test('no fn (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{filter: () => true, source:num, clock:num, target:[anyt]          \})
			        guard(\{filter: () => true, source:num, clock:str, target:[anyt]          \})
			        guard(\{filter: () => true, source:num, clock:num, target:[num]           \})
			        guard(\{filter: () => true, source:num, clock:str, target:[num]           \})
			        guard(\{filter: () => true, source:str, clock:num, target:[anyt]          \})
			        guard(\{filter: () => true, source:str, clock:num, target:[anyt,voidt]    \})
			        guard(\{filter: () => true, source:str, clock:num, target:[numStr]        \})
			        guard(\{filter: () => true, source:str, clock:num, target:[voidt]         \})
			        guard(\{filter: () => true, source:num, clock:num, target:[voidt]         \})
			        guard(\{filter: () => true, source:num, clock:num, target:[numStr,anyt]   \})
			        guard(\{filter: () => true, source:str, clock:str, target:[numStr,anyt]   \})
			        guard(\{filter: () => true, source:str, clock:str, target:[numStr,voidt]  \})
			        guard(\{filter: () => true, source:str, clock:str, target:[strBool,numStr]\})
			        guard(\{filter: () => true, source:str, clock:str, target:[strBool,anyt]  \})
			        guard(\{filter: () => true, source:str, clock:str, target:[strBool,voidt] \})
			        guard(\{filter: () => true, source:str, clock:str, target:[anyt,numStr]   \})
			        guard(\{filter: () => true, source:str, clock:str, target:[anyt,voidt]    \})
			        guard(\{filter: () => true, source:str, clock:str, target:[str,numStr]    \})
			        guard(\{filter: () => true, source:str, clock:str, target:[str,anyt]      \})
			        guard(\{filter: () => true, source:str, clock:str, target:[str,voidt]     \})
			        guard(\{filter: () => true, source:str, clock:str, target:[voidt,numStr]  \})
			        guard(\{filter: () => true, source:str, clock:str, target:[voidt,strBool] \})
			        guard(\{filter: () => true, source:str, clock:str, target:[voidt,anyt]    \})
			        guard(\{filter: () => true, source:str, clock:str, target:[numStr]        \})
			        guard(\{filter: () => true, source:str, clock:str, target:[strBool]       \})
			        guard(\{filter: () => true, source:str, clock:str, target:[anyt]          \})
			        guard(\{filter: () => true, source:str, clock:str, target:[str]           \})
			        guard(\{filter: () => true, source:str, clock:str, target:[voidt]         \})
			        guard(\{filter: () => true, source:num, clock:str, target:[voidt]         \})
			        guard(\{filter: () => true, source:str, clock:num, target:[str,anyt]      \})
			        guard(\{filter: () => true, source:str, clock:num, target:[strBool,voidt] \})
			        guard(\{filter: () => true, source:num, clock:str, target:[numStr,anyt]   \})
			        guard(\{filter: () => true, source:str, clock:num, target:[str,numStr]    \})
			        guard(\{filter: () => true, source:str, clock:num, target:[numStr,anyt]   \})
			        guard(\{filter: () => true, source:str, clock:num, target:[strBool]       \})
			        guard(\{filter: () => true, source:str, clock:num, target:[str]           \})
			        guard(\{filter: () => true, source:str, clock:num, target:[str,voidt]     \})
			        guard(\{filter: () => true, source:str, clock:num, target:[strBool,numStr]\})
			        guard(\{filter: () => true, source:num, clock:num, target:[num,anyt]      \})
			        guard(\{filter: () => true, source:num, clock:str, target:[num,anyt]      \})
			        guard(\{filter: () => true, source:str, clock:num, target:[numStr,voidt]  \})
			        guard(\{filter: () => true, source:num, clock:num, target:[voidt,numStr]  \})
			        guard(\{filter: () => true, source:num, clock:num, target:[voidt,anyt]    \})
			        guard(\{filter: () => true, source:str, clock:num, target:[voidt,numStr]  \})
			        guard(\{filter: () => true, source:num, clock:str, target:[voidt,anyt]    \})
			        guard(\{filter: () => true, source:num, clock:num, target:[num,numStr]    \})
			        guard(\{filter: () => true, source:num, clock:str, target:[voidt,numStr]  \})
			        guard(\{filter: () => true, source:num, clock:num, target:[num,voidt]     \})
			        guard(\{filter: () => true, source:num, clock:str, target:[num,voidt]     \})
			        guard(\{filter: () => true, source:num, clock:num, target:[numStr]        \})
			        guard(\{filter: () => true, source:str, clock:num, target:[anyt,numStr]   \})
			        guard(\{filter: () => true, source:str, clock:num, target:[voidt,strBool] \})
			        guard(\{filter: () => true, source:num, clock:num, target:[anyt,numStr]   \})
			        guard(\{filter: () => true, source:num, clock:str, target:[num,numStr]    \})
			        guard(\{filter: () => true, source:str, clock:num, target:[voidt,anyt]    \})
			        guard(\{filter: () => true, source:num, clock:num, target:[anyt,voidt]    \})
			        guard(\{filter: () => true, source:str, clock:num, target:[strBool,anyt]  \})
			        guard(\{filter: () => true, source:num, clock:str, target:[anyt,voidt]    \})
			        guard(\{filter: () => true, source:num, clock:str, target:[numStr]        \})
			        guard(\{filter: () => true, source:num, clock:num, target:[numStr,voidt]  \})
			        guard(\{filter: () => true, source:num, clock:str, target:[numStr,voidt]  \})
			        guard(\{filter: () => true, source:num, clock:str, target:[anyt,numStr]   \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('no fn (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:num, target:[num]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:str, target:[num]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[str]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:num, target:[num,voidt]     \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:str, target:[num,numStr]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:str, target:[num,anyt]      \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:str, target:[num,str]       \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:str, target:[num,voidt]     \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[str]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:num, target:[num,str]       \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:num, target:[num,anyt]      \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[num,str]       \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[num,str]       \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:str, clock:num, target:[num,numStr]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[str,voidt]     \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[strBool,voidt] \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[str,numStr]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[str,numStr]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[str,voidt]     \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[strBool]       \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[strBool]       \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[strBool,anyt]  \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[strBool,voidt] \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[voidt,strBool] \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[strBool,anyt]  \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[strBool,numStr]\})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:num, target:[str,anyt]      \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[str,anyt]      \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[voidt,strBool] \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:num, clock:str, target:[strBool,numStr]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<string | boolean>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('combinable', () => \{
			  describe('source:wide', () => \{
			    test('source:wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num]    \})
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num,ab] \})
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[ab]       \})
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num]    \})
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num,ab] \})
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[ab]       \})
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_str]\})
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_str]\})
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num]               \})
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num,l_num_str]     \})
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num]    \})
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num,l_num_str]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('source:wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[abn]                \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[abn,a_str]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num,abn]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[abn,ab]             \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[ab,a_str]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_str,ab]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[abn]                \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[abn,a_str]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[ab,a_str]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num,abn]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[abn,ab]             \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_str,ab]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num,l_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_num]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_num]          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			  describe('source:same', () => \{
			    test('source:same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[a_num]\})
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num]\})
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num]\})
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('source:same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[a_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[abn]                \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[ab]                 \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[a_num,abn]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[a_num,ab]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[a_str,ab]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[abn,a_str]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[abn,ab]             \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, target:[ab,a_str]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num,abn]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[abn,ab]             \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[abn,a_str]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[abn]                \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[ab,a_str]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num,ab]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[ab]                 \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_str,ab]           \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num_str]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num_num]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num,l_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_str]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_num]          \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        guard(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_num,l_str]    \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<ABN>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<AS>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<AB>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Event<[number, number]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			              Type 'Event<[string]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			        "
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\guard\\guardArrayTarget.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\guard\\guardClockArray.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, guard\} from 'effector'
			const typecheck = '\{global\}'
			
			type AB = \{a: string; b: number\}
			const voidt = createEvent()
			const anyt = createEvent<any>()
			const str = createEvent<string>()
			const strClk = createEvent<string>()
			const num = createEvent<number>()
			const a = createStore('')
			const b = createStore(0)
			const aTarget = createEvent<\{a: string\}>()
			const abTarget = createEvent<AB>()
			const aclock = createEvent<\{a: string; clock: any\}>()
			const abclock = createEvent<\{a: string; b: number; clock: any\}>()
			const fnAbClockString = (\{a, b\}: AB, clock: string) => (\{a, b, clock\})
			const fnAbClockAny = (\{a, b\}: AB, clock: any) => (\{a, b, clock\})
			const fnAString = (a: string) => (\{a\})
			const fnAStringClockString = (a: string, clock: string) => (\{a, clock\})
			const fnAStringClockAny = (a: string, clock: any) => (\{a, clock\})
			const fnAb = (\{a, b\}: AB) => (\{a, b\})
			
			describe('clock only', () => \{
			  test('noSource (should pass)', () => \{
			    //prettier-ignore
			    \{
			      guard(\{filter: () => true, clock:strClk       \})
			      guard(\{filter: () => true, clock:anyt         \})
			      guard(\{filter: () => true, clock:[strClk]     \})
			      guard(\{filter: () => true, clock:[anyt]       \})
			      guard(\{filter: () => true, clock:[strClk,anyt]\})
			      guard(\{filter: () => true, clock:strClk       , target:str\})
			      guard(\{filter: () => true, clock:anyt         , target:str\})
			      guard(\{filter: () => true, clock:[strClk]     , target:str\})
			      guard(\{filter: () => true, clock:[anyt]       , target:str\})
			      guard(\{filter: () => true, clock:[strClk,anyt], target:str\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			test('noClock (should pass)', () => \{
			  //prettier-ignore
			  \{
			    guard(\{filter: () => true, source:a    \})
			    guard(\{filter: () => true, source:\{a,b\}\})
			    guard(\{filter: () => true, source:a    , target:str     \})
			    guard(\{filter: () => true, source:\{a,b\}, target:abTarget\})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test(' (should pass)', () => \{
			  //prettier-ignore
			  \{
			    guard(\{filter: () => true, source:a    , clock:[voidt,str]     \})
			    guard(\{filter: () => true, source:a    , clock:[voidt]         \})
			    guard(\{filter: () => true, source:a    , clock:[str]           \})
			    guard(\{filter: () => true, source:a    , clock:[str,voidt,anyt]\})
			    guard(\{filter: () => true, source:a    , clock:[voidt,str,anyt]\})
			    guard(\{filter: () => true, source:a    , clock:[anyt,str,voidt]\})
			    guard(\{filter: () => true, source:a    , clock:[voidt,anyt,str]\})
			    guard(\{filter: () => true, source:a    , clock:[str,anyt,voidt]\})
			    guard(\{filter: () => true, source:a    , clock:[anyt,voidt,str]\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[str]           \})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt]         \})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt,str]     \})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[anyt,str,voidt]\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt,anyt,str]\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[anyt,voidt,str]\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt,str,anyt]\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[str,anyt,voidt]\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[str,voidt,anyt]\})
			    guard(\{filter: () => true, source:a    , clock:[voidt]         , target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[str]           , target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[voidt,str]     , target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[str,voidt,anyt], target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[voidt,anyt,str], target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[anyt,str,voidt], target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[voidt,str,anyt], target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[str,anyt,voidt], target:str     \})
			    guard(\{filter: () => true, source:a    , clock:[anyt,voidt,str], target:str     \})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt]         , target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[str]           , target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt,str]     , target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt,str,anyt], target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[anyt,voidt,str], target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[str,voidt,anyt], target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[str,anyt,voidt], target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[voidt,anyt,str], target:abTarget\})
			    guard(\{filter: () => true, source:\{a,b\}, clock:[anyt,str,voidt], target:abTarget\})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\guard\\guardClockArray.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\guard\\guardOther.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  sample,
			  guard,
			  Store,
			  Event,
			\} from 'effector'
			const typecheck = '\{global\}'
			
			test('clock param name in the function', () => \{
			  const trigger: Event<number> = createEvent()
			  const allow: Store<string> = createStore('no')
			
			  const result1 = guard(\{
			    source: trigger,
			    //@ts-expect-error
			    filter: allow,
			  \})
			  const result2 = guard(\{
			    source: trigger,
			    clock: trigger,
			    //@ts-expect-error
			    filter: allow,
			  \})
			  const result3 = guard(\{
			    clock: trigger,
			    //@ts-expect-error
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Store<string>' is not assignable to type 'Store<boolean> | ((source: number) => boolean)'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Store<string>' is not assignable to type 'Store<boolean> | ((source: number, clock: number) => boolean)'.
			          Type 'Store<string>' is not assignable to type 'Store<boolean>'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Store<string>' is not assignable to type 'Store<boolean> | ((clock: number) => boolean)'.
			          Type 'Store<string>' is not assignable to type 'Store<boolean>'.
			    "
			  \`)
			\})
			
			test('custom typeguards: target array support (1)', () => \{
			  function debounce<T>(event: Event<T>): Event<T> \{
			    return event
			  \}
			  const \$store = createStore<string | number>(0)
			  const \$flag = createStore(false)
			  const trigger = createEvent<\{a: number\}>()
			
			  const targetA = createEffect<\{field: number | string; data: number\}, void>()
			  const targetB = createEvent<\{field: number | string; data: string\}>()
			  const targetC = createEvent<\{field: unknown; data: number\}>()
			  const targetD = createEvent<\{field: number; data: number\}>()
			  const targetE = createEvent<\{field: any\}>()
			  const targetF = createEvent<\{field: any; data: any; extra: boolean\}>()
			  const targetVoid = createEvent()
			  const targetAny = createEvent<any>()
			
			  const res = guard(\{
			    source: sample(\{
			      clock: debounce(trigger),
			      source: [\$flag, \$store],
			      fn: ([isAble, field], data) => (isAble ? \{field, data\} : null),
			    \}),
			    filter: (e): e is \{field: number | string; data: number\} => !!e,
			    target: [
			      targetVoid,
			      targetA,
			      //@ts-expect-error
			      targetB,
			      targetC,
			      //@ts-expect-error
			      targetD,
			      targetE,
			      //@ts-expect-error
			      targetF,
			      targetAny,
			    ],
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '((src: (string | number | boolean)[], clk: \{ a: number; \}) => any) & (([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null)'.
			      Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '(src: (string | number | boolean)[], clk: \{ a: number; \}) => any'.
			        Types of parameters '__0' and 'src' are incompatible.
			          Type '(string | number | boolean)[]' is not assignable to type '[any, any]'.
			            Target requires 2 element(s) but source may have fewer.
			    Binding element 'isAble' implicitly has an 'any' type.
			    Binding element 'field' implicitly has an 'any' type.
			    Parameter 'data' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			test('custom typeguards: target array support (2)', () => \{
			  function debounce<T>(event: Event<T>): Event<T> \{
			    return event
			  \}
			  const \$store = createStore<string | number>(0)
			  const \$flag = createStore(false)
			  const trigger = createEvent<\{a: number\}>()
			
			  const targetA = createEffect<\{field: number | string; data: number\}, void>()
			  const targetB = createEvent<\{field: number | string; data: string\}>()
			  const targetC = createEvent<\{field: unknown; data: number\}>()
			  const targetD = createEvent<\{field: string; data: number\}>()
			  const targetE = createEvent<\{field: any\}>()
			  const targetF = createEvent<\{field: any; data: any; extra: boolean\}>()
			
			  const targetVoid = createEvent()
			  const targetAny = createEvent<any>()
			
			  const res = guard(\{
			    source: sample(\{
			      clock: debounce(trigger),
			      source: [\$flag, \$store],
			      fn: ([isAble, field], data) => (isAble ? \{field, data\} : null),
			    \}),
			    filter: (e): e is \{field: number; data: number\} => !!e,
			    target: [
			      targetVoid,
			      targetA,
			      //@ts-expect-error
			      targetB,
			      targetC,
			      //@ts-expect-error
			      targetD,
			      targetE,
			      //@ts-expect-error
			      targetF,
			      targetAny,
			    ],
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '((src: (string | number | boolean)[], clk: \{ a: number; \}) => any) & (([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null)'.
			      Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '(src: (string | number | boolean)[], clk: \{ a: number; \}) => any'.
			        Types of parameters '__0' and 'src' are incompatible.
			          Type '(string | number | boolean)[]' is not assignable to type '[any, any]'.
			    Binding element 'isAble' implicitly has an 'any' type.
			    Binding element 'field' implicitly has an 'any' type.
			    Parameter 'data' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			test('generic support', () => \{
			  const source = createEvent<null | number>()
			  const target = createEvent<number>()
			
			  function filter<T>(value: T): value is NonNullable<T> \{
			    return value != null
			  \}
			
			  guard(\{source, filter, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<number>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\guard\\guardOther.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\guard\\guardReturn.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, guard, Event, Store\} from 'effector'
			const typecheck = '\{global\}'
			type AN = \{a: number\}
			const \$num = createStore(0)
			const a = createStore(\{a: 0\})
			const num = createEvent<number>()
			const aNum = createEvent<AN>()
			const aT = createStore(\{a: 0\})
			const aNumT = createEvent<AN>()
			const fn0 = () => (\{a: 0\})
			const fn1 = (\{a\}: AN) => (\{a\})
			const fn2 = (\{a\}: AN, c: number) => (\{a: a + c\})
			
			describe('no target', () => \{
			  test('no target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    , clock:num\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       , clock:num\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:num\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    , clock:\$num\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       , clock:\$num\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:\$num\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    , clock:[num,\$num]\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       , clock:[num,\$num]\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('unit target', () => \{
			  test('unit target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    , target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:aNum    , target:aT   \})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:a       , target:aT   \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       , target:aNumT\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}, target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:\{a:\$num\}, target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    , clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:aNum    , clock:num, target:aT   \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       , clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:a       , clock:num, target:aT   \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = guard(\{filter: () => true, source:aNum    , clock:\$num, target:aT   \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    , clock:\$num, target:aNumT\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       , clock:\$num, target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:a       , clock:\$num, target:aT   \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:\$num, target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:\$num, target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = guard(\{filter: () => true, source:aNum    , clock:[num,\$num], target:aT   \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:aNum    , clock:[num,\$num], target:aNumT\})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:a       , clock:[num,\$num], target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:a       , clock:[num,\$num], target:aT   \})\}
			      \{const result: Event<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num], target:aNumT\})\}
			      \{const result: Store<AN> = guard(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num], target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('tuple target', () => \{
			  test('tuple target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:aNum    , target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:a       , target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:\{a:\$num\}, target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('tuple target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:aNum    , clock:num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:a       , clock:num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('tuple target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:aNum    , clock:\$num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:a       , clock:\$num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:\{a:\$num\}, clock:\$num, target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('tuple target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:aNum    , clock:[num,\$num], target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:a       , clock:[num,\$num], target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = guard(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\guard\\guardReturn.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\guard\\guardWideNarrow.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, guard, Event\} from 'effector'
			const typecheck = '\{global\}'
			
			test('wide union (should fail)', () => \{
			  const trigger: Event<\{a: 1\} | \{a: 2\} | \{a: 3\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1\} | \{a: 2\}> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<\{ a: 1; \} | \{ a: 2; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}>' is not assignable to type 'Event<\{ a: 1; \} | \{ a: 2; \}>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: \{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ a: 1; \} | \{ a: 2; \}) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type '\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}' is not assignable to type '\{ a: 1; \} | \{ a: 2; \}'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<\{ a: 1; \} | \{ a: 2; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}>' is not assignable to type '[Event<\{ a: 1; \} | \{ a: 2; \}>]'.
			    "
			  \`)
			\})
			
			test('narrow union (should pass)', () => \{
			  const trigger: Event<\{a: 1\} | \{a: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1\} | \{a: 2\} | \{a: 3\}> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('unknown type in source (should fail)', () => \{
			  const trigger: Event<unknown> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<string> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<unknown>' is not assignable to type 'Event<string>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: unknown) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type 'unknown' is not assignable to type 'string'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<unknown>' is not assignable to type '[Event<string>]'.
			    "
			  \`)
			\})
			
			test('unknown type in target (should pass)', () => \{
			  const trigger: Event<string> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<unknown> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('optional props (should fail)', () => \{
			  const trigger: Event<\{a: 1; b?: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1; b: 2\}> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<\{ a: 1; b: 2; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<\{ a: 1; b?: 2 | undefined; \}>' is not assignable to type 'Event<\{ a: 1; b: 2; \}>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: \{ a: 1; b?: 2 | undefined; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ a: 1; b: 2; \}) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type '\{ a: 1; b?: 2 | undefined; \}' is not assignable to type '\{ a: 1; b: 2; \}'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<\{ a: 1; b: 2; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<\{ a: 1; b?: 2 | undefined; \}>' is not assignable to type '[Event<\{ a: 1; b: 2; \}>]'.
			    "
			  \`)
			\})
			
			test('wide object (should pass)', () => \{
			  const trigger: Event<\{a: 1; b: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1\}> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('narrow object (should fail)', () => \{
			  const trigger: Event<\{a: 1; b: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1; b: 2; c: 3\}> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<\{ a: 1; b: 2; c: 3; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<\{ a: 1; b: 2; \}>' is not assignable to type 'Event<\{ a: 1; b: 2; c: 3; \}>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: \{ a: 1; b: 2; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ a: 1; b: 2; c: 3; \}) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type '\{ a: 1; b: 2; \}' is not assignable to type '\{ a: 1; b: 2; c: 3; \}'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<\{ a: 1; b: 2; c: 3; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<\{ a: 1; b: 2; \}>' is not assignable to type '[Event<\{ a: 1; b: 2; c: 3; \}>]'.
			    "
			  \`)
			\})
			
			test('narrow object combined (should fail)', () => \{
			  const foo = createStore('not enough')
			  const target = createEvent<\{foo: string; bar: string\}>()
			
			  guard(\{
			    source: \{foo\},
			    filter: () => true,
			    //@ts-expect-error
			    target,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<\{ foo: string; bar: string; \}>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    "
			  \`)
			\})
			
			test('wide tuple (should pass)', () => \{
			  const trigger: Event<[1, 2, 3]> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<[1, 2]> = createEvent()
			
			  guard(\{
			    source: trigger,
			    filter: allow,
			    target,
			  \})
			
			  guard(\{
			    source: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('narrow tuple (should fail)', () => \{
			  const trigger: Event<[1, 2]> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<[1, 2, 3]> = createEvent()
			
			  guard(\{
			    source: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target,
			  \})
			
			  guard(\{
			    source: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<[1, 2, 3]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<[1, 2, 3]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    "
			  \`)
			\})
			
			test('wide union in array (should fail)', () => \{
			  const trigger: Event<Array<number | string | boolean>> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<Array<number | string>> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    //@ts-expect-error
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = guard(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<(string | number)[]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<(string | number | boolean)[]>' is not assignable to type 'Event<(string | number)[]>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: (string | number | boolean)[]) => any) => Subscription' is not assignable to type '(watcher: (payload: (string | number)[]) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type '(string | number | boolean)[]' is not assignable to type '(string | number)[]'.
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'Event<(string | number)[]>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			    Type 'Event<(string | number | boolean)[]>' is not assignable to type '[Event<(string | number)[]>]'.
			    "
			  \`)
			\})
			
			test('narrow union in array (should pass)', () => \{
			  const trigger: Event<Array<number | string>> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<Array<number | string | boolean>> = createEvent()
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  guard(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\guard\\guardWideNarrow.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\guard.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, guard, Store, Event, Unit\} from 'effector'
			const typecheck = '\{global\}'
			
			describe('explicit generics', () => \{
			  test('guard<A>(\{source, clock, filter\})', () => \{
			    const source = createEvent<string | null>()
			    const clock = createEvent<number>()
			    const filter = createStore(true)
			    const withFilterStore: Event<string | null> = guard<string | null>(\{
			      source,
			      clock,
			      filter,
			    \})
			    const withFilterFn: Event<string | null> = guard<string | null>(\{
			      source,
			      clock,
			      filter: e => e !== null,
			    \})
			    const withFilterBoolean: Event<string> = guard<string | null>(\{
			      source,
			      clock,
			      filter: Boolean,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('guard<A>(\{source, filter\})', () => \{
			    const source = createEvent<string | null>()
			    const filter = createStore(true)
			    const withFilterStore: Event<string | null> = guard<string | null>(\{
			      source,
			      filter,
			    \})
			    const withFilterFn: Event<string | null> = guard<string | null>(\{
			      source,
			      filter: e => e !== null,
			    \})
			    const withFilterBoolean: Event<string> = guard<string | null>(\{
			      source,
			      filter: Boolean,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('guard<A>(\{clock, filter\})', () => \{
			    const clock = createEvent<string | null>()
			    const filter = createStore(true)
			    const withFilterStore: Event<string | null> = guard<string | null>(\{
			      clock,
			      filter,
			    \})
			    const withFilterFn: Event<string | null> = guard<string | null>(\{
			      clock,
			      filter: e => e !== null,
			    \})
			    const withFilterBoolean: Event<string> = guard<string | null>(\{
			      clock,
			      filter: Boolean,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('guard<A>(\{source, filter, target\})', () => \{
			    const source = createEvent<string | null>()
			    const filter = createStore(true)
			    const target = createEvent<string>()
			    const withFilterStore: Unit<string | null> = guard<string | null>(\{
			      source,
			      filter,
			      target,
			    \})
			    const withFilterFn: Unit<string | null> = guard<string | null>(\{
			      source,
			      filter: e => e !== null,
			      target,
			    \})
			    const withFilterBoolean: Unit<string> = guard<string | null>(\{
			      source,
			      filter: Boolean,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Target' is not assignable to type 'Unit<string | null>'.
			        Type 'Tuple<any>' is not assignable to type 'Unit<string | null>'.
			      Type 'Target' is not assignable to type 'Unit<string | null>'.
			        Type 'Tuple<any>' is not assignable to type 'Unit<string | null>'.
			      Type 'Target' is not assignable to type 'Unit<string>'.
			        Type 'Tuple<any>' is not assignable to type 'Unit<string>'.
			      "
			    \`)
			  \})
			  test('guard<Source, Result>(\{source, filter\})', () => \{
			    const source = createEvent<string | null>()
			    const clock = createEvent<string | null>()
			    const result1: Event<string> = guard<string | null, string>(\{
			      source,
			      clock,
			      filter: (e): e is string => e !== null,
			    \})
			    const result2: Event<string> = guard<string | null, string>(\{
			      source,
			      filter: (e): e is string => e !== null,
			    \})
			    const result3: Event<string> = guard<string | null, string>(\{
			      clock,
			      filter: (e): e is string => e !== null,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('guard<Source, Result>(\{source, filter, target\})', () => \{
			    const source = createEvent<string | null>()
			    const target = createEvent<string>()
			    const result: Unit<string> = guard<string | null, string>(\{
			      source,
			      filter: (e): e is string => e !== null,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Target' is not assignable to type 'Unit<string>'.
			        Type 'Tuple<any>' is not assignable to type 'Unit<string>'.
			      "
			    \`)
			  \})
			\})
			
			describe('guard(source, config)', () => \{
			  describe('guard(source, \{filter: store\})', () => \{
			    it('return new event (should pass)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow = createStore<boolean>(false)
			
			      const result: Event<number> = guard(trigger, \{filter: allow\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    it('support any unit (should pass)', () => \{
			      const trigger: Store<number[]> = createStore([1])
			      const allow = createStore<boolean>(false)
			
			      const result: Event<number[]> = guard(trigger, \{filter: allow\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('store is not boolean (should fail)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow: Store<string> = createStore('no')
			
			      //@ts-expect-error
			      guard(trigger, \{filter: allow\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Store<string>' is not assignable to type 'Store<boolean> | ((source: number) => boolean)'.
			              Type 'Store<string>' is not assignable to type 'Store<boolean>'.
			                The types returned by 'getState()' are incompatible between these types.
			                  Type 'string' is not assignable to type 'boolean'.
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow: Store<string> = createStore('no')
			
			      //@ts-expect-error
			      const result: Event<string> = guard(trigger, \{filter: allow\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Store<string>' is not assignable to type 'Store<boolean> | ((source: number) => boolean)'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        const trigger: Event<number> = createEvent()
			        const allow = createStore<boolean>(false)
			        const target: Store<number> = createStore(0)
			
			        guard(trigger, \{
			          filter: allow,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        const trigger: Event<number> = createEvent()
			        const allow = createStore<boolean>(false)
			        const target: Store<string> = createStore('no')
			
			        guard(trigger, \{
			          filter: allow,
			          //@ts-expect-error
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Store<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			          "
			        \`)
			      \})
			    \})
			  \})
			  describe('guard(source, \{filter: fn\})', () => \{
			    it('returns new event (should pass)', () => \{
			      const trigger: Event<number> = createEvent()
			      const result: Event<number> = guard(trigger, \{filter: n => n > 0\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow: Store<string> = createStore('no')
			
			      //@ts-expect-error
			      const result: Event<string> = guard(trigger, \{filter: x => x > 0\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<number>' is not assignable to type 'Event<string>'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        const trigger: Event<number> = createEvent()
			        const target: Store<number> = createStore(0)
			
			        guard(trigger, \{
			          filter: x => x > 0,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        const trigger: Event<number> = createEvent()
			        const target: Store<string> = createStore('no')
			
			        guard(trigger, \{
			          filter: x => x > 0,
			          //@ts-expect-error
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Store<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			          "
			        \`)
			      \})
			    \})
			  \})
			  describe('guard(source, \{filter: Boolean\})', () => \{
			    it('returns new event (should pass)', () => \{
			      type User = \{name: string\}
			      const trigger: Event<User | null> = createEvent()
			      const result: Event<User> = guard(trigger, \{filter: Boolean\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      type User = \{name: string\}
			      const trigger: Event<User | null> = createEvent()
			
			      //@ts-expect-error
			      const result: Event<string> = guard(trigger, \{filter: Boolean\})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<User>' is not assignable to type 'Event<string>'.
			          Types of property 'watch' are incompatible.
			            Type '(watcher: (payload: User) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
			              Types of parameters 'watcher' and 'watcher' are incompatible.
			                Types of parameters 'payload' and 'payload' are incompatible.
			                  Type 'User' is not assignable to type 'string'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        type User = \{name: string\}
			        const trigger: Event<User | null> = createEvent()
			        const target = createStore<User>(\{name: 'alice'\})
			
			        guard(trigger, \{
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        type User = \{name: string\}
			        const trigger: Event<User | null> = createEvent()
			        const target: Store<string> = createStore('no')
			
			        guard(trigger, \{
			          filter: Boolean,
			          //@ts-expect-error
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Store<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			          "
			        \`)
			      \})
			    \})
			  \})
			\})
			
			describe('guard(config)', () => \{
			  describe('guard(\{source, filter: store\})', () => \{
			    it('return new event (should pass)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow = createStore<boolean>(false)
			
			      const result: Event<number> = guard(\{
			        source: trigger,
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    it('support any unit (should pass)', () => \{
			      const trigger: Store<number[]> = createStore([1])
			      const allow = createStore<boolean>(false)
			
			      const result: Event<number[]> = guard(\{
			        source: trigger,
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('store is not boolean (should fail)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow: Store<string> = createStore('no')
			
			      guard(\{
			        source: trigger,
			        //@ts-expect-error
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Store<string>' is not assignable to type 'Store<boolean> | ((source: number) => boolean)'.
			              Type 'Store<string>' is not assignable to type 'Store<boolean>'.
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow: Store<string> = createStore('no')
			
			      guard(\{
			        source: trigger,
			        //@ts-expect-error
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          The last overload gave the following error.
			            Type 'Store<string>' is not assignable to type 'Store<boolean> | ((source: number) => boolean)'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        const trigger: Event<number> = createEvent()
			        const allow = createStore<boolean>(false)
			        const target: Store<number> = createStore(0)
			
			        guard(\{
			          source: trigger,
			          filter: allow,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        const trigger: Event<number> = createEvent()
			        const allow = createStore<boolean>(false)
			        const target: Store<string> = createStore('no')
			
			        guard(\{
			          source: trigger,
			          filter: allow,
			          //@ts-expect-error
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Store<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			          "
			        \`)
			      \})
			    \})
			  \})
			  describe('guard(\{source, filter: fn\})', () => \{
			    it('returns new event (should pass)', () => \{
			      const trigger: Event<number> = createEvent()
			      const result: Event<number> = guard(\{
			        source: trigger,
			        filter: n => n > 0,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      const trigger: Event<number> = createEvent()
			      const allow: Store<string> = createStore('no')
			
			      //@ts-expect-error
			      const result: Event<string> = guard(\{
			        source: trigger,
			        filter: n => n > 0,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<number>' is not assignable to type 'Event<string>'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        const trigger: Event<number> = createEvent()
			        const target: Store<number> = createStore(0)
			
			        guard(\{
			          source: trigger,
			          filter: x => x > 0,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        const trigger: Event<number> = createEvent()
			        const target: Store<string> = createStore('no')
			
			        guard(\{
			          source: trigger,
			          filter: x => x > 0,
			          //@ts-expect-error
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Store<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			          "
			        \`)
			      \})
			      describe('any to void', () => \{
			        test('with store (should pass)', () => \{
			          const filter = createStore(true)
			          const source = createEvent<string>()
			          const target = createEvent<void>()
			
			          guard(\{
			            source,
			            filter,
			            target,
			          \})
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			        test('with function (should pass)', () => \{
			          const source = createEvent<\{pass: boolean\}>()
			          const target = createEvent<void>()
			
			          guard(\{
			            source,
			            filter: (\{pass\}) => pass,
			            target,
			          \})
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			      \})
			    \})
			  \})
			  describe('guard(\{source, filter: Boolean\})', () => \{
			    it('returns new event (should pass)', () => \{
			      type User = \{name: string\}
			      const trigger: Event<User | null> = createEvent()
			      const result: Event<User> = guard(\{
			        source: trigger,
			        filter: Boolean,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      type User = \{name: string\}
			      const trigger: Event<User> = createEvent()
			
			      //@ts-expect-error
			      const result: Event<string> = guard(\{
			        source: trigger,
			        filter: Boolean,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<User>' is not assignable to type 'Event<string>'.
			          Types of property 'watch' are incompatible.
			            Type '(watcher: (payload: User) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
			              Types of parameters 'watcher' and 'watcher' are incompatible.
			                Types of parameters 'payload' and 'payload' are incompatible.
			                  Type 'User' is not assignable to type 'string'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        type User = \{name: string\}
			        const trigger: Event<User | null> = createEvent()
			        const target: Store<User> = createStore(\{name: 'alice'\})
			
			        guard(\{
			          source: trigger,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        type User = \{name: string\}
			        const trigger: Event<User> = createEvent()
			        const target: Store<string> = createStore('no')
			
			        guard(\{
			          source: trigger,
			          filter: Boolean,
			          //@ts-expect-error
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          No overload matches this call.
			            The last overload gave the following error.
			              Type 'Store<string>' is not assignable to type '\\\\"incompatible unit in target\\\\"'.
			          "
			        \`)
			      \})
			      test('any to void (should pass)', () => \{
			        const source = createEvent<\{pass: boolean\}>()
			        const target = createEvent<void>()
			
			        guard(\{
			          source,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			    \})
			  \})
			\})
			
			test('guard return type supports union types (should pass)', () => \{
			  const trigger: Event<\{a: 1\} | \{a: 2\}> = createEvent()
			  const allow = createStore<boolean>(false)
			
			  const result: Event<\{a: 1\} | \{a: 2\}> = guard(trigger, \{filter: allow\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\guard.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(38)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\index.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{step, createNode, createEvent, Event, launch, split\} from 'effector'
			
			const typecheck = '\{global\}'
			
			describe('createNode', () => \{
			  test('createNode(\{\})', () => \{
			    const foo = createNode(\{\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('createNode()', () => \{
			    const foo = createNode()
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('split', () => \{
			  describe('split infer result', () => \{
			    describe('split result no false-negative', () => \{
			      it('works with user-defined event', () => \{
			        const source: Event<string[]> = createEvent()
			        const \{
			          emptyList,
			          oneElement,
			          __: commonList,
			        \} = split(source, \{
			          emptyList: list => list.length === 0,
			          oneElement: list => list.length === 1,
			        \})
			        const split_result__nofneg__user_defined: Event<string[]> = emptyList
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      it('works with default event', () => \{
			        const source: Event<string[]> = createEvent()
			        const \{emptyList, oneElement, __\} = split(source, \{
			          emptyList: list => list.length === 0,
			          oneElement: list => list.length === 1,
			        \})
			        const split_result__nofneg__defaults: Event<string[]> = __
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			    \})
			    describe('split result no false-positive', () => \{
			      test('split result no false-positive user-defined', () => \{
			        const source: Event<string[]> = createEvent()
			        const \{emptyList, oneElement\} = split(source, \{
			          emptyList: list => list.length === 0,
			          oneElement: list => list.length === 1,
			        \})
			        //@ts-expect-error
			        const split_result__nofpos__user_defined_1: Event<number> = emptyList
			        //@ts-expect-error
			        const split_result__nofpos__user_defined_2: null = oneElement
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Type 'Event<string[]>' is not assignable to type 'Event<number>'.
			            Types of property 'watch' are incompatible.
			              Type '(watcher: (payload: string[]) => any) => Subscription' is not assignable to type '(watcher: (payload: number) => any) => Subscription'.
			                Types of parameters 'watcher' and 'watcher' are incompatible.
			                  Types of parameters 'payload' and 'payload' are incompatible.
			                    Type 'string[]' is not assignable to type 'number'.
			          Type 'Event<string[]>' is not assignable to type 'null'.
			          "
			        \`)
			      \})
			      test('split result no false-positive defaults 1', () => \{
			        const source: Event<string[]> = createEvent()
			        const \{__\} = split(source, \{
			          emptyList: list => list.length === 0,
			          oneElement: list => list.length === 1,
			        \})
			        //@ts-expect-error
			        const split_result__nofpos__defaults_1: Event<number> = __
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Type 'Event<string[]>' is not assignable to type 'Event<number>'.
			          "
			        \`)
			      \})
			      test('split result no false-positive defaults 2', () => \{
			        const source: Event<string[]> = createEvent()
			        const \{__\} = split(source, \{
			          emptyList: list => list.length === 0,
			          oneElement: list => list.length === 1,
			        \})
			        //@ts-expect-error
			        const split_result__nofpos__defaults_2: null = __
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Type 'Event<string[]>' is not assignable to type 'null'.
			          "
			        \`)
			      \})
			    \})
			  \})
			
			  test('split arguments no false-positive', () => \{
			    const source: Event<string[]> = createEvent()
			    split(source, \{
			      //@ts-expect-error
			      wrongResult: list => null,
			      //@ts-expect-error
			      wrongArg_1: (list: null) => true,
			      //@ts-expect-error
			      wrongArg_2: (list: number[]) => true,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'null' is not assignable to type 'boolean'.
			      Type '(list: null) => true' is not assignable to type '(payload: string[]) => boolean'.
			        Types of parameters 'list' and 'payload' are incompatible.
			          Type 'string[]' is not assignable to type 'null'.
			      Type '(list: number[]) => true' is not assignable to type '(payload: string[]) => boolean'.
			        Types of parameters 'list' and 'payload' are incompatible.
			          Type 'string[]' is not assignable to type 'number[]'.
			            Type 'string' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\launch.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{step, createNode, createEvent, Event, launch, split\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('launch(unit, payload)', () => \{
			  const foo = createEvent<number>()
			  const customNode = createNode(\{
			    scope: \{max: 100, lastValue: -1, add: 10\},
			    child: [foo],
			    node: [
			      step.compute(\{
			        fn: (arg, \{add\}) => arg + add,
			      \}),
			      step.filter(\{
			        fn: (arg, \{max, lastValue\}) => arg < max && arg !== lastValue,
			      \}),
			      step.compute(\{
			        fn(arg, scope) \{
			          scope.lastValue = arg
			          return arg
			        \},
			      \}),
			    ],
			  \})
			  //@ts-expect-error
			  launch(foo, '')
			  launch(foo, 0)
			  launch(customNode, 100)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type 'string' is not assignable to parameter of type 'number'.
			    "
			  \`)
			\})
			test('launch(\{target: unit\})', () => \{
			  const foo = createEvent<number>()
			  const customNode = createNode(\{
			    scope: \{max: 100, lastValue: -1, add: 10\},
			    child: [foo],
			    node: [
			      step.compute(\{
			        fn: (arg, \{add\}) => arg + add,
			      \}),
			      step.filter(\{
			        fn: (arg, \{max, lastValue\}) => arg < max && arg !== lastValue,
			      \}),
			      step.compute(\{
			        fn(arg, scope) \{
			          scope.lastValue = arg
			          return arg
			        \},
			      \}),
			    ],
			  \})
			  //@ts-expect-error
			  launch(\{target: foo, params: ''\})
			  launch(\{target: foo, params: 0\})
			  launch(\{target: customNode, params: 100\})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      Overload 1 of 3, '(config: \{ target: Node | Unit<number>; params: number; defer?: boolean | undefined; page?: any; scope?: Scope | undefined; meta?: Record<string, any> | undefined; \}): void', gave the following error.
			        Type 'string' is not assignable to type 'number'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\launch.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\restore.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{restore, createEvent, createEffect, createStore, Store\} from 'effector'
			
			const typecheck = '\{global\}'
			
			describe('restore cases (should pass)', () => \{
			  test('restore(Event<number>, number): Store<number>', () => \{
			    const ev = createEvent<number>()
			
			    let restored = restore(ev, 0)
			    let store: Store<number>
			
			    store = restored
			    restored = store
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('restore(Event<number>, null): Store<number|null>', () => \{
			    const ev = createEvent<number>()
			
			    let restored = restore(ev, null)
			    let store: Store<number | null>
			
			    store = restored
			    restored = store
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('restore(Effect<any,number,Error>, number): Store<number>', () => \{
			    const eff = createEffect<any, number, Error>()
			
			    let restored = restore(eff, 0)
			    let store: Store<number>
			
			    store = restored
			    restored = store
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('restore(Effect<any,number,Error>, null): Store<number|null>', () => \{
			    const eff = createEffect<any, number, Error>()
			
			    let restored = restore(eff, null)
			    let store: Store<number | null>
			
			    store = restored
			    restored = store
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('restore(Dictionary<?>): wraps each non-Store dictionary property into Store', () => \{
			    const dictionary = \{
			      n: 0,
			      s: '',
			      b: false,
			      l: createStore(''),
			    \}
			
			    let restored = restore(dictionary)
			
			    let shape: \{
			      n: Store<number>
			      s: Store<string>
			      b: Store<boolean>
			      l: Store<string>
			    \}
			
			    shape = restored
			    restored = shape
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('restore cases (should fail)', () => \{
			  test('restore(Event<number>, string)', () => \{
			    const ev = createEvent<number>()
			    //@ts-expect-error
			    restore(ev, 'initial')
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Argument of type 'string' is not assignable to parameter of type 'number'.
			      "
			    \`)
			  \})
			  test('restore(Effect<any,number,Error>, string)', () => \{
			    const eff = createEffect<any, number, Error>()
			    //@ts-expect-error
			    restore(eff, 'initial')
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        The last overload gave the following error.
			          Argument of type 'Effect<any, number, Error>' is not assignable to parameter of type 'Event<string>'.
			            Property 'thru' is missing in type 'Effect<any, number, Error>' but required in type 'Event<string>'.
			      "
			    \`)
			  \})
			  test('restore(Event<any>)', () => \{
			    try \{
			      const ev = createEvent<number>()
			
			      let restored = restore(ev)
			      let store: Store<number>
			
			      store = restored
			      //@ts-expect-error
			      restored = store
			    \} catch (e) \{\}
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<number>' is not assignable to type 'never'.
			      "
			    \`)
			  \})
			  test('restore(Effect<any,number,Error>)', () => \{
			    try \{
			      const eff = createEffect<any, number, Error>()
			
			      let restored = restore(eff)
			      let store: Store<number>
			
			      store = restored
			      //@ts-expect-error
			      restored = store
			    \} catch (e) \{\}
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'Store<number>' is not assignable to type 'never'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\restore.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sample\\arrayTarget.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  sample,
			  Store,
			  Event,
			  guard,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			/**
			 * Please note, that some tests may seem duplicating, having the same target sets but
			 * in different order. This is crucial for testing the correctness of conditional tuple
			 * iteration algorithms as they rely on order in some situations.
			 */
			describe('basic cases (should pass)', () => \{
			  test('\{ source: number, clock: any, target: [number] \} (should pass)', () => \{
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			
			    sample(\{source: num, clock: anyt, target: [num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [numberString, number] \} (should pass)', () => \{
			    const numberString = createEvent<number | string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			
			    sample(\{source: num, clock: anyt, target: [numberString, num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [void] \} (should pass)', () => \{
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    const voidt = createEvent<void>()
			
			    sample(\{source: num, clock: anyt, target: [voidt]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [number, void] \} (should pass)', () => \{
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    const voidt = createEvent<void>()
			
			    sample(\{source: num, clock: anyt, target: [num, voidt]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [void, number] \} (should pass)', () => \{
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    const voidt = createEvent<void>()
			
			    sample(\{source: num, clock: anyt, target: [voidt, num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('basic cases', () => \{
			  test('\{ source: number, clock: any, target: [] \} (?)', () => \{
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    sample(\{source: num, clock: anyt, target: []\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [string] \} (should fail)', () => \{
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<number>; clock: Event<any>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [number, string] \} (should fail)', () => \{
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [num, str]\})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [string, number] \} (should fail)', () => \{
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [str, num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [numberString, string] \} (should fail)', () => \{
			    const numberString = createEvent<number | string>()
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [numberString, str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [string, numberString] \} (should fail)', () => \{
			    const numberString = createEvent<number | string>()
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [str, numberString]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [number, stringBoolean] \} (should fail)', () => \{
			    const stringBoolean = createEvent<string | boolean>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [num, stringBoolean]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [stringBoolean, number] \} (should fail)', () => \{
			    const stringBoolean = createEvent<string | boolean>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [stringBoolean, num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [void, string] \} (should fail)', () => \{
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    const voidt = createEvent<void>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [voidt, str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<number>; clock: Event<any>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [string, void] \} (should fail)', () => \{
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    const voidt = createEvent<void>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [str, voidt]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<number>; clock: Event<any>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [any, string] \} (should fail)', () => \{
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [anyt, str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: any, target: [string, any] \} (should fail)', () => \{
			    const str = createEvent<string>()
			    const num = createEvent<number>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: num, clock: anyt, target: [str, anyt]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('source & clock mapping (should pass)', () => \{
			  test('\{ source: number, clock: number, fn: (s, c) => s + c, target: [number] \} (should pass)', () => \{
			    const num = createEvent<number>()
			
			    sample(\{
			      source: num,
			      clock: num,
			      fn: (s, c) => s + c,
			      target: [num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: number, clock: number, fn: (s, c) => s + c, target: [numberString, number] \} (should pass)', () => \{
			    const numberString = createEvent<number | string>()
			    const num = createEvent<number>()
			
			    sample(\{
			      source: num,
			      clock: num,
			      fn: (s, c) => s + c,
			      target: [numberString, num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('combinable source object (should pass)', () => \{
			  test('\{ source: \{ a: \$num \}, clock: any, target: [a_num] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const a_num = createEvent<\{a: number\}>()
			    const anyt = createEvent<any>()
			
			    sample(\{source: \{a: \$num\}, clock: anyt, target: [a_num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: \{ a: \$num, b: \$num \}, clock: any, target: [a_num] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const a_num = createEvent<\{a: number\}>()
			    const anyt = createEvent<any>()
			
			    sample(\{source: \{a: \$num, b: \$num\}, clock: anyt, target: [a_num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: \{ a: \$num, b: \$num \}, clock: any, target: [a_num_b_num] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const a_num_b_num = createEvent<\{a: number; b: number\}>()
			    const anyt = createEvent<any>()
			
			    sample(\{
			      source: \{a: \$num, b: \$num\},
			      clock: anyt,
			      target: [a_num_b_num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('combinable source object (should fail)', () => \{
			  test('\{ source: \{ a: \$num \}, clock: any, target: [a_str] \} (should fail)', () => \{
			    const \$num = createStore<number>(0)
			    const a_str = createEvent<\{a: string\}>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: \{a: \$num\}, clock: anyt, target: [a_str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>; target: Event<\{ a: string; \}>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: string; \}; \}[]; \}'.
			      "
			    \`)
			  \})
			
			  test('\{ source: \{ a: \$num \}, clock: any, target: [a_num, a_str] \} (should fail)', () => \{
			    const \$num = createStore<number>(0)
			    const a_str = createEvent<\{a: string\}>()
			    const a_num = createEvent<\{a: number\}>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: \{a: \$num\}, clock: anyt, target: [a_num, a_str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: \{ a: \$num \}, clock: any, target: [a_num_b_str] \} (should fail)', () => \{
			    const \$num = createStore<number>(0)
			    const a_num_b_str = createEvent<\{a: number; b: string\}>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: \{a: \$num\}, clock: anyt, target: [a_num_b_str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: \{ a: Store<number>; \}; clock: Event<any>; target: Event<\{ a: number; b: string; \}>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: number; b: string; \}; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: \{ a: number; b: string; \}; \}[]; \}'.
			      "
			    \`)
			  \})
			
			  test('\{ source: \{ a: \$num \}, clock: any, target: [a_num_b_num, a_num] \} (should fail)', () => \{
			    const \$num = createStore<number>(0)
			    const a_num_b_num = createEvent<\{a: number; b: number\}>()
			    const a_num = createEvent<\{a: number\}>()
			    const anyt = createEvent<any>()
			
			    //@ts-expect-error
			    sample(\{source: \{a: \$num\}, clock: anyt, target: [a_num_b_num, a_num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('combinable source object & clock mapping (should pass)', () => \{
			  test('\{ source: \{ a: \$num, b: \$num \}, clock: number, fn: (s, c) => s.a + s.b + c, target: [number] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const num = createEvent<number>()
			
			    sample(\{
			      source: \{a: \$num, b: \$num\},
			      clock: num,
			      fn: (s, c) => s.a + s.b + c,
			      target: [num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: \{ a: \$num, b: \$num \}, clock: number, fn: (s, c) => s.a + s.b + c, target: [numberString, number] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const numberString = createEvent<number | string>()
			    const num = createEvent<number>()
			
			    sample(\{
			      source: \{a: \$num, b: \$num\},
			      clock: num,
			      fn: (s, c) => s.a + s.b + c,
			      target: [numberString, num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('combinable source list (should pass)', () => \{
			  test('\{ source: [\$num], clock: any, target: [l_num] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const l_num = createEvent<[number]>()
			    const anyt = createEvent<any>()
			
			    sample(\{source: [\$num], clock: anyt, target: [l_num]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			      "
			    \`)
			  \})
			
			  test('\{ source: [\$num, \$num], clock: any, target: [l_num_num] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const l_num_num = createEvent<[number, number]>()
			    const anyt = createEvent<any>()
			
			    sample(\{
			      source: [\$num, \$num],
			      clock: anyt,
			      target: [l_num_num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			      "
			    \`)
			  \})
			\})
			
			describe('combinable source list (should fail)', () => \{
			  test('\{ source: [\$num], clock: any, target: [l_str] \} (should fail)', () => \{
			    const \$num = createStore<number>(0)
			    const l_str = createEvent<[string]>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: [\$num], clock: anyt, target: [l_str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			      "
			    \`)
			  \})
			
			  test('\{ source: [\$num], clock: any, target: [l_num, l_str] \} (should fail)', () => \{
			    const \$num = createStore<number>(0)
			    const l_str = createEvent<[string]>()
			    const l_num = createEvent<[number]>()
			    const anyt = createEvent<any>()
			    //@ts-expect-error
			    sample(\{source: [\$num], clock: anyt, target: [l_num, l_str]\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<number>[]; clock: Event<any>; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			      "
			    \`)
			  \})
			\})
			
			describe('combinable source list & clock mapping (should pass)', () => \{
			  test('\{ source: [\$num, \$num], clock: number, fn: ([a, b], c) => a + b + c, target: [number] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const num = createEvent<number>()
			
			    sample(\{
			      source: [\$num, \$num],
			      clock: num,
			      fn: ([a, b], c) => a + b + c,
			      target: [num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('\{ source: [\$num, \$num], clock: number, fn: ([a, b], c) => a + b + c, target: [numberString, number] \} (should pass)', () => \{
			    const \$num = createStore<number>(0)
			    const numberString = createEvent<number | string>()
			    const num = createEvent<number>()
			
			    sample(\{
			      source: [\$num, \$num],
			      clock: num,
			      fn: ([a, b], c) => a + b + c,
			      target: [numberString, num],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sample\\arrayTarget.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(34)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sample\\clockArray.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample, Event\} from 'effector'
			
			const typecheck = '\{global\}'
			
			describe('with target', () => \{
			  it('without fn (should pass)', () => \{
			    const target = createEvent<\{a: string; b: string\}>()
			    const source = createStore(\{a: '', b: ''\})
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    sample(\{
			      source,
			      clock: [clockA, clockB, clockC],
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('without fn with combinable source (should pass)', () => \{
			    const target = createEvent<\{a: string; b: string\}>()
			    const a = createStore('')
			    const b = createStore('')
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    sample(\{
			      source: \{a, b\},
			      clock: [clockA, clockB, clockC],
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('with fn (should pass)', () => \{
			    const target = createEvent<\{a: string; b: string; clock: any\}>()
			    const source = createStore(\{a: '', b: ''\})
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    sample(\{
			      source,
			      clock: [clockA, clockB, clockC],
			      fn: (\{a, b\}, clock) => (\{a, b, clock\}),
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  describe('with fn and combinable source (should pass)', () => \{
			    describe('with explicitly typed arguments', () => \{
			      describe('with second argument in fn', () => \{
			        test('with unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string; clock: any\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockB = createEvent<any>()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockB, clockC],
			            fn: (\{a, b\}: \{a: string; b: string\}, clock: any) => (\{a, b, clock\}),
			            target,
			          \})
			
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			
			        test('without unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string; clock: any\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockC],
			            fn: (\{a, b\}: \{a: string; b: string\}, clock: any) => (\{a, b, clock\}),
			            target,
			          \})
			
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			      \})
			
			      describe('without second argument in fn', () => \{
			        test('with unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockB = createEvent<any>()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockB, clockC],
			            fn: (\{a, b\}: \{a: string; b: string\}) => (\{a, b\}),
			            target,
			          \})
			
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			
			        test('without unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockC],
			            fn: (\{a, b\}: \{a: string; b: string\}) => (\{a, b\}),
			            target,
			          \})
			
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			      \})
			    \})
			
			    describe('with implicitly typed arguments', () => \{
			      describe('with second argument in fn', () => \{
			        test('with unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string; clock: any\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockB = createEvent<any>()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockB, clockC],
			            fn: (\{a, b\}, clock) => (\{a, b, clock\}),
			            target,
			          \})
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			
			        test('without unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string; clock: any\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockC],
			            fn: (\{a, b\}, clock) => (\{a, b, clock\}),
			            target,
			          \})
			
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			      \})
			
			      describe('without second argument in fn', () => \{
			        test('with unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockB = createEvent<any>()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockB, clockC],
			            fn: (\{a, b\}) => (\{a, b\}),
			            target,
			          \})
			
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			
			        test('without unification to any (should pass)', () => \{
			          const target = createEvent<\{a: string; b: string\}>()
			          const a = createStore('')
			          const b = createStore('')
			          const clockA = createEvent()
			          const clockC = createEvent<string>()
			
			          sample(\{
			            source: \{a, b\},
			            clock: [clockA, clockC],
			            fn: (\{a, b\}) => (\{a, b\}),
			            target,
			          \})
			
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			      \})
			    \})
			  \})
			
			  test('detect incorrect arguments in fn with combinable source (should fail)', () => \{
			    const target = createEvent<\{a: string; clock: any\}>()
			    const a = createStore('')
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    sample(\{
			      source: \{a\},
			      clock: [clockA, clockB, clockC],
			      //@ts-expect-error
			      fn: (\{a\}: \{a: number\}, clock: any) => (\{a, clock\}),
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(\{ a \}: \{ a: number; \}, clock: any) => \{ a: number; clock: any; \}' is not assignable to type '((src: \{ a: string; \}, clk: any) => any) & ((\{ a \}: \{ a: number; \}, clock: any) => \{ a: number; clock: any; \})'.
			        Type '(\{ a \}: \{ a: number; \}, clock: any) => \{ a: number; clock: any; \}' is not assignable to type '(src: \{ a: string; \}, clk: any) => any'.
			          Types of parameters '__0' and 'src' are incompatible.
			            Type '\{ a: string; \}' is not assignable to type '\{ a: number; \}'.
			              Types of property 'a' are incompatible.
			                Type 'string' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			
			  test('detect too wide type of clocks (should fail)', () => \{
			    const target = createEvent<\{a: string; b: string; clock: string\}>()
			    const source = createStore(\{a: '', b: ''\})
			    const clockA = createEvent()
			    const clockC = createEvent<string>()
			
			    sample(\{
			      source,
			      clock: [clockA, clockC],
			      //@ts-expect-error
			      fn: (\{a, b\}: any, clock: string) => (\{a, b, clock\}),
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(\{ a, b \}: any, clock: string) => \{ a: any; b: any; clock: string; \}' is not assignable to type '((src: \{ a: string; b: string; \}, clk: string | void) => any) & ((\{ a, b \}: any, clock: string) => \{ a: any; b: any; clock: string; \})'.
			        Type '(\{ a, b \}: any, clock: string) => \{ a: any; b: any; clock: string; \}' is not assignable to type '(src: \{ a: string; b: string; \}, clk: string | void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'string | void' is not assignable to type 'string'.
			              Type 'void' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			\})
			
			describe('without target', () => \{
			  it('without fn (should pass)', () => \{
			    const source = createStore(\{a: '', b: ''\})
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    const target: Event<\{a: string; b: string\}> = sample(\{
			      source,
			      clock: [clockA, clockB, clockC],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('without fn with combinable source (should pass)', () => \{
			    const a = createStore('')
			    const b = createStore('')
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    const target: Event<\{a: string; b: string\}> = sample(\{
			      source: \{a, b\},
			      clock: [clockA, clockB, clockC],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('with fn (should pass)', () => \{
			    const source = createStore(\{a: '', b: ''\})
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    const target1 = sample(\{
			      source,
			      clock: [clockA, clockB, clockC],
			      fn: (\{a, b\}, clock) => (\{a, b, clock\}),
			    \})
			    const target2: Event<\{a: string; b: string; clock: any\}> = sample(\{
			      source,
			      clock: [clockA, clockB, clockC],
			      fn: (\{a, b\}, clock) => (\{a, b, clock\}),
			    \})
			    const target3: Event<\{a: string; b: string; clock: any\}> = sample(\{
			      source,
			      clock: [clockA, clockB, clockC],
			      fn: (\{a, b\}: \{a: string; b: string\}, clock: any) => (\{a, b, clock\}),
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('with fn and combinable source (should pass)', () => \{
			    const a = createStore('')
			    const b = createStore('')
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    const target1 = sample(\{
			      source: \{a, b\},
			      clock: [clockA, clockB, clockC],
			      fn: (\{a, b\}, clock) => (\{a, b, clock\}),
			    \})
			    const target2: Event<\{a: string; b: string; clock: any\}> = sample(\{
			      source: \{a, b\},
			      clock: [clockA, clockB, clockC],
			      fn: (\{a, b\}, clock) => (\{a, b, clock\}),
			    \})
			    const target3: Event<\{a: string; b: string; clock: any\}> = sample(\{
			      source: \{a, b\},
			      clock: [clockA, clockB, clockC],
			      fn: (\{a, b\}: \{a: string; b: string\}, clock: any) => (\{a, b, clock\}),
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  it('should detect incorrect arguments in fn with combinable source (should fail)', () => \{
			    const a = createStore('')
			    const clockA = createEvent()
			    const clockB = createEvent<any>()
			    const clockC = createEvent<string>()
			
			    const target: Event<\{a: string; clock: any\}> = sample(\{
			      source: \{a\},
			      clock: [clockA, clockB, clockC],
			      //@ts-expect-error
			      fn: (\{a\}: \{a: number\}, clock: any) => (\{a, clock\}),
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(\{ a \}: \{ a: number; \}, clock: any) => \{ a: number; clock: any; \}' is not assignable to type '((src: \{ a: string; \}, clk: any) => any) & ((\{ a \}: \{ a: number; \}, clock: any) => \{ a: number; clock: any; \})'.
			        Type '(\{ a \}: \{ a: number; \}, clock: any) => \{ a: number; clock: any; \}' is not assignable to type '(src: \{ a: string; \}, clk: any) => any'.
			          Types of parameters '__0' and 'src' are incompatible.
			            Type '\{ a: string; \}' is not assignable to type '\{ a: number; \}'.
			              Types of property 'a' are incompatible.
			                Type 'string' is not assignable to type 'number'.
			      "
			    \`)
			  \})
			
			  it('should detect too wide type of clocks (should fail)', () => \{
			    const source = createStore(\{a: '', b: ''\})
			    const clockA = createEvent()
			    const clockC = createEvent<string>()
			
			    const target: Event<\{a: string; b: string; clock: string\}> = sample(\{
			      source,
			      clock: [clockA, clockC],
			      //@ts-expect-error
			      fn: (\{a, b\}: any, clock: string) => (\{a, b, clock\}),
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(\{ a, b \}: any, clock: string) => \{ a: any; b: any; clock: string; \}' is not assignable to type '((src: \{ a: string; b: string; \}, clk: string | void) => any) & ((\{ a, b \}: any, clock: string) => \{ a: any; b: any; clock: string; \})'.
			        Type '(\{ a, b \}: any, clock: string) => \{ a: any; b: any; clock: string; \}' is not assignable to type '(src: \{ a: string; b: string; \}, clk: string | void) => any'.
			          Types of parameters 'clock' and 'clk' are incompatible.
			            Type 'string | void' is not assignable to type 'string'.
			              Type 'void' is not assignable to type 'string'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sample\\clockArray.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(19)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sample\\implicitCombine.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  sample,
			  Store,
			  Event,
			  guard,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			it('supports store objects as a source (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample(\{
			    source: \{a, b\},
			    clock,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			it('supports a list of stores as a source (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample(\{
			    source: [a, b],
			    clock,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			it('supports store objects as a source + mapping (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample(\{
			    source: \{a, b\},
			    clock,
			    fn: (\{a, b\}, clock) => a.toString() + b + clock.toString(),
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			it('supports a list of stores as a source + mapping (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample(\{
			    source: [a, b],
			    clock,
			    fn: ([a, b], clock) => a.toString() + b + clock.toString(),
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			it('supports store objects as a source + target forwarding (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			  const target = createEvent<\{a: number; b: string\}>()
			
			  const result = sample(\{
			    source: \{a, b\},
			    clock,
			    target,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			it('supports a list of stores as a source + target forwarding (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			  const target = createEvent<[number, string]>()
			
			  const result = sample(\{
			    source: [a, b],
			    clock,
			    target,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number, string]>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}; \}'.
			    "
			  \`)
			\})
			
			it('supports store objects as a source + mapping + target forwarding (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			  const target = createEvent<string>()
			
			  const result = sample(\{
			    source: \{a, b\},
			    clock,
			    fn: (\{a, b\}, clock) => a.toString() + b + clock.toString(),
			    target,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			it('supports a list of stores as a source + mapping + target forwarding (should pass)', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			  const target = createEvent<string>()
			
			  const result = sample(\{
			    source: [a, b],
			    clock,
			    fn: ([a, b], clock) => a.toString() + b + clock.toString(),
			    target,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			it('supports store objects as a source (should pass) [non-config sample overload]', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample(\{a, b\}, clock)
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 2.
			    "
			  \`)
			\})
			
			it('supports a list of stores as a source (should pass) [non-config sample overload]', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample([a, b], clock)
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 2.
			    "
			  \`)
			\})
			
			it('supports store objects as a source + mapping (should pass) [non-config sample overload]', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample(
			    \{a, b\},
			    clock,
			    (\{a, b\}, clock) => a.toString() + b + clock.toString(),
			  )
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 3.
			    Binding element 'a' implicitly has an 'any' type.
			    Binding element 'b' implicitly has an 'any' type.
			    Parameter 'clock' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			it('supports a list of stores as a source + mapping (should pass) [non-config sample overload]', () => \{
			  const a = createStore(1)
			  const b = createStore('b')
			  const clock = createEvent<number>()
			
			  const result = sample(
			    [a, b],
			    clock,
			    ([a, b], clock) => a.toString() + b + clock.toString(),
			  )
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 3.
			    Binding element 'a' implicitly has an 'any' type.
			    Binding element 'b' implicitly has an 'any' type.
			    Parameter 'clock' implicitly has an 'any' type.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sample\\implicitCombine.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sample\\sample.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  sample,
			  Store,
			  Event,
			  guard,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			describe('explicit generics', () => \{
			  test('sample<A, B, R>(\{source, clock, fn, target\})', () => \{
			    const source = createEvent<string>()
			    const clock = createEvent<number>()
			    const target = createEvent<number>()
			    //@ts-expect-error
			    sample<string, number, number>(\{
			      source,
			      clock,
			      //@ts-expect-error
			      fn: str => str.length,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Expected 19 type arguments, but got 3.
			      Parameter 'str' implicitly has an 'any' type.
			      "
			    \`)
			  \})
			  test('sample<A, B>(\{source, fn, target\})', () => \{
			    const source = createEvent<string>()
			    const target = createEvent<number>()
			    //@ts-expect-error
			    sample<string, number>(\{
			      source,
			      //@ts-expect-error
			      fn: str => str.length,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Expected 19 type arguments, but got 2.
			      Parameter 'str' implicitly has an 'any' type.
			      "
			    \`)
			  \})
			  test('sample<A>(\{source, clock, target\})', () => \{
			    const source = createEvent<string>()
			    const clock = createEvent<number>()
			    const target = createEvent<string>()
			    //@ts-expect-error
			    sample<string>(\{
			      source,
			      clock,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Expected 19 type arguments, but got 1.
			      "
			    \`)
			  \})
			  test('sample<A>(\{source, target\})', () => \{
			    const source = createEvent<string>()
			    const target = createEvent<string>()
			    //@ts-expect-error
			    sample<string>(\{
			      source,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Expected 19 type arguments, but got 1.
			      "
			    \`)
			  \})
			  test('sample<A, B, R>(\{source, clock, fn\})', () => \{
			    const source = createEvent<string>()
			    const clock = createEvent<number>()
			    //@ts-expect-error
			    const result: Event<number> = sample<string, number, number>(\{
			      source,
			      clock,
			      //@ts-expect-error
			      fn: (str, num) => str.length + num,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type 'string' is not assignable to type 'Event<number>'.
			      Expected 19 type arguments, but got 3.
			      Parameter 'str' implicitly has an 'any' type.
			      Parameter 'num' implicitly has an 'any' type.
			      "
			    \`)
			  \})
			  test('sample<A>(\{source: store, clock\})', () => \{
			    const source = createStore('')
			    const clock = createEvent<number>()
			    //@ts-expect-error
			    sample<string>(\{
			      source,
			      clock,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Expected 19 type arguments, but got 1.
			      "
			    \`)
			  \})
			  test('sample<A>(\{source: event, clock\})', () => \{
			    const source = createEvent<string>()
			    const clock = createEvent<number>()
			    //@ts-expect-error
			    sample<string>(\{
			      source,
			      clock,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Expected 19 type arguments, but got 1.
			      "
			    \`)
			  \})
			\})
			
			describe('generic edge cases', () => \{
			  test('generic edge cases (should pass)', () => \{
			    function generic1<A, B>(target: Store<A>, clock: Event<B>) \{
			      \{
			        sample(\{
			          source: target,
			          clock,
			          target,
			        \})
			        const result = sample(\{
			          source: target,
			          clock,
			        \})
			      \}
			      \{
			        const result: Store<A> = sample(\{
			          source: target,
			          clock,
			          fn: (source, clock) => source,
			          target,
			        \})
			      \}
			      \{
			        const result: Event<B> = sample(\{
			          source: target,
			          clock,
			          fn: (source, clock) => clock,
			          target: clock,
			        \})
			      \}
			      \{
			        sample(\{
			          clock,
			          source: target,
			          filter: Boolean,
			          target,
			        \})
			        const result = sample(\{
			          clock,
			          source: target,
			          filter: Boolean,
			        \})
			      \}
			      \{
			        sample(\{
			          clock,
			          source: target,
			          filter: Boolean,
			          fn: (source, clock) => source,
			          target,
			        \})
			        const result = sample(\{
			          clock,
			          source: target,
			          filter: Boolean,
			          fn: (source, clock) => source,
			        \})
			      \}
			      \{
			        sample(\{
			          clock,
			          source: target,
			          filter: (source, clock) => true,
			          fn: (source, clock) => source,
			          target,
			        \})
			        const result = sample(\{
			          clock,
			          source: target,
			          filter: (source, clock) => true,
			          fn: (source, clock) => source,
			        \})
			      \}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('generic edge cases (should fail)', () => \{
			    function generic1<A, B>(target: Store<A>, clock: Event<B>) \{
			      \{
			        //@ts-expect-error
			        sample(\{
			          source: target,
			          clock,
			          target: clock,
			        \})
			      \}
			      \{
			        //@ts-expect-error
			        sample(\{
			          source: target,
			          clock,
			          fn: (source, clock) => source,
			          target: clock,
			        \})
			      \}
			      \{
			        //@ts-expect-error
			        sample(\{
			          source: target,
			          clock,
			          fn: (source, clock) => clock,
			          target,
			        \})
			      \}
			      \{
			        //@ts-expect-error
			        const result = sample(\{
			          clock,
			          source: target,
			          filter: Boolean,
			          target: clock,
			        \})
			      \}
			      \{
			        //@ts-expect-error
			        const result = sample(\{
			          clock,
			          source: target,
			          filter: Boolean,
			          fn: (source, clock) => clock,
			          target,
			        \})
			      \}
			      \{
			        //@ts-expect-error
			        const result = sample(\{
			          clock,
			          source: target,
			          filter: (source, clock) => true,
			          fn: (source, clock) => clock,
			          target,
			        \})
			      \}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '[\{ source: Store<A>; clock: Event<B>; target: Event<B>; \}]' is not assignable to parameter of type 'TargetOrError<A, \\\\"src\\\\", Event<B>, \{ clock: Event<B>; source: Store<A>; filter?: undefined; target: Event<B>; greedy?: boolean | undefined; \} & \{ source: Store<...>; clock: Event<...>; target: Event<...>; \}>'.
			      Argument of type '[\{ source: Store<A>; clock: Event<B>; fn: (source: A, clock: B) => A; target: Event<B>; \}]' is not assignable to parameter of type 'TargetOrError<A, \\\\"fnRet\\\\", Event<B>, \{ clock: Event<B>; source: Store<A>; filter?: undefined; fn: (source: A, clock: B) => A; target: Event<B>; greedy?: boolean | undefined; \} & \{ ...; \}>'.
			      Argument of type '[\{ source: Store<A>; clock: Event<B>; fn: (source: A, clock: B) => B; target: Store<A>; \}]' is not assignable to parameter of type 'TargetOrError<B, \\\\"fnRet\\\\", Store<A>, \{ clock: Event<B>; source: Store<A>; filter?: undefined; fn: (source: A, clock: B) => B; target: Store<A>; greedy?: boolean | undefined; \} & \{ ...; \}>'.
			      Argument of type '[\{ clock: Event<B>; source: Store<A>; filter: BooleanConstructor; target: Event<B>; \}]' is not assignable to parameter of type 'TargetOrError<NonFalsy<A>, \\\\"src\\\\", Event<B>, \{ clock: Event<B>; source: Store<A>; filter: BooleanConstructor; target: Event<B>; greedy?: boolean | undefined; \} & \{ ...; \}>'.
			      Argument of type '[\{ clock: Event<B>; source: Store<A>; filter: BooleanConstructor; fn: (source: NonFalsy<A>, clock: B) => B; target: Store<A>; \}]' is not assignable to parameter of type 'TargetOrError<B, \\\\"fnRet\\\\", Store<A>, \{ clock: Event<B>; source: Store<A>; filter?: BooleanConstructor | undefined; fn?: ((source: NonFalsy<A>, clock: B) => B) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}>'.
			      Argument of type '[\{ clock: Event<B>; source: Store<A>; filter: (source: A, clock: B) => true; fn: (source: A, clock: B) => B; target: Store<A>; \}]' is not assignable to parameter of type 'TargetOrError<B, \\\\"fnRet\\\\", Store<A>, \{ clock: Event<B>; source: Store<A>; filter?: ((source: A, clock: B) => true) | undefined; fn?: ((source: A, clock: B) => B) | undefined; target: Store<...>; greedy?: boolean | undefined; \} & \{ ...; \}>'.
			      "
			    \`)
			  \})
			\})
			
			test('event by event', () => \{
			  const a = createEvent<number>()
			  const b = createEvent<boolean>()
			  const c = sample(a, b)
			
			  const sample_ee_check1: Event<number> = c
			  //@ts-expect-error
			  const sample_ee_check2: Event<string> = c
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 2.
			    "
			  \`)
			\})
			test('event by event with handler', () => \{
			  const a = createEvent<string>()
			  const b = createEvent<boolean>()
			  const c = sample(a, b, (a, b) => (\{a, b\}))
			
			  const sample_eeh_check1: Event<\{a: string; b: boolean\}> = c
			  //@ts-expect-error
			  const sample_eeh_check2: Event<string> = c
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 3.
			    Parameter 'a' implicitly has an 'any' type.
			    Parameter 'b' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			test('store by event', () => \{
			  const d = createStore(0)
			  const b = createEvent<boolean>()
			  const e = sample(d, b)
			
			  const sample_se_check1: Event<number> = e
			  //@ts-expect-error
			  const sample_se_check2: Event<string> = e
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 2.
			    "
			  \`)
			\})
			test('store by event with handler', () => \{
			  const d = createStore('')
			  const b = createEvent<boolean>()
			  const e = sample(d, b, (a, b) => (\{a, b\}))
			
			  const sample_seh_check1: Event<\{a: string; b: boolean\}> = e
			  //@ts-expect-error
			  const sample_seh_check2: Event<string> = e
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 3.
			    Parameter 'a' implicitly has an 'any' type.
			    Parameter 'b' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			test('effect by event', () => \{
			  const f = createEffect<string, any, any>()
			  const b = createEvent<boolean>()
			  const g = sample(f, b)
			
			  const sample_efe_check1: Event<string> = g
			  //@ts-expect-error
			  const sample_efe_check2: Event<number> = g
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 2.
			    "
			  \`)
			\})
			test('effect by event with handler', () => \{
			  const f = createEffect<string, any, any>()
			  const b = createEvent<boolean>()
			  const g = sample(f, b, (a, b) => (\{a, b\}))
			
			  const sample_efeh_check1: Event<\{a: string; b: boolean\}> = g
			  //@ts-expect-error
			  const sample_efeh_check2: Event<number> = g
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 3.
			    Parameter 'a' implicitly has an 'any' type.
			    Parameter 'b' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			test('store by store', () => \{
			  const a = createStore(false)
			  const b = createStore(0)
			  const c = sample(a, b)
			
			  const sample_ss_check1: Store<boolean> = c
			  //@ts-expect-error
			  const sample_ss_check2: Store<string> = c
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 2.
			    "
			  \`)
			\})
			test('store by store with handler', () => \{
			  const a = createStore('')
			  const b = createStore(true)
			  const c = sample(a, b, (a, b) => (\{a, b\}))
			
			  const sample_ssh_check1: Store<\{a: string; b: boolean\}> = c
			  //@ts-expect-error
			  const sample_ssh_check2: Store<string> = c
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 1 arguments, but got 3.
			    Parameter 'a' implicitly has an 'any' type.
			    Parameter 'b' implicitly has an 'any' type.
			    "
			  \`)
			\})
			describe('sample(Store<T>):Store<T>', () => \{
			  test('correct case (should pass)', () => \{
			    const a = createStore('')
			    const sample_s_correct: Store<string> = sample(a)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type 'Store<string>' is not assignable to parameter of type '\{ error: \\\\"either target, clock or source should exists\\\\"; \}'.
			        Property 'error' is missing in type 'Store<string>' but required in type '\{ error: \\\\"either target, clock or source should exists\\\\"; \}'.
			      "
			    \`)
			  \})
			  test('incorrect case (should fail)', () => \{
			    const a = createStore('')
			    //@ts-expect-error
			    const sample_s_incorrect: Store<number> = sample(a)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type 'Store<string>' is not assignable to parameter of type '\{ error: \\\\"either target, clock or source should exists\\\\"; \}'.
			      "
			    \`)
			  \})
			  describe('edge case', () => \{
			    test('correct case (should pass)', () => \{
			      const a = createStore('')
			      const clock = createEvent()
			      const sample_s_edge_correct: Event<string> = sample(a, clock)
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Expected 1 arguments, but got 2.
			        "
			      \`)
			    \})
			    test('incorrect case (should fail)', () => \{
			      const a = createStore('')
			      const clock = createEvent()
			      //@ts-expect-error
			      const sample_s_edge_incorrect: Event<number> = sample(a, clock)
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Expected 1 arguments, but got 2.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('sample + guard (should pass)', () => \{
			  test("directly assign \`guard\` invocation to \`sample\`'s \`clock\` argument without losing inference in \`sample\`'s \`fn\` (should pass)", () => \{
			    const source = createStore(0)
			    const clock = createEvent<number>()
			
			    sample(\{
			      source,
			      clock: guard(clock, \{
			        filter: clock => clock > 0,
			      \}),
			      fn: (source, clock) => source + clock,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test("directly assign \`sample\` invocation to \`guard\`'s \`source\` argument without losing inference in \`guard\`'s \`filter\` (should pass)", () => \{
			    const source = createStore(0)
			    const clock = createEvent<number>()
			
			    guard(\{
			      source: sample(\{
			        source,
			        clock,
			        fn: (source, clock) => source + clock,
			      \}),
			      filter: n => n > 0,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('edge case (should pass)', () => \{
			    function debounce<T>(event: Event<T>): Event<T> \{
			      return event
			    \}
			    const \$store = createStore(0)
			    const \$flag = createStore(false)
			    const trigger = createEvent<number>()
			    const target = createEffect<\{field: number; data: number\}, void>()
			
			    guard(\{
			      source: sample(\{
			        clock: debounce(trigger),
			        source: [\$flag, \$store],
			        fn: ([isAble, field], data) => (isAble ? \{field, data\} : null),
			      \}),
			      filter: (e): e is \{field: number; data: number\} => !!e,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '((src: (number | boolean)[], clk: number) => any) & (([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null)'.
			        Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '(src: (number | boolean)[], clk: number) => any'.
			          Types of parameters '__0' and 'src' are incompatible.
			            Type '(number | boolean)[]' is not assignable to type '[any, any]'.
			              Target requires 2 element(s) but source may have fewer.
			      Binding element 'isAble' implicitly has an 'any' type.
			      Binding element 'field' implicitly has an 'any' type.
			      Parameter 'data' implicitly has an 'any' type.
			      "
			    \`)
			  \})
			\})
			describe('without clock', () => \{
			  test('with fn (should pass)', () => \{
			    const source = createStore([\{foo: 'ok', bar: 0\}])
			    const target = createStore(\{foo: '...', bar: 1\})
			
			    sample(\{
			      source,
			      target,
			      fn: ([obj]) => obj,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('with fn [combinable] (should pass)', () => \{
			    const foo = createStore('ok')
			    const bar = createStore(0)
			    const target = createStore(\{foo: '...', bar: 1\})
			
			    sample(\{
			      source: \{foo, bar\},
			      target,
			      fn: (\{foo, bar\}) => (\{foo, bar\}),
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			
			  test('without fn (should pass)', () => \{
			    const source = createEvent()
			    const fx = createEffect<void, void, any>()
			
			    sample(\{
			      source,
			      target: fx,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('without fn [combinable] (should pass)', () => \{
			    const foo = createStore('ok')
			    const bar = createStore(0)
			    const target = createStore(\{foo: '...', bar: 1\})
			
			    sample(\{
			      source: \{foo, bar\},
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('without fn, any to void (should pass)', () => \{
			    const source = createEvent<string>()
			    const target = createEvent<void>()
			    sample(\{
			      source,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('clock without source', () => \{
			  test('with fn (should pass)', () => \{
			    const clock = createStore([\{foo: 'ok', bar: 0\}])
			    const target = createStore(\{foo: '...', bar: 1\})
			    sample(\{
			      clock,
			      target,
			      fn: ([obj]) => obj,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('with fn [clock array] (should pass)', () => \{
			    const clock = createStore(\{foo: 'ok', bar: 0\})
			    const target = createStore(\{foo: '...', bar: 1\})
			    sample(\{
			      clock: [clock],
			      target,
			      fn: foo => foo,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('without fn (should pass)', () => \{
			    const clock = createEvent<number>()
			    const fx = createEffect<number, void, any>()
			    sample(\{
			      clock,
			      target: fx,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('without fn [void] (should pass)', () => \{
			    const clock = createEvent()
			    const fx = createEffect<void, void, any>()
			    sample(\{
			      clock,
			      target: fx,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('without fn [clock array] (should pass)', () => \{
			    const foo = createStore('ok')
			    const bar = createStore(0)
			    const target = createEvent<string | number>()
			    sample(\{
			      clock: [foo, bar],
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('without fn, any to void (should pass)', () => \{
			    const clock = createEvent<string>()
			    const target = createEvent<void>()
			    sample(\{
			      clock,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('with fn (should fail)', () => \{
			    const foo = createStore('ok')
			    const target = createStore(1)
			    sample(\{
			      //@ts-expect-error
			      clock: foo,
			      fn: foo => foo,
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ clock: Store<string>; fn: (foo: string) => string; target: Store<number>; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}; \}'.
			        Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: string; targetType: number; \}; \}'.
			      "
			    \`)
			  \})
			  test('with fn [clock array] (should fail)', () => \{
			    const foo = createStore(0)
			    const bar = createStore(1)
			    const target = createStore(2)
			
			    sample(\{
			      //@ts-expect-error
			      clock: [foo, bar],
			      fn: foo => true,
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ clock: Store<number>[]; fn: (foo: number) => boolean; target: Store<number>; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: boolean; targetType: number; \}; \}'.
			        Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: boolean; targetType: number; \}; \}'.
			      "
			    \`)
			  \})
			  test('without fn (should fail)', () => \{
			    const foo = createStore('ok')
			    const target = createStore(1)
			
			    sample(\{
			      //@ts-expect-error
			      clock: foo,
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ clock: Store<string>; target: Store<number>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string; targetType: number; \}; \}'.
			        Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string; targetType: number; \}; \}'.
			      "
			    \`)
			  \})
			
			  test('without fn [clock array] (should fail)', () => \{
			    const foo = createStore('ok')
			    const bar = createStore(0)
			    const baz = createStore(true)
			    const target = createStore(1)
			
			    sample(\{
			      //@ts-expect-error
			      clock: [foo, bar, baz],
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ clock: (Store<boolean> | Store<number> | Store<string>)[]; target: Store<number>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string | number | boolean; targetType: number; \}; \}'.
			        Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: string | number | boolean; targetType: number; \}; \}'.
			      "
			    \`)
			  \})
			\})
			describe('sample + .map', () => \{
			  test('directly assign \`.map\` result to \`source\` (should pass)', () => \{
			    const event: Event<[\{foo: string\}]> = createEvent()
			    const target = createStore('yes')
			
			    sample(\{
			      source: event.map(([obj]) => obj.foo),
			      target,
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('directly assign \`.map\` result to \`source\` without losing inference in \`fn\` (should pass)', () => \{
			    const event: Event<[\{foo: 'payload'\}]> = createEvent()
			    const a = createStore(0)
			    const b = createEvent<number | string>()
			
			    sample(\{
			      source: event.map(([obj]) => obj.foo),
			      fn: payload =>
			        // cast never if payload is any
			        (payload as 0 extends 1 & typeof payload ? never : typeof payload)
			          .length,
			      target: [a, b],
			    \})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			test('from unknown to known type (should fail)', () => \{
			  const emitUnknown = createEvent<unknown>()
			  const receiveNumber = createEvent<number>()
			  sample(\{
			    //@ts-expect-error
			    source: emitUnknown,
			    target: receiveNumber,
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Event<unknown>; target: Event<number>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: unknown; targetType: number; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: unknown; targetType: number; \}; \}'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sample\\sample.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(42)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sample\\targetForwarding.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  sample,
			  Store,
			  Event,
			  guard,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('a target receives a more strict value type from a source [with clock] (should pass)', () => \{
			  const source = createStore(\{a: '', b: ''\})
			  const clock = createEvent()
			  const target = createEvent<\{a: string\}>()
			
			  sample(\{source, clock, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('a target receives a more strict value type from a source [without clock] (should pass)', () => \{
			  const source = createStore(\{a: '', b: ''\})
			  const target = createEvent<\{a: string\}>()
			
			  sample(\{source, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('a target receives an equal value type from a source [with clock] (should pass)', () => \{
			  const source = createStore<\{a: string; b?: string\}>(\{a: '', b: ''\})
			  const clock = createEvent()
			  const target = createEvent<\{a: string; b?: string\}>()
			
			  sample(\{source, clock, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('a target receives an equal value type from a source [without clock] (should pass)', () => \{
			  const source = createStore<\{a: string; b?: string\}>(\{a: '', b: ''\})
			  const target = createEvent<\{a: string; b?: string\}>()
			
			  sample(\{source, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('a target receives a more strict (or equal) value type from a mapping fn [with clock] (should pass)', () => \{
			  const source = createStore(null)
			  const clock = createEvent()
			  const fn = () => (\{a: '', b: ''\})
			  const target = createEvent<\{a: string\}>()
			
			  sample(\{source, clock, fn, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('a target receives a more strict (or equal) value type from a mapping fn [without clock] (should pass)', () => \{
			  const source = createStore(null)
			  const fn = () => (\{a: '', b: ''\})
			  const target = createEvent<\{a: string\}>()
			
			  sample(\{source, fn, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('when a target receives a more loose value type from a source [with clock] (should fail)', () => \{
			  const source = createStore(\{a: ''\})
			  const clock = createEvent()
			  const target = createEvent<\{a: string; b: string\}>()
			  //@ts-expect-error
			  sample(\{source, clock, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Store<\{ a: string; \}>; clock: Event<void>; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			    "
			  \`)
			\})
			
			test('when a target receives a more loose value type from a source [without clock] (should fail)', () => \{
			  const source = createStore(\{a: ''\})
			  const target = createEvent<\{a: string; b: string\}>()
			  //@ts-expect-error
			  sample(\{source, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Store<\{ a: string; \}>; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			    "
			  \`)
			\})
			
			test('when a target receives a more loose value type from a mapping fn [with clock] (should fail)', () => \{
			  const source = createStore(null)
			  const clock = createEvent()
			  const fn = () => (\{a: ''\})
			  const target = createEvent<\{a: string; b: string\}>()
			  //@ts-expect-error
			  sample(\{source, clock, fn, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Store<null>; clock: Event<void>; fn: () => \{ a: string; \}; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			    "
			  \`)
			\})
			
			test('when a target receives a more loose value type from a mapping fn [without clock] (should fail)', () => \{
			  const source = createStore(null)
			  const fn = () => (\{a: ''\})
			  const target = createEvent<\{a: string; b: string\}>()
			  //@ts-expect-error
			  sample(\{source, fn, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Store<null>; fn: () => \{ a: string; \}; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{ a: string; \}; targetType: \{ a: string; b: string; \}; \}; \}'.
			    "
			  \`)
			\})
			
			test('when nullable field passed to strict target [with clock] (should fail)', () => \{
			  const source = createStore<\{foo: string; bar: string | null\}>(\{
			    foo: '',
			    bar: null,
			  \})
			  const clock = createStore<string | null>(null)
			  const target = createEffect<\{foo: string; bar: string\}, void, Error>()
			  //@ts-expect-error
			  sample(\{source, clock, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Store<\{ foo: string; bar: string | null; \}>; clock: Store<string | null>; target: Effect<\{ foo: string; bar: string; \}, void, Error>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ foo: string; bar: string | null; \}; targetType: \{ foo: string; bar: string; \}; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ foo: string; bar: string | null; \}; targetType: \{ foo: string; bar: string; \}; \}; \}'.
			    "
			  \`)
			\})
			
			test('when nullable field passed to strict target [without clock] (should fail)', () => \{
			  const source = createStore<\{foo: string; bar: string | null\}>(\{
			    foo: '',
			    bar: null,
			  \})
			  const target = createEffect<\{foo: string; bar: string\}, void, Error>()
			  //@ts-expect-error
			  sample(\{source, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Store<\{ foo: string; bar: string | null; \}>; target: Effect<\{ foo: string; bar: string; \}, void, Error>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ foo: string; bar: string | null; \}; targetType: \{ foo: string; bar: string; \}; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ foo: string; bar: string | null; \}; targetType: \{ foo: string; bar: string; \}; \}; \}'.
			    "
			  \`)
			\})
			
			describe('edge case for \{\} type', () => \{
			  test('when a target receives a more loose value type from a source [with clock] (should fail)', () => \{
			    const source = createStore(\{\})
			    const clock = createEvent()
			    const target = createEvent<\{a: string; b: string\}>()
			
			    //@ts-expect-error
			    sample(\{source, clock, target\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<\{\}>; clock: Event<void>; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      "
			    \`)
			  \})
			  test('when a target receives a more loose value type from a source [without clock] (should fail)', () => \{
			    const source = createStore(\{\})
			    const target = createEvent<\{a: string; b: string\}>()
			    //@ts-expect-error
			    sample(\{source, target\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<\{\}>; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      "
			    \`)
			  \})
			
			  test('when a target receives a more loose value type from a mapping fn [with clock] (should fail)', () => \{
			    const source = createStore(null)
			    const clock = createEvent()
			    const fn = () => (\{\})
			    const target = createEvent<\{a: string; b: string\}>()
			    //@ts-expect-error
			    sample(\{source, clock, fn, target\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<null>; clock: Event<void>; fn: () => \{\}; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      "
			    \`)
			  \})
			
			  test('when a target receives a more loose value type from a mapping fn [without clock] (should fail)', () => \{
			    const source = createStore(null)
			    const fn = () => (\{\})
			    const target = createEvent<\{a: string; b: string\}>()
			    //@ts-expect-error
			    sample(\{source, fn, target\})
			
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Store<null>; fn: () => \{\}; target: Event<\{ a: string; b: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"fn result should extend target type\\\\"; targets: \{ fnResult: \{\}; targetType: \{ a: string; b: string; \}; \}; \}'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sample\\targetForwarding.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(16)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterArrayTarget.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample\} from 'effector'
			const typecheck = '\{global\}'
			
			/** used as valid source type */
			type AN = \{a: number\}
			/** used as invalid source type */
			type AS = \{a: string\}
			/** used as valid source type */
			type AB = \{a: number; b: string\}
			/** used as invalid source type */
			type ABN = \{a: number; b: number\}
			const voidt = createEvent()
			const anyt = createEvent<any>()
			const str = createEvent<string>()
			const num = createEvent<number>()
			const numStr = createEvent<number | string>()
			const strBool = createEvent<string | boolean>()
			const \$num = createStore<number>(0)
			const \$str = createStore<string>('')
			const a_num = createEvent<AN>()
			const a_str = createEvent<AS>()
			const ab = createEvent<AB>()
			const abn = createEvent<ABN>()
			const l_num = createEvent<[number]>()
			const l_str = createEvent<[string]>()
			const l_num_str = createEvent<[number, string]>()
			const l_num_num = createEvent<[number, number]>()
			
			const fn = \{
			  noArgs: () => (\{a: 2, b: ''\}),
			  assertFirst: \{
			    object: \{
			      solo: (\{a\}: AS, cl: number) => (\{a: cl, b: a\}),
			      pair: (\{a, b\}: ABN, cl: number) => (\{a: b + cl, b: ''\}),
			    \},
			    tuple: \{
			      solo: ([a]: [string], cl: number) => (\{a: cl, b: a\}),
			      pair: ([a, b]: [number, number], cl: number) => (\{a: b + cl, b: ''\}),
			    \},
			  \},
			  assertFirstOnly: \{
			    object: \{
			      solo: (\{a\}: AS) => (\{a: 0, b: a\}),
			      pair: (\{b\}: ABN) => (\{a: b, b: ''\}),
			    \},
			    tuple: \{
			      solo: ([a]: [string]) => (\{a: 2, b: a\}),
			      pair: ([, b]: [number, number]) => (\{a: b, b: ''\}),
			    \},
			  \},
			  assertSecond: \{
			    object: \{
			      solo: (\{a\}: AN, cl: string) => (\{a, b: cl\}),
			      pair: (\{a\}: AB, cl: string) => (\{a, b: cl\}),
			    \},
			    tuple: \{
			      solo: ([a]: [number], cl: string) => (\{a, b: cl\}),
			      pair: ([a]: [number, string], cl: string) => (\{a, b: cl\}),
			    \},
			  \},
			  typedSrc: \{
			    object: \{
			      solo: (\{a\}: AN) => (\{a, b: ''\}),
			      pair: (\{a, b\}: AB) => (\{a, b\}),
			    \},
			    tuple: \{
			      solo: ([a]: [number]) => (\{a, b: ''\}),
			      pair: ([a, b]: [number, string]) => (\{a, b\}),
			    \},
			  \},
			  typedSrcClock: \{
			    object: \{
			      solo: (\{a\}: AN, cl: number) => (\{a: a + cl, b: ''\}),
			      pair: (\{a, b\}: AB, cl: number) => (\{a: a + cl, b\}),
			    \},
			    tuple: \{
			      solo: ([a]: [number], cl: number) => (\{a: a + cl, b: ''\}),
			      pair: ([a, b]: [number, string], cl: number) => (\{a: a + cl, b\}),
			    \},
			  \},
			\}
			
			describe('basic cases', () => \{
			  describe('no fn', () => \{
			    test('no fn (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{filter: () => true, source:num, clock:num, target:[anyt]          \})
			        sample(\{filter: () => true, source:num, clock:str, target:[anyt]          \})
			        sample(\{filter: () => true, source:num, clock:num, target:[num]           \})
			        sample(\{filter: () => true, source:num, clock:str, target:[num]           \})
			        sample(\{filter: () => true, source:str, clock:num, target:[anyt]          \})
			        sample(\{filter: () => true, source:str, clock:num, target:[anyt,voidt]    \})
			        sample(\{filter: () => true, source:str, clock:num, target:[numStr]        \})
			        sample(\{filter: () => true, source:str, clock:num, target:[voidt]         \})
			        sample(\{filter: () => true, source:num, clock:num, target:[voidt]         \})
			        sample(\{filter: () => true, source:num, clock:num, target:[numStr,anyt]   \})
			        sample(\{filter: () => true, source:str, clock:str, target:[numStr,anyt]   \})
			        sample(\{filter: () => true, source:str, clock:str, target:[numStr,voidt]  \})
			        sample(\{filter: () => true, source:str, clock:str, target:[strBool,numStr]\})
			        sample(\{filter: () => true, source:str, clock:str, target:[strBool,anyt]  \})
			        sample(\{filter: () => true, source:str, clock:str, target:[strBool,voidt] \})
			        sample(\{filter: () => true, source:str, clock:str, target:[anyt,numStr]   \})
			        sample(\{filter: () => true, source:str, clock:str, target:[anyt,voidt]    \})
			        sample(\{filter: () => true, source:str, clock:str, target:[str,numStr]    \})
			        sample(\{filter: () => true, source:str, clock:str, target:[str,anyt]      \})
			        sample(\{filter: () => true, source:str, clock:str, target:[str,voidt]     \})
			        sample(\{filter: () => true, source:str, clock:str, target:[voidt,numStr]  \})
			        sample(\{filter: () => true, source:str, clock:str, target:[voidt,strBool] \})
			        sample(\{filter: () => true, source:str, clock:str, target:[voidt,anyt]    \})
			        sample(\{filter: () => true, source:str, clock:str, target:[numStr]        \})
			        sample(\{filter: () => true, source:str, clock:str, target:[strBool]       \})
			        sample(\{filter: () => true, source:str, clock:str, target:[anyt]          \})
			        sample(\{filter: () => true, source:str, clock:str, target:[str]           \})
			        sample(\{filter: () => true, source:str, clock:str, target:[voidt]         \})
			        sample(\{filter: () => true, source:num, clock:str, target:[voidt]         \})
			        sample(\{filter: () => true, source:str, clock:num, target:[str,anyt]      \})
			        sample(\{filter: () => true, source:str, clock:num, target:[strBool,voidt] \})
			        sample(\{filter: () => true, source:num, clock:str, target:[numStr,anyt]   \})
			        sample(\{filter: () => true, source:str, clock:num, target:[str,numStr]    \})
			        sample(\{filter: () => true, source:str, clock:num, target:[numStr,anyt]   \})
			        sample(\{filter: () => true, source:str, clock:num, target:[strBool]       \})
			        sample(\{filter: () => true, source:str, clock:num, target:[str]           \})
			        sample(\{filter: () => true, source:str, clock:num, target:[str,voidt]     \})
			        sample(\{filter: () => true, source:str, clock:num, target:[strBool,numStr]\})
			        sample(\{filter: () => true, source:num, clock:num, target:[num,anyt]      \})
			        sample(\{filter: () => true, source:num, clock:str, target:[num,anyt]      \})
			        sample(\{filter: () => true, source:str, clock:num, target:[numStr,voidt]  \})
			        sample(\{filter: () => true, source:num, clock:num, target:[voidt,numStr]  \})
			        sample(\{filter: () => true, source:num, clock:num, target:[voidt,anyt]    \})
			        sample(\{filter: () => true, source:str, clock:num, target:[voidt,numStr]  \})
			        sample(\{filter: () => true, source:num, clock:str, target:[voidt,anyt]    \})
			        sample(\{filter: () => true, source:num, clock:num, target:[num,numStr]    \})
			        sample(\{filter: () => true, source:num, clock:str, target:[voidt,numStr]  \})
			        sample(\{filter: () => true, source:num, clock:num, target:[num,voidt]     \})
			        sample(\{filter: () => true, source:num, clock:str, target:[num,voidt]     \})
			        sample(\{filter: () => true, source:num, clock:num, target:[numStr]        \})
			        sample(\{filter: () => true, source:str, clock:num, target:[anyt,numStr]   \})
			        sample(\{filter: () => true, source:str, clock:num, target:[voidt,strBool] \})
			        sample(\{filter: () => true, source:num, clock:num, target:[anyt,numStr]   \})
			        sample(\{filter: () => true, source:num, clock:str, target:[num,numStr]    \})
			        sample(\{filter: () => true, source:str, clock:num, target:[voidt,anyt]    \})
			        sample(\{filter: () => true, source:num, clock:num, target:[anyt,voidt]    \})
			        sample(\{filter: () => true, source:str, clock:num, target:[strBool,anyt]  \})
			        sample(\{filter: () => true, source:num, clock:str, target:[anyt,voidt]    \})
			        sample(\{filter: () => true, source:num, clock:str, target:[numStr]        \})
			        sample(\{filter: () => true, source:num, clock:num, target:[numStr,voidt]  \})
			        sample(\{filter: () => true, source:num, clock:str, target:[numStr,voidt]  \})
			        sample(\{filter: () => true, source:num, clock:str, target:[anyt,numStr]   \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('no fn (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:num, target:[num]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:str, target:[num]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[str]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:num, target:[num,voidt]     \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:str, target:[num,numStr]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:str, target:[num,anyt]      \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:str, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:str, target:[num,voidt]     \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[str]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:num, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:num, target:[num,anyt]      \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[num,str]       \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:str, clock:num, target:[num,numStr]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[str,voidt]     \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[strBool,voidt] \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[str,numStr]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[str,numStr]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[str,voidt]     \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[strBool]       \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[strBool]       \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[num,strBool]   \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[strBool,anyt]  \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[strBool,voidt] \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[voidt,strBool] \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[strBool,anyt]  \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[strBool,numStr]\})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:num, target:[str,anyt]      \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[str,anyt]      \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[voidt,strBool] \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:num, clock:str, target:[strBool,numStr]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ filter: () => boolean; source: Event<string>; clock: Event<number>; target: Event<number>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<string>; clock: Event<string>; target: Event<number>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<number>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<string>; clock: Event<number>; target: (Event<void> | Event<number>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<string>; clock: Event<string>; target: (Event<void> | Event<number>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: string; targetType: number | void; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<string>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<string>; target: (Event<void> | Event<string>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | void; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<number>; target: Event<string | boolean>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<string>; target: Event<string | boolean>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<string>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<number>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Event<number>; clock: Event<string>; target: (Event<void> | Event<string | boolean>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string | boolean | void; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			\})
			describe('combinable', () => \{
			  describe('source:wide', () => \{
			    test('source:wide (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num]    \})
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num,ab] \})
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[ab]       \})
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num]    \})
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num,ab] \})
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[ab]       \})
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_str]\})
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_str]\})
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num]               \})
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num,l_num_str]     \})
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num]    \})
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num,l_num_str]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, string] | [number]; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('source:wide (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[abn]                \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[abn]                \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num,b:\$str\}, clock:num, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num,\$str]    , clock:num, target:[l_num_num]          \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; b: Store<string>; \}; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; b: Store<string>; \}; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; b: Store<string>; \}; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; b: Store<string>; \}; clock: Event<number>; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; b: string; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: (Store<number> | Store<string>)[]; clock: Event<number>; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: (string | number)[]; targetType: [number, number]; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('source:same', () => \{
			    test('source:same (should pass)', () => \{
			      //prettier-ignore
			      \{
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[a_num]\})
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num]\})
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num]\})
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num]\})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: Event<[number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number]; \}[]; \}'.
			        "
			      \`)
			    \})
			    test('source:same (should fail)', () => \{
			      //prettier-ignore
			      \{
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[abn]                \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[ab]                 \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[a_num,ab]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num,abn]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[abn,ab]             \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[abn,a_str]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[abn]                \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[ab,a_str]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num,a_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_num,ab]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[ab]                 \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[a_str,ab]           \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num_str]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , target:[l_num_num,l_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_str]              \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_str]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_num]          \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num,l_str]        \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num,l_num_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_str,l_num_num]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_str,l_str]    \})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_str,l_num_num]\})
			        //@ts-expect-error
			        sample(\{filter: () => true, source:[\$num]  , clock:num, target:[l_num_num,l_str]    \})
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; target: Event<AB>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; target: (Event<AB> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<AS>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AB> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB | ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AS> | Event<ABN>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<ABN>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: ABN; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; clock: Event<number>; target: Event<AB>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AB; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: \{ a: Store<number>; \}; clock: Event<number>; target: (Event<AS> | Event<AB>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ a: number; \}; targetType: AS | AB; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: Event<[string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: Event<[number, string]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: Event<[number, number]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: (Event<[number]> | Event<[string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: (Event<[number]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, string] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: (Event<[number]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: (Event<[string]> | Event<[number, string]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [string] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: (Event<[number, string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [number, string]; \}[]; \}'.
			        Argument of type '\{ filter: () => boolean; source: Store<number>[]; clock: Event<number>; target: (Event<[string]> | Event<[number, number]>)[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			          Object literal may only specify known properties, and 'filter' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number[]; targetType: [number, number] | [string]; \}[]; \}'.
			        "
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterArrayTarget.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterClockArray.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample\} from 'effector'
			const typecheck = '\{global\}'
			
			type AB = \{a: string; b: number\}
			const voidt = createEvent()
			const anyt = createEvent<any>()
			const str = createEvent<string>()
			const strClk = createEvent<string>()
			const num = createEvent<number>()
			const a = createStore('')
			const b = createStore(0)
			const aTarget = createEvent<\{a: string\}>()
			const abTarget = createEvent<AB>()
			const aclock = createEvent<\{a: string; clock: any\}>()
			const abclock = createEvent<\{a: string; b: number; clock: any\}>()
			const fnAbClockString = (\{a, b\}: AB, clock: string) => (\{a, b, clock\})
			const fnAbClockAny = (\{a, b\}: AB, clock: any) => (\{a, b, clock\})
			const fnAString = (a: string) => (\{a\})
			const fnAStringClockString = (a: string, clock: string) => (\{a, clock\})
			const fnAStringClockAny = (a: string, clock: any) => (\{a, clock\})
			const fnAb = (\{a, b\}: AB) => (\{a, b\})
			
			describe('clock only', () => \{
			  test('noSource (should pass)', () => \{
			    //prettier-ignore
			    \{
			      sample(\{filter: () => true, clock:strClk       \})
			      sample(\{filter: () => true, clock:anyt         \})
			      sample(\{filter: () => true, clock:[strClk]     \})
			      sample(\{filter: () => true, clock:[anyt]       \})
			      sample(\{filter: () => true, clock:[strClk,anyt]\})
			      sample(\{filter: () => true, clock:strClk       , target:str\})
			      sample(\{filter: () => true, clock:anyt         , target:str\})
			      sample(\{filter: () => true, clock:[strClk]     , target:str\})
			      sample(\{filter: () => true, clock:[anyt]       , target:str\})
			      sample(\{filter: () => true, clock:[strClk,anyt], target:str\})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			test('noClock (should pass)', () => \{
			  //prettier-ignore
			  \{
			    sample(\{filter: () => true, source:a    \})
			    sample(\{filter: () => true, source:\{a,b\}\})
			    sample(\{filter: () => true, source:a    , target:str     \})
			    sample(\{filter: () => true, source:\{a,b\}, target:abTarget\})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test(' (should pass)', () => \{
			  //prettier-ignore
			  \{
			    sample(\{filter: () => true, source:a    , clock:[voidt,str]     \})
			    sample(\{filter: () => true, source:a    , clock:[voidt]         \})
			    sample(\{filter: () => true, source:a    , clock:[str]           \})
			    sample(\{filter: () => true, source:a    , clock:[str,voidt,anyt]\})
			    sample(\{filter: () => true, source:a    , clock:[voidt,str,anyt]\})
			    sample(\{filter: () => true, source:a    , clock:[anyt,str,voidt]\})
			    sample(\{filter: () => true, source:a    , clock:[voidt,anyt,str]\})
			    sample(\{filter: () => true, source:a    , clock:[str,anyt,voidt]\})
			    sample(\{filter: () => true, source:a    , clock:[anyt,voidt,str]\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[str]           \})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt]         \})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt,str]     \})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[anyt,str,voidt]\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt,anyt,str]\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[anyt,voidt,str]\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt,str,anyt]\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[str,anyt,voidt]\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[str,voidt,anyt]\})
			    sample(\{filter: () => true, source:a    , clock:[voidt]         , target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[str]           , target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[voidt,str]     , target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[str,voidt,anyt], target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[voidt,anyt,str], target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[anyt,str,voidt], target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[voidt,str,anyt], target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[str,anyt,voidt], target:str     \})
			    sample(\{filter: () => true, source:a    , clock:[anyt,voidt,str], target:str     \})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt]         , target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[str]           , target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt,str]     , target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt,str,anyt], target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[anyt,voidt,str], target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[str,voidt,anyt], target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[str,anyt,voidt], target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[voidt,anyt,str], target:abTarget\})
			    sample(\{filter: () => true, source:\{a,b\}, clock:[anyt,str,voidt], target:abTarget\})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterClockArray.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterOther.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  sample,
			  Store,
			  Event,
			\} from 'effector'
			const typecheck = '\{global\}'
			
			test('clock param name in the function', () => \{
			  const trigger: Event<number> = createEvent()
			  const allow: Store<string> = createStore('no')
			
			  const result1 = sample(\{
			    //@ts-expect-error
			    source: trigger,
			    filter: allow,
			  \})
			  const result2 = sample(\{
			    //@ts-expect-error
			    source: trigger,
			    clock: trigger,
			    filter: allow,
			  \})
			  const result3 = sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Event<number>; filter: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			    Argument of type '\{ source: Event<number>; clock: Event<number>; filter: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			    Argument of type '\{ clock: Event<number>; filter: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			    "
			  \`)
			\})
			
			test('custom typeguards: target array support (1)', () => \{
			  function debounce<T>(event: Event<T>): Event<T> \{
			    return event
			  \}
			  const \$store = createStore<string | number>(0)
			  const \$flag = createStore(false)
			  const trigger = createEvent<\{a: number\}>()
			
			  const targetA = createEffect<\{field: number | string; data: number\}, void>()
			  const targetB = createEvent<\{field: number | string; data: string\}>()
			  const targetC = createEvent<\{field: unknown; data: number\}>()
			  const targetD = createEvent<\{field: number; data: number\}>()
			  const targetE = createEvent<\{field: any\}>()
			  const targetF = createEvent<\{field: any; data: any; extra: boolean\}>()
			  const targetVoid = createEvent()
			  const targetAny = createEvent<any>()
			
			  const res = sample(\{
			    source: sample(\{
			      clock: debounce(trigger),
			      source: [\$flag, \$store],
			      fn: ([isAble, field], data) => (isAble ? \{field, data\} : null),
			    \}),
			    filter: (e): e is \{field: number | string; data: number\} => !!e,
			    target: [
			      targetVoid,
			      targetA,
			      targetB,
			      targetC,
			      targetD,
			      targetE,
			      targetF,
			      targetAny,
			    ],
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '((src: (string | number | boolean)[], clk: \{ a: number; \}) => any) & (([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null)'.
			      Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '(src: (string | number | boolean)[], clk: \{ a: number; \}) => any'.
			        Types of parameters '__0' and 'src' are incompatible.
			          Type '(string | number | boolean)[]' is not assignable to type '[any, any]'.
			    Binding element 'isAble' implicitly has an 'any' type.
			    Binding element 'field' implicitly has an 'any' type.
			    Parameter 'data' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			test('custom typeguards: target array support (2)', () => \{
			  function debounce<T>(event: Event<T>): Event<T> \{
			    return event
			  \}
			  const \$store = createStore<string | number>(0)
			  const \$flag = createStore(false)
			  const trigger = createEvent<\{a: number\}>()
			
			  const targetA = createEffect<\{field: number | string; data: number\}, void>()
			  const targetB = createEvent<\{field: number | string; data: string\}>()
			  const targetC = createEvent<\{field: unknown; data: number\}>()
			  const targetD = createEvent<\{field: string; data: number\}>()
			  const targetE = createEvent<\{field: any\}>()
			  const targetF = createEvent<\{field: any; data: any; extra: boolean\}>()
			
			  const targetVoid = createEvent()
			  const targetAny = createEvent<any>()
			
			  const res = sample(\{
			    source: sample(\{
			      clock: debounce(trigger),
			      source: [\$flag, \$store],
			      fn: ([isAble, field], data) => (isAble ? \{field, data\} : null),
			    \}),
			    filter: (e): e is \{field: number; data: number\} => !!e,
			    target: [
			      targetVoid,
			      targetA,
			      targetB,
			      targetC,
			      targetD,
			      targetE,
			      targetF,
			      targetAny,
			    ],
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '((src: (string | number | boolean)[], clk: \{ a: number; \}) => any) & (([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null)'.
			      Type '([isAble, field]: [any, any], data: any) => \{ field: any; data: any; \} | null' is not assignable to type '(src: (string | number | boolean)[], clk: \{ a: number; \}) => any'.
			        Types of parameters '__0' and 'src' are incompatible.
			          Type '(string | number | boolean)[]' is not assignable to type '[any, any]'.
			    Binding element 'isAble' implicitly has an 'any' type.
			    Binding element 'field' implicitly has an 'any' type.
			    Parameter 'data' implicitly has an 'any' type.
			    "
			  \`)
			\})
			
			test('generic support', () => \{
			  const source = createEvent<null | number>()
			  const target = createEvent<number>()
			
			  function filter<T>(value: T): value is NonNullable<T> \{
			    return value != null
			  \}
			
			  sample(\{source, filter, target\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			describe('function without argument support', () => \{
			  const target = createEvent<string>()
			  test('filter function', () => \{
			    const clock = createEvent<number>()
			    const source = createEvent<number>()
			    sample(\{
			      clock,
			      source,
			      filter: arg => arg > 0,
			      fn: () => 'ok',
			    \})
			    sample(\{
			      clock,
			      filter: arg => arg > 0,
			      fn: () => 'ok',
			    \})
			    sample(\{
			      source,
			      filter: arg => arg > 0,
			      fn: () => 'ok',
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('filter infer', () => \{
			    const clock = createEvent<number | null>()
			    const source = createEvent<number | null>()
			    sample(\{
			      clock,
			      source,
			      filter: (arg): arg is number => typeof arg === 'number',
			      fn: () => 'ok',
			    \})
			    sample(\{
			      clock,
			      filter: (arg): arg is number => typeof arg === 'number',
			      fn: () => 'ok',
			    \})
			    sample(\{
			      source,
			      filter: (arg): arg is number => typeof arg === 'number',
			      fn: () => 'ok',
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('filter bool', () => \{
			    const clock = createEvent<number | null>()
			    const source = createEvent<number | null>()
			    sample(\{
			      clock,
			      source,
			      filter: Boolean,
			      fn: () => 'ok',
			    \})
			    sample(\{
			      clock,
			      filter: Boolean,
			      fn: () => 'ok',
			    \})
			    sample(\{
			      source,
			      filter: Boolean,
			      fn: () => 'ok',
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('filter function + target', () => \{
			    const clock = createEvent<number>()
			    const source = createEvent<number>()
			    sample(\{
			      clock,
			      source,
			      filter: arg => arg > 0,
			      fn: () => 'ok',
			      target,
			    \})
			    sample(\{
			      clock,
			      filter: arg => arg > 0,
			      fn: () => 'ok',
			      target,
			    \})
			    sample(\{
			      source,
			      filter: arg => arg > 0,
			      fn: () => 'ok',
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('filter infer + target', () => \{
			    const clock = createEvent<number | null>()
			    const source = createEvent<number | null>()
			    sample(\{
			      clock,
			      source,
			      filter: (arg): arg is number => typeof arg === 'number',
			      fn: () => 'ok',
			      target,
			    \})
			    sample(\{
			      clock,
			      filter: (arg): arg is number => typeof arg === 'number',
			      fn: () => 'ok',
			      target,
			    \})
			    sample(\{
			      source,
			      filter: (arg): arg is number => typeof arg === 'number',
			      fn: () => 'ok',
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('filter bool + target', () => \{
			    const clock = createEvent<number | null>()
			    const source = createEvent<number | null>()
			    sample(\{
			      clock,
			      source,
			      filter: Boolean,
			      fn: () => 'ok',
			      target,
			    \})
			    sample(\{
			      clock,
			      filter: Boolean,
			      fn: () => 'ok',
			      target,
			    \})
			    sample(\{
			      source,
			      filter: Boolean,
			      fn: () => 'ok',
			      target,
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('difference in behavior between typed and untyped filters/functions combinations', () => \{
			  type AN = \{a: number\}
			  const aNumNull = createEvent<AN | null>()
			  const num = createEvent<number>()
			  const aNum = createEvent<number>()
			  describe('with target', () => \{
			    test('typed filter, untyped fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val: AN | null): val is AN => val !== null,
			        fn: (\{a\}) => a,
			        target: aNum,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('typed filter, typed fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val: AN | null): val is AN => val !== null,
			        fn: (\{a\}: AN) => a,
			        target: aNum,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('untyped filter, untyped fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val): val is AN => val !== null,
			        fn: (\{a\}) => a,
			        target: aNum,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Property 'a' does not exist on type 'AN | null'.
			        "
			      \`)
			    \})
			    test('untyped filter, typed fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val): val is AN => val !== null,
			        fn: (\{a\}: AN) => a,
			        target: aNum,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			  describe('without target', () => \{
			    test('typed filter, untyped fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val: AN | null): val is AN => val !== null,
			        fn: (\{a\}) => a,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('typed filter, typed fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val: AN | null): val is AN => val !== null,
			        fn: (\{a\}: AN) => a,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('untyped filter, untyped fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val): val is AN => val !== null,
			        fn: (\{a\}) => a,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Property 'a' does not exist on type 'AN | null'.
			        "
			      \`)
			    \})
			    test('untyped filter, typed fn', () => \{
			      sample(\{
			        clock: num,
			        source: aNumNull,
			        filter: (val): val is AN => val !== null,
			        fn: (\{a\}: AN) => a,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterOther.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(18)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterReturn.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample, Event, Store\} from 'effector'
			const typecheck = '\{global\}'
			type AN = \{a: number\}
			const \$num = createStore(0)
			const a = createStore(\{a: 0\})
			const num = createEvent<number>()
			const aNum = createEvent<AN>()
			const aT = createStore(\{a: 0\})
			const aNumT = createEvent<AN>()
			const fn0 = () => (\{a: 0\})
			const fn1 = (\{a\}: AN) => (\{a\})
			const fn2 = (\{a\}: AN, c: number) => (\{a: a + c\})
			
			describe('no target', () => \{
			  test('no target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    , clock:num\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       , clock:num\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:num\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    , clock:\$num\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       , clock:\$num\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:\$num\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('no target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    , clock:[num,\$num]\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       , clock:[num,\$num]\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('unit target', () => \{
			  test('unit target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    , target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:aNum    , target:aT   \})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:a       , target:aT   \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       , target:aNumT\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:\{a:\$num\}, target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    , clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:aNum    , clock:num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       , clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:a       , clock:num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{filter: () => true, source:aNum    , clock:\$num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    , clock:\$num, target:aNumT\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       , clock:\$num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:a       , clock:\$num, target:aT   \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:\$num, target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:\$num, target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('unit target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: Store<AN> = sample(\{filter: () => true, source:aNum    , clock:[num,\$num], target:aT   \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:aNum    , clock:[num,\$num], target:aNumT\})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:a       , clock:[num,\$num], target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:a       , clock:[num,\$num], target:aT   \})\}
			      \{const result: Event<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num], target:aNumT\})\}
			      \{const result: Store<AN> = sample(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num], target:aT   \})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			describe('tuple target', () => \{
			  test('tuple target, none clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:aNum    , target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:a       , target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:\{a:\$num\}, target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			        Target requires 2 element(s) but source may have fewer.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, event clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:aNum    , clock:num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:a       , clock:num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:\{a:\$num\}, clock:num, target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, store clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:aNum    , clock:\$num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:a       , clock:\$num, target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:\{a:\$num\}, clock:\$num, target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			  test('tuple target, tuple clock (should pass)', () => \{
			    //prettier-ignore
			    \{
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:aNum    , clock:[num,\$num], target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:a       , clock:[num,\$num], target:[aNumT,aT]\})\}
			      \{const result: [Event<AN>, Store<AN>] = sample(\{filter: () => true, source:\{a:\$num\}, clock:[num,\$num], target:[aNumT,aT]\})\}
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      Type '(Event<AN> | Store<\{ a: number; \}>)[]' is not assignable to type '[Event<AN>, Store<AN>]'.
			      "
			    \`)
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterReturn.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterWideNarrow.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample, Event\} from 'effector'
			const typecheck = '\{global\}'
			
			test('wide union (should fail)', () => \{
			  const trigger: Event<\{a: 1\} | \{a: 2\} | \{a: 3\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1\} | \{a: 2\}> = createEvent()
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ clock: Event<\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}>; filter: Store<boolean>; target: Event<\{ a: 1; \} | \{ a: 2; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}; targetType: \{ a: 1; \} | \{ a: 2; \}; \}; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}; targetType: \{ a: 1; \} | \{ a: 2; \}; \}; \}'.
			    Type 'Event<\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}>' is not assignable to type 'Event<\{ a: 1; \} | \{ a: 2; \}>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: \{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ a: 1; \} | \{ a: 2; \}) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type '\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}' is not assignable to type '\{ a: 1; \} | \{ a: 2; \}'.
			    Argument of type '\{ clock: Event<\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}>; filter: Store<boolean>; target: Event<\{ a: 1; \} | \{ a: 2; \}>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}; targetType: \{ a: 1; \} | \{ a: 2; \}; \}[]; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}; targetType: \{ a: 1; \} | \{ a: 2; \}; \}[]; \}'.
			    Type 'Event<\{ a: 1; \} | \{ a: 2; \} | \{ a: 3; \}>' is not assignable to type '[Event<\{ a: 1; \} | \{ a: 2; \}>]'.
			    "
			  \`)
			\})
			
			test('narrow union (should pass)', () => \{
			  const trigger: Event<\{a: 1\} | \{a: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1\} | \{a: 2\} | \{a: 3\}> = createEvent()
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('unknown type in source (should fail)', () => \{
			  const trigger: Event<unknown> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<string> = createEvent()
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ clock: Event<unknown>; filter: Store<boolean>; target: Event<string>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: unknown; targetType: string; \}; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: unknown; targetType: string; \}; \}'.
			    Type 'Event<unknown>' is not assignable to type 'Event<string>'.
			    Argument of type '\{ clock: Event<unknown>; filter: Store<boolean>; target: Event<string>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: unknown; targetType: string; \}[]; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: unknown; targetType: string; \}[]; \}'.
			    Type 'Event<unknown>' is not assignable to type '[Event<string>]'.
			    "
			  \`)
			\})
			
			test('unknown type in target (should pass)', () => \{
			  const trigger: Event<string> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<unknown> = createEvent()
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('optional props (should fail)', () => \{
			  const trigger: Event<\{a: 1; b?: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1; b: 2\}> = createEvent()
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ clock: Event<\{ a: 1; b?: 2 | undefined; \}>; filter: Store<boolean>; target: Event<\{ a: 1; b: 2; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b?: 2 | undefined; \}; targetType: \{ a: 1; b: 2; \}; \}; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b?: 2 | undefined; \}; targetType: \{ a: 1; b: 2; \}; \}; \}'.
			    Type 'Event<\{ a: 1; b?: 2 | undefined; \}>' is not assignable to type 'Event<\{ a: 1; b: 2; \}>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: \{ a: 1; b?: 2 | undefined; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ a: 1; b: 2; \}) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type '\{ a: 1; b?: 2 | undefined; \}' is not assignable to type '\{ a: 1; b: 2; \}'.
			    Argument of type '\{ clock: Event<\{ a: 1; b?: 2 | undefined; \}>; filter: Store<boolean>; target: Event<\{ a: 1; b: 2; \}>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b?: 2 | undefined; \}; targetType: \{ a: 1; b: 2; \}; \}[]; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b?: 2 | undefined; \}; targetType: \{ a: 1; b: 2; \}; \}[]; \}'.
			    Type 'Event<\{ a: 1; b?: 2 | undefined; \}>' is not assignable to type '[Event<\{ a: 1; b: 2; \}>]'.
			    "
			  \`)
			\})
			
			test('wide object (should pass)', () => \{
			  const trigger: Event<\{a: 1; b: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1\}> = createEvent()
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('narrow object (should fail)', () => \{
			  const trigger: Event<\{a: 1; b: 2\}> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<\{a: 1; b: 2; c: 3\}> = createEvent()
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ clock: Event<\{ a: 1; b: 2; \}>; filter: Store<boolean>; target: Event<\{ a: 1; b: 2; c: 3; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b: 2; \}; targetType: \{ a: 1; b: 2; c: 3; \}; \}; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b: 2; \}; targetType: \{ a: 1; b: 2; c: 3; \}; \}; \}'.
			    Type 'Event<\{ a: 1; b: 2; \}>' is not assignable to type 'Event<\{ a: 1; b: 2; c: 3; \}>'.
			      Types of property 'watch' are incompatible.
			        Type '(watcher: (payload: \{ a: 1; b: 2; \}) => any) => Subscription' is not assignable to type '(watcher: (payload: \{ a: 1; b: 2; c: 3; \}) => any) => Subscription'.
			          Types of parameters 'watcher' and 'watcher' are incompatible.
			            Types of parameters 'payload' and 'payload' are incompatible.
			              Type '\{ a: 1; b: 2; \}' is not assignable to type '\{ a: 1; b: 2; c: 3; \}'.
			    Argument of type '\{ clock: Event<\{ a: 1; b: 2; \}>; filter: Store<boolean>; target: Event<\{ a: 1; b: 2; c: 3; \}>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b: 2; \}; targetType: \{ a: 1; b: 2; c: 3; \}; \}[]; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: \{ a: 1; b: 2; \}; targetType: \{ a: 1; b: 2; c: 3; \}; \}[]; \}'.
			    Type 'Event<\{ a: 1; b: 2; \}>' is not assignable to type '[Event<\{ a: 1; b: 2; c: 3; \}>]'.
			    "
			  \`)
			\})
			
			test('narrow object combined (should fail)', () => \{
			  const foo = createStore('not enough')
			  const target = createEvent<\{foo: string; bar: string\}>()
			
			  sample(\{
			    //@ts-expect-error
			    source: \{foo\},
			    filter: () => true,
			    target,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: \{ foo: Store<string>; \}; filter: () => boolean; target: Event<\{ foo: string; bar: string; \}>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ foo: string; \}; targetType: \{ foo: string; bar: string; \}; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: \{ foo: string; \}; targetType: \{ foo: string; bar: string; \}; \}; \}'.
			    "
			  \`)
			\})
			
			test('wide tuple (should pass)', () => \{
			  const trigger: Event<[1, 2, 3]> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<[1, 2]> = createEvent()
			
			  sample(\{
			    source: trigger,
			    filter: allow,
			    target,
			  \})
			
			  sample(\{
			    source: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('narrow tuple (should fail)', () => \{
			  const trigger: Event<[1, 2]> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<[1, 2, 3]> = createEvent()
			
			  sample(\{
			    //@ts-expect-error
			    source: trigger,
			    filter: allow,
			    target,
			  \})
			
			  sample(\{
			    //@ts-expect-error
			    source: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Event<[1, 2]>; filter: Store<boolean>; target: Event<[1, 2, 3]>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: [1, 2]; targetType: [1, 2, 3]; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: [1, 2]; targetType: [1, 2, 3]; \}; \}'.
			    Argument of type '\{ source: Event<[1, 2]>; filter: Store<boolean>; target: Event<[1, 2, 3]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: [1, 2]; targetType: [1, 2, 3]; \}[]; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: [1, 2]; targetType: [1, 2, 3]; \}[]; \}'.
			    "
			  \`)
			\})
			
			test('wide union in array (should fail)', () => \{
			  const trigger: Event<Array<number | string | boolean>> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<Array<number | string>> = createEvent()
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  //@ts-expect-error
			  const result1: typeof target = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  sample(\{
			    //@ts-expect-error
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  //@ts-expect-error
			  const result2: [typeof target] = sample(\{
			    clock: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ clock: Event<(string | number | boolean)[]>; filter: Store<boolean>; target: Event<(string | number)[]>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: (string | number | boolean)[]; targetType: (string | number)[]; \}; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: (string | number | boolean)[]; targetType: (string | number)[]; \}; \}'.
			    Type 'Event<(string | number | boolean)[]>' is not assignable to type 'Event<(string | number)[]>'.
			    Argument of type '\{ clock: Event<(string | number | boolean)[]>; filter: Store<boolean>; target: Event<(string | number)[]>[]; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: (string | number | boolean)[]; targetType: (string | number)[]; \}[]; \}'.
			      Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: (string | number | boolean)[]; targetType: (string | number)[]; \}[]; \}'.
			    Type 'Event<(string | number | boolean)[]>' is not assignable to type '[Event<(string | number)[]>]'.
			    "
			  \`)
			\})
			
			test('narrow union in array (should pass)', () => \{
			  const trigger: Event<Array<number | string>> = createEvent()
			  const allow = createStore<boolean>(true)
			  const target: Event<Array<number | string | boolean>> = createEvent()
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target,
			  \})
			
			  sample(\{
			    clock: trigger,
			    filter: allow,
			    target: [target],
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sampleFilter\\sampleFilterWideNarrow.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\sampleFilter.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, createEvent, sample, Store, Event\} from 'effector'
			const typecheck = '\{global\}'
			
			describe('sample(config)', () => \{
			  describe('sample(\{source, filter: store\})', () => \{
			    it('return new event (should pass)', () => \{
			      const trigger = createEvent<number>()
			      const allow = createStore<boolean>(false)
			
			      const result: Event<number> = sample(\{
			        source: trigger,
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    it('support any unit (should pass)', () => \{
			      const trigger = createStore<number[]>([1])
			      const allow = createStore<boolean>(false)
			
			      const result: Event<number[]> = sample(\{
			        source: trigger,
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('store is not boolean (should fail)', () => \{
			      const trigger = createEvent<number>()
			      const allow = createStore<string>('no')
			
			      sample(\{
			        //@ts-expect-error
			        source: trigger,
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<number>; filter: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      const trigger = createEvent<number>()
			      const allow = createStore<string>('no')
			
			      sample(\{
			        //@ts-expect-error
			        source: trigger,
			        filter: allow,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<number>; filter: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"filter unit should has boolean type\\\\"; got: string; \}'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        const trigger: Event<number> = createEvent()
			        const allow = createStore<boolean>(false)
			        const target: Store<number> = createStore(0)
			
			        sample(\{
			          source: trigger,
			          filter: allow,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        const trigger: Event<number> = createEvent()
			        const allow = createStore<boolean>(false)
			        const target = createStore<string>('no')
			
			        sample(\{
			          //@ts-expect-error
			          source: trigger,
			          filter: allow,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Argument of type '\{ source: Event<number>; filter: Store<boolean>; target: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}; \}'.
			            Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}; \}'.
			          "
			        \`)
			      \})
			    \})
			  \})
			  describe('sample(\{source, filter: fn\})', () => \{
			    it('returns new event (should pass)', () => \{
			      const trigger = createEvent<number>()
			      const result: Event<number> = sample(\{
			        source: trigger,
			        filter: n => n > 0,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      const trigger = createEvent<number>()
			
			      //@ts-expect-error
			      const result: Event<string> = sample(\{
			        source: trigger,
			        filter: n => n > 0,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<number>' is not assignable to type 'Event<string>'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        const trigger = createEvent<number>()
			        const target = createStore<number>(0)
			
			        sample(\{
			          source: trigger,
			          filter: x => x > 0,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        const trigger = createEvent<number>()
			        const target = createStore<string>('no')
			
			        sample(\{
			          //@ts-expect-error
			          source: trigger,
			          filter: x => x > 0,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Argument of type '\{ source: Event<number>; filter: (x: number) => boolean; target: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}; \}'.
			            Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}; \}'.
			          "
			        \`)
			      \})
			      describe('any to void', () => \{
			        test('with store (should pass)', () => \{
			          const filter = createStore(true)
			          const source = createEvent<string>()
			          const target = createEvent<void>()
			
			          sample(\{
			            source,
			            filter,
			            target,
			          \})
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			        test('with function (should pass)', () => \{
			          const source = createEvent<\{pass: boolean\}>()
			          const target = createEvent<void>()
			
			          sample(\{
			            source,
			            filter: (\{pass\}) => pass,
			            target,
			          \})
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			      \})
			    \})
			  \})
			  describe('sample(\{source, clock, filter: fn\})', () => \{
			    it('returns new event (should pass)', () => \{
			      const clock = createEvent<string>()
			      const source = createEvent<number>()
			      const result: Event<number> = sample(\{
			        clock,
			        source,
			        filter: (src, clk) => src + clk.length > 0,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      const clock = createEvent<string>()
			      const source = createEvent<number>()
			
			      //@ts-expect-error
			      const result: Event<string> = sample(\{
			        clock,
			        source,
			        filter: (src, clk) => src + clk.length > 0,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<number>' is not assignable to type 'Event<string>'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        const clock = createEvent<string>()
			        const source = createEvent<number>()
			        const target = createStore<number>(0)
			
			        sample(\{
			          clock,
			          source,
			          filter: (src, clk) => src + clk.length > 0,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('filter + fn edge case (should pass)', () => \{
			        const \$source = createStore(\{a: null as number | null, b: ''\})
			        const aNum = createEvent<number>()
			        sample(\{
			          source: \$source,
			          target: aNum,
			          filter: (val): val is \{a: number; b: string\} =>
			            typeof val.a === 'number' && val.a > 0,
			          fn: val => 1,
			        \})
			        sample(\{
			          source: \$source,
			          target: aNum,
			          filter: (val): val is \{a: number; b: string\} =>
			            typeof val.a === 'number' && val.a > 0,
			          fn: (val: \{a: number; b: string\}) => val.a + 1,
			        \})
			        sample(\{
			          clock: \$source,
			          target: aNum,
			          filter: (val): val is \{a: number; b: string\} =>
			            typeof val.a === 'number' && val.a > 0,
			          fn: val => 1,
			        \})
			        sample(\{
			          clock: \$source,
			          target: aNum,
			          filter: (val): val is \{a: number; b: string\} =>
			            typeof val.a === 'number' && val.a > 0,
			          fn: (val: \{a: number; b: string\}) => val.a + 1,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        const clock = createEvent<string>()
			        const source = createEvent<number>()
			        const target = createStore<string>('no')
			
			        sample(\{
			          //@ts-expect-error
			          clock,
			          source,
			          filter: (src, clk) => src + clk.length > 0,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Argument of type '\{ clock: Event<string>; source: Event<number>; filter: (src: number, clk: string) => boolean; target: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}; \}'.
			            Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: number; targetType: string; \}; \}'.
			          "
			        \`)
			      \})
			      describe('any to void', () => \{
			        test('with store (should pass)', () => \{
			          const clock = createEvent<string>()
			          const filter = createStore(true)
			          const source = createEvent<string>()
			          const target = createEvent<void>()
			
			          sample(\{
			            clock,
			            source,
			            filter,
			            target,
			          \})
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			        test('with function (should pass)', () => \{
			          const clock = createEvent<string>()
			          const source = createEvent<\{pass: boolean\}>()
			          const target = createEvent<void>()
			
			          sample(\{
			            clock,
			            source,
			            filter: (\{pass\}, clk) => pass && clk.length > 0,
			            target,
			          \})
			          expect(typecheck).toMatchInlineSnapshot(\`
			            "
			            no errors
			            "
			          \`)
			        \})
			      \})
			    \})
			  \})
			  describe('sample(\{source, filter: Boolean\})', () => \{
			    it('returns new event (should pass)', () => \{
			      type User = \{name: string\}
			      const trigger = createEvent<User | null>()
			      const result: Event<User> = sample(\{
			        source: trigger,
			        filter: Boolean,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      type User = \{name: string\}
			      const trigger = createEvent<User>()
			
			      //@ts-expect-error
			      const result: Event<string> = sample(\{
			        source: trigger,
			        filter: Boolean,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<User>' is not assignable to type 'Event<string>'.
			          Types of property 'watch' are incompatible.
			            Type '(watcher: (payload: User) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
			              Types of parameters 'watcher' and 'watcher' are incompatible.
			                Types of parameters 'payload' and 'payload' are incompatible.
			                  Type 'User' is not assignable to type 'string'.
			        "
			      \`)
			    \})
			    it('filters falsy values (should pass)', () => \{
			      type User = \{name: string\}
			      type FalsyValues = null | undefined | false | 0 | 0n | ''
			      const trigger = createEvent<User | FalsyValues>()
			      const result: Event<User> = sample(\{
			        source: trigger,
			        filter: Boolean,
			      \})
			      const resultFn: Event<User> = sample(\{
			        source: trigger,
			        filter: Boolean,
			        fn: (arg: User) => arg,
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        type User = \{name: string\}
			        const trigger = createEvent<User | null>()
			        const target = createStore<User>(\{name: 'alice'\})
			
			        sample(\{
			          source: trigger,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        type User = \{name: string\}
			        const trigger = createEvent<User>()
			        const target = createStore<string>('no')
			
			        sample(\{
			          //@ts-expect-error
			          source: trigger,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Argument of type '\{ source: Event<User>; filter: BooleanConstructor; target: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: User; targetType: string; \}; \}'.
			            Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source should extend target type\\\\"; targets: \{ sourceType: User; targetType: string; \}; \}'.
			          "
			        \`)
			      \})
			      test('any to void (should pass)', () => \{
			        const source = createEvent<\{pass: boolean\}>()
			        const target = createEvent<void>()
			
			        sample(\{
			          source,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			    \})
			  \})
			  describe('sample(\{clock, filter: Boolean\})', () => \{
			    it('returns new event (should pass)', () => \{
			      type User = \{name: string\}
			      const trigger = createEvent<User | null>()
			      const result: Event<User> = sample(\{
			        clock: trigger,
			        filter: Boolean,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('result type mismatch (should fail)', () => \{
			      type User = \{name: string\}
			      const trigger = createEvent<User>()
			
			      //@ts-expect-error
			      const result: Event<string> = sample(\{
			        clock: trigger,
			        filter: Boolean,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Event<User>' is not assignable to type 'Event<string>'.
			          Types of property 'watch' are incompatible.
			            Type '(watcher: (payload: User) => any) => Subscription' is not assignable to type '(watcher: (payload: string) => any) => Subscription'.
			              Types of parameters 'watcher' and 'watcher' are incompatible.
			                Types of parameters 'payload' and 'payload' are incompatible.
			                  Type 'User' is not assignable to type 'string'.
			        "
			      \`)
			    \})
			    describe('support target field', () => \{
			      it('allow to pass target field (should pass)', () => \{
			        type User = \{name: string\}
			        const trigger = createEvent<User | null>()
			        const target = createStore<User>(\{name: 'alice'\})
			
			        sample(\{
			          clock: trigger,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			      test('type mismatch (should fail)', () => \{
			        type User = \{name: string\}
			        const trigger = createEvent<User>()
			        const target = createStore<string>('no')
			
			        sample(\{
			          //@ts-expect-error
			          clock: trigger,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          Argument of type '\{ clock: Event<User>; filter: BooleanConstructor; target: Store<string>; \}' is not assignable to parameter of type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: User; targetType: string; \}; \}'.
			            Object literal may only specify known properties, and 'clock' does not exist in type '\{ error: \\\\"clock should extend target type\\\\"; targets: \{ clockType: User; targetType: string; \}; \}'.
			          "
			        \`)
			      \})
			      test('any to void (should pass)', () => \{
			        const clock = createEvent<\{pass: boolean\}>()
			        const target = createEvent<void>()
			
			        sample(\{
			          clock,
			          filter: Boolean,
			          target,
			        \})
			        expect(typecheck).toMatchInlineSnapshot(\`
			          "
			          no errors
			          "
			        \`)
			      \})
			    \})
			  \})
			\})
			
			describe('filter return validation', () => \{
			  const anyt = createEvent<any>()
			  describe('wrong return', () => \{
			    test('sample(\{source, filter\}) (should fail)', () => \{
			      //@ts-expect-error
			      sample(\{source: anyt, filter: () => 0\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '[\{ source: Event<any>; filter: () => number; \}]' is not assignable to parameter of type '[config: \{ source: Event<any>; clock?: undefined; filter: (src: any) => src is any; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ source: Event<any>; filter: () => number; \}] | [config: ...]'.
			          Type '[\{ source: Event<any>; filter: () => number; \}]' is not assignable to type '[config: \{ source: Event<any>; clock?: undefined; filter: (src: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ source: Event<any>; filter: () => number; \}]'.
			            Type '\{ source: Event<any>; filter: () => number; \}' is not assignable to type '\{ source: Event<any>; clock?: undefined; filter: (src: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ source: Event<any>; filter: () => number; \}'.
			              Type '\{ source: Event<any>; filter: () => number; \}' is not assignable to type '\{ source: Event<any>; clock?: undefined; filter: (src: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        "
			      \`)
			    \})
			    test('sample(\{clock, filter\}) (should fail)', () => \{
			      //@ts-expect-error
			      sample(\{clock: anyt, filter: () => 0\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '[\{ clock: Event<any>; filter: () => number; \}]' is not assignable to parameter of type '[config: \{ clock: Event<any>; source?: undefined; filter: (clk: any) => clk is any; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ clock: Event<any>; filter: () => number; \}] | [config: ...]'.
			          Type '[\{ clock: Event<any>; filter: () => number; \}]' is not assignable to type '[config: \{ clock: Event<any>; source?: undefined; filter: (clk: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ clock: Event<any>; filter: () => number; \}]'.
			            Type '\{ clock: Event<any>; filter: () => number; \}' is not assignable to type '\{ clock: Event<any>; source?: undefined; filter: (clk: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ clock: Event<any>; filter: () => number; \}'.
			              Type '\{ clock: Event<any>; filter: () => number; \}' is not assignable to type '\{ clock: Event<any>; source?: undefined; filter: (clk: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        "
			      \`)
			    \})
			    test('sample(\{source, clock, filter\}) (should fail)', () => \{
			      //@ts-expect-error
			      sample(\{source: anyt, clock: anyt, filter: () => 0\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '[\{ source: Event<any>; clock: Event<any>; filter: () => number; \}]' is not assignable to parameter of type '[config: \{ clock: Event<any>; source: Event<any>; filter: (src: any, clk: any) => src is any; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ source: Event<...>; clock: Event<...>; filter: () => number; \}] | [config: ...]'.
			          Type '[\{ source: Event<any>; clock: Event<any>; filter: () => number; \}]' is not assignable to type '[config: \{ clock: Event<any>; source: Event<any>; filter: (src: any, clk: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ source: Event<...>; clock: Event<...>; filter: () => number; \}]'.
			            Type '\{ source: Event<any>; clock: Event<any>; filter: () => number; \}' is not assignable to type '\{ clock: Event<any>; source: Event<any>; filter: (src: any, clk: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \} & \{ source: Event<...>; clock: Event<...>; filter: () => number; \}'.
			              Type '\{ source: Event<any>; clock: Event<any>; filter: () => number; \}' is not assignable to type '\{ clock: Event<any>; source: Event<any>; filter: (src: any, clk: any) => boolean; target?: undefined; greedy?: boolean | undefined; name?: string | undefined; \}'.
			                The types returned by 'filter(...)' are incompatible between these types.
			                  Type 'number' is not assignable to type 'boolean'.
			        "
			      \`)
			    \})
			  \})
			  describe('boolean return', () => \{
			    test('sample(\{source, filter\}) (should pass)', () => \{
			      sample(\{source: anyt, filter: () => true as boolean\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('sample(\{clock, filter\}) (should pass)', () => \{
			      sample(\{clock: anyt, filter: () => true as boolean\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('sample(\{source, clock, filter\}) (should pass)', () => \{
			      sample(\{source: anyt, clock: anyt, filter: () => true as boolean\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			  describe('boolean subtype return', () => \{
			    test('sample(\{source, filter\}) (should pass)', () => \{
			      sample(\{source: anyt, filter: () => true as true\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('sample(\{clock, filter\}) (should pass)', () => \{
			      sample(\{clock: anyt, filter: () => true as true\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('sample(\{source, clock, filter\}) (should pass)', () => \{
			      sample(\{source: anyt, clock: anyt, filter: () => true as true\})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			\})
			
			describe('any support in arguments inference', () => \{
			  function assertNonNever<T>(val: T): [T] extends [never] ? 'never' : 'ok' \{
			    return val as any
			  \}
			  const anyt = createEvent<any>()
			  test('sample(\{source, filter\}) (should pass)', () => \{
			    sample(\{
			      source: anyt,
			      filter(src) \{
			        const x: 'ok' = assertNonNever(src)
			        return false
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('sample(\{clock, filter\}) (should pass)', () => \{
			    sample(\{
			      clock: anyt,
			      filter(clk) \{
			        const x: 'ok' = assertNonNever(clk)
			        return false
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('sample(\{clock: [clock], filter\}) (should pass)', () => \{
			    sample(\{
			      clock: [anyt],
			      filter(clk) \{
			        const x: 'ok' = assertNonNever(clk)
			        return false
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('sample(\{source, clock, filter\}) (should pass)', () => \{
			    sample(\{
			      source: anyt,
			      clock: anyt,
			      filter(src, clk) \{
			        const x1: 'ok' = assertNonNever(src)
			        const x2: 'ok' = assertNonNever(clk)
			        return false
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('sample(\{source, clock: [clock], filter\}) (should pass)', () => \{
			    sample(\{
			      source: anyt,
			      clock: [anyt],
			      filter(src, clk) \{
			        const x1: 'ok' = assertNonNever(src)
			        const x2: 'ok' = assertNonNever(clk)
			        return false
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			test('sample return type supports union types (should pass)', () => \{
			  const trigger = createEvent<\{a: 1\} | \{a: 2\}>()
			  const allow = createStore<boolean>(false)
			
			  const result: Event<\{a: 1\} | \{a: 2\}> = sample(\{
			    source: trigger,
			    filter: allow,
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('incorrect filter (should fail)', () => \{
			  const trigger = createEvent()
			  const target = createEvent()
			  function factory() \{
			    //@ts-expect-error
			    sample(\{
			      source: trigger,
			      filter: null,
			      target,
			    \})
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '[\{ source: Event<void>; filter: null; target: Event<void>; \}]' is not assignable to parameter of type '[config: never] | [config: never]'.
			      Type '[\{ source: Event<void>; filter: null; target: Event<void>; \}]' is not assignable to type '[config: never]'.
			        Type '\{ source: Event<void>; filter: null; target: Event<void>; \}' is not assignable to type 'never'.
			          The intersection '\{ source: Event<void>; clock?: undefined; filter: (src: void) => boolean; target: Event<void>; greedy?: boolean | undefined; \} & \{ source: Event<void>; filter: null; target: Event<...>; \}' was reduced to 'never' because property 'filter' has conflicting types in some constituents.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\sampleFilter.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(46)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\split.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createEvent,
			  createStore,
			  Event,
			  guard,
			  split,
			  attach,
			  sample,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			it('infer type by given predicate (should pass)', () => \{
			  const event: Event<number | string> = createEvent()
			  const \{onlyNumbers\} = split(event, \{
			    onlyNumbers: (value): value is number => typeof value === 'number',
			  \})
			  const shouldBeOk: Event<number> = onlyNumbers
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('matcher stores / matcher functions (should pass)', () => \{
			  const source: Event<number | string> = createEvent()
			  const firstBool = createStore(true)
			  const firstTarget: Event<number | string> = createEvent()
			  const secondTarget: Event<number | string> = createEvent()
			  const defaultarget: Event<number | string> = createEvent()
			  split(\{
			    source,
			    match: \{
			      a: firstBool,
			      b: e => true,
			    \},
			    cases: \{
			      a: firstTarget,
			      b: secondTarget,
			      __: defaultarget,
			    \},
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('case store (should pass)', () => \{
			  const source: Event<number> = createEvent()
			  const caseStore = createStore<'a' | 'b'>('a')
			  const firstTarget: Event<number> = createEvent()
			  const secondTarget: Event<number> = createEvent()
			  const defaultarget: Event<number> = createEvent()
			  split(\{
			    source,
			    match: caseStore,
			    cases: \{
			      a: firstTarget,
			      b: secondTarget,
			      __: defaultarget,
			    \},
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('case store case mismatch (should fail)', () => \{
			  const source: Event<number> = createEvent()
			  const caseStore = createStore<'a' | 'c'>('a')
			  const firstTarget: Event<number> = createEvent()
			  const secondTarget: Event<number> = createEvent()
			  const defaultarget: Event<number> = createEvent()
			  split(\{
			    //@ts-expect-error
			    source,
			    match: caseStore,
			    cases: \{
			      a: firstTarget,
			      b: secondTarget,
			      __: defaultarget,
			    \},
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Event<number>; match: Store<\\\\"a\\\\" | \\\\"c\\\\">; cases: \{ a: Event<number>; b: Event<number>; __: Event<number>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			    "
			  \`)
			\})
			
			test('case function (should pass)', () => \{
			  const source: Event<number> = createEvent()
			  const firstTarget: Event<number> = createEvent()
			  const secondTarget: Event<number> = createEvent()
			  const defaultarget: Event<number> = createEvent()
			  split(\{
			    source,
			    match: x => (x > 0 ? 'a' : 'b'),
			    cases: \{
			      a: firstTarget,
			      b: secondTarget,
			      __: defaultarget,
			    \},
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('case function case mismatch (should fail)', () => \{
			  const source: Event<number> = createEvent()
			  const firstTarget: Event<number> = createEvent()
			  const secondTarget: Event<number> = createEvent()
			  const defaultarget: Event<number> = createEvent()
			  split(\{
			    //@ts-expect-error
			    source,
			    match: x => (x > 0 ? 'a' : 'c'),
			    cases: \{
			      a: firstTarget,
			      b: secondTarget,
			      __: defaultarget,
			    \},
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Event<number>; match: (x: number) => \\\\"a\\\\" | \\\\"c\\\\"; cases: \{ a: Event<number>; b: Event<number>; __: Event<number>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			    "
			  \`)
			\})
			
			test('event with unknown payload in target (should pass)', () => \{
			  const source = createEvent<string>()
			  const target = createEvent<unknown>()
			
			  split(\{
			    source,
			    match: \{
			      test: value => value === 'ok',
			    \},
			    cases: \{
			      test: target,
			    \},
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('edge case with target (should pass)', () => \{
			  const intervalStore = createStore(Date.now())
			  const filter = createStore(true)
			  const enumType = 3
			  const typeStore = createStore(enumType)
			  const source = guard(\{source: intervalStore, filter\})
			  const caseA = createEvent()
			  const caseB = createEvent()
			
			  split(\{source, match: typeStore, cases: \{[enumType]: caseA, __: caseB\}\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			describe('any to void', () => \{
			  test('void only (should pass)', () => \{
			    const source = createEvent<number>()
			    const \$case = createStore<'a' | 'b'>('a')
			    const aVoid = createEvent()
			    split(\{
			      source,
			      match: \$case,
			      cases: \{
			        a: [aVoid],
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('non-void in same case (should pass)', () => \{
			    const source = createEvent<number>()
			    const \$case = createStore<'a' | 'b'>('a')
			    const aVoid = createEvent()
			    const aNonVoid = createEvent<number>()
			    split(\{
			      source,
			      match: \$case,
			      cases: \{
			        a: [aNonVoid, aVoid],
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('incorrect non-void in same case (should fail)', () => \{
			    const source = createEvent<number>()
			    const \$case = createStore<'a' | 'b'>('a')
			    const aVoid = createEvent()
			    const aNonVoid = createEvent<string>()
			    split(\{
			      //@ts-expect-error
			      source,
			      match: \$case,
			      cases: \{
			        a: [aNonVoid, aVoid],
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<number>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: (Event<void> | Event<string>)[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: number; caseType: string | void; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: number; caseType: string | void; \}'.
			      "
			    \`)
			  \})
			  test('non-void in another case (should pass)', () => \{
			    const source = createEvent<number>()
			    const \$case = createStore<'a' | 'b'>('a')
			    const aVoid = createEvent()
			    const bNonVoid = createEvent<number>()
			    split(\{
			      source,
			      match: \$case,
			      cases: \{
			        a: [aVoid],
			        b: bNonVoid,
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('union type in source', () => \{
			  test('case store (should pass)', () => \{
			    const source: Event<number | string> = createEvent()
			    const \$case = createStore<'a' | 'b'>('a')
			    const firstTarget: Event<number | string> = createEvent()
			    const secondTarget: Event<number | string> = createEvent()
			    const defaultarget: Event<number | string> = createEvent()
			    split(\{
			      source,
			      match: \$case,
			      cases: \{
			        a: firstTarget,
			        b: secondTarget,
			        __: defaultarget,
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('case function (should pass)', () => \{
			    const source: Event<number | string> = createEvent()
			    const firstTarget: Event<number | string> = createEvent()
			    const secondTarget: Event<number | string> = createEvent()
			    const defaultarget: Event<number | string> = createEvent()
			    split(\{
			      source,
			      match: (src): 'a' | 'b' => 'a',
			      cases: \{
			        a: firstTarget,
			        b: secondTarget,
			        __: defaultarget,
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('matcher object (should pass)', () => \{
			    const source: Event<number | string> = createEvent()
			    const firstBool = createStore(true)
			    const firstTarget: Event<number | string> = createEvent()
			    const secondTarget: Event<number | string> = createEvent()
			    const defaultarget: Event<number | string> = createEvent()
			    split(\{
			      source,
			      match: \{
			        a: firstBool,
			        b: e => true,
			      \},
			      cases: \{
			        a: firstTarget,
			        b: secondTarget,
			        __: defaultarget,
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('matcher function with inference', () => \{
			  test('basic case (should pass)', () => \{
			    type A = \{tag: 'a'; value: 0\}
			    type B = \{tag: 'b'; value: 'b'\}
			    const source = createEvent<A | B>()
			    const aFull = createEvent<A>()
			    const aPart = createEvent<\{value: 0\}>()
			    const b = createEvent<\{tag: 'b'\}>()
			    const c = createEvent<A | B>()
			    const defTrigger = createEvent<\{tag: 'a'\} | B>()
			    const \$cFlag = createStore(false)
			    split(\{
			      source,
			      match: \{
			        a: (src): src is A => src.tag === 'a',
			        b: (src): src is B => src.tag === 'b',
			        c: \$cFlag,
			      \},
			      cases: \{
			        a: [aFull, aPart],
			        b,
			        c,
			        __: defTrigger,
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('wrong inference (should fail)', () => \{
			    type A = \{tag: 'a'; value: 0\}
			    type B = \{tag: 'b'; value: 'b'\}
			    const source = createEvent<A | B>()
			    const aFull = createEvent<A>()
			    const aPart = createEvent<\{value: 0\}>()
			    const c = createEvent<A | B>()
			    const defTrigger = createEvent<\{tag: 'a'\} | B>()
			    const \$cFlag = createStore(false)
			    split(\{
			      //@ts-expect-error
			      source,
			      match: \{
			        a: (src): src is B => src.tag === 'b',
			        c: \$cFlag,
			      \},
			      cases: \{
			        a: [aFull, aPart],
			        c,
			        __: defTrigger,
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<A | B>; match: \{ a: (src: A | B) => src is B; c: Store<boolean>; \}; cases: \{ a: (Event<A> | Event<\{ value: 0; \}>)[]; c: Event<A | B>; __: Event<...>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"case should extends type inferred by matcher function\\\\"; incorrectCases: \{ a: \{ caseType: A | \{ value: 0; \}; inferredType: B; \}; \}; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"case should extends type inferred by matcher function\\\\"; incorrectCases: \{ a: \{ caseType: A | \{ value: 0; \}; inferredType: B; \}; \}; \}'.
			      "
			    \`)
			  \})
			\})
			describe('clock cases', () => \{
			  describe('source + clock', () => \{
			    test('unit clock (should pass)', () => \{
			      const clock = createEvent<number>()
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        clock,
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('array clock (should pass)', () => \{
			      const clockA = createEvent<number>()
			      const clockB = createEvent<string>()
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        clock: [clockA, clockB],
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			  \})
			\})
			describe('array cases', () => \{
			  describe('case store', () => \{
			    /** type: source == cases, arrays only */
			
			    test('case name: match == cases, type: source == cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source == cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source == cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\">; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source == cases, array case + unit case */
			
			    test('case name: match == cases, type: source == cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source == cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b' | 'c'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source == cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source > cases, arrays only */
			
			    test('case name: match == cases, type: source > cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source > cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source > cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const \$case = createStore<'a'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; bar: number; \}>; match: Store<\\\\"a\\\\">; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source > cases, array case + unit case */
			
			    test('case name: match == cases, type: source > cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source > cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const \$case = createStore<'a' | 'b' | 'c'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source > cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; bar: number; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source < cases, arrays only */
			
			    test('case name: match == cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a'>('a')
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\">; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source < cases, array case + unit case */
			
			    test('case name: match == cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b' | 'c'>('a')
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\">; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source != cases, arrays only */
			
			    test('case name: match == cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a'>('a')
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\">; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source != cases, array case + unit case */
			
			    test('case name: match == cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b' | 'c'>('a')
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\">; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const \$case = createStore<'a' | 'b'>('a')
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      const c = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \$case,
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: Store<\\\\"a\\\\" | \\\\"b\\\\">; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; c: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        "
			      \`)
			    \})
			  \})
			  describe('case function', () => \{
			    /** type: source == cases, arrays only */
			
			    test('case name: match == cases, type: source == cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source == cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source == cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: (src): 'a' => 'a',
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: \{ foo: 1; \}) => \\\\"a\\\\"; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source == cases, array case + unit case */
			
			    test('case name: match == cases, type: source == cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source == cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' | 'c' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source == cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: \{ foo: 1; \}) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source > cases, arrays only */
			
			    test('case name: match == cases, type: source > cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' => (src.bar > 0 ? 'a' : 'b'),
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source > cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source > cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: (src): 'a' => 'a',
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; bar: number; \}>; match: (src: \{ foo: 1; bar: number; \}) => \\\\"a\\\\"; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source > cases, array case + unit case */
			
			    test('case name: match == cases, type: source > cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source > cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: (src): 'a' | 'b' | 'c' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source > cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; bar: number; \}>; match: (src: \{ foo: 1; bar: number; \}) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source < cases, arrays only */
			
			    test('case name: match == cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' => 'a',
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\"; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			
			    test('source doesnt satisfy cases but match do it (should fail)', () => \{
			      const source = sample(\{
			        clock: createEvent<number | null>(),
			        source: createStore<number | null>(1),
			        fn: (\$value, evtPayload) => (\{a: \$value, b: evtPayload\}),
			      \})
			      const cases = \{
			        write: createEvent<\{a: number; b: number\}>(),
			      \}
			
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          write: src => src.a !== null && src.b !== null,
			        \},
			        cases,
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ a: number | null; b: number | null; \}>; match: \{ write: (src: any) => boolean; \}; cases: \{ write: Event<\{ a: number; b: number; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ a: number | null; b: number | null; \}; caseType: \{ a: number; b: number; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ a: number | null; b: number | null; \}; caseType: \{ a: number; b: number; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			
			    /** type: source < cases, array case + unit case */
			
			    test('case name: match == cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' | 'c' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: \{ foo: 1; \}) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source != cases, arrays only */
			
			    test('case name: match == cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' => 'a',
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\"; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			
			    /** type: source != cases, array case + unit case */
			
			    test('case name: match == cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' | 'c' => 'a',
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      const c = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        //@ts-expect-error src is any
			        match: (src): 'a' | 'b' => 'a',
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: (src: any) => \\\\"a\\\\" | \\\\"b\\\\"; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; c: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			  \})
			  describe('matcher function', () => \{
			    /** type: source == cases, arrays only */
			
			    test('case name: match == cases, type: source == cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source == cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source == cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          a: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: \{ foo: 1; \}) => true; \}; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source == cases, array case + unit case */
			
			    test('case name: match == cases, type: source == cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source == cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			          c: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source == cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: \{ foo: 1; \}) => true; b: (src: \{ foo: 1; \}) => true; \}; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source > cases, arrays only */
			
			    test('case name: match == cases, type: source > cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source > cases, arrays only (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source > cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          a: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; bar: number; \}>; match: \{ a: (src: \{ foo: 1; bar: number; \}) => true; \}; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source > cases, array case + unit case */
			
			    test('case name: match == cases, type: source > cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source > cases, array case + unit case (should pass)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      split(\{
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			          c: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source > cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1; bar: number\}>()
			      const a = createEvent<\{foo: 1\}>()
			      const b = createEvent<\{foo: 1\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; bar: number; \}>; match: \{ a: (src: \{ foo: 1; bar: number; \}) => true; b: (src: \{ foo: 1; bar: number; \}) => true; \}; cases: \{ a: Event<\{ foo: 1; \}>[]; b: Event<\{ foo: 1; \}>; c: Event<...>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source < cases, arrays only */
			
			    test('case name: match == cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source < cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			
			    /** type: source < cases, array case + unit case */
			
			    test('case name: match == cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			          //@ts-expect-error src is any
			          c: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; c: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 1; bar: number; \} | \{ foo: 1; bar: string; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source < cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 1; bar: number\}>()
			      const b = createEvent<\{foo: 1; bar: string\}>()
			      const c = createEvent<\{foo: 1\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          a: src => true,
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: \{ foo: 1; \}) => true; b: (src: \{ foo: 1; \}) => true; \}; cases: \{ a: Event<\{ foo: 1; bar: number; \}>[]; b: Event<\{ foo: 1; bar: string; \}>; c: Event<\{ foo: 1; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\" | \\\\"c\\\\"; got: \\\\"a\\\\" | \\\\"b\\\\"; \}'.
			        "
			      \`)
			    \})
			
			    /** type: source != cases, arrays only */
			
			    test('case name: match == cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source != cases, arrays only (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b: [b],
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			
			    /** type: source != cases, array case + unit case */
			
			    test('case name: match == cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match > cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			          //@ts-expect-error src is any
			          c: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; c: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			    test('case name: match < cases, type: source != cases, array case + unit case (should fail)', () => \{
			      const source = createEvent<\{foo: 1\}>()
			      const a = createEvent<\{foo: 2\}>()
			      const b = createEvent<\{foo: 2\}>()
			      const c = createEvent<\{foo: 2\}>()
			      split(\{
			        //@ts-expect-error
			        source,
			        match: \{
			          //@ts-expect-error src is any
			          a: src => true,
			          //@ts-expect-error src is any
			          b: src => true,
			        \},
			        cases: \{
			          a: [a],
			          b,
			          c,
			        \},
			      \})
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Argument of type '\{ source: Event<\{ foo: 1; \}>; match: \{ a: (src: any) => boolean; b: (src: any) => boolean; \}; cases: \{ a: Event<\{ foo: 2; \}>[]; b: Event<\{ foo: 2; \}>; c: Event<\{ foo: 2; \}>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			          Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"source type should extends cases\\\\"; sourceType: \{ foo: 1; \}; caseType: \{ foo: 2; \} | \{ foo: 2; \} | \{ foo: 2; \}; \}'.
			        Parameter 'src' implicitly has an 'any' type.
			        Parameter 'src' implicitly has an 'any' type.
			        "
			      \`)
			    \})
			  \})
			  test('case store case mismatch (should fail)', () => \{
			    const source: Event<number> = createEvent()
			    const caseStore = createStore<'a' | 'c'>('a')
			    const firstTarget: Event<number> = createEvent()
			    const secondTarget: Event<number> = createEvent()
			    const defaultarget: Event<number> = createEvent()
			    split(\{
			      //@ts-expect-error
			      source,
			      match: caseStore,
			      cases: \{
			        a: [firstTarget],
			        b: [secondTarget],
			        __: [defaultarget],
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<number>; match: Store<\\\\"a\\\\" | \\\\"c\\\\">; cases: \{ a: Event<number>[]; b: Event<number>[]; __: Event<number>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match unit should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			      "
			    \`)
			  \})
			  test('case function case mismatch (should fail)', () => \{
			    const source: Event<number> = createEvent()
			    const firstTarget: Event<number> = createEvent()
			    const secondTarget: Event<number> = createEvent()
			    const defaultarget: Event<number> = createEvent()
			    split(\{
			      //@ts-expect-error
			      source,
			      match: (src): 'a' | 'c' => 'a',
			      cases: \{
			        a: [firstTarget],
			        b: [secondTarget],
			        __: [defaultarget],
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<number>; match: (src: number) => \\\\"a\\\\" | \\\\"c\\\\"; cases: \{ a: Event<number>[]; b: Event<number>[]; __: Event<number>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match function should return case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			      "
			    \`)
			  \})
			  test('matcher function case mismatch (should fail)', () => \{
			    const source: Event<number> = createEvent()
			    const firstTarget: Event<number> = createEvent()
			    const secondTarget: Event<number> = createEvent()
			    const defaultarget: Event<number> = createEvent()
			    split(\{
			      //@ts-expect-error
			      source,
			      match: \{
			        a: src => true,
			        c: src => true,
			      \},
			      cases: \{
			        a: [firstTarget],
			        b: [secondTarget],
			        __: [defaultarget],
			      \},
			    \})
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      Argument of type '\{ source: Event<number>; match: \{ a: (src: number) => true; c: (src: number) => true; \}; cases: \{ a: Event<number>[]; b: Event<number>[]; __: Event<number>[]; \}; \}' is not assignable to parameter of type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			        Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"match object should contain case names\\\\"; need: \\\\"a\\\\" | \\\\"b\\\\"; got: \\\\"a\\\\" | \\\\"c\\\\"; \}'.
			      "
			    \`)
			  \})
			\})
			
			test('split + attach', () => \{
			  const \$number = createStore<number>(0)
			  split(\{
			    source: \$number,
			    match: \{\},
			    cases: \{
			      __: attach(\{
			        source: createStore<any>(null),
			        effect: (_, param: number) => \{\},
			      \}),
			    \},
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type '\{ source: Store<number>; match: \{\}; cases: \{ __: Effect<number, void, Error>; \}; \}' is not assignable to parameter of type '\{ error: \\\\"config should be object with fields \\\\\\\\\\\\"source\\\\\\\\\\\\", \\\\\\\\\\\\"match\\\\\\\\\\\\" and \\\\\\\\\\\\"cases\\\\\\\\\\\\"\\\\"; got: \{ source: Store<number>; match: \{\}; cases: unknown; clock: unknown; \}; \}'.
			      Object literal may only specify known properties, and 'source' does not exist in type '\{ error: \\\\"config should be object with fields \\\\\\\\\\\\"source\\\\\\\\\\\\", \\\\\\\\\\\\"match\\\\\\\\\\\\" and \\\\\\\\\\\\"cases\\\\\\\\\\\\"\\\\"; got: \{ source: Store<number>; match: \{\}; cases: unknown; clock: unknown; \}; \}'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\split.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(96)
    });
    it('effector_effector\\src\\types\\__tests__\\effector\\store.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{
			  createStore,
			  createEvent,
			  createEffect,
			  createStoreObject,
			  restore,
			  combine,
			  Store,
			  Event,
			  CompositeName,
			  kind,
			  sample,
			\} from 'effector'
			
			const typecheck = '\{global\}'
			
			test('createStore', () => \{
			  const createStore_store1: Store<number> = createStore(0)
			  //@ts-expect-error
			  const createStore_store2: Store<string> = createStore(0)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type 'Store<number>' is not assignable to type 'Store<string>'.
			      The types returned by 'getState()' are incompatible between these types.
			        Type 'number' is not assignable to type 'string'.
			    "
			  \`)
			\})
			test('createStoreObject', () => \{
			  const ev = createEvent()
			  const a = createStore('')
			  const b = createStore(0)
			  const c = createStoreObject(\{a, b\})
			  c.on(ev, (state, payload) => state)
			  c.reset(ev)
			  c.off(ev)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('combine', () => \{
			  const ev = createEvent()
			  const a = createStore('')
			  const b = createStore(0)
			  const c = combine(a, b, (a, b) => a + b)
			  c.on(ev, (state, payload) => state)
			  c.reset(ev)
			  c.off(ev)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('restore', () => \{
			  const eff = createEffect<\{foo: number\}, \{bar: string\}, any>()
			  const foo = restore(eff, \{bar: ''\})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#(properties)', () => \{
			  const store = createStore(0)
			  const kind1: kind = store.kind
			  const shortName: string = store.shortName
			  const compositeName: CompositeName = store.compositeName
			  const defaultState: number = store.defaultState
			
			  const computed = store.map(() => 'hello')
			  const kind2: kind = computed.kind
			  const shortName1: string = computed.shortName
			  const compositeName1: CompositeName = computed.compositeName
			  const defaultState1: string = computed.defaultState
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#getState', () => \{
			  const store = createStore(0)
			  const state: number = store.getState()
			
			  const computed = store.map(() => 'hello')
			  const state1: string = computed.getState()
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#map', () => \{
			  const store = createStore(0)
			  const computed = store.map(() => 'hello')
			
			  const map_check1: Store<string> = computed
			  //@ts-expect-error
			  const map_check2: Store<number> = computed
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type 'Store<string>' is not assignable to type 'Store<number>'.
			    "
			  \`)
			\})
			
			describe('#reset', () => \{
			  test('simple case', () => \{
			    const event = createEvent()
			    const store = createStore(0)
			    store.reset(event)
			    const computed = store.map(() => 'hello')
			
			    computed.reset(event)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('.reset(a, b)', () => \{
			    const a = createEvent<string>()
			    const b = createEvent<number>()
			    const store = createStore(0)
			    store.reset(a, b)
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('.reset([a, b])', () => \{
			    const a = createEvent<string>()
			    const b = createEvent<number>()
			    const store = createStore(0)
			    store.reset([a, b])
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe("#reinit", () => \{
			  test("simple case", () => \{
			    const \$store = createStore<Array<number>>([]);
			    const eventPush = createEvent<number>();
			    \$store.on(eventPush, (store, item) => [...store, item]);
			    eventPush(1);
			    eventPush(2);
			    eventPush(3);
			    const before = \$store.getState().length;
			    expect(before).toBe(3);
			    \$store.reinit?.();
			
			    const after = \$store.getState().length;
			    expect(after).toBe(0);
			
			    \$store.off(eventPush);
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`);
			  \})
			\});
			
			test('#on', () => \{
			  const event = createEvent()
			  const store = createStore(0)
			  store.on(event, (state, payload) => state)
			  const computed = store.map(() => 'hello')
			
			  computed.on(event, (state, payload) => state)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#on triggers[] (should pass)', () => \{
			  const event = createEvent<string>()
			  const another = createStore('')
			  const store = createStore(0)
			
			  store.on([event, another], (state, payload) => state)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#on triggers[] non-intersecting types (should pass)', () => \{
			  const event = createEvent<number>()
			  const another = createStore('')
			  const store = createStore(0)
			
			  store.on([event, another], (state, payload) => state)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('.on(sample()) inline (should pass)', () => \{
			  const store = createStore('111')
			  const event = createEvent<any>()
			  const noInline = sample(\{source: store, clock: event\})
			  const anotherStore = createStore('123').on(
			    sample(\{source: store, clock: event\}),
			    (_, str) => str,
			  )
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#off', () => \{
			  const event = createEvent()
			  const store = createStore(0)
			  store.off(event)
			  const computed = store.map(() => 'hello')
			
			  computed.off(event)
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#subscribe', () => \{
			  const event = createEvent()
			  const store = createStore(0)
			  // @ts-ignore I don't know type
			  store.subscribe(() => \{\})
			  const computed = store.map(() => 'hello')
			  // @ts-ignore I don't know type
			  computed.subscribe(() => \{\})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#watch', () => \{
			  const event: Event<number> = createEvent()
			  const store = createStore(0)
			  store.watch((state, payload) => \{
			    const store_watch_check1: number = state
			    const store_watch_check2: typeof undefined = payload
			  \})
			  store.watch(event, (state, payload) => \{
			    const store_watchBy_check1: number = state
			    const store_watchBy_check2: number = payload
			  \})
			  const computed = store.map(() => 'hello')
			  computed.watch((state, payload) => \{
			    const store_watchComputed_check1: string = state
			    const store_watchComputed_check2: typeof undefined = payload
			  \})
			  computed.watch(event, (state, payload) => \{
			    const store_watchByComputed_check1: string = state
			    const store_watchByComputed_check2: number = payload
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('#thru', () => \{
			  const event = createEvent()
			  const store = createStore(0)
			  const result = store.thru(store => \{
			    const thru_check1: Store<number> = store
			    return thru_check1
			  \})
			
			  const computed = store.map(() => 'hello')
			  const result1 = computed.thru(store => \{
			    const thru_computed_check1: Store<string> = store
			    return thru_computed_check1
			  \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('unsafe widening (should fail)', () => \{
			  //@ts-expect-error
			  const \$values: Store<\{
			    page: number
			    limit: number
			    [key: string]: any
			  \}> = createStore(\{page: 0, limit: 0, id: 1\})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Type 'Store<\{ page: number; limit: number; id: number; \}>' is not assignable to type 'Store<\{ [key: string]: any; page: number; limit: number; \}>'.
			      Types of property 'updates' are incompatible.
			        Type 'Event<\{ page: number; limit: number; id: number; \}>' is not assignable to type 'Event<\{ [key: string]: any; page: number; limit: number; \}>'.
			          Types of parameters 'payload' and 'payload' are incompatible.
			            Type '\{ [key: string]: any; page: number; limit: number; \}' is not assignable to type '\{ page: number; limit: number; id: number; \}'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector\\store.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(20)
    });
    it('effector_effector\\src\\types\\__tests__\\effector-react\\effectorReact.test.tsx', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import * as React from 'react'
			import \{createStore, createEvent, createEffect\} from 'effector'
			import \{
			  createComponent,
			  createGate,
			  useGate,
			  useEvent,
			  useUnit,
			\} from 'effector-react'
			
			const typecheck = '\{global\}'
			
			test('createComponent', () => \{
			  const ImplicitObject = createComponent(
			    \{
			      a: createStore<number>(0),
			      b: createStore<number>(1),
			    \},
			    (props, state) => \{
			      const createComponent_implicitObject_check1: number = state.a
			      const createComponent_implicitObject_check2: number = state.b
			      return null
			    \},
			  )
			  const Store = createComponent(createStore(0), (props, state) => \{
			    const createComponent_createStore_check1: number = state
			    return null
			  \})
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('createGate', () => \{
			  const Foo = createGate<number>('foo')
			  const Bar = createGate<\{a: number\}>('bar')
			  const Baz = createGate<number | null>('baz', null)
			
			  const Component = () => \{
			    useGate(Foo, 1)
			    useGate(Bar, 1)
			    useGate(Bar, \{a: 1\})
			    useGate(Bar, \{\})
			
			    useGate(Baz, null)
			    useGate(Baz, 1)
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type 'number' is not assignable to parameter of type '\{ a: number; \}'.
			    Argument of type '\{\}' is not assignable to parameter of type '\{ a: number; \}'.
			      Property 'a' is missing in type '\{\}' but required in type '\{ a: number; \}'.
			    "
			  \`)
			\})
			
			test('useEvent of Event', () => \{
			  const runEvent: () => (payload: number) => number = () =>
			    useEvent(createEvent<number>())
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useEvent of Event<void>', () => \{
			  const runEvent: () => () => void = () => useEvent(createEvent<void>())
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useEvent of Effect', () => \{
			  const runEffect: () => (payload: number) => Promise<string> = () =>
			    useEvent(createEffect<number, string, Error>())
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useEvent of Effect<void, unknown, Error>', () => \{
			  const runEffect: () => () => Promise<unknown> = () =>
			    useEvent(createEffect<void, unknown, Error>())
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useEvent of object', () => \{
			  const handlers: () => \{
			    foo: (payload: number) => number
			    bar: (payload: number) => Promise<string>
			  \} = () =>
			    useEvent(\{
			      foo: createEvent<number>(),
			      bar: createEffect<number, string, Error>(),
			    \})
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useEvent of array', () => \{
			  const handlers: () => [
			    (payload: number) => number,
			    (payload: number) => Promise<string>,
			  ] = () =>
			    useEvent([createEvent<number>(), createEffect<number, string, Error>()])
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useUnit should support single units', () => \{
			  const a = createEvent<number>()
			  const \$b = createStore(0)
			  const cFx = createEffect((p: number) => p.toString())
			
			  const Comp = () => \{
			    const aEv: (p: number) => number = useUnit(a)
			    const b: number = useUnit(\$b)
			    const cEff: (p: number) => Promise<string> = useUnit(cFx)
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			  \`)
			\})
			test('useUnit should support array shape', () => \{
			  const Comp = () => \{
			    const handlers: [
			      number,
			      (payload: number) => number,
			      (payload: number) => Promise<string>,
			    ] = useUnit([
			      createStore(0),
			      createEvent<number>(),
			      createEffect<number, string, Error>(),
			    ])
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			  \`)
			\})
			test('useUnit should support object shape', () => \{
			  const Comp = () => \{
			    const handlers: \{
			      foo: (payload: number) => number
			      bar: (payload: number) => Promise<string>
			      baz: string
			    \} = useUnit(\{
			      baz: createStore(''),
			      foo: createEvent<number>(),
			      bar: createEffect<number, string, Error>(),
			    \})
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			test('useUnit should not allow non-unit values', () => \{
			  const Comp = () => \{
			    const handlers: \{
			      foo: (payload: number) => number
			      bar: (payload: number) => Promise<string>
			      baz: string
			      wrong: string
			    \} = useUnit(\{
			      baz: createStore(''),
			      foo: createEvent<number>(),
			      bar: createEffect<number, string, Error>(),
			      wrong: 'plain string',
			    \})
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    No overload matches this call.
			      The last overload gave the following error.
			        Type 'string' is not assignable to type 'Store<any> | Effect<any, any, any> | Event<any>'.
			    "
			  \`)
			\})
			
			test('useUnit should correctly resolve void events and effects in shape mode', () => \{
			  const event = createEvent<void>()
			  const effect = createEffect(() => \{\})
			
			  function x(callback: (e: unknown) => void | Promise<void>) \{\}
			
			  const Comp = () => \{
			    const \{runEvent\} = useUnit(\{runEvent: event\})
			    const \{runEffect\} = useUnit(\{runEffect: effect\})
			    const [runEvent1] = useUnit([event])
			    const [runEffect1] = useUnit([effect])
			
			    x(runEvent)
			    x(runEffect)
			    x(runEvent1)
			    x(runEffect1)
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useUnit should correctly resolve any type except void events and effects in shape mode', () => \{
			  const event = createEvent<boolean>()
			  const effect = createEffect((_: boolean) => _)
			
			  function x(callback: (e: boolean) => boolean | Promise<boolean>) \{\}
			
			  const Comp = () => \{
			    const \{runEvent\} = useUnit(\{runEvent: event\})
			    const \{runEffect\} = useUnit(\{runEffect: effect\})
			    const [runEvent1] = useUnit([event])
			    const [runEffect1] = useUnit([effect])
			
			    x(runEvent)
			    x(runEffect)
			    x(runEvent1)
			    x(runEffect1)
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('useUnit should not allow to call void events with arguments', () => \{
			  const event = createEvent()
			
			  const Comp = () => \{
			    const \{runEvent\} = useUnit(\{runEvent: event\})
			    const [runEvent1] = useUnit([event])
			
			    runEvent(1)
			    runEvent1('')
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 0 arguments, but got 1.
			    Expected 0 arguments, but got 1.
			    "
			  \`)
			\})
			
			test('useUnit should not allow to call void effects with arguments', () => \{
			  const effect = createEffect(() => \{\})
			
			  const Comp = () => \{
			    const \{runEffect\} = useUnit(\{runEffect: effect\})
			    const [runEffect1] = useUnit([effect])
			
			    runEffect(1)
			    runEffect1('')
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Expected 0 arguments, but got 1.
			    Expected 0 arguments, but got 1.
			    "
			  \`)
			\})
			
			test('useUnit should not allow wrong types for events or effects with arguments', () => \{
			  const event = createEvent<number>()
			  const effect = createEffect((_: string) => _)
			
			  const constEvent = createEvent<42>()
			  const constEffect = createEffect((_: 42) => _)
			
			  const Comp = () => \{
			    const \{runEvent\} = useUnit(\{runEvent: event\})
			    const \{runEffect\} = useUnit(\{runEffect: effect\})
			    const [runEvent1] = useUnit([event])
			    const [runEffect1] = useUnit([effect])
			    const \{runConstEvent\} = useUnit(\{runConstEvent: constEvent\})
			    const \{runConstEffect\} = useUnit(\{runConstEffect: constEffect\})
			
			    runEvent('')
			    runEffect(1)
			    runEvent1('')
			    runEffect1(1)
			    runConstEvent(0)
			    runConstEffect(\{\})
			  \}
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    Argument of type 'string' is not assignable to parameter of type 'number'.
			    Argument of type 'number' is not assignable to parameter of type 'string'.
			    Argument of type 'string' is not assignable to parameter of type 'number'.
			    Argument of type 'number' is not assignable to parameter of type 'string'.
			    Argument of type '0' is not assignable to parameter of type '42'.
			    Argument of type '\{\}' is not assignable to parameter of type '42'.
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector-react\\effectorReact.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(17)
    });
    it('effector_effector\\src\\types\\__tests__\\effector-react\\useList.test.tsx', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import React from 'react'
			
			import \{createStore\} from 'effector'
			import \{useList\} from 'effector-react'
			
			const typecheck = '\{global\}'
			
			type User = \{
			  username: string
			  email: string
			  bio: string
			\}
			test('plain array support', () => \{
			  const users = createStore<User[]>([
			    \{
			      username: 'alice',
			      email: 'alice@example.com',
			      bio: '. . .',
			    \},
			    \{
			      username: 'bob',
			      email: 'bob@example.com',
			      bio: '~/ - /~',
			    \},
			    \{
			      username: 'carol',
			      email: 'carol@example.com',
			      bio: '- - -',
			    \},
			  ])
			  const UserList = () => useList(users, (\{username\}) => <p>\{username\}</p>)
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('readonly array support', () => \{
			  const users = createStore<ReadonlyArray<User>>([
			    \{
			      username: 'alice',
			      email: 'alice@example.com',
			      bio: '. . .',
			    \},
			    \{
			      username: 'bob',
			      email: 'bob@example.com',
			      bio: '~/ - /~',
			    \},
			    \{
			      username: 'carol',
			      email: 'carol@example.com',
			      bio: '- - -',
			    \},
			  ])
			  const UserList = () => useList(users, (\{username\}) => <p>\{username\}</p>)
			
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test('getKey support', () => \{
			  const users = createStore<User[]>([
			    \{
			      username: 'alice',
			      email: 'alice@example.com',
			      bio: '. . .',
			    \},
			    \{
			      username: 'bob',
			      email: 'bob@example.com',
			      bio: '~/ - /~',
			    \},
			    \{
			      username: 'carol',
			      email: 'carol@example.com',
			      bio: '- - -',
			    \},
			  ])
			
			  const UserList = () =>
			    useList(users, \{
			      getKey: (\{email\}) => email,
			      fn: (\{username\}, key: string) => (
			        <p>
			          user: \{username\}, email: \{key\}
			        </p>
			      ),
			    \})
			  const App = () => (
			    <div>
			      <UserList />
			    </div>
			  )
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			
			test("usage as components' return value", () => \{
			  const users = createStore<User[]>([
			    \{
			      username: 'alice',
			      email: 'alice@example.com',
			      bio: '. . .',
			    \},
			    \{
			      username: 'bob',
			      email: 'bob@example.com',
			      bio: '~/ - /~',
			    \},
			    \{
			      username: 'carol',
			      email: 'carol@example.com',
			      bio: '- - -',
			    \},
			  ])
			  const UserList = () => useList(users, (\{username\}) => <p>\{username\}</p>)
			  const App = () => (
			    <div>
			      <UserList />
			    </div>
			  )
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector-react\\useList.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('effector_effector\\src\\types\\__tests__\\effector-react\\useStoreMap.test.tsx', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import React from 'react'
			
			import \{createStore\} from 'effector'
			import \{useStoreMap\} from 'effector-react'
			
			const typecheck = '\{global\}'
			
			type User = \{
			  username: string
			  email: string
			  bio: string
			\}
			type Props = \{
			  id: number
			  field: keyof User
			\}
			describe('useStoreMap', () => \{
			  const users = createStore<User[]>([
			    \{
			      username: 'alice',
			      email: 'alice@example.com',
			      bio: '. . .',
			    \},
			    \{
			      username: 'bob',
			      email: 'bob@example.com',
			      bio: '~/ - /~',
			    \},
			    \{
			      username: 'carol',
			      email: 'carol@example.com',
			      bio: '- - -',
			    \},
			  ])
			  describe('infer type with \`as const\`', () => \{
			    it('should pass typecheck', () => \{
			      const UserProperty = (\{id, field\}: Props) => \{
			        const value = useStoreMap(\{
			          store: users,
			          keys: [id, field] as const,
			          fn: (users, [id, field]) => users[id][field] || null,
			        \})
			        return <div>\{value\}</div>
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    it('should fail typecheck', () => \{
			      const UserProperty = (\{id, field\}: Props) => \{
			        const value = useStoreMap(\{
			          store: users,
			          keys: [id] as const,
			          //@ts-expect-error
			          fn: (users, [id, field]) => null,
			        \})
			        return <div>\{value\}</div>
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Tuple type 'readonly [number]' of length '1' has no element at index '1'.
			        "
			      \`)
			    \})
			  \})
			  describe('infer type with \`as [explicit, tuple]\`', () => \{
			    it('should pass typecheck', () => \{
			      const UserProperty = (\{id, field\}: Props) => \{
			        const value = useStoreMap(\{
			          store: users,
			          keys: [id, field] as [number, keyof User],
			          fn: (users, [id, field]) => users[id][field] || null,
			        \})
			        return <div>\{value\}</div>
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    it('should fail typecheck', () => \{
			      const UserProperty = (\{id, field\}: Props) => \{
			        const value = useStoreMap(\{
			          store: users,
			          //@ts-expect-error
			          keys: [id, field] as [number, keyof User],
			          fn: (users, [id, field]: [number, number]) => null,
			        \})
			        //@ts-expect-error
			        return <div>\{value\}</div>
			      \}
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        No overload matches this call.
			          Overload 1 of 3, '(opts: \{ readonly store: Store<User[]>; readonly keys: [number, number]; readonly fn: (state: User[], keys: [number, number]) => null | undefined; readonly updateFilter?: ((update: null, current: null) => boolean) | undefined; readonly defaultValue: null; readonly forceScope?: boolean | undefined; \}): null', gave the following error.
			            Type '[number, keyof User]' is not assignable to type '[number, number]'.
			              Type at position 1 in source is not compatible with type at position 1 in target.
			                Type 'string' is not assignable to type 'number'.
			                  Type 'string' is not assignable to type 'number'.
			          Overload 2 of 3, '(opts: \{ readonly store: Store<User[]>; readonly keys: [number, number]; readonly fn: (state: User[], keys: [number, number]) => null; readonly updateFilter?: ((update: null, current: null) => boolean) | undefined; readonly forceScope?: boolean | undefined; \}): null', gave the following error.
			            Type '[number, keyof User]' is not assignable to type '[number, number]'.
			        Type 'unknown' is not assignable to type 'ReactNode'.
			        "
			      \`)
			    \})
			  \})
			  it('can infer tuple type without \`as\`', () => \{
			    const UserProperty = (\{id, field\}: Props) => \{
			      const value = useStoreMap(\{
			        store: users,
			        keys: [id, field],
			        fn: (users, [id, field]) => users[id][field] || null,
			      \})
			      return <div>\{value\}</div>
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			test('useStoreMap(store, fn)', () => \{
			  const store = createStore(\{foo: 0, bar: 'ok'\})
			  const Foo = () => \{
			    const value = useStoreMap(store, (\{foo\}) => foo)
			    return <div>\{value\}</div>
			  \}
			  expect(typecheck).toMatchInlineSnapshot(\`
			    "
			    no errors
			    "
			  \`)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector-react\\useStoreMap.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('effector_effector\\src\\types\\__tests__\\effector-vue\\effectorVue.test.ts', () => {
        const sourceCode = `
			import \{createStore\} from 'effector'
			import Vue from 'vue'
			import \{createComponent\} from 'effector-vue'
			
			const typecheck = '\{global\}'
			
			describe('vue extend', () => \{
			  describe('object type', () => \{
			    test('should pass typecheck', () => \{
			      const \$counter = createStore(1)
			
			      Vue.extend(\{
			        effector: \{
			          counter: \$counter,
			        \},
			        methods: \{
			          twice() \{
			            return this.counter * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('should fail typecheck', () => \{
			      const \$name = createStore('effector')
			
			      Vue.extend(\{
			        effector: \{
			          name: \$name,
			        \},
			        methods: \{
			          twice() \{
			            return this.name * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
			        "
			      \`)
			    \})
			  \})
			
			  describe('function', () => \{
			    test('arrow function should pass typecheck', () => \{
			      const \$counter = createStore(1)
			
			      Vue.extend(\{
			        effector: () => \$counter,
			        methods: \{
			          twice() \{
			            return this.state * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			
			    test('arrow function should fail typecheck', () => \{
			      const \$name = createStore('effector')
			
			      Vue.extend(\{
			        effector: () => \$name,
			        methods: \{
			          twice() \{
			            return this.state * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
			        "
			      \`)
			    \})
			
			    test('function should pass typecheck', () => \{
			      // Typescript type inference don't works as expected
			      // https://github.com/microsoft/TypeScript/issues/38623
			      const \$counter = createStore(1)
			
			      Vue.extend(\{
			        effector() \{
			          return \$counter
			        \},
			        methods: \{
			          twice() \{
			            return this.state * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			
			    test('function should fail typecheck', () => \{
			      // Typescript type inference don't works as expected
			      // https://github.com/microsoft/TypeScript/issues/38623
			      const \$name = createStore('effector')
			
			      Vue.extend(\{
			        effector() \{
			          return \$name
			        \},
			        methods: \{
			          twice() \{
			            return this.state * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
			        "
			      \`)
			    \})
			  \})
			
			  describe('directly', () => \{
			    test('should pass typecheck', () => \{
			      const \$counter = createStore(1)
			
			      Vue.extend(\{
			        effector: \$counter,
			        methods: \{
			          twice() \{
			            return this.state * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			
			    test('should fail typecheck', () => \{
			      const \$name = createStore('effector')
			
			      Vue.extend(\{
			        effector: \$name,
			        methods: \{
			          twice() \{
			            return this.state * 2
			          \},
			        \},
			      \})
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
			        "
			      \`)
			    \})
			  \})
			
			  describe('createComponent', () => \{
			    test('should pass typecheck', () => \{
			      const \$counter = createStore(1)
			
			      createComponent(
			        \{
			          methods: \{
			            twice() \{
			              return this.\$counter * 2
			            \},
			          \},
			        \},
			        \{\$counter\},
			      )
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			
			    test('should fail typecheck', () => \{
			      const \$name = createStore('effector')
			
			      createComponent(
			        \{
			          methods: \{
			            twice() \{
			              return this.\$name * 2
			            \},
			          \},
			        \},
			        \{\$name\},
			      )
			
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
			        "
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\effector-vue\\effectorVue.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(10)
    });
    it('effector_effector\\src\\types\\__tests__\\forest\\index.test.ts', () => {
        const sourceCode = `
			/* eslint-disable no-unused-vars */
			import \{createStore, Store\} from 'effector'
			import \{h, spec, list, using, remap\} from 'forest'
			
			const typecheck = '\{global\}'
			
			describe('text', () => \{
			  test('correct case (should pass)', () => \{
			    const store = createStore<\{value: string\} | null>(null)
			    function run() \{
			      using(document.body, () => \{
			        h('div', \{
			          text: store.map(data => data && data.value),
			        \})
			      \})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('incorrect value (should fail)', () => \{
			    const store = createStore<\{value: string\} | null>(null)
			    function run() \{
			      using(document.body, () => \{
			        //@ts-expect-error
			        h('div', \{
			          text: store.map(data => data),
			        \})
			      \})
			    \}
			    expect(dropInconsistentLine(typecheck)).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        Overload 1 of 2, '(tag: DOMTag, spec: \{ attr?: PropertyMap | undefined; data?: PropertyMap | undefined; text?: DOMProperty | AttributeStoreInput | (DOMProperty | AttributeStoreInput)[] | undefined; ... 5 more ...; fn?: (() => void) | undefined; \}): void', gave the following error.
			          Type 'Store<\{ value: string; \} | null>' is not assignable to type 'DOMProperty | AttributeStoreInput | (DOMProperty | AttributeStoreInput)[] | undefined'.
			            Type 'Store<\{ value: string; \} | null>' is not assignable to type 'AttributeStoreInput'.
			              Types of property 'map' are incompatible.
			                Type '\{ <T>(fn: (state: \{ value: string; \} | null, lastState?: T | undefined) => T): Store<T>; <T>(fn: (state: \{ value: string; \} | null, lastState: T) => T, firstState: T): Store<...>; \}' is not assignable to type '\{ <T>(fn: (state: string | number | boolean | null, lastState?: T | undefined) => T): Store<T>; <T>(fn: (state: string | number | boolean | null, lastState: T) => T, firstState: T): Store<...>; \}'.
			                  Types of parameters 'fn' and 'fn' are incompatible.
			                    Types of parameters 'state' and 'state' are incompatible.
			                      Type '\{ value: string; \} | null' is not assignable to type 'string | number | boolean | null'.
			                        Type '\{ value: string; \}' is not assignable to type 'string | number | boolean | null'.
			        Overload 2 of 2, '(tag: DOMTag, cb: () => void): void', gave the following error.
			          Argument of type '\{ text: Store<\{ value: string; \} | null>; \}' is not assignable to parameter of type '() => void'.
			            Object literal may only specify known properties, and 'text' does not exist in type '() => void'.
			      "
			    \`)
			    function dropInconsistentLine(text: string) \{
			      return text
			        .split(\`\\n\`)
			        .filter(line => !line.includes(\`to type 'true'\`))
			        .join(\`\\n\`)
			    \}
			  \})
			  test('value subtyping (should pass)', () => \{
			    const store = createStore<'foo' | 'bar'>('foo')
			    function run() \{
			      using(document.body, () => \{
			        h('div', \{
			          text: store,
			        \})
			      \})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			\})
			
			describe('dom tag typecheck', () => \{
			  test('should pass', () => \{
			    function run() \{
			      using(document.body, () => \{
			        h('div', () => \{\})
			      \})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  test('should fail', () => \{
			    function run() \{
			      using(document.body, () => \{
			        h('damn', () => \{\})
			      \})
			    \}
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      No overload matches this call.
			        Overload 1 of 2, '(tag: DOMTag, spec: \{ attr?: PropertyMap | undefined; data?: PropertyMap | undefined; text?: DOMProperty | AttributeStoreInput | (DOMProperty | AttributeStoreInput)[] | undefined; ... 5 more ...; fn?: (() => void) | undefined; \}): void', gave the following error.
			          Argument of type '\\\\"damn\\\\"' is not assignable to parameter of type 'DOMTag'.
			        Overload 2 of 2, '(tag: DOMTag, cb: () => void): void', gave the following error.
			          Argument of type '\\\\"damn\\\\"' is not assignable to parameter of type 'DOMTag'.
			      "
			    \`)
			  \})
			\})
			
			describe('remap', () => \{
			  test('single key', () => \{
			    const shape = createStore(\{foo: 'ok', bar: 0, baz: null\})
			    const foo: Store<string> = remap(shape, 'foo')
			    expect(typecheck).toMatchInlineSnapshot(\`
			      "
			      no errors
			      "
			    \`)
			  \})
			  describe('array of keys', () => \{
			    test('without "as const" (should pass)', () => \{
			      const shape = createStore(\{foo: 'ok', bar: 0, baz: null\})
			      const [foo, bar]: [Store<string>, Store<number>] = remap(shape, [
			        'foo',
			        'bar',
			      ])
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('with "as const" (should pass)', () => \{
			      const shape = createStore(\{foo: 'ok', bar: 0, baz: null\})
			      const [foo, bar]: readonly [Store<string>, Store<number>] = remap(shape, [
			        'foo',
			        'bar',
			      ] as const)
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        no errors
			        "
			      \`)
			    \})
			    test('incorrect types (should fail)', () => \{
			      const shape = createStore(\{foo: 'ok', bar: 0, baz: null\})
			      const [foo, bar] = remap(shape, ['foo', 'bar'])
			      const foo1: Store<number> = foo
			      const foo2: Store<string> = foo
			      const bar1: Store<number> = bar
			      const bar2: Store<string> = bar
			      expect(typecheck).toMatchInlineSnapshot(\`
			        "
			        Type 'Store<string>' is not assignable to type 'Store<number>'.
			        Type 'Store<number>' is not assignable to type 'Store<string>'.
			        "
			      \`)
			    \})
			  \})
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\types\\__tests__\\forest\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\vue\\__tests__\\createGate.test.ts', () => {
        const sourceCode = `
			/* eslint-disable react-hooks/rules-of-hooks */
			import \{shallowMount\} from 'vue-test-utils-next'
			import \{
			  useStore,
			  useVModel,
			  useGate,
			  createGate,
			\} from 'effector-vue/composition'
			import \{reactive, ref, nextTick\} from 'vue-next'
			import \{allSettled, createEvent, createStore, fork\} from 'effector'
			
			jest.mock('vue', () => require('vue-next'))
			
			it('plain gate', async () => \{
			  const Gate = createGate()
			  expect(Gate.status.getState()).toBeFalsy()
			  const wrapper = shallowMount(\{
			    template: \`<div></div>\`,
			    setup() \{
			      useGate(Gate)
			    \},
			  \})
			  expect(Gate.status.getState()).toBeTruthy()
			  wrapper.unmount()
			  expect(Gate.status.getState()).toBeFalsy()
			\})
			
			it('close event should be called without arguments to Gate', async () => \{
			  const spyClose = jest.fn()
			
			  const Gate = createGate()
			
			  Gate.close.watch(spyClose);
			
			  const wrapper = shallowMount(\{
			    template: \`<div></div>\`,
			    setup() \{
			      useGate(Gate)
			    \},
			  \})
			
			  wrapper.unmount()
			
			  expect(spyClose).toHaveBeenCalled()
			\})
			
			test('works without babel plugin', () => \{
			  const Gate3 = \{_: createGate\}._(\{name: 'name', defaultState: \{state: 1\}\})
			  const Gate4 = \{_: createGate\}._(\{
			    name: 'name',
			    defaultState: \{state: 1\},
			    sid: 'custom-sid',
			  \})
			
			  expect(Gate3.state.shortName).toMatchInlineSnapshot(\`"name.state"\`)
			  expect(Gate3.state.getState()).toEqual(\{state: 1\})
			
			  expect(Gate4.state.shortName).toMatchInlineSnapshot(\`"name.state"\`)
			  expect(Gate4.state.sid).toMatchInlineSnapshot(\`"custom-sid"\`)
			\})
			
			it('gate with props', () => \{
			  const Gate = createGate(\{
			    defaultState: \{
			      meet: 'Hello world',
			    \},
			  \})
			
			  expect(Gate.state.getState()).toEqual(\{
			    meet: 'Hello world',
			  \})
			
			  const wrapper = shallowMount(\{
			    template: \`<div></div>\`,
			    setup() \{
			      useGate(Gate, () => (\{
			        meet: 'Hello Vue Gate',
			      \}))
			    \},
			  \})
			
			  expect(Gate.state.getState()).toEqual(\{
			    meet: 'Hello Vue Gate',
			  \})
			  wrapper.unmount()
			  expect(Gate.state.getState()).toEqual(\{
			    meet: 'Hello world',
			  \})
			\})
			
			it('update props to gate from [ref]', async () => \{
			  const Gate = createGate(\{
			    defaultState: \{
			      meet: 'Hello world',
			    \},
			  \})
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <button @click="handleClick">Click</button>
			    \`,
			    setup() \{
			      const meet = ref('Hello Vue Gate')
			      const handleClick = () => (meet.value = 'Hello effector')
			      useGate(Gate, () => (\{meet: meet.value\}))
			      return \{handleClick\}
			    \},
			  \})
			
			  expect(Gate.state.getState()).toEqual(\{
			    meet: 'Hello Vue Gate',
			  \})
			
			  await wrapper.find('button').trigger('click')
			
			  expect(Gate.state.getState()).toEqual(\{
			    meet: 'Hello effector',
			  \})
			\})
			
			it('update props to gate from [reactive]', async () => \{
			  const Gate = createGate(\{
			    defaultState: \{
			      meet: 'Hello world',
			    \},
			  \})
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <button @click="handleClick">Click</button>
			    \`,
			    setup() \{
			      const obj = reactive(\{
			        meet: 'Hello Vue Gate',
			      \})
			      const handleClick = () => (obj.meet = 'Hello effector')
			      useGate(Gate, () => obj)
			      return \{handleClick\}
			    \},
			  \})
			
			  expect(Gate.state.getState()).toEqual(\{
			    meet: 'Hello Vue Gate',
			  \})
			
			  await wrapper.find('button').trigger('click')
			
			  expect(Gate.state.getState()).toEqual(\{
			    meet: 'Hello effector',
			  \})
			\})
			
			it('works with effector store', async () => \{
			  const Gate = createGate()
			  const \$user = createStore('John Doe')
			  const updated = createEvent()
			  \$user.on(updated, () => 'Alan Doe')
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <button @click="updated">Click</button>
			      </div>
			    \`,
			    setup() \{
			      const user = useStore(\$user)
			      useGate(Gate, () => user)
			      return \{
			        updated,
			      \}
			    \},
			  \})
			
			  expect(Gate.state.getState()).toBe('John Doe')
			  await wrapper.find('button').trigger('click')
			  expect(Gate.state.getState()).toBe('Alan Doe')
			\})
			
			it('gate used before useStore hook', async () => \{
			  const Gate = createGate()
			  const \$loading = createStore(false).on(Gate.open, () => true)
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        \{\{loading\}\}
			      </div>
			    \`,
			    setup() \{
			      useGate(Gate)
			      const loading = useStore(\$loading)
			
			      return \{
			        loading,
			      \}
			    \},
			  \})
			
			  await nextTick()
			  expect(wrapper.vm.\$el.innerHTML).toBeTruthy()
			\})
			
			it('gate used before useStore hook', async () => \{
			  const Gate = createGate()
			  const \$isEnabled = createStore(false).on(Gate.open, () => true)
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <input
			          type="checkbox"
			          v-model="isEnabled"
			          data-test="checkbox"
			        >
			      </div>
			    \`,
			    setup() \{
			      useGate(Gate)
			      const isEnabled = useVModel(\$isEnabled)
			
			      return \{
			        isEnabled,
			      \}
			    \},
			  \})
			
			  await nextTick()
			  // @ts-ignore
			  expect(wrapper.find('[data-test="checkbox"]').element.checked).toBeTruthy()
			\})
			
			it('State should be updated if open event triggered manually', async () => \{
			  const Gate = createGate(\{defaultState: 'empty'\})
			  const scope = fork()
			
			  await allSettled(Gate.open, \{scope, params: 'data'\})
			
			  expect(scope.getState(Gate.state)).toBe('data')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\vue\\__tests__\\createGate.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(10)
    });
    it('effector_effector\\src\\vue\\__tests__\\index.test.ts', () => {
        const sourceCode = `
			import \{shallowMount, createLocalVue, mount\} from 'vue-test-utils-legacy'
			import \{createStore, createEvent\} from 'effector'
			import Vue from 'vue'
			import \{VueEffector, createComponent\} from 'effector-vue'
			
			const localVue = createLocalVue()
			localVue.use(VueEffector)
			
			test('show counter', () => \{
			  const \$counter = createStore(0)
			  const component = Vue.extend(\{
			    template: '<div>\{\{ counter \}\}</div>',
			    effector: \{
			      counter: \$counter,
			    \},
			  \})
			  const wrapper = shallowMount(component, \{
			    localVue,
			  \})
			  expect(wrapper.vm.counter).toBe(0)
			  expect(wrapper.html()).toBe('<div>0</div>')
			\})
			
			test('is store its [key] state', async () => \{
			  const \$counter = createStore(0)
			  const evt = createEvent()
			
			  \$counter.on(evt, state => state + 1)
			
			  const wrapper = shallowMount(
			    \{
			      template: '<div>\{\{ state \}\}</div>',
			      effector: \$counter,
			    \},
			    \{localVue\},
			  )
			
			  evt()
			
			  await wrapper.vm.\$nextTick()
			
			  // @ts-ignore
			  expect(wrapper.vm.state).toBe(1)
			\})
			
			test('show counter with createComponent', () => \{
			  const \$counter = createStore(0)
			  const componentWithWrapper = createComponent(
			    \{
			      name: 'ComponentWithWrapper',
			      template: '<div>\{\{ counter \}\}</div>',
			    \},
			    \{counter: \$counter\},
			  )
			
			  const wrapper = shallowMount(componentWithWrapper, \{
			    localVue,
			  \})
			
			  expect(wrapper.vm.counter).toBe(0)
			  expect(wrapper.html()).toBe('<div>0</div>')
			\})
			
			test('vue \$watch', async () => \{
			  const \$counter = createStore(0)
			  const mockCallback = jest.fn()
			
			  const component = createComponent(
			    \{
			      template: '<div>\{\{ counter \}\}</div>',
			      created() \{
			        this.\$watch('counter', function counter() \{
			          mockCallback()
			        \})
			      \},
			    \},
			    \{counter: \$counter\},
			  )
			  const wrapper = shallowMount(component, \{
			    localVue,
			  \})
			
			  expect(wrapper.vm.counter).toBe(0)
			
			  //@ts-ignore
			  \$counter.setState(1)
			  await localVue.nextTick()
			
			  expect(wrapper.vm.counter).toBe(1)
			  expect(mockCallback.mock.calls.length).toBe(1)
			\})
			
			test('test SID if pass event to effector object', async () => \{
			  const evt = createEvent()
			  const mockCallback = jest.fn()
			
			  const component = createComponent(
			    \{
			      template: '<div>\{\{ evt \}\}</div>',
			      watch: \{
			        evt() \{
			          mockCallback()
			        \},
			      \},
			    \},
			    \{evt\},
			  )
			
			  const wrapper = shallowMount(component, \{
			    localVue,
			  \})
			
			  evt()
			  // @ts-ignore
			  await wrapper.vm.\$nextTick()
			  expect(mockCallback.mock.calls.length).toBe(1)
			\})
			
			test('vue component watch option', async () => \{
			  const \$counter = createStore(0)
			  const mockCallback = jest.fn()
			
			  const component = createComponent(
			    \{
			      template: '<div>\{\{ counter \}\}</div>',
			      watch: \{
			        counter() \{
			          mockCallback()
			        \},
			      \},
			    \},
			    \{counter: \$counter\},
			  )
			  const wrapper = shallowMount(component, \{
			    localVue,
			  \})
			
			  expect(wrapper.vm.counter).toBe(0)
			
			  //@ts-ignore
			  \$counter.setState(1)
			  await localVue.nextTick()
			
			  expect(wrapper.vm.counter).toBe(1)
			  expect(mockCallback.mock.calls.length).toBe(1)
			\})
			
			test('is v-model works correct with state key on input', () => \{
			  const expected = 'John Doe'
			
			  const \$fullname = createStore('')
			  const component = Vue.extend(\{
			    template: \`<div><input v-model="state" data-input></div>\`,
			    effector: \$fullname,
			  \})
			
			  const wrapper = shallowMount(component, \{
			    localVue,
			  \})
			
			  wrapper.find('[data-input]').setValue(expected)
			
			  // @ts-ignore
			  expect(wrapper.vm.state).toBe(expected)
			\})
			
			test('is v-model works correct with custom key on input', () => \{
			  const expected = 'John Doe'
			
			  const \$fullname = createStore('')
			  const component = Vue.extend(\{
			    template: \`<div><input v-model="\$fullname" data-input></div>\`,
			    effector: \{
			      \$fullname,
			    \},
			  \})
			
			  const wrapper = shallowMount(component, \{
			    localVue,
			  \})
			
			  wrapper.find('[data-input]').setValue(expected)
			
			  // @ts-ignore
			  expect(wrapper.vm.\$fullname).toBe(expected)
			\})
			
			test('is v-model works with custom component', () => \{
			  const expected = 'John Doe'
			
			  const child = Vue.extend(\{
			    name: 'child',
			    template: \`<div></div>\`,
			    props: \{
			      value: String,
			    \},
			    methods: \{
			      handleChange() \{
			        this.\$emit('input', expected)
			      \},
			    \},
			  \})
			
			  const \$fullname = createStore('')
			  const component = Vue.extend(\{
			    template: \`
			      <div>
			        <child v-model="\$fullname"/>
			      </div>
			    \`,
			
			    components: \{
			      child,
			    \},
			
			    effector: \{
			      \$fullname,
			    \},
			  \})
			
			  const wrapper = mount(component, \{
			    localVue,
			  \})
			
			  // @ts-ignore
			  wrapper.findComponent(\{name: 'child'\}).vm.handleChange()
			
			  // @ts-ignore
			  expect(wrapper.vm.\$fullname).toBe(expected)
			\})
			
			test('non v-model usage support', async () => \{
			  const changeEvent = createEvent()
			  const someEvt = createEvent()
			
			  const \$store = createStore('')
			    .on(changeEvent, (_, value) => value)
			    .on(someEvt, () => 'some-value')
			
			  const component = Vue.extend(\{
			    template: \`
			      <div id="app">
			        <input id="input" :value="value" @input="(e) => changeEvent(e.target.value)" />
			        <button id="btn" @click="someEvt">set some-value</button>
			      </div>
			    \`,
			    name: 'App',
			    effector: \{
			      value: \$store,
			    \},
			    methods: \{
			      changeEvent,
			      someEvt,
			    \},
			  \})
			
			  const wrapper = mount(component, \{
			    localVue,
			  \})
			  const input = wrapper.element.querySelector('#input')! as HTMLInputElement
			  const btn = wrapper.element.querySelector('#btn')! as HTMLButtonElement
			  btn.click()
			
			  await wrapper.vm.\$nextTick()
			
			  expect(\$store.getState()).toBe('some-value')
			  expect(input.value).toBe('some-value')
			\})
			
			test('change value in array from UI via v-model', async () => \{
			
			  const handleChange = createEvent<number>()
			
			  const \$users = createStore<\{name: string; selected: boolean\}[]>([
			    \{name: 'Alan', selected: false\},
			    \{name: 'Criss', selected: false\},
			    \{name: 'John', selected: false\},
			  ])
			
			  \$users.on(handleChange, (state, payload) => \{
			    const idx = state.findIndex((_, i) => i === payload);
			    const s = [...state];
			
			    s[idx].selected = !s[idx].selected;
			    return s;
			  \})
			
			  const component = Vue.extend(\{
			    template: \`
			      <div>
			        <label
			          v-for="(user, key) in \$users"
			          :key="key"
			        >
			        <input
			          type="checkbox"
			          :value="user"
			          @change="handleChange(key)"
			          data-test="checkbox"
			        >
			          \{\{user.name\}\}
			        </label>
			      </div>
			    \`,
			
			    effector: \{
			      \$users
			    \},
			
			    methods: \{
			      handleChange
			    \}
			  \})
			
			  const wrapper = mount(component, \{
			    localVue
			  \})
			  const checkbox = wrapper.find('[data-test="checkbox"]')
			
			  await checkbox.setChecked()
			
			  expect(\$users.getState()[0].selected).toBeTruthy()
			\})
			
			test('change value in array from event via v-model', async () => \{
			
			  const handleChange = createEvent<number>()
			
			  const \$users = createStore<\{name: string; selected: boolean\}[]>([
			    \{name: 'Alan', selected: false\},
			    \{name: 'Criss', selected: false\},
			    \{name: 'John', selected: false\},
			  ])
			
			  \$users.on(handleChange, (state, payload) => \{
			    const idx = state.findIndex((_, i) => i === payload);
			    const s = [...state];
			
			    s[idx].selected = !s[idx].selected;
			    return s;
			  \})
			
			  const component = Vue.extend(\{
			    template: \`
			      <div>
			        <label
			          v-for="(user, key) in \$users"
			          :key="key"
			        >
			        <input
			          type="checkbox"
			          :value="user"
			          @change="handleChange(key)"
			          data-test="checkbox"
			        >
			          \{\{user.name\}\}
			        </label>
			
			        <button @click="handleChange(0)" data-test="btn">
			          Change
			        </button>
			      </div>
			    \`,
			
			    effector: \{
			      \$users
			    \},
			
			    methods: \{
			      handleChange
			    \}
			  \})
			
			  const wrapper = mount(component, \{
			    localVue
			  \})
			  const btn = wrapper.find('[data-test="btn"]')
			  await btn.trigger('click');
			
			  expect(\$users.getState()[0].selected).toBeTruthy()
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\vue\\__tests__\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('effector_effector\\src\\vue\\__tests__\\optionsApi.test.ts', () => {
        const sourceCode = `
			import \{defineComponent\} from 'vue-next'
			import \{mount, shallowMount\} from 'vue-test-utils-next'
			import \{createEvent, createStore\} from 'effector'
			
			import \{VueEffector\} from '../optionsApi'
			
			jest.mock('vue', () => require('vue-next'))
			
			console.error = jest.fn()
			
			beforeEach(() => \{
			  // @ts-ignore
			  console.error.mockClear()
			\})
			
			const globalOptions = \{
			  global: \{
			    plugins: [VueEffector],
			  \},
			\}
			
			test('show counter', () => \{
			  const counter\$ = createStore(0)
			  const component = defineComponent(\{
			    template: \`<div>\{\{counter\$\}\}</div>\`,
			    effector() \{
			      return \{
			        counter\$,
			      \}
			    \},
			  \})
			
			  const wrapper = shallowMount(component, \{
			    ...globalOptions,
			  \})
			
			  expect(wrapper.vm.counter\$).toBe(0)
			  expect(wrapper.html()).toBe('<div>0</div>')
			\})
			
			test('test SID if pass event to effector object', async () => \{
			  const evt = createEvent()
			  const mockCallback = jest.fn()
			
			  const component = defineComponent(\{
			    template: '<div>\{\{ evt \}\}</div>',
			    effector() \{
			      return \{
			        evt,
			      \}
			    \},
			    watch: \{
			      evt() \{
			        mockCallback()
			      \},
			    \},
			  \})
			
			  const wrapper = shallowMount(component, \{
			    ...globalOptions,
			  \})
			
			  evt()
			  await wrapper.vm.\$nextTick()
			
			  expect(mockCallback.mock.calls.length).toBe(1)
			\})
			
			test('vue component watch option', async () => \{
			  const counter\$ = createStore(0)
			  const mockCallback = jest.fn()
			
			  const component = defineComponent(\{
			    template: '<div>\{\{ counter\$ \}\}</div>',
			    effector() \{
			      return \{
			        counter\$,
			      \}
			    \},
			    watch: \{
			      counter\$() \{
			        mockCallback()
			      \},
			    \},
			  \})
			
			  const wrapper = shallowMount(component, \{
			    ...globalOptions,
			  \})
			
			  expect(wrapper.vm.counter\$).toBe(0)
			
			  //@ts-ignore
			  counter\$.setState(1)
			  await wrapper.vm.\$nextTick()
			
			  expect(wrapper.vm.counter\$).toBe(1)
			  expect(mockCallback.mock.calls.length).toBe(1)
			\})
			
			test('is v-model works correct with input', () => \{
			  const expected = 'John Doe'
			
			  const fullname\$ = createStore('')
			  const component = defineComponent(\{
			    template: \`<div><input v-model="fullname\$" data-input></div>\`,
			    effector() \{
			      return \{
			        fullname\$: \{
			          value: fullname\$,
			          vModel: true,
			        \},
			      \}
			    \},
			  \})
			
			  const wrapper = shallowMount(component, \{
			    ...globalOptions,
			  \})
			
			  wrapper.find('[data-input]').setValue(expected)
			
			  // @ts-ignore
			  expect(wrapper.vm.fullname\$).toBe(expected)
			\})
			
			test('is v-model works with custom component', async () => \{
			  const expected = 'John Doe'
			
			  const child = defineComponent(\{
			    name: 'child',
			    template: \`<div></div>\`,
			    methods: \{
			      handleChange() \{
			        this.\$emit('update:modelValue', expected)
			      \},
			    \},
			  \})
			
			  const fullname\$ = createStore('')
			  const component = defineComponent(\{
			    template: \`
			      <div>
			        <child v-model="fullname\$"/>
			      </div>
			    \`,
			
			    components: \{
			      child,
			    \},
			
			    effector() \{
			      return \{
			        fullname\$: \{
			          value: fullname\$,
			          vModel: true,
			        \},
			      \}
			    \},
			  \})
			
			  const wrapper = mount(component, \{
			    ...globalOptions,
			  \})
			
			  wrapper.findComponent(\{name: 'child'\}).vm.handleChange()
			  expect(wrapper.vm.fullname\$).toBe(expected)
			\})
			
			test('non v-model usage support', async () => \{
			  const changeEvent = createEvent()
			  const someEvt = createEvent()
			
			  const store\$ = createStore('')
			    .on(changeEvent, (_, value) => value)
			    .on(someEvt, () => 'some-value')
			
			  const component = defineComponent(\{
			    template: \`
			      <div id="app">
			        <input id="input" :value="store\$" @input="(e) => changeEvent(e.target.value)" />
			        <button id="btn" @click="someEvt">set some-value</button>
			      </div>
			    \`,
			    name: 'App',
			    effector() \{
			      return \{
			        store\$,
			      \}
			    \},
			    methods: \{
			      changeEvent,
			      someEvt,
			    \},
			  \})
			
			  const wrapper = mount(component, \{
			    ...globalOptions,
			  \})
			  const input = wrapper.element.querySelector('#input')! as HTMLInputElement
			  const btn = wrapper.element.querySelector('#btn')! as HTMLButtonElement
			  btn.click()
			
			  await wrapper.vm.\$nextTick()
			
			  expect(store\$.getState()).toBe('some-value')
			  expect(input.value).toBe('some-value')
			\})
			
			test('change value in array from UI via v-model', async () => \{
			  const handleChange = createEvent<number>()
			
			  const users\$ = createStore<\{name: string; selected: boolean\}[]>([
			    \{name: 'Alan', selected: false\},
			    \{name: 'Criss', selected: false\},
			    \{name: 'John', selected: false\},
			  ])
			
			  users\$.on(handleChange, (state, payload) => \{
			    const idx = state.findIndex((_, i) => i === payload)
			    const s = [...state]
			
			    s[idx].selected = !s[idx].selected
			    return s
			  \})
			
			  const component = defineComponent(\{
			    template: \`
			      <div>
			        <label
			          v-for="(user, key) in users\$"
			          :key="key"
			        >
			        <input
			          type="checkbox"
			          :value="user"
			          @change="handleChange(key)"
			          data-test="checkbox"
			        >
			          \{\{user.name\}\}
			        </label>
			      </div>
			    \`,
			
			    effector() \{
			      return \{
			        users\$,
			      \}
			    \},
			
			    methods: \{
			      handleChange,
			    \},
			  \})
			
			  const wrapper = mount(component, \{
			    ...globalOptions,
			  \})
			  const checkbox = wrapper.find('[data-test="checkbox"]')
			  // @ts-ignore
			  await checkbox.setChecked()
			
			  expect(users\$.getState()[0].selected).toBeTruthy()
			\})
			
			test('change value in array from event via v-model', async () => \{
			  const handleChange = createEvent<number>()
			
			  const users\$ = createStore<\{name: string; selected: boolean\}[]>([
			    \{name: 'Alan', selected: false\},
			    \{name: 'Criss', selected: false\},
			    \{name: 'John', selected: false\},
			  ])
			
			  users\$.on(handleChange, (state, payload) => \{
			    const idx = state.findIndex((_, i) => i === payload)
			    const s = [...state]
			
			    s[idx].selected = !s[idx].selected
			    return s
			  \})
			
			  const component = defineComponent(\{
			    template: \`
			      <div>
			        <label
			          v-for="(user, key) in users\$"
			          :key="key"
			        >
			        <input
			          type="checkbox"
			          :value="user"
			          @change="handleChange(key)"
			          data-test="checkbox"
			        >
			          \{\{user.name\}\}
			        </label>
			
			        <button @click="handleChange(0)" data-test="btn">
			          Change
			        </button>
			      </div>
			    \`,
			
			    effector() \{
			      return \{
			        users\$,
			      \}
			    \},
			
			    methods: \{
			      handleChange,
			    \},
			  \})
			
			  const wrapper = mount(component, \{
			    ...globalOptions,
			  \})
			  const btn = wrapper.find('[data-test="btn"]')
			  await btn.trigger('click')
			
			  expect(users\$.getState()[0].selected).toBeTruthy()
			\})
			
			test('effector store is readonly for UI', async () => \{
			  const counter\$ = createStore(0)
			
			  const component = defineComponent(\{
			    template: \`<div></div>\`,
			    effector() \{
			      return \{
			        counter\$,
			      \}
			    \},
			    methods: \{
			      handleChange() \{
			        // @ts-ignore
			        this.counter\$ = 15
			      \},
			    \},
			  \})
			  const wrapper = shallowMount(component, \{
			    ...globalOptions,
			  \})
			
			  wrapper.vm.handleChange()
			  await wrapper.vm.\$nextTick()
			
			  expect(console.error).toHaveBeenCalledTimes(1)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\vue\\__tests__\\optionsApi.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\vue\\__tests__\\useStore.test.ts', () => {
        const sourceCode = `
			/* eslint-disable react-hooks/rules-of-hooks */
			import \{shallowMount\} from 'vue-test-utils-next'
			import \{useStore\} from 'effector-vue/composition'
			import \{createEvent, createStore\} from 'effector'
			
			jest.mock('vue', () => require('vue-next'))
			
			it('list of primitive values rendered correct', () => \{
			  const length = 3
			  const \$numbers = createStore(Array.from(\{length\}, (_, idx) => idx))
			  const wrapper = shallowMount(\{
			    template: \`
			      <ul id="app">
			        <li v-for="(n, key) in numbers" :key="key" data-test="item">\{\{n\}\}</li>
			      </ul>
			    \`,
			    setup() \{
			      const numbers = useStore(\$numbers)
			      return \{numbers\}
			    \}
			  \})
			  expect(wrapper.findAll('[data-test="item"]')).toHaveLength(length)
			\})
			
			it('add new item and re-render list', async () => \{
			  const userAdded = createEvent()
			  const \$users = createStore([\{name: 'John', surname: 'Doe'\}])
			
			  \$users.on(userAdded, (state) => [...state, \{name: 'Alan', surname: 'Doe'\}])
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <ul id="app">
			        <li v-for="(item, key) in users" :key="key" data-test="item">\{\{item.name\}\}</li>
			      </ul>
			    \`,
			    setup() \{
			      const users = useStore(\$users)
			      return \{users\}
			    \}
			  \})
			  userAdded()
			
			  await wrapper.vm.\$nextTick()
			  expect(wrapper.findAll('[data-test="item"]')).toHaveLength(2)
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\vue\\__tests__\\useStore.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('effector_effector\\src\\vue\\__tests__\\useStoreMap.test.ts', () => {
        const sourceCode = `
			import \{useStoreMap, useStore\} from 'effector-vue/composition'
			import \{createEvent, createStore\} from 'effector'
			import \{mount, shallowMount\} from 'vue-test-utils-next'
			import \{ defineComponent, nextTick, ref \} from 'vue-next'
			
			jest.mock('vue', () => require('vue-next'))
			
			it("should render correct", async () => \{
			  const userRemove = createEvent<string>()
			  const userAgeChange = createEvent<\{nickname: string; age: number\}>()
			  const \$users = createStore<Record<string, \{age: number; name: string\}>>(\{
			    alex: \{age: 20, name: 'Alex'\},
			    john: \{age: 30, name: 'John'\},
			  \})
			  const \$userNames = createStore(['alex', 'john'])
			
			  \$userNames.on(userRemove, (list, username) =>
			    list.filter(item => item !== username),
			  )
			  \$users
			    .on(userRemove, (users, nickname) => \{
			      const upd = \{...users\}
			      delete upd[nickname]
			      return upd
			    \})
			    .on(userAgeChange, (users, \{nickname, age\}) => (\{
			      ...users,
			      [nickname]: \{...users[nickname], age\},
			    \}))
			
			  const Card = defineComponent(\{
			    props: \{
			      nickname: \{
			        type: String,
			        required: true
			      \},
			    \},
			    setup(props) \{
			      const user = useStoreMap(
			        \{
			          store: \$users,
			          keys: () => props.nickname,
			          fn: (users, nickname) => users[nickname],
			        \},
			      )
			      return \{user\}
			    \},
			    template: \`
			      <div>\{\{user.name\}\}:\{\{user.age\}\}</div>
			    \`
			  \})
			
			  const wrapper = mount(\{
			    components: \{
			      Card,
			    \},
			    setup() \{
			      const userNames = useStore(\$userNames)
			      return \{userNames\}
			    \},
			    template: \`
			      <div>
			        <Card v-for="(name, key) in userNames" :key="key" :nickname="name" data-test="card" />
			      </div>
			    \`
			  \})
			
			  expect(wrapper.findAllComponents('[data-test="card"]').map(v => v.text()).join('')).toBe("Alex:20John:30")
			
			  userAgeChange(\{nickname: 'john', age: 40 \})
			
			  await nextTick()
			
			  expect(wrapper.findAllComponents('[data-test="card"]').map(v => v.text()).join('')).toBe("Alex:20John:40")
			
			  userRemove("alex")
			
			  await nextTick()
			  expect(wrapper.findAllComponents('[data-test="card"]').map(v => v.text()).join('')).toBe("John:40")
			\})
			
			it('defaultValue support', async () => \{
			  const store = createStore(['Vue', 'React', "Angular"])
			  let target = ref("Vue")
			
			  const wrapper = shallowMount(\{
			    setup() \{
			      const framework = useStoreMap(\{
			        store,
			        keys: () => target.value,
			        fn: (state, target) => state.find(t => t === target),
			        defaultValue: "Solid",
			      \})
			
			      return \{framework\}
			    \},
			    template: \`
			      <div>
			        \{\{framework\}\}
			      </div>
			    \`
			  \})
			
			  expect(wrapper.text()).toBe('Vue')
			
			  target.value = "Ember"
			
			  await nextTick()
			
			  expect(wrapper.text()).toBe('Solid')
			\})
			
			test('updateFilter support', async () => \{
			  const update = createEvent<number>()
			  const store = createStore(0).on(update, (_, x) => x)
			
			  const wrapper = shallowMount(\{
			    setup() \{
			      const n = useStoreMap(\{
			        store,
			        fn: state => state,
			        updateFilter: (x) => x % 2 === 0,
			      \})
			
			      return \{n\}
			    \},
			    template: \`
			      <div>
			        \{\{n\}\}
			      </div>
			    \`
			  \})
			
			  expect(wrapper.text()).toBe('0')
			
			  update(1)
			
			  await nextTick()
			
			  expect(wrapper.text()).toBe('0')
			
			  update(2)
			
			  await nextTick()
			
			  expect(wrapper.text()).toBe('2')
			
			  update(3)
			
			  await nextTick()
			
			  expect(wrapper.text()).toBe('2')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\vue\\__tests__\\useStoreMap.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('effector_effector\\src\\vue\\__tests__\\useVModel.test.ts', () => {
        const sourceCode = `
			/* eslint-disable react-hooks/rules-of-hooks */
			import \{useVModel\} from 'effector-vue/composition'
			import \{createEvent, createStore, restore\} from 'effector'
			import \{shallowMount\} from 'vue-test-utils-next'
			
			jest.mock('vue', () => require('vue-next'))
			
			it('updated value of input if store changed from outside', async () => \{
			  const updated = createEvent()
			  const \$user = createStore(\{
			    skills: [
			      \{name: 'HTML', points: 10\}
			    ]
			  \})
			
			  \$user
			    .on(updated, (state) => (\{...state, skills: [\{name: 'HTML', points: 20\}]\}))
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <input v-model="user.skills[0].points" data-test="skills.points">
			      </div>
			    \`,
			    setup() \{
			      const user = useVModel(\$user)
			      user.value.skills
			      return \{user\}
			    \}
			  \})
			  await wrapper.find('[data-test="skills.points"]').setValue(15)
			  expect(\$user.getState()).toEqual(\{
			    skills: [\{name: 'HTML', points: '15'\}]
			  \})
			  updated()
			
			  await wrapper.vm.\$nextTick()
			  // @ts-ignore
			  expect(wrapper.find('[data-test="skills.points"]').element.value).toBe('20')
			\})
			
			it('[v-model] works correct with scalar values', async () => \{
			  const \$username = createStore('')
			  const wrapper = shallowMount(\{
			    template: \`
			      <div><input v-model="username" data-test="field"></div>
			    \`,
			    setup() \{
			      const username = useVModel(\$username)
			      return \{username\}
			    \}
			  \})
			  await wrapper.find('[data-test="field"]').setValue('John Doe')
			  expect(\$username.getState()).toBe('John Doe')
			\})
			
			it('[v-model] works correct with objects', async () => \{
			  const \$user = createStore(\{
			    name: '',
			    surname: '',
			  \})
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <input v-model="user.name" data-test="name">
			        <input v-model="user.surname" data-test="surname">
			      </div>
			    \`,
			    setup() \{
			      const user = useVModel(\$user)
			      return \{user\}
			    \}
			  \})
			
			  await wrapper.find('[data-test="name"]').setValue('John')
			  await wrapper.find('[data-test="surname"]').setValue('Doe')
			  expect(\$user.getState()).toEqual(\{
			    name: 'John',
			    surname: 'Doe',
			  \})
			\})
			
			it('reset useVModel', async () => \{
			  const model = \{
			    name: '',
			    surname: '',
			  \}
			  const reset = createEvent()
			  const \$user = createStore(model).reset(reset)
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <input v-model="user.name" data-test="name">
			        <input v-model="user.surname" data-test="surname">
			      </div>
			    \`,
			    setup() \{
			      const user = useVModel(\$user)
			      return \{user\}
			    \}
			  \})
			
			  await wrapper.find('[data-test="name"]').setValue('John')
			  await wrapper.find('[data-test="surname"]').setValue('Doe')
			  reset()
			  await wrapper.vm.\$nextTick()
			  expect(\$user.getState()).toEqual(model)
			\})
			
			it('[v-model] works correct with checkboxes (like vue-3 way)', async () => \{
			  const \$skills = createStore([])
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <input type="checkbox" v-model="skills" data-test="skills" value="HTML">
			      <input type="checkbox" v-model="skills" data-test="skills" value="CSS">
			      <input type="checkbox" v-model="skills" data-test="skills" value="JS">
			    \`,
			    setup() \{
			      const skills = useVModel(\$skills)
			      return \{skills\}
			    \}
			  \})
			
			  await wrapper.findAll('[data-test="skills"]')[0].setValue()
			  await wrapper.findAll('[data-test="skills"]')[1].setValue()
			  await wrapper.findAll('[data-test="skills"]')[2].setValue()
			  expect(\$skills.getState()).toEqual(['HTML', 'CSS', 'JS'])
			\})
			
			it('[v-model] works correct with radio (like vue-3 way)', async () => \{
			  const \$gender = createStore('male')
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <input type="radio" name="gender" v-model="gender" data-test="gender" value="female">
			      <input type="radio" name="gender" v-model="gender" data-test="gender" value="male">
			    \`,
			    setup() \{
			      const gender = useVModel(\$gender)
			      return \{gender\}
			    \}
			  \})
			
			  await wrapper.find('[data-test="gender"]').setValue()
			  expect(\$gender.getState()).toEqual('female')
			\})
			
			it('[v-model] default values rendered correct when passing object with Store values', async () => \{
			  const \$user = \{
			    name: createStore('John'),
			    surname: createStore('Doe'),
			  \}
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <input v-model="user.name" data-test="name">
			        <input v-model="user.surname" data-test="surname">
			      </div>
			    \`,
			    setup() \{
			      const user = useVModel(\$user)
			
			      return \{user\}
			    \}
			  \})
			
			  const nameInput = wrapper.find('[data-test="name"]').element as any
			  const surnameInput = wrapper.find('[data-test="surname"]').element as any
			
			  expect(nameInput.value).toBe('John')
			  expect(surnameInput.value).toBe('Doe')
			\})
			
			it('[v-model] changed deep value', async () => \{
			  const updated = createEvent()
			  const \$user = createStore(\{
			    skills: [
			      \{name: 'HTML', points: 10\}
			    ]
			  \})
			
			  \$user
			    .on(updated, (state) => (\{...state, skills: [\{name: 'HTML', points: 20\}]\}))
			
			  const userForm = \{
			    base: \$user
			  \}
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <input v-model="user.base.skills[0].points" data-test="skills.points">
			      </div>
			    \`,
			    setup() \{
			      const user = useVModel(userForm)
			
			      return \{user\}
			    \}
			  \})
			  await wrapper.find('[data-test="skills.points"]').setValue(15)
			
			  expect(\$user.getState()).toEqual(\{
			    skills: [\{name: 'HTML', points: '15'\}]
			  \})
			
			  updated()
			
			  await wrapper.vm.\$nextTick()
			  // @ts-ignore
			  expect(wrapper.find('[data-test="skills.points"]').element.value).toBe('20')
			\})
			
			it('[v-model] change each store value separately', async () => \{
			  const nameChanged = createEvent<string>()
			  const surnameChanged = createEvent<string>()
			
			  const \$name = restore(nameChanged, 'John')
			  const \$surname = restore(surnameChanged, 'Doe')
			
			  const \$user = \{
			    name: \$name,
			    surname: \$surname,
			  \}
			
			  const wrapper = shallowMount(\{
			    template: \`
			      <div>
			        <input v-model="user.name" data-test="name">
			        <input v-model="user.surname" data-test="surname">
			      </div>
			    \`,
			    setup() \{
			      const user = useVModel(\$user)
			
			      return \{user\}
			    \}
			  \})
			
			  const nameInput = wrapper.find('[data-test="name"]').element as any
			  const surnameInput = wrapper.find('[data-test="surname"]').element as any
			
			  expect(nameInput.value).toBe('John')
			  expect(surnameInput.value).toBe('Doe')
			
			  await wrapper.find('[data-test="name"]').setValue('Alan')
			  await wrapper.find('[data-test="surname"]').setValue('Boe')
			
			  expect(\$name.getState()).toEqual('Alan')
			  expect(\$surname.getState()).toEqual('Boe')
			
			  nameChanged('John')
			  surnameChanged('Doe')
			
			  await wrapper.vm.\$nextTick()
			
			  expect(nameInput.value).toBe('John')
			  expect(surnameInput.value).toBe('Doe')
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\vue\\__tests__\\useVModel.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('effector_effector\\src\\vue\\__tests__\\VueSSRPlugin.test.ts', () => {
        const sourceCode = `
			import \{fork\} from 'effector';
			import \{ mount, config \} from "vue-test-utils-next"
			import \{ getScope \} from '../lib/get-scope';
			
			import \{ VueSSRPlugin \} from '../ssr/VueSSRPlugin';
			
			jest.mock('vue', () => require('vue-next'))
			
			it('check default scope name', () => \{
			  const scope = fork()
			
			  config.global.plugins = [VueSSRPlugin(\{scope\})]
			
			  const wrapper = mount(\{
			    template: \`
			      <div>\{\{scopeName\}\}</div>
			    \`,
			    setup() \{
			      const \{scopeName\} = getScope()
			      return \{
			        scopeName
			      \}
			    \}
			  \});
			
			  expect(wrapper.vm.scopeName).toBe("root");
			\})
			
			it('set custom scope name', () => \{
			  const scope = fork()
			
			  config.global.plugins = [VueSSRPlugin(\{scope, scopeName: "my-custom-scope-name"\})]
			
			  const wrapper = mount(\{
			    template: \`
			      <div>\{\{scopeName\}\}</div>
			    \`,
			    setup() \{
			      const \{scopeName\} = getScope()
			      return \{
			        scopeName
			      \}
			    \}
			  \});
			
			  expect(wrapper.vm.scopeName).toBe("my-custom-scope-name");
			\})
			`

		const tests = extractFromSource(sourceCode, 'effector_effector\\src\\vue\\__tests__\\VueSSRPlugin.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
});
