const { extractFromSource } = require('../../src/extractor');

describe('mattermost_mattermost-mobile', () => {
    it('mattermost_mattermost-mobile\\app\\actions\\local\\channel.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{DeviceEventEmitter\} from 'react-native';
			
			import \{Navigation\} from '@constants';
			import \{SYSTEM_IDENTIFIERS\} from '@constants/database';
			import DatabaseManager from '@database/manager';
			import \{getMyChannel\} from '@queries/servers/channel';
			import \{getCommonSystemValues, getTeamHistory\} from '@queries/servers/system';
			import \{getTeamChannelHistory\} from '@queries/servers/team';
			import \{dismissAllModalsAndPopToRoot, dismissAllModalsAndPopToScreen\} from '@screens/navigation';
			
			import \{switchToChannel\} from './channel';
			
			import type ServerDataOperator from '@database/operator/server_data_operator';
			import type \{Database\} from '@nozbe/watermelondb';
			
			let mockIsTablet: jest.Mock;
			const now = new Date('2020-01-01').getTime();
			
			jest.mock('@screens/navigation', () => \{
			    const original = jest.requireActual('@screens/navigation');
			    return \{
			        ...original,
			        dismissAllModalsAndPopToScreen: jest.fn(),
			        dismissAllModalsAndPopToRoot: jest.fn(),
			    \};
			\});
			
			jest.mock('@utils/helpers', () => \{
			    const original = jest.requireActual('@utils/helpers');
			    mockIsTablet = jest.fn(() => false);
			    return \{
			        ...original,
			        isTablet: mockIsTablet,
			    \};
			\});
			
			const queryDatabaseValues = async (database: Database, teamId: string, channelId: string) => (\{
			    systemValues: await getCommonSystemValues(database),
			    teamHistory: await getTeamHistory(database),
			    channelHistory: await getTeamChannelHistory(database, teamId),
			    member: await getMyChannel(database, channelId),
			\});
			
			describe('switchToChannel', () => \{
			    let operator: ServerDataOperator;
			    let spyNow: jest.SpyInstance;
			    const serverUrl = 'baseHandler.test.com';
			    const channelId = 'id1';
			    const teamId = 'tId1';
			    const team: Team = \{
			        id: teamId,
			    \} as Team;
			    const channel: Channel = \{
			        id: channelId,
			        team_id: teamId,
			        total_msg_count: 0,
			    \} as Channel;
			    const channelMember: ChannelMembership = \{
			        id: 'id',
			        channel_id: channelId,
			        msg_count: 0,
			    \} as ChannelMembership;
			    beforeEach(async () => \{
			        await DatabaseManager.init([serverUrl]);
			        operator = DatabaseManager.serverDatabases[serverUrl]!.operator;
			        spyNow = jest.spyOn(Date, 'now').mockImplementation(() => now);
			    \});
			
			    afterEach(async () => \{
			        await DatabaseManager.destroyServerDatabase(serverUrl);
			        spyNow.mockRestore();
			    \});
			
			    it('handle not found database', async () => \{
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{error\} = await switchToChannel('foo', 'channelId');
			        listener.remove();
			
			        expect(error).toBeTruthy();
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(0);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('handle no member', async () => \{
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, 'channelId');
			        listener.remove();
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(0);
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(systemValues.currentTeamId).toBe('');
			        expect(systemValues.currentChannelId).toBe('');
			        expect(teamHistory.length).toBe(0);
			        expect(channelHistory.length).toBe(0);
			        expect(member?.lastViewedAt).toBe(undefined);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(0);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to current channel', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: teamId\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: channelId\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(2); // Viewed at, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(0);
			        expect(channelHistory.length).toBe(0);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to different channel in same team', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: teamId\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(4); // Viewed at, channel history and currentChannelId
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(0);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to different channel in different team', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: 'currentTeamId'\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId, teamId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(6); // Viewed at, channel history, team history, currentTeamId and currentChannelId
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(1);
			        expect(teamHistory[0]).toBe(teamId);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to same channel in different team', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        const tChannel = \{...channel, team_id: ''\};
			        await operator.handleChannel(\{channels: [tChannel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [tChannel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: 'currentTeamId'\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: channelId\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId, teamId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(5); // Viewed at, channel history, team history and currentTeamId, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(1);
			        expect(teamHistory[0]).toBe(teamId);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to dm channel in different team', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        const tChannel = \{...channel, team_id: ''\};
			        await operator.handleChannel(\{channels: [tChannel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [tChannel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: 'currentTeamId'\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId, teamId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(6); // Viewed at, channel history, team history, currentTeamId and currentChannelId, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(1);
			        expect(teamHistory[0]).toBe(teamId);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to a channel from different team without passing the teamId', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: 'currentTeamId'\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(6); // Viewed at, channel history, team history, currentTeamId and currentChannelId, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(1);
			        expect(teamHistory[0]).toBe(teamId);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to a channel from the same team without passing a teamId', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: teamId\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(4); // Viewed at, channel history and currentChannelId, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(0);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to a DM without passing the teamId', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        const tChannel = \{...channel, team_id: ''\};
			        await operator.handleChannel(\{channels: [tChannel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [tChannel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: teamId\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(4); // Viewed at, channel history and currentChannelId, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(0);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to a channel passing a wrong teamId', async () => \{
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: 'currentTeamId'\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId, 'someTeamId');
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(6); // Viewed at, channel history, team history, currentTeamId and currentChannelId, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(1);
			        expect(teamHistory[0]).toBe(teamId);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('switch to a DM passing a non-existing teamId', async () => \{
			        const currentTeamId = 'ctid';
			        const currentChannelId = 'ccid';
			
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        const tChannel = \{...channel, team_id: ''\};
			        await operator.handleChannel(\{channels: [tChannel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [tChannel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: currentTeamId\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: currentChannelId\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{error\} = await switchToChannel(serverUrl, channelId, 'someTeamId');
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeTruthy();
			        expect(systemValues.currentTeamId).toBe(currentTeamId);
			        expect(systemValues.currentChannelId).toBe(currentChannelId);
			        expect(teamHistory.length).toBe(0);
			        expect(channelHistory.length).toBe(0);
			        expect(member?.lastViewedAt).toBe(0);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(0);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('prepare records only does not change the database', async () => \{
			        const currentTeamId = 'ctid';
			        const currentChannelId = 'ccid';
			
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: currentTeamId\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: currentChannelId\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId, teamId, false, true);
			        for (const model of models!) \{
			            model.cancelPrepareUpdate();
			        \}
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(6); // Viewed at, channel history, team history, currentTeamId and currentChannelId, lastunread
			        expect(systemValues.currentTeamId).toBe(currentTeamId);
			        expect(systemValues.currentChannelId).toBe(currentChannelId);
			        expect(teamHistory.length).toBe(0);
			        expect(channelHistory.length).toBe(0);
			        expect(member?.lastViewedAt).toBe(0);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(1);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(0);
			        expect(listenerCallback).toHaveBeenCalledTimes(0);
			    \});
			
			    it('test behaviour when it is a tablet', async () => \{
			        mockIsTablet.mockImplementationOnce(() => true);
			
			        await operator.handleTeam(\{teams: [team], prepareRecordsOnly: false\});
			        await operator.handleChannel(\{channels: [channel], prepareRecordsOnly: false\});
			        await operator.handleMyChannel(\{channels: [channel], myChannels: [channelMember], prepareRecordsOnly: false\});
			        await operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: 'currentTeamId'\}, \{id: SYSTEM_IDENTIFIERS.CURRENT_CHANNEL_ID, value: 'currentChannelId'\}], prepareRecordsOnly: false\});
			
			        const listenerCallback = jest.fn();
			        const listener = DeviceEventEmitter.addListener(Navigation.NAVIGATION_HOME, listenerCallback);
			        const \{models, error\} = await switchToChannel(serverUrl, channelId, teamId);
			        listener.remove();
			
			        const \{systemValues, teamHistory, channelHistory, member\} = await queryDatabaseValues(operator.database, teamId, channelId);
			
			        expect(error).toBeUndefined();
			        expect(models?.length).toBe(6); // Viewed at, channel history, team history, currentTeamId and currentChannelId, lastUnread
			        expect(systemValues.currentTeamId).toBe(teamId);
			        expect(systemValues.currentChannelId).toBe(channelId);
			        expect(teamHistory.length).toBe(1);
			        expect(teamHistory[0]).toBe(teamId);
			        expect(channelHistory.length).toBe(1);
			        expect(channelHistory[0]).toBe(channelId);
			        expect(member?.lastViewedAt).toBe(now);
			        expect(dismissAllModalsAndPopToScreen).toHaveBeenCalledTimes(0);
			        expect(dismissAllModalsAndPopToRoot).toHaveBeenCalledTimes(1);
			        expect(listenerCallback).toHaveBeenCalledTimes(1);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\actions\\local\\channel.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(14)
    });
    it('mattermost_mattermost-mobile\\app\\client\\rest\\index.test.js', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import assert from 'assert';
			
			import nock from 'nock';
			
			import \{HEADER_X_VERSION_ID\} from '@client/rest/constants';
			import ClientError from '@client/rest/error';
			import TestHelper from '@test/test_helper';
			import \{isMinimumServerVersion\} from '@utils/helpers';
			
			describe('Client', () => \{
			    beforeAll(() => \{
			        if (!nock.isActive()) \{
			            nock.activate();
			        \}
			    \});
			
			    afterAll(() => \{
			        nock.restore();
			    \});
			
			    describe('doFetch', () => \{
			        it('serverVersion should be set from response header', async () => \{
			            const client = TestHelper.createClient();
			
			            assert.equal(client.serverVersion, '');
			
			            client.apiClient.get.mockReturnValueOnce(\{
			                code: 200,
			                data: \{\},
			                headers: \{[HEADER_X_VERSION_ID]: '5.0.0.5.0.0.abc123'\},
			                ok: true,
			            \});
			
			            await client.getMe();
			
			            assert.equal(client.serverVersion, '5.0.0');
			            assert.equal(isMinimumServerVersion(client.serverVersion, 5, 0, 0), true);
			            assert.equal(isMinimumServerVersion(client.serverVersion, 5, 1, 0), false);
			
			            client.apiClient.get.mockReturnValueOnce(\{
			                code: 200,
			                data: \{\},
			                headers: \{[HEADER_X_VERSION_ID]: '5.3.0.5.3.0.abc123'\},
			                ok: true,
			            \});
			
			            await client.getMe();
			
			            assert.equal(client.serverVersion, '5.3.0');
			            assert.equal(isMinimumServerVersion(client.serverVersion, 5, 0, 0), true);
			            assert.equal(isMinimumServerVersion(client.serverVersion, 5, 1, 0), true);
			        \});
			    \});
			\});
			
			describe('ClientError', () => \{
			    it('standard fields should be enumerable', () => \{
			        const error = new ClientError('https://example.com', \{
			            message: 'This is a message',
			            intl: \{
			                id: 'test.error',
			                defaultMessage: 'This is a message with a translation',
			            \},
			            server_error_id: 'test.app_error',
			            status_code: 418,
			            url: 'https://example.com/api/v4/error',
			        \});
			
			        const copy = \{...error\};
			
			        assert.strictEqual(copy.message, error.message);
			        assert.strictEqual(copy.intl, error.intl);
			        assert.strictEqual(copy.server_error_id, error.server_error_id);
			        assert.strictEqual(copy.status_code, error.status_code);
			        assert.strictEqual(copy.url, error.url);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\client\\rest\\index.test.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\components\\app_version\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntl\} from '@test/intl-test-helper';
			
			import AppVersion from './index';
			
			describe('@components/app_version', () => \{
			    it('should match snapshot', () => \{
			        const wrapper = renderWithIntl(<AppVersion/>);
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\app_version\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\components\\channel_item\\channel_item.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Database, Q\} from '@nozbe/watermelondb';
			import React from 'react';
			
			import \{MM_TABLES\} from '@constants/database';
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import ChannelItem from './channel_item';
			
			import type ChannelModel from '@typings/database/models/servers/channel';
			import type MyChannelModel from '@typings/database/models/servers/my_channel';
			
			describe('components/channel_list/categories/body/channel_item', () => \{
			    let database: Database;
			    let myChannel: MyChannelModel;
			
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			
			        const myChannels = await database.get<MyChannelModel>(MM_TABLES.SERVER.MY_CHANNEL).query(
			            Q.take(1),
			        ).fetch();
			
			        myChannel = myChannels[0];
			    \});
			
			    it('should match snapshot', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <ChannelItem
			                channel=\{\{displayName: 'Hello!', type: 'O', shared: false, name: 'hello', deleteAt: 0\} as ChannelModel\}
			                hasDraft=\{false\}
			                isActive=\{false\}
			                membersCount=\{0\}
			                isMuted=\{false\}
			                currentUserId=\{'id'\}
			                testID='channel_item'
			                onPress=\{() => undefined\}
			                isUnread=\{myChannel.isUnread\}
			                mentionsCount=\{myChannel.mentionsCount\}
			                hasCall=\{false\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot when it has a draft', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <ChannelItem
			                channel=\{\{displayName: 'Hello!', type: 'G', shared: false, name: 'hello', deleteAt: 0\} as ChannelModel\}
			                hasDraft=\{true\}
			                isActive=\{false\}
			                membersCount=\{3\}
			                isMuted=\{false\}
			                currentUserId=\{'id'\}
			                testID='channel_item'
			                onPress=\{() => undefined\}
			                isUnread=\{myChannel.isUnread\}
			                mentionsCount=\{myChannel.mentionsCount\}
			                hasCall=\{false\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot when it has a call', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <ChannelItem
			                channel=\{\{displayName: 'Hello!', type: 'G', shared: false, name: 'hello', deleteAt: 0\} as ChannelModel\}
			                hasDraft=\{true\}
			                isActive=\{false\}
			                membersCount=\{3\}
			                isMuted=\{false\}
			                currentUserId=\{'id'\}
			                testID='channel_item'
			                onPress=\{() => undefined\}
			                isUnread=\{myChannel.isUnread\}
			                mentionsCount=\{myChannel.mentionsCount\}
			                hasCall=\{true\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\channel_item\\channel_item.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\components\\channel_list_row\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import ChannelListRow from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/channel_list_row', () => \{
			    let database: Database;
			    const channel: Channel = \{
			        id: '1',
			        create_at: 1111,
			        update_at: 1111,
			        delete_at: 0,
			        team_id: 'my team',
			        type: 'O',
			        display_name: 'channel',
			        name: 'channel',
			        header: 'channel',
			        purpose: '',
			        last_post_at: 1,
			        total_msg_count: 1,
			        extra_update_at: 1,
			        creator_id: '1',
			        scheme_id: null,
			        group_constrained: null,
			        shared: true,
			    \};
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should match snapshot with open channel icon', () => \{
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                channel=\{channel\}
			                selected=\{false\}
			                selectable=\{false\}
			                testID='ChannelListRow'
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with private channel icon', () => \{
			        channel.type = 'P';
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                channel=\{channel\}
			                selected=\{false\}
			                selectable=\{false\}
			                testID='ChannelListRow'
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with delete_at filled in', () => \{
			        channel.delete_at = 1111;
			        channel.shared = false;
			        channel.type = 'O';
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                channel=\{channel\}
			                testID='ChannelListRow'
			                selectable=\{false\}
			                selected=\{false\}
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with shared filled in', () => \{
			        channel.delete_at = 0;
			        channel.shared = true;
			        channel.type = 'O';
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                channel=\{channel\}
			                testID='ChannelListRow'
			                selectable=\{false\}
			                selected=\{false\}
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with purpose filled in', () => \{
			        channel.purpose = 'My purpose';
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                channel=\{channel\}
			                testID='ChannelListRow'
			                selectable=\{false\}
			                selected=\{false\}
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should be selected', () => \{
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                channel=\{channel\}
			                testID='ChannelListRow'
			                selectable=\{true\}
			                selected=\{true\}
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\channel_list_row\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('mattermost_mattermost-mobile\\app\\components\\custom_status\\clear_button.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import ClearButton from '@components/custom_status/clear_button';
			import Preferences from '@constants/preferences';
			import \{fireEvent, render\} from '@test/intl-test-helper';
			
			describe('components/custom_status/clear_button', () => \{
			    const baseProps = \{
			        handlePress: jest.fn(),
			        testID: 'clear_custom_status.button',
			        theme: Preferences.THEMES.denim,
			    \};
			
			    it('should match snapshot', () => \{
			        const wrapper = render(
			            <ClearButton
			                \{...baseProps\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should call handlePress when press event is fired', () => \{
			        const \{getByTestId\} = render(
			            <ClearButton
			                \{...baseProps\}
			            />,
			        );
			
			        fireEvent.press(getByTestId(baseProps.testID));
			        expect(baseProps.handlePress).toBeCalled();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\custom_status\\clear_button.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\components\\custom_status\\custom_status_emoji.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import CustomStatusEmoji from '@components/custom_status/custom_status_emoji';
			import \{CustomStatusDurationEnum\} from '@constants/custom_status';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/custom_status/custom_status_emoji', () => \{
			    let database: Database | undefined;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    const customStatus: UserCustomStatus = \{
			        emoji: 'calendar',
			        text: 'In a meeting',
			        duration: CustomStatusDurationEnum.DONT_CLEAR,
			    \};
			    it('should match snapshot', () => \{
			        const wrapper = renderWithEverything(
			            <CustomStatusEmoji
			                customStatus=\{customStatus\}
			            />,
			            \{database\},
			        );
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with props', () => \{
			        const wrapper = renderWithEverything(
			            <CustomStatusEmoji
			                customStatus=\{customStatus\}
			                emojiSize=\{34\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\custom_status\\custom_status_emoji.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\components\\custom_status\\custom_status_text.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import CustomStatusText from '@components/custom_status/custom_status_text';
			import Preferences from '@constants/preferences';
			import \{render\} from '@test/intl-test-helper';
			
			describe('components/custom_status/custom_status_text', () => \{
			    const baseProps = \{
			        text: 'In a meeting',
			        theme: Preferences.THEMES.denim,
			    \};
			
			    it('should match snapshot', () => \{
			        const wrapper = render(
			            <CustomStatusText
			                \{...baseProps\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with empty text', () => \{
			        const wrapper = render(
			            <CustomStatusText
			                \{...baseProps\}
			                text=\{''\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\custom_status\\custom_status_text.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\components\\error_text\\error_text.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{Preferences\} from '@constants';
			import \{renderWithIntl\} from '@test/intl-test-helper';
			
			import ErrorTextComponent from './index';
			
			describe('ErrorText', () => \{
			    const baseProps = \{
			        testID: 'error.text',
			        textStyle: \{
			            fontSize: 14,
			            marginHorizontal: 15,
			        \},
			        theme: Preferences.THEMES.denim,
			        error: 'Username must begin with a letter and contain between 3 and 22 characters including numbers, lowercase letters, and the symbols',
			    \};
			
			    test('should match snapshot', () => \{
			        const wrapper = renderWithIntl(
			            <ErrorTextComponent \{...baseProps\}/>,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\error_text\\error_text.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\components\\friendly_date\\friendly_date.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntl\} from '@test/intl-test-helper';
			
			import FriendlyDate from './index';
			
			describe('Friendly Date', () => \{
			    it('should render correctly', () => \{
			        const justNow = new Date();
			        justNow.setSeconds(justNow.getSeconds() - 10);
			        const justNowText = renderWithIntl(
			            <FriendlyDate value=\{justNow\}/>,
			        );
			        expect(justNowText.getByText('Now')).toBeTruthy();
			
			        const minutesAgo = new Date();
			        minutesAgo.setMinutes(minutesAgo.getMinutes() - 1);
			        const minutesAgoText = renderWithIntl(
			            <FriendlyDate value=\{minutesAgo\}/>,
			        );
			        expect(minutesAgoText.getByText('1 min ago')).toBeTruthy();
			
			        const hoursAgo = new Date();
			        hoursAgo.setHours(hoursAgo.getHours() - 4);
			        const hoursAgoText = renderWithIntl(
			            <FriendlyDate value=\{hoursAgo\}/>,
			        );
			        expect(hoursAgoText.getByText('4 hours ago')).toBeTruthy();
			
			        const yesterday = new Date();
			        yesterday.setDate(yesterday.getDate() - 1);
			        const yesterdayText = renderWithIntl(
			            <FriendlyDate value=\{yesterday\}/>,
			        );
			        expect(yesterdayText.getByText('Yesterday')).toBeTruthy();
			
			        const daysAgo = new Date();
			        daysAgo.setDate(daysAgo.getDate() - 10);
			        const daysAgoText = renderWithIntl(
			            <FriendlyDate value=\{daysAgo\}/>,
			        );
			        expect(daysAgoText.getByText('10 days ago')).toBeTruthy();
			
			        // Difference is less than 30 days
			        const daysEdgeCase = new Date(2020, 3, 28);
			        const daysEdgeCaseTodayDate = new Date(2020, 4, 28);
			        const daysEdgeCaseText = renderWithIntl(
			            <FriendlyDate
			                sourceDate=\{daysEdgeCaseTodayDate\}
			                value=\{daysEdgeCase\}
			            />,
			        );
			        expect(daysEdgeCaseText.getByText('1 month ago')).toBeTruthy();
			
			        const daysAgoMax = new Date(2020, 4, 6);
			        const daysAgoMaxTodayDate = new Date(2020, 5, 5);
			        const daysAgoMaxText = renderWithIntl(
			            <FriendlyDate
			                sourceDate=\{daysAgoMaxTodayDate\}
			                value=\{daysAgoMax\}
			            />,
			        );
			        expect(daysAgoMaxText.getByText('30 days ago')).toBeTruthy();
			
			        const monthsAgo = new Date();
			        monthsAgo.setMonth(monthsAgo.getMonth() - 2);
			        const monthsAgoText = renderWithIntl(
			            <FriendlyDate value=\{monthsAgo\}/>,
			        );
			        expect(monthsAgoText.getByText('2 months ago')).toBeTruthy();
			
			        const yearsAgo = new Date();
			        yearsAgo.setFullYear(yearsAgo.getFullYear() - 2);
			        const yearsAgoText = renderWithIntl(
			            <FriendlyDate value=\{yearsAgo\}/>,
			        );
			        expect(yearsAgoText.getByText('2 years ago')).toBeTruthy();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\friendly_date\\friendly_date.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\components\\loading\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			
			import Loading from './index';
			
			test('Loading  should match snapshot', () => \{
			    const \{toJSON\} = renderWithIntlAndTheme(
			        <Loading/>,
			    );
			
			    expect(toJSON()).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\loading\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\components\\loading_error\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			
			import ErrorComponent from './index';
			
			test('Loading Error should match snapshot', () => \{
			    const \{toJSON\} = renderWithIntlAndTheme(
			        <ErrorComponent
			            loading=\{false\}
			            message='Error description'
			            onRetry=\{() => true\}
			            title='Error title'
			        />,
			    );
			
			    expect(toJSON()).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\loading_error\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\components\\markdown\\transform.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import assert from 'assert';
			
			import \{Node, Parser\} from 'commonmark';
			
			import \{
			    addListItemIndices,
			    combineTextNodes,
			    getFirstMatch,
			    highlightMentions,
			    highlightTextNode,
			    mentionKeysToPatterns,
			    pullOutImages,
			\} from '@components/markdown/transform';
			import \{logError\} from '@utils/log';
			
			import type \{UserMentionKey\} from '@typings/global/markdown';
			
			/* eslint-disable max-lines, no-underscore-dangle */
			
			describe('Components.Markdown.transform', () => \{
			    const parser = new Parser();
			
			    describe('combineTextNodes', () => \{
			        const tests = [\{
			            name: 'no text nodes',
			            input: \{
			                type: 'document',
			                children: [\{
			                    type: 'thematic_break',
			                \}],
			            \},
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'thematic_break',
			                \}],
			            \},
			        \}, \{
			            name: 'one text node',
			            input: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is a sentence',
			                    \}],
			                \}],
			            \},
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is a sentence',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'multiple text nodes',
			            input: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This ',
			                    \}, \{
			                        type: 'text',
			                        literal: 'is a',
			                    \}, \{
			                        type: 'text',
			                        literal: ' sen',
			                    \}, \{
			                        type: 'text',
			                        literal: 'tence',
			                    \}],
			                \}],
			            \},
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is a sentence',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'mixed formatting',
			            input: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This ',
			                    \}, \{
			                        type: 'emph',
			                        children: [\{
			                            type: 'text',
			                            literal: 'is a',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' sen',
			                    \}, \{
			                        type: 'text',
			                        literal: 'tence',
			                    \}],
			                \}],
			            \},
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This ',
			                    \}, \{
			                        type: 'emph',
			                        children: [\{
			                            type: 'text',
			                            literal: 'is a',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' sentence',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'multiple paragraphs',
			            input: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is a ',
			                    \}, \{
			                        type: 'text',
			                        literal: 'paragraph',
			                    \}],
			                \}, \{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is',
			                    \}, \{
			                        type: 'text',
			                        literal: ' another ',
			                    \}, \{
			                        type: 'text',
			                        literal: 'paragraph',
			                    \}],
			                \}],
			            \},
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is a paragraph',
			                    \}],
			                \}, \{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is another paragraph',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'MM-12880 merging text followed by non-text',
			            input: 'test: *italics*',
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'test: ',
			                    \}, \{
			                        type: 'emph',
			                        children: [\{
			                            type: 'text',
			                            literal: 'italics',
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'MM-12880 merging text followed by image',
			            input: 'test: ![image](https://example.com/image)',
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'test: ',
			                    \}, \{
			                        type: 'image',
			                        destination: 'https://example.com/image',
			                        title: '',
			                        children: [\{
			                            type: 'text',
			                            literal: 'image',
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}];
			
			        for (const test of tests) \{
			            it(test.name, () => \{
			                const input = typeof test.input === 'string' ? parser.parse(test.input) : makeAst(test.input);
			                const expected = makeAst(test.expected);
			                const actual = combineTextNodes(input);
			
			                assert.ok(verifyAst(actual));
			                assert.deepStrictEqual(astToString(actual), astToString(expected));
			                assert.deepStrictEqual(stripUnusedFields(actual), stripUnusedFields(expected));
			            \});
			        \}
			    \});
			
			    describe('addListItemIndices', () => \{
			        it('unordered list', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'one',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'one',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 2,
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = addListItemIndices(input);
			
			            assert.ok(verifyAst(actual));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('ordered list', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    listStart: 7,
			                    listDelimiter: 'period',
			                    children: [\{
			                        type: 'item',
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'one',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    listStart: 7,
			                    listDelimiter: 'period',
			                    children: [\{
			                        type: 'item',
			                        index: 7,
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'one',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 8,
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = addListItemIndices(input);
			
			            assert.ok(verifyAst(actual));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('nested lists', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    listStart: 7,
			                    listDelimiter: 'period',
			                    children: [\{
			                        type: 'item',
			                        children: [\{
			                            type: 'list',
			                            listType: 'bullet',
			                            listTight: true,
			                            listStart: 3,
			                            listDelimiter: 'period',
			                            children: [\{
			                                type: 'item',
			                                children: [\{
			                                    type: 'pargraph',
			                                    children: [\{
			                                        type: 'text',
			                                        literal: 'one',
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                children: [\{
			                                    type: 'list',
			                                    listTight: true,
			                                    children: [\{
			                                        type: 'item',
			                                        children: [\{
			                                            type: 'pargraph',
			                                            children: [\{
			                                                type: 'text',
			                                                literal: 'one',
			                                            \}],
			                                        \}],
			                                    \}, \{
			                                        type: 'item',
			                                        children: [\{
			                                            type: 'pargraph',
			                                            children: [\{
			                                                type: 'text',
			                                                literal: 'two',
			                                            \}],
			                                        \}],
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'list',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'one',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    listStart: 7,
			                    listDelimiter: 'period',
			                    children: [\{
			                        type: 'item',
			                        index: 7,
			                        children: [\{
			                            type: 'list',
			                            listType: 'bullet',
			                            listTight: true,
			                            listStart: 3,
			                            listDelimiter: 'period',
			                            children: [\{
			                                type: 'item',
			                                index: 3,
			                                children: [\{
			                                    type: 'pargraph',
			                                    children: [\{
			                                        type: 'text',
			                                        literal: 'one',
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                index: 4,
			                                children: [\{
			                                    type: 'list',
			                                    listTight: true,
			                                    children: [\{
			                                        type: 'item',
			                                        index: 1,
			                                        children: [\{
			                                            type: 'pargraph',
			                                            children: [\{
			                                                type: 'text',
			                                                literal: 'one',
			                                            \}],
			                                        \}],
			                                    \}, \{
			                                        type: 'item',
			                                        index: 2,
			                                        children: [\{
			                                            type: 'pargraph',
			                                            children: [\{
			                                                type: 'text',
			                                                literal: 'two',
			                                            \}],
			                                        \}],
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 8,
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'list',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'one',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 2,
			                        children: [\{
			                            type: 'pargraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'two',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = addListItemIndices(input);
			
			            assert.ok(verifyAst(actual));
			            assert.deepStrictEqual(actual, expected);
			        \});
			    \});
			
			    describe('pullOutImages', () => \{
			        it('simple example with no images', () => \{
			            const input = parser.parse('test');
			            const expected = parser.parse('test');
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('complex example with no images', () => \{
			            const inputString = '- abc\\n    1. def\\n\\n    2. ghi\\n\\n3. jkl\\n- mno\\n    1. pqr\\n---\\n# vwx\\n\\nyz';
			            const input = parser.parse(inputString);
			            const expected = parser.parse(inputString);
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('paragraph', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('paragraph with surrounding text', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is text with ',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' in it',
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is text with ',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' in it',
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('paragraph with multiple images', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image',
			                        \}],
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image2',
			                        children: [\{
			                            type: 'text',
			                            literal: 'another image',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image',
			                        \}],
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image2',
			                        children: [\{
			                            type: 'text',
			                            literal: 'another image',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('headings', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'heading',
			                    level: 1,
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is the start 1',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 1',
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'heading',
			                    level: 4,
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 2',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: 'This is the end 2',
			                    \}],
			                \}, \{
			                    type: 'heading',
			                    level: 2,
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is the start 3',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 3',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: 'This is the end 3',
			                    \}],
			                \}, \{
			                    type: 'heading',
			                    level: 3,
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 4a',
			                        \}],
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 4b',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'heading',
			                    level: 1,
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is the start 1',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 1',
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'heading',
			                    level: 4,
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 2',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: 'This is the end 2',
			                    \}],
			                \}, \{
			                    type: 'heading',
			                    level: 2,
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is the start 3',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 3',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: 'This is the end 3',
			                    \}],
			                \}, \{
			                    type: 'heading',
			                    level: 3,
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 4a',
			                        \}],
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'an image 4b',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('block quote', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'block_quote',
			                    children: [\{
			                        type: 'paragraph',
			                        children: [\{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'block_quote',
			                    children: [\{
			                        type: 'paragraph',
			                        children: [\{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('block quote with other text', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'block_quote',
			                    children: [\{
			                        type: 'paragraph',
			                        children: [\{
			                            type: 'text',
			                            literal: 'This is ',
			                        \}, \{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: ' in a sentence',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'block_quote',
			                    children: [\{
			                        type: 'paragraph',
			                        children: [\{
			                            type: 'text',
			                            literal: 'This is ',
			                        \}, \{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: ' in a sentence',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('unordered list', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 2,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 3,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is moretext',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bullet',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 2,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 3,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is moretext',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('ordered list', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: false,
			                    children: [\{
			                        type: 'item',
			                        index: 7,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 8,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: false,
			                    children: [\{
			                        type: 'item',
			                        index: 7,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 8,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('complicated list', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: false,
			                    children: [\{
			                        type: 'item',
			                        index: 7,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 8,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}, \{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 9,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}, \{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 10,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 11,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: false,
			                    children: [\{
			                        type: 'item',
			                        index: 7,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 8,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}, \{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 9,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}, \{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 10,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'an image',
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 11,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is text',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('nested lists', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'list',
			                            listType: 'bulleted',
			                            listTight: false,
			                            children: [\{
			                                type: 'item',
			                                index: 3,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}, \{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                index: 4,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}, \{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 2,
			                        children: [\{
			                            type: 'list',
			                            listType: 'ordered',
			                            listTight: true,
			                            children: [\{
			                                type: 'item',
			                                index: 1,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}, \{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                index: 2,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}, \{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'list',
			                            listType: 'bulleted',
			                            listTight: false,
			                            children: [\{
			                                type: 'item',
			                                index: 3,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}, \{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                index: 4,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}, \{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'item',
			                        index: 2,
			                        children: [\{
			                            type: 'list',
			                            listType: 'ordered',
			                            listTight: true,
			                            children: [\{
			                                type: 'item',
			                                index: 1,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}, \{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                index: 2,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'text',
			                                        literal: 'This is text',
			                                    \}, \{
			                                        type: 'image',
			                                        destination: 'http://example.com/image',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'an image',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('complex example with images', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bulleted',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/abc',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'abc',
			                                \}],
			                            \}],
			                        \}, \{
			                            type: 'list',
			                            listType: 'numbered',
			                            listTight: false,
			                            children: [\{
			                                type: 'item',
			                                index: 1,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/def',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'def',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                index: 2,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/ghi',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'ghi',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			
			                    \}],
			                \}, \{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 3,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/jkl',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'jkl',
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'block_quote',
			                    children: [\{
			                        type: 'paragraph',
			                        children: [\{
			                            type: 'image',
			                            destination: 'http://example.com/mno',
			                            children: [\{
			                                type: 'text',
			                                literal: 'mno',
			                            \}],
			                        \}, \{
			                            type: 'softbreak',
			                        \}, \{
			                            type: 'image',
			                            destination: 'http://example.com/pqr',
			                            children: [\{
			                                type: 'text',
			                                literal: 'pqr',
			                            \}],
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'thematic_break',
			                \}, \{
			                    type: 'heading',
			                    level: 1,
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'vw',
			                        \}],
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'x',
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'yz',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'list',
			                    listType: 'bulleted',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 1,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/abc',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'abc',
			                                \}],
			                            \}],
			                        \}, \{
			                            type: 'list',
			                            listType: 'numbered',
			                            listTight: false,
			                            children: [\{
			                                type: 'item',
			                                index: 1,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/def',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'def',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}, \{
			                                type: 'item',
			                                index: 2,
			                                children: [\{
			                                    type: 'paragraph',
			                                    children: [\{
			                                        type: 'image',
			                                        destination: 'http://example.com/ghi',
			                                        children: [\{
			                                            type: 'text',
			                                            literal: 'ghi',
			                                        \}],
			                                    \}],
			                                \}],
			                            \}],
			                        \}],
			
			                    \}],
			                \}, \{
			                    type: 'list',
			                    listType: 'ordered',
			                    listTight: true,
			                    children: [\{
			                        type: 'item',
			                        index: 3,
			                        children: [\{
			                            type: 'paragraph',
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/jkl',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'jkl',
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'block_quote',
			                    children: [\{
			                        type: 'paragraph',
			                        children: [\{
			                            type: 'image',
			                            destination: 'http://example.com/mno',
			                            children: [\{
			                                type: 'text',
			                                literal: 'mno',
			                            \}],
			                        \}, \{
			                            type: 'softbreak',
			                        \}, \{
			                            type: 'image',
			                            destination: 'http://example.com/pqr',
			                            children: [\{
			                                type: 'text',
			                                literal: 'pqr',
			                            \}],
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'thematic_break',
			                \}, \{
			                    type: 'heading',
			                    level: 1,
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'vw',
			                        \}],
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'x',
			                        \}],
			                    \}],
			                \}, \{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'yz',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('simple link', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'link',
			                        destination: 'http://example.com',
			                        children: [\{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'link',
			                        destination: 'http://example.com',
			                        children: [\{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            linkDestination: 'http://example.com',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('link in sentence', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'link',
			                        destination: 'http://example.com',
			                        children: [\{
			                            type: 'text',
			                            literal: 'This is ',
			                        \}, \{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: ' in a sentence.',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'link',
			                        destination: 'http://example.com',
			                        children: [\{
			                            type: 'text',
			                            literal: 'This is ',
			                        \}, \{
			                            type: 'image',
			                            destination: 'http://example.com/image',
			                            linkDestination: 'http://example.com',
			                            children: [\{
			                                type: 'text',
			                                literal: 'an image',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: ' in a sentence.',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('table', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'table',
			                    children: [\{
			                        type: 'table_row',
			                        isHeading: true,
			                        children: [\{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}],
			                        \}, \{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is ',
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}, \{
			                                type: 'text',
			                                literal: ' in a sentence.',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'table_row',
			                        isHeading: true,
			                        children: [\{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is ',
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}, \{
			                                type: 'text',
			                                literal: ' in a sentence.',
			                            \}],
			                        \}, \{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'table',
			                    children: [\{
			                        type: 'table_row',
			                        isHeading: true,
			                        children: [\{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}],
			                        \}, \{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is ',
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}, \{
			                                type: 'text',
			                                literal: ' in a sentence.',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'table_row',
			                        isHeading: true,
			                        children: [\{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'text',
			                                literal: 'This is ',
			                            \}, \{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}, \{
			                                type: 'text',
			                                literal: ' in a sentence.',
			                            \}],
			                        \}, \{
			                            type: 'table_cell',
			                            isHeading: true,
			                            children: [\{
			                                type: 'image',
			                                destination: 'http://example.com/image',
			                                children: [\{
			                                    type: 'text',
			                                    literal: 'image1',
			                                \}],
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			
			        it('adjacent images and text', () => \{
			            const input = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'First:',
			                    \}, \{
			                        type: 'softbreak',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'Image',
			                        \}],
			                    \}, \{
			                        type: 'softbreak',
			                    \}, \{
			                        type: 'text',
			                        literal: 'Second:',
			                    \}, \{
			                        type: 'softbreak',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'Image',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const expected = makeAst(\{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'First:',
			                    \}, \{
			                        type: 'softbreak',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'Image',
			                        \}],
			                    \}, \{
			                        type: 'softbreak',
			                    \}, \{
			                        type: 'text',
			                        literal: 'Second:',
			                    \}, \{
			                        type: 'softbreak',
			                    \}, \{
			                        type: 'image',
			                        destination: 'http://example.com/image',
			                        children: [\{
			                            type: 'text',
			                            literal: 'Image',
			                        \}],
			                    \}],
			                \}],
			            \});
			            const actual = pullOutImages(input);
			
			            assert.ok(verifyAst(actual));
			            assert.equal(astToString(actual), astToString(expected));
			            assert.deepStrictEqual(actual, expected);
			        \});
			    \});
			
			    describe('highlightMentions', () => \{
			        const tests = [\{
			            name: 'no mentions',
			            input: 'These are words',
			            mentionKeys: [],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are words',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'not an at-mention',
			            input: 'These are words',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'words',
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'at-mention for another user',
			            input: 'This is @user',
			            mentionKeys: [\{key: '@words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is ',
			                    \}, \{
			                        type: 'at_mention',
			                        _mentionName: 'user',
			                        children: [\{
			                            type: 'text',
			                            literal: '@user',
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'at-mention',
			            input: 'These are @words',
			            mentionKeys: [\{key: '@words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'at_mention',
			                            _mentionName: 'words',
			                            children: [\{
			                                type: 'text',
			                                literal: '@words',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'at-mention and non-at-mention for same word',
			            input: 'These are @words',
			            mentionKeys: [\{key: 'words'\}, \{key: '@words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'at_mention',
			                            _mentionName: 'words',
			                            children: [\{
			                                type: 'text',
			                                literal: '@words',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'case insensitive mentions',
			            input: 'These are Words and wORDS',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'Words',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' and ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'wORDS',
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'case sesitive mentions',
			            input: 'These are Words and wORDS',
			            mentionKeys: [\{key: 'Words', caseSensitive: true\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'Words',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' and wORDS',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'bold',
			            input: 'These are **words** in a sentence',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'strong',
			                        children: [\{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'words',
			                            \}],
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' in a sentence',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'italics',
			            input: 'These _are Words in_ a sentence',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These ',
			                    \}, \{
			                        type: 'emph',
			                        children: [\{
			                            type: 'text',
			                            literal: 'are ',
			                        \}, \{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'Words',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: ' in',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' a sentence',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'code span',
			            input: 'These are \`words\`',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'code',
			                        literal: 'words',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'code block',
			            input: '\`\`\`\\nThese are\\nwords\\n\`\`\`',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'code_block',
			                    literal: 'These are\\nwords\\n',
			                \}],
			            \},
			        \}, \{
			            name: 'link text',
			            input: 'These are [words words](https://example.com)',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'These are ',
			                    \}, \{
			                        type: 'link',
			                        destination: 'https://example.com',
			                        title: '',
			                        children: [\{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'words',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: ' ',
			                        \}, \{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'words',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'link url',
			            input: 'This is [a link](https://example.com/words)',
			            mentionKeys: [\{key: 'example'\}, \{key: 'com'\}, \{key: 'https'\}, \{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is ',
			                    \}, \{
			                        type: 'link',
			                        destination: 'https://example.com/words',
			                        title: '',
			                        children: [\{
			                            type: 'text',
			                            literal: 'a link',
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'autolinked url',
			            input: 'https://example.com/words',
			            mentionKeys: [\{key: 'example'\}, \{key: 'com'\}, \{key: 'https'\}, \{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'link',
			                        destination: 'https://example.com/words',
			                        title: '',
			                        children: [\{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'https',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: '://',
			                        \}, \{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'example',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: '.',
			                        \}, \{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'com',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: '/',
			                        \}, \{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'words',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'words with punctuation',
			            input: 'words. (words) words/words/words words:words',
			            mentionKeys: [\{key: 'words'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'words',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: '. (',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'words',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ') ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'words',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: '/',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'words',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: '/',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: 'words',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: ' ',
			                    \}, \{
			                        type: 'link',
			                        destination: 'words:words',
			                        title: '',
			                        children: [\{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'words',
			                            \}],
			                        \}, \{
			                            type: 'text',
			                            literal: ':',
			                        \}, \{
			                            type: 'mention_highlight',
			                            children: [\{
			                                type: 'text',
			                                literal: 'words',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'multibyte keyword',
			            input: '我爱吃番茄炒饭',
			            mentionKeys: [\{key: '番茄'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: '我爱吃',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: '番茄',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: '炒饭',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'multiple multibyte keywords',
			            input: 'CJK is 中國日本한국.',
			            mentionKeys: [\{key: '中國'\}, \{key: '日本'\}, \{key: '한국'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'CJK is ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: '中國',
			                        \}],
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: '日本',
			                        \}],
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'text',
			                            literal: '한국',
			                        \}],
			                    \}, \{
			                        type: 'text',
			                        literal: '.',
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'Mention followed by a period',
			            input: 'This is a mention for @channel.',
			            mentionKeys: [\{key: 'channel'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is a mention for ',
			                    \}, \{
			                        type: 'mention_highlight',
			                        children: [\{
			                            type: 'at_mention',
			                            _mentionName: 'channel.',
			                            children: [\{
			                                type: 'text',
			                                literal: '@channel.',
			                            \}],
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}, \{
			            name: 'Do not mention partial keys',
			            input: 'This is a mention for @Gvn.',
			            mentionKeys: [\{key: 'gv'\}],
			            expected: \{
			                type: 'document',
			                children: [\{
			                    type: 'paragraph',
			                    children: [\{
			                        type: 'text',
			                        literal: 'This is a mention for ',
			                    \}, \{
			                        type: 'at_mention',
			                        _mentionName: 'Gvn.',
			                        children: [\{
			                            type: 'text',
			                            literal: '@Gvn.',
			                        \}],
			                    \}],
			                \}],
			            \},
			        \}];
			
			        for (const test of tests) \{
			            it(test.name, () => \{
			                const input = combineTextNodes(parser.parse(test.input));
			                const expected = makeAst(test.expected);
			                const actual = highlightMentions(input, test.mentionKeys);
			
			                assert.ok(verifyAst(actual));
			                assert.deepStrictEqual(stripUnusedFields(actual), stripUnusedFields(expected));
			            \});
			        \}
			    \});
			
			    describe('getFirstMention', () => \{
			        const tests = [\{
			            name: 'no mention keys',
			            input: 'apple banana orange',
			            mentionKeys: [],
			            expected: \{index: -1, length: -1\},
			        \}, \{
			            name: 'single mention',
			            input: 'apple banana orange',
			            mentionKeys: [\{key: 'banana'\}],
			            expected: \{index: 6, length: 6\},
			        \}, \{
			            name: 'multiple mentions',
			            input: 'apple banana orange',
			            mentionKeys: [\{key: 'apple'\}, \{key: 'orange'\}],
			            expected: \{index: 0, length: 5\},
			        \}, \{
			            name: 'case sensitive',
			            input: 'apple APPLE Apple aPPle',
			            mentionKeys: [\{key: 'Apple', caseSensitive: true\}],
			            expected: \{index: 12, length: 5\},
			        \}, \{
			            name: 'followed by period',
			            input: 'banana.',
			            mentionKeys: [\{key: 'banana'\}],
			            expected: \{index: 0, length: 6\},
			        \}, \{
			            name: 'followed by underscores',
			            input: 'banana__',
			            mentionKeys: [\{key: 'banana'\}],
			            expected: \{index: 0, length: 6\},
			        \}, \{
			            name: 'in brackets',
			            input: '(banana)',
			            mentionKeys: [\{key: 'banana'\}],
			            expected: \{index: 1, length: 6\},
			        \}, \{
			            name: 'following punctuation',
			            input: ':banana',
			            mentionKeys: [\{key: 'banana'\}],
			            expected: \{index: 1, length: 6\},
			        \}, \{
			            name: 'not part of another word',
			            input: 'pineapple',
			            mentionKeys: [\{key: 'apple'\}],
			            expected: \{index: -1, length: -1\},
			        \}, \{
			            name: 'no error from weird mention keys',
			            input: 'apple banana orange',
			            mentionKeys: [\{key: '*\\\\3_.'\}],
			            expected: \{index: -1, length: -1\},
			        \}, \{
			            name: 'no blank mention keys',
			            input: 'apple banana orange',
			            mentionKeys: [\{key: ''\}],
			            expected: \{index: -1, length: -1\},
			        \}, \{
			            name: 'multibyte key',
			            input: '좋은 하루 되세요.',
			            mentionKeys: [\{key: '하루'\}],
			            expected: \{index: 3, length: 2\},
			        \}];
			
			        function getFirstMention(str: string, mentionKeys: UserMentionKey[]) \{
			            const patterns = mentionKeysToPatterns(mentionKeys);
			            return getFirstMatch(str, patterns);
			        \}
			
			        for (const test of tests) \{
			            it(test.name, () => \{
			                const actual = getFirstMention(test.input, test.mentionKeys);
			
			                assert.deepStrictEqual(actual, test.expected);
			            \});
			        \}
			    \});
			
			    describe('highlightTextNode', () => \{
			        const type = 'paragraph';
			        const literal = 'This is a sentence';
			
			        const tests = [\{
			            name: 'highlight entire text',
			            start: 0,
			            end: literal.length,
			            expected: [\{
			                type,
			                children: [\{
			                    type: 'text',
			                    literal,
			                \}],
			            \}],
			        \}, \{
			            name: 'highlight start of text',
			            start: 0,
			            end: 6,
			            expected: [\{
			                type,
			                children: [\{
			                    type: 'text',
			                    literal: 'This i',
			                \}],
			            \}, \{
			                type: 'text',
			                literal: 's a sentence',
			            \}],
			        \}, \{
			            name: 'highlight end of text',
			            start: 8,
			            end: literal.length,
			            expected: [\{
			                type: 'text',
			                literal: 'This is ',
			            \}, \{
			                type,
			                children: [\{
			                    type: 'text',
			                    literal: 'a sentence',
			                \}],
			            \}],
			        \}, \{
			            name: 'highlight middle of text',
			            start: 5,
			            end: 12,
			            expected: [\{
			                type: 'text',
			                literal: 'This ',
			            \}, \{
			                type,
			                children: [\{
			                    type: 'text',
			                    literal: 'is a se',
			                \}],
			            \}, \{
			                type: 'text',
			                literal: 'ntence',
			            \}],
			        \}];
			
			        for (const test of tests) \{
			            it(test.name + ', without siblings', () => \{
			                const actual = makeAst(\{
			                    type: 'parent',
			                    children: [\{
			                        type: 'text',
			                        literal,
			                    \}],
			                \});
			                const expected = makeAst(\{
			                    type: 'parent',
			                    children: test.expected,
			                \});
			
			                const node = actual.firstChild;
			                assert.equal(node!.type, 'text');
			
			                const highlighted = highlightTextNode(node!, test.start, test.end, type);
			                assert.equal(highlighted.type, type);
			
			                assert.ok(verifyAst(actual));
			                assert.deepStrictEqual(actual, expected);
			            \});
			
			            it(test.name + ', with siblings', () => \{
			                const actual = makeAst(\{
			                    type: 'parent',
			                    children: [\{
			                        type: 'previous',
			                    \}, \{
			                        type: 'text',
			                        literal,
			                    \}, \{
			                        type: 'next',
			                    \}],
			                \});
			                const expected = makeAst(\{
			                    type: 'parent',
			                    children: [
			                        \{
			                            type: 'previous',
			                        \},
			                        ...test.expected,
			                        \{
			                            type: 'next',
			                        \},
			                    ],
			                \});
			
			                const node = actual.firstChild!.next;
			                assert.equal(node!.type, 'text');
			
			                const highlighted = highlightTextNode(node!, test.start, test.end, type);
			                assert.equal(highlighted.type, type);
			
			                assert.ok(verifyAst(actual));
			                assert.deepStrictEqual(actual, expected);
			            \});
			        \}
			    \});
			\});
			
			// Testing and debugging functions
			
			// Confirms that all parent, child, and sibling linkages are correct and go both ways.
			function verifyAst(node: Node) \{
			    if (node.prev && node.prev.next !== node) \{
			        logError('node is not linked properly to prev');
			        return false;
			    \}
			
			    if (node.next && node.next.prev !== node) \{
			        logError('node is not linked properly to next');
			        return false;
			    \}
			
			    if (!node.firstChild && node.lastChild) \{
			        logError('node has children, but is not linked to first child');
			        return false;
			    \}
			
			    if (node.firstChild && !node.lastChild) \{
			        logError('node has children, but is not linked to last child');
			        return false;
			    \}
			
			    for (let child = node.firstChild; child; child = child.next) \{
			        if (child.parent !== node) \{
			            logError('node is not linked properly to child');
			            return false;
			        \}
			
			        if (!verifyAst(child)) \{
			            return false;
			        \}
			
			        if (!child.next && child !== node.lastChild) \{
			            logError('node children are not linked correctly');
			            return false;
			        \}
			    \}
			
			    if (node.firstChild && node.firstChild.prev) \{
			        logError('node\\'s first child has previous sibling');
			        return false;
			    \}
			
			    if (node.lastChild && node.lastChild.next) \{
			        logError('node\\'s last child has next sibling');
			        return false;
			    \}
			
			    return true;
			\}
			
			function astToString(node: Node, indent = '') \{
			    if (!node) \{
			        return '';
			    \}
			
			    let out = '';
			
			    out += indent + nodeToString(node) + '\\n';
			
			    for (let child = node.firstChild; child !== null; child = child.next) \{
			        out += astToString(child, indent + '  ');
			    \}
			
			    return out;
			\}
			
			const neighbours = ['parent', 'prev', 'next', 'firstChild', 'lastChild'];
			const importantFields = ['literal', 'destination', 'title', 'level', 'listType', 'listTight', 'listDelimiter', 'mentionName', 'channelName', 'emojiName', 'continue', 'index'];
			function nodeToString(node: any) \{
			    let out = node.type;
			
			    for (const neighbour of neighbours) \{
			        if (node[neighbour]) \{
			            out += ' ' + neighbour + '=\`' + node[neighbour].type;
			            if (node[neighbour].type === 'text') \{
			                out += ':' + node[neighbour].literal;
			            \}
			            out += '\`';
			        \}
			    \}
			
			    for (const field of importantFields) \{
			        if (node[field]) \{
			            out += ' ' + field + '=\`' + node[field] + '\`';
			        \}
			    \}
			
			    return out;
			\}
			
			// Converts an AST represented as a JavaScript object into a full Commonmark-compatitle AST.
			// This function is intended for use while testing. An example of input would be:
			// \{
			//     type: 'document',
			//     children: [\{
			//         type: 'heading',
			//         level: 2,
			//         children: [\{
			//             type: 'text',
			//             literal: 'This is a heading'
			//         \}]
			//     \}, \{
			//         type: 'paragraph',
			//         children: [\{
			//             type: 'text',
			//             literal: 'This is a paragraph'
			//         \}]
			//     \}]
			// \}
			function makeAst(input: any) \{
			    const \{type, children, ...other\} = input;
			
			    const node = new Node(type);
			
			    for (const key of Object.keys(other)) \{
			        // @ts-expect-error key
			        node[key] = other[key];
			    \}
			
			    if (children) \{
			        for (const child of children) \{
			            node.appendChild(makeAst(child));
			        \}
			    \}
			
			    return node;
			\}
			
			// Remove any fields from the AST that are only used while parsing to make testing equality easier.
			function stripUnusedFields(node: any) \{
			    const walker = node.walker();
			
			    let e;
			    while ((e = walker.next())) \{
			        e.node._open = false;
			        e.node._size = null;
			        e.node._sourcepos = null;
			
			        e.node._fenceChar = null;
			        e.node._fenceLength = 0;
			        e.node._fenceOffset = 0;
			        e.node._info = '';
			        e.node._isFenced = false;
			    \}
			
			    return node;
			\}
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\markdown\\transform.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(25)
    });
    it('mattermost_mattermost-mobile\\app\\components\\post_list\\post\\body\\content\\message_attachments\\attachment_footer.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import Preferences from '@constants/preferences';
			import \{render\} from '@test/intl-test-helper';
			
			import AttachmentFooter from './attachment_footer';
			
			describe('AttachmentFooter', () => \{
			    const baseProps = \{
			        text: 'This is the footer!',
			        icon: 'https://images.com/image.png',
			        theme: Preferences.THEMES.denim,
			    \};
			
			    test('it matches snapshot when footer text is provided', () => \{
			        const props = \{
			            ...baseProps,
			            icon: undefined,
			        \};
			
			        const wrapper = render(<AttachmentFooter \{...props\}/>);
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    test('it matches snapshot when both footer and footer_icon are provided', () => \{
			        const wrapper = render(<AttachmentFooter \{...baseProps\}/>);
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\post_list\\post\\body\\content\\message_attachments\\attachment_footer.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\components\\post_list\\post\\system_message\\system_message_helpers.test.js', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{Post\} from '@constants';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import \{SystemMessage\} from './system_message';
			
			const baseProps = \{
			    author: \{
			        id: 'me',
			        username: 'username',
			        firstName: 'Test',
			        lastName: 'Author',
			    \},
			\};
			
			describe('renderSystemMessage', () => \{
			    let database;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    test('uses renderer for Channel Header update', () => \{
			        const post = \{
			            props: \{
			                old_header: 'old header',
			                new_header: 'new header',
			            \},
			            type: Post.POST_TYPES.HEADER_CHANGE,
			        \};
			        const \{getByText, toJSON\} = renderWithEverything(
			            <SystemMessage
			                post=\{post\}
			                \{...baseProps\}
			            />,
			            \{database\},
			        );
			        expect(toJSON()).toMatchSnapshot();
			        expect(getByText('@username')).toBeTruthy();
			        expect(getByText('updated the channel header from: old header to: new header')).toBeTruthy();
			    \});
			
			    test('uses renderer for Channel Display Name update', () => \{
			        const post = \{
			            props: \{
			                old_displayname: 'old displayname',
			                new_displayname: 'new displayname',
			            \},
			            type: Post.POST_TYPES.DISPLAYNAME_CHANGE,
			        \};
			
			        const \{getByText, toJSON\} = renderWithEverything(
			            <SystemMessage
			                post=\{post\}
			                \{...baseProps\}
			            />,
			            \{database\},
			        );
			        expect(toJSON()).toMatchSnapshot();
			        expect(getByText('@username')).toBeTruthy();
			        expect(getByText('updated the channel display name from: old displayname to: new displayname')).toBeTruthy();
			    \});
			
			    test('uses renderer for Channel Purpose update', () => \{
			        const post = \{
			            props: \{
			                old_purpose: 'old purpose',
			                new_purpose: 'new purpose',
			            \},
			            type: Post.POST_TYPES.PURPOSE_CHANGE,
			        \};
			        const \{getByText, toJSON\} = renderWithEverything(
			            <SystemMessage
			                post=\{post\}
			                \{...baseProps\}
			            />,
			            \{database\},
			        );
			        expect(toJSON()).toMatchSnapshot();
			        expect(getByText('@username updated the channel purpose from: old purpose to: new purpose')).toBeTruthy();
			    \});
			
			    test('uses renderer for archived channel', () => \{
			        const post = \{
			            type: Post.POST_TYPES.CHANNEL_DELETED,
			        \};
			
			        const \{getByText, toJSON\} = renderWithEverything(
			            <SystemMessage
			                post=\{post\}
			                \{...baseProps\}
			            />,
			            \{database\},
			        );
			        expect(toJSON()).toMatchSnapshot();
			        expect(getByText('@username')).toBeTruthy();
			        expect(getByText('archived the channel')).toBeTruthy();
			    \});
			
			    test('uses renderer for OLD archived channel without a username', () => \{
			        const post = \{
			            props: \{\},
			            type: Post.POST_TYPES.CHANNEL_DELETED,
			        \};
			
			        const \{getByText, toJSON\} = renderWithEverything(
			            <SystemMessage
			                \{...baseProps\}
			                post=\{post\}
			                author=\{undefined\}
			            />,
			            \{database\},
			        );
			        expect(toJSON()).toMatchSnapshot();
			        expect(getByText('archived the channel')).toBeTruthy();
			    \});
			
			    test('uses renderer for unarchived channel', () => \{
			        const post = \{
			            type: Post.POST_TYPES.CHANNEL_UNARCHIVED,
			        \};
			
			        const viewOne = renderWithEverything(
			            <SystemMessage
			                \{...baseProps\}
			                post=\{post\}
			            />,
			            \{database\},
			        );
			        expect(viewOne.toJSON()).toMatchSnapshot();
			        expect(viewOne.getByText('@username')).toBeTruthy();
			        expect(viewOne.getByText('unarchived the channel')).toBeTruthy();
			
			        const viewTwo = renderWithEverything(
			            <SystemMessage
			                \{...baseProps\}
			                post=\{post\}
			                author=\{undefined\}
			            />,
			            \{database\},
			        );
			        expect(viewTwo.toJSON()).toBeNull();
			        expect(viewTwo.queryByText('archived the channel')).toBeFalsy();
			    \});
			
			    test('is null for non-qualifying system messages', () => \{
			        const post = \{
			            postType: 'not_relevant',
			        \};
			
			        const renderedMessage = renderWithEverything(
			            <SystemMessage
			                \{...baseProps\}
			                post=\{post\}
			            />,
			            \{database\},
			        );
			        expect(renderedMessage.toJSON()).toBeNull();
			    \});
			
			    test('uses renderer for Guest added and join to channel', () => \{
			        const post = \{
			            props: \{
			                username: 'username',
			            \},
			            type: Post.POST_TYPES.GUEST_JOIN_CHANNEL,
			        \};
			        const joined = renderWithEverything(
			            <SystemMessage
			                post=\{post\}
			                \{...baseProps\}
			            />,
			            \{database\},
			        );
			        expect(joined.toJSON()).toMatchSnapshot();
			        expect(joined.getByText('@username')).toBeTruthy();
			        expect(joined.getByText('joined the channel as a guest.')).toBeTruthy();
			
			        post.type = Post.POST_TYPES.ADD_GUEST_TO_CHANNEL;
			        post.props = \{
			            username: 'username',
			            addedUsername: 'other.user',
			        \};
			
			        const added = renderWithEverything(
			            <SystemMessage
			                post=\{post\}
			                \{...baseProps\}
			            />,
			            \{database\},
			        );
			        expect(added.toJSON()).toMatchSnapshot();
			        expect(added.getByText('@other.user')).toBeTruthy();
			        expect(added.getByText('added to the channel as a guest by')).toBeTruthy();
			        expect(added.getByText('@username.')).toBeTruthy();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\post_list\\post\\system_message\\system_message_helpers.test.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('mattermost_mattermost-mobile\\app\\components\\post_list\\thread_overview\\thread_overview.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntl\} from '@test/intl-test-helper';
			
			import ThreadOverview from './thread_overview';
			
			import type PostModel from '@typings/database/models/servers/post';
			
			describe('ThreadOverview', () => \{
			    it('should match snapshot when post is not saved and 0 replies', () => \{
			        const props = \{
			            isSaved: true,
			            repliesCount: 0,
			            rootId: '',
			            rootPost: \{\} as PostModel,
			            testID: 'thread-overview',
			        \};
			
			        const wrapper = renderWithIntl(<ThreadOverview \{...props\}/>);
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot when post is saved and has replies', () => \{
			        const props = \{
			            isSaved: false,
			            repliesCount: 2,
			            rootId: '',
			            rootPost: \{\} as PostModel,
			            testID: 'thread-overview',
			        \};
			
			        const wrapper = renderWithIntl(<ThreadOverview \{...props\}/>);
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\post_list\\thread_overview\\thread_overview.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\components\\server_icon\\server_icon.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			
			import Icon from './index';
			
			describe('Server Icon', () => \{
			    test('Server Icon Component should match snapshot', () => \{
			        const \{toJSON\} = renderWithIntlAndTheme(
			            <Icon
			                hasUnreads=\{false\}
			                mentionCount=\{0\}
			            />,
			        );
			
			        expect(toJSON()).toMatchSnapshot();
			    \});
			
			    test('Server Icon Component should match snapshot with unreads', () => \{
			        const \{toJSON\} = renderWithIntlAndTheme(
			            <Icon
			                hasUnreads=\{true\}
			                mentionCount=\{0\}
			                testID='server_icon'
			            />,
			        );
			
			        expect(toJSON()).toMatchSnapshot();
			    \});
			
			    test('Server Icon Component should match snapshot with mentions', () => \{
			        const \{toJSON\} = renderWithIntlAndTheme(
			            <Icon
			                hasUnreads=\{false\}
			                mentionCount=\{1\}
			                testID='server_icon'
			            />,
			        );
			
			        expect(toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\server_icon\\server_icon.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\components\\threads_button\\threads_button.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			
			import Threads from './threads_button';
			
			const baseProps = \{
			    currentChannelId: 'someChannelId',
			    groupUnreadsSeparately: true,
			    onlyUnreads: false,
			    unreadsAndMentions: \{
			        unreads: false,
			        mentions: 0,
			    \},
			\};
			
			describe('Thread item in the channel list', () => \{
			    test('Threads Component should match snapshot', () => \{
			        const \{toJSON\} = renderWithIntlAndTheme(
			            <Threads \{...baseProps\}/>,
			        );
			        expect(toJSON()).toMatchSnapshot();
			    \});
			
			    test('Threads Component should match snapshot with only unreads filter', () => \{
			        const \{toJSON\} = renderWithIntlAndTheme(
			            <Threads
			                \{...baseProps\}
			                onlyUnreads=\{true\}
			            />,
			        );
			
			        expect(toJSON()).toMatchSnapshot();
			    \});
			
			    test('Threads Component should match snapshot with onCenterBg', () => \{
			        const \{toJSON\} = renderWithIntlAndTheme(
			            <Threads
			                \{...baseProps\}
			                onCenterBg=\{true\}
			            />,
			        );
			
			        expect(toJSON()).toMatchSnapshot();
			    \});
			
			    test('Threads Component should match snapshot, groupUnreadsSeparately false, always show', () => \{
			        const \{toJSON\} = renderWithIntlAndTheme(
			            <Threads
			                \{...baseProps\}
			                groupUnreadsSeparately=\{false\}
			                onlyUnreads=\{true\}
			            />,
			        );
			
			        expect(toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\threads_button\\threads_button.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\app\\components\\user_list\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import UserList from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/channel_list_row', () => \{
			    let database: Database;
			    const user: UserProfile = \{
			        id: '1',
			        create_at: 1111,
			        update_at: 1111,
			        delete_at: 0,
			        username: 'johndoe',
			        auth_service: '',
			        email: 'john@doe.com',
			        nickname: '',
			        first_name: '',
			        last_name: '',
			        position: '',
			        roles: '',
			        locale: '',
			        notify_props: \{
			            channel: 'true',
			            comments: 'never',
			            desktop: 'mention',
			            desktop_sound: 'true',
			            email: 'true',
			            first_name: 'true',
			            mention_keys: '',
			            push: 'mention',
			            push_status: 'away',
			        \},
			    \};
			
			    const user2: UserProfile = \{
			        id: '2',
			        create_at: 1111,
			        update_at: 1111,
			        delete_at: 0,
			        username: 'rocky',
			        auth_service: '',
			        email: 'rocky@doe.com',
			        nickname: '',
			        first_name: '',
			        last_name: '',
			        position: '',
			        roles: '',
			        locale: '',
			        notify_props: \{
			            channel: 'true',
			            comments: 'never',
			            desktop: 'mention',
			            desktop_sound: 'true',
			            email: 'true',
			            first_name: 'true',
			            mention_keys: '',
			            push: 'mention',
			            push_status: 'away',
			        \},
			    \};
			
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should show no results', () => \{
			        const wrapper = renderWithEverything(
			            <UserList
			                profiles=\{[user]\}
			                testID='UserListRow'
			                currentUserId=\{'1'\}
			                handleSelectProfile=\{() => \{
			                    // noop
			                \}\}
			                fetchMore=\{() => \{
			                    // noop
			                \}\}
			                loading=\{true\}
			                selectedIds=\{\{\}\}
			                showNoResults=\{true\}
			                tutorialWatched=\{true\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should show results no tutorial', () => \{
			        const wrapper = renderWithEverything(
			            <UserList
			                profiles=\{[user]\}
			                testID='UserListRow'
			                currentUserId=\{'1'\}
			                handleSelectProfile=\{() => \{
			                    // noop
			                \}\}
			                fetchMore=\{() => \{
			                    // noop
			                \}\}
			                loading=\{true\}
			                selectedIds=\{\{\}\}
			                showNoResults=\{true\}
			                tutorialWatched=\{true\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should show results no tutorial 2 users', () => \{
			        const wrapper = renderWithEverything(
			            <UserList
			                profiles=\{[user, user2]\}
			                testID='UserListRow'
			                currentUserId=\{'1'\}
			                handleSelectProfile=\{() => \{
			                    // noop
			                \}\}
			                fetchMore=\{() => \{
			                    // noop
			                \}\}
			                loading=\{true\}
			                selectedIds=\{\{\}\}
			                showNoResults=\{true\}
			                tutorialWatched=\{true\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should show results and tutorial', () => \{
			        const wrapper = renderWithEverything(
			            <UserList
			                profiles=\{[user]\}
			                testID='UserListRow'
			                currentUserId=\{'1'\}
			                handleSelectProfile=\{() => \{
			                    // noop
			                \}\}
			                fetchMore=\{() => \{
			                    // noop
			                \}\}
			                loading=\{true\}
			                selectedIds=\{\{\}\}
			                showNoResults=\{false\}
			                tutorialWatched=\{false\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\user_list\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\app\\components\\user_status\\user_status.test.js', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{General\} from '@constants';
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			
			import UserStatus from './';
			
			describe('UserStatus', () => \{
			    const baseProps = \{
			        size: 32,
			    \};
			
			    test('should match snapshot, should default to offline status', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <UserStatus \{...baseProps\}/>,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    test('should match snapshot, away status', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <UserStatus
			                \{...baseProps\}
			                status=\{General.AWAY\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    test('should match snapshot, dnd status', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <UserStatus
			                \{...baseProps\}
			                status=\{General.DND\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    test('should match snapshot, online status', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <UserStatus
			                \{...baseProps\}
			                status=\{General.ONLINE\}
			            />,
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\components\\user_status\\user_status.test.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\app\\database\\manager\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Database, Q\} from '@nozbe/watermelondb';
			
			import \{MM_TABLES\} from '@constants/database';
			import DatabaseManager from '@database/manager';
			import ServerDataOperator from '@database/operator/server_data_operator';
			
			import type ServersModel from '@typings/database/models/app/servers';
			
			const \{SERVERS\} = MM_TABLES.APP;
			
			// NOTE :  On the mock Database Manager, we cannot test for :
			// 1. Android/iOS file path
			// 2. Deletion of the 'databases' folder on those two platforms
			
			describe('*** Database Manager tests ***', () => \{
			    const serverUrls = ['https://appv1.mattermost.com', 'https://appv2.mattermost.com'];
			    beforeAll(async () => \{
			        await DatabaseManager.init(serverUrls);
			        await DatabaseManager.updateServerIdentifier(serverUrls[0], 'appv1');
			        await DatabaseManager.updateServerIdentifier(serverUrls[1], 'appv2');
			    \});
			
			    it('=> should return a default database', async () => \{
			        expect.assertions(2);
			
			        const appDatabase = DatabaseManager.appDatabase?.database;
			
			        expect(appDatabase).toBeInstanceOf(Database);
			        expect(Object.keys(DatabaseManager.serverDatabases).length).toBe(2);
			    \});
			
			    it('=> should create a new server database', async () => \{
			        expect.assertions(3);
			
			        const spyOnAddServerToDefaultDatabase = jest.spyOn(DatabaseManager as any, 'addServerToAppDatabase');
			
			        const connection1 = await DatabaseManager!.createServerDatabase(\{
			            config: \{
			                dbName: 'appv3 mattermost',
			                serverUrl: 'https://appv3.mattermost.com',
			                identifier: 'appv3',
			            \},
			        \});
			
			        expect(connection1?.database).toBeInstanceOf(Database);
			        expect(connection1?.operator).toBeInstanceOf(ServerDataOperator);
			        expect(spyOnAddServerToDefaultDatabase).toHaveBeenCalledTimes(1);
			    \});
			
			    it('=> should switch between active servers', async () => \{
			        expect.assertions(4);
			
			        let activeServerUrl = await DatabaseManager.getActiveServerUrl();
			        const serverA = await DatabaseManager.getActiveServerDatabase();
			
			        // as we haven't set an active server yet, so the first registered server should be the active one
			        expect(activeServerUrl).toBe(serverUrls[0]);
			        expect(serverA).toEqual(DatabaseManager.serverDatabases[serverUrls[0]]!.database);
			
			        await DatabaseManager.setActiveServerDatabase('https://appv2.mattermost.com');
			
			        // new active server should change and we have a Database and is active
			        activeServerUrl = await DatabaseManager.getActiveServerUrl();
			        const serverB = await DatabaseManager.getActiveServerDatabase();
			        expect(activeServerUrl).toBe(serverUrls[1]);
			        expect(serverB).toEqual(DatabaseManager.serverDatabases[serverUrls[1]]!.database);
			    \});
			
			    it('=> should delete appv1 server from the servers table of App database', async () => \{
			        expect.assertions(2);
			
			        await DatabaseManager.setActiveServerDatabase('https://appv1.mattermost.com');
			        await DatabaseManager.destroyServerDatabase('https://appv1.mattermost.com');
			
			        const fetchServerRecords = async (serverUrl: string) => \{
			            const servers = await DatabaseManager.appDatabase?.database!.collections.get<ServersModel>(SERVERS).query(Q.where('url', serverUrl)).fetch();
			            return servers?.length || 0;
			        \};
			
			        const destroyed = await fetchServerRecords(serverUrls[0]);
			        expect(destroyed).toBe(0);
			
			        // Removing database for appv1 connection
			        const activeServerUrl = await DatabaseManager.getActiveServerUrl();
			        expect(activeServerUrl).toEqual(serverUrls[1]);
			    \});
			
			    it('=> should return appv3 server url from the servers table of App database', async () => \{
			        expect.assertions(1);
			
			        const serverUrl = await DatabaseManager.getServerUrlFromIdentifier('appv3');
			        expect(serverUrl).toBe('https://appv3.mattermost.com');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\manager\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\app_data_operator\\index.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import DatabaseManager from '@database/manager';
			import \{buildAppInfoKey\} from '@database/operator/app_data_operator/comparator';
			import \{
			    transformInfoRecord,
			    transformGlobalRecord,
			\} from '@database/operator/app_data_operator/transformers';
			
			describe('** APP DATA OPERATOR **', () => \{
			    beforeAll(async () => \{
			        await DatabaseManager.init([]);
			    \});
			
			    it('=> HandleApp: should write to INFO table', async () => \{
			        const appDatabase = DatabaseManager.appDatabase?.database;
			        const appOperator = DatabaseManager.appDatabase?.operator;
			        expect(appDatabase).toBeTruthy();
			        expect(appOperator).toBeTruthy();
			
			        const spyOnHandleRecords = jest.spyOn(appOperator as any, 'handleRecords');
			
			        await appOperator?.handleInfo(\{
			            info: [
			                \{
			                    build_number: 'build-10x',
			                    created_at: 1,
			                    version_number: 'version-10',
			                \},
			                \{
			                    build_number: 'build-11y',
			                    created_at: 1,
			                    version_number: 'version-11',
			                \},
			            ],
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'version_number',
			            transformer: transformInfoRecord,
			            buildKeyRecordBy: buildAppInfoKey,
			            createOrUpdateRawValues: [
			                \{
			                    build_number: 'build-10x',
			                    created_at: 1,
			                    version_number: 'version-10',
			                \},
			                \{
			                    build_number: 'build-11y',
			                    created_at: 1,
			                    version_number: 'version-11',
			                \},
			            ],
			            tableName: 'Info',
			            prepareRecordsOnly: false,
			        \}, 'handleInfo');
			    \});
			
			    it('=> HandleGlobal: should write to GLOBAL table', async () => \{
			        const appDatabase = DatabaseManager.appDatabase?.database;
			        const appOperator = DatabaseManager.appDatabase?.operator;
			        expect(appDatabase).toBeTruthy();
			        expect(appOperator).toBeTruthy();
			
			        const spyOnHandleRecords = jest.spyOn(appOperator as any, 'handleRecords');
			        const globals: IdValue[] = [\{id: 'global-1-name', value: 'global-1-value'\}];
			
			        await appOperator?.handleGlobal(\{
			            globals,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            transformer: transformGlobalRecord,
			            createOrUpdateRawValues: globals,
			            tableName: 'Global',
			            prepareRecordsOnly: false,
			        \}, 'handleGlobal');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\app_data_operator\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\app_data_operator\\transformers\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import DatabaseManager from '@database/manager';
			import \{
			    transformInfoRecord,
			    transformGlobalRecord,
			\} from '@database/operator/app_data_operator/transformers/index';
			
			describe('** APP DATA TRANSFORMER **', () => \{
			    beforeAll(async () => \{
			        await DatabaseManager.init([]);
			    \});
			
			    it('=> transformInfoRecord: should return an array of type Info', async () => \{
			        expect.assertions(3);
			
			        const database = DatabaseManager.appDatabase?.database;
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformInfoRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    build_number: 'build-7',
			                    created_at: 1,
			                    version_number: 'v-1',
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Info');
			    \});
			
			    it('=> transformGlobalRecord: should return an array of type Global', async () => \{
			        expect.assertions(3);
			
			        const database = DatabaseManager.appDatabase?.database;
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformGlobalRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{id: 'g-n1', value: 'g-v1'\},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Global');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\app_data_operator\\transformers\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\category.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{MM_TABLES\} from '@constants/database';
			import DatabaseManager from '@database/manager';
			import \{
			    transformCategoryRecord,
			    transformCategoryChannelRecord,
			\} from '@database/operator/server_data_operator/transformers/category';
			
			import type ServerDataOperator from '..';
			
			describe('*** Operator: Category Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> handleCategories: should write to the CATEGORY table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const categories: Category[] = [
			            \{
			                id: 'kjlw9j1ttnxwig7tnqgebg7dtipno',
			                collapsed: false,
			                display_name: 'Test',
			                muted: false,
			                sort_order: 1,
			                sorting: 'recent',
			                team_id: '',
			                type: 'direct_messages',
			            \},
			        ];
			
			        await operator.handleCategories(\{
			            categories,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: categories,
			            tableName: MM_TABLES.SERVER.CATEGORY,
			            prepareRecordsOnly: false,
			            transformer: transformCategoryRecord,
			        \}, 'handleCategories');
			    \});
			
			    it('=> handleCategoryChannels: should write to the CATEGORY_CHANNEL table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const categoryChannels: CategoryChannel[] = [
			            \{
			                id: 'team_id-channel_id',
			                category_id: 'kjlw9j1ttnxwig7tnqgebg7dtipno',
			                channel_id: 'channel-id',
			                sort_order: 1,
			            \},
			        ];
			
			        await operator.handleCategoryChannels(\{
			            categoryChannels,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: categoryChannels,
			            tableName: MM_TABLES.SERVER.CATEGORY_CHANNEL,
			            prepareRecordsOnly: false,
			            transformer: transformCategoryChannelRecord,
			        \}, 'handleCategoryChannels');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\category.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\channel.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{updateMyChannelLastFetchedAt\} from '@actions/local/channel';
			import DatabaseManager from '@database/manager';
			import \{
			    buildChannelMembershipKey,
			    buildMyChannelKey,
			\} from '@database/operator/server_data_operator/comparators';
			import \{
			    transformChannelInfoRecord,
			    transformChannelMembershipRecord,
			    transformChannelRecord,
			    transformMyChannelRecord,
			    transformMyChannelSettingsRecord,
			\} from '@database/operator/server_data_operator/transformers/channel';
			
			import type ServerDataOperator from '..';
			
			describe('*** Operator: Channel Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			    const serverUrl = 'baseHandler.test.com';
			    beforeAll(async () => \{
			        await DatabaseManager.init([serverUrl]);
			        operator = DatabaseManager.serverDatabases[serverUrl]!.operator;
			    \});
			
			    it('=> HandleChannel: should write to the CHANNEL table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const channels: Channel[] = [
			            \{
			                create_at: 1600185541285,
			                creator_id: '',
			                delete_at: 0,
			                display_name: '',
			                extra_update_at: 0,
			                group_constrained: null,
			                header: '(https://mattermost',
			                id: 'kjlw9j1ttnxwig7tnqgebg7dtipno',
			                last_post_at: 1617311494451,
			                name: 'gh781zkzkhh357b4bejephjz5u8daw__9ciscaqbrpd6d8s68k76xb9bte',
			                purpose: '',
			                scheme_id: null,
			                shared: false,
			                team_id: '',
			                total_msg_count: 585,
			                type: 'D',
			                update_at: 1604401077256,
			            \},
			        ];
			
			        await operator.handleChannel(\{
			            channels,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: channels,
			            tableName: 'Channel',
			            prepareRecordsOnly: false,
			            transformer: transformChannelRecord,
			        \}, 'handleChannel');
			    \});
			
			    it('=> HandleMyChannelSettings: should write to the MY_CHANNEL_SETTINGS table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const settings: ChannelMembership[] = [
			            \{
			                id: 'c',
			                user_id: 'me',
			                channel_id: 'c',
			                roles: '',
			                msg_count: 0,
			                mention_count: 0,
			                last_viewed_at: 0,
			                last_update_at: 0,
			                notify_props: \{
			                    desktop: 'default',
			                    email: 'default',
			                    mark_unread: 'mention',
			                    push: 'mention',
			                    ignore_channel_mentions: 'default',
			                \},
			            \},
			        ];
			
			        await operator.handleMyChannelSettings(\{
			            settings,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: settings,
			            tableName: 'MyChannelSettings',
			            prepareRecordsOnly: false,
			            buildKeyRecordBy: buildMyChannelKey,
			            transformer: transformMyChannelSettingsRecord,
			        \}, 'handleMyChannelSettings');
			    \});
			
			    it('=> HandleChannelInfo: should write to the CHANNEL_INFO table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const channelInfos = [
			            \{
			                id: 'c',
			                guest_count: 10,
			                header: 'channel info header',
			                member_count: 10,
			                pinned_post_count: 3,
			                purpose: 'sample channel ',
			            \},
			        ];
			
			        await operator.handleChannelInfo(\{
			            channelInfos,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: channelInfos,
			            tableName: 'ChannelInfo',
			            prepareRecordsOnly: false,
			            transformer: transformChannelInfoRecord,
			        \}, 'handleChannelInfo');
			    \});
			
			    it('=> HandleMyChannel: should write to the MY_CHANNEL table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const channels: Channel[] = [\{
			            id: 'c',
			            name: 'channel',
			            display_name: 'Channel',
			            type: 'O',
			            create_at: 1,
			            update_at: 1,
			            delete_at: 0,
			            team_id: '123',
			            header: '',
			            purpose: '',
			            last_post_at: 2,
			            creator_id: 'me',
			            total_msg_count: 20,
			            extra_update_at: 0,
			            shared: false,
			            scheme_id: null,
			            group_constrained: false,
			        \}];
			        const myChannels: ChannelMembership[] = [
			            \{
			                id: 'c',
			                user_id: 'me',
			                channel_id: 'c',
			                last_post_at: 1617311494451,
			                last_viewed_at: 1617311494451,
			                last_update_at: 1617311494451,
			                mention_count: 3,
			                msg_count: 10,
			                roles: 'guest',
			                notify_props: \{
			                    desktop: 'default',
			                    email: 'default',
			                    mark_unread: 'mention',
			                    push: 'mention',
			                    ignore_channel_mentions: 'default',
			                \},
			            \},
			        ];
			
			        await operator.handleMyChannel(\{
			            channels,
			            myChannels,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: myChannels,
			            tableName: 'MyChannel',
			            prepareRecordsOnly: false,
			            buildKeyRecordBy: buildMyChannelKey,
			            transformer: transformMyChannelRecord,
			        \}, 'handleMyChannel');
			    \});
			
			    it('=> HandleMyChannel: should keep the previous lastFetchedAt for MY_CHANNEL', async () => \{
			        const channels: Channel[] = [\{
			            id: 'c',
			            name: 'channel',
			            display_name: 'Channel',
			            type: 'O',
			            create_at: 1,
			            update_at: 1,
			            delete_at: 0,
			            team_id: '123',
			            header: '',
			            purpose: '',
			            last_post_at: 2,
			            creator_id: 'me',
			            total_msg_count: 20,
			            extra_update_at: 0,
			            shared: false,
			            scheme_id: null,
			            group_constrained: false,
			        \}];
			        const myChannels: ChannelMembership[] = [
			            \{
			                id: 'c',
			                user_id: 'me',
			                channel_id: 'c',
			                last_post_at: 1617311494451,
			                last_viewed_at: 1617311494451,
			                last_update_at: 1617311494451,
			                mention_count: 3,
			                msg_count: 10,
			                roles: 'guest',
			                notify_props: \{
			                    desktop: 'default',
			                    email: 'default',
			                    mark_unread: 'mention',
			                    push: 'mention',
			                    ignore_channel_mentions: 'default',
			                \},
			            \},
			        ];
			
			        await operator.handleMyChannel(\{
			            channels,
			            myChannels,
			            prepareRecordsOnly: false,
			        \});
			
			        await updateMyChannelLastFetchedAt(serverUrl, 'c', 123456789, false);
			        myChannels[0].last_viewed_at = 1617311494452;
			        const updated = await operator.handleMyChannel(\{
			            channels,
			            myChannels,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(updated[0].lastFetchedAt).toBe(123456789);
			    \});
			
			    it('=> HandleChannelMembership: should write to the CHANNEL_MEMBERSHIP table', async () => \{
			        expect.assertions(2);
			        const channelMemberships: ChannelMembership[] = [
			            \{
			                id: '17bfnb1uwb8epewp4q3x3rx9go-9ciscaqbrpd6d8s68k76xb9bte',
			                channel_id: '17bfnb1uwb8epewp4q3x3rx9go',
			                user_id: '9ciscaqbrpd6d8s68k76xb9bte',
			                roles: 'wqyby5r5pinxxdqhoaomtacdhc',
			                last_viewed_at: 1613667352029,
			                msg_count: 3864,
			                mention_count: 0,
			                notify_props: \{
			                    desktop: 'default',
			                    email: 'default',
			                    ignore_channel_mentions: 'default',
			                    mark_unread: 'mention',
			                    push: 'default',
			                \},
			                last_update_at: 1613667352029,
			                scheme_user: true,
			                scheme_admin: false,
			            \},
			            \{
			                id: '1yw6gxfr4bn1jbyp9nr7d53yew-9ciscaqbrpd6d8s68k76xb9bte',
			                channel_id: '1yw6gxfr4bn1jbyp9nr7d53yew',
			                user_id: '9ciscaqbrpd6d8s68k76xb9bte',
			                roles: 'channel_user',
			                last_viewed_at: 1615300540549,
			                msg_count: 16,
			                mention_count: 0,
			                notify_props: \{
			                    desktop: 'default',
			                    email: 'default',
			                    ignore_channel_mentions: 'default',
			                    mark_unread: 'all',
			                    push: 'default',
			                \},
			                last_update_at: 1615300540549,
			                scheme_user: true,
			                scheme_admin: false,
			            \},
			        ];
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			
			        await operator.handleChannelMembership(\{
			            channelMemberships,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'user_id',
			            createOrUpdateRawValues: channelMemberships,
			            tableName: 'ChannelMembership',
			            prepareRecordsOnly: false,
			            buildKeyRecordBy: buildChannelMembershipKey,
			            transformer: transformChannelMembershipRecord,
			        \}, 'handleChannelMembership');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\channel.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\group.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			// See LICENSE.txt for license information.
			
			import \{MM_TABLES\} from '@constants/database';
			import DatabaseManager from '@database/manager';
			import \{
			    transformGroupRecord,
			\} from '@database/operator/server_data_operator/transformers/group';
			
			import type ServerDataOperator from '..';
			
			describe('*** Operator: Group Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> handleGroups: should write to the GROUP table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const groups: Group[] = [
			            \{
			                id: 'kjlw9j1ttnxwig7tnqgebg7dtipno',
			                name: 'test',
			                display_name: 'Test',
			                source: 'custom',
			                remote_id: 'iuh4r89egnslnvakjsdjhg',
			                description: 'Test description',
			                member_count: 0,
			                allow_reference: true,
			                create_at: 0,
			                update_at: 0,
			                delete_at: 0,
			            \},
			        ];
			
			        await operator.handleGroups(\{
			            groups,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: groups,
			            tableName: MM_TABLES.SERVER.GROUP,
			            prepareRecordsOnly: false,
			            transformer: transformGroupRecord,
			        \}, 'handleGroups');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\group.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\index.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import DatabaseManager from '@database/manager';
			import \{
			    transformConfigRecord,
			    transformCustomEmojiRecord,
			    transformRoleRecord,
			    transformSystemRecord,
			\} from '@database/operator/server_data_operator/transformers/general';
			
			import type ServerDataOperator from '..';
			
			describe('*** DataOperator: Base Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> HandleRole: should write to the ROLE table', async () => \{
			        expect.assertions(1);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			
			        const roles: Role[] = [
			            \{
			                id: 'custom-role-id-1',
			                name: 'custom-role-1',
			                permissions: ['custom-permission-1'],
			            \},
			        ];
			
			        await operator.handleRole(\{
			            roles,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            transformer: transformRoleRecord,
			            createOrUpdateRawValues: roles,
			            tableName: 'Role',
			            prepareRecordsOnly: false,
			        \}, 'handleRole');
			    \});
			
			    it('=> HandleCustomEmojis: should write to the CUSTOM_EMOJI table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const emojis: CustomEmoji[] = [
			            \{
			                id: 'i',
			                create_at: 1580913641769,
			                update_at: 1580913641769,
			                delete_at: 0,
			                creator_id: '4cprpki7ri81mbx8efixcsb8jo',
			                name: 'boomI',
			            \},
			        ];
			
			        await operator.handleCustomEmojis(\{
			            emojis,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'name',
			            createOrUpdateRawValues: emojis,
			            tableName: 'CustomEmoji',
			            prepareRecordsOnly: false,
			            transformer: transformCustomEmojiRecord,
			        \}, 'handleCustomEmojis');
			    \});
			
			    it('=> HandleSystem: should write to the SYSTEM table', async () => \{
			        expect.assertions(1);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			
			        const systems = [\{id: 'system-1', value: 'system-1'\}];
			
			        await operator.handleSystem(\{
			            systems,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            transformer: transformSystemRecord,
			            createOrUpdateRawValues: systems,
			            tableName: 'System',
			            prepareRecordsOnly: false,
			        \}, 'handleSystem');
			    \});
			
			    it('=> HandleConfig: should write to the CONFIG table', async () => \{
			        expect.assertions(1);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			
			        const configs = [\{id: 'config-1', value: 'config-1'\}];
			        const configsToDelete = [\{id: 'toDelete', value: 'toDelete'\}];
			
			        await operator.handleConfigs(\{
			            configs,
			            configsToDelete,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            transformer: transformConfigRecord,
			            createOrUpdateRawValues: configs,
			            tableName: 'Config',
			            prepareRecordsOnly: false,
			            deleteRawValues: configsToDelete,
			        \}, 'handleConfigs');
			    \});
			
			    it('=> No table name: should not call execute if tableName is invalid', async () => \{
			        expect.assertions(3);
			
			        const appDatabase = DatabaseManager.appDatabase?.database;
			        const appOperator = DatabaseManager.appDatabase?.operator;
			        expect(appDatabase).toBeTruthy();
			        expect(appOperator).toBeTruthy();
			
			        await expect(
			            operator?.handleRecords(\{
			                fieldName: 'invalidField',
			                tableName: 'INVALID_TABLE_NAME',
			                transformer: transformSystemRecord,
			                createOrUpdateRawValues: [\{id: 'tos-1', value: '1'\}],
			                prepareRecordsOnly: false,
			            \}, 'test'),
			        ).rejects.toThrow(Error);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\post.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Database, Q\} from '@nozbe/watermelondb';
			
			import \{ActionType\} from '@constants';
			import \{OperationType\} from '@constants/database';
			import DatabaseManager from '@database/manager';
			import \{buildDraftKey\} from '@database/operator/server_data_operator/comparators';
			import \{transformDraftRecord, transformPostsInChannelRecord\} from '@database/operator/server_data_operator/transformers/post';
			import \{createPostsChain\} from '@database/operator/utils/post';
			
			import \{exportedForTest\} from './post';
			
			import type ServerDataOperator from '..';
			import type PostsInChannelModel from '@typings/database/models/servers/posts_in_channel';
			
			Q.sortBy = jest.fn().mockImplementation((field) => \{
			    return Q.where(field, Q.gte(0));
			\});
			describe('*** Operator: Post Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> HandleDraft: should write to the the Draft table', async () => \{
			        expect.assertions(1);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const drafts = [
			            \{
			                channel_id: '4r9jmr7eqt8dxq3f9woypzurrychannelid',
			                files: [
			                    \{
			                        id: '322dxx',
			                        user_id: 'user_id',
			                        post_id: 'post_id',
			                        create_at: 123,
			                        update_at: 456,
			                        delete_at: 789,
			                        name: 'an_image',
			                        extension: 'jpg',
			                        size: 10,
			                        mime_type: 'image',
			                        width: 10,
			                        height: 10,
			                        has_preview_image: false,
			                        clientId: 'clientId',
			                    \},
			                ],
			                message: 'test draft message for post',
			                root_id: '',
			            \},
			        ];
			
			        await operator.handleDraft(\{drafts, prepareRecordsOnly: false\});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            buildKeyRecordBy: buildDraftKey,
			            fieldName: 'channel_id',
			            transformer: transformDraftRecord,
			            createOrUpdateRawValues: drafts,
			            tableName: 'Draft',
			            prepareRecordsOnly: false,
			        \}, 'handleDraft');
			    \});
			
			    it('=> HandlePosts: should write to the Post and its sub-child tables', async () => \{
			        // expect.assertions(12);
			
			        const posts: Post[] = [
			            \{
			                id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                create_at: 1596032651747,
			                update_at: 1596032651747,
			                edit_at: 0,
			                delete_at: 0,
			                is_pinned: false,
			                is_following: false,
			                user_id: 'q3mzxua9zjfczqakxdkowc6u6yy',
			                channel_id: 'xxoq1p6bqg7dkxb3kj1mcjoungw',
			                root_id: '',
			                original_id: '',
			                message: "I'll second these kudos!  Thanks m!",
			                type: '',
			                props: \{\},
			                hashtags: '',
			                pending_post_id: '',
			                reply_count: 4,
			                last_reply_at: 0,
			                participants: null,
			                metadata: \{
			                    images: \{
			                        'https://community-release.mattermost.com/api/v4/image?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F6913320%3Fs%3D400%26v%3D4': \{
			                            width: 400,
			                            height: 400,
			                            format: 'png',
			                            frame_count: 0,
			                        \},
			                    \},
			                    reactions: [
			                        \{
			                            user_id: 'njic1w1k5inefp848jwk6oukio',
			                            post_id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                            emoji_name: 'clap',
			                            create_at: 1608252965442,
			                        \},
			                    ],
			                    embeds: [
			                        \{
			                            type: 'opengraph',
			                            url: 'https://github.com/mickmister/mattermost-plugin-default-theme',
			                            data: \{
			                                type: 'object',
			                                url: 'https://github.com/mickmister/mattermost-plugin-default-theme',
			                                title: 'mickmister/mattermost-plugin-default-theme',
			                                description: 'Contribute to mickmister/mattermost-plugin-default-theme development by creating an account on GitHub.',
			                                determiner: '',
			                                site_name: 'GitHub',
			                                locale: '',
			                                locales_alternate: null,
			                                images: [
			                                    \{
			                                        url: '',
			                                        secure_url: 'https://community-release.mattermost.com/api/v4/image?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F6913320%3Fs%3D400%26v%3D4',
			                                        type: '',
			                                        width: 0,
			                                        height: 0,
			                                    \},
			                                ],
			                                audios: null,
			                                videos: null,
			                            \},
			                        \},
			                    ],
			                    emojis: [
			                        \{
			                            id: 'dgwyadacdbbwjc8t357h6hwsrh',
			                            create_at: 1502389307432,
			                            update_at: 1502389307432,
			                            delete_at: 0,
			                            creator_id: 'x6sdh1ok1tyd9f4dgq4ybw839a',
			                            name: 'thanks',
			                        \},
			                    ],
			                    files: [
			                        \{
			                            id: 'f1oxe5rtepfs7n3zifb4sso7po',
			                            user_id: '89ertha8xpfsumpucqppy5knao',
			                            post_id: 'a7ebyw883trm884p1qcgt8yw4a',
			                            create_at: 1608270920357,
			                            update_at: 1608270920357,
			                            delete_at: 0,
			                            name: '4qtwrg.jpg',
			                            extension: 'jpg',
			                            size: 89208,
			                            mime_type: 'image/jpeg',
			                            width: 500,
			                            height: 656,
			                            has_preview_image: true,
			                            mini_preview:
			                                '/9j/2wCEAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRQBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIABAAEAMBIgACEQEDEQH/xAGiAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgsQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+gEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoLEQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AN/T/iZp+pX15FpUmnwLbXtpJpyy2sQLw8CcBXA+bksCDnHGOaf4W+P3xIshbQ6loB8RrbK11f3FpbBFW3ZwiFGHB2kr25BIOeCPPbX4S3407T7rTdDfxFNIpDyRaw9lsB4OECHGR15yO4GK6fRPhR4sGmSnxAs8NgchNOjvDPsjz8qSHA37cDk5JPPFdlOpTdPlcVt/Ku1lrvr17b67EPnjrH8/626H/9k=',
			                        \},
			                    ],
			                \},
			            \},
			            \{
			                id: '8fcnk3p1jt8mmkaprgajoxz115a',
			                create_at: 1596104683748,
			                update_at: 1596104683748,
			                edit_at: 0,
			                delete_at: 0,
			                is_pinned: false,
			                is_following: false,
			                user_id: 'hy5sq51sebfh58ktrce5ijtcwyy',
			                channel_id: 'xxoq1p6bqg7dkxb3kj1mcjoungw',
			                root_id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                original_id: '',
			                message: 'a added to the channel by j.',
			                type: 'system_add_to_channel',
			                props: \{
			                    addedUserId: 'z89qsntet7bimd3xddfu7u9ncdaxc',
			                    addedUsername: 'a',
			                    userId: 'hy5sdfdfq51sebfh58ktrce5ijtcwy',
			                    username: 'j',
			                \},
			                hashtags: '',
			                pending_post_id: '',
			                reply_count: 0,
			                last_reply_at: 0,
			                participants: null,
			                metadata: \{\},
			            \},
			            \{
			                id: '3y3w3a6gkbg73bnj3xund9o5ic',
			                create_at: 1596277483749,
			                update_at: 1596277483749,
			                edit_at: 0,
			                delete_at: 0,
			                is_pinned: false,
			                is_following: false,
			                user_id: '44ud4m9tqwby3mphzzdwm7h31sr',
			                channel_id: 'xxoq1p6bqg7dkxb3kj1mcjoungw',
			                root_id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                original_id: '',
			                message: 'Great work M!',
			                type: '',
			                props: \{\},
			                hashtags: '',
			                pending_post_id: '',
			                reply_count: 4,
			                last_reply_at: 0,
			                participants: null,
			                metadata: \{\},
			            \},
			        ];
			
			        const order = [
			            '8swgtrrdiff89jnsiwiip3y1eoe',
			            '8fcnk3p1jt8mmkaprgajoxz115a',
			            '3y3w3a6gkbg73bnj3xund9o5ic',
			        ];
			        const actionType = ActionType.POSTS.RECEIVED_IN_CHANNEL;
			
			        const spyOnHandleFiles = jest.spyOn(operator, 'handleFiles');
			        const spyOnHandleReactions = jest.spyOn(operator, 'handleReactions');
			        const spyOnHandleCustomEmojis = jest.spyOn(operator, 'handleCustomEmojis');
			        const spyOnHandlePostsInThread = jest.spyOn(operator, 'handlePostsInThread');
			        const spyOnHandlePostsInChannel = jest.spyOn(operator, 'handlePostsInChannel');
			
			        // handlePosts will in turn call handlePostsInThread
			        await operator.handlePosts(\{
			            actionType,
			            order,
			            posts,
			            previousPostId: '',
			        \});
			
			        expect(spyOnHandleReactions).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleReactions).toHaveBeenCalledWith(\{
			            postsReactions: [\{
			                post_id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                reactions: [
			                    \{
			                        user_id: 'njic1w1k5inefp848jwk6oukio',
			                        post_id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                        emoji_name: 'clap',
			                        create_at: 1608252965442,
			                    \},
			                ],
			            \}],
			            prepareRecordsOnly: true,
			        \});
			
			        expect(spyOnHandleFiles).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleFiles).toHaveBeenCalledWith(\{
			            files: [
			                \{
			                    id: 'f1oxe5rtepfs7n3zifb4sso7po',
			                    user_id: '89ertha8xpfsumpucqppy5knao',
			                    post_id: 'a7ebyw883trm884p1qcgt8yw4a',
			                    create_at: 1608270920357,
			                    update_at: 1608270920357,
			                    delete_at: 0,
			                    name: '4qtwrg.jpg',
			                    extension: 'jpg',
			                    size: 89208,
			                    mime_type: 'image/jpeg',
			                    width: 500,
			                    height: 656,
			                    has_preview_image: true,
			                    mini_preview:
			                        '/9j/2wCEAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRQBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIABAAEAMBIgACEQEDEQH/xAGiAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgsQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+gEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoLEQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AN/T/iZp+pX15FpUmnwLbXtpJpyy2sQLw8CcBXA+bksCDnHGOaf4W+P3xIshbQ6loB8RrbK11f3FpbBFW3ZwiFGHB2kr25BIOeCPPbX4S3407T7rTdDfxFNIpDyRaw9lsB4OECHGR15yO4GK6fRPhR4sGmSnxAs8NgchNOjvDPsjz8qSHA37cDk5JPPFdlOpTdPlcVt/Ku1lrvr17b67EPnjrH8/626H/9k=',
			                \},
			            ],
			            prepareRecordsOnly: true,
			        \});
			
			        expect(spyOnHandleCustomEmojis).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleCustomEmojis).toHaveBeenCalledWith(\{
			            prepareRecordsOnly: true,
			            emojis: [
			                \{
			                    id: 'dgwyadacdbbwjc8t357h6hwsrh',
			                    create_at: 1502389307432,
			                    update_at: 1502389307432,
			                    delete_at: 0,
			                    creator_id: 'x6sdh1ok1tyd9f4dgq4ybw839a',
			                    name: 'thanks',
			                \},
			            ],
			        \});
			
			        const postInThreadExpected: Record<string, Post[]> = \{\};
			        posts.filter((p) => p.root_id).forEach((p) => \{
			            if (postInThreadExpected[p.root_id]) \{
			                postInThreadExpected[p.root_id].push(p);
			            \} else \{
			                postInThreadExpected[p.root_id] = [p];
			            \}
			        \});
			        expect(spyOnHandlePostsInThread).toHaveBeenCalledTimes(1);
			        expect(spyOnHandlePostsInThread).toHaveBeenCalledWith(postInThreadExpected, ActionType.POSTS.RECEIVED_IN_CHANNEL, true);
			
			        const linkedPosts = createPostsChain(\{order, posts, previousPostId: ''\});
			        expect(spyOnHandlePostsInChannel).toHaveBeenCalledTimes(1);
			        expect(spyOnHandlePostsInChannel).toHaveBeenCalledWith(linkedPosts.slice(0, 3), actionType, true);
			    \});
			\});
			
			describe('*** Operator: merge chunks ***', () => \{
			    const \{mergePostInChannelChunks\} = exportedForTest;
			    let database: Database;
			    let operator: ServerDataOperator;
			    const databaseName = 'baseHandler.test.com';
			    const channelId = '1234';
			    beforeEach(async () => \{
			        await DatabaseManager.init([databaseName]);
			        const serverDatabase = DatabaseManager.serverDatabases[databaseName]!;
			        database = serverDatabase.database;
			        operator = serverDatabase.operator;
			    \});
			
			    afterEach(async () => \{
			        await DatabaseManager.destroyServerDatabase(databaseName);
			    \});
			
			    it('merge on empty chunks', async () => \{
			        const newChunk = await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 0, latest: 100\}\}\});
			        const chunks: PostsInChannelModel[] = [];
			        const result = await mergePostInChannelChunks(newChunk, chunks);
			        expect(result.length).toBe(0);
			        expect(newChunk.earliest).toBe(0);
			        expect(newChunk.latest).toBe(100);
			    \});
			
			    it('remove contained chunks', async () => \{
			        const newChunk = await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 0, latest: 100\}\}\});
			        const chunks: PostsInChannelModel[] = [
			            await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 20, latest: 80\}\}\}),
			        ];
			        const result = await mergePostInChannelChunks(newChunk, chunks);
			        expect(result.length).toBe(1);
			        expect(newChunk.earliest).toBe(0);
			        expect(newChunk.latest).toBe(100);
			        expect(result[0]).toBe(chunks[0]);
			        expect(chunks[0]._preparedState).toBe('destroyPermanently');
			    \});
			
			    it('merge intersecting chunks', async () => \{
			        const newChunk = await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 50, latest: 100\}\}\});
			        const chunks: PostsInChannelModel[] = [
			            await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 25, latest: 70\}\}\}),
			            await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 80, latest: 125\}\}\}),
			        ];
			        const result = await mergePostInChannelChunks(newChunk, chunks);
			        expect(result.length).toBe(3);
			        expect(newChunk.earliest).toBe(25);
			        expect(newChunk.latest).toBe(125);
			        expect(newChunk._preparedState).toBe('update');
			        expect(result[0]).toBe(chunks[0]);
			        expect(chunks[0]._preparedState).toBe('destroyPermanently');
			        expect(result[1]).toBe(chunks[1]);
			        expect(chunks[1]._preparedState).toBe('destroyPermanently');
			        expect(result[2]).toBe(newChunk);
			        await operator.batchRecords(result, 'test');
			    \});
			
			    it('merge with the chunk present', async () => \{
			        const newChunk = await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 50, latest: 100\}\}\});
			        const chunks: PostsInChannelModel[] = [
			            await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 25, latest: 70\}\}\}),
			            newChunk,
			            await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 80, latest: 125\}\}\}),
			        ];
			        const result = await mergePostInChannelChunks(newChunk, chunks);
			        expect(result.length).toBe(3);
			        expect(newChunk.earliest).toBe(25);
			        expect(newChunk.latest).toBe(125);
			        expect(newChunk._preparedState).toBe('update');
			        expect(result[0]).toBe(chunks[0]);
			        expect(chunks[0]._preparedState).toBe('destroyPermanently');
			        expect(result[1]).toBe(chunks[2]);
			        expect(chunks[2]._preparedState).toBe('destroyPermanently');
			        expect(result[2]).toBe(newChunk);
			        await operator.batchRecords(result, 'test');
			    \});
			
			    it('do nothing with no intersecting chunks', async () => \{
			        const newChunk = await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 50, latest: 100\}\}\});
			        const chunks: PostsInChannelModel[] = [
			            await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 25, latest: 40\}\}\}),
			            newChunk,
			            await transformPostsInChannelRecord(\{action: OperationType.CREATE, database, value: \{record: undefined, raw: \{channel_id: channelId, earliest: 110, latest: 125\}\}\}),
			        ];
			        const result = await mergePostInChannelChunks(newChunk, chunks);
			        expect(result.length).toBe(0);
			        expect(newChunk.earliest).toBe(50);
			        expect(newChunk.latest).toBe(100);
			        expect(newChunk._preparedState).toBe('create');
			        for (const chunk of chunks) \{
			            expect(chunk._preparedState).toBe('create');
			        \}
			        await operator.batchRecords(result, 'test');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\post.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\reaction.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import DatabaseManager from '@database/manager';
			
			import type ServerDataOperator from '@database/operator/server_data_operator';
			
			describe('*** Operator: User Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> HandleReactions: should write to Reactions table', async () => \{
			        expect.assertions(2);
			
			        const spyOnPrepareRecords = jest.spyOn(operator, 'prepareRecords');
			        const spyOnBatchOperation = jest.spyOn(operator, 'batchRecords');
			
			        await operator.handleReactions(\{
			            postsReactions: [\{
			                post_id: '4r9jmr7eqt8dxq3f9woypzurry',
			                reactions: [
			                    \{
			                        create_at: 1608263728086,
			                        emoji_name: 'p4p1',
			                        post_id: '4r9jmr7eqt8dxq3f9woypzurry',
			                        user_id: 'ooumoqgq3bfiijzwbn8badznwc',
			                    \},
			                ],
			            \}],
			            prepareRecordsOnly: false,
			        \});
			
			        // Called twice:  Once for Reaction record
			        expect(spyOnPrepareRecords).toHaveBeenCalledTimes(1);
			
			        // Only one batch operation for both tables
			        expect(spyOnBatchOperation).toHaveBeenCalledTimes(1);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\reaction.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\team.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import DatabaseManager from '@database/manager';
			import \{
			    buildTeamMembershipKey,
			    buildTeamSearchHistoryKey,
			\} from '@database/operator/server_data_operator/comparators';
			import \{
			    transformMyTeamRecord,
			    transformTeamChannelHistoryRecord,
			    transformTeamMembershipRecord,
			    transformTeamRecord,
			    transformTeamSearchHistoryRecord,
			\} from '@database/operator/server_data_operator/transformers/team';
			
			import type ServerDataOperator from '..';
			
			describe('*** Operator: Team Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> HandleTeam: should write to the TEAM table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const teams: Team[] = [
			            \{
			                id: 'rcgiyftm7jyrxnmdfdfa1osd8zswby',
			                create_at: 1445538153952,
			                update_at: 1588876392150,
			                delete_at: 0,
			                display_name: 'Contributors',
			                name: 'core',
			                description: '',
			                email: '',
			                type: 'O',
			                company_name: '',
			                allowed_domains: '',
			                invite_id: 'codoy5s743rq5mk18i7u5dfdfksz7e',
			                allow_open_invite: true,
			                last_team_icon_update: 1525181587639,
			                scheme_id: 'hbwgrncq1pfcdkpotzidfdmarn95o',
			                group_constrained: null,
			            \},
			        ];
			
			        await operator.handleTeam(\{
			            teams,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: teams,
			            tableName: 'Team',
			            prepareRecordsOnly: false,
			            transformer: transformTeamRecord,
			        \}, 'handleTeam');
			    \});
			
			    it('=> HandleTeamMemberships: should write to the TEAM_MEMBERSHIP table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const teamMemberships: TeamMembership[] = [
			            \{
			                team_id: 'a',
			                user_id: 'ab',
			                roles: '',
			                delete_at: 0,
			                msg_count: 0,
			                mention_count: 0,
			                scheme_user: true,
			                scheme_admin: false,
			            \},
			        ];
			
			        await operator.handleTeamMemberships(\{
			            teamMemberships,
			            prepareRecordsOnly: false,
			        \});
			
			        const memberships = teamMemberships.map((m) => (\{
			            ...m,
			            id: \`\$\{m.team_id\}-\$\{m.user_id\}\`,
			        \}));
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'user_id',
			            createOrUpdateRawValues: memberships,
			            tableName: 'TeamMembership',
			            prepareRecordsOnly: false,
			            buildKeyRecordBy: buildTeamMembershipKey,
			            transformer: transformTeamMembershipRecord,
			        \}, 'handleTeamMemberships');
			    \});
			
			    it('=> HandleMyTeam: should write to the MY_TEAM table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const myTeams = [
			            \{
			                id: 'teamA',
			                roles: 'roleA, roleB, roleC',
			            \},
			        ];
			
			        await operator.handleMyTeam(\{
			            myTeams,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: myTeams,
			            tableName: 'MyTeam',
			            prepareRecordsOnly: false,
			            transformer: transformMyTeamRecord,
			        \}, 'handleMyTeam');
			    \});
			
			    it('=> HandleTeamChannelHistory: should write to the TEAM_CHANNEL_HISTORY table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const teamChannelHistories = [
			            \{
			                id: 'a',
			                channel_ids: ['ca', 'cb'],
			            \},
			        ];
			
			        await operator.handleTeamChannelHistory(\{
			            teamChannelHistories,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: teamChannelHistories,
			            tableName: 'TeamChannelHistory',
			            prepareRecordsOnly: false,
			            transformer: transformTeamChannelHistoryRecord,
			        \}, 'handleTeamChannelHistory');
			    \});
			
			    it('=> HandleTeamSearchHistory: should write to the TEAM_SEARCH_HISTORY table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const teamSearchHistories: TeamSearchHistory[] = [
			            \{
			                team_id: 'a',
			                term: 'termA',
			                display_term: 'termA',
			                created_at: 1445538153952,
			            \},
			        ];
			
			        await operator.handleTeamSearchHistory(\{
			            teamSearchHistories,
			            prepareRecordsOnly: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'team_id',
			            createOrUpdateRawValues: teamSearchHistories,
			            tableName: 'TeamSearchHistory',
			            prepareRecordsOnly: false,
			            buildKeyRecordBy: buildTeamSearchHistoryKey,
			            transformer: transformTeamSearchHistoryRecord,
			        \}, 'handleTeamSearchHistory');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\team.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\thread.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import DatabaseManager from '@database/manager';
			import \{transformThreadRecord, transformThreadParticipantRecord, transformThreadInTeamRecord, transformTeamThreadsSyncRecord\} from '@database/operator/server_data_operator/transformers/thread';
			
			import type ServerDataOperator from '..';
			
			jest.mock('@database/operator/utils/thread', () => \{
			    return \{
			        sanitizeThreadParticipants: (\{rawParticipants\}: \{rawParticipants: ThreadParticipant[]\}) => \{
			            return \{
			                createParticipants: rawParticipants.map((participant) => (\{
			                    raw: participant,
			                \})),
			            \};
			        \},
			    \};
			\});
			
			describe('*** Operator: Thread Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> HandleThreads: should write to the the Thread & ThreadParticipant & ThreadsInTeam tables', async () => \{
			        expect.assertions(4);
			
			        const spyOnBatchOperation = jest.spyOn(operator, 'batchRecords');
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const spyOnHandleThreadParticipants = jest.spyOn(operator, 'handleThreadParticipants');
			        const spyOnHandleThreadInTeam = jest.spyOn(operator, 'handleThreadInTeam');
			
			        const threads = [
			            \{
			                id: 'thread-1',
			                reply_count: 2,
			                last_reply_at: 123,
			                last_viewed_at: 123,
			                participants: [\{
			                    id: 'user-1',
			                \}],
			                is_following: true,
			                unread_replies: 0,
			                unread_mentions: 0,
			                lastFetchedAt: 0,
			            \},
			        ] as ThreadWithLastFetchedAt[];
			
			        const threadsMap = \{team_id_1: threads\};
			        await operator.handleThreads(\{threads, prepareRecordsOnly: false, teamId: 'team_id_1'\});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            transformer: transformThreadRecord,
			            createOrUpdateRawValues: threads,
			            tableName: 'Thread',
			            prepareRecordsOnly: true,
			        \}, 'handleThreads(NEVER)');
			
			        // Should handle participants
			        expect(spyOnHandleThreadParticipants).toHaveBeenCalledWith(\{
			            threadsParticipants: threads.map((thread) => (\{
			                thread_id: thread.id,
			                participants: thread.participants.map((participant) => (\{
			                    id: participant.id,
			                    thread_id: thread.id,
			                \})),
			            \})),
			            prepareRecordsOnly: true,
			        \});
			
			        expect(spyOnHandleThreadInTeam).toHaveBeenCalledWith(\{
			            threadsMap,
			            prepareRecordsOnly: true,
			        \});
			
			        // Only one batch operation for both tables
			        expect(spyOnBatchOperation).toHaveBeenCalledTimes(1);
			    \});
			
			    it('=> HandleThreadParticipants: should write to the the ThreadParticipant table', async () => \{
			        expect.assertions(1);
			
			        const spyOnPrepareRecords = jest.spyOn(operator, 'prepareRecords');
			
			        const threadsParticipants = [
			            \{
			                thread_id: 'thread-1',
			                participants: [\{
			                    id: 'user-1',
			                    thread_id: 'thread-1',
			                \}],
			            \},
			        ];
			
			        await operator.handleThreadParticipants(\{threadsParticipants, prepareRecordsOnly: false\});
			
			        expect(spyOnPrepareRecords).toHaveBeenCalledWith(\{
			            createRaws: [\{
			                raw: threadsParticipants[0].participants[0],
			            \}],
			            transformer: transformThreadParticipantRecord,
			            tableName: 'ThreadParticipant',
			        \});
			    \});
			
			    it('=> HandleThreadInTeam: should write to the the ThreadsInTeam table', async () => \{
			        expect.assertions(1);
			
			        const spyOnPrepareRecords = jest.spyOn(operator, 'prepareRecords');
			
			        const team1Threads = [
			            \{
			                id: 'thread-1',
			                reply_count: 2,
			                last_reply_at: 123,
			                last_viewed_at: 123,
			                participants: [\{
			                    id: 'user-1',
			                \}],
			                is_following: true,
			                unread_replies: 0,
			                unread_mentions: 0,
			            \},
			            \{
			                id: 'thread-2',
			                reply_count: 2,
			                last_reply_at: 123,
			                last_viewed_at: 123,
			                participants: [\{
			                    id: 'user-1',
			                \}],
			                is_following: true,
			                unread_replies: 0,
			                unread_mentions: 0,
			            \},
			        ] as Thread[];
			
			        const team2Threads = [
			            \{
			                id: 'thread-2',
			                reply_count: 2,
			                last_reply_at: 123,
			                last_viewed_at: 123,
			                participants: [\{
			                    id: 'user-1',
			                \}],
			                is_following: true,
			                unread_replies: 2,
			                unread_mentions: 0,
			            \},
			        ] as Thread[];
			
			        const threadsMap = \{
			            team_id_1: team1Threads,
			            team_id_2: team2Threads,
			        \};
			
			        await operator.handleThreadInTeam(\{threadsMap, prepareRecordsOnly: false\});
			
			        expect(spyOnPrepareRecords).toHaveBeenCalledWith(\{
			            createRaws: [\{
			                raw: \{team_id: 'team_id_1', thread_id: 'thread-2'\},
			                record: undefined,
			            \}, \{
			                raw: \{team_id: 'team_id_2', thread_id: 'thread-2'\},
			                record: undefined,
			            \}],
			            transformer: transformThreadInTeamRecord,
			            tableName: 'ThreadsInTeam',
			        \});
			    \});
			
			    it('=> HandleTeamThreadsSync: should write to the the TeamThreadsSync table', async () => \{
			        expect.assertions(1);
			
			        const spyOnPrepareRecords = jest.spyOn(operator, 'prepareRecords');
			
			        const data = [
			            \{
			                id: 'team_id_1',
			                earliest: 100,
			                latest: 200,
			            \},
			            \{
			                id: 'team_id_2',
			                earliest: 100,
			                latest: 300,
			            \},
			        ] as TeamThreadsSync[];
			
			        await operator.handleTeamThreadsSync(\{data, prepareRecordsOnly: false\});
			
			        expect(spyOnPrepareRecords).toHaveBeenCalledWith(\{
			            createRaws: [\{
			                raw: \{id: 'team_id_1', earliest: 100, latest: 200\},
			            \}, \{
			                raw: \{id: 'team_id_2', earliest: 100, latest: 300\},
			            \}],
			            updateRaws: [],
			            transformer: transformTeamThreadsSyncRecord,
			            tableName: 'TeamThreadsSync',
			        \});
			    \});
			
			    it('=> HandleTeamThreadsSync: should update the record in TeamThreadsSync table', async () => \{
			        expect.assertions(1);
			
			        const spyOnPrepareRecords = jest.spyOn(operator, 'prepareRecords');
			
			        const data = [
			            \{
			                id: 'team_id_1',
			                earliest: 100,
			                latest: 300,
			            \},
			        ] as TeamThreadsSync[];
			
			        await operator.handleTeamThreadsSync(\{data, prepareRecordsOnly: false\});
			
			        expect(spyOnPrepareRecords).toHaveBeenCalledWith(\{
			            createRaws: [],
			            updateRaws: [
			                expect.objectContaining(\{
			                    raw: \{id: 'team_id_1', earliest: 100, latest: 300\},
			                \}),
			            ],
			            transformer: transformTeamThreadsSyncRecord,
			            tableName: 'TeamThreadsSync',
			        \});
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\thread.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\user.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import DatabaseManager from '@database/manager';
			import \{buildPreferenceKey\} from '@database/operator/server_data_operator/comparators';
			import \{
			    transformPreferenceRecord,
			    transformUserRecord,
			\} from '@database/operator/server_data_operator/transformers/user';
			
			import type ServerDataOperator from '@database/operator/server_data_operator';
			
			describe('*** Operator: User Handlers tests ***', () => \{
			    let operator: ServerDataOperator;
			
			    beforeAll(async () => \{
			        await DatabaseManager.init(['baseHandler.test.com']);
			        operator = DatabaseManager.serverDatabases['baseHandler.test.com']!.operator;
			    \});
			
			    it('=> HandleReactions: should write to Reactions table', async () => \{
			        expect.assertions(2);
			
			        const spyOnPrepareRecords = jest.spyOn(operator, 'prepareRecords');
			        const spyOnBatchOperation = jest.spyOn(operator, 'batchRecords');
			
			        await operator.handleReactions(\{
			            postsReactions: [\{
			                post_id: '4r9jmr7eqt8dxq3f9woypzurry',
			                reactions: [
			                    \{
			                        create_at: 1608263728086,
			                        emoji_name: 'p4p1',
			                        post_id: '4r9jmr7eqt8dxq3f9woypzurry',
			                        user_id: 'ooumoqgq3bfiijzwbn8badznwc',
			                    \},
			                ],
			            \}],
			            prepareRecordsOnly: false,
			        \});
			
			        // Called twice:  Once for Reaction record
			        expect(spyOnPrepareRecords).toHaveBeenCalledTimes(1);
			
			        // Only one batch operation for both tables
			        expect(spyOnBatchOperation).toHaveBeenCalledTimes(1);
			    \});
			
			    it('=> HandleUsers: should write to the User table', async () => \{
			        expect.assertions(2);
			
			        const users: UserProfile[] = [
			            \{
			                id: '9ciscaqbrpd6d8s68k76xb9bte',
			                create_at: 1599457495881,
			                update_at: 1607683720173,
			                delete_at: 0,
			                username: 'a.l',
			                auth_service: 'saml',
			                email: 'a.l@mattermost.com',
			                email_verified: true,
			                is_bot: false,
			                nickname: '',
			                first_name: 'A',
			                last_name: 'L',
			                position: 'Mobile Engineer',
			                roles: 'system_user',
			                props: \{\},
			                notify_props: \{
			                    desktop: 'all',
			                    desktop_sound: 'true',
			                    email: 'true',
			                    first_name: 'true',
			                    mark_unread: 'mention',
			                    mention_keys: '',
			                    push: 'mention',
			                    channel: 'true',
			                    auto_responder_active: 'false',
			                    auto_responder_message: 'Hello, I am out of office and unable to respond to messages.',
			                    comments: 'never',
			                    desktop_notification_sound: 'Hello',
			                    push_status: 'online',
			                \},
			                last_picture_update: 1604686302260,
			                locale: 'en',
			                timezone: \{
			                    automaticTimezone: 'Indian/Mauritius',
			                    manualTimezone: '',
			                    useAutomaticTimezone: '',
			                \},
			            \},
			        ];
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			
			        await operator.handleUsers(\{users, prepareRecordsOnly: false\});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'id',
			            createOrUpdateRawValues: users,
			            tableName: 'User',
			            prepareRecordsOnly: false,
			            transformer: transformUserRecord,
			        \}, 'handleUsers');
			    \});
			
			    it('=> HandlePreferences: should write to the PREFERENCE table', async () => \{
			        expect.assertions(2);
			
			        const spyOnHandleRecords = jest.spyOn(operator, 'handleRecords');
			        const preferences = [
			            \{
			                user_id: '9ciscaqbrpd6d8s68k76xb9bte',
			                category: 'group_channel_show',
			                name: 'qj91hepgjfn6xr4acm5xzd8zoc',
			                value: 'true',
			            \},
			            \{
			                user_id: '9ciscaqbrpd6d8s68k76xb9bte',
			                category: 'notifications',
			                name: 'email_interval',
			                value: '30',
			            \},
			            \{
			                user_id: '9ciscaqbrpd6d8s68k76xb9bte',
			                category: 'theme',
			                name: '',
			                value:
			                    '\{"awayIndicator":"#c1b966","buttonBg":"#4cbba4","buttonColor":"#ffffff","centerChannelBg":"#2f3e4e","centerChannelColor":"#dddddd","codeTheme":"solarized-dark","dndIndicator":"#e81023","errorTextColor":"#ff6461","image":"/static/files/0b8d56c39baf992e5e4c58d74fde0fd6.png","linkColor":"#a4ffeb","mentionBg":"#b74a4a","mentionColor":"#ffffff","mentionHighlightBg":"#984063","mentionHighlightLink":"#a4ffeb","newMessageSeparator":"#5de5da","onlineIndicator":"#65dcc8","sidebarBg":"#1b2c3e","sidebarHeaderBg":"#1b2c3e","sidebarHeaderTextColor":"#ffffff","sidebarText":"#ffffff","sidebarTextActiveBorder":"#66b9a7","sidebarTextActiveColor":"#ffffff","sidebarTextHoverBg":"#4a5664","sidebarUnreadText":"#ffffff","type":"Mattermost Dark"\}',
			            \},
			            \{
			                user_id: '9ciscaqbrpd6d8s68k76xb9bte',
			                category: 'tutorial_step', // we aren't using this category in the app, should be filtered
			                name: '9ciscaqbrpd6d8s68k76xb9bte',
			                value: '2',
			            \},
			        ];
			
			        await operator.handlePreferences(\{
			            preferences,
			            prepareRecordsOnly: false,
			            sync: false,
			        \});
			
			        expect(spyOnHandleRecords).toHaveBeenCalledTimes(1);
			        expect(spyOnHandleRecords).toHaveBeenCalledWith(\{
			            fieldName: 'user_id',
			            createOrUpdateRawValues: preferences.filter((p) => p.category !== 'tutorial_step'),
			            tableName: 'Preference',
			            prepareRecordsOnly: true,
			            buildKeyRecordBy: buildPreferenceKey,
			            transformer: transformPreferenceRecord,
			        \}, 'handlePreferences(NEVER)');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\handlers\\user.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\category.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{
			    transformCategoryRecord,
			    transformCategoryChannelRecord,
			\} from '@database/operator/server_data_operator/transformers/category';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('*** CATEGORY Prepare Records Test ***', () => \{
			    it('=> transformCategoryRecord: should return an array of type CategoryModel', async () => \{
			        // expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'category_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformCategoryRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'kow9j1ttnxwig7tnqgebg7dtipno',
			                    display_name: 'Test',
			                    sorting: 'recent',
			                    sort_order: 0,
			                    muted: false,
			                    collapsed: false,
			                    type: 'custom',
			                    team_id: '',
			                \} as Category,
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords.collection.table).toBe('Category');
			    \});
			
			    it('=> transformCategoryChannelRecord: should return an array of type CategoryChannelModel', async () => \{
			        // expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'category_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformCategoryChannelRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'team_id-channel_id',
			                    category_id: 'kow9j1ttnxwig7tnqgebg7dtipno',
			                    channel_id: 'channel_id',
			                    sort_order: 0,
			                \} as CategoryChannel,
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords.collection.table).toBe('CategoryChannel');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\category.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\channel.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{
			    transformChannelInfoRecord,
			    transformChannelRecord,
			    transformMyChannelRecord,
			    transformMyChannelSettingsRecord,
			    transformChannelMembershipRecord,
			\} from '@database/operator/server_data_operator/transformers/channel';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('*** CHANNEL Prepare Records Test ***', () => \{
			    it('=> transformChannelRecord: should return an array of type Channel', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'channel_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformChannelRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'kow9j1ttnxwig7tnqgebg7dtipno',
			                    create_at: 1600185541285,
			                    update_at: 1604401077256,
			                    delete_at: 0,
			                    team_id: '',
			                    type: 'D',
			                    display_name: '',
			                    name: 'jui1zkzkhh357b4bejephjz5u8daw__9ciscaqbrpd6d8s68k76xb9bte',
			                    header: 'https://mattermost)',
			                    purpose: '',
			                    last_post_at: 1617311494451,
			                    total_msg_count: 585,
			                    extra_update_at: 0,
			                    creator_id: '',
			                    scheme_id: null,
			                    group_constrained: null,
			                    shared: false,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords.collection.table).toBe('Channel');
			    \});
			
			    it('=> transformMyChannelSettingsRecord: should return an array of type MyChannelSettings', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'channel_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const raw: ChannelMembership = \{
			            channel_id: 'c',
			            user_id: 'me',
			            roles: '',
			            last_viewed_at: 0,
			            msg_count: 0,
			            mention_count: 0,
			            last_update_at: 0,
			            notify_props: \{
			                desktop: 'default',
			                email: 'default',
			                push: 'mention',
			                mark_unread: 'mention',
			                ignore_channel_mentions: 'default',
			            \},
			        \};
			
			        const preparedRecords = await transformMyChannelSettingsRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw,
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('MyChannelSettings');
			    \});
			
			    it('=> transformChannelInfoRecord: should return an array of type ChannelInfo', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'channel_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformChannelInfoRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'c',
			                    channel_id: 'c',
			                    guest_count: 10,
			                    header: 'channel info header',
			                    member_count: 10,
			                    pinned_post_count: 3,
			                    files_count: 0,
			                    purpose: 'sample channel ',
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('ChannelInfo');
			    \});
			
			    it('=> transformMyChannelRecord: should return an array of type MyChannel', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'channel_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformMyChannelRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    channel_id: 'cd',
			                    user_id: 'guest',
			                    last_post_at: 1617311494451,
			                    last_viewed_at: 1617311494451,
			                    last_update_at: 0,
			                    mention_count: 3,
			                    msg_count: 10,
			                    roles: 'guest',
			                    notify_props: \{\},
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('MyChannel');
			    \});
			
			    it('=> transformChannelMembershipRecord: should return an array of type ChannelMembership', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'user_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformChannelMembershipRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    channel_id: '17bfnb1uwb8epewp4q3x3rx9go',
			                    user_id: '9ciscaqbrpd6d8s68k76xb9bte',
			                    roles: 'wqyby5r5pinxxdqhoaomtacdhc',
			                    last_viewed_at: 1613667352029,
			                    msg_count: 3864,
			                    mention_count: 0,
			                    notify_props: \{
			                        desktop: 'default',
			                        email: 'default',
			                        ignore_channel_mentions: 'default',
			                        mark_unread: 'mention',
			                        push: 'default',
			                    \},
			                    last_update_at: 1613667352029,
			                    scheme_user: true,
			                    scheme_admin: false,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('ChannelMembership');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\channel.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\general.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{
			    transformCustomEmojiRecord,
			    transformRoleRecord,
			    transformSystemRecord,
			\} from '@database/operator/server_data_operator/transformers/general';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('*** Role Prepare Records Test ***', () => \{
			    it('=> transformRoleRecord: should return an array of type Role', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'isolated_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformRoleRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'role-1',
			                    name: 'role-name-1',
			                    permissions: [],
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Role');
			    \});
			\});
			
			describe('*** System Prepare Records Test ***', () => \{
			    it('=> transformSystemRecord: should return an array of type System', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'isolated_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformSystemRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{id: 'system-1', name: 'system-name-1', value: 'system'\},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('System');
			    \});
			\});
			
			describe('*** CustomEmoj Prepare Records Test ***', () => \{
			    it('=> transformCustomEmojiRecord: should return an array of type CustomEmoji', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'isolated_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformCustomEmojiRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'i',
			                    create_at: 1580913641769,
			                    update_at: 1580913641769,
			                    delete_at: 0,
			                    creator_id: '4cprpki7ri81mbx8efixcsb8jo',
			                    name: 'boomI',
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('CustomEmoji');
			    \});
			\});
			
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\general.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\group.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{transformGroupRecord\} from '@database/operator/server_data_operator/transformers/group';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('*** GROUP Prepare Records Test ***', () => \{
			    it('=> transformGroupRecord: should return an array of type GroupModel', async () => \{
			        // expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'group_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformGroupRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'kow9j1ttnxwig7tnqgebg7dtipno',
			                    display_name: 'Test',
			                    name: 'recent',
			                    source: 'custom',
			                    remote_id: 'custom',
			                    member_count: 10,
			                \} as Group,
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords.collection.table).toBe('Group');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\group.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\post.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{
			    transformDraftRecord,
			    transformFileRecord,
			    transformPostInThreadRecord,
			    transformPostRecord,
			    transformPostsInChannelRecord,
			\} from '@database/operator/server_data_operator/transformers/post';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('***  POST Prepare Records Test ***', () => \{
			    it('=> transformPostRecord: should return an array of type Post', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'post_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformPostRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                    create_at: 1596032651748,
			                    update_at: 1596032651748,
			                    edit_at: 0,
			                    delete_at: 0,
			                    is_pinned: false,
			                    user_id: 'q3mzxua9zjfczqakxdkowc6u6yy',
			                    channel_id: 'xxoq1p6bqg7dkxb3kj1mcjoungw',
			                    root_id: 'ps81iqbesfby8jayz7owg4yypoo',
			                    original_id: '',
			                    message: 'Testing composer post',
			                    type: '',
			                    props: \{\},
			                    hashtags: '',
			                    pending_post_id: '',
			                    reply_count: 4,
			                    last_reply_at: 0,
			                    participants: null,
			                    metadata: \{\},
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Post');
			    \});
			
			    it('=> transformPostInThreadRecord: should return an array of type PostsInThread', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'post_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformPostInThreadRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'ps81iqbddesfby8jayz7owg4yypoo',
			                    root_id: '8swgtrrdiff89jnsiwiip3y1eoe',
			                    earliest: 1596032651748,
			                    latest: 1597032651748,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('PostsInThread');
			    \});
			
			    it('=> transformFileRecord: should return an array of type File', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'post_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformFileRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'file-id',
			                    post_id: 'ps81iqbddesfby8jayz7owg4yypoo',
			                    name: 'test_file',
			                    extension: '.jpg',
			                    has_preview_image: true,
			                    mime_type: 'image/jpeg',
			                    size: 1000,
			                    create_at: 1609253011321,
			                    delete_at: 1609253011321,
			                    height: 20,
			                    width: 20,
			                    update_at: 1609253011321,
			                    user_id: 'wqyby5r5pinxxdqhoaomtacdhc',
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('File');
			    \});
			
			    it('=> transformDraftRecord: should return an array of type Draft', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'post_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformDraftRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'ps81i4yypoo',
			                    root_id: 'ps81iqbddesfby8jayz7owg4yypoo',
			                    message: 'draft message',
			                    channel_id: 'channel_idp23232e',
			                    files: [],
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Draft');
			    \});
			
			    it('=> transformPostsInChannelRecord: should return an array of type PostsInChannel', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'post_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformPostsInChannelRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'ps81i4yypoo',
			                    channel_id: 'channel_idp23232e',
			                    earliest: 1608253011321,
			                    latest: 1609253011321,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('PostsInChannel');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\post.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\reaction.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{transformReactionRecord\} from '@database/operator/server_data_operator/transformers/reaction';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('*** REACTION Prepare Records Test ***', () => \{
			    it('=> transformReactionRecord: should return an array of type Reaction', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'reaction_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformReactionRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'ps81iqbddesfby8jayz7owg4yypoo',
			                    user_id: 'q3mzxua9zjfczqakxdkowc6u6yy',
			                    post_id: 'ps81iqbddesfby8jayz7owg4yypoo',
			                    emoji_name: 'thumbsup',
			                    create_at: 1596032651748,
			                    update_at: 1608253011321,
			                    delete_at: 0,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Reaction');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\reaction.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\team.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{
			    transformMyTeamRecord,
			    transformTeamChannelHistoryRecord,
			    transformTeamMembershipRecord,
			    transformTeamRecord,
			    transformTeamSearchHistoryRecord,
			\} from '@database/operator/server_data_operator/transformers/team';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('*** TEAM Prepare Records Test ***', () => \{
			    it('=> transformMyTeamRecord: should return an array of type MyTeam', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'team_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformMyTeamRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'teamA',
			                    roles: 'roleA, roleB, roleC',
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('MyTeam');
			    \});
			
			    it('=> transformTeamRecord: should return an array of type Team', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'team_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformTeamRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'rcgiyftm7jyrxnmdfdfa1osd8zswby',
			                    create_at: 1445538153952,
			                    update_at: 1588876392150,
			                    delete_at: 0,
			                    display_name: 'Contributors',
			                    name: 'core',
			                    description: '',
			                    email: '',
			                    type: 'O',
			                    company_name: '',
			                    allowed_domains: '',
			                    invite_id: 'codoy5s743rq5mk18i7u5dfdfksz7e',
			                    allow_open_invite: true,
			                    last_team_icon_update: 1525181587639,
			                    scheme_id: 'hbwgrncq1pfcdkpotzidfdmarn95o',
			                    group_constrained: null,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Team');
			    \});
			
			    it('=> transformTeamChannelHistoryRecord: should return an array of type Team', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'team_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformTeamChannelHistoryRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: 'a',
			                    channel_ids: ['ca', 'cb'],
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('TeamChannelHistory');
			    \});
			
			    it('=> transformTeamSearchHistoryRecord: should return an array of type TeamSearchHistory', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'team_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformTeamSearchHistoryRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    team_id: 'a',
			                    term: 'termA',
			                    display_term: 'termA',
			                    created_at: 1445538153952,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('TeamSearchHistory');
			    \});
			
			    it('=> transformTeamMembershipRecord: should return an array of type TeamMembership', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'team_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformTeamMembershipRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    team_id: 'a',
			                    user_id: 'ab',
			                    roles: '3ngdqe1e7tfcbmam4qgnxp91bw',
			                    delete_at: 0,
			                    scheme_user: true,
			                    scheme_admin: false,
			                    msg_count: 0,
			                    mention_count: 0,
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('TeamMembership');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\team.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\user.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{OperationType\} from '@constants/database';
			import \{transformPreferenceRecord, transformUserRecord\} from '@database/operator/server_data_operator/transformers/user';
			import \{createTestConnection\} from '@database/operator/utils/create_test_connection';
			
			describe('*** USER Prepare Records Test ***', () => \{
			    it('=> transformPreferenceRecord: should return an array of type Preference', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'user_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformPreferenceRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{user_id: '9ciscaqbrpd6d8s68k76xb9bte', category: 'tutorial_step', name: '9ciscaqbrpd6d8s68k76xb9bte', value: '2'\},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('Preference');
			    \});
			
			    it('=> transformUserRecord: should return an array of type User', async () => \{
			        expect.assertions(3);
			
			        const database = await createTestConnection(\{databaseName: 'user_prepare_records', setActive: true\});
			        expect(database).toBeTruthy();
			
			        const preparedRecords = await transformUserRecord(\{
			            action: OperationType.CREATE,
			            database: database!,
			            value: \{
			                record: undefined,
			                raw: \{
			                    id: '9ciscaqbrpd6d8s68k76xb9bte',
			                    is_bot: false,
			                    create_at: 1599457495881,
			                    update_at: 1607683720173,
			                    delete_at: 0,
			                    username: 'a.l',
			                    auth_service: '',
			                    email: 'a.l@mattermost.com',
			                    nickname: '',
			                    first_name: 'A',
			                    last_name: 'L',
			                    position: 'Mobile Engineer',
			                    roles: 'system_user',
			                    props: \{\},
			                    notify_props: \{
			                        desktop: 'all',
			                        desktop_sound: 'true',
			                        email: 'true',
			                        first_name: 'true',
			                        mention_keys: '',
			                        mark_unread: 'mention',
			                        push: 'mention',
			                        channel: 'true',
			                        auto_responder_active: 'false',
			                        auto_responder_message: 'Hello, I am out of office and unable to respond to messages.',
			                        comments: 'never',
			                        desktop_notification_sound: 'Hello',
			                        push_status: 'online',
			                    \},
			                    last_picture_update: 1604686302260,
			                    locale: 'en',
			                    timezone: \{
			                        automaticTimezone: 'Indian/Mauritius',
			                        manualTimezone: '',
			                        useAutomaticTimezone: 'true',
			                    \},
			                \},
			            \},
			        \});
			
			        expect(preparedRecords).toBeTruthy();
			        expect(preparedRecords!.collection.table).toBe('User');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\server_data_operator\\transformers\\user.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\database\\operator\\utils\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import DatabaseManager from '@database/manager';
			import \{createPostsChain, sanitizePosts\} from '@database/operator/utils/post';
			import \{sanitizeReactions\} from '@database/operator/utils/reaction';
			
			import \{mockedPosts, mockedReactions\} from './mock';
			
			describe('DataOperator: Utils tests', () => \{
			    it('=> sanitizePosts: should filter between ordered and unordered posts', () => \{
			        const \{postsOrdered, postsUnordered\} = sanitizePosts(\{
			            posts: Object.values(mockedPosts.posts),
			            orders: mockedPosts.order,
			        \});
			        expect(postsOrdered.length).toBe(4);
			        expect(postsUnordered.length).toBe(2);
			    \});
			
			    it('=> createPostsChain: should link posts amongst each other based on order array', () => \{
			        const previousPostId = 'prev_xxyuoxmehne';
			        const chainedOfPosts = createPostsChain(\{
			            order: mockedPosts.order,
			            posts: Object.values(mockedPosts.posts),
			            previousPostId,
			        \});
			
			        // eslint-disable-next-line max-nested-callbacks
			        const post1 = chainedOfPosts.find((post) => \{
			            const p = post;
			            return p.id === '8swgtrrdiff89jnsiwiip3y1eoe';
			        \});
			
			        expect(post1).toBeTruthy();
			        expect(post1?.prev_post_id).toBe('8fcnk3p1jt8mmkaprgajoxz115a');
			
			        // eslint-disable-next-line max-nested-callbacks
			        const post2 = chainedOfPosts.find((post) => \{
			            const p = post;
			            return p.id === '8fcnk3p1jt8mmkaprgajoxz115a';
			        \});
			
			        expect(post2).toBeTruthy();
			        expect(post2!.prev_post_id).toBe('3y3w3a6gkbg73bnj3xund9o5ic');
			
			        // eslint-disable-next-line max-nested-callbacks
			        const post3 = chainedOfPosts.find((post) => \{
			            const p = post;
			            return p.id === '3y3w3a6gkbg73bnj3xund9o5ic';
			        \});
			
			        expect(post3).toBeTruthy();
			        expect(post3?.prev_post_id).toBe('4btbnmticjgw7ewd3qopmpiwqw');
			
			        // eslint-disable-next-line max-nested-callbacks
			        const post4 = chainedOfPosts.find((post) => \{
			            const p = post;
			            return p.id === '4btbnmticjgw7ewd3qopmpiwqw';
			        \});
			
			        expect(post4).toBeTruthy();
			        expect(post4!.prev_post_id).toBe(previousPostId);
			    \});
			
			    it('=> sanitizeReactions: should triage between reactions that needs creation/deletion and emojis to be created', async () => \{
			        const dbName = 'server_schema_connection';
			        const serverUrl = 'https://appv2.mattermost.com';
			        const server = await DatabaseManager.createServerDatabase(\{
			            config: \{
			                dbName,
			                serverUrl,
			            \},
			        \});
			
			        if (!server) \{
			            fail('server database not created');
			        \}
			
			        // we commit one Reaction to our database
			        const prepareRecords = await server.operator.handleReactions(\{
			            postsReactions: [\{
			                post_id: '8ww8kb1dbpf59fu4d5xhu5nf5w',
			                reactions: [
			                    \{
			                        user_id: 'beqkgo4wzbn98kjzjgc1p5n91o',
			                        post_id: '8ww8kb1dbpf59fu4d5xhu5nf5w',
			                        emoji_name: 'tada_will_be_removed',
			                        create_at: 1601558322701,
			                    \},
			                ],
			            \}],
			            prepareRecordsOnly: true,
			        \});
			
			        // Jest in not using the same database instance amongst the Singletons; hence, we are creating the reaction record here
			        // eslint-disable-next-line max-nested-callbacks
			        await server.database.write(async (writer) => \{
			            await writer.batch(...prepareRecords);
			        \});
			
			        const \{
			            createReactions,
			            deleteReactions,
			        \} = await sanitizeReactions(\{
			            database: server.database,
			            post_id: '8ww8kb1dbpf59fu4d5xhu5nf5w',
			            rawReactions: mockedReactions,
			        \});
			
			        // The reaction with emoji_name 'tada_will_be_removed' will be in the deleteReactions array.   This implies that the user who reacted on that post later removed the reaction.
			        expect(deleteReactions.length).toBe(1);
			        expect(deleteReactions[0].emojiName).toBe('tada_will_be_removed');
			
			        expect(createReactions.length).toBe(3);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\operator\\utils\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\database\\schema\\app\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{MM_TABLES\} from '@constants/database';
			
			import \{schema\} from './index';
			
			const \{INFO, GLOBAL, SERVERS\} = MM_TABLES.APP;
			
			describe('*** Test schema for APP database ***', () => \{
			    it('=> The APP SCHEMA should strictly match', () => \{
			        expect(schema).toEqual(\{
			            version: 1,
			            tables: \{
			                [INFO]: \{
			                    name: INFO,
			                    columns: \{
			                        build_number: \{name: 'build_number', type: 'string'\},
			                        created_at: \{name: 'created_at', type: 'number'\},
			                        version_number: \{name: 'version_number', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'build_number', type: 'string'\},
			                        \{name: 'created_at', type: 'number'\},
			                        \{name: 'version_number', type: 'string'\},
			                    ],
			                \},
			                [GLOBAL]: \{
			                    name: GLOBAL,
			                    columns: \{
			                        value: \{name: 'value', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'value', type: 'string'\},
			                    ],
			                \},
			                [SERVERS]: \{
			                    name: SERVERS,
			                    columns: \{
			                        db_path: \{name: 'db_path', type: 'string'\},
			                        display_name: \{name: 'display_name', type: 'string'\},
			                        identifier: \{name: 'identifier', type: 'string', isIndexed: true\},
			                        last_active_at: \{name: 'last_active_at', type: 'number', isIndexed: true\},
			                        url: \{name: 'url', type: 'string', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'db_path', type: 'string'\},
			                        \{name: 'display_name', type: 'string'\},
			                        \{name: 'identifier', type: 'string', isIndexed: true\},
			                        \{name: 'last_active_at', type: 'number', isIndexed: true\},
			                        \{name: 'url', type: 'string', isIndexed: true\},
			                    ],
			                \},
			            \},
			        \});
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\schema\\app\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\database\\schema\\server\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			/* eslint-disable max-lines */
			
			import \{MM_TABLES\} from '@constants/database';
			
			import \{serverSchema\} from './index';
			
			const \{
			    CATEGORY,
			    CATEGORY_CHANNEL,
			    CHANNEL,
			    CHANNEL_INFO,
			    CHANNEL_MEMBERSHIP,
			    CONFIG,
			    CUSTOM_EMOJI,
			    DRAFT,
			    FILE,
			    GROUP,
			    GROUP_CHANNEL,
			    GROUP_MEMBERSHIP,
			    GROUP_TEAM,
			    MY_CHANNEL,
			    MY_CHANNEL_SETTINGS,
			    MY_TEAM,
			    POST,
			    POSTS_IN_CHANNEL,
			    POSTS_IN_THREAD,
			    PREFERENCE,
			    REACTION,
			    ROLE,
			    SYSTEM,
			    TEAM,
			    TEAM_CHANNEL_HISTORY,
			    TEAM_MEMBERSHIP,
			    TEAM_SEARCH_HISTORY,
			    THREAD,
			    THREAD_PARTICIPANT,
			    THREADS_IN_TEAM,
			    TEAM_THREADS_SYNC,
			    USER,
			\} = MM_TABLES.SERVER;
			
			describe('*** Test schema for SERVER database ***', () => \{
			    it('=> The SERVER SCHEMA should strictly match', () => \{
			        expect(serverSchema).toEqual(\{
			            version: 3,
			            unsafeSql: undefined,
			            tables: \{
			                [CATEGORY]: \{
			                    name: CATEGORY,
			                    unsafeSql: undefined,
			                    columns: \{
			                        collapsed: \{name: 'collapsed', type: 'boolean'\},
			                        display_name: \{name: 'display_name', type: 'string'\},
			                        muted: \{name: 'muted', type: 'boolean'\},
			                        sort_order: \{name: 'sort_order', type: 'number'\},
			                        sorting: \{name: 'sorting', type: 'string'\},
			                        team_id: \{name: 'team_id', type: 'string', isIndexed: true\},
			                        type: \{name: 'type', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'collapsed', type: 'boolean'\},
			                        \{name: 'display_name', type: 'string'\},
			                        \{name: 'muted', type: 'boolean'\},
			                        \{name: 'sort_order', type: 'number'\},
			                        \{name: 'sorting', type: 'string'\},
			                        \{name: 'team_id', type: 'string', isIndexed: true\},
			                        \{name: 'type', type: 'string'\},
			                    ],
			                \},
			                [CATEGORY_CHANNEL]: \{
			                    name: CATEGORY_CHANNEL,
			                    unsafeSql: undefined,
			                    columns: \{
			                        category_id: \{name: 'category_id', type: 'string', isIndexed: true\},
			                        channel_id: \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        sort_order: \{name: 'sort_order', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'category_id', type: 'string', isIndexed: true\},
			                        \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        \{name: 'sort_order', type: 'number'\},
			                    ],
			                \},
			                [CHANNEL_INFO]: \{
			                    name: CHANNEL_INFO,
			                    unsafeSql: undefined,
			                    columns: \{
			                        guest_count: \{name: 'guest_count', type: 'number'\},
			                        header: \{name: 'header', type: 'string'\},
			                        member_count: \{name: 'member_count', type: 'number'\},
			                        pinned_post_count: \{name: 'pinned_post_count', type: 'number'\},
			                        files_count: \{name: 'files_count', type: 'number'\},
			                        purpose: \{name: 'purpose', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'guest_count', type: 'number'\},
			                        \{name: 'header', type: 'string'\},
			                        \{name: 'member_count', type: 'number'\},
			                        \{name: 'pinned_post_count', type: 'number'\},
			                        \{name: 'files_count', type: 'number'\},
			                        \{name: 'purpose', type: 'string'\},
			                    ],
			                \},
			                [CHANNEL]: \{
			                    name: CHANNEL,
			                    unsafeSql: undefined,
			                    columns: \{
			                        create_at: \{name: 'create_at', type: 'number'\},
			                        creator_id: \{name: 'creator_id', type: 'string', isIndexed: true\},
			                        delete_at: \{name: 'delete_at', type: 'number'\},
			                        display_name: \{name: 'display_name', type: 'string'\},
			                        is_group_constrained: \{
			                            name: 'is_group_constrained',
			                            type: 'boolean',
			                        \},
			                        name: \{name: 'name', type: 'string', isIndexed: true\},
			                        shared: \{name: 'shared', type: 'boolean'\},
			                        team_id: \{name: 'team_id', type: 'string', isIndexed: true\},
			                        type: \{name: 'type', type: 'string'\},
			                        update_at: \{name: 'update_at', type: 'number'\},
			
			                    \},
			                    columnArray: [
			                        \{name: 'create_at', type: 'number'\},
			                        \{name: 'creator_id', type: 'string', isIndexed: true\},
			                        \{name: 'delete_at', type: 'number'\},
			                        \{name: 'display_name', type: 'string'\},
			                        \{name: 'is_group_constrained', type: 'boolean'\},
			                        \{name: 'name', type: 'string', isIndexed: true\},
			                        \{name: 'shared', type: 'boolean'\},
			                        \{name: 'team_id', type: 'string', isIndexed: true\},
			                        \{name: 'type', type: 'string'\},
			                        \{name: 'update_at', type: 'number'\},
			                    ],
			                \},
			                [CHANNEL_MEMBERSHIP]: \{
			                    name: CHANNEL_MEMBERSHIP,
			                    unsafeSql: undefined,
			                    columns: \{
			                        channel_id: \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        user_id: \{name: 'user_id', type: 'string', isIndexed: true\},
			                        scheme_admin: \{name: 'scheme_admin', type: 'boolean'\},
			                    \},
			                    columnArray: [
			                        \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        \{name: 'user_id', type: 'string', isIndexed: true\},
			                        \{name: 'scheme_admin', type: 'boolean'\},
			                    ],
			                \},
			                [CONFIG]: \{
			                    name: CONFIG,
			                    unsafeSql: undefined,
			                    columns: \{
			                        value: \{name: 'value', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'value', type: 'string'\},
			                    ],
			                \},
			                [CUSTOM_EMOJI]: \{
			                    name: CUSTOM_EMOJI,
			                    unsafeSql: undefined,
			                    columns: \{
			                        name: \{name: 'name', type: 'string', isIndexed: true\},
			                    \},
			                    columnArray: [\{name: 'name', type: 'string', isIndexed: true\}],
			                \},
			                [MY_CHANNEL]: \{
			                    name: MY_CHANNEL,
			                    unsafeSql: undefined,
			                    columns: \{
			                        is_unread: \{name: 'is_unread', type: 'boolean'\},
			                        last_post_at: \{name: 'last_post_at', type: 'number'\},
			                        last_viewed_at: \{name: 'last_viewed_at', type: 'number'\},
			                        manually_unread: \{name: 'manually_unread', type: 'boolean'\},
			                        mentions_count: \{name: 'mentions_count', type: 'number'\},
			                        message_count: \{name: 'message_count', type: 'number'\},
			                        roles: \{name: 'roles', type: 'string'\},
			                        viewed_at: \{name: 'viewed_at', type: 'number'\},
			                        last_fetched_at: \{name: 'last_fetched_at', type: 'number', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'is_unread', type: 'boolean'\},
			                        \{name: 'last_post_at', type: 'number'\},
			                        \{name: 'last_viewed_at', type: 'number'\},
			                        \{name: 'manually_unread', type: 'boolean'\},
			                        \{name: 'mentions_count', type: 'number'\},
			                        \{name: 'message_count', type: 'number'\},
			                        \{name: 'roles', type: 'string'\},
			                        \{name: 'viewed_at', type: 'number'\},
			                        \{name: 'last_fetched_at', type: 'number', isIndexed: true\},
			                    ],
			                \},
			                [MY_CHANNEL_SETTINGS]: \{
			                    name: MY_CHANNEL_SETTINGS,
			                    unsafeSql: undefined,
			                    columns: \{
			                        notify_props: \{name: 'notify_props', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'notify_props', type: 'string'\},
			                    ],
			                \},
			                [POSTS_IN_CHANNEL]: \{
			                    name: POSTS_IN_CHANNEL,
			                    unsafeSql: undefined,
			                    columns: \{
			                        channel_id: \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        earliest: \{name: 'earliest', type: 'number'\},
			                        latest: \{name: 'latest', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        \{name: 'earliest', type: 'number'\},
			                        \{name: 'latest', type: 'number'\},
			                    ],
			                \},
			                [DRAFT]: \{
			                    name: DRAFT,
			                    unsafeSql: undefined,
			                    columns: \{
			                        channel_id: \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        files: \{name: 'files', type: 'string'\},
			                        message: \{name: 'message', type: 'string'\},
			                        root_id: \{name: 'root_id', type: 'string', isIndexed: true\},
			                        metadata: \{name: 'metadata', type: 'string', isOptional: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        \{name: 'files', type: 'string'\},
			                        \{name: 'message', type: 'string'\},
			                        \{name: 'root_id', type: 'string', isIndexed: true\},
			                        \{name: 'metadata', type: 'string', isOptional: true\},
			                    ],
			                \},
			                [FILE]: \{
			                    name: FILE,
			                    unsafeSql: undefined,
			                    columns: \{
			                        extension: \{name: 'extension', type: 'string'\},
			                        height: \{name: 'height', type: 'number'\},
			                        image_thumbnail: \{name: 'image_thumbnail', type: 'string'\},
			                        local_path: \{name: 'local_path', type: 'string', isOptional: true\},
			                        mime_type: \{name: 'mime_type', type: 'string'\},
			                        name: \{name: 'name', type: 'string'\},
			                        post_id: \{name: 'post_id', type: 'string', isIndexed: true\},
			                        size: \{name: 'size', type: 'number'\},
			                        width: \{name: 'width', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'extension', type: 'string'\},
			                        \{name: 'height', type: 'number'\},
			                        \{name: 'image_thumbnail', type: 'string'\},
			                        \{name: 'local_path', type: 'string', isOptional: true\},
			                        \{name: 'mime_type', type: 'string'\},
			                        \{name: 'name', type: 'string'\},
			                        \{name: 'post_id', type: 'string', isIndexed: true\},
			                        \{name: 'size', type: 'number'\},
			                        \{name: 'width', type: 'number'\},
			                    ],
			                \},
			                [GROUP]: \{
			                    name: GROUP,
			                    unsafeSql: undefined,
			                    columns: \{
			                        display_name: \{name: 'display_name', type: 'string'\},
			                        name: \{name: 'name', type: 'string', isIndexed: true\},
			                        description: \{name: 'description', type: 'string'\},
			                        source: \{name: 'source', type: 'string'\},
			                        remote_id: \{name: 'remote_id', type: 'string', isIndexed: true\},
			                        created_at: \{name: 'created_at', type: 'number'\},
			                        updated_at: \{name: 'updated_at', type: 'number'\},
			                        deleted_at: \{name: 'deleted_at', type: 'number'\},
			                        member_count: \{name: 'member_count', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'display_name', type: 'string'\},
			                        \{name: 'name', type: 'string', isIndexed: true\},
			                        \{name: 'description', type: 'string'\},
			                        \{name: 'source', type: 'string'\},
			                        \{name: 'remote_id', type: 'string', isIndexed: true\},
			                        \{name: 'created_at', type: 'number'\},
			                        \{name: 'updated_at', type: 'number'\},
			                        \{name: 'deleted_at', type: 'number'\},
			                        \{name: 'member_count', type: 'number'\},
			                    ],
			                \},
			                [GROUP_CHANNEL]: \{
			                    name: GROUP_CHANNEL,
			                    unsafeSql: undefined,
			                    columns: \{
			                        group_id: \{name: 'group_id', type: 'string', isIndexed: true\},
			                        channel_id: \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        created_at: \{name: 'created_at', type: 'number'\},
			                        updated_at: \{name: 'updated_at', type: 'number'\},
			                        deleted_at: \{name: 'deleted_at', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'group_id', type: 'string', isIndexed: true\},
			                        \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        \{name: 'created_at', type: 'number'\},
			                        \{name: 'updated_at', type: 'number'\},
			                        \{name: 'deleted_at', type: 'number'\},
			                    ],
			                \},
			                [GROUP_MEMBERSHIP]: \{
			                    name: GROUP_MEMBERSHIP,
			                    unsafeSql: undefined,
			                    columns: \{
			                        group_id: \{name: 'group_id', type: 'string', isIndexed: true\},
			                        user_id: \{name: 'user_id', type: 'string', isIndexed: true\},
			                        created_at: \{name: 'created_at', type: 'number'\},
			                        updated_at: \{name: 'updated_at', type: 'number'\},
			                        deleted_at: \{name: 'deleted_at', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'group_id', type: 'string', isIndexed: true\},
			                        \{name: 'user_id', type: 'string', isIndexed: true\},
			                        \{name: 'created_at', type: 'number'\},
			                        \{name: 'updated_at', type: 'number'\},
			                        \{name: 'deleted_at', type: 'number'\},
			                    ],
			                \},
			                [GROUP_TEAM]: \{
			                    name: GROUP_TEAM,
			                    unsafeSql: undefined,
			                    columns: \{
			                        group_id: \{name: 'group_id', type: 'string', isIndexed: true\},
			                        team_id: \{name: 'team_id', type: 'string', isIndexed: true\},
			                        created_at: \{name: 'created_at', type: 'number'\},
			                        updated_at: \{name: 'updated_at', type: 'number'\},
			                        deleted_at: \{name: 'deleted_at', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'group_id', type: 'string', isIndexed: true\},
			                        \{name: 'team_id', type: 'string', isIndexed: true\},
			                        \{name: 'created_at', type: 'number'\},
			                        \{name: 'updated_at', type: 'number'\},
			                        \{name: 'deleted_at', type: 'number'\},
			                    ],
			                \},
			                [POSTS_IN_THREAD]: \{
			                    name: POSTS_IN_THREAD,
			                    unsafeSql: undefined,
			                    columns: \{
			                        earliest: \{name: 'earliest', type: 'number'\},
			                        latest: \{name: 'latest', type: 'number'\},
			                        root_id: \{name: 'root_id', type: 'string', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'earliest', type: 'number'\},
			                        \{name: 'latest', type: 'number'\},
			                        \{name: 'root_id', type: 'string', isIndexed: true\},
			                    ],
			                \},
			                [POST]: \{
			                    name: POST,
			                    unsafeSql: undefined,
			                    columns: \{
			                        channel_id: \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        create_at: \{name: 'create_at', type: 'number'\},
			                        delete_at: \{name: 'delete_at', type: 'number'\},
			                        edit_at: \{name: 'edit_at', type: 'number'\},
			                        is_pinned: \{name: 'is_pinned', type: 'boolean'\},
			                        message: \{name: 'message', type: 'string'\},
			                        message_source: \{name: 'message_source', type: 'string'\},
			                        metadata: \{name: 'metadata', type: 'string', isOptional: true\},
			                        original_id: \{name: 'original_id', type: 'string'\},
			                        pending_post_id: \{name: 'pending_post_id', type: 'string', isIndexed: true\},
			                        previous_post_id: \{name: 'previous_post_id', type: 'string'\},
			                        props: \{name: 'props', type: 'string'\},
			                        root_id: \{name: 'root_id', type: 'string'\},
			                        type: \{name: 'type', type: 'string'\},
			                        update_at: \{name: 'update_at', type: 'number'\},
			                        user_id: \{name: 'user_id', type: 'string', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'channel_id', type: 'string', isIndexed: true\},
			                        \{name: 'create_at', type: 'number'\},
			                        \{name: 'delete_at', type: 'number'\},
			                        \{name: 'edit_at', type: 'number'\},
			                        \{name: 'is_pinned', type: 'boolean'\},
			                        \{name: 'message', type: 'string'\},
			                        \{name: 'message_source', type: 'string'\},
			                        \{name: 'metadata', type: 'string', isOptional: true\},
			                        \{name: 'original_id', type: 'string'\},
			                        \{name: 'pending_post_id', type: 'string', isIndexed: true\},
			                        \{name: 'previous_post_id', type: 'string'\},
			                        \{name: 'props', type: 'string'\},
			                        \{name: 'root_id', type: 'string'\},
			                        \{name: 'type', type: 'string'\},
			                        \{name: 'update_at', type: 'number'\},
			                        \{name: 'user_id', type: 'string', isIndexed: true\},
			                    ],
			                \},
			                [PREFERENCE]: \{
			                    name: PREFERENCE,
			                    unsafeSql: undefined,
			                    columns: \{
			                        category: \{name: 'category', type: 'string', isIndexed: true\},
			                        name: \{name: 'name', type: 'string'\},
			                        user_id: \{name: 'user_id', type: 'string', isIndexed: true\},
			                        value: \{name: 'value', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'category', type: 'string', isIndexed: true\},
			                        \{name: 'name', type: 'string'\},
			                        \{name: 'user_id', type: 'string', isIndexed: true\},
			                        \{name: 'value', type: 'string'\},
			                    ],
			                \},
			                [REACTION]: \{
			                    name: REACTION,
			                    unsafeSql: undefined,
			                    columns: \{
			                        create_at: \{name: 'create_at', type: 'number'\},
			                        emoji_name: \{name: 'emoji_name', type: 'string'\},
			                        post_id: \{name: 'post_id', type: 'string', isIndexed: true\},
			                        user_id: \{name: 'user_id', type: 'string', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'create_at', type: 'number'\},
			                        \{name: 'emoji_name', type: 'string'\},
			                        \{name: 'post_id', type: 'string', isIndexed: true\},
			                        \{name: 'user_id', type: 'string', isIndexed: true\},
			                    ],
			                \},
			                [MY_TEAM]: \{
			                    name: MY_TEAM,
			                    unsafeSql: undefined,
			                    columns: \{
			                        roles: \{name: 'roles', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'roles', type: 'string'\},
			                    ],
			                \},
			                [ROLE]: \{
			                    name: ROLE,
			                    unsafeSql: undefined,
			                    columns: \{
			                        name: \{name: 'name', type: 'string', isIndexed: true\},
			                        permissions: \{name: 'permissions', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'name', type: 'string', isIndexed: true\},
			                        \{name: 'permissions', type: 'string'\},
			                    ],
			                \},
			                [SYSTEM]: \{
			                    name: SYSTEM,
			                    unsafeSql: undefined,
			                    columns: \{
			                        value: \{name: 'value', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'value', type: 'string'\},
			                    ],
			                \},
			                [TEAM]: \{
			                    name: TEAM,
			                    unsafeSql: undefined,
			                    columns: \{
			                        allowed_domains: \{name: 'allowed_domains', type: 'string'\},
			                        description: \{name: 'description', type: 'string'\},
			                        display_name: \{name: 'display_name', type: 'string'\},
			                        is_allow_open_invite: \{
			                            name: 'is_allow_open_invite',
			                            type: 'boolean',
			                        \},
			                        is_group_constrained: \{
			                            name: 'is_group_constrained',
			                            type: 'boolean',
			                        \},
			                        last_team_icon_updated_at: \{
			                            name: 'last_team_icon_updated_at',
			                            type: 'number',
			                        \},
			                        name: \{name: 'name', type: 'string'\},
			                        type: \{name: 'type', type: 'string'\},
			                        update_at: \{name: 'update_at', type: 'number'\},
			                        invite_id: \{name: 'invite_id', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'allowed_domains', type: 'string'\},
			                        \{name: 'description', type: 'string'\},
			                        \{name: 'display_name', type: 'string'\},
			                        \{name: 'is_allow_open_invite', type: 'boolean'\},
			                        \{name: 'is_group_constrained', type: 'boolean'\},
			                        \{name: 'last_team_icon_updated_at', type: 'number'\},
			                        \{name: 'name', type: 'string'\},
			                        \{name: 'type', type: 'string'\},
			                        \{name: 'update_at', type: 'number'\},
			                        \{name: 'invite_id', type: 'string'\},
			                    ],
			                \},
			                [TEAM_CHANNEL_HISTORY]: \{
			                    name: TEAM_CHANNEL_HISTORY,
			                    unsafeSql: undefined,
			                    columns: \{
			                        channel_ids: \{name: 'channel_ids', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'channel_ids', type: 'string'\},
			                    ],
			                \},
			                [TEAM_MEMBERSHIP]: \{
			                    name: TEAM_MEMBERSHIP,
			                    unsafeSql: undefined,
			                    columns: \{
			                        team_id: \{name: 'team_id', type: 'string', isIndexed: true\},
			                        user_id: \{name: 'user_id', type: 'string', isIndexed: true\},
			                        scheme_admin: \{name: 'scheme_admin', type: 'boolean'\},
			                    \},
			                    columnArray: [
			                        \{name: 'team_id', type: 'string', isIndexed: true\},
			                        \{name: 'user_id', type: 'string', isIndexed: true\},
			                        \{name: 'scheme_admin', type: 'boolean'\},
			                    ],
			                \},
			                [TEAM_SEARCH_HISTORY]: \{
			                    name: TEAM_SEARCH_HISTORY,
			                    unsafeSql: undefined,
			                    columns: \{
			                        created_at: \{name: 'created_at', type: 'number'\},
			                        display_term: \{name: 'display_term', type: 'string'\},
			                        team_id: \{name: 'team_id', type: 'string', isIndexed: true\},
			                        term: \{name: 'term', type: 'string'\},
			                    \},
			                    columnArray: [
			                        \{name: 'created_at', type: 'number'\},
			                        \{name: 'display_term', type: 'string'\},
			                        \{name: 'team_id', type: 'string', isIndexed: true\},
			                        \{name: 'term', type: 'string'\},
			                    ],
			                \},
			                [THREAD]: \{
			                    name: THREAD,
			                    unsafeSql: undefined,
			                    columns: \{
			                        is_following: \{name: 'is_following', type: 'boolean'\},
			                        last_reply_at: \{name: 'last_reply_at', type: 'number'\},
			                        last_viewed_at: \{name: 'last_viewed_at', type: 'number'\},
			                        reply_count: \{name: 'reply_count', type: 'number'\},
			                        unread_mentions: \{name: 'unread_mentions', type: 'number'\},
			                        unread_replies: \{name: 'unread_replies', type: 'number'\},
			                        viewed_at: \{name: 'viewed_at', type: 'number'\},
			                        last_fetched_at: \{name: 'last_fetched_at', type: 'number', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'is_following', type: 'boolean'\},
			                        \{name: 'last_reply_at', type: 'number'\},
			                        \{name: 'last_viewed_at', type: 'number'\},
			                        \{name: 'reply_count', type: 'number'\},
			                        \{name: 'unread_mentions', type: 'number'\},
			                        \{name: 'unread_replies', type: 'number'\},
			                        \{name: 'viewed_at', type: 'number'\},
			                        \{name: 'last_fetched_at', type: 'number', isIndexed: true\},
			                    ],
			                \},
			                [THREAD_PARTICIPANT]: \{
			                    name: THREAD_PARTICIPANT,
			                    unsafeSql: undefined,
			                    columns: \{
			                        thread_id: \{name: 'thread_id', type: 'string', isIndexed: true\},
			                        user_id: \{name: 'user_id', type: 'string', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'thread_id', type: 'string', isIndexed: true\},
			                        \{name: 'user_id', type: 'string', isIndexed: true\},
			                    ],
			                \},
			                [THREADS_IN_TEAM]: \{
			                    name: THREADS_IN_TEAM,
			                    unsafeSql: undefined,
			                    columns: \{
			                        team_id: \{name: 'team_id', type: 'string', isIndexed: true\},
			                        thread_id: \{name: 'thread_id', type: 'string', isIndexed: true\},
			                    \},
			                    columnArray: [
			                        \{name: 'team_id', type: 'string', isIndexed: true\},
			                        \{name: 'thread_id', type: 'string', isIndexed: true\},
			                    ],
			                \},
			                [TEAM_THREADS_SYNC]: \{
			                    name: TEAM_THREADS_SYNC,
			                    unsafeSql: undefined,
			                    columns: \{
			                        earliest: \{name: 'earliest', type: 'number'\},
			                        latest: \{name: 'latest', type: 'number'\},
			                    \},
			                    columnArray: [
			                        \{name: 'earliest', type: 'number'\},
			                        \{name: 'latest', type: 'number'\},
			                    ],
			                \},
			                [USER]: \{
			                    name: USER,
			                    unsafeSql: undefined,
			                    columns: \{
			                        auth_service: \{name: 'auth_service', type: 'string'\},
			                        delete_at: \{name: 'delete_at', type: 'number'\},
			                        email: \{name: 'email', type: 'string'\},
			                        first_name: \{name: 'first_name', type: 'string'\},
			                        is_bot: \{name: 'is_bot', type: 'boolean'\},
			                        is_guest: \{name: 'is_guest', type: 'boolean'\},
			                        last_name: \{name: 'last_name', type: 'string'\},
			                        last_picture_update: \{name: 'last_picture_update', type: 'number'\},
			                        locale: \{name: 'locale', type: 'string'\},
			                        nickname: \{name: 'nickname', type: 'string'\},
			                        notify_props: \{name: 'notify_props', type: 'string'\},
			                        position: \{name: 'position', type: 'string'\},
			                        props: \{name: 'props', type: 'string'\},
			                        remote_id: \{name: 'remote_id', type: 'string', isOptional: true\},
			                        roles: \{name: 'roles', type: 'string'\},
			                        status: \{name: 'status', type: 'string'\},
			                        timezone: \{name: 'timezone', type: 'string'\},
			                        update_at: \{name: 'update_at', type: 'number'\},
			                        username: \{name: 'username', type: 'string'\},
			                        terms_of_service_create_at: \{name: 'terms_of_service_create_at', type: 'number'\},
			                        terms_of_service_id: \{name: 'terms_of_service_id', type: 'string'\},
			
			                    \},
			                    columnArray: [
			                        \{name: 'auth_service', type: 'string'\},
			                        \{name: 'delete_at', type: 'number'\},
			                        \{name: 'email', type: 'string'\},
			                        \{name: 'first_name', type: 'string'\},
			                        \{name: 'is_bot', type: 'boolean'\},
			                        \{name: 'is_guest', type: 'boolean'\},
			                        \{name: 'last_name', type: 'string'\},
			                        \{name: 'last_picture_update', type: 'number'\},
			                        \{name: 'locale', type: 'string'\},
			                        \{name: 'nickname', type: 'string'\},
			                        \{name: 'notify_props', type: 'string'\},
			                        \{name: 'position', type: 'string'\},
			                        \{name: 'props', type: 'string'\},
			                        \{name: 'remote_id', type: 'string', isOptional: true\},
			                        \{name: 'roles', type: 'string'\},
			                        \{name: 'status', type: 'string'\},
			                        \{name: 'timezone', type: 'string'\},
			                        \{name: 'update_at', type: 'number'\},
			                        \{name: 'username', type: 'string'\},
			                        \{name: 'terms_of_service_id', type: 'string'\},
			                        \{name: 'terms_of_service_create_at', type: 'number'\},
			                    ],
			                \},
			            \},
			        \});
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\database\\schema\\server\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\helpers\\database\\index.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{sanitizeLikeString\} from '.';
			
			describe('Test SQLite Sanitize like string with latin and non-latin characters', () => \{
			    const disallowed = ',./;[]!@#\$%^&*()_-=+~';
			
			    test('test (latin)', () => \{
			        expect(sanitizeLikeString('test123')).toBe('test123');
			        expect(sanitizeLikeString(\`test123\$\{disallowed\}\`)).toBe(\`test123\$\{'_'.repeat(disallowed.length)\}\`);
			    \});
			
			    test('test (arabic)', () => \{
			        expect(sanitizeLikeString('اختبار123')).toBe('اختبار123');
			        expect(sanitizeLikeString(\`اختبار123\$\{disallowed\}\`)).toBe(\`اختبار123\$\{'_'.repeat(disallowed.length)\}\`);
			    \});
			
			    test('test (greek)', () => \{
			        expect(sanitizeLikeString('δοκιμή123')).toBe('δοκιμή123');
			        expect(sanitizeLikeString(\`δοκιμή123\$\{disallowed\}\`)).toBe(\`δοκιμή123\$\{'_'.repeat(disallowed.length)\}\`);
			    \});
			
			    test('test (hebrew)', () => \{
			        expect(sanitizeLikeString('חשבון123')).toBe('חשבון123');
			        expect(sanitizeLikeString(\`חשבון123\$\{disallowed\}\`)).toBe(\`חשבון123\$\{'_'.repeat(disallowed.length)\}\`);
			    \});
			
			    test('test (russian)', () => \{
			        expect(sanitizeLikeString('тест123')).toBe('тест123');
			        expect(sanitizeLikeString(\`тест123\$\{disallowed\}\`)).toBe(\`тест123\$\{'_'.repeat(disallowed.length)\}\`);
			    \});
			
			    test('test (chinese trad)', () => \{
			        expect(sanitizeLikeString('測試123')).toBe('測試123');
			        expect(sanitizeLikeString(\`測試123\$\{disallowed\}\`)).toBe(\`測試123\$\{'_'.repeat(disallowed.length)\}\`);
			    \});
			
			    test('test (japanese)', () => \{
			        expect(sanitizeLikeString('テスト123')).toBe('テスト123');
			        expect(sanitizeLikeString(\`テスト123\$\{disallowed\}\`)).toBe(\`テスト123\$\{'_'.repeat(disallowed.length)\}\`);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\helpers\\database\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('mattermost_mattermost-mobile\\app\\managers\\draft_upload_manager\\index.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{AppState, type AppStateStatus\} from 'react-native';
			
			import \{addFilesToDraft\} from '@actions/local/draft';
			import \{PROGRESS_TIME_TO_STORE\} from '@constants/files';
			import DatabaseManager from '@database/manager';
			import \{getDraft\} from '@queries/servers/drafts';
			import TestHelper from '@test/test_helper';
			
			import \{exportedForTesting\} from '.';
			
			import type ServerDataOperator from '@database/operator/server_data_operator';
			import type \{ClientResponse, ProgressPromise\} from '@mattermost/react-native-network-client';
			
			const \{DraftUploadManager\} = exportedForTesting;
			
			const url = 'baseHandler.test.com';
			const mockClient = TestHelper.createClient();
			
			jest.mock('@managers/network_manager', () => \{
			    const original = jest.requireActual('@managers/network_manager');
			    return \{
			        ...original,
			        getClient: (serverUrl: string) => \{
			            if (serverUrl === url) \{
			                return mockClient;
			            \}
			
			            throw new Error('client not found');
			        \},
			    \};
			\});
			
			const now = new Date('2020-01-01').getTime();
			const timeNotStore = now + (PROGRESS_TIME_TO_STORE - 1);
			const timeStore = now + PROGRESS_TIME_TO_STORE + 1;
			
			const mockUpload = () => \{
			    const returnValue: \{
			        resolvePromise: ((value: ClientResponse | PromiseLike<ClientResponse>) => void) | null;
			        rejectPromise: ((reason?: any) => void) | null;
			        progressFunc: ((fractionCompleted: number, bytesRead?: number | null | undefined) => void) | null;
			    \} = \{
			        resolvePromise: null,
			        rejectPromise: null,
			        progressFunc: null,
			    \};
			    (mockClient.apiClient.upload as jest.Mock).mockImplementationOnce(() => \{
			        const promise = (new Promise<ClientResponse>((resolve, reject) => \{
			            returnValue.resolvePromise = resolve;
			            returnValue.rejectPromise = reject;
			        \}) as ProgressPromise<ClientResponse>);
			        promise.progress = (f) => \{
			            returnValue.progressFunc = f;
			            return promise;
			        \};
			        promise.cancel = jest.fn();
			        return promise;
			    \});
			
			    return returnValue;
			\};
			
			describe('draft upload manager', () => \{
			    let operator: ServerDataOperator;
			    const channelId = 'cid';
			    const rootId = 'rid';
			
			    beforeEach(async () => \{
			        await DatabaseManager.init([url]);
			        operator = DatabaseManager.serverDatabases[url]!.operator;
			        AppState.currentState = 'active';
			    \});
			
			    afterEach(async () => \{
			        await DatabaseManager.destroyServerDatabase(url);
			    \});
			
			    it('File is uploaded and stored', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const fileClientId = 'clientId';
			        const fileServerId = 'serverId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId: fileClientId, localPath: 'path1'\} as FileInfo]);
			
			        manager.prepareUpload(url, \{clientId: fileClientId, localPath: 'path1'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(fileClientId)).toBe(true);
			
			        expect(uploadMocks.resolvePromise).not.toBeNull();
			        uploadMocks.resolvePromise!(\{ok: true, code: 201, data: \{file_infos: [\{clientId: fileClientId, id: fileServerId, localPath: 'path1'\}]\}\});
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        const draft = await getDraft(operator.database, channelId, rootId);
			        expect(draft?.files.length).toBe(1);
			        expect(draft?.files[0].id).toBe(fileServerId);
			
			        expect(manager.isUploading(fileClientId)).toBe(false);
			    \});
			
			    it('Progress is not stored on progress, but stored on fail', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const fileClientId = 'clientId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId: fileClientId, localPath: 'path1'\} as FileInfo]);
			
			        manager.prepareUpload(url, \{clientId: fileClientId, localPath: 'path2'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(fileClientId)).toBe(true);
			
			        // Wait for other promises to finish
			        await new Promise(process.nextTick);
			
			        const bytesRead = 200;
			        uploadMocks.progressFunc!(0.1, bytesRead);
			
			        // Wait for other promises to finish
			        await new Promise(process.nextTick);
			
			        // There has been progress, but we are not storing in to the database since the app is still active.
			        let draft = await getDraft(operator.database, channelId, rootId);
			        expect(draft?.files.length).toBe(1);
			        expect(draft?.files[0].bytesRead).toBeUndefined();
			
			        uploadMocks.rejectPromise!('error');
			
			        // Wait for other promises to finish
			        await new Promise(process.nextTick);
			
			        // After a failure, we store the progress on the database, so we can resume from the point before failure.
			        draft = await getDraft(operator.database, channelId, rootId);
			        expect(draft?.files.length).toBe(1);
			        expect(draft?.files[0].bytesRead).toBe(bytesRead);
			        expect(draft?.files[0].failed).toBe(true);
			
			        expect(manager.isUploading(fileClientId)).toBe(false);
			    \});
			
			    it('Progress is stored on AppState change to background for all files, and then only after certain time', async () => \{
			        const channelIds = ['cid1', 'cid2', 'cid3'];
			        const rootIds = ['rid1', '', 'rid3'];
			        const clientIds = ['client1', 'client2', 'client3'];
			        const fileUrls = ['url1', 'url2', 'url3'];
			        const bytesReads = [200, 300, 400];
			        const bytesReadsNotStore = [200, 300, 400];
			        const bytesReadsStore = [400, 1000, 450];
			        const bytesReadBeforeActive = [500, 1200, 650];
			        const appStateSpy = jest.spyOn(AppState, 'addEventListener');
			        let eventListener: (state: AppStateStatus) => void;
			        appStateSpy.mockImplementationOnce((name, f) => \{
			            eventListener = f;
			            return \{\} as any;
			        \});
			        const spyNow = jest.spyOn(Date, 'now');
			        spyNow.mockImplementation(() => now);
			        AppState.currentState = 'active';
			        const manager = new DraftUploadManager();
			
			        const progressFunc: \{[fileUrl: string] : ((fractionCompleted: number, bytesRead?: number | null | undefined) => void)\} = \{\};
			        const cancel = jest.fn();
			
			        let promise: ProgressPromise<ClientResponse>;
			        (mockClient.apiClient.upload as jest.Mock).mockImplementation((endpoint, fileUrl) => \{
			            promise = (new Promise<ClientResponse>(() => \{
			                // Do nothing
			            \}) as ProgressPromise<ClientResponse>);
			            promise.progress = (f) => \{
			                progressFunc[fileUrl] = f;
			                return promise;
			            \};
			            promise.cancel = cancel;
			            return promise;
			        \});
			
			        for (let i = 0; i < 3; i++) \{
			            const file = \{clientId: clientIds[i], localPath: fileUrls[i]\} as FileInfo;
			            // eslint-disable-next-line no-await-in-loop
			            await addFilesToDraft(url, channelIds[i], rootIds[i], [file]);
			            manager.prepareUpload(url, file, channelIds[i], rootIds[i], 0);
			        \}
			
			        (mockClient.apiClient.upload as jest.Mock).mockRestore();
			
			        for (let i = 0; i < 3; i++) \{
			            progressFunc[fileUrls[i]](0.1, bytesReads[i]);
			        \}
			
			        AppState.currentState = 'background';
			        eventListener!('background');
			
			        // Wait for other promises to finish
			        await new Promise(process.nextTick);
			
			        for (let i = 0; i < 3; i++) \{
			            // eslint-disable-next-line no-await-in-loop
			            const draft = await getDraft(operator.database, channelIds[i], rootIds[i]);
			            expect(draft?.files.length).toBe(1);
			            expect(draft?.files[0].bytesRead).toBe(bytesReads[i]);
			        \}
			
			        // Add progress inside the time window where it should not store in background
			        spyNow.mockImplementation(() => timeNotStore);
			
			        for (let i = 0; i < 3; i++) \{
			            progressFunc[fileUrls[i]](0.1, bytesReadsNotStore[i]);
			        \}
			
			        // Wait for other promises to finish
			        await new Promise(process.nextTick);
			
			        for (let i = 0; i < 3; i++) \{
			            // eslint-disable-next-line no-await-in-loop
			            const draft = await getDraft(operator.database, channelIds[i], rootIds[i]);
			            expect(draft?.files.length).toBe(1);
			            expect(draft?.files[0].bytesRead).toBe(bytesReads[i]);
			        \}
			
			        // Add progress inside the time window where it should store in background
			        spyNow.mockImplementation(() => timeStore);
			
			        for (let i = 0; i < 3; i++) \{
			            progressFunc[fileUrls[i]](0.1, bytesReadsStore[i]);
			
			            // Wait for other promises to finish (if not, watermelondb complains)
			            // eslint-disable-next-line no-await-in-loop
			            await new Promise(process.nextTick);
			        \}
			
			        for (let i = 0; i < 3; i++) \{
			            // eslint-disable-next-line no-await-in-loop
			            const draft = await getDraft(operator.database, channelIds[i], rootIds[i]);
			            expect(draft?.files.length).toBe(1);
			            expect(draft?.files[0].bytesRead).toBe(bytesReadsStore[i]);
			        \}
			
			        for (let i = 0; i < 3; i++) \{
			            progressFunc[fileUrls[i]](0.1, bytesReadBeforeActive[i]);
			        \}
			
			        AppState.currentState = 'active';
			        eventListener!('active');
			
			        for (let i = 0; i < 3; i++) \{
			            // eslint-disable-next-line no-await-in-loop
			            const draft = await getDraft(operator.database, channelIds[i], rootIds[i]);
			            expect(draft?.files.length).toBe(1);
			            expect(draft?.files[0].bytesRead).toBe(bytesReadsStore[i]);
			        \}
			
			        spyNow.mockClear();
			    \});
			
			    it('Error on complete: Received wrong response code', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const fileClientId = 'clientId';
			        const fileServerId = 'serverId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId: fileClientId, localPath: 'path1'\} as FileInfo]);
			
			        manager.prepareUpload(url, \{clientId: fileClientId, localPath: 'path1'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(fileClientId)).toBe(true);
			
			        expect(uploadMocks.resolvePromise).not.toBeNull();
			        uploadMocks.resolvePromise!(\{ok: true, code: 500, data: \{file_infos: [\{clientId: fileClientId, id: fileServerId, localPath: 'path1'\}]\}\});
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        const draft = await getDraft(operator.database, channelId, rootId);
			        expect(draft?.files.length).toBe(1);
			        expect(draft?.files[0].id).toBeUndefined();
			        expect(draft?.files[0].failed).toBe(true);
			
			        expect(manager.isUploading(fileClientId)).toBe(false);
			    \});
			
			    it('Error on complete: Received no data', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const clientId = 'clientId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId, localPath: 'path1'\} as FileInfo]);
			
			        manager.prepareUpload(url, \{clientId, localPath: 'path1'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(clientId)).toBe(true);
			
			        expect(uploadMocks.resolvePromise).not.toBeNull();
			        uploadMocks.resolvePromise!(\{ok: true, code: 201\});
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        const draft = await getDraft(operator.database, channelId, rootId);
			        expect(draft?.files.length).toBe(1);
			        expect(draft?.files[0].id).toBeUndefined();
			        expect(draft?.files[0].failed).toBe(true);
			
			        expect(manager.isUploading(clientId)).toBe(false);
			    \});
			
			    it('Error on complete: Received no file info', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const clientId = 'clientId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId, localPath: 'path1'\} as FileInfo]);
			
			        manager.prepareUpload(url, \{clientId, localPath: 'path1'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(clientId)).toBe(true);
			
			        expect(uploadMocks.resolvePromise).not.toBeNull();
			        uploadMocks.resolvePromise!(\{ok: true, code: 201, data: \{\}\});
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        const draft = await getDraft(operator.database, channelId, rootId);
			        expect(draft?.files.length).toBe(1);
			        expect(draft?.files[0].id).toBeUndefined();
			        expect(draft?.files[0].failed).toBe(true);
			
			        expect(manager.isUploading(clientId)).toBe(false);
			    \});
			
			    it('Progress handler', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const clientId = 'clientId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId, localPath: 'path1'\} as FileInfo]);
			
			        const nullProgressHandler = jest.fn();
			        let cancelProgressHandler = manager.registerProgressHandler(clientId, nullProgressHandler);
			        expect(cancelProgressHandler).toBeNull();
			
			        manager.prepareUpload(url, \{clientId, localPath: 'path1'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(clientId)).toBe(true);
			
			        const progressHandler = jest.fn();
			        cancelProgressHandler = manager.registerProgressHandler(clientId, progressHandler);
			        expect(cancelProgressHandler).not.toBeNull();
			
			        let bytesRead = 200;
			        uploadMocks.progressFunc!(0.1, bytesRead);
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        expect(progressHandler).toHaveBeenCalledWith(0.1, bytesRead);
			
			        cancelProgressHandler!();
			        bytesRead = 400;
			        uploadMocks.progressFunc!(0.1, bytesRead);
			
			        // Make sure calling several times the cancel does not create any problem.
			        cancelProgressHandler!();
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        expect(manager.isUploading(clientId)).toBe(true);
			        expect(progressHandler).toHaveBeenCalledTimes(1);
			        expect(nullProgressHandler).not.toHaveBeenCalled();
			    \});
			
			    it('Error handler: normal error', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const clientId = 'clientId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId, localPath: 'path1'\} as FileInfo]);
			
			        const nullErrorHandler = jest.fn();
			        let cancelErrorHandler = manager.registerProgressHandler(clientId, nullErrorHandler);
			        expect(cancelErrorHandler).toBeNull();
			
			        manager.prepareUpload(url, \{clientId, localPath: 'path1'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(clientId)).toBe(true);
			
			        const errorHandler = jest.fn();
			        cancelErrorHandler = manager.registerErrorHandler(clientId, errorHandler);
			        expect(cancelErrorHandler).not.toBeNull();
			
			        uploadMocks.rejectPromise!(\{message: 'error'\});
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        expect(errorHandler).toHaveBeenCalledWith('error');
			
			        // Make sure cancelling after error does not create any problem.
			        cancelErrorHandler!();
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        expect(manager.isUploading(clientId)).toBe(false);
			        expect(errorHandler).toHaveBeenCalledTimes(1);
			        expect(nullErrorHandler).not.toHaveBeenCalled();
			    \});
			
			    it('Error handler: complete error', async () => \{
			        const manager = new DraftUploadManager();
			        const uploadMocks = mockUpload();
			
			        const clientId = 'clientId';
			        await addFilesToDraft(url, channelId, rootId, [\{clientId, localPath: 'path1'\} as FileInfo]);
			
			        const nullErrorHandler = jest.fn();
			        let cancelErrorHandler = manager.registerProgressHandler(clientId, nullErrorHandler);
			        expect(cancelErrorHandler).toBeNull();
			
			        manager.prepareUpload(url, \{clientId, localPath: 'path1'\} as FileInfo, channelId, rootId, 0);
			        expect(manager.isUploading(clientId)).toBe(true);
			
			        const errorHandler = jest.fn();
			        cancelErrorHandler = manager.registerErrorHandler(clientId, errorHandler);
			        expect(cancelErrorHandler).not.toBeNull();
			
			        uploadMocks.resolvePromise!(\{ok: true, code: 500\});
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        // Make sure cancelling after error does not create any problem.
			        cancelErrorHandler!();
			
			        // Wait for other promises (on complete write) to finish
			        await new Promise(process.nextTick);
			
			        expect(manager.isUploading(clientId)).toBe(false);
			        expect(errorHandler).toHaveBeenCalledTimes(1);
			        expect(nullErrorHandler).not.toHaveBeenCalled();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\managers\\draft_upload_manager\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('mattermost_mattermost-mobile\\app\\products\\calls\\actions\\calls.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import assert from 'assert';
			
			import \{act, renderHook\} from '@testing-library/react-hooks';
			import InCallManager from 'react-native-incall-manager';
			
			import * as CallsActions from '@calls/actions';
			import \{getConnectionForTesting\} from '@calls/actions/calls';
			import * as Permissions from '@calls/actions/permissions';
			import \{needsRecordingWillBePostedAlert, needsRecordingErrorAlert\} from '@calls/alerts';
			import * as State from '@calls/state';
			import \{
			    myselfLeftCall,
			    newCurrentCall,
			    setCallsConfig,
			    setCallsState,
			    setChannelsWithCalls,
			    setCurrentCall,
			    useCallsConfig,
			    useCallsState,
			    useChannelsWithCalls,
			    useCurrentCall,
			    userJoinedCall,
			\} from '@calls/state';
			import \{
			    type Call,
			    type CallsState,
			    type ChannelsWithCalls,
			    type CurrentCall,
			    DefaultCallsConfig,
			    DefaultCallsState,
			\} from '@calls/types/calls';
			import DatabaseManager from '@database/manager';
			import NetworkManager from '@managers/network_manager';
			
			const mockClient = \{
			    getCalls: jest.fn(() => [
			        \{
			            call: \{
			                users: ['user-1', 'user-2'],
			                states: \{
			                    'user-1': \{unmuted: true\},
			                    'user-2': \{unmuted: false\},
			                \},
			                start_at: 123,
			                screen_sharing_id: '',
			                thread_id: 'thread-1',
			            \},
			            channel_id: 'channel-1',
			            enabled: true,
			        \},
			    ]),
			    getCallsConfig: jest.fn(() => (\{
			        ICEServers: ['mattermost.com'],
			        AllowEnableCalls: true,
			        DefaultEnabled: true,
			        last_retrieved_at: 1234,
			    \})),
			    getPluginsManifests: jest.fn(() => (
			        [
			            \{id: 'playbooks'\},
			            \{id: 'com.mattermost.calls'\},
			        ]
			    )),
			    enableChannelCalls: jest.fn(),
			    startCallRecording: jest.fn(),
			    stopCallRecording: jest.fn(),
			\};
			
			jest.mock('@calls/connection/connection', () => (\{
			    newConnection: jest.fn(() => Promise.resolve(\{
			        disconnect: jest.fn(),
			        mute: jest.fn(),
			        unmute: jest.fn(),
			        waitForPeerConnection: jest.fn(() => Promise.resolve()),
			    \})),
			\}));
			
			jest.mock('@actions/remote/thread', () => (\{
			    updateThreadFollowing: jest.fn(() => Promise.resolve(\{\})),
			\}));
			
			jest.mock('@queries/servers/thread', () => (\{
			    getThreadById: jest.fn(() => Promise.resolve(\{
			        isFollowing: false,
			    \})),
			\}));
			
			jest.mock('@calls/alerts');
			jest.mock('react-native-navigation', () => (\{
			    Navigation: \{
			        pop: jest.fn(() => Promise.resolve(\{
			            catch: jest.fn(),
			        \})),
			    \},
			\}));
			
			const addFakeCall = (serverUrl: string, channelId: string) => \{
			    const call = \{
			        participants: \{
			            xohi8cki9787fgiryne716u84o: \{id: 'xohi8cki9787fgiryne716u84o', muted: false, raisedHand: 0\},
			            xohi8cki9787fgiryne716u841: \{id: 'xohi8cki9787fgiryne716u84o', muted: true, raisedHand: 0\},
			            xohi8cki9787fgiryne716u842: \{id: 'xohi8cki9787fgiryne716u84o', muted: false, raisedHand: 0\},
			            xohi8cki9787fgiryne716u843: \{id: 'xohi8cki9787fgiryne716u84o', muted: true, raisedHand: 0\},
			            xohi8cki9787fgiryne716u844: \{id: 'xohi8cki9787fgiryne716u84o', muted: false, raisedHand: 0\},
			            xohi8cki9787fgiryne716u845: \{id: 'xohi8cki9787fgiryne716u84o', muted: true, raisedHand: 0\},
			        \},
			        channelId,
			        startTime: (new Date()).getTime(),
			        screenOn: '',
			        threadId: 'abcd1234567',
			        ownerId: 'xohi8cki9787fgiryne716u84o',
			        hostId: 'xohi8cki9787fgiryne716u84o',
			    \} as Call;
			    act(() => \{
			        State.setCallsState(serverUrl, \{myUserId: 'myUserId', calls: \{\}, enabled: \{\}\});
			        State.callStarted(serverUrl, call);
			    \});
			\};
			
			describe('Actions.Calls', () => \{
			    const \{newConnection\} = require('@calls/connection/connection');
			    const \{updateThreadFollowing\} = require('@actions/remote/thread');
			
			    InCallManager.setSpeakerphoneOn = jest.fn();
			    InCallManager.setForceSpeakerphoneOn = jest.fn();
			    // eslint-disable-next-line
			    // @ts-ignore
			    NetworkManager.getClient = () => mockClient;
			    jest.spyOn(Permissions, 'hasMicrophonePermission').mockReturnValue(Promise.resolve(true));
			
			    beforeAll(async () => \{
			        await DatabaseManager.init(['server1']);
			
			        // create subjects
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall(), useCallsConfig('server1')];
			        \});
			
			        assert.deepEqual(result.current[0], DefaultCallsState);
			        assert.deepEqual(result.current[1], \{\});
			        assert.deepEqual(result.current[2], null);
			        assert.deepEqual(result.current[3], DefaultCallsConfig);
			    \});
			
			    beforeEach(() => \{
			        newConnection.mockClear();
			        updateThreadFollowing.mockClear();
			        mockClient.getCalls.mockClear();
			        mockClient.getCallsConfig.mockClear();
			        mockClient.getPluginsManifests.mockClear();
			        mockClient.enableChannelCalls.mockClear();
			
			        // reset to default state for each test
			        act(() => \{
			            setCallsState('server1', DefaultCallsState);
			            setChannelsWithCalls('server1', \{\});
			            setCurrentCall(null);
			            setCallsConfig('server1', DefaultCallsConfig);
			        \});
			    \});
			
			    it('joinCall', async () => \{
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        addFakeCall('server1', 'channel-id');
			
			        let response: \{ data?: string \};
			        await act(async () => \{
			            response = await CallsActions.joinCall('server1', 'channel-id', 'myUserId', true);
			
			            // manually call newCurrentConnection because newConnection is mocked
			            newCurrentCall('server1', 'channel-id', 'myUserId');
			        \});
			
			        assert.equal(response!.data, 'channel-id');
			        assert.equal((result.current[1] as CurrentCall).channelId, 'channel-id');
			        expect(newConnection).toBeCalled();
			        expect(newConnection.mock.calls[0][1]).toBe('channel-id');
			        expect(updateThreadFollowing).toBeCalled();
			
			        await act(async () => \{
			            CallsActions.leaveCall();
			        \});
			    \});
			
			    it('leaveCall', async () => \{
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        addFakeCall('server1', 'channel-id');
			        expect(getConnectionForTesting()).toBe(null);
			
			        let response: \{ data?: string \};
			        await act(async () => \{
			            response = await CallsActions.joinCall('server1', 'channel-id', 'myUserId', true);
			
			            // manually call newCurrentConnection because newConnection is mocked
			            newCurrentCall('server1', 'channel-id', 'myUserId');
			            userJoinedCall('server1', 'channel-id', 'myUserId');
			        \});
			        assert.equal(response!.data, 'channel-id');
			        assert.equal((result.current[1] as CurrentCall | null)?.channelId, 'channel-id');
			
			        expect(getConnectionForTesting()!.disconnect).not.toBeCalled();
			        const disconnectMock = getConnectionForTesting()!.disconnect;
			
			        await act(async () => \{
			            CallsActions.leaveCall();
			
			            // because disconnect is mocked
			            myselfLeftCall();
			        \});
			
			        expect(disconnectMock).toBeCalled();
			        expect(getConnectionForTesting()).toBe(null);
			        assert.equal((result.current[1] as CurrentCall | null), null);
			    \});
			
			    it('muteMyself', async () => \{
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        addFakeCall('server1', 'channel-id');
			        expect(getConnectionForTesting()).toBe(null);
			
			        let response: \{ data?: string \};
			        await act(async () => \{
			            response = await CallsActions.joinCall('server1', 'channel-id', 'myUserId', true);
			
			            // manually call newCurrentConnection because newConnection is mocked
			            newCurrentCall('server1', 'channel-id', 'myUserId');
			            userJoinedCall('server1', 'channel-id', 'myUserId');
			        \});
			        assert.equal(response!.data, 'channel-id');
			        assert.equal((result.current[1] as CurrentCall | null)?.channelId, 'channel-id');
			
			        await act(async () => \{
			            CallsActions.muteMyself();
			        \});
			
			        expect(getConnectionForTesting()!.mute).toBeCalled();
			
			        await act(async () => \{
			            CallsActions.leaveCall();
			        \});
			    \});
			
			    it('unmuteMyself', async () => \{
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        addFakeCall('server1', 'channel-id');
			        expect(getConnectionForTesting()).toBe(null);
			
			        let response: \{ data?: string \};
			        await act(async () => \{
			            response = await CallsActions.joinCall('server1', 'channel-id', 'mysUserId', true);
			
			            // manually call newCurrentConnection because newConnection is mocked
			            newCurrentCall('server1', 'channel-id', 'myUserId');
			            userJoinedCall('server1', 'channel-id', 'myUserId');
			        \});
			        assert.equal(response!.data, 'channel-id');
			        assert.equal((result.current[1] as CurrentCall | null)?.channelId, 'channel-id');
			
			        await act(async () => \{
			            CallsActions.unmuteMyself();
			        \});
			
			        expect(getConnectionForTesting()!.unmute).toBeCalled();
			
			        await act(async () => \{
			            CallsActions.leaveCall();
			        \});
			    \});
			
			    it('loadCalls', async () => \{
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			
			        await act(async () => \{
			            await CallsActions.loadCalls('server1', 'userId1');
			        \});
			        expect(mockClient.getCalls).toBeCalled();
			        assert.equal((result.current[0] as CallsState).calls['channel-1'].channelId, 'channel-1');
			        assert.equal((result.current[0] as CallsState).enabled['channel-1'], true);
			        assert.equal((result.current[1] as ChannelsWithCalls)['channel-1'], true);
			        assert.equal((result.current[2] as CurrentCall | null), null);
			    \});
			
			    it('loadCalls fails from server', async () => \{
			        const expectedCallsState: CallsState = \{
			            myUserId: 'userId1',
			            calls: \{\},
			            enabled: \{\},
			        \};
			
			        // setup
			        const oldGetCalls = mockClient.getCalls;
			
			        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
			        // @ts-ignore
			        mockClient.getCalls = jest.fn(() => null);
			
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			
			        await act(async () => \{
			            await CallsActions.loadCalls('server1', 'userId1');
			        \});
			        expect(mockClient.getCalls).toBeCalled();
			        assert.deepEqual((result.current[0] as CallsState), expectedCallsState);
			        assert.deepEqual((result.current[1] as ChannelsWithCalls), \{\});
			        assert.equal((result.current[2] as CurrentCall | null), null);
			
			        mockClient.getCalls = oldGetCalls;
			    \});
			
			    it('loadConfig', async () => \{
			        // setup
			        const \{result\} = renderHook(() => useCallsConfig('server1'));
			
			        await act(async () => \{
			            await CallsActions.loadConfig('server1');
			        \});
			        expect(mockClient.getCallsConfig).toBeCalledWith();
			        assert.equal(result.current.DefaultEnabled, true);
			        assert.equal(result.current.AllowEnableCalls, true);
			    \});
			
			    it('enableChannelCalls', async () => \{
			        const \{result\} = renderHook(() => useCallsState('server1'));
			        assert.equal(result.current.enabled['channel-1'], undefined);
			        mockClient.enableChannelCalls.mockReturnValueOnce(\{enabled: true\});
			        await act(async () => \{
			            await CallsActions.enableChannelCalls('server1', 'channel-1', true);
			        \});
			        expect(mockClient.enableChannelCalls).toBeCalledWith('channel-1', true);
			        assert.equal(result.current.enabled['channel-1'], true);
			    \});
			
			    it('disableChannelCalls', async () => \{
			        const \{result\} = renderHook(() => useCallsState('server1'));
			        assert.equal(result.current.enabled['channel-1'], undefined);
			        mockClient.enableChannelCalls.mockReturnValueOnce(\{enabled: true\});
			        await act(async () => \{
			            await CallsActions.enableChannelCalls('server1', 'channel-1', true);
			        \});
			        expect(mockClient.enableChannelCalls).toBeCalledWith('channel-1', true);
			        assert.equal(result.current.enabled['channel-1'], true);
			        mockClient.enableChannelCalls.mockReturnValueOnce(\{enabled: false\});
			        await act(async () => \{
			            await CallsActions.enableChannelCalls('server1', 'channel-1', false);
			        \});
			        expect(mockClient.enableChannelCalls).toBeCalledWith('channel-1', false);
			        assert.equal(result.current.enabled['channel-1'], false);
			    \});
			
			    it('startCallRecording', async () => \{
			        await act(async () => \{
			            await CallsActions.startCallRecording('server1', 'channel-id');
			        \});
			
			        expect(mockClient.startCallRecording).toBeCalledWith('channel-id');
			        expect(needsRecordingErrorAlert).toBeCalled();
			    \});
			
			    it('stopCallRecording', async () => \{
			        await act(async () => \{
			            await CallsActions.stopCallRecording('server1', 'channel-id');
			        \});
			
			        expect(mockClient.stopCallRecording).toBeCalledWith('channel-id');
			        expect(needsRecordingErrorAlert).toBeCalled();
			        expect(needsRecordingWillBePostedAlert).toBeCalled();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\products\\calls\\actions\\calls.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(11)
    });
    it('mattermost_mattermost-mobile\\app\\products\\calls\\state\\actions.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import assert from 'assert';
			
			import \{act, renderHook\} from '@testing-library/react-hooks';
			
			import \{needsRecordingAlert\} from '@calls/alerts';
			import \{
			    newCurrentCall,
			    processMeanOpinionScore,
			    setAudioDeviceInfo,
			    setCallQualityAlertDismissed,
			    setCallsState,
			    setChannelsWithCalls,
			    setCurrentCall,
			    setHost,
			    setMicPermissionsErrorDismissed,
			    setMicPermissionsGranted,
			    setRecordingState,
			    useCallsConfig,
			    useCallsState,
			    useChannelsWithCalls,
			    useCurrentCall,
			    useGlobalCallsState,
			    userReacted,
			\} from '@calls/state';
			import \{
			    callEnded,
			    callStarted,
			    myselfLeftCall,
			    setCalls,
			    setCallScreenOff,
			    setCallScreenOn,
			    setChannelEnabled,
			    setConfig,
			    setPluginEnabled,
			    setRaisedHand,
			    setScreenShareURL,
			    setSpeakerPhone,
			    setUserMuted,
			    setUserVoiceOn,
			    userJoinedCall,
			    userLeftCall,
			\} from '@calls/state/actions';
			import \{
			    AudioDevice,
			    type Call,
			    type CallsState,
			    type CurrentCall,
			    DefaultCallsConfig,
			    DefaultCallsState,
			    DefaultCurrentCall,
			    DefaultGlobalCallsState,
			    type GlobalCallsState,
			\} from '@calls/types/calls';
			import \{License\} from '@constants';
			import DatabaseManager from '@database/manager';
			
			import type \{CallRecordingState\} from '@mattermost/calls/lib/types';
			
			jest.mock('@calls/alerts');
			
			jest.mock('@constants/calls', () => (\{
			    CALL_QUALITY_RESET_MS: 100,
			\}));
			
			jest.mock('@actions/remote/thread', () => (\{
			    updateThreadFollowing: jest.fn(() => Promise.resolve(\{\})),
			\}));
			
			jest.mock('@queries/servers/thread', () => (\{
			    getThreadById: jest.fn(() => Promise.resolve(\{
			        isFollowing: false,
			    \})),
			\}));
			
			jest.mock('react-native-navigation', () => (\{
			    Navigation: \{
			        pop: jest.fn(() => Promise.resolve(\{
			            catch: jest.fn(),
			        \})),
			    \},
			\}));
			
			const call1: Call = \{
			    participants: \{
			        'user-1': \{id: 'user-1', muted: false, raisedHand: 0\},
			        'user-2': \{id: 'user-2', muted: true, raisedHand: 0\},
			    \},
			    channelId: 'channel-1',
			    startTime: 123,
			    screenOn: '',
			    threadId: 'thread-1',
			    ownerId: 'user-1',
			    hostId: 'user-1',
			\};
			const call2: Call = \{
			    participants: \{
			        'user-3': \{id: 'user-3', muted: false, raisedHand: 0\},
			        'user-4': \{id: 'user-4', muted: true, raisedHand: 0\},
			    \},
			    channelId: 'channel-2',
			    startTime: 123,
			    screenOn: '',
			    threadId: 'thread-2',
			    ownerId: 'user-3',
			    hostId: 'user-3',
			\};
			const call3: Call = \{
			    participants: \{
			        'user-5': \{id: 'user-5', muted: false, raisedHand: 0\},
			        'user-6': \{id: 'user-6', muted: true, raisedHand: 0\},
			    \},
			    channelId: 'channel-3',
			    startTime: 123,
			    screenOn: '',
			    threadId: 'thread-3',
			    ownerId: 'user-5',
			    hostId: 'user-5',
			\};
			
			describe('useCallsState', () => \{
			    const \{updateThreadFollowing\} = require('@actions/remote/thread');
			
			    beforeAll(() => \{
			        // create subjects
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			
			        assert.deepEqual(result.current[0], DefaultCallsState);
			        assert.deepEqual(result.current[1], \{\});
			        assert.deepEqual(result.current[2], null);
			    \});
			
			    beforeEach(() => \{
			        // reset to default state for each test
			        updateThreadFollowing.mockClear();
			
			        act(() => \{
			            setCallsState('server1', DefaultCallsState);
			            setChannelsWithCalls('server1', \{\});
			            setCurrentCall(null);
			        \});
			    \});
			
			    it('default state', () => \{
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1')];
			        \});
			        assert.deepEqual(result.current[0], DefaultCallsState);
			        assert.deepEqual(result.current[1], \{\});
			    \});
			
			    it('setCalls, two callsState hooks, channelsWithCalls hook, ', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1\},
			            enabled: \{'channel-1': true\},
			        \};
			        const initialChannelsWithCallsState = \{
			            'channel-1': true,
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			        const testNewCall1 = \{
			            ...call1,
			            participants: \{
			                'user-1': \{id: 'user-1', muted: false, raisedHand: 0\},
			                'user-2': \{id: 'user-2', muted: true, raisedHand: 0\},
			                'user-3': \{id: 'user-3', muted: false, raisedHand: 123\},
			            \},
			        \};
			        const test = \{
			            calls: \{'channel-1': testNewCall1, 'channel-2': call2, 'channel-3': call3\},
			            enabled: \{'channel-2': true\},
			        \};
			
			        const expectedCallsState = \{
			            ...initialCallsState,
			            myUserId: 'myId',
			            calls: \{'channel-1': testNewCall1, 'channel-2': call2, 'channel-3': call3\},
			            enabled: \{'channel-2': true\},
			        \};
			        const expectedChannelsWithCallsState = \{
			            ...initialChannelsWithCallsState,
			            'channel-2': true,
			            'channel-3': true,
			        \};
			        const expectedCurrentCallState = \{
			            ...initialCurrentCallState,
			            ...testNewCall1,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [
			                useCallsState('server1'),
			                useCallsState('server1'),
			                useChannelsWithCalls('server1'),
			                useCurrentCall(),
			            ];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setChannelsWithCalls('server1', initialChannelsWithCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialCallsState);
			        assert.deepEqual(result.current[2], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[3], initialCurrentCallState);
			
			        // test
			        act(() => setCalls('server1', 'myId', test.calls, test.enabled));
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], expectedCallsState);
			        assert.deepEqual(result.current[2], expectedChannelsWithCallsState);
			        assert.deepEqual(result.current[3], expectedCurrentCallState);
			    \});
			
			    it('joinedCall', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1\},
			        \};
			        const initialChannelsWithCallsState = \{
			            'channel-1': true,
			        \};
			
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			        const expectedCallsState = \{
			            'channel-1': \{
			                participants: \{
			                    'user-1': \{id: 'user-1', muted: false, raisedHand: 0\},
			                    'user-2': \{id: 'user-2', muted: true, raisedHand: 0\},
			                    'user-3': \{id: 'user-3', muted: true, raisedHand: 0\},
			                \},
			                channelId: 'channel-1',
			                startTime: 123,
			                screenOn: '',
			                threadId: 'thread-1',
			                ownerId: 'user-1',
			                hostId: 'user-1',
			            \},
			        \};
			        const expectedChannelsWithCallsState = initialChannelsWithCallsState;
			        const expectedCurrentCallState = \{
			            ...initialCurrentCallState,
			            ...expectedCallsState['channel-1'],
			        \} as CurrentCall;
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setChannelsWithCalls('server1', initialChannelsWithCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			
			        // test
			        act(() => userJoinedCall('server1', 'channel-1', 'user-3'));
			        assert.deepEqual((result.current[0] as CallsState).calls, expectedCallsState);
			        assert.deepEqual(result.current[1], expectedChannelsWithCallsState);
			        assert.deepEqual(result.current[2], expectedCurrentCallState);
			        act(() => userJoinedCall('server1', 'invalid-channel', 'user-1'));
			        assert.deepEqual((result.current[0] as CallsState).calls, expectedCallsState);
			        assert.deepEqual(result.current[1], expectedChannelsWithCallsState);
			        assert.deepEqual(result.current[2], expectedCurrentCallState);
			    \});
			
			    it('leftCall', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1\},
			        \};
			        const initialChannelsWithCallsState = \{
			            'channel-1': true,
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			        const expectedCallsState = \{
			            'channel-1': \{
			                participants: \{
			                    'user-2': \{id: 'user-2', muted: true, raisedHand: 0\},
			                \},
			                channelId: 'channel-1',
			                startTime: 123,
			                screenOn: '',
			                threadId: 'thread-1',
			                ownerId: 'user-1',
			                hostId: 'user-1',
			            \},
			        \};
			        const expectedChannelsWithCallsState = initialChannelsWithCallsState;
			        const expectedCurrentCallState = \{
			            ...initialCurrentCallState,
			            ...expectedCallsState['channel-1'],
			        \} as CurrentCall;
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setChannelsWithCalls('server1', initialChannelsWithCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			
			        // test
			        act(() => userLeftCall('server1', 'channel-1', 'user-1'));
			        assert.deepEqual((result.current[0] as CallsState).calls, expectedCallsState);
			        assert.deepEqual(result.current[1], expectedChannelsWithCallsState);
			        assert.deepEqual(result.current[2], expectedCurrentCallState);
			        act(() => userLeftCall('server1', 'invalid-channel', 'user-2'));
			        assert.deepEqual((result.current[0] as CallsState).calls, expectedCallsState);
			        assert.deepEqual(result.current[1], expectedChannelsWithCallsState);
			        assert.deepEqual(result.current[2], expectedCurrentCallState);
			    \});
			
			    it('leftCall with screensharing on', () => \{
			        const initialCallsState: CallsState = \{
			            ...DefaultCallsState,
			            calls: \{
			                'channel-1': \{
			                    ...call1,
			                    screenOn: 'user-1',
			                \},
			            \},
			        \};
			        const initialChannelsWithCallsState = \{
			            'channel-1': true,
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			            screenOn: 'user-1',
			        \};
			        const expectedCallsState = \{
			            'channel-1': \{
			                participants: \{
			                    'user-2': \{id: 'user-2', muted: true, raisedHand: 0\},
			                \},
			                channelId: 'channel-1',
			                startTime: 123,
			                threadId: 'thread-1',
			                ownerId: 'user-1',
			                hostId: 'user-1',
			                screenOn: '',
			            \},
			        \};
			        const expectedChannelsWithCallsState = initialChannelsWithCallsState;
			        const expectedCurrentCallState: CurrentCall = \{
			            ...initialCurrentCallState,
			            ...expectedCallsState['channel-1'],
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setChannelsWithCalls('server1', initialChannelsWithCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			
			        // test
			        act(() => userLeftCall('server1', 'channel-1', 'user-1'));
			        assert.deepEqual((result.current[0] as CallsState).calls, expectedCallsState);
			        assert.deepEqual(result.current[1], expectedChannelsWithCallsState);
			        assert.deepEqual(result.current[2], expectedCurrentCallState);
			    \});
			
			    it('callStarted', async () => \{
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: false,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			
			        // setup
			        await DatabaseManager.init(['server1']);
			
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			        assert.deepEqual(result.current[0], DefaultCallsState);
			        assert.deepEqual(result.current[1], \{\});
			        assert.deepEqual(result.current[2], null);
			
			        // test
			        await act(async () => \{
			            setCurrentCall(initialCurrentCallState);
			            await callStarted('server1', call1);
			        \});
			        assert.deepEqual((result.current[0] as CallsState).calls, \{'channel-1': call1\});
			        assert.deepEqual(result.current[1], \{'channel-1': true\});
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			        expect(updateThreadFollowing).toBeCalled();
			    \});
			
			    it('callEnded', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const initialChannelsWithCallsState = \{'channel-1': true, 'channel-2': true\};
			        const expectedCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-2': call2\},
			        \};
			        const expectedChannelsWithCallsState = \{'channel-2': true\};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setChannelsWithCalls('server1', initialChannelsWithCallsState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], null);
			
			        // test
			        act(() => callEnded('server1', 'channel-1'));
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], expectedChannelsWithCallsState);
			        assert.deepEqual(result.current[2], null);
			    \});
			
			    it('setUserMuted', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const initialChannelsWithCallsState = \{'channel-1': true, 'channel-2': true\};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setChannelsWithCalls('server1', initialChannelsWithCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			
			        // test
			        act(() => setUserMuted('server1', 'channel-1', 'user-1', true));
			        assert.deepEqual((result.current[0] as CallsState).calls['channel-1'].participants['user-1'].muted, true);
			        assert.deepEqual((result.current[2] as CurrentCall | null)?.participants['user-1'].muted, true);
			        act(() => \{
			            setUserMuted('server1', 'channel-1', 'user-1', false);
			            setUserMuted('server1', 'channel-1', 'user-2', false);
			        \});
			        assert.deepEqual((result.current[0] as CallsState).calls['channel-1'].participants['user-1'].muted, false);
			        assert.deepEqual((result.current[0] as CallsState).calls['channel-1'].participants['user-2'].muted, false);
			        assert.deepEqual((result.current[2] as CurrentCall | null)?.participants['user-1'].muted, false);
			        assert.deepEqual((result.current[2] as CurrentCall | null)?.participants['user-2'].muted, false);
			        act(() => setUserMuted('server1', 'channel-1', 'user-2', true));
			        assert.deepEqual((result.current[0] as CallsState).calls['channel-1'].participants['user-2'].muted, true);
			        assert.deepEqual((result.current[2] as CurrentCall | null)?.participants['user-2'].muted, true);
			        assert.deepEqual(result.current[0], initialCallsState);
			        act(() => setUserMuted('server1', 'invalid-channel', 'user-1', true));
			        assert.deepEqual(result.current[0], initialCallsState);
			    \});
			
			    it('setCallScreenOn/Off', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const initialChannelsWithCallsState = \{'channel-1': true, 'channel-2': true\};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useChannelsWithCalls('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setChannelsWithCalls('server1', initialChannelsWithCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			
			        // test
			        act(() => setCallScreenOn('server1', 'channel-1', 'user-1'));
			        assert.deepEqual((result.current[0] as CallsState).calls['channel-1'].screenOn, 'user-1');
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual((result.current[2] as CurrentCall).screenOn, 'user-1');
			        act(() => setCallScreenOff('server1', 'channel-1'));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			        act(() => setCallScreenOn('server1', 'channel-1', 'invalid-user'));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			        act(() => setCallScreenOff('server1', 'invalid-channel'));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialChannelsWithCallsState);
			        assert.deepEqual(result.current[2], initialCurrentCallState);
			    \});
			
			    it('setRaisedHand', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1\},
			        \};
			        const expectedCalls = \{
			            'channel-1': \{
			                participants: \{
			                    'user-1': \{id: 'user-1', muted: false, raisedHand: 0\},
			                    'user-2': \{id: 'user-2', muted: true, raisedHand: 345\},
			                \},
			                channelId: 'channel-1',
			                startTime: 123,
			                screenOn: false,
			                threadId: 'thread-1',
			                ownerId: 'user-1',
			                hostId: 'user-1',
			            \},
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			        const expectedCurrentCallState = \{
			            ...initialCurrentCallState,
			            ...expectedCalls['channel-1'],
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialCurrentCallState);
			
			        // test
			        act(() => setRaisedHand('server1', 'channel-1', 'user-2', 345));
			        assert.deepEqual((result.current[0] as CallsState).calls, expectedCalls);
			        assert.deepEqual((result.current[1] as CurrentCall | null), expectedCurrentCallState);
			
			        act(() => setRaisedHand('server1', 'invalid-channel', 'user-1', 345));
			        assert.deepEqual((result.current[0] as CallsState).calls, expectedCalls);
			        assert.deepEqual((result.current[1] as CurrentCall | null), expectedCurrentCallState);
			
			        // unraise hand:
			        act(() => setRaisedHand('server1', 'channel-1', 'user-2', 0));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialCurrentCallState);
			    \});
			
			    it('myselfJoinedCall / LeftCall', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const newCall1 = \{
			            ...call1,
			            participants: \{
			                ...call1.participants,
			                myUserId: \{id: 'myUserId', muted: true, raisedHand: 0\},
			            \},
			        \};
			        const expectedCallsState = \{
			            ...initialCallsState,
			            calls: \{
			                ...initialCallsState.calls,
			                'channel-1': newCall1,
			            \},
			        \};
			        const expectedCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...newCall1,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => setCallsState('server1', initialCallsState));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			
			        // test
			        act(() => \{
			            newCurrentCall('server1', 'channel-1', 'myUserId');
			            userJoinedCall('server1', 'channel-1', 'myUserId');
			        \});
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], expectedCurrentCallState);
			
			        act(() => \{
			            myselfLeftCall();
			            userLeftCall('server1', 'channel-1', 'myUserId');
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			    \});
			
			    it('setChannelEnabled', () => \{
			        const initialState = \{
			            ...DefaultCallsState,
			            enabled: \{'channel-1': true, 'channel-2': false\},
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => useCallsState('server1'));
			        act(() => setCallsState('server1', initialState));
			        assert.deepEqual(result.current, initialState);
			
			        // test setCalls affects enabled:
			        act(() => setCalls('server1', 'myUserId', \{\}, \{'channel-1': true\}));
			        assert.deepEqual(result.current.enabled, \{'channel-1': true\});
			
			        // re-setup:
			        act(() => setCallsState('server1', initialState));
			        assert.deepEqual(result.current, initialState);
			
			        // test setChannelEnabled affects enabled:
			        act(() => setChannelEnabled('server1', 'channel-3', true));
			        assert.deepEqual(result.current.enabled, \{'channel-1': true, 'channel-2': false, 'channel-3': true\});
			        act(() => setChannelEnabled('server1', 'channel-3', false));
			        assert.deepEqual(result.current.enabled, \{
			            'channel-1': true,
			            'channel-2': false,
			            'channel-3': false,
			        \});
			        act(() => setChannelEnabled('server1', 'channel-1', true));
			        assert.deepEqual(result.current.enabled, \{
			            'channel-1': true,
			            'channel-2': false,
			            'channel-3': false,
			        \});
			        act(() => setChannelEnabled('server1', 'channel-1', false));
			        assert.deepEqual(result.current.enabled, \{
			            'channel-1': false,
			            'channel-2': false,
			            'channel-3': false,
			        \});
			    \});
			
			    it('setScreenShareURL', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => setCallsState('server1', initialCallsState));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			
			        // test joining a call and setting url:
			        act(() => newCurrentCall('server1', 'channel-1', 'myUserId'));
			        act(() => userJoinedCall('server1', 'channel-1', 'myUserId'));
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.screenShareURL, '');
			        act(() => setScreenShareURL('testUrl'));
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.screenShareURL, 'testUrl');
			
			        act(() => \{
			            myselfLeftCall();
			            userLeftCall('server1', 'channel-1', 'myUserId');
			            setScreenShareURL('test');
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			    \});
			
			    it('setSpeakerPhoneOn', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const newCall1 = \{
			            ...call1,
			            participants: \{
			                ...call1.participants,
			                myUserId: \{id: 'myUserId', muted: true, raisedHand: 0\},
			            \},
			        \};
			        const expectedCallsState = \{
			            ...initialCallsState,
			            calls: \{
			                ...initialCallsState.calls,
			                'channel-1': newCall1,
			            \},
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => setCallsState('server1', initialCallsState));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			
			        // test
			        act(() => newCurrentCall('server1', 'channel-1', 'myUserId'));
			        act(() => userJoinedCall('server1', 'channel-1', 'myUserId'));
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.speakerphoneOn, false);
			        act(() => setSpeakerPhone(true));
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.speakerphoneOn, true);
			        act(() => setSpeakerPhone(false));
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.speakerphoneOn, false);
			        assert.deepEqual(result.current[0], expectedCallsState);
			        act(() => \{
			            myselfLeftCall();
			            setSpeakerPhone(true);
			        \});
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], null);
			    \});
			
			    it('setAudioDeviceInfo', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const newCall1 = \{
			            ...call1,
			            participants: \{
			                ...call1.participants,
			                myUserId: \{id: 'myUserId', muted: true, raisedHand: 0\},
			            \},
			        \};
			        const expectedCallsState = \{
			            ...initialCallsState,
			            calls: \{
			                ...initialCallsState.calls,
			                'channel-1': newCall1,
			            \},
			        \};
			
			        const defaultAudioDeviceInfo = \{
			            availableAudioDeviceList: [],
			            selectedAudioDevice: AudioDevice.None,
			        \};
			        const newAudioDeviceInfo = \{
			            availableAudioDeviceList: [AudioDevice.Speakerphone, AudioDevice.Earpiece],
			            selectedAudioDevice: AudioDevice.Speakerphone,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => setCallsState('server1', initialCallsState));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			
			        // test
			        act(() => newCurrentCall('server1', 'channel-1', 'myUserId'));
			        act(() => userJoinedCall('server1', 'channel-1', 'myUserId'));
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.audioDeviceInfo, defaultAudioDeviceInfo);
			        act(() => setAudioDeviceInfo(newAudioDeviceInfo));
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.audioDeviceInfo, newAudioDeviceInfo);
			        assert.deepEqual((result.current[1] as CurrentCall | null)?.speakerphoneOn, false);
			        assert.deepEqual(result.current[0], expectedCallsState);
			        act(() => \{
			            myselfLeftCall();
			        \});
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], null);
			    \});
			
			    it('MicPermissions', () => \{
			        const initialGlobalState = DefaultGlobalCallsState;
			        const initialCallsState: CallsState = \{
			            ...DefaultCallsState,
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const newCall1: Call = \{
			            ...call1,
			            participants: \{
			                ...call1.participants,
			                myUserId: \{id: 'myUserId', muted: true, raisedHand: 0\},
			            \},
			        \};
			        const expectedCallsState: CallsState = \{
			            ...initialCallsState,
			            calls: \{
			                ...initialCallsState.calls,
			                'channel-1': newCall1,
			            \},
			        \};
			        const expectedCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            connected: true,
			            ...newCall1,
			        \};
			        const secondExpectedCurrentCallState: CurrentCall = \{
			            ...expectedCurrentCallState,
			            micPermissionsErrorDismissed: true,
			        \};
			        const expectedGlobalState: GlobalCallsState = \{
			            micPermissionsGranted: true,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall(), useGlobalCallsState()];
			        \});
			        act(() => setCallsState('server1', initialCallsState));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			        assert.deepEqual(result.current[2], initialGlobalState);
			
			        // join call
			        act(() => \{
			            setMicPermissionsGranted(false);
			            newCurrentCall('server1', 'channel-1', 'myUserId');
			            userJoinedCall('server1', 'channel-1', 'myUserId');
			        \});
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], expectedCurrentCallState);
			        assert.deepEqual(result.current[2], initialGlobalState);
			
			        // dismiss mic error
			        act(() => setMicPermissionsErrorDismissed());
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], secondExpectedCurrentCallState);
			        assert.deepEqual(result.current[2], initialGlobalState);
			
			        // grant permissions
			        act(() => setMicPermissionsGranted(true));
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], secondExpectedCurrentCallState);
			        assert.deepEqual(result.current[2], expectedGlobalState);
			
			        act(() => \{
			            myselfLeftCall();
			            userLeftCall('server1', 'channel-1', 'myUserId');
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			    \});
			
			    it('CallQuality', async () => \{
			        const initialCallsState: CallsState = \{
			            ...DefaultCallsState,
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const newCall1: Call = \{
			            ...call1,
			            participants: \{
			                ...call1.participants,
			                myUserId: \{id: 'myUserId', muted: true, raisedHand: 0\},
			            \},
			        \};
			        const expectedCallsState: CallsState = \{
			            ...initialCallsState,
			            calls: \{
			                ...initialCallsState.calls,
			                'channel-1': newCall1,
			            \},
			        \};
			        const currentCallNoAlertNoDismissed: CurrentCall = \{
			            ...DefaultCurrentCall,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            connected: true,
			            ...newCall1,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => setCallsState('server1', initialCallsState));
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], null);
			
			        // join call
			        act(() => \{
			            newCurrentCall('server1', 'channel-1', 'myUserId');
			            userJoinedCall('server1', 'channel-1', 'myUserId');
			        \});
			        assert.deepEqual(result.current[0], expectedCallsState);
			        assert.deepEqual(result.current[1], currentCallNoAlertNoDismissed);
			
			        // call quality goes bad
			        act(() => processMeanOpinionScore(3.4999));
			        assert.deepEqual((result.current[1] as CurrentCall).callQualityAlert, true);
			        assert.equal((result.current[1] as CurrentCall).callQualityAlertDismissed, 0);
			
			        // call quality goes good
			        act(() => processMeanOpinionScore(4));
			        assert.deepEqual(result.current[1], currentCallNoAlertNoDismissed);
			
			        // call quality goes bad
			        act(() => processMeanOpinionScore(3.499));
			        assert.deepEqual((result.current[1] as CurrentCall).callQualityAlert, true);
			        assert.equal((result.current[1] as CurrentCall).callQualityAlertDismissed, 0);
			
			        // dismiss call quality alert
			        const timeNow = Date.now();
			        act(() => setCallQualityAlertDismissed());
			        assert.deepEqual((result.current[1] as CurrentCall).callQualityAlert, false);
			        assert.equal((result.current[1] as CurrentCall).callQualityAlertDismissed >= timeNow &&
			            (result.current[1] as CurrentCall).callQualityAlertDismissed <= Date.now(), true);
			
			        // call quality goes bad, but we're not past the dismissed limit
			        act(() => processMeanOpinionScore(3.4999));
			        assert.deepEqual((result.current[1] as CurrentCall).callQualityAlert, false);
			
			        // test that the dismiss expired
			        await act(async () => \{
			            await new Promise((r) => setTimeout(r, 101));
			            processMeanOpinionScore(3.499);
			        \});
			        assert.deepEqual((result.current[1] as CurrentCall).callQualityAlert, true);
			    \});
			
			    it('voiceOn and Off', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialCurrentCallState);
			
			        // test
			        act(() => setUserVoiceOn('channel-1', 'user-1', true));
			        assert.deepEqual(result.current[1], \{...initialCurrentCallState, voiceOn: \{'user-1': true\}\});
			        assert.deepEqual(result.current[0], initialCallsState);
			        act(() => setUserVoiceOn('channel-1', 'user-2', true));
			        assert.deepEqual(result.current[1], \{...initialCurrentCallState, voiceOn: \{'user-1': true, 'user-2': true\}\});
			        assert.deepEqual(result.current[0], initialCallsState);
			        act(() => setUserVoiceOn('channel-1', 'user-1', false));
			        assert.deepEqual(result.current[1], \{...initialCurrentCallState, voiceOn: \{'user-2': true\}\});
			        assert.deepEqual(result.current[0], initialCallsState);
			
			        // test that voice state is cleared on reconnect
			        act(() => setCalls('server1', 'myUserId', initialCallsState.calls, \{\}));
			        assert.deepEqual(result.current[1], initialCurrentCallState);
			        assert.deepEqual(result.current[0], initialCallsState);
			    \});
			
			    it('config', () => \{
			        const newConfig = \{
			            ...DefaultCallsConfig,
			            ICEServers: [],
			            ICEServersConfigs: [
			                \{
			                    urls: ['stun:stun.example.com:3478'],
			                \},
			                \{
			                    urls: ['turn:turn.example.com:3478'],
			                \},
			            ],
			            AllowEnableCalls: true,
			            DefaultEnabled: true,
			            NeedsTURNCredentials: false,
			            last_retrieved_at: 123,
			            sku_short_name: License.SKU_SHORT_NAME.Professional,
			            MaxCallParticipants: 8,
			            EnableRecordings: true,
			            bot_user_id: '',
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => useCallsConfig('server1'));
			        assert.deepEqual(result.current, DefaultCallsConfig);
			
			        // test
			        act(() => setConfig('server1', newConfig));
			        assert.deepEqual(result.current, \{...newConfig, pluginEnabled: false\});
			        act(() => setPluginEnabled('server1', true));
			        assert.deepEqual(result.current, \{...newConfig, pluginEnabled: true\});
			        act(() => setPluginEnabled('server1', false));
			        assert.deepEqual(result.current, \{...newConfig, pluginEnabled: false\});
			    \});
			
			    it('user reactions', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			        const expectedCurrentCallState: CurrentCall = \{
			            ...initialCurrentCallState,
			            reactionStream: [
			                \{name: 'smile', latestTimestamp: 202, count: 1, literal: undefined\},
			                \{name: '+1', latestTimestamp: 145, count: 2, literal: undefined\},
			            ],
			            participants: \{
			                ...initialCurrentCallState.participants,
			                'user-1': \{
			                    ...initialCurrentCallState.participants['user-1'],
			                    reaction: \{
			                        user_id: 'user-1',
			                        emoji: \{name: 'smile', unified: 'something'\},
			                        timestamp: 202,
			                    \},
			                \},
			                'user-2': \{
			                    ...initialCurrentCallState.participants['user-2'],
			                    reaction: \{
			                        user_id: 'user-2',
			                        emoji: \{name: '+1', unified: 'something'\},
			                        timestamp: 123,
			                    \},
			                \},
			            \},
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialCurrentCallState);
			
			        // test
			        act(() => \{
			            userReacted('server1', 'channel-1', \{
			                user_id: 'user-2',
			                emoji: \{name: '+1', unified: 'something'\},
			                timestamp: 123,
			            \});
			            userReacted('server1', 'channel-1', \{
			                user_id: 'user-1',
			                emoji: \{name: '+1', unified: 'something'\},
			                timestamp: 145,
			            \});
			            userReacted('server1', 'channel-1', \{
			                user_id: 'user-1',
			                emoji: \{name: 'smile', unified: 'something'\},
			                timestamp: 202,
			            \});
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], expectedCurrentCallState);
			    \});
			
			    it('setRecordingState', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			        const recState: CallRecordingState = \{
			            init_at: 123,
			            start_at: 231,
			            end_at: 345,
			        \};
			        const expectedCallsState: CallsState = \{
			            ...initialCallsState,
			            calls: \{
			                ...initialCallsState.calls,
			                'channel-1': \{
			                    ...call1,
			                    recState,
			                \},
			            \},
			        \};
			        const expectedCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			            recState,
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialCurrentCallState);
			
			        // test
			        act(() => setRecordingState('server1', 'channel-1', recState));
			        assert.deepEqual((result.current[0] as CallsState), expectedCallsState);
			        assert.deepEqual((result.current[1] as CurrentCall | null), expectedCurrentCallState);
			        act(() => setRecordingState('server1', 'channel-2', recState));
			        assert.deepEqual((result.current[0] as CallsState).calls['channel-2'], \{...call2, recState\});
			        assert.deepEqual((result.current[1] as CurrentCall | null), expectedCurrentCallState);
			        act(() => setRecordingState('server1', 'channel-1', \{...recState, start_at: recState.start_at + 1\}));
			        expect(needsRecordingAlert).toBeCalled();
			    \});
			
			    it('setHost', () => \{
			        const initialCallsState = \{
			            ...DefaultCallsState,
			            calls: \{'channel-1': call1, 'channel-2': call2\},
			        \};
			        const initialCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			        \};
			        const expectedCallsState: CallsState = \{
			            ...initialCallsState,
			            calls: \{
			                ...initialCallsState.calls,
			                'channel-1': \{
			                    ...call1,
			                    hostId: 'user-52',
			                \},
			            \},
			        \};
			        const expectedCurrentCallState: CurrentCall = \{
			            ...DefaultCurrentCall,
			            connected: true,
			            serverUrl: 'server1',
			            myUserId: 'myUserId',
			            ...call1,
			            hostId: 'user-52',
			        \};
			
			        // setup
			        const \{result\} = renderHook(() => \{
			            return [useCallsState('server1'), useCurrentCall()];
			        \});
			        act(() => \{
			            setCallsState('server1', initialCallsState);
			            setCurrentCall(initialCurrentCallState);
			        \});
			        assert.deepEqual(result.current[0], initialCallsState);
			        assert.deepEqual(result.current[1], initialCurrentCallState);
			
			        // test
			        act(() => setHost('server1', 'channel-1', 'user-52'));
			        assert.deepEqual((result.current[0] as CallsState), expectedCallsState);
			        assert.deepEqual((result.current[1] as CurrentCall | null), expectedCurrentCallState);
			        act(() => setHost('server1', 'channel-2', 'user-1923'));
			        assert.deepEqual((result.current[0] as CallsState).calls['channel-2'], \{...call2, hostId: 'user-1923'\});
			        assert.deepEqual((result.current[1] as CurrentCall | null), expectedCurrentCallState);
			        act(() => setHost('server1', 'channel-1', 'myUserId'));
			        expect(needsRecordingAlert).toBeCalled();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\products\\calls\\state\\actions.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(22)
    });
    it('mattermost_mattermost-mobile\\app\\products\\calls\\utils.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import assert from 'assert';
			
			import \{type CallsConfigState, DefaultCallsConfig\} from '@calls/types/calls';
			import \{License\} from '@constants';
			
			import \{getICEServersConfigs\} from './utils';
			
			describe('getICEServersConfigs', () => \{
			    it('backwards compatible case, no ICEServersConfigs present', () => \{
			        const config: CallsConfigState = \{
			            ...DefaultCallsConfig,
			            pluginEnabled: true,
			            ICEServers: ['stun:stun.example.com:3478'],
			            ICEServersConfigs: [],
			            AllowEnableCalls: true,
			            DefaultEnabled: true,
			            NeedsTURNCredentials: false,
			            last_retrieved_at: 0,
			            sku_short_name: License.SKU_SHORT_NAME.Professional,
			            MaxCallParticipants: 8,
			            EnableRecordings: true,
			        \};
			        const iceConfigs = getICEServersConfigs(config);
			
			        assert.deepEqual(iceConfigs, [
			            \{
			                urls: ['stun:stun.example.com:3478'],
			            \},
			        ]);
			    \});
			
			    it('ICEServersConfigs set', () => \{
			        const config: CallsConfigState = \{
			            ...DefaultCallsConfig,
			            pluginEnabled: true,
			            ICEServersConfigs: [
			                \{
			                    urls: ['stun:stun.example.com:3478'],
			                \},
			                \{
			                    urls: ['turn:turn.example.com:3478'],
			                \},
			            ],
			            AllowEnableCalls: true,
			            DefaultEnabled: true,
			            NeedsTURNCredentials: false,
			            last_retrieved_at: 0,
			            sku_short_name: License.SKU_SHORT_NAME.Professional,
			            MaxCallParticipants: 8,
			            EnableRecordings: true,
			        \};
			        const iceConfigs = getICEServersConfigs(config);
			
			        assert.deepEqual(iceConfigs, [
			            \{
			                urls: ['stun:stun.example.com:3478'],
			            \},
			            \{
			                urls: ['turn:turn.example.com:3478'],
			            \},
			        ]);
			    \});
			
			    it('Both ICEServers and ICEServersConfigs set', () => \{
			        const config: CallsConfigState = \{
			            ...DefaultCallsConfig,
			            pluginEnabled: true,
			            ICEServers: ['stun:stuna.example.com:3478'],
			            ICEServersConfigs: [
			                \{
			                    urls: ['stun:stunb.example.com:3478'],
			                \},
			                \{
			                    urls: ['turn:turn.example.com:3478'],
			                \},
			            ],
			            AllowEnableCalls: true,
			            DefaultEnabled: true,
			            NeedsTURNCredentials: false,
			            last_retrieved_at: 0,
			            sku_short_name: License.SKU_SHORT_NAME.Professional,
			            MaxCallParticipants: 8,
			            EnableRecordings: true,
			        \};
			        const iceConfigs = getICEServersConfigs(config);
			
			        assert.deepEqual(iceConfigs, [
			            \{
			                urls: ['stun:stunb.example.com:3478'],
			            \},
			            \{
			                urls: ['turn:turn.example.com:3478'],
			            \},
			        ]);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\products\\calls\\utils.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\queries\\servers\\system.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{SYSTEM_IDENTIFIERS\} from '@constants/database';
			import DatabaseManager from '@database/manager';
			
			import \{observeCanDownloadFiles, observeCanUploadFiles\} from './system';
			
			import type ServerDataOperator from '@database/operator/server_data_operator';
			import type \{Database\} from '@nozbe/watermelondb';
			
			describe('observeCanUploadFiles', () => \{
			    const serverUrl = 'baseHandler.test.com';
			    let database: Database;
			    let operator: ServerDataOperator;
			    beforeEach(async () => \{
			        await DatabaseManager.init([serverUrl]);
			        const serverDatabaseAndOperator = DatabaseManager.getServerDatabaseAndOperator(serverUrl);
			        database = serverDatabaseAndOperator.database;
			        operator = serverDatabaseAndOperator.operator;
			    \});
			    afterEach(async () => \{
			        await DatabaseManager.destroyServerDatabase(serverUrl);
			    \});
			
			    it('should return true if no file attachment config value', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableMobileFileUpload', value: 'true'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            observeCanUploadFiles(database).subscribe((data) => \{
			                if (data === true) \{
			                    done();
			                \} else \{
			                    done.fail();
			                \}
			            \});
			        \});
			    \}, 1500);
			
			    it('should return false if file attachment config value is false', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'false'\}, \{id: 'EnableMobileFileUpload', value: 'true'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            observeCanUploadFiles(database).subscribe((data) => \{
			                if (data === false) \{
			                    done();
			                \} else \{
			                    done.fail();
			                \}
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if file attachment config value is true and there is no license', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'true'\}, \{id: 'EnableMobileFileUpload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            observeCanUploadFiles(database).subscribe((data) => \{
			                if (data === true) \{
			                    done();
			                \} else \{
			                    done.fail();
			                \}
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if file attachment config value is true and server is not licensed', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'true'\}, \{id: 'EnableMobileFileUpload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{isLicensed: false\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanUploadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if file attachment config value is true and server is licensed, but no compliance is set', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'true'\}, \{id: 'EnableMobileFileUpload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanUploadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if file attachment config value is true and server is licensed, but compliance is set to false', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'true'\}, \{id: 'EnableMobileFileUpload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'false'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanUploadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if file attachment config value is true and server is licensed and compliance is set to true, but EnableMobileFileUpload is not set', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'true'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanUploadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return false if file attachment config value is true and server is licensed and compliance is set to true, but EnableMobileFileUpload is set to false', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'true'\}, \{id: 'EnableMobileFileUpload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanUploadFiles(database).subscribe((data) => \{
			                    if (data === false) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if file attachment config value is true and server is licensed and compliance is set to true, but EnableMobileFileUpload is set to true', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableFileAttachments', value: 'true'\}, \{id: 'EnableMobileFileUpload', value: 'true'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanUploadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			\});
			
			describe('observeCanDownloadFiles', () => \{
			    const serverUrl = 'baseHandler.test.com';
			    let database: Database;
			    let operator: ServerDataOperator;
			    beforeEach(async () => \{
			        await DatabaseManager.init([serverUrl]);
			        const serverDatabaseAndOperator = DatabaseManager.getServerDatabaseAndOperator(serverUrl);
			        database = serverDatabaseAndOperator.database;
			        operator = serverDatabaseAndOperator.operator;
			    \});
			    afterEach(async () => \{
			        await DatabaseManager.destroyServerDatabase(serverUrl);
			    \});
			
			    it('should return true if there is no license', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableMobileFileDownload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            observeCanDownloadFiles(database).subscribe((data) => \{
			                if (data === true) \{
			                    done();
			                \} else \{
			                    done.fail();
			                \}
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if server is not licensed', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableMobileFileDownload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{isLicensed: false\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanDownloadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if server is licensed, but no compliance is set', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableMobileFileDownload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanDownloadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if server is licensed, but compliance is set to false', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableMobileFileDownload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'false'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanDownloadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if is licensed and compliance is set to true, but EnableMobileFileDownload is not set', (done) => \{
			        operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			            observeCanDownloadFiles(database).subscribe((data) => \{
			                if (data === true) \{
			                    done();
			                \} else \{
			                    done.fail();
			                \}
			            \});
			        \});
			    \}, 1500);
			
			    it('should return false if server is licensed and compliance is set to true, but EnableMobileFileDownload is set to false', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableMobileFileDownload', value: 'false'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanDownloadFiles(database).subscribe((data) => \{
			                    if (data === false) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			
			    it('should return true if server is licensed and compliance is set to true, but EnableMobileFileDownload is set to true', (done) => \{
			        operator.handleConfigs(\{configs: [\{id: 'EnableMobileFileDownload', value: 'true'\}], prepareRecordsOnly: false, configsToDelete: []\}).then(() => \{
			            operator.handleSystem(\{systems: [\{id: SYSTEM_IDENTIFIERS.LICENSE, value: \{IsLicensed: 'true', Compliance: 'true'\}\}], prepareRecordsOnly: false\}).then(() => \{
			                observeCanDownloadFiles(database).subscribe((data) => \{
			                    if (data === true) \{
			                        done();
			                    \} else \{
			                        done.fail();
			                    \}
			                \});
			            \});
			        \});
			    \}, 1500);
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\queries\\servers\\system.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(16)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\body\\category_body.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Database, Q\} from '@nozbe/watermelondb';
			import React from 'react';
			
			import \{MM_TABLES\} from '@constants/database';
			import \{DEFAULT_LOCALE\} from '@i18n';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import CategoryBody from '.';
			
			import type CategoryModel from '@typings/database/models/servers/category';
			
			const \{SERVER: \{CATEGORY\}\} = MM_TABLES;
			
			describe('components/channel_list/categories/body', () => \{
			    let database: Database;
			    let category: CategoryModel;
			
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			
			        const categories = await database.get<CategoryModel>(CATEGORY).query(
			            Q.take(1),
			        ).fetch();
			
			        category = categories[0];
			    \});
			
			    it('should match snapshot', (done) => \{
			        const wrapper = renderWithEverything(
			            <CategoryBody
			                category=\{category\}
			                locale=\{DEFAULT_LOCALE\}
			                isTablet=\{false\}
			                onChannelSwitch=\{() => undefined\}
			            />,
			            \{database\},
			        );
			
			        setTimeout(() => \{
			            expect(wrapper.toJSON()).toBeTruthy();
			            done();
			        \});
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\body\\category_body.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\categories.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import Categories from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/channel_list/categories', () => \{
			    let database: Database;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('render without error', () => \{
			        const wrapper = renderWithEverything(
			            <Categories/>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toBeTruthy();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\categories.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\header\\header.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Database, Q\} from '@nozbe/watermelondb';
			import React from 'react';
			
			import \{MM_TABLES\} from '@constants/database';
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import CategoryHeader from './header';
			
			import type CategoryModel from '@typings/database/models/servers/category';
			
			describe('components/channel_list/categories/header', () => \{
			    let database: Database;
			    let category: CategoryModel;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			
			        database = server.database;
			        const categories = await database.get<CategoryModel>(MM_TABLES.SERVER.CATEGORY).query(
			            Q.take(1),
			        ).fetch();
			
			        category = categories[0];
			    \});
			
			    it('should match snapshot', () => \{
			        const wrapper = renderWithIntlAndTheme(
			            <CategoryHeader
			                category=\{category\}
			                hasChannels=\{true\}
			            />,
			        );
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\header\\header.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\unreads\\unreads.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import UnreadsCategory from './unreads';
			
			import type \{Database\} from '@nozbe/watermelondb';
			
			describe('components/channel_list/categories/body', () => \{
			    let database: Database;
			
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('do not render when there are no unread channels', () => \{
			        const wrapper = renderWithEverything(
			            <UnreadsCategory
			                unreadChannels=\{[]\}
			                onChannelSwitch=\{() => undefined\}
			                onlyUnreads=\{false\}
			                unreadThreads=\{\{unreads: false, mentions: 0\}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toBeNull();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\categories\\unreads\\unreads.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\header\\header.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{PUSH_PROXY_STATUS_VERIFIED\} from '@constants/push_proxy';
			import \{renderWithIntl\} from '@test/intl-test-helper';
			
			import Header from './header';
			
			describe('components/channel_list/header', () => \{
			    it('Channel List Header Component should match snapshot', () => \{
			        const \{toJSON\} = renderWithIntl(
			            <Header
			                pushProxyStatus=\{PUSH_PROXY_STATUS_VERIFIED\}
			                canCreateChannels=\{true\}
			                canJoinChannels=\{true\}
			                canInvitePeople=\{true\}
			                displayName=\{'Test!'\}
			            />,
			        );
			
			        expect(toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\header\\header.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			import \{act\} from 'react-test-renderer';
			
			import \{SYSTEM_IDENTIFIERS\} from '@constants/database';
			import \{getTeamById\} from '@queries/servers/team';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import CategoriesList from '.';
			
			import type ServerDataOperator from '@database/operator/server_data_operator';
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/categories_list', () => \{
			    let database: Database;
			    let operator: ServerDataOperator;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			        operator = server.operator;
			
			        const team = await getTeamById(database, TestHelper.basicTeam!.id);
			        await database.write(async () => \{
			            await team?.update(() => \{
			                team.displayName = 'Test Team!';
			            \});
			        \});
			    \});
			
			    it('should render', () => \{
			        const wrapper = renderWithEverything(
			            <CategoriesList
			                moreThanOneTeam=\{false\}
			                hasChannels=\{true\}
			            />,
			            \{database\},
			        );
			        expect(wrapper.toJSON()).toBeTruthy();
			    \});
			
			    it('should render channel list with thread menu', () => \{
			        jest.useFakeTimers();
			        const wrapper = renderWithEverything(
			            <CategoriesList
			                isCRTEnabled=\{true\}
			                moreThanOneTeam=\{false\}
			                hasChannels=\{true\}
			            />,
			            \{database\},
			        );
			        act(() => \{
			            jest.runAllTimers();
			        \});
			        expect(wrapper.toJSON()).toBeTruthy();
			        jest.useRealTimers();
			    \});
			
			    it('should render team error', async () => \{
			        await operator.handleSystem(\{
			            systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: ''\}],
			            prepareRecordsOnly: false,
			        \});
			
			        jest.useFakeTimers();
			        const wrapper = renderWithEverything(
			            <CategoriesList
			                moreThanOneTeam=\{false\}
			                hasChannels=\{true\}
			            />,
			            \{database\},
			        );
			
			        act(() => \{
			            jest.runAllTimers();
			        \});
			        expect(wrapper.toJSON()).toMatchSnapshot();
			        jest.useRealTimers();
			
			        await operator.handleSystem(\{
			            systems: [\{id: SYSTEM_IDENTIFIERS.CURRENT_TEAM_ID, value: TestHelper.basicTeam!.id\}],
			            prepareRecordsOnly: false,
			        \});
			    \});
			
			    it('should render channels error', () => \{
			        jest.useFakeTimers();
			        const wrapper = renderWithEverything(
			            <CategoriesList
			                moreThanOneTeam=\{true\}
			                hasChannels=\{false\}
			            />,
			            \{database\},
			        );
			        act(() => \{
			            jest.runAllTimers();
			        \});
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\subheader\\search_field\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{renderWithIntlAndTheme\} from '@test/intl-test-helper';
			
			import Search from './index';
			
			test('Search Field should match snapshot', () => \{
			    const \{toJSON\} = renderWithIntlAndTheme(
			        <Search/>,
			    );
			
			    expect(toJSON()).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\home\\channel_list\\categories_list\\subheader\\search_field\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\integration_selector\\channel_list_row\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{Preferences\} from '@constants';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import ChannelListRow from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/integration_selector/channel_list_row', () => \{
			    let database: Database;
			    const channel: Channel = \{
			        id: '1',
			        create_at: 1111,
			        update_at: 1111,
			        delete_at: 0,
			        team_id: 'my team',
			        type: 'O',
			        display_name: 'channel',
			        name: 'channel',
			        header: 'channel',
			        purpose: '',
			        last_post_at: 1,
			        total_msg_count: 1,
			        extra_update_at: 1,
			        creator_id: '1',
			        scheme_id: null,
			        group_constrained: null,
			        shared: true,
			    \};
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should match snapshot with open channel icon', () => \{
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                id='1234'
			                theme=\{Preferences.THEMES.denim\}
			                channel=\{channel\}
			                selected=\{false\}
			                selectable=\{false\}
			                enabled=\{true\}
			                testID='ChannelListRow'
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            >
			                <br/>
			            </ChannelListRow>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with private channel icon', () => \{
			        channel.type = 'P';
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                id='1234'
			                theme=\{Preferences.THEMES.denim\}
			                channel=\{channel\}
			                selected=\{false\}
			                selectable=\{false\}
			                enabled=\{true\}
			                testID='ChannelListRow'
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            >
			                <br/>
			            </ChannelListRow>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with delete_at filled in', () => \{
			        channel.delete_at = 1111;
			        channel.shared = false;
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                id='1234'
			                theme=\{Preferences.THEMES.denim\}
			                channel=\{channel\}
			                testID='ChannelListRow'
			                enabled=\{true\}
			                selectable=\{false\}
			                selected=\{false\}
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            >
			                <br/>
			            </ChannelListRow>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with shared filled in', () => \{
			        channel.delete_at = 0;
			        channel.shared = true;
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                id='1234'
			                theme=\{Preferences.THEMES.denim\}
			                channel=\{channel\}
			                testID='ChannelListRow'
			                enabled=\{true\}
			                selectable=\{false\}
			                selected=\{false\}
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            >
			                <br/>
			            </ChannelListRow>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot with purpose filled in', () => \{
			        channel.purpose = 'My purpose';
			
			        const wrapper = renderWithEverything(
			            <ChannelListRow
			                id='1234'
			                theme=\{Preferences.THEMES.denim\}
			                channel=\{channel\}
			                testID='ChannelListRow'
			                enabled=\{true\}
			                selectable=\{false\}
			                selected=\{false\}
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            >
			                <br/>
			            </ChannelListRow>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\integration_selector\\channel_list_row\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\integration_selector\\custom_list\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			import \{Text\} from 'react-native';
			
			import \{Preferences\} from '@constants';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import CustomList from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/integration_selector/custom_list', () => \{
			    let database: Database;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should render', () => \{
			        const channel: Channel = \{
			            id: '1',
			            create_at: 1111,
			            update_at: 1111,
			            delete_at: 1111,
			            team_id: 'my team',
			            type: 'O',
			            display_name: 'channel',
			            name: 'channel',
			            header: 'channel',
			            purpose: 'channel',
			            last_post_at: 1,
			            total_msg_count: 1,
			            extra_update_at: 1,
			            creator_id: '1',
			            scheme_id: null,
			            group_constrained: null,
			            shared: true,
			        \};
			        const wrapper = renderWithEverything(
			            <CustomList
			                data=\{[channel]\}
			                key='custom_list'
			                loading=\{false\}
			                theme=\{Preferences.THEMES.denim\}
			                testID='ChannelListRow'
			                noResults=\{() => \{
			                    return <Text>\{'No Results'\}</Text>;
			                \}\}
			                onLoadMore=\{() => \{
			                    // noop
			                \}\}
			                onRowPress=\{() => \{
			                    // noop
			                \}\}
			                renderItem=\{(props: object): JSX.Element => \{
			                    return (<Text>\{props.toString()\}</Text>);
			                \}\}
			                loadingComponent=\{null\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toBeTruthy();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\integration_selector\\custom_list\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\integration_selector\\custom_list_row\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			import \{Text, View\} from 'react-native';
			
			import CompassIcon from '@components/compass_icon';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import CustomListRow from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/integration_selector/custom_list_row', () => \{
			    let database: Database;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should match snapshot', () => \{
			        const wrapper = renderWithEverything(
			            <CustomListRow
			                id='1'
			                onPress=\{() => \{
			                    // noop
			                \}\}
			                enabled=\{true\}
			                selectable=\{true\}
			                selected=\{true\}
			            >
			                <View>
			                    <View>
			                        <CompassIcon
			                            name=\{'globe'\}
			                        />
			                        <Text>
			                            \{'My channel'\}
			                        </Text>
			                    </View>
			                </View>
			            </CustomListRow>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\integration_selector\\custom_list_row\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\integration_selector\\option_list_row\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{Preferences\} from '@constants';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import OptionListRow from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/integration_selector/option_list_row', () => \{
			    let database: Database;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should match snapshot for option', () => \{
			        const myItem = \{
			            value: '1',
			            text: 'my text',
			        \};
			        const wrapper = renderWithEverything(
			            <OptionListRow
			                enabled=\{true\}
			                selectable=\{false\}
			                selected=\{false\}
			                theme=\{Preferences.THEMES.denim\}
			                item=\{myItem\}
			                id='1'
			                onPress=\{() => \{
			                    // noop
			                \}\}
			            >
			                <br/>
			            </OptionListRow>,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\integration_selector\\option_list_row\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\integration_selector\\selected_option\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{Preferences, View as ViewConstants\} from '@constants';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import SelectedOption from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/integration_selector/selected_option', () => \{
			    let database: Database;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should match snapshot for option', () => \{
			        const myItem = \{
			            value: '1',
			            text: 'my text',
			        \};
			        const wrapper = renderWithEverything(
			            <SelectedOption
			                theme=\{Preferences.THEMES.denim\}
			                option=\{myItem\}
			                dataSource=\{ViewConstants.DATA_SOURCE_DYNAMIC\}
			                onRemove=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot for userProfile', () => \{
			        const userProfile: UserProfile = \{
			            id: '1',
			            create_at: 1111,
			            update_at: 1111,
			            delete_at: 0,
			            username: 'johndoe',
			            nickname: 'johndoe',
			            first_name: 'johndoe',
			            last_name: 'johndoe',
			            position: 'hacker',
			            roles: 'admin',
			            locale: 'en_US',
			            notify_props: \{
			                channel: 'true',
			                comments: 'never',
			                desktop: 'all',
			                desktop_sound: 'true',
			                email: 'true',
			                first_name: 'true',
			                mention_keys: 'false',
			                push: 'mention',
			                push_status: 'ooo',
			            \},
			            email: 'johndoe@me.com',
			            auth_service: 'dummy',
			        \};
			        const wrapper = renderWithEverything(
			            <SelectedOption
			                theme=\{Preferences.THEMES.denim\}
			                option=\{userProfile\}
			                dataSource=\{ViewConstants.DATA_SOURCE_USERS\}
			                onRemove=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot for channel', () => \{
			        const channel: Channel = \{
			            id: '1',
			            create_at: 1111,
			            update_at: 1111,
			            delete_at: 0,
			            team_id: 'my team',
			            type: 'O',
			            display_name: 'channel',
			            name: 'channel',
			            header: 'channel',
			            purpose: '',
			            last_post_at: 1,
			            total_msg_count: 1,
			            extra_update_at: 1,
			            creator_id: '1',
			            scheme_id: null,
			            group_constrained: null,
			            shared: true,
			        \};
			        const wrapper = renderWithEverything(
			            <SelectedOption
			                theme=\{Preferences.THEMES.denim\}
			                option=\{channel\}
			                dataSource=\{ViewConstants.DATA_SOURCE_CHANNELS\}
			                onRemove=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\integration_selector\\selected_option\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\integration_selector\\selected_options\\index.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{Preferences, View as ViewConstants\} from '@constants';
			import \{renderWithEverything\} from '@test/intl-test-helper';
			import TestHelper from '@test/test_helper';
			
			import SelectedOptions from '.';
			
			import type Database from '@nozbe/watermelondb/Database';
			
			describe('components/integration_selector/selected_options', () => \{
			    let database: Database;
			    beforeAll(async () => \{
			        const server = await TestHelper.setupServerDatabase();
			        database = server.database;
			    \});
			
			    it('should match snapshot for users', () => \{
			        const userProfile: UserProfile = \{
			            id: '1',
			            create_at: 1111,
			            update_at: 1111,
			            delete_at: 1111,
			            username: 'johndoe',
			            nickname: 'johndoe',
			            first_name: 'johndoe',
			            last_name: 'johndoe',
			            position: 'hacker',
			            roles: 'admin',
			            locale: 'en_US',
			            notify_props: \{
			                channel: 'true',
			                comments: 'never',
			                desktop: 'all',
			                desktop_sound: 'true',
			                email: 'true',
			                first_name: 'true',
			                mention_keys: 'false',
			                push: 'mention',
			                push_status: 'ooo',
			            \},
			            email: 'johndoe@me.com',
			            auth_service: 'dummy',
			        \};
			        const wrapper = renderWithEverything(
			            <SelectedOptions
			                theme=\{Preferences.THEMES.denim\}
			                selectedOptions=\{[userProfile]\}
			                dataSource=\{ViewConstants.DATA_SOURCE_USERS\}
			                onRemove=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot for channels', () => \{
			        const channel: Channel = \{
			            id: '1',
			            create_at: 1111,
			            update_at: 1111,
			            delete_at: 0,
			            team_id: 'my team',
			            type: 'O',
			            display_name: 'channel',
			            name: 'channel',
			            header: 'channel',
			            purpose: '',
			            last_post_at: 1,
			            total_msg_count: 1,
			            extra_update_at: 1,
			            creator_id: '1',
			            scheme_id: null,
			            group_constrained: null,
			            shared: true,
			        \};
			
			        const wrapper = renderWithEverything(
			            <SelectedOptions
			                theme=\{Preferences.THEMES.denim\}
			                selectedOptions=\{[channel]\}
			                dataSource=\{ViewConstants.DATA_SOURCE_CHANNELS\}
			                onRemove=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			
			    it('should match snapshot for options', () => \{
			        const myItem = \{
			            value: '1',
			            text: 'my text',
			        \};
			
			        const wrapper = renderWithEverything(
			            <SelectedOptions
			                theme=\{Preferences.THEMES.denim\}
			                selectedOptions=\{[myItem]\}
			                dataSource=\{ViewConstants.DATA_SOURCE_DYNAMIC\}
			                onRemove=\{() => \{
			                    // noop
			                \}\}
			            />,
			            \{database\},
			        );
			
			        expect(wrapper.toJSON()).toMatchSnapshot();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\integration_selector\\selected_options\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\sso\\sso.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import \{Preferences, Screens\} from '@constants';
			import LaunchType from '@constants/launch';
			import \{renderWithIntl\} from '@test/intl-test-helper';
			
			import SSOLogin from './index';
			
			jest.mock('@screens/navigation', () => \{
			    return \{
			        getThemeFromState: () => 'light',
			    \};
			\});
			
			jest.mock('@utils/url', () => \{
			    return \{
			        tryOpenURL: () => true,
			    \};
			\});
			
			describe('SSO', () => \{
			    const baseProps = \{
			        componentId: Screens.SSO,
			        license: \{
			            IsLicensed: 'true',
			        \},
			        ssoType: 'GITLAB',
			        theme: Preferences.THEMES.denim,
			        serverUrl: 'https://locahost:8065',
			        serverDisplayName: 'Test Server',
			        launchType: LaunchType.Normal,
			    \};
			
			    test('implement with OS browser & redirect url from version 5.33', async () => \{
			        const props = \{...baseProps, config: \{Version: '5.36.0'\}\};
			        const \{getByTestId\} = renderWithIntl(<SSOLogin \{...props\}/>);
			        expect(getByTestId('sso.redirect_url')).toBeTruthy();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\sso\\sso.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\app\\screens\\sso\\sso_with_redirect_url.test.tsx', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import React from 'react';
			
			import Preferences from '@constants/preferences';
			import \{renderWithIntl\} from '@test/intl-test-helper';
			
			import SSOWithRedirectURL from './sso_with_redirect_url';
			
			jest.mock('@utils/url', () => \{
			    return \{
			        tryOpenURL: () => null,
			    \};
			\});
			
			describe('SSO with redirect url', () => \{
			    const baseProps = \{
			        customUrlScheme: 'mmauth://',
			        doSSOLogin: jest.fn(),
			        intl: \{\},
			        loginError: '',
			        loginUrl: '',
			        serverUrl: 'http://localhost:8065',
			        setLoginError: jest.fn(),
			        theme: Preferences.THEMES.denim,
			    \};
			
			    test('should show message when user navigates to the page', () => \{
			        const \{getByTestId\} = renderWithIntl(<SSOWithRedirectURL \{...baseProps\}/>);
			        expect(getByTestId('mobile.oauth.switch_to_browser')).toBeDefined();
			    \});
			
			    test('should show "try again" and hide default message when error text is displayed', () => \{
			        const \{getByTestId\} = renderWithIntl(
			            <SSOWithRedirectURL
			                \{...baseProps\}
			                loginError='some error'
			            />,
			        );
			        expect(getByTestId('mobile.oauth.try_again')).toBeDefined();
			        let browser;
			        try \{
			            browser = getByTestId('mobile.oauth.switch_to_browser');
			        \} catch (error) \{
			            // do nothing
			        \}
			        expect(browser).toBeUndefined();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\screens\\sso\\sso_with_redirect_url.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\utils\\markdown\\latex.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			/* eslint-disable no-useless-escape */
			
			import \{splitLatexCodeInLines\} from './latex';
			
			describe('LatexUtilTest', () => \{
			    test('Simple lines test', () => \{
			        const content = '\\\\frac\{1\}\{2\} = 0.5 \\\\\\\\ \\\\pi == 3';
			
			        const result = splitLatexCodeInLines(content);
			
			        expect(result.length).toEqual(2);
			        expect(result[0]).toEqual('\\\\frac\{1\}\{2\} = 0.5');
			        expect(result[1]).toEqual('\\\\pi == 3');
			    \});
			
			    test('Multi line with cases test', () => \{
			        const content = \`b_n=\\\\frac\{1\}\{\\\\pi\}\\\\int\\\\limits_\{-\\\\pi\}^\{\\\\pi\}f(x)\\\\sin nx\\\\,\\\\mathrm\{d\}x=\\\\frac\{1\}\{\\\\pi\}\\\\int\\\\limits_\{-\\\\pi\}^\{\\\\pi\}x^2\\\\sin nx\\\\,\\\\mathrm\{d\}x\\\\\\\\
			X(m, n) = \\\\left.
			\\\\begin\{cases\}
			x(n), & \\\\text\{for \} 0 \\\\leq n \\\\leq 1 \\\\\\\\
			x(n - 1), & \\\\text\{for \} 0 \\\\leq n \\\\leq 1 \\\\\\\\
			x(n - 1), & \\\\text\{for \} 0 \\\\leq n \\\\leq 1
			\\\\end\{cases\} \\\\right\\\\\} = xy\\\\\\\\
			\\\\lim_\{a\\\\to \\\\infty\} \\\\tfrac\{1\}\{a\}\\\\\\\\
			\\\\lim_\{a \\\\underset\{>\}\{\\\\to\} 0\} \\\\frac\{1\}\{a\}\\\\\\\\
			x = a_0 + \\\\frac\{1\}\{a_1 + \\\\frac\{1\}\{a_2 + \\\\frac\{1\}\{a_3 + a_4\}\}\}\`;
			
			        const result = splitLatexCodeInLines(content);
			
			        expect(result.length).toEqual(5);
			        expect(result[0]).toEqual('b_n=\\\\frac\{1\}\{\\\\pi\}\\\\int\\\\limits_\{-\\\\pi\}^\{\\\\pi\}f(x)\\\\sin nx\\\\,\\\\mathrm\{d\}x=\\\\frac\{1\}\{\\\\pi\}\\\\int\\\\limits_\{-\\\\pi\}^\{\\\\pi\}x^2\\\\sin nx\\\\,\\\\mathrm\{d\}x');
			        expect(result[1]).toEqual(\`X(m, n) = \\\\left.
			\\\\begin\{cases\}
			x(n), & \\\\text\{for \} 0 \\\\leq n \\\\leq 1 \\\\\\\\
			x(n - 1), & \\\\text\{for \} 0 \\\\leq n \\\\leq 1 \\\\\\\\
			x(n - 1), & \\\\text\{for \} 0 \\\\leq n \\\\leq 1
			\\\\end\{cases\} \\\\right\\\\\} = xy\`);
			        expect(result[2]).toEqual('\\\\lim_\{a\\\\to \\\\infty\} \\\\tfrac\{1\}\{a\}');
			        expect(result[3]).toEqual('\\\\lim_\{a \\\\underset\{>\}\{\\\\to\} 0\} \\\\frac\{1\}\{a\}');
			        expect(result[4]).toEqual('x = a_0 + \\\\frac\{1\}\{a_1 + \\\\frac\{1\}\{a_2 + \\\\frac\{1\}\{a_3 + a_4\}\}\}');
			    \});
			
			    test('Escaped bracket test', () => \{
			        const content = 'test = \\\\frac\{1\\\\\{\}\{2\} = \\\\alpha \\\\\\\\ line = 2';
			
			        const result = splitLatexCodeInLines(content);
			
			        expect(result.length).toEqual(2);
			        expect(result[0]).toEqual('test = \\\\frac\{1\\\\\{\}\{2\} = \\\\alpha');
			        expect(result[1]).toEqual('line = 2');
			    \});
			
			    test('Escaped begin and end statement', () => \{
			        const content = 'test = \\\\\\\\begin \\\\\\\\ line = 2';
			
			        const result = splitLatexCodeInLines(content);
			
			        expect(result.length).toEqual(3);
			        expect(result[0]).toEqual('test =');
			        expect(result[1]).toEqual('begin');
			        expect(result[2]).toEqual('line = 2');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\utils\\markdown\\latex.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\app\\utils\\server\\server.test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Alert\} from 'react-native';
			
			import \{getIntlShape\} from '@test/intl-test-helper';
			
			import \{unsupportedServer\} from '.';
			
			describe('Unsupported Server Alert', () => \{
			    const intl = getIntlShape();
			
			    it('should show the alert for sysadmin', () => \{
			        const alert = jest.spyOn(Alert, 'alert');
			        unsupportedServer('Default Server', true, intl);
			        expect(alert?.mock?.calls?.[0]?.[2]?.length).toBe(2);
			    \});
			
			    it('should show the alert for team admin / user', () => \{
			        const alert = jest.spyOn(Alert, 'alert');
			        unsupportedServer('Default Server', false, intl);
			        expect(alert?.mock?.calls?.[0]?.[2]?.length).toBe(1);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\utils\\server\\server.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\app\\utils\\tap\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{preventDoubleTap\} from './index';
			
			/*eslint max-nested-callbacks: 0 */
			describe('Prevent double tap', () => \{
			    it('should prevent double taps within the 300ms default', (done) => \{
			        const testFunction = jest.fn();
			        const test = preventDoubleTap(testFunction);
			
			        test();
			        test();
			        expect(testFunction).toHaveBeenCalledTimes(1);
			        setTimeout(() => \{
			            test();
			            expect(testFunction).toHaveBeenCalledTimes(1);
			            done();
			        \}, 100);
			    \});
			
			    it('should prevent double taps within 1 second', (done) => \{
			        const testFunction = jest.fn();
			        const test = preventDoubleTap(testFunction, 1000);
			
			        test();
			        test();
			        expect(testFunction).toHaveBeenCalledTimes(1);
			        setTimeout(() => \{
			            test();
			            expect(testFunction).toHaveBeenCalledTimes(1);
			            done();
			        \}, 900);
			    \});
			
			    it('should register multiple taps when done > 300ms apart', (done) => \{
			        const testFunction = jest.fn();
			        const test = preventDoubleTap(testFunction);
			
			        test();
			        test();
			        expect(testFunction).toHaveBeenCalledTimes(1);
			        setTimeout(() => \{
			            test();
			            expect(testFunction).toHaveBeenCalledTimes(2);
			            done();
			        \}, 750);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\utils\\tap\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(12)
    });
    it('mattermost_mattermost-mobile\\app\\utils\\theme\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Preferences\} from '@constants';
			import \{getKeyboardAppearanceFromTheme\} from '@utils/theme';
			
			const themes = Preferences.THEMES;
			
			describe('getKeyboardAppearanceFromTheme', () => \{
			    it('should return "light" keyboard appearance for centerChannelBg="#ffffff"', () => \{
			        const keyboardAppearance = getKeyboardAppearanceFromTheme(themes.denim);
			        expect(keyboardAppearance).toBe('light');
			    \});
			
			    it('should return "light" keyboard appearance for centerChannelBg="#ffffff"', () => \{
			        const keyboardAppearance = getKeyboardAppearanceFromTheme(themes.sapphire);
			        expect(keyboardAppearance).toBe('light');
			    \});
			
			    it('should return "dark" keyboard appearance for centerChannelBg="#ffffff"', () => \{
			        const keyboardAppearance = getKeyboardAppearanceFromTheme(themes.quartz);
			        expect(keyboardAppearance).toBe('light');
			    \});
			
			    it('should return "dark" keyboard appearance for centerChannelBg="#0a111f"', () => \{
			        const keyboardAppearance = getKeyboardAppearanceFromTheme(themes.indigo);
			        expect(keyboardAppearance).toBe('dark');
			    \});
			
			    it('should return "dark" keyboard appearance for centerChannelBg="#090a0b"', () => \{
			        const keyboardAppearance = getKeyboardAppearanceFromTheme(themes.onyx);
			        expect(keyboardAppearance).toBe('dark');
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\utils\\theme\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\app\\utils\\url\\test.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			import \{Linking\} from 'react-native';
			
			import DeepLinkType from '@constants/deep_linking';
			import TestHelper from '@test/test_helper';
			import \{matchDeepLink, parseDeepLink\} from '@utils/deep_link';
			import * as UrlUtils from '@utils/url';
			
			/* eslint-disable max-nested-callbacks */
			
			describe('UrlUtils', () => \{
			    describe('isImageLink', () => \{
			        it('not an image link', () => \{
			            const link = 'https://mattermost.com/index.html';
			            expect(UrlUtils.isImageLink(link)).toEqual(false);
			        \});
			
			        it('a png link', () => \{
			            const link = 'https://mattermost.com/image.png';
			            expect(UrlUtils.isImageLink(link)).toEqual(true);
			        \});
			
			        it('a jpg link', () => \{
			            const link = 'https://mattermost.com/assets/image.jpeg';
			            expect(UrlUtils.isImageLink(link)).toEqual(true);
			        \});
			
			        it('a jpeg link', () => \{
			            const link = 'https://mattermost.com/logo.jpeg';
			            expect(UrlUtils.isImageLink(link)).toEqual(true);
			        \});
			
			        it('a bmp link', () => \{
			            const link = 'https://images.mattermost.com/foo/bar/asdf.bmp';
			            expect(UrlUtils.isImageLink(link)).toEqual(true);
			        \});
			
			        it('a gif link', () => \{
			            const link = 'https://mattermost.com/jif.gif';
			            expect(UrlUtils.isImageLink(link)).toEqual(true);
			        \});
			
			        it('a link with a query parameter', () => \{
			            const link = 'https://mattermost.com/image.png?hash=foobar';
			            expect(UrlUtils.isImageLink(link)).toEqual(true);
			        \});
			    \});
			
			    describe('getYouTubeVideoId', () => \{
			        const tests = [
			            ['https://youtu.be/zrFWrmPgfzc', 'zrFWrmPgfzc'],
			            ['https://youtu.be/zrFWrmPgfzc?t=10s', 'zrFWrmPgfzc'],
			            [
			                'https://www.youtube.com/watch?v=zrFWrmPgfzc&feature=youtu.be',
			                'zrFWrmPgfzc',
			            ],
			            ['https://www.youtube.com/watch?v=zrFWrmPgfzc&t=10s', 'zrFWrmPgfzc'],
			            ['https://www.youtube.com/watch?t=10s&v=zrFWrmPgfzc', 'zrFWrmPgfzc'],
			        ];
			
			        for (const test of tests) \{
			            const input = test[0];
			            const expected = test[1];
			
			            it(input, () => \{
			                expect(UrlUtils.getYouTubeVideoId(input)).toEqual(expected);
			            \});
			        \}
			    \});
			
			    describe('stripTrailingSlashes', () => \{
			        it('should return the same url', () => \{
			            const url =
			        'https://www.youtube.com/watch?v=zrFWrmPgfzc&feature=youtu.be';
			            expect(UrlUtils.stripTrailingSlashes(url)).toEqual(url);
			        \});
			
			        it('should return an url without the initial //', () => \{
			            const url = '//www.youtube.com/watch?v=zrFWrmPgfzc&feature=youtu.be';
			            const expected = 'www.youtube.com/watch?v=zrFWrmPgfzc&feature=youtu.be';
			            expect(UrlUtils.stripTrailingSlashes(url)).toEqual(expected);
			        \});
			
			        it('should return an url without the initial // and the lasts ////', () => \{
			            const url = '//www.youtube.com/watch?v=zrFWrmPgfzc&feature=youtu.be////';
			            const expected = 'www.youtube.com/watch?v=zrFWrmPgfzc&feature=youtu.be';
			            expect(UrlUtils.stripTrailingSlashes(url)).toEqual(expected);
			        \});
			
			        it('should return an url without the initial // and the lasts //// or spaces', () => \{
			            const url =
			        'https: //www .y o u t u be .co m/watch   ?v=z r FW r mP gf zc& fe atu r e = you  tu .be////';
			            const expected =
			        'https://www.youtube.com/watch?v=zrFWrmPgfzc&feature=youtu.be';
			            expect(UrlUtils.stripTrailingSlashes(url)).toEqual(expected);
			        \});
			    \});
			
			    describe('removeProtocol', () => \{
			        const tests = [
			            \{
			                name: 'should return url without http protocol prefix',
			                url: 'http://localhost:8065',
			                expected: 'localhost:8065',
			            \},
			            \{
			                name: 'should return url without https protocol prefix',
			                url: 'https://localhost:8065',
			                expected: 'localhost:8065',
			            \},
			            \{name: 'should return null', url: '', expected: ''\},
			            \{
			                name: 'should return url without arbitrary protocol prefix',
			                url: 'udp://localhost:8065',
			                expected: 'localhost:8065',
			            \},
			        ];
			
			        for (const test of tests) \{
			            const \{name, url, expected\} = test;
			
			            it(name, () => \{
			                expect(UrlUtils.removeProtocol(url)).toEqual(expected);
			            \});
			        \}
			    \});
			
			    describe('matchDeepLink', () => \{
			        const URL_NO_PROTOCOL = 'localhost:8065';
			        const URL_PATH_NO_PROTOCOL = 'localhost:8065/subpath';
			        const SITE_URL = \`http://\$\{URL_NO_PROTOCOL\}\`;
			        const SERVER_URL = \`http://\$\{URL_NO_PROTOCOL\}\`;
			        const SERVER_WITH_SUBPATH = \`http://\$\{URL_PATH_NO_PROTOCOL\}\`;
			        const DEEPLINK_URL_ROOT = \`mattermost://\$\{URL_NO_PROTOCOL\}\`;
			
			        const tests = [
			            \{
			                name: 'should return null if all inputs are empty',
			                input: \{url: '', serverURL: '', siteURL: ''\},
			                expected: \{type: 'invalid'\},
			            \},
			            \{
			                name: 'should return null if any of the input is null',
			                input: \{url: '', serverURL: '', siteURL: null\},
			                expected: \{type: 'invalid'\},
			            \},
			            \{
			                name: 'should return null if any of the input is null',
			                input: \{url: '', serverURL: null, siteURL: ''\},
			                expected: \{type: 'invalid'\},
			            \},
			            \{
			                name: 'should return null if any of the input is null',
			                input: \{url: null, serverURL: '', siteURL: ''\},
			                expected: \{type: 'invalid'\},
			            \},
			            \{
			                name: 'should return null for not supported link',
			                input: \{
			                    url: 'https://otherserver.com',
			                    serverURL: SERVER_URL,
			                    siteURL: SITE_URL,
			                \},
			                expected: \{type: 'invalid'\},
			            \},
			            \{
			                name: 'should return null despite url subset match',
			                input: \{url: 'http://myserver.com', serverURL: 'http://myserver.co'\},
			                expected: \{type: 'invalid'\},
			            \},
			            \{
			                name: 'should match despite no server URL in input link',
			                input: \{
			                    url: '/ad-1/pl/qe93kkfd7783iqwuwfcwcxbsgy',
			                    serverURL: SERVER_URL,
			                    siteURL: SITE_URL,
			                \},
			                expected: \{
			                    data: \{
			                        postId: 'qe93kkfd7783iqwuwfcwcxbsgy',
			                        serverUrl: URL_NO_PROTOCOL,
			                        teamName: 'ad-1',
			                    \},
			                    type: DeepLinkType.Permalink,
			                \},
			            \},
			            \{
			                name: 'should match channel link',
			                input: \{
			                    url: SITE_URL + '/ad-1/channels/town-square',
			                    serverURL: SERVER_URL,
			                    siteURL: SITE_URL,
			                \},
			                expected: \{
			                    data: \{
			                        channelName: 'town-square',
			                        serverUrl: URL_NO_PROTOCOL,
			                        teamName: 'ad-1',
			                    \},
			                    type: DeepLinkType.Channel,
			                \},
			            \},
			            \{
			                name: 'should match permalink',
			                input: \{
			                    url: SITE_URL + '/ad-1/pl/qe93kkfd7783iqwuwfcwcxbsgy',
			                    serverURL: SERVER_URL,
			                    siteURL: SITE_URL,
			                \},
			                expected: \{
			                    data: \{
			                        postId: 'qe93kkfd7783iqwuwfcwcxbsgy',
			                        serverUrl: URL_NO_PROTOCOL,
			                        teamName: 'ad-1',
			                    \},
			                    type: DeepLinkType.Permalink,
			                \},
			            \},
			            \{
			                name: 'should match channel link with deeplink prefix',
			                input: \{
			                    url: DEEPLINK_URL_ROOT + '/ad-1/channels/town-square',
			                    serverURL: SERVER_URL,
			                    siteURL: SITE_URL,
			                \},
			                expected: \{
			                    data: \{
			                        channelName: 'town-square',
			                        serverUrl: URL_NO_PROTOCOL,
			                        teamName: 'ad-1',
			                    \},
			                    type: DeepLinkType.Channel,
			                \},
			            \},
			            \{
			                name: 'should match permalink with deeplink prefix on a Server hosted in a Subpath',
			                input: \{
			                    url: DEEPLINK_URL_ROOT + '/subpath/ad-1/pl/qe93kkfd7783iqwuwfcwcxbsrr',
			                    serverURL: SERVER_WITH_SUBPATH,
			                    siteURL: SERVER_WITH_SUBPATH,
			                \},
			                expected: \{
			                    data: \{
			                        postId: 'qe93kkfd7783iqwuwfcwcxbsrr',
			                        serverUrl: URL_PATH_NO_PROTOCOL,
			                        teamName: 'ad-1',
			                    \},
			                    type: 'permalink',
			                \},
			            \},
			            \{
			                name: 'should match permalink on a Server hosted in a Subpath',
			                input: \{
			                    url: SERVER_WITH_SUBPATH + '/ad-1/pl/qe93kkfd7783iqwuwfcwcxbsrr',
			                    serverURL: SERVER_WITH_SUBPATH,
			                    siteURL: SERVER_WITH_SUBPATH,
			                \},
			                expected: \{
			                    data: \{
			                        postId: 'qe93kkfd7783iqwuwfcwcxbsrr',
			                        serverUrl: URL_PATH_NO_PROTOCOL,
			                        teamName: 'ad-1',
			                    \},
			                    type: 'permalink',
			                \},
			            \},
			            \{
			                name: 'should not match url',
			                input: \{
			                    url: 'https://github.com/mattermost/mattermost-mobile/issues/new',
			                    serverURL: SERVER_WITH_SUBPATH,
			                    siteURL: SERVER_WITH_SUBPATH,
			                \},
			                expected: \{
			                    type: 'invalid',
			                \},
			            \},
			        ];
			
			        for (const test of tests) \{
			            const \{name, input, expected\} = test;
			
			            it(name, () => \{
			                const match = matchDeepLink(input.url!, input.serverURL!, input.siteURL!);
			                const parsed = parseDeepLink(match);
			                Reflect.deleteProperty(parsed, 'url');
			                expect(parsed).toEqual(expected);
			            \});
			        \}
			    \});
			
			    describe('tryOpenUrl', () => \{
			        const url = 'https://some.url.com';
			
			        it('should call onSuccess when Linking.openURL succeeds', async () => \{
			            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
			            // @ts-ignore
			            Linking.openURL.mockResolvedValueOnce();
			            const onError = jest.fn();
			            const onSuccess = jest.fn();
			
			            await UrlUtils.tryOpenURL(url, onError, onSuccess);
			            expect(onError).not.toHaveBeenCalled();
			            expect(onSuccess).toHaveBeenCalledTimes(1);
			        \});
			
			        it('should call onError when Linking.openURL fails', async () => \{
			            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
			            // @ts-ignore
			            Linking.openURL.mockRejectedValueOnce();
			            const onError = jest.fn();
			            const onSuccess = jest.fn();
			
			            UrlUtils.tryOpenURL(url, onError, onSuccess);
			            await TestHelper.wait(200);
			            expect(onError).toHaveBeenCalledTimes(1);
			            expect(onSuccess).not.toHaveBeenCalled();
			        \});
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\app\\utils\\url\\test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(16)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\about.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    HomeScreen,
			    LoginScreen,
			    AboutScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - About', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, and go to about screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await AboutScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on about screen
			        await AboutScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await AboutScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5104_1 - should match elements on about screen', async () => \{
			        // * Verify basic elements on about screen
			        await expect(AboutScreen.backButton).toBeVisible();
			        await expect(AboutScreen.logo).toBeVisible();
			        await expect(AboutScreen.siteName).toBeVisible();
			        await expect(AboutScreen.title).toBeVisible();
			        await expect(AboutScreen.subtitle).toBeVisible();
			        await expect(AboutScreen.appVersionTitle).toHaveText('App Version:');
			        await expect(AboutScreen.appVersionValue).toBeVisible();
			        await expect(AboutScreen.serverVersionTitle).toHaveText('Server Version:');
			        await expect(AboutScreen.serverVersionValue).toBeVisible();
			        await expect(AboutScreen.databaseTitle).toHaveText('Database:');
			        await expect(AboutScreen.databaseValue).toBeVisible();
			        await expect(AboutScreen.databaseSchemaVersionTitle).toHaveText('Database Schema Version:');
			        await expect(AboutScreen.databaseSchemaVersionValue).toBeVisible();
			        await expect(AboutScreen.licensee).toBeVisible();
			        await expect(AboutScreen.learnMoreText).toHaveText('Learn more about Enterprise Edition at ');
			        await expect(AboutScreen.learnMoreUrl).toBeVisible();
			        await expect(AboutScreen.copyright).toHaveText(\`Copyright 2015-\$\{new Date().getFullYear()\} Mattermost, Inc. All rights reserved\`);
			        await expect(AboutScreen.termsOfService).toHaveText('Terms of Service');
			        await expect(AboutScreen.privacyPolicy).toHaveText('Privacy Policy');
			        await expect(AboutScreen.noticeText).toHaveText('Mattermost is made possible by the open source software used in our server and mobile apps.');
			        await waitFor(AboutScreen.buildDateValue).toBeVisible().whileElement(by.id(AboutScreen.testID.scrollView)).scroll(50, 'down');
			        await expect(AboutScreen.buildHashTitle).toHaveText('Build Hash:');
			        await expect(AboutScreen.buildHashValue).toBeVisible();
			        await expect(AboutScreen.buildHashEnterpriseTitle).toHaveText('EE Build Hash:');
			        await expect(AboutScreen.buildHashEnterpriseValue).toBeVisible();
			        await expect(AboutScreen.buildDateTitle).toHaveText('Build Date:');
			        await expect(AboutScreen.buildDateValue).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\about.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\account_menu.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    CustomStatusScreen,
			    EditProfileScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Account - Account Menu', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server and go to account screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on account screen
			        await AccountScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4988_1 - should match elements on account screen', async () => \{
			        // * Verify basic elements on account screen
			        const \{userInfoProfilePicture, userInfoUserDisplayName, userInfoUsername\} = AccountScreen.getUserInfo(testUser.id);
			        await expect(userInfoProfilePicture).toBeVisible();
			        await expect(userInfoUserDisplayName).toHaveText(\`\$\{testUser.first_name\} \$\{testUser.last_name\} (\$\{testUser.nickname\})\`);
			        await expect(userInfoUsername).toHaveText(\`@\$\{testUser.username\}\`);
			        await expect(AccountScreen.userPresenceOption).toBeVisible();
			        await expect(AccountScreen.setStatusOption).toBeVisible();
			        await expect(AccountScreen.yourProfileOption).toBeVisible();
			        await expect(AccountScreen.settingsOption).toBeVisible();
			        await expect(AccountScreen.logoutOption).toBeVisible();
			    \});
			
			    it('MM-T4988_2 - should be able to set user presence', async () => \{
			        // # Tap on user presence option and tap on offline user status option
			        await AccountScreen.userPresenceOption.tap();
			        await wait(timeouts.ONE_SEC);
			        await AccountScreen.offlineUserStatusOption.tap();
			
			        // * Verify on account screen and verify user presence icon and label are for offline user status
			        await AccountScreen.toBeVisible();
			        await expect(AccountScreen.getUserPresenceIndicator('offline')).toBeVisible();
			        await expect(AccountScreen.getUserPresenceLabel('offline')).toHaveText('Offline');
			
			        // # Tap on user presence option and tap on do not disturb user status option
			        await AccountScreen.userPresenceOption.tap();
			        await wait(timeouts.ONE_SEC);
			        await AccountScreen.dndUserStatusOption.tap();
			
			        // * Verify on account screen and verify user presence icon and label are for do no disturb user status
			        await AccountScreen.toBeVisible();
			        await expect(AccountScreen.getUserPresenceIndicator('dnd')).toBeVisible();
			        await expect(AccountScreen.getUserPresenceLabel('dnd')).toHaveText('Do Not Disturb');
			
			        // # Tap on user presence option and tap on away user status option
			        await AccountScreen.userPresenceOption.tap();
			        await wait(timeouts.ONE_SEC);
			        await AccountScreen.awayUserStatusOption.tap();
			
			        // * Verify on account screen and verify user presence icon and label are for away user status
			        await AccountScreen.toBeVisible();
			        await expect(AccountScreen.getUserPresenceIndicator('away')).toBeVisible();
			        await expect(AccountScreen.getUserPresenceLabel('away')).toHaveText('Away');
			
			        // # Tap on user presence option and tap on online user status option
			        await AccountScreen.userPresenceOption.tap();
			        await wait(timeouts.ONE_SEC);
			        await AccountScreen.onlineUserStatusOption.tap();
			
			        // * Verify on account screen and verify user presence icon and label are for online user status
			        await AccountScreen.toBeVisible();
			        await expect(AccountScreen.getUserPresenceIndicator('online')).toBeVisible();
			        await expect(AccountScreen.getUserPresenceLabel('online')).toHaveText('Online');
			    \});
			
			    it('MM-T4988_3 - should be able to go to custom status screen', async () => \{
			        // # Tap on set status option
			        await AccountScreen.setStatusOption.tap();
			
			        // * Verify on custom status screen
			        await CustomStatusScreen.toBeVisible();
			
			        // # Go back to account screen
			        await CustomStatusScreen.close();
			    \});
			
			    it('MM-T4988_4 - should be able to go to edit profile screen', async () => \{
			        // # Tap on your profile option
			        await AccountScreen.yourProfileOption.tap();
			
			        // * Verify on edit profile screen
			        await EditProfileScreen.toBeVisible();
			
			        // # Go back to account screen
			        await EditProfileScreen.close();
			    \});
			
			    it('MM-T4988_5 - should be able to go to settings screen', async () => \{
			        // # Tap on settings option
			        await AccountScreen.settingsOption.tap();
			
			        // * Verify on settings screen
			        await SettingsScreen.toBeVisible();
			
			        // # Go back to account screen
			        await SettingsScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\account_menu.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\advanced_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    AdvancedSettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Advanced Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, and go to advanced settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await AdvancedSettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on advanced settings screen
			        await AdvancedSettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await AdvancedSettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5103_1 - should match elements on advanced settings screen', async () => \{
			        // * Verify basic elements on advanced settings screen
			        await expect(AdvancedSettingsScreen.backButton).toBeVisible();
			        await expect(AdvancedSettingsScreen.deleteDataOption).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\advanced_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\auto_responder_notification_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    AutoResponderNotificationSettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    NotificationSettingsScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isIos\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Auto-Responder Notification Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, open notification settings screen, and go to auto-responder notification settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await NotificationSettingsScreen.open();
			        await AutoResponderNotificationSettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on auto-responder notification settings screen
			        await AutoResponderNotificationSettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await AutoResponderNotificationSettingsScreen.back();
			        await NotificationSettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5110_1 - should match elements on auto-responder notification settings screen', async () => \{
			        // * Verify basic elements on auto-responder notification settings screen
			        await expect(AutoResponderNotificationSettingsScreen.backButton).toBeVisible();
			        await expect(AutoResponderNotificationSettingsScreen.enableAutomaticRepliesOptionToggledOff).toBeVisible();
			        await expect(AutoResponderNotificationSettingsScreen.messageInputDescription).toHaveText('Set a custom message that is automatically sent in response to direct messages, such as an out of office or vacation reply. Enabling this setting changes your status to Out of Office and disables notifications.');
			    \});
			
			    it('MM-T5110_2 - should be able to change auto-responder notification settings and save by tapping navigation back button', async () => \{
			        // # Toggle enable automatic replies option on, type in message, and tap on back button
			        const message = \`Message \$\{getRandomId()\}\`;
			        await AutoResponderNotificationSettingsScreen.toggleEnableAutomaticRepliesOptionOn();
			        await AutoResponderNotificationSettingsScreen.messageInput.replaceText(message);
			        await AutoResponderNotificationSettingsScreen.back();
			
			        // * Verify on notification settings screen and automatic replies is enabled
			        await NotificationSettingsScreen.toBeVisible();
			        await expect(NotificationSettingsScreen.automaticRepliesOptionInfo).toHaveText('On');
			
			        // * Go back to auto-responder notification settings screen
			        await AutoResponderNotificationSettingsScreen.open();
			
			        // * Verify enable automatic replies option is toggled on and message is saved
			        await expect(AutoResponderNotificationSettingsScreen.enableAutomaticRepliesOptionToggledOn).toBeVisible();
			        if (isIos()) \{
			            await expect(AutoResponderNotificationSettingsScreen.messageInput).toHaveValue(message);
			        \} else \{
			            await expect(AutoResponderNotificationSettingsScreen.messageInput).toHaveText(message);
			        \}
			
			        // # Toggle enable automatic replies option off and tap on back button
			        await AutoResponderNotificationSettingsScreen.toggleEnableAutomaticRepliesOptionOff();
			        await AutoResponderNotificationSettingsScreen.back();
			
			        // * Verify on notification settings screen and automatic replies is disabled
			        await NotificationSettingsScreen.toBeVisible();
			        await expect(NotificationSettingsScreen.automaticRepliesOptionInfo).toHaveText('Off');
			
			        // * Go back to auto-responder notification settings screen
			        await AutoResponderNotificationSettingsScreen.open();
			
			        // * Verify enable automatic replies option is toggled off and message input does not exist
			        await expect(AutoResponderNotificationSettingsScreen.enableAutomaticRepliesOptionToggledOff).toBeVisible();
			        await expect(AutoResponderNotificationSettingsScreen.messageInput).not.toExist();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\auto_responder_notification_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\clock_display_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    ClockDisplaySettingsScreen,
			    DisplaySettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Clock Display Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, open display settings screen, and go to clock display settings
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await DisplaySettingsScreen.open();
			        await ClockDisplaySettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on clock display settings screen
			        await ClockDisplaySettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ClockDisplaySettingsScreen.back();
			        await DisplaySettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5112_1 - should match elements on clock display settings screen', async () => \{
			        // * Verify basic elements on clock display settings screen
			        await expect(ClockDisplaySettingsScreen.backButton).toBeVisible();
			        await expect(ClockDisplaySettingsScreen.twelveHourOption).toBeVisible();
			        await expect(ClockDisplaySettingsScreen.twentyFourHourOption).toBeVisible();
			    \});
			
			    it('MM-T5112_2 - should be able to select a clock display and save by tapping navigation back button', async () => \{
			        // # Tap on a twenty four hour option and tap on back button
			        await ClockDisplaySettingsScreen.twentyFourHourOption.tap();
			        await ClockDisplaySettingsScreen.back();
			
			        // * Verify on display settings screen and twenty four hour is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.clockDisplayOptionInfo).toHaveText('24-hour');
			
			        // # Go back to clock display settings screen
			        await ClockDisplaySettingsScreen.open();
			
			        // * Verify twenty four option is selected
			        await expect(ClockDisplaySettingsScreen.twentyFourHourOptionSelected).toBeVisible();
			
			        // # Tap on twelve hour option and tap on back button
			        await ClockDisplaySettingsScreen.twelveHourOption.tap();
			        await ClockDisplaySettingsScreen.back();
			
			        // * Verify on display settings screen and twelve hour is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.clockDisplayOptionInfo).toHaveText('12-hour');
			
			        // # Go back to clock display settings screen
			        await ClockDisplaySettingsScreen.open();
			
			        // * Verify twelve hour option is selected
			        await expect(ClockDisplaySettingsScreen.twelveHourOptionSelected).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\clock_display_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\custom_status.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    CustomStatusScreen,
			    EmojiPickerScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isIos, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Account - Custom Status', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server and go to account screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on account screen
			        await AccountScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4990_1 - should match elements on custom status screen', async () => \{
			        // # Open custom status screen
			        await CustomStatusScreen.open();
			
			        // * Verify basic elements on custom status screen
			        await expect(CustomStatusScreen.doneButton).toBeVisible();
			        await expect(CustomStatusScreen.getCustomStatusEmoji('default')).toBeVisible();
			        await expect(CustomStatusScreen.statusInput).toBeVisible();
			        await expect(CustomStatusScreen.suggestions).toBeVisible();
			        await verifySuggestedCustomStatus('calendar', 'In a meeting', 'one_hour');
			        await verifySuggestedCustomStatus('hamburger', 'Out for lunch', 'thirty_minutes');
			        await verifySuggestedCustomStatus('sneezing_face', 'Out sick', 'today');
			        await verifySuggestedCustomStatus('house', 'Working from home', 'today');
			        await verifySuggestedCustomStatus('palm_tree', 'On a vacation', 'this_week');
			
			        // # Go back to account screen
			        await CustomStatusScreen.close();
			    \});
			
			    it('MM-T4990_2 - should be able to set a status via suggestions', async () => \{
			        // # Open custom status screen, tap on a suggested custom status, and tap on done button
			        const customStatusEmojiName = 'calendar';
			        const customStatusText = 'In a meeting';
			        const customStatusDuration = 'one_hour';
			        await CustomStatusScreen.open();
			        const \{customStatusSuggestion\} = CustomStatusScreen.getSuggestedCustomStatus(customStatusEmojiName, customStatusText, customStatusDuration);
			        await customStatusSuggestion.tap();
			        await CustomStatusScreen.doneButton.tap();
			
			        // * Verify on account screen and suggested custom status is set
			        await verifyOnAccountScreenAndCustomStatusIsSet(customStatusEmojiName, customStatusText, customStatusDuration);
			
			        // # Open custom status screen
			        await CustomStatusScreen.open();
			
			        // * Verify custom status is set on the field, shown under recent, and removed from suggestions
			        await expect(CustomStatusScreen.getCustomStatusEmoji(customStatusEmojiName)).toBeVisible();
			        if (isIos()) \{
			            await expect(CustomStatusScreen.statusInput).toHaveValue(customStatusText);
			        \} else \{
			            await expect(CustomStatusScreen.statusInput).toHaveText(customStatusText);
			        \}
			        const \{customStatusSuggestion: recentCustomStatus, customStatusClearButton: recentCustomStatusClearButton\} = CustomStatusScreen.getRecentCustomStatus(customStatusEmojiName, customStatusText, customStatusDuration);
			        await expect(recentCustomStatus).toBeVisible();
			        const \{customStatusSuggestion: suggestedCustomStatus\} = CustomStatusScreen.getSuggestedCustomStatus(customStatusEmojiName, customStatusText, customStatusDuration);
			        await expect(suggestedCustomStatus).not.toExist();
			
			        // # Tap on clear button for custom status from recent
			        await recentCustomStatusClearButton.tap();
			
			        // * Verify custom status is removed from recent and shown back under suggestions
			        await expect(recentCustomStatus).not.toExist();
			        await expect(suggestedCustomStatus).toBeVisible();
			
			        // # Tap on status input clear button and tap on done button
			        await CustomStatusScreen.statusInputClearButton.tap();
			        await CustomStatusScreen.doneButton.tap();
			    \});
			
			    it('MM-T4990_3 - should be able to set a status via emoji picker and custom status', async () => \{
			        // # Open custom status screen, pick an emoji and type in custom status, and tap on done button
			        const customStatusEmojiName = 'clown_face';
			        const customStatusText = \`Status \$\{getRandomId()\}\`;
			        const customStatusDuration = 'today';
			        await CustomStatusScreen.open();
			        await CustomStatusScreen.openEmojiPicker('default', true);
			        await EmojiPickerScreen.searchInput.replaceText(customStatusEmojiName);
			        await element(by.text('🤡')).tap();
			        await wait(timeouts.ONE_SEC);
			        await CustomStatusScreen.statusInput.replaceText(customStatusText);
			        await CustomStatusScreen.doneButton.tap();
			
			        // * Verify on account screen and custom status is set
			        await verifyOnAccountScreenAndCustomStatusIsSet(customStatusEmojiName, customStatusText, customStatusDuration);
			
			        // # Open custom status screen
			        await CustomStatusScreen.open();
			
			        // * Verify custom status is set on the field and shown under recent
			        await expect(CustomStatusScreen.getCustomStatusEmoji(customStatusEmojiName)).toBeVisible();
			        if (isIos()) \{
			            await expect(CustomStatusScreen.statusInput).toHaveValue(customStatusText);
			        \} else \{
			            await expect(CustomStatusScreen.statusInput).toHaveText(customStatusText);
			        \}
			        const \{customStatusSuggestion: recentCustomStatus, customStatusClearButton: recentCustomStatusClearButton\} = CustomStatusScreen.getRecentCustomStatus(customStatusEmojiName, customStatusText, customStatusDuration);
			        await expect(recentCustomStatus).toBeVisible();
			
			        // # Tap on clear button for custom status from recent
			        await recentCustomStatusClearButton.tap();
			
			        // * Verify custom status is removed from recent
			        await expect(recentCustomStatus).not.toExist();
			
			        // # Tap on status input clear button and tap on done button
			        await CustomStatusScreen.statusInputClearButton.tap();
			        await CustomStatusScreen.doneButton.tap();
			    \});
			
			    it('MM-T4990_4 - should be able to clear custom status from account', async () => \{
			        // # Open custom status screen, tap on a suggested custom status, and tap on done button
			        const customStatusEmojiName = 'calendar';
			        const customStatusText = 'In a meeting';
			        const customStatusDuration = 'one_hour';
			        await CustomStatusScreen.open();
			        const \{customStatusSuggestion\} = CustomStatusScreen.getSuggestedCustomStatus(customStatusEmojiName, customStatusText, customStatusDuration);
			        await customStatusSuggestion.tap();
			        await CustomStatusScreen.doneButton.tap();
			
			        // * Verify on account screen and suggested custom status is set
			        await verifyOnAccountScreenAndCustomStatusIsSet(customStatusEmojiName, customStatusText, customStatusDuration);
			
			        // # Tap on clear button for custom status from display field
			        await AccountScreen.customStatusClearButton.tap();
			
			        // * Verify custom status is cleared from account screen
			        const defaultStatusText = 'Set a custom status';
			        const \{accountCustomStatusEmoji, accountCustomStatusText, accountCustomStatusExpiry\} = AccountScreen.getCustomStatus(customStatusEmojiName, customStatusDuration);
			        await expect(accountCustomStatusEmoji).not.toExist();
			        await expect(accountCustomStatusText).toHaveText(defaultStatusText);
			        await expect(accountCustomStatusExpiry).not.toExist();
			
			        // # Open custom status screen
			        await CustomStatusScreen.open();
			
			        // * Verify custom status is cleared from input field
			        await expect(CustomStatusScreen.getCustomStatusEmoji('default')).toBeVisible();
			        if (isIos()) \{
			            await expect(CustomStatusScreen.statusInput).toHaveValue(defaultStatusText);
			        \} else \{
			            await expect(CustomStatusScreen.statusInput).toHaveText('');
			        \}
			
			        // # Go back to account screen
			        await CustomStatusScreen.close();
			    \});
			\});
			
			const verifySuggestedCustomStatus = async (emojiName: string, text: string, duration: string) => \{
			    const \{customStatusSuggestionEmoji, customStatusSuggestionText, customStatusSuggestionDuration\} = CustomStatusScreen.getSuggestedCustomStatus(emojiName, text, duration);
			    await expect(customStatusSuggestionEmoji).toBeVisible();
			    await expect(customStatusSuggestionText).toBeVisible();
			    await expect(customStatusSuggestionDuration).toBeVisible();
			\};
			
			const verifyOnAccountScreenAndCustomStatusIsSet = async (emojiName: string, text: string, duration: string) => \{
			    await AccountScreen.toBeVisible();
			    const \{accountCustomStatusEmoji, accountCustomStatusText, accountCustomStatusExpiry\} = AccountScreen.getCustomStatus(emojiName, duration);
			    await expect(accountCustomStatusEmoji).toBeVisible();
			    await expect(accountCustomStatusText).toHaveText(text);
			    await expect(accountCustomStatusExpiry).toBeVisible();
			\};
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\custom_status.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\display_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    ClockDisplaySettingsScreen,
			    DisplaySettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    SettingsScreen,
			    ThemeDisplaySettingsScreen,
			    TimezoneDisplaySettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Display Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, and go to display settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await DisplaySettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on display settings screen
			        await DisplaySettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await DisplaySettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5102_1 - should match elements on display settings screen', async () => \{
			        // * Verify basic elements on display settings screen
			        await expect(DisplaySettingsScreen.backButton).toBeVisible();
			        await expect(DisplaySettingsScreen.themeOption).toBeVisible();
			        await expect(DisplaySettingsScreen.clockDisplayOption).toBeVisible();
			        await expect(DisplaySettingsScreen.timezoneOption).toBeVisible();
			    \});
			
			    it('MM-T5102_2 - should be able to go to theme display settings screen', async () => \{
			        // # Tap on theme option
			        await DisplaySettingsScreen.themeOption.tap();
			
			        // * Verify on theme display settings screen
			        await ThemeDisplaySettingsScreen.toBeVisible();
			
			        // # Go back to display settings screen
			        await ThemeDisplaySettingsScreen.back();
			    \});
			
			    it('MM-T5102_3 - should be able to go to clock display settings screen', async () => \{
			        // # Tap on clock display option
			        await DisplaySettingsScreen.clockDisplayOption.tap();
			
			        // * Verify on clock display settings screen
			        await ClockDisplaySettingsScreen.toBeVisible();
			
			        // # Go back to display settings screen
			        await ClockDisplaySettingsScreen.back();
			    \});
			
			    it('MM-T5102_4 - should be able to go to timezone display settings screen', async () => \{
			        // # Tap on timezone option
			        await DisplaySettingsScreen.timezoneOption.tap();
			
			        // # Verify on timezone display settings screen
			        await TimezoneDisplaySettingsScreen.toBeVisible();
			
			        // # Go back to display settings screen
			        await TimezoneDisplaySettingsScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\display_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\edit_profile.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    EditProfileScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isIos\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Account - Edit Profile', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server and go to account screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on account screen
			        await AccountScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4989_1 - should match elements on edit profile screen', async () => \{
			        // # Open edit profile screen
			        await EditProfileScreen.open();
			
			        // * Verify basic elements on edit profile screen
			        await expect(EditProfileScreen.closeButton).toBeVisible();
			        await expect(EditProfileScreen.saveButton).toBeVisible();
			        await expect(EditProfileScreen.getEditProfilePicture(testUser.id)).toBeVisible();
			        if (isIos()) \{
			            await expect(EditProfileScreen.firstNameInput).toHaveValue(testUser.first_name);
			            await expect(EditProfileScreen.lastNameInput).toHaveValue(testUser.last_name);
			            await expect(EditProfileScreen.usernameInput).toHaveValue(testUser.username);
			            await expect(EditProfileScreen.emailInputDisabled).toHaveValue(testUser.email);
			            await expect(EditProfileScreen.nicknameInput).toHaveValue(testUser.nickname);
			            await expect(EditProfileScreen.positionInput).toHaveValue(testUser.position);
			        \} else \{
			            await expect(EditProfileScreen.firstNameInput).toHaveText(testUser.first_name);
			            await expect(EditProfileScreen.lastNameInput).toHaveText(testUser.last_name);
			            await expect(EditProfileScreen.usernameInput).toHaveText(testUser.username);
			            await expect(EditProfileScreen.emailInputDisabled).toHaveText(testUser.email);
			            await expect(EditProfileScreen.nicknameInput).toHaveText(testUser.nickname);
			            await expect(EditProfileScreen.positionInput).toHaveText(testUser.position);
			        \}
			        await expect(EditProfileScreen.emailInputDescription).toHaveText('Email must be updated using a web client or desktop application.');
			
			        // # Go back to account screen
			        await EditProfileScreen.close();
			    \});
			
			    it('MM-T4989_2 - should be able to edit profile and save', async () => \{
			        // # Open edit profile screen, edit fields, and tap on save button
			        const suffix = getRandomId(3);
			        await EditProfileScreen.open();
			        await EditProfileScreen.firstNameInput.replaceText(\`\$\{testUser.first_name\}\$\{suffix\}\`);
			        await EditProfileScreen.lastNameInput.replaceText(\`\$\{testUser.last_name\}\$\{suffix\}\`);
			        await EditProfileScreen.scrollView.tap(\{x: 1, y: 1\});
			        await waitFor(EditProfileScreen.usernameInput).toBeVisible().whileElement(by.id(EditProfileScreen.testID.scrollView)).scroll(50, 'down');
			        await EditProfileScreen.usernameInput.clearText();
			        await EditProfileScreen.usernameInput.typeText(\`\$\{testUser.username\}\$\{suffix\}\`);
			        await EditProfileScreen.scrollView.tap(\{x: 1, y: 1\});
			        await waitFor(EditProfileScreen.nicknameInput).toBeVisible().whileElement(by.id(EditProfileScreen.testID.scrollView)).scroll(50, 'down');
			        await EditProfileScreen.nicknameInput.replaceText(\`\$\{testUser.nickname\}\$\{suffix\}\`);
			        await EditProfileScreen.scrollView.tap(\{x: 1, y: 1\});
			        await waitFor(EditProfileScreen.positionInput).toBeVisible().whileElement(by.id(EditProfileScreen.testID.scrollView)).scroll(50, 'down');
			        await EditProfileScreen.positionInput.replaceText(\`\$\{testUser.position\}\$\{suffix\}\`);
			        await EditProfileScreen.saveButton.tap();
			
			        // * Verify on account screen and user full name and username are updated
			        await AccountScreen.toBeVisible();
			        const \{userInfoUserDisplayName, userInfoUsername\} = AccountScreen.getUserInfo(testUser.id);
			        await expect(userInfoUserDisplayName).toHaveText(\`\$\{testUser.first_name\}\$\{suffix\} \$\{testUser.last_name\}\$\{suffix\} (\$\{testUser.nickname\}\$\{suffix\})\`);
			        await expect(userInfoUsername).toHaveText(\`@\$\{testUser.username\}\$\{suffix\}\`);
			
			        // # Open edit profile screen
			        await EditProfileScreen.open();
			
			        // * Verify edited profile fields contain the updated values
			        if (isIos()) \{
			            await expect(EditProfileScreen.firstNameInput).toHaveValue(\`\$\{testUser.first_name\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.lastNameInput).toHaveValue(\`\$\{testUser.last_name\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.usernameInput).toHaveValue(\`\$\{testUser.username\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.emailInputDisabled).toHaveValue(testUser.email);
			            await expect(EditProfileScreen.nicknameInput).toHaveValue(\`\$\{testUser.nickname\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.positionInput).toHaveValue(\`\$\{testUser.position\}\$\{suffix\}\`);
			        \} else \{
			            await expect(EditProfileScreen.firstNameInput).toHaveText(\`\$\{testUser.first_name\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.lastNameInput).toHaveText(\`\$\{testUser.last_name\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.usernameInput).toHaveText(\`\$\{testUser.username\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.emailInputDisabled).toHaveText(testUser.email);
			            await expect(EditProfileScreen.nicknameInput).toHaveText(\`\$\{testUser.nickname\}\$\{suffix\}\`);
			            await expect(EditProfileScreen.positionInput).toHaveText(\`\$\{testUser.position\}\$\{suffix\}\`);
			        \}
			
			        // # Go back to account screen
			        await EditProfileScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\edit_profile.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\email_notification_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    EmailNotificationSettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    NotificationSettingsScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Email Notification Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, open notification settings screen, and go to email notification settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await NotificationSettingsScreen.open();
			        await EmailNotificationSettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on email notification settings screen
			        await EmailNotificationSettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await EmailNotificationSettingsScreen.back();
			        await NotificationSettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5109_1 - should match elements on email notification settings screen', async () => \{
			        // * Verify basic elements on email notification settings screen
			        await expect(EmailNotificationSettingsScreen.backButton).toBeVisible();
			        await expect(EmailNotificationSettingsScreen.immediatelyOption).toBeVisible();
			        await expect(EmailNotificationSettingsScreen.neverOption).toBeVisible();
			        await expect(EmailNotificationSettingsScreen.emailThreadsOptionToggledOn).toBeVisible();
			    \});
			
			    it('MM-T5109_2 - should be able to change email notification settings and save by tapping navigation back button', async () => \{
			        // # Tap on never option
			        await EmailNotificationSettingsScreen.neverOption.tap();
			
			        // * Verify email threads option does not exist
			        await expect(EmailNotificationSettingsScreen.emailThreadsOptionToggledOn).not.toExist();
			
			        // # Tap on back button
			        await EmailNotificationSettingsScreen.back();
			
			        // * Verify on notification settings screen and never is set
			        await NotificationSettingsScreen.toBeVisible();
			        await expect(NotificationSettingsScreen.emailNotificationsOptionInfo).toHaveText('Never');
			
			        // # Go back to email notification settings screen
			        await EmailNotificationSettingsScreen.open();
			
			        // * Verify never option is selected
			        await expect(EmailNotificationSettingsScreen.neverOptionSelected).toBeVisible();
			
			        // # Tap on immediately option, toggle email threads option off, and tap on back button
			        await EmailNotificationSettingsScreen.immediatelyOption.tap();
			        await EmailNotificationSettingsScreen.toggleEmailThreadsOptionOff();
			        await EmailNotificationSettingsScreen.back();
			
			        // * Verify on notification settings screen and immediately is set
			        await NotificationSettingsScreen.toBeVisible();
			        await expect(NotificationSettingsScreen.emailNotificationsOptionInfo).toHaveText('Immediately');
			
			        // # Go back to email notification settings screen
			        await EmailNotificationSettingsScreen.open();
			
			        // * Verify immediately option is selected and email thread option is toggled off
			        await expect(EmailNotificationSettingsScreen.immediatelyOptionSelected).toBeVisible();
			        await expect(EmailNotificationSettingsScreen.emailThreadsOptionToggledOff).toBeVisible();
			
			        // # Toggle email threads option off, tap on back button, and go back to email notification settings screen
			        await EmailNotificationSettingsScreen.toggleEmailThreadsOptionOn();
			        await EmailNotificationSettingsScreen.back();
			        await EmailNotificationSettingsScreen.open();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\email_notification_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\mention_notification_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    HomeScreen,
			    LoginScreen,
			    MentionNotificationSettingsScreen,
			    NotificationSettingsScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isIos\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Mention Notification Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, open notification settings screen, and go to mention notification settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await NotificationSettingsScreen.open();
			        await MentionNotificationSettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on mention notification settings screen
			        await MentionNotificationSettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await MentionNotificationSettingsScreen.back();
			        await NotificationSettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5107_1 - should match elements on mention notification settings screen', async () => \{
			        // * Verify basic elements on mention notification settings screen
			        await expect(MentionNotificationSettingsScreen.backButton).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.caseSensitiveFirstNameOptionToggledOff).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.nonCaseSensitiveUsernameOptionToggledOff).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.channelWideMentionsOptionToggledOn).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.keywordsInput).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.keywordsInputDescription).toHaveText('Keywords are not case-sensitive. Separate keywords with commas.');
			    \});
			
			    it('MM-T5107_2 - should be able to change mention notification settings and save by tapping navigation back button', async () => \{
			        // # Switch toggles, type in keywords as camelcase with spaces, tap on back button, and go back to mention notifications screen
			        const keywords = \` Keywords \$\{getRandomId()\} \`;
			        await MentionNotificationSettingsScreen.toggleCaseSensitiveFirstNameOptionOn();
			        await MentionNotificationSettingsScreen.toggleNonCaseSensitiveUsernameOptionOn();
			        await MentionNotificationSettingsScreen.toggleChannelWideMentionsOptionOff();
			        await MentionNotificationSettingsScreen.keywordsInput.replaceText(keywords);
			        await MentionNotificationSettingsScreen.back();
			        await MentionNotificationSettingsScreen.open();
			
			        // * Verify toggles are switched and keywords are saved as lowercase without spaces
			        await expect(MentionNotificationSettingsScreen.caseSensitiveFirstNameOptionToggledOn).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.nonCaseSensitiveUsernameOptionToggledOn).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.channelWideMentionsOptionToggledOff).toBeVisible();
			        if (isIos()) \{
			            await expect(MentionNotificationSettingsScreen.keywordsInput).toHaveValue(keywords.replace(/ /g, '').toLowerCase());
			        \} else \{
			            await expect(MentionNotificationSettingsScreen.keywordsInput).toHaveText(keywords.replace(/ /g, '').toLowerCase());
			        \}
			
			        // # Switch toggles back to original state, clear keywords, tap on back button, and go back to mention notifications screen
			        await MentionNotificationSettingsScreen.toggleCaseSensitiveFirstNameOptionOff();
			        await MentionNotificationSettingsScreen.toggleNonCaseSensitiveUsernameOptionOff();
			        await MentionNotificationSettingsScreen.toggleChannelWideMentionsOptionOn();
			        await MentionNotificationSettingsScreen.keywordsInput.clearText();
			        await MentionNotificationSettingsScreen.back();
			        await MentionNotificationSettingsScreen.open();
			
			        // * Verify toggles are switched back to original state and keywords are cleared
			        await expect(MentionNotificationSettingsScreen.caseSensitiveFirstNameOptionToggledOff).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.nonCaseSensitiveUsernameOptionToggledOff).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.channelWideMentionsOptionToggledOn).toBeVisible();
			        await expect(MentionNotificationSettingsScreen.keywordsInput).not.toHaveValue(keywords.replace(/ /g, '').toLowerCase());
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\mention_notification_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\notification_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    AutoResponderNotificationSettingsScreen,
			    EmailNotificationSettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    MentionNotificationSettingsScreen,
			    NotificationSettingsScreen,
			    PushNotificationSettingsScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Notification Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, and go to notification settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await NotificationSettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on notification settings screen
			        await NotificationSettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await NotificationSettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5101_1 - should match elements on notification settings screen', async () => \{
			        // * Verify basic elements on notification settings screen
			        await expect(NotificationSettingsScreen.backButton).toBeVisible();
			        await expect(NotificationSettingsScreen.mentionsOption).toBeVisible();
			        await expect(NotificationSettingsScreen.pushNotificationsOption).toBeVisible();
			        await expect(NotificationSettingsScreen.emailNotificationsOption).toBeVisible();
			        await expect(NotificationSettingsScreen.automaticRepliesOption).toBeVisible();
			    \});
			
			    it('MM-T5101_2 - should be able to go to mention notification settings screen', async () => \{
			        // # Tap on mention option
			        await NotificationSettingsScreen.mentionsOption.tap();
			
			        // * Verify on mention notification settings screen
			        await MentionNotificationSettingsScreen.toBeVisible();
			
			        // # Go back to notification settings screen
			        await MentionNotificationSettingsScreen.back();
			    \});
			
			    it('MM-T5101_3 - should be able to go to push notification settings screen', async () => \{
			        // # Tap on push notifications option
			        await NotificationSettingsScreen.pushNotificationsOption.tap();
			
			        // * Verify on push notification settings screen
			        await PushNotificationSettingsScreen.toBeVisible();
			
			        // # Go back to notification settings screen
			        await PushNotificationSettingsScreen.back();
			    \});
			
			    it('MM-T5101_4 - should be able to go to email notification settings screen', async () => \{
			        // # Tap on email notifications option
			        await NotificationSettingsScreen.emailNotificationsOption.tap();
			
			        // # Verify on email notification settings screen
			        await EmailNotificationSettingsScreen.toBeVisible();
			
			        // # Go back to notification settings screen
			        await EmailNotificationSettingsScreen.back();
			    \});
			
			    it('MM-T5101_5 - should be able to go to auto-responder notification settings screen', async () => \{
			        // # Tap on automatic replies option
			        await NotificationSettingsScreen.automaticRepliesOption.tap();
			
			        // # Verify on auto-responder notification settings screen
			        await AutoResponderNotificationSettingsScreen.toBeVisible();
			
			        // # Go back to notification settings screen
			        await AutoResponderNotificationSettingsScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\notification_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\push_notification_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    HomeScreen,
			    LoginScreen,
			    NotificationSettingsScreen,
			    PushNotificationSettingsScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Push Notification Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, open notification settings screen, and go to push notification settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await NotificationSettingsScreen.open();
			        await PushNotificationSettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on push notification settings screen
			        await PushNotificationSettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await PushNotificationSettingsScreen.back();
			        await NotificationSettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5108_1 - should match elements on push notification settings screen', async () => \{
			        // * Verify basic elements on push notification settings screen
			        await expect(PushNotificationSettingsScreen.backButton).toBeVisible();
			        await expect(PushNotificationSettingsScreen.allNewMessagesOption).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mentionsOnlyOption).toBeVisible();
			        await expect(PushNotificationSettingsScreen.nothingOption).toBeVisible();
			        await expect(PushNotificationSettingsScreen.pushThreadsFollowingOptionToggledOn).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mobileOnlineOption).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mobileAwayOption).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mobileOfflineOption).toBeVisible();
			    \});
			
			    it('MM-T5108_2 - should be able to change push notification settings and save by tapping navigation back button', async () => \{
			        // # Tap on all new messages option, tap on mobile online option, tap on back button, and go back to push notification settings screen
			        await PushNotificationSettingsScreen.allNewMessagesOption.tap();
			        await PushNotificationSettingsScreen.mobileOnlineOption.tap();
			        await PushNotificationSettingsScreen.back();
			        await PushNotificationSettingsScreen.open();
			
			        // * Verify all new messages option and mobile online option are selected and push threads following option does not exist
			        await expect(PushNotificationSettingsScreen.allNewMessagesOptionSelected).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mobileOnlineOptionSelected).toBeVisible();
			        await expect(PushNotificationSettingsScreen.pushThreadsFollowingOptionToggledOn).not.toExist();
			
			        // # Tap on nothing option, tap on back button, and go back to push notification settings screen
			        await PushNotificationSettingsScreen.nothingOption.tap();
			        await PushNotificationSettingsScreen.back();
			        await PushNotificationSettingsScreen.open();
			
			        // * Verify nothing option is selected and mobile options do no exist
			        await expect(PushNotificationSettingsScreen.nothingOptionSelected).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mobileOnlineOption).not.toExist();
			        await expect(PushNotificationSettingsScreen.mobileAwayOption).not.toExist();
			        await expect(PushNotificationSettingsScreen.mobileOfflineOption).not.toExist();
			
			        // # Tap on mentions only option, tap on mobile away option, toggle push threads following option off, tap on back button, and go back to push notification settings screen
			        await PushNotificationSettingsScreen.mentionsOnlyOption.tap();
			        await PushNotificationSettingsScreen.mobileAwayOption.tap();
			        await PushNotificationSettingsScreen.togglePushThreadsFollowingOptionOff();
			        await PushNotificationSettingsScreen.back();
			        await PushNotificationSettingsScreen.open();
			
			        // * Verify mentions only option and mobile away option are selected and push threads following option is toggled off
			        await expect(PushNotificationSettingsScreen.mentionsOnlyOptionSelected).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mobileAwayOptionSelected).toBeVisible();
			        await expect(PushNotificationSettingsScreen.pushThreadsFollowingOptionToggledOff).toBeVisible();
			
			        // # Toggle push threads following option on, tap on back button, and go back to push notification settings screen
			        await PushNotificationSettingsScreen.togglePushThreadsFollowingOptionOn();
			        await PushNotificationSettingsScreen.back();
			        await PushNotificationSettingsScreen.open();
			
			        // * Verify push threads following option is toggled on
			        await expect(PushNotificationSettingsScreen.pushThreadsFollowingOptionToggledOn).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\push_notification_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AboutScreen,
			    AccountScreen,
			    AdvancedSettingsScreen,
			    DisplaySettingsScreen,
			    HomeScreen,
			    NotificationSettingsScreen,
			    LoginScreen,
			    ServerScreen,
			    SettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, and go to settings screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on settings screen
			        await SettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4991_1 - should match elements on settings screen', async () => \{
			        // * Verify basic elements on settings screen
			        await expect(SettingsScreen.notificationsOption).toBeVisible();
			        await expect(SettingsScreen.displayOption).toBeVisible();
			        await expect(SettingsScreen.advancedSettingsOption).toBeVisible();
			        await expect(SettingsScreen.aboutOption).toBeVisible();
			        await expect(SettingsScreen.helpOption).toBeVisible();
			        await expect(SettingsScreen.reportProblemOption).toBeVisible();
			    \});
			
			    it('MM-T4991_2 - should be able to go to notification settings screen', async () => \{
			        // # Tap on notifications option
			        await SettingsScreen.notificationsOption.tap();
			
			        // * Verify on notification settings screen
			        await NotificationSettingsScreen.toBeVisible();
			
			        // # Go back to settings screen
			        await NotificationSettingsScreen.back();
			    \});
			
			    it('MM-T4991_3 - should be able to go to display settings screen', async () => \{
			        // # Tap on display option
			        await SettingsScreen.displayOption.tap();
			
			        // * Verify on display settings screen
			        await DisplaySettingsScreen.toBeVisible();
			
			        // # Go back to settings screen
			        await DisplaySettingsScreen.back();
			    \});
			
			    it('MM-T4991_4 - should be able to go to advanced settings screen', async () => \{
			        // # Tap on advanced settings option
			        await SettingsScreen.advancedSettingsOption.tap();
			
			        // * Verify on advanced settings screen
			        await AdvancedSettingsScreen.toBeVisible();
			
			        // # Go back to settings screen
			        await AdvancedSettingsScreen.back();
			    \});
			
			    it('MM-T4991_5 - should be able to go to about screen', async () => \{
			        // # Tap on about option
			        await SettingsScreen.aboutOption.tap();
			
			        // * Verify on about screen
			        await AboutScreen.toBeVisible();
			
			        // # Go back to settings screen
			        await AboutScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\theme_display_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    DisplaySettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    SettingsScreen,
			    ThemeDisplaySettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Theme Display Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, open display settings screen, and go to theme display settings
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await DisplaySettingsScreen.open();
			        await ThemeDisplaySettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on theme display settings screen
			        await ThemeDisplaySettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ThemeDisplaySettingsScreen.back();
			        await DisplaySettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5111_1 - should match elements on theme display settings screen', async () => \{
			        // * Verify basic elements on theme display settings screen
			        await expect(ThemeDisplaySettingsScreen.backButton).toBeVisible();
			        await expect(ThemeDisplaySettingsScreen.denimOption).toBeVisible();
			        await expect(ThemeDisplaySettingsScreen.sapphireOption).toBeVisible();
			        await expect(ThemeDisplaySettingsScreen.quartzOption).toBeVisible();
			        await expect(ThemeDisplaySettingsScreen.indigoOption).toBeVisible();
			        await expect(ThemeDisplaySettingsScreen.onyxOption).toBeVisible();
			    \});
			
			    it('MM-T5111_2 - should be able to select a theme and save by tapping navigation back button', async () => \{
			        // # Tap on a sapphire option and tap on back button
			        await ThemeDisplaySettingsScreen.sapphireOption.tap();
			        await ThemeDisplaySettingsScreen.back();
			
			        // * Verify on display settings screen and sapphire is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.themeOptionInfo).toHaveText('Sapphire');
			
			        // # Go back to theme display settings screen
			        await ThemeDisplaySettingsScreen.open();
			
			        // * Verify sapphire option is selected
			        await expect(ThemeDisplaySettingsScreen.sapphireOptionSelected).toBeVisible();
			
			        // # Tap on denim option and tap on back button
			        await ThemeDisplaySettingsScreen.denimOption.tap();
			        await ThemeDisplaySettingsScreen.back();
			
			        // * Verify on display settings screen and denim is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.themeOptionInfo).toHaveText('Denim');
			
			        // # Go back to theme display settings screen
			        await ThemeDisplaySettingsScreen.open();
			
			        // * Verify denim option is selected
			        await expect(ThemeDisplaySettingsScreen.denimOptionSelected).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\theme_display_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\timezone_display_settings.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    DisplaySettingsScreen,
			    HomeScreen,
			    LoginScreen,
			    SelectTimezoneScreen,
			    ServerScreen,
			    SettingsScreen,
			    TimezoneDisplaySettingsScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Account - Settings - Timezone Display Settings', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server, open account screen, open settings screen, open display settings screen, and go to timezone display settings
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			        await SettingsScreen.open();
			        await DisplaySettingsScreen.open();
			        await TimezoneDisplaySettingsScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on timezone display settings screen
			        await TimezoneDisplaySettingsScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await TimezoneDisplaySettingsScreen.back();
			        await DisplaySettingsScreen.back();
			        await SettingsScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5113_1 - should match elements on timezone display settings screen', async () => \{
			        // * Verify basic elements on timezone display settings screen
			        await expect(TimezoneDisplaySettingsScreen.backButton).toBeVisible();
			        await expect(TimezoneDisplaySettingsScreen.automaticOptionToggledOn).toBeVisible();
			    \});
			
			    it('MM-T5113_2 - should be able to select a timezone and save by tapping navigation back button', async () => \{
			        // # Toggle automatic option off and tap on manual option
			        await TimezoneDisplaySettingsScreen.toggleAutomaticOptionOff();
			        await TimezoneDisplaySettingsScreen.manualOption.tap();
			
			        // * Verify on select timezone screen
			        await SelectTimezoneScreen.toBeVisible();
			
			        // # Search for a timezone and tap on a timezone
			        await SelectTimezoneScreen.searchInput.replaceText('Africa');
			        await SelectTimezoneScreen.getNonSelectedTimezoneRow('Africa/Nairobi').tap();
			
			        // * Verify on timezone display settings screen and timezone is set
			        await TimezoneDisplaySettingsScreen.toBeVisible();
			        await expect(TimezoneDisplaySettingsScreen.manualOptionInfo).toHaveText('Nairobi');
			
			        // # Tap on back button
			        await TimezoneDisplaySettingsScreen.back();
			
			        // * Verify on display settings screen and manual is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.timezoneOptionInfo).toHaveText('Manual');
			
			        // # Go back to timezone display settings screen, toggle automatic option on and tap on back button
			        await TimezoneDisplaySettingsScreen.open();
			        await TimezoneDisplaySettingsScreen.toggleAutomaticOptionOn();
			        await TimezoneDisplaySettingsScreen.back();
			
			        // * Verify on display settings and auto is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.timezoneOptionInfo).toHaveText('Auto');
			
			        // # Go back to timezone display settings screen
			        await TimezoneDisplaySettingsScreen.open();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\account\\timezone_display_settings.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\at_mention.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - At-Mention', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			    let testOtherUser: any;
			    let userAtMentionAutocomplete: any;
			    let otherUserAtMentionAutocomplete: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			        (\{atMentionItem: userAtMentionAutocomplete\} = Autocomplete.getAtMentionItem(testUser.id));
			
			        (\{user: testOtherUser\} = await User.apiCreateUser(siteOneUrl));
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser.id, testTeam.id);
			        await Channel.apiAddUserToChannel(siteOneUrl, testOtherUser.id, testChannel.id);
			        (\{atMentionItem: otherUserAtMentionAutocomplete\} = Autocomplete.getAtMentionItem(testOtherUser.id));
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			    \});
			
			    beforeEach(async () => \{
			        // # Clear post input
			        await ChannelScreen.postInput.clearText();
			
			        // * Verify autocomplete is not displayed
			        await Autocomplete.toBeVisible(false);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4878_1 - should suggest user based on username', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in username
			        await ChannelScreen.postInput.typeText(testUser.username);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_2 - should suggest user based on nickname', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in nickname
			        await ChannelScreen.postInput.typeText(testUser.nickname);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_3 - should suggest user based on first name', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in first name
			        await ChannelScreen.postInput.typeText(testUser.first_name);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_4 - should suggest user based on last name', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in last name
			        await ChannelScreen.postInput.typeText(testUser.last_name);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_5 - should suggest user based on lowercase first name', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in lowercase first name
			        await ChannelScreen.postInput.typeText(testUser.first_name.toLowerCase());
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_6 - should suggest user based on lowercase last name', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in lowercase last name
			        await ChannelScreen.postInput.typeText(testUser.last_name.toLowerCase());
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_7 - should suggest user based on full name with space', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in full name with space
			        await ChannelScreen.postInput.typeText(\`\$\{testUser.first_name\} \$\{testUser.last_name\}\`);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_8 - should suggest user based on partial full name with space', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in partial full name with space
			        await ChannelScreen.postInput.typeText(\`\$\{testUser.first_name\} \$\{testUser.last_name.substring(0, testUser.last_name.length - 6)\}\`);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_9 - should stop suggesting user after full name with trailing space', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in full name
			        await ChannelScreen.postInput.typeText(\`\$\{testUser.first_name\} \$\{testUser.last_name\}\`);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(userAtMentionAutocomplete).toBeVisible();
			
			        // # Type in trailing space
			        await ChannelScreen.postInput.typeText(' ');
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify at-mention autocomplete does not contain associated user suggestion
			        await expect(userAtMentionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4878_10 - should stop suggesting user when keyword is not associated with any user', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in keyword not associated with any user
			        await ChannelScreen.postInput.typeText(getRandomId());
			
			        // * Verify at-mention autocomplete does not contain associated user suggestion
			        await expect(userAtMentionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4878_11 - should be able to select at-mention multiple times', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			        await ChannelScreen.postInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in username and tap on user at-mention autocomplete
			        await ChannelScreen.postInput.typeText(testUser.username);
			        await userAtMentionAutocomplete.tap();
			
			        // * Verify at-mention list disappears
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			
			        // # Type in "@" again to re-activate at-mention list
			        await ChannelScreen.postInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			    \});
			
			    it('MM-T4878_12 - should not be able to autocomplete deactivated user', async () => \{
			        // # Deactivate another channel member user and type in "@" to activate at-mention autocomplete
			        await User.apiDeactivateUser(siteOneUrl, testOtherUser.id);
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in username of deactivated user
			        await ChannelScreen.postInput.typeText(testOtherUser.username);
			
			        // * Verify at-mention autocomplete does not contain associated user suggestion
			        await expect(otherUserAtMentionAutocomplete).not.toBeVisible();
			
			        // # Reactivate user, clear post input, and type in "@" to activate at-mention list
			        await User.apiUpdateUserActiveStatus(siteOneUrl, testOtherUser.id, true);
			        await ChannelScreen.postInput.clearText();
			        await Autocomplete.toBeVisible(false);
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in username of reactivated user
			        await ChannelScreen.postInput.typeText(testOtherUser.username);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        await expect(otherUserAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_13 - should be able to autocomplete out of channel user', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        const \{user: outOfChannelUser\} = await User.apiCreateUser(siteOneUrl);
			        await Team.apiAddUserToTeam(siteOneUrl, outOfChannelUser.id, testTeam.id);
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in username of out of channel user
			        await ChannelScreen.postInput.typeText(outOfChannelUser.username);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        const \{atMentionItem: outOfChannelUserAtMentionAutocomplete\} = Autocomplete.getAtMentionItem(outOfChannelUser.id);
			        await expect(outOfChannelUserAtMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4878_14 - should include current user in autocomplete', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in username of current user
			        await ChannelScreen.postInput.typeText(testUser.username);
			
			        // * Verify at-mention autocomplete contains current user
			        const \{atMentionItemUserDisplayName, atMentionItemCurrentUserIndicator, atMentionItemUsername\} = Autocomplete.getAtMentionItem(testUser.id);
			        await expect(atMentionItemUserDisplayName).toHaveText(\`\$\{testUser.first_name\} \$\{testUser.last_name\}\`);
			        await expect(atMentionItemCurrentUserIndicator).toHaveText(' (you)');
			        await expect(atMentionItemUsername).toHaveText(\` @\$\{testUser.username\}\`);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\at_mention.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(14)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\channel_mention.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			    Team,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Channel Mention', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testOtherChannel: any;
			    let testTeam: any;
			    let channelMentionAutocomplete: any;
			    let otherChannelMentionAutocomplete: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        (\{channelMentionItem: channelMentionAutocomplete\} = Autocomplete.getChannelMentionItem(testChannel.name));
			
			        (\{channel: testOtherChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\}));
			        await Channel.apiAddUserToChannel(siteOneUrl, user.id, testOtherChannel.id);
			        (\{channelMentionItem: otherChannelMentionAutocomplete\} = Autocomplete.getChannelMentionItem(testOtherChannel.name));
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			    \});
			
			    beforeEach(async () => \{
			        // # Clear post input
			        await ChannelScreen.postInput.clearText();
			
			        // * Verify autocomplete is not displayed
			        await Autocomplete.toBeVisible(false);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4879_1 - should suggest channel based on channel name', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel name
			        await ChannelScreen.postInput.typeText(testChannel.name);
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        await expect(channelMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4879_2 - should suggest channel based on channel display name', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel display name
			        await ChannelScreen.postInput.typeText(testChannel.display_name);
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        await expect(channelMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4879_3 - should suggest channel based on lowercase channel display name', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in lowercase channel display name
			        await ChannelScreen.postInput.typeText(testChannel.display_name.toLowerCase());
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        await expect(channelMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4879_4 - should suggest channel based on partial channel display name', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in partial channel display name
			        await ChannelScreen.postInput.typeText(\`\$\{testChannel.display_name.substring(0, testChannel.display_name.length - 4)\}\`);
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        await expect(channelMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4879_5 - should stop suggesting channel after channel display name with trailing space', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel display name
			        await ChannelScreen.postInput.typeText(testChannel.display_name);
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        await expect(channelMentionAutocomplete).toBeVisible();
			
			        // # Type in trailing space
			        await ChannelScreen.postInput.typeText(' ');
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify channel mention autocomplete does not contain associated channel suggestion
			        await expect(channelMentionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4879_6 - should stop suggesting channel when keyword is not associated with any channel', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in keyword not associated with any channel
			        await ChannelScreen.postInput.typeText(getRandomId());
			
			        // * Verify channel mention autocomplete does not contain associated channel suggestion
			        await expect(channelMentionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4879_7 - should be able to select channel mention multiple times', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			        await ChannelScreen.postInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel name and tap on channel mention autocomplete
			        await ChannelScreen.postInput.typeText(testChannel.name);
			        await channelMentionAutocomplete.tap();
			
			        // * Verify channel mention list disappears
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			
			        // # Type in "~" again to re-activate channel mention list
			        await ChannelScreen.postInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			    \});
			
			    it('MM-T4879_8 - should be able to autocomplete archived channel', async () => \{
			        // # Archive another team channel and type in "~" to activate channel mention autocomplete
			        await Channel.apiDeleteChannel(siteOneUrl, testOtherChannel.id);
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel name of archived channel
			        await ChannelScreen.postInput.typeText(testOtherChannel.name);
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        await expect(otherChannelMentionAutocomplete).toBeVisible();
			
			        // # Unarchive channel, clear post input, and type in "~" to activate channel mention list
			        await Channel.apiRestoreChannel(siteOneUrl, testOtherChannel.id);
			        await ChannelScreen.postInput.clearText();
			        await Autocomplete.toBeVisible(false);
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel name of unarchived channel
			        await ChannelScreen.postInput.typeText(testOtherChannel.name);
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        await expect(otherChannelMentionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4879_9 - should not be able to autocomplete out of team channel', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        const \{team: otherTeam\} = await Team.apiCreateTeam(siteOneUrl);
			        const \{channel: outOfTeamChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: otherTeam.id\});
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel name of out of team channel
			        await ChannelScreen.postInput.typeText(outOfTeamChannel.name);
			
			        // * Verify channel mention autocomplete does not contain associated channel suggestion
			        const \{channelMentionItem: outOfTeamChannelChannelMentionAutocomplete\} = Autocomplete.getChannelMentionItem(outOfTeamChannel.name);
			        await expect(outOfTeamChannelChannelMentionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4879_10 - should include current channel in autocomplete', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel name of current channel
			        await ChannelScreen.postInput.typeText(testChannel.name);
			
			        // * Verify channel mention autocomplete contains current channel
			        const \{channelMentionItemChannelDisplayName\} = Autocomplete.getChannelMentionItem(testChannel.name);
			        await expect(channelMentionItemChannelDisplayName).toHaveText(\`\$\{testChannel.display_name\} ~\$\{testChannel.name\}\`);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\channel_mention.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(10)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\channel_post_draft.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Channel Post Draft', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, channel.name);
			    \});
			
			    beforeEach(async () => \{
			        // # Clear post input
			        await ChannelScreen.postInput.clearText();
			
			        // * Verify autocomplete is not displayed
			        await Autocomplete.toBeVisible(false);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4882_1 - should render at-mention autocomplete in post input', async () => \{
			        // * Verify at-mention list is not displayed
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			    \});
			
			    it('MM-T4882_2 - should render channel mention autocomplete in post input', async () => \{
			        // * Verify channel mention list is not displayed
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			    \});
			
			    it('MM-T4882_3 - should render emoji suggestion autocomplete in post input', async () => \{
			        // * Verify emoji suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in ":" followed by 2 characters to activate emoji suggestion autocomplete
			        await ChannelScreen.postInput.typeText(':sm');
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			    \});
			
			    it('MM-T4882_4 - should render slash suggestion autocomplete in post input', async () => \{
			        // * Verify slash suggestion list is not displayed
			        await expect(Autocomplete.flatSlashSuggestionList).not.toBeVisible();
			
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText('/');
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\channel_post_draft.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\create_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    CreateOrEditChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Create Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open create channel screen
			        await CreateOrEditChannelScreen.openCreateChannel();
			    \});
			
			    beforeEach(async () => \{
			        // # Clear header input
			        await CreateOrEditChannelScreen.headerInput.clearText();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await CreateOrEditChannelScreen.close();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4904_1 - should render at-mention autocomplete in header input', async () => \{
			        // * Verify at-mention list is not displayed
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			
			        // # Type in "@" to activate at-mention autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await waitFor(Autocomplete.sectionAtMentionList).toBeVisible().withTimeout(timeouts.ONE_SEC);
			    \});
			
			    it('MM-T4904_2 - should render channel mention autocomplete in header input', async () => \{
			        // * Verify channel mention list is not displayed
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			
			        // # Type in "~" to activate channel mention autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			    \});
			
			    it('MM-T4904_3 - should render emoji suggestion autocomplete in header input', async () => \{
			        // * Verify emoji suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in ":" followed by 2 characters to activate emoji suggestion autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText(':sm');
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			    \});
			
			    it('MM-T4904_4 - should not render slash suggestion autocomplete in header input', async () => \{
			        // * Verify slash suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in "/" to activate slash suggestion autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('/');
			
			        // * Verify slash suggestion list is still not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\create_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\edit_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelInfoScreen,
			    ChannelListScreen,
			    ChannelScreen,
			    CreateOrEditChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Edit Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen, open channel info screen, and open edit channel screen
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await ChannelInfoScreen.open();
			        await CreateOrEditChannelScreen.openEditChannel();
			    \});
			
			    beforeEach(async () => \{
			        // # Clear header input
			        await CreateOrEditChannelScreen.headerInput.clearText();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await CreateOrEditChannelScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4885_1 - should render at-mention autocomplete in header input', async () => \{
			        // * Verify at-mention list is not displayed
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			
			        // # Type in "@" to activate at-mention autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await waitFor(Autocomplete.sectionAtMentionList).toBeVisible().withTimeout(timeouts.ONE_SEC);
			    \});
			
			    it('MM-T4885_2 - should render channel mention autocomplete in header input', async () => \{
			        // * Verify channel mention list is not displayed
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			
			        // # Type in "~" to activate channel mention autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			    \});
			
			    it('MM-T4885_3 - should render emoji suggestion autocomplete in header input', async () => \{
			        // * Verify emoji suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in ":" followed by 2 characters to activate emoji suggestion autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText(':sm');
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			    \});
			
			    it('MM-T4885_4 - should not render slash suggestion autocomplete in header input', async () => \{
			        // * Verify slash suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in "/" to activate slash suggestion autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('/');
			
			        // * Verify slash suggestion list is still not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\edit_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\edit_channel_header.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    CreateOrEditChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Edit Channel Header', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen and open edit channel header screen
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await CreateOrEditChannelScreen.openEditChannelHeader();
			    \});
			
			    beforeEach(async () => \{
			        // # Clear header input
			        await CreateOrEditChannelScreen.headerInput.clearText();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await CreateOrEditChannelScreen.close();
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4884_1 - should render at-mention autocomplete in header input', async () => \{
			        // * Verify at-mention list is not displayed
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			
			        // # Type in "@" to activate at-mention autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await waitFor(Autocomplete.sectionAtMentionList).toExist().withTimeout(timeouts.ONE_SEC);
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			    \});
			
			    it('MM-T4884_2 - should render channel mention autocomplete in header input', async () => \{
			        // * Verify channel mention list is not displayed
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			
			        // # Type in "~" to activate channel mention autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			    \});
			
			    it('MM-T4884_3 - should render emoji suggestion autocomplete in header input', async () => \{
			        // * Verify emoji suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in ":" followed by 2 characters to activate emoji suggestion autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText(':sm');
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			    \});
			
			    it('MM-T4884_4 - should not render slash suggestion autocomplete in header input', async () => \{
			        // * Verify slash suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in "/" to activate slash suggestion autocomplete
			        await CreateOrEditChannelScreen.headerInput.typeText('/');
			
			        // * Verify slash suggestion list is still not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\edit_channel_header.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\edit_post.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    EditPostScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Edit Post', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen, post a message, open post options for message, and open edit post screen
			        const message = \`Messsage \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, channel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await EditPostScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // # Clear message input
			        await EditPostScreen.messageInput.clearText();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await EditPostScreen.close();
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4883_1 - should render at-mention autocomplete in message input', async () => \{
			        // * Verify at-mention list is not displayed
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			
			        // # Type in "@" to activate at-mention autocomplete
			        await EditPostScreen.messageInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			    \});
			
			    it('MM-T4883_2 - should render channel mention autocomplete in message input', async () => \{
			        // * Verify channel mention list is not displayed
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			
			        // # Type in "~" to activate channel mention autocomplete
			        await EditPostScreen.messageInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			    \});
			
			    it('MM-T4883_3 - should render emoji suggestion autocomplete in message input', async () => \{
			        // * Verify emoji suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in ":" followed by 2 characters to activate emoji suggestion autocomplete
			        await EditPostScreen.messageInput.typeText(':sm');
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			    \});
			
			    it('MM-T4883_4 - should not render slash suggestion autocomplete in message input', async () => \{
			        // * Verify slash suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in "/" to activate slash suggestion autocomplete
			        await EditPostScreen.messageInput.typeText('/');
			
			        // * Verify slash suggestion list is still not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\edit_post.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\emoji_suggestion.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Emoji Suggestion', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const emojiName = 'fox_face';
			    const emojiNameFirst2Chars = emojiName.substring(0, 2);
			    const emojiName3rdToLastChars = emojiName.substring(2);
			    let emojiSuggestionAutocomplete: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			
			        (\{emojiSuggestionItem: emojiSuggestionAutocomplete\} = Autocomplete.getEmojiSuggestionItem(emojiName));
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, channel.name);
			    \});
			
			    beforeEach(async () => \{
			        // # Clear post input
			        await ChannelScreen.postInput.clearText();
			
			        // * Verify autocomplete is not displayed
			        await Autocomplete.toBeVisible(false);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4880_1 - should suggest emoji based on emoji name', async () => \{
			        // # Type in ":" then first 2 characters of emoji name to activate emoji suggestion autocomplete
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars\}\`);
			        await Autocomplete.toBeVisible();
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			
			        // # Type in 3rd to last characters of emoji name
			        await ChannelScreen.postInput.typeText(emojiName3rdToLastChars);
			
			        // * Verify emoji suggestion autocomplete contains associated emoji suggestion
			        await expect(emojiSuggestionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4880_2 - should suggest emoji based on uppercase emoji name', async () => \{
			        // # Type in ":" then uppercase first 2 characters of emoji name to activate emoji suggestion autocomplete
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars.toUpperCase()\}\`);
			        await Autocomplete.toBeVisible();
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			
			        // # Type in uppercase 3rd to last characters of emoji name
			        await ChannelScreen.postInput.typeText(emojiName3rdToLastChars.toUpperCase());
			
			        // * Verify emoji suggestion autocomplete contains associated emoji suggestion
			        await expect(emojiSuggestionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4880_3 - should suggest emoji based on partial emoji name', async () => \{
			        // # Type in ":" then first 2 characters of emoji name to activate emoji suggestion autocomplete
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars\}\`);
			        await Autocomplete.toBeVisible();
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			
			        // # Type in partial emoji name
			        await ChannelScreen.postInput.typeText(\`\$\{emojiName.substring(2, 4)\}\`);
			
			        // * Verify emoji suggestion autocomplete contains associated emoji suggestion
			        await expect(emojiSuggestionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4880_4 - should stop suggesting emoji after emoji name with trailing space', async () => \{
			        // # Type in ":" then first 2 characters of emoji name to activate emoji suggestion autocomplete
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars\}\`);
			        await Autocomplete.toBeVisible();
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			
			        // # Type in 3rd to last characters of emoji name
			        await ChannelScreen.postInput.typeText(emojiName3rdToLastChars);
			
			        // * Verify emoji suggestion autocomplete contains associated emoji suggestion
			        await expect(emojiSuggestionAutocomplete).toBeVisible();
			
			        // # Type in trailing space
			        await ChannelScreen.postInput.typeText(' ');
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify emoji suggestion autocomplete does not contain associated emoji suggestion
			        await expect(emojiSuggestionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4880_5 - should stop suggesting emoji when keyword is not associated with any emoji', async () => \{
			        // # Type in ":" then first 2 characters of emoji name to activate emoji suggestion autocomplete
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars\}\`);
			        await Autocomplete.toBeVisible();
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			
			        // # Type in keyword not associated with any emoji
			        await ChannelScreen.postInput.typeText(getRandomId());
			
			        // * Verify emoji suggestion autocomplete does not contain associated emoji suggestion
			        await expect(emojiSuggestionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4880_6 - should be able to select emoji suggestion multiple times', async () => \{
			        // # Type in ":" then first 2 characters of emoji name to activate emoji suggestion autocomplete
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars\}\`);
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			
			        // # Type in 3rd to last characters of emoji name and tap on emoji suggestion autocomplete
			        await ChannelScreen.postInput.typeText(emojiName3rdToLastChars);
			        await emojiSuggestionAutocomplete.tap();
			
			        // * Verify emoji suggestion list disappears
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in ":" then first 2 characters of emoji name again to re-activate emoji suggestion list
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars\}\`);
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\emoji_suggestion.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\slash_suggestion.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Slash Suggestion', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const slashCommand = 'away';
			    let slashSuggestionAutocomplete: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			
			        (\{slashSuggestionItem: slashSuggestionAutocomplete\} = Autocomplete.getSlashSuggestionItem(slashCommand));
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, channel.name);
			    \});
			
			    beforeEach(async () => \{
			        // # Clear post input
			        await ChannelScreen.postInput.clearText();
			
			        // * Verify autocomplete is not displayed
			        await Autocomplete.toBeVisible(false);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4881_1 - should suggest slash command based on slash command name', async () => \{
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText('/');
			        await Autocomplete.toBeVisible();
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			
			        // # Type in slash command name
			        await ChannelScreen.postInput.typeText(slashCommand);
			
			        // * Verify slash suggestion autocomplete contains associated slash command suggestion
			        await expect(slashSuggestionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4881_2 - should suggest slash command based on partial slash command name', async () => \{
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText('/');
			        await Autocomplete.toBeVisible();
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			
			        // # Type in partial slash command name
			        await ChannelScreen.postInput.typeText(\`\$\{slashCommand.substring(0, slashCommand.length - 2)\}\`);
			
			        // * Verify slash suggestion autocomplete contains associated slash command suggestion
			        await expect(slashSuggestionAutocomplete).toBeVisible();
			    \});
			
			    it('MM-T4881_3 - should stop suggesting slash command after uppercase slash command name', async () => \{
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText('/');
			        await Autocomplete.toBeVisible();
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			
			        // # Type in uppercase slash command name
			        await ChannelScreen.postInput.typeText(slashCommand.toUpperCase());
			
			        // * Verify slash suggestion autocomplete does not contain associated slash command suggestion
			        await expect(slashSuggestionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4881_4 - should stop suggesting slash command after slash command name with trailing space', async () => \{
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText('/');
			        await Autocomplete.toBeVisible();
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			
			        // # Type in slash command name
			        await ChannelScreen.postInput.typeText(slashCommand);
			
			        // * Verify slash suggestion autocomplete contains associated slash command suggestion
			        await expect(slashSuggestionAutocomplete).toBeVisible();
			
			        // # Type in trailing space
			        await ChannelScreen.postInput.typeText(' ');
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify slash suggestion autocomplete does not contain associated slash command suggestion
			        await expect(slashSuggestionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4881_5 - should stop suggesting slash command when keyword is not associated with any slash command', async () => \{
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText('/');
			        await Autocomplete.toBeVisible();
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			
			        // # Type in keyword not associated with any slash command
			        await ChannelScreen.postInput.typeText(getRandomId());
			
			        // * Verify slash suggestion autocomplete does not contain associated slash command suggestion
			        await expect(slashSuggestionAutocomplete).not.toBeVisible();
			    \});
			
			    it('MM-T4881_6 - should not be able to select slash suggestion multiple times', async () => \{
			        // # Type in "/" to activate slash suggestion autocomplete
			        await expect(Autocomplete.flatSlashSuggestionList).not.toBeVisible();
			        await ChannelScreen.postInput.typeText('/');
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			
			        // # Type in slash command name and tap on slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText(slashCommand);
			        await slashSuggestionAutocomplete.tap();
			
			        // * Verify slash suggestion list disappears
			        await expect(Autocomplete.flatSlashSuggestionList).not.toBeVisible();
			
			        // # Type in "/" again to re-activate slash suggestion list
			        await ChannelScreen.postInput.typeText('/');
			
			        // * Verify slash suggestion list is not displayed
			        await expect(Autocomplete.flatSlashSuggestionList).not.toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\slash_suggestion.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\thread_post_draft.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Autocomplete - Thread Post Draft', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen, post a message, and tap on post to open reply thread
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await ChannelScreen.postMessage(message);
			        await element(by.text(message)).tap();
			    \});
			
			    beforeEach(async () => \{
			        // # Clear post input
			        await ThreadScreen.postInput.clearText();
			
			        // * Verify autocomplete is not displayed
			        await Autocomplete.toBeVisible(false);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4905_1 - should render at-mention autocomplete in post input', async () => \{
			        // * Verify at-mention list is not displayed
			        await expect(Autocomplete.sectionAtMentionList).not.toBeVisible();
			
			        // # Type in "@" to activate at-mention autocomplete
			        await ThreadScreen.postInput.typeText('@');
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			    \});
			
			    it('MM-T4905_2 - should render channel mention autocomplete in post input', async () => \{
			        // * Verify channel mention list is not displayed
			        await expect(Autocomplete.sectionChannelMentionList).not.toBeVisible();
			
			        // # Type in "~" to activate channel mention autocomplete
			        await ThreadScreen.postInput.typeText('~');
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			    \});
			
			    it('MM-T4905_3 - should render emoji suggestion autocomplete in post input', async () => \{
			        // * Verify emoji suggestion list is not displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).not.toBeVisible();
			
			        // # Type in ":" followed by 2 characters to activate emoji suggestion autocomplete
			        await ThreadScreen.postInput.typeText(':sm');
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			    \});
			
			    it('MM-T4905_4 - should render slash suggestion autocomplete in post input', async () => \{
			        // * Verify slash suggestion list is not displayed
			        await expect(Autocomplete.flatSlashSuggestionList).not.toBeVisible();
			
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ThreadScreen.postInput.typeText('/');
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\autocomplete\\thread_post_draft.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\archive_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    BrowseChannelsScreen,
			    ChannelDropdownMenuScreen,
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Archive Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{team, user\} = await Setup.apiInit(siteOneUrl);
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4932_1 - should be able to archive a public channel and confirm', async () => \{
			        // # Open a public channel screen, open channel info screen, and tap on archive channel option and confirm
			        const \{channel: publicChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'O', teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, publicChannel.id);
			        await wait(timeouts.TWO_SEC);
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, publicChannel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.archivePublicChannel(\{confirm: true\});
			
			        // * Verify on channel screen and post draft archived message is displayed
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.postDraftArchived).toBeVisible();
			        await expect(element(by.text('You are viewing an archived channel. New messages cannot be posted.'))).toBeVisible();
			
			        // # Tap on close channel button, open browse channels screen, tap on channel dropdown, tap on archived channels menu item, and search for the archived public channel
			        await ChannelScreen.postDraftArchivedCloseChannelButton.tap();
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.channelDropdownTextPublic.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelDropdownMenuScreen.archivedChannelsItem.tap();
			        await BrowseChannelsScreen.searchInput.replaceText(publicChannel.name);
			
			        // * Verify search returns the archived public channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(BrowseChannelsScreen.getChannelItemDisplayName(publicChannel.name)).toHaveText(publicChannel.display_name);
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			
			    it('MM-T4932_2 - should be able to archive a public channel and cancel', async () => \{
			        // # Open a public channel screen, open channel info screen, and tap on archive channel option and cancel
			        const \{channel: publicChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'O', teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, publicChannel.id);
			        await wait(timeouts.TWO_SEC);
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, publicChannel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.archivePublicChannel(\{confirm: false\});
			
			        // * Verify still on channel info screen
			        await ChannelInfoScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4932_3 - should be able to archive a private channel and confirm', async () => \{
			        // # Open a private channel screen, open channel info screen, and tap on archive channel option and confirm
			        const \{channel: privateChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'P', teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, privateChannel.id);
			        await wait(timeouts.TWO_SEC);
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, privateChannel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.archivePrivateChannel(\{confirm: true\});
			
			        // * Verify on channel screen and post draft archived message is displayed
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.postDraftArchived).toBeVisible();
			        await expect(element(by.text('You are viewing an archived channel. New messages cannot be posted.'))).toBeVisible();
			
			        // # Tap on close channel button, open browse channels screen, tap on channel dropdown, tap on archived channels menu item, and search for the archived private channel
			        await ChannelScreen.postDraftArchivedCloseChannelButton.tap();
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.channelDropdownTextPublic.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelDropdownMenuScreen.archivedChannelsItem.tap();
			        await BrowseChannelsScreen.searchInput.replaceText(privateChannel.name);
			
			        // * Verify search returns the archived private channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(BrowseChannelsScreen.getChannelItemDisplayName(privateChannel.name)).toHaveText(privateChannel.display_name);
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\archive_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\browse_channels.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    BrowseChannelsScreen,
			    ChannelDropdownMenuScreen,
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Browse Channels', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{team, user\} = await Setup.apiInit(siteOneUrl);
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4729_1 - should match elements on browse channels screen', async () => \{
			        // # Open browse channels screen
			        await BrowseChannelsScreen.open();
			
			        // * Verify basic elements on browse channels screen
			        await expect(BrowseChannelsScreen.closeButton).toBeVisible();
			        await expect(BrowseChannelsScreen.searchInput).toBeVisible();
			        await expect(BrowseChannelsScreen.flatChannelList).toBeVisible();
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			
			    it('MM-T4729_2 - should be able to browse and join an unjoined public channel', async () => \{
			        // # As admin, create a new public channel so that user can join
			        const \{channel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			
			        // * Verify new public channel does not appear on channel list screen
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, channel.display_name)).not.toExist();
			
			        // # Open browse channels screen and search for the new public channel name to join
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.searchInput.replaceText(channel.name);
			
			        // * Verify search returns the new public channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(BrowseChannelsScreen.getChannelItemDisplayName(channel.name)).toHaveText(channel.display_name);
			
			        // # Tap on the new public channel item
			        await BrowseChannelsScreen.getChannelItem(channel.name).multiTap(2);
			
			        // * Verify on newly joined public channel screen
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(channel.display_name);
			        await expect(ChannelScreen.introDisplayName).toHaveText(channel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			        await ChannelListScreen.toBeVisible();
			
			        // * Verify newly joined public channel is added to channel list
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, channel.name)).toBeVisible();
			    \});
			
			    it('MM-T4729_3 - should display empty search state for browse channels', async () => \{
			        // # Open browse channels screen and search for a non-existent channel
			        const searchTerm = 'blahblahblahblah';
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.searchInput.replaceText(searchTerm);
			
			        // * Verify empty search state for browse channels
			        await wait(timeouts.ONE_SEC);
			        await expect(element(by.text(\`No matches found for “\$\{searchTerm\}”\`))).toBeVisible();
			        await expect(element(by.text('Check the spelling or try another search.'))).toBeVisible();
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			
			    it('MM-T4729_4 - should not be able to browse direct and group message channels', async () => \{
			        // # Create direct and group message channels, open browse channels screen, and search for the direct message channel
			        const \{user: testOtherUser1\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'a'\});
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser1.id, testTeam.id);
			        const \{user: testOtherUser2\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'b'\});
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser2.id, testTeam.id);
			        await Channel.apiCreateDirectChannel(siteOneUrl, [testUser.id, testOtherUser1.id]);
			        await Channel.apiCreateGroupChannel(siteOneUrl, [testUser.id, testOtherUser1.id, testOtherUser2.id]);
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.searchInput.replaceText(testOtherUser1.username);
			
			        // * Verify empty search state for browse channels
			        await wait(timeouts.ONE_SEC);
			        await expect(element(by.text(\`No matches found for “\$\{testOtherUser1.username\}”\`))).toBeVisible();
			
			        // # Search for the group message channel
			        await BrowseChannelsScreen.searchInput.replaceText(testOtherUser2.username);
			
			        // * Verify empty search state for browse channels
			        await expect(element(by.text(\`No matches found for “\$\{testOtherUser2.username\}”\`))).toBeVisible();
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			
			    it('MM-T4729_5 - should be able to browse an archived channel', async () => \{
			        // # Archive a channel, open browse channels screen, tap on channel dropdown, tap on archived channels menu item, and search for the archived channel
			        const \{channel: archivedChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, archivedChannel.id);
			        await Channel.apiDeleteChannel(siteOneUrl, archivedChannel.id);
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.channelDropdownTextPublic.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelDropdownMenuScreen.archivedChannelsItem.tap();
			        await BrowseChannelsScreen.searchInput.replaceText(archivedChannel.name);
			
			        // * Verify search returns the archived channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(BrowseChannelsScreen.getChannelItemDisplayName(archivedChannel.name)).toHaveText(archivedChannel.display_name);
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			
			    it('MM-T4729_6 - should not be able to browse a joined public channel', async () => \{
			        // # Open browse channels screen and search for a joined public channel
			        const \{channel: joinedPublicChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'O', teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, joinedPublicChannel.id);
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.searchInput.replaceText(joinedPublicChannel.name);
			
			        // * Verify empty search state for browse channels
			        await wait(timeouts.ONE_SEC);
			        await expect(element(by.text(\`No matches found for “\$\{joinedPublicChannel.name\}”\`))).toBeVisible();
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			
			    it('MM-T4729_7 - should not be able to browse joined and unjoined private channel', async () => \{
			        // # As admin, create joined and unjoined private channels, open browse channels screen, and search for the joined private channel
			        const \{channel: joinedPrivateChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'P', teamId: testTeam.id\});
			        const \{channel: unjoinedPrivateChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'P', teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, joinedPrivateChannel.id);
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.searchInput.replaceText(joinedPrivateChannel.name);
			
			        // * Verify empty search state for browse channels
			        await expect(element(by.text(\`No matches found for “\$\{joinedPrivateChannel.name\}”\`))).toBeVisible();
			
			        // # Search for the unjoined private channel
			        await BrowseChannelsScreen.searchInput.replaceText(unjoinedPrivateChannel.name);
			
			        // * Verify empty search state for browse channels
			        await wait(timeouts.ONE_SEC);
			        await expect(element(by.text(\`No matches found for “\$\{unjoinedPrivateChannel.name\}”\`))).toBeVisible();
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\browse_channels.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\channel_info.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Channel Info', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4928_1 - should match elements on channel info screen', async () => \{
			        // # Open a channel screen and open channel info screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			
			        // * Verify basic elements on channel info screen
			        await expect(ChannelInfoScreen.closeButton).toBeVisible();
			        await expect(ChannelInfoScreen.publicPrivateTitleDisplayName).toHaveText(testChannel.display_name);
			        await expect(ChannelInfoScreen.publicPrivateTitlePurpose).toHaveText(\`Channel purpose: \$\{testChannel.display_name.toLowerCase()\}\`);
			        await expect(element(by.text(\`Channel header: \$\{testChannel.display_name.toLowerCase()\}\`))).toBeVisible();
			        await expect(ChannelInfoScreen.favoriteAction).toBeVisible();
			        await expect(ChannelInfoScreen.muteAction).toBeVisible();
			        await expect(ChannelInfoScreen.joinStartCallAction).toBeVisible();
			        await expect(ChannelInfoScreen.ignoreMentionsOptionToggledOff).toBeVisible();
			        await expect(ChannelInfoScreen.pinnedMessagesOption).toBeVisible();
			        await expect(ChannelInfoScreen.copyChannelLinkOption).toBeVisible();
			        await expect(ChannelInfoScreen.editChannelOption).toBeVisible();
			        await ChannelInfoScreen.scrollView.scrollTo('bottom');
			        await expect(ChannelInfoScreen.leaveChannelOption).toBeVisible();
			        await waitFor(ChannelInfoScreen.archiveChannelOption).toBeVisible().whileElement(by.id(ChannelInfoScreen.testID.scrollView)).scroll(50, 'down');
			        await expect(ChannelInfoScreen.archiveChannelOption).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4928_2 - should be able to view channel info by tapping intro channel info action', async () => \{
			        // # Open a channel screen and tap on intro channel info action
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.introChannelInfoAction.tap();
			
			        // * Verify on channel info screen
			        await ChannelInfoScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4928_3 - should be able to view channel info from channel quick actions', async () => \{
			        // # Open a channel screen, tap on channel quick actions button, and tap on channel info action
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.channelQuickActionsButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelScreen.channelInfoQuickAction.tap();
			
			        // * Verify on channel info screen
			        await ChannelInfoScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\channel_info.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\channel_list.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Setup,
			    Team,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    BrowseChannelsScreen,
			    ChannelScreen,
			    ChannelListScreen,
			    CreateDirectMessageScreen,
			    CreateOrEditChannelScreen,
			    FindChannelsScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Channel List', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const directMessagesCategory = 'direct_messages';
			    const offTopicChannelName = 'off-topic';
			    const townSquareChannelName = 'town-square';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4728_1 - should match elements on channel list screen', async () => \{
			        // * Verify basic elements on channel list screen
			        await expect(ChannelListScreen.serverIcon).toBeVisible();
			        await expect(ChannelListScreen.headerTeamDisplayName).toHaveText(testTeam.display_name);
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			        await expect(ChannelListScreen.headerPlusButton).toBeVisible();
			        await expect(ChannelListScreen.threadsButton).toBeVisible();
			        await expect(ChannelListScreen.getCategoryHeaderDisplayName(channelsCategory)).toHaveText('CHANNELS');
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, testChannel.name)).toHaveText(testChannel.display_name);
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, offTopicChannelName)).toHaveText('Off-Topic');
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, townSquareChannelName)).toHaveText('Town Square');
			        await expect(ChannelListScreen.getCategoryHeaderDisplayName(directMessagesCategory)).toHaveText('DIRECT MESSAGES');
			    \});
			
			    it('MM-T4728_2 - should be able to switch between channels', async () => \{
			        // # Tap on a first channel
			        await ChannelListScreen.getChannelItemDisplayName(channelsCategory, testChannel.name).tap();
			
			        // * Verify on first channel
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(testChannel.display_name);
			
			        // # Go back to channel list screen and tap on a second channel
			        await ChannelScreen.back();
			        await ChannelListScreen.toBeVisible();
			        await ChannelListScreen.getChannelItemDisplayName(channelsCategory, offTopicChannelName).tap();
			
			        // * Verify on second channel
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText('Off-Topic');
			
			        // # Go back to channel list screen and tap on a third channel
			        await ChannelScreen.back();
			        await ChannelListScreen.toBeVisible();
			        await ChannelListScreen.getChannelItemDisplayName(channelsCategory, townSquareChannelName).tap();
			
			        // * Verify on third channel
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText('Town Square');
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4728_3 - should be able to collapse and expand categories', async () => \{
			        // # Go to a channel to make it active and go back to channel list screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.back();
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Toggle channels category to collapse
			        await ChannelListScreen.getCategoryExpanded(channelsCategory).tap();
			
			        // * Verify category is collapsed and channels are not listed
			        await wait(timeouts.ONE_SEC);
			        await expect(ChannelListScreen.getCategoryCollapsed(channelsCategory)).toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, testChannel.name)).not.toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, offTopicChannelName)).not.toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, townSquareChannelName)).not.toBeVisible();
			
			        // # Toggle channels category to expand
			        await ChannelListScreen.getCategoryCollapsed(channelsCategory).tap();
			
			        // * Verify category is expanded and all channels are listed
			        await wait(timeouts.ONE_SEC);
			        await expect(ChannelListScreen.getCategoryExpanded(channelsCategory)).toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, testChannel.name)).toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, offTopicChannelName)).toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, townSquareChannelName)).toBeVisible();
			    \});
			
			    it('MM-T4728_4 - should be able to go to browse channels screen', async () => \{
			        // # Tap on plus menu button and tap on browse channels item
			        await ChannelListScreen.headerPlusButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelListScreen.browseChannelsItem.tap();
			
			        // * Verify on browse channels screen
			        await BrowseChannelsScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await BrowseChannelsScreen.close();
			    \});
			
			    it('MM-T4728_5 - should be able to go to create direct message screen', async () => \{
			        // # Tap on plus menu button and tap on open a direct message item
			        await ChannelListScreen.headerPlusButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelListScreen.openDirectMessageItem.tap();
			
			        // * Verify on create direct message screen
			        await CreateDirectMessageScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await CreateDirectMessageScreen.closeTutorial();
			        await CreateDirectMessageScreen.close();
			    \});
			
			    it('MM-T4728_6 - should be able to go to create channel screen', async () => \{
			        // # Tap on plus menu button and tap on create new channel item
			        await ChannelListScreen.headerPlusButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelListScreen.createNewChannelItem.tap();
			
			        // * Verify on create channel screen
			        await CreateOrEditChannelScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await CreateOrEditChannelScreen.close();
			    \});
			
			    it('MM-T4728_7 - should be able to go to global threads screen', async () => \{
			        // # Tap on threads button
			        await ChannelListScreen.threadsButton.tap();
			
			        // * Verify on global threads screen
			        await GlobalThreadsScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4728_8 - should be able to go to find channels screen', async () => \{
			        // # Tap on search field button
			        await ChannelListScreen.subheaderSearchFieldButton.tap();
			
			        // * Verify on find channels screen
			        await FindChannelsScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await FindChannelsScreen.close();
			    \});
			
			    it('MM-T4728_9 - should be able to switch between teams', async () => \{
			        // # As admin, create a second team and add user to the second team; as user, terminate app and relaunch app
			        const \{team: testTeamTwo\} = await Team.apiCreateTeam(siteOneUrl, \{prefix: 'a'\});
			        await Team.apiAddUserToTeam(siteOneUrl, testUser.id, testTeamTwo.id);
			        await device.reloadReactNative();
			
			        // * Verify on first team and team sidebar item is selected and has correct display name abbreviation
			        await expect(ChannelListScreen.headerTeamDisplayName).toHaveText(testTeam.display_name);
			        await expect(ChannelListScreen.getTeamItemSelected(testTeam.id)).toBeVisible();
			        await expect(ChannelListScreen.getTeamItemDisplayNameAbbreviation(testTeam.id)).toHaveText(testTeam.display_name.substring(0, 2).toUpperCase());
			
			        // # Tap on second team item from team sidebar
			        await ChannelListScreen.getTeamItemNotSelected(testTeamTwo.id).tap();
			
			        // * Verify on second team and team sidebar item is selected and has correct display name abbreviation
			        await expect(ChannelListScreen.headerTeamDisplayName).toHaveText(testTeamTwo.display_name);
			        await expect(ChannelListScreen.getTeamItemSelected(testTeamTwo.id)).toBeVisible();
			        await expect(ChannelListScreen.getTeamItemDisplayNameAbbreviation(testTeamTwo.id)).toHaveText(testTeamTwo.display_name.substring(0, 2).toUpperCase());
			
			        // # Tap back on first team item from team sidebar
			        await ChannelListScreen.getTeamItemNotSelected(testTeam.id).tap();
			
			        // * Verify on first team
			        await expect(ChannelListScreen.headerTeamDisplayName).toHaveText(testTeam.display_name);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\channel_list.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\channel_post_list.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isAndroid\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Channel Post List', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4773_1 - should match elements on channel screen', async () => \{
			        // # Open a channel screen
			        await ChannelScreen.open('channels', testChannel.name);
			        if (isAndroid()) \{
			            await ChannelScreen.back();
			            await ChannelScreen.open('channels', testChannel.name);
			        \}
			
			        // * Verify basic elements on channel screen
			        await expect(ChannelScreen.backButton).toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(testChannel.display_name);
			        await expect(ChannelScreen.introDisplayName).toHaveText(testChannel.display_name);
			        await expect(ChannelScreen.introSetHeaderAction).toBeVisible();
			        await expect(ChannelScreen.introChannelInfoAction).toBeVisible();
			        await expect(ChannelScreen.postList.getFlatList()).toBeVisible();
			        await expect(ChannelScreen.postDraft).toBeVisible();
			        await expect(ChannelScreen.postInput).toBeVisible();
			        await expect(ChannelScreen.atInputQuickAction).toBeVisible();
			        await expect(ChannelScreen.slashInputQuickAction).toBeVisible();
			        await expect(ChannelScreen.fileQuickAction).toBeVisible();
			        await expect(ChannelScreen.imageQuickAction).toBeVisible();
			        await expect(ChannelScreen.cameraQuickAction).toBeVisible();
			        await expect(ChannelScreen.sendButtonDisabled).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4773_2 - should be able to add a message to post list and delete a message from post list', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open('channels', testChannel.name);
			        if (isAndroid()) \{
			            await ChannelScreen.back();
			            await ChannelScreen.open('channels', testChannel.name);
			        \}
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for the message that was just posted, tap delete option and confirm
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify message is deleted from post list
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\channel_post_list.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\convert_to_private_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{siteOneUrl\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    CreateOrEditChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{getAdminAccount, getRandomId, timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Convert to Private Channel', () => \{
			    const siteOneDisplayName = 'Server 1';
			
			    beforeAll(async () => \{
			        // # Log in to server as admin
			        await ServerScreen.connectToServer(siteOneUrl, siteOneDisplayName);
			        await LoginScreen.login(getAdminAccount());
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await waitFor(ChannelListScreen.channelListScreen).toBeVisible().withTimeout(timeouts.TWO_MIN);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4972_1 - should be able to convert public channel to private and confirm', async () => \{
			        // # Create a public channel screen, open channel info screen, and tap on convert to private channel option and confirm
			        const channelDisplayName = \`Channel \$\{getRandomId()\}\`;
			        await CreateOrEditChannelScreen.openCreateChannel();
			        await CreateOrEditChannelScreen.displayNameInput.replaceText(channelDisplayName);
			        await CreateOrEditChannelScreen.createButton.tap();
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.convertToPrivateChannel(channelDisplayName, \{confirm: true\});
			
			        // * Verify on channel info screen and convert to private channel option does not exist
			        await ChannelInfoScreen.toBeVisible();
			        await expect(ChannelInfoScreen.convertPrivateOption).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4972_2 - should be able to convert public channel to private and cancel', async () => \{
			        // # Create a public channel screen, open channel info screen, and tap on convert to private channel option and cancel
			        const channelDisplayName = \`Channel \$\{getRandomId()\}\`;
			        await CreateOrEditChannelScreen.openCreateChannel();
			        await CreateOrEditChannelScreen.displayNameInput.replaceText(channelDisplayName);
			        await CreateOrEditChannelScreen.createButton.tap();
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.convertToPrivateChannel(channelDisplayName, \{confirm: false\});
			
			        // * Verify on channel info screen and convert to private channel option still exists
			        await ChannelInfoScreen.toBeVisible();
			        await expect(ChannelInfoScreen.convertPrivateOption).toExist();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\convert_to_private_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\create_channel_and_edit_channel_header.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    CreateOrEditChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isIos\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Create Channel and Edit Channel Header', () => \{
			    const serverOneDisplayName = 'Server 1';
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4731_1 - should match elements on create channel screen', async () => \{
			        // # Open create channel screen
			        await CreateOrEditChannelScreen.openCreateChannel();
			
			        // * Verify basic elements on create channel screen
			        await expect(CreateOrEditChannelScreen.closeButton).toBeVisible();
			        await expect(CreateOrEditChannelScreen.createButton).toBeVisible();
			        await expect(CreateOrEditChannelScreen.makePrivateToggledOff).toBeVisible();
			        await expect(CreateOrEditChannelScreen.makePrivateDescription).toHaveText('When a channel is set to private, only invited team members can access and participate in that channel');
			        await expect(CreateOrEditChannelScreen.displayNameInput).toBeVisible();
			        await expect(CreateOrEditChannelScreen.purposeInput).toBeVisible();
			        await expect(CreateOrEditChannelScreen.purposeDescription).toHaveText('Describe how this channel should be used.');
			        await expect(CreateOrEditChannelScreen.headerInput).toBeVisible();
			        await expect(CreateOrEditChannelScreen.headerDescription).toHaveText('Specify text to appear in the channel header beside the channel name. For example, include frequently used links by typing link text [Link Title](http://example.com).');
			
			        // # Go back to channel list screen
			        await CreateOrEditChannelScreen.close();
			    \});
			
			    it('MM-T4731_2 - should be able to create a public channel and edit the channel header', async () => \{
			        // # Open create channel screen, toggle make private off, fill out channel info, and tap create button
			        const suffix = getRandomId();
			        const displayName = \`Channel \$\{suffix\}\`;
			        const purpose = \`Purpose \$\{suffix\}\`;
			        const header = \`Header \$\{suffix\}\`;
			        await CreateOrEditChannelScreen.openCreateChannel();
			        await expect(CreateOrEditChannelScreen.makePrivateToggledOff).toBeVisible();
			        await CreateOrEditChannelScreen.displayNameInput.replaceText(displayName);
			        await CreateOrEditChannelScreen.purposeInput.replaceText(purpose);
			        await CreateOrEditChannelScreen.headerInput.replaceText(header);
			        await CreateOrEditChannelScreen.createButton.tap();
			
			        // * Verify on newly created public channel
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(displayName);
			        await expect(ChannelScreen.introDisplayName).toHaveText(displayName);
			
			        // # Tap on set header action to edit the channel header
			        await ChannelScreen.introSetHeaderAction.tap();
			
			        // * Verify channel header is correct
			        if (isIos()) \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveValue(header);
			        \} else \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveText(header);
			        \}
			
			        // # Edit the channel header, save, and re-open edit channel header screen
			        await CreateOrEditChannelScreen.headerInput.replaceText(\`\$\{header\} edit\`);
			        await CreateOrEditChannelScreen.saveButton.tap();
			        await CreateOrEditChannelScreen.openEditChannelHeader();
			
			        // * Verify channel header has new value
			        if (isIos()) \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveValue(\`\$\{header\} edit\`);
			        \} else \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveText(\`\$\{header\} edit\`);
			        \}
			
			        // # Go back to channel list screen
			        await CreateOrEditChannelScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4731_3 - should be able to create a private channel and edit the channel header', async () => \{
			        // # Open create channel screen, toggle make private on, fill out channel info, and tap create button
			        const suffix = getRandomId();
			        const displayName = \`Channel \$\{suffix\}\`;
			        const purpose = \`Purpose \$\{suffix\}\`;
			        const header = \`Header \$\{suffix\}\`;
			        await CreateOrEditChannelScreen.openCreateChannel();
			        await CreateOrEditChannelScreen.toggleMakePrivateOn();
			        await CreateOrEditChannelScreen.displayNameInput.replaceText(displayName);
			        await CreateOrEditChannelScreen.purposeInput.replaceText(purpose);
			        await CreateOrEditChannelScreen.headerInput.replaceText(header);
			        await CreateOrEditChannelScreen.createButton.tap();
			
			        // * Verify on newly created private channel
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(displayName);
			        await expect(ChannelScreen.introDisplayName).toHaveText(displayName);
			
			        // # Tap on set header action to edit the channel header
			        await ChannelScreen.introSetHeaderAction.tap();
			
			        // * Verify channel header is correct
			        if (isIos()) \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveValue(header);
			        \} else \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveText(header);
			        \}
			
			        // # Edit the channel header, save, and re-open edit channel header screen
			        await CreateOrEditChannelScreen.headerInput.replaceText(\`\$\{header\} edit\`);
			        await CreateOrEditChannelScreen.saveButton.tap();
			        await CreateOrEditChannelScreen.openEditChannelHeader();
			
			        // * Verify channel header has new value
			        if (isIos()) \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveValue(\`\$\{header\} edit\`);
			        \} else \{
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveText(\`\$\{header\} edit\`);
			        \}
			
			        // # Go back to channel list screen
			        await CreateOrEditChannelScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\create_channel_and_edit_channel_header.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\create_direct_message.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    CreateDirectMessageScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Channels - Create Direct Message', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const directMessagesCategory = 'direct_messages';
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{team, user\} = await Setup.apiInit(siteOneUrl);
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4730_1 - should match elements on create direct message screen', async () => \{
			        // # Open create direct message screen
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.closeTutorial();
			
			        // * Verify basic elements on create direct message screen
			        await expect(CreateDirectMessageScreen.closeButton).toBeVisible();
			        await expect(CreateDirectMessageScreen.searchInput).toBeVisible();
			        await expect(CreateDirectMessageScreen.sectionUserList).toBeVisible();
			
			        // # Go back to channel list screen
			        await CreateDirectMessageScreen.close();
			    \});
			
			    it('MM-T4730_2 - should be able to create a direct message', async () => \{
			        // # As admin, create a new user to open direct message with
			        const \{user: newUser\} = await User.apiCreateUser(siteOneUrl);
			        await Team.apiAddUserToTeam(siteOneUrl, newUser.id, testTeam.id);
			
			        // * Verify no direct message channel for the new user appears on channel list screen
			        const newUserDisplayName = newUser.username;
			        await expect(ChannelListScreen.getChannelItemDisplayName(directMessagesCategory, newUserDisplayName)).not.toBeVisible();
			
			        // # Open create direct message screen and search for the new user
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.searchInput.replaceText(newUserDisplayName);
			
			        // * Verify search returns the new user item
			        await expect(CreateDirectMessageScreen.getUserItemDisplayName(newUser.id)).toBeVisible();
			
			        // # Tap on the new user item
			        await CreateDirectMessageScreen.getUserItem(newUser.id).tap();
			
			        // * Verify the new user is selected
			        await expect(CreateDirectMessageScreen.getSelectedUserDisplayName(newUser.id)).toBeVisible();
			
			        // # Tap on start button
			        await CreateDirectMessageScreen.startButton.tap();
			
			        // * Verify on direct message channel screen for the new user
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(newUserDisplayName);
			        await expect(ChannelScreen.introDisplayName).toHaveText(newUserDisplayName);
			
			        // # Post a message and go back to channel list screen
			        await ChannelScreen.postMessage('test');
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await ChannelListScreen.toBeVisible();
			
			        // * Verify direct message channel for the new user is added to direct message list
			        const \{channel: directMessageChannel\} = await Channel.apiCreateDirectChannel(siteOneUrl, [testUser.id, newUser.id]);
			        await expect(ChannelListScreen.getChannelItemDisplayName(directMessagesCategory, directMessageChannel.name)).toHaveText(newUserDisplayName);
			    \});
			
			    it('MM-T4730_3 - should be able to create a group message', async () => \{
			        // # As admin, create two new users to open group message with
			        const \{user: firstNewUser\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'a'\});
			        await Team.apiAddUserToTeam(siteOneUrl, firstNewUser.id, testTeam.id);
			        const \{user: secondNewUser\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'b'\});
			        await Team.apiAddUserToTeam(siteOneUrl, secondNewUser.id, testTeam.id);
			
			        // * Verify no group message channel for the new users appears on channel list screen
			        const firstNewUserDisplayName = firstNewUser.username;
			        const secondNewUserDisplayName = secondNewUser.username;
			        const groupDisplayName = \`\$\{firstNewUserDisplayName\}, \$\{secondNewUserDisplayName\}\`;
			        await expect(element(by.text(groupDisplayName))).not.toBeVisible();
			
			        // # Open create direct message screen, search for the first new user and tap on the first new user item
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.searchInput.replaceText(firstNewUser.username);
			        await CreateDirectMessageScreen.getUserItem(firstNewUser.id).tap();
			
			        // * Verify the first new user is selected
			        await expect(CreateDirectMessageScreen.getSelectedUserDisplayName(firstNewUser.id)).toBeVisible();
			
			        // # Search for the second new user and tap on the second new user item
			        await CreateDirectMessageScreen.searchInput.replaceText(secondNewUser.username);
			        await CreateDirectMessageScreen.getUserItem(secondNewUser.id).tap();
			
			        // * Verify the second new user is selected
			        await expect(CreateDirectMessageScreen.getSelectedUserDisplayName(secondNewUser.id)).toBeVisible();
			
			        // # Tap on start button
			        await CreateDirectMessageScreen.startButton.tap();
			
			        // * Verify on group message channel screen for the other two new users
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(groupDisplayName);
			        await expect(ChannelScreen.introDisplayName).toHaveText(groupDisplayName);
			
			        // # Post a message and go back to channel list screen
			        await ChannelScreen.postMessage('test');
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await ChannelListScreen.toBeVisible();
			
			        // * Verify group message channel for the other two new users is added to direct message list
			        await expect(element(by.text(groupDisplayName))).toBeVisible();
			    \});
			
			    it('MM-T4730_4 - should display empty search state for create direct message', async () => \{
			        // # Open create direct message screen and search for a non-existent user
			        const searchTerm = 'blahblahblahblah';
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.searchInput.replaceText(searchTerm);
			
			        // * Verify empty search state for create direct message
			        await expect(element(by.text(\`No matches found for “\$\{searchTerm\}”\`))).toBeVisible();
			        await expect(element(by.text('Check the spelling or try another search.'))).toBeVisible();
			
			        // # Go back to channel list screen
			        await CreateDirectMessageScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\create_direct_message.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\edit_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelInfoScreen,
			    ChannelListScreen,
			    CreateDirectMessageScreen,
			    CreateOrEditChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{isIos\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Edit Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testOtherUser1: any;
			    let testOtherUser2: any;
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        (\{user: testOtherUser1\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'a'\}));
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser1.id, team.id);
			        (\{user: testOtherUser2\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'b'\}));
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser2.id, team.id);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel screen
			        await ChannelScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4906_1 - should match elements on edit channel screen', async () => \{
			        // # Open channel info screen and open edit channel screen
			        await ChannelInfoScreen.open();
			        await CreateOrEditChannelScreen.openEditChannel();
			
			        // * Verify basic elements on edit channel screen
			        await expect(CreateOrEditChannelScreen.backButton).toBeVisible();
			        await expect(CreateOrEditChannelScreen.saveButton).toBeVisible();
			        await expect(CreateOrEditChannelScreen.displayNameInput).toBeVisible();
			        await expect(CreateOrEditChannelScreen.purposeInput).toBeVisible();
			        await expect(CreateOrEditChannelScreen.purposeDescription).toHaveText('Describe how this channel should be used.');
			        await expect(CreateOrEditChannelScreen.headerInput).toBeVisible();
			        await expect(CreateOrEditChannelScreen.headerDescription).toHaveText('Specify text to appear in the channel header beside the channel name. For example, include frequently used links by typing link text [Link Title](http://example.com).');
			
			        // # Go back to channel screen
			        await CreateOrEditChannelScreen.back();
			        await ChannelInfoScreen.close();
			    \});
			
			    it('MM-T4906_2 - should be able to edit public channel', async () => \{
			        // # Open channel info screen and open edit channel screen
			        await ChannelInfoScreen.open();
			        await CreateOrEditChannelScreen.openEditChannel();
			
			        // * Verify current values of fields
			        if (isIos()) \{
			            await expect(CreateOrEditChannelScreen.displayNameInput).toHaveValue(testChannel.display_name);
			            await expect(CreateOrEditChannelScreen.purposeInput).toHaveValue(\`Channel purpose: \$\{testChannel.display_name.toLowerCase()\}\`);
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveValue(\`Channel header: \$\{testChannel.display_name.toLowerCase()\}\`);
			        \} else \{
			            await expect(CreateOrEditChannelScreen.displayNameInput).toHaveText(testChannel.display_name);
			            await expect(CreateOrEditChannelScreen.purposeInput).toHaveText(\`Channel purpose: \$\{testChannel.display_name.toLowerCase()\}\`);
			            await expect(CreateOrEditChannelScreen.headerInput).toHaveText(\`Channel header: \$\{testChannel.display_name.toLowerCase()\}\`);
			        \}
			
			        // # Edit channel info and save changes
			        await CreateOrEditChannelScreen.displayNameInput.typeText(' name');
			        await CreateOrEditChannelScreen.purposeInput.typeText(' purpose');
			        await CreateOrEditChannelScreen.headerInput.typeText('\\nheader1\\nheader2');
			        await CreateOrEditChannelScreen.saveButton.tap();
			
			        // * Verify on channel info screen and changes have been saved
			        await ChannelInfoScreen.toBeVisible();
			        await expect(ChannelInfoScreen.publicPrivateTitleDisplayName).toHaveText(\`\$\{testChannel.display_name\} name\`);
			        await expect(ChannelInfoScreen.publicPrivateTitlePurpose).toHaveText(\`Channel purpose: \$\{testChannel.display_name.toLowerCase()\} purpose\`);
			        await expect(element(by.text(\`Channel header: \$\{testChannel.display_name.toLowerCase()\}\\nheader1\\nheader2\`))).toBeVisible();
			
			        // # Go back to channel screen
			        await ChannelInfoScreen.close();
			    \});
			
			    it('MM-T4906_3 - should be able edit direct message channel', async () => \{
			        // # Create a direct message with another user
			        await ChannelScreen.back();
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.closeTutorial();
			        await CreateDirectMessageScreen.searchInput.replaceText(testOtherUser1.username);
			        await CreateDirectMessageScreen.getUserItem(testOtherUser1.id).tap();
			        await CreateDirectMessageScreen.startButton.tap();
			
			        // * Verify on direct message channel screen
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(testOtherUser1.username);
			
			        // # Open channel info screen, open edit channel header screen, edit channel info, and save changes
			        await ChannelInfoScreen.open();
			        await CreateOrEditChannelScreen.openEditChannelHeader(\{fromChannelInfo: true\});
			        await CreateOrEditChannelScreen.headerInput.typeText('header1');
			        await CreateOrEditChannelScreen.headerInput.tapReturnKey();
			        await CreateOrEditChannelScreen.headerInput.typeText('header2');
			        await CreateOrEditChannelScreen.saveButton.tap();
			
			        // * Verify on channel info screen and changes have been saved
			        await ChannelInfoScreen.toBeVisible();
			        await expect(element(by.text('header1\\nheader2'))).toBeVisible();
			
			        // # Go back to channel screen
			        await ChannelInfoScreen.close();
			    \});
			
			    it('MM-T4906_4 - should be able edit group message channel', async () => \{
			        // # Create a group message with two other users
			        await ChannelScreen.back();
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.searchInput.replaceText(testOtherUser1.username);
			        await CreateDirectMessageScreen.getUserItem(testOtherUser1.id).tap();
			        await CreateDirectMessageScreen.searchInput.replaceText(testOtherUser2.username);
			        await CreateDirectMessageScreen.getUserItem(testOtherUser2.id).tap();
			        await CreateDirectMessageScreen.startButton.tap();
			
			        // * Verify on group message channel screen
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(\`\$\{testOtherUser1.username\}, \$\{testOtherUser2.username\}\`);
			
			        // # Open channel info screen, open edit channel header screen, edit channel info, and save changes
			        await ChannelInfoScreen.open();
			        await CreateOrEditChannelScreen.openEditChannelHeader(\{fromChannelInfo: true\});
			        await CreateOrEditChannelScreen.headerInput.typeText('header1');
			        await CreateOrEditChannelScreen.headerInput.tapReturnKey();
			        await CreateOrEditChannelScreen.headerInput.typeText('header2');
			        await CreateOrEditChannelScreen.saveButton.tap();
			
			        // * Verify on channel info screen and changes have been saved
			        await ChannelInfoScreen.toBeVisible();
			        await expect(element(by.text('header1\\nheader2'))).toBeVisible();
			
			        // # Go back to channel screen
			        await ChannelInfoScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\edit_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\favorite_and_unfavorite_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    CreateDirectMessageScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Favorite and Unfavorite Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const favoritesCategory = 'favorites';
			    const directMessagesCategory = 'direct_messages';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4929_1 - should be able to favorite/unfavorite a channel from channel quick actions', async () => \{
			        // # Open a channel screen, tap on channel quick actions button, and tap on favorite quick action to favorite the channel
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.channelQuickActionsButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelScreen.favoriteQuickAction.tap();
			
			        // * Verify favorited toast message appears
			        await wait(timeouts.ONE_SEC);
			        await expect(ChannelScreen.toastMessage).toHaveText('This channel was favorited');
			        await waitFor(ChannelScreen.toastMessage).not.toExist().withTimeout(timeouts.TEN_SEC);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			
			        // * Verify channel is listed under favorites category
			        await expect(ChannelListScreen.getChannelItemDisplayName(favoritesCategory, testChannel.name)).toBeVisible();
			
			        // # Go back to the favorited channel, tap on channel quick actions button, and tap on favorited quick action to unfavorite the channel
			        await ChannelScreen.open(favoritesCategory, testChannel.name);
			        await ChannelScreen.channelQuickActionsButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelScreen.unfavoriteQuickAction.tap();
			
			        // * Verify unfavorited toast message appears
			        await wait(timeouts.ONE_SEC);
			        await expect(ChannelScreen.toastMessage).toHaveText('This channel was unfavorited');
			        await waitFor(ChannelScreen.toastMessage).not.toExist().withTimeout(timeouts.TEN_SEC);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			
			        // * Verify channel is not listed anymore under favorites category and is back under channels category
			        await expect(ChannelListScreen.getChannelItemDisplayName(favoritesCategory, testChannel.name)).not.toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, testChannel.name)).toBeVisible();
			    \});
			
			    it('MM-T4929_2 - should be able to favorite/unfavorite a channel from channel info screen', async () => \{
			        // # Open a channel screen, open channel info screen, tap on favorite action to favorite the channel, and go back to channel list screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.favoriteAction.tap();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			
			        // * Verify channel is listed under favorites category
			        await expect(ChannelListScreen.getChannelItemDisplayName(favoritesCategory, testChannel.name)).toBeVisible();
			
			        // # Go back to the favorited channel, open channel info screen, tap on favorited action to unfavorite the channel, and go back to channel list screen
			        await ChannelScreen.open(favoritesCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.unfavoriteAction.tap();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			
			        // * Verify channel is not listed anymore under favorites category and is back under channels category
			        await expect(ChannelListScreen.getChannelItemDisplayName(favoritesCategory, testChannel.name)).not.toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(channelsCategory, testChannel.name)).toBeVisible();
			    \});
			
			    it('MM-T4929_3 - should be able to favorite/unfavorite a direct message channel from channel intro', async () => \{
			        // # Open a direct message channel screen, post a message, tap on intro favorite action to favorite the channel, and go back to channel list screen
			        const \{user: newUser\} = await User.apiCreateUser(siteOneUrl);
			        await Team.apiAddUserToTeam(siteOneUrl, newUser.id, testTeam.id);
			        const \{channel: directMessageChannel\} = await Channel.apiCreateDirectChannel(siteOneUrl, [testUser.id, newUser.id]);
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.closeTutorial();
			        await CreateDirectMessageScreen.searchInput.replaceText(newUser.username);
			        await CreateDirectMessageScreen.getUserItem(newUser.id).tap();
			        await CreateDirectMessageScreen.startButton.tap();
			        await ChannelScreen.postMessage('test');
			        await device.reloadReactNative();
			        await ChannelListScreen.getChannelItemDisplayName(directMessagesCategory, directMessageChannel.name).tap();
			        await ChannelScreen.introFavoriteAction.tap();
			        await ChannelScreen.back();
			
			        // * Verify direct message channel is listed under favorites category
			        await expect(ChannelListScreen.getChannelItemDisplayName(favoritesCategory, directMessageChannel.name)).toHaveText(newUser.username);
			
			        // # Go back to the favorited direct message channel, tap on intro favorited action to unfavorite the direct message channel, and go back to channel list screen
			        await ChannelScreen.open(favoritesCategory, directMessageChannel.name);
			        await ChannelScreen.introUnfavoriteAction.tap();
			        await ChannelScreen.back();
			
			        // * Verify direct message channel is not listed anymore under favorites category and is back under direct messages category
			        await expect(ChannelListScreen.getChannelItemDisplayName(favoritesCategory, directMessageChannel.name)).not.toBeVisible();
			        await expect(ChannelListScreen.getChannelItemDisplayName(directMessagesCategory, directMessageChannel.name)).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\favorite_and_unfavorite_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\find_channels.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    FindChannelsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Find Channels', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4907_1 - should match elements on find channels screen', async () => \{
			        // # Open find channels screen
			        await FindChannelsScreen.open();
			
			        // * Verify basic elements on find channels screen
			        await expect(FindChannelsScreen.closeButton).toBeVisible();
			        await expect(FindChannelsScreen.searchInput).toBeVisible();
			        await expect(FindChannelsScreen.sectionUnfilteredChannelList).toExist();
			
			        // # Go back to channel list screen
			        await FindChannelsScreen.close();
			    \});
			
			    it('MM-T4907_2 - should be able to find and navigate to a public channel', async () => \{
			        // # Open find channels screen and search for a public channel to navigate to
			        await FindChannelsScreen.open();
			        await FindChannelsScreen.searchInput.replaceText(testChannel.name);
			
			        // * Verify search returns the target public channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(FindChannelsScreen.getFilteredChannelItemDisplayName(testChannel.name)).toHaveText(testChannel.display_name);
			
			        // # Tap on the target public channel item
			        await FindChannelsScreen.getFilteredChannelItem(testChannel.name).tap();
			
			        // * Verify on target public channel screen
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(testChannel.display_name);
			        await expect(ChannelScreen.introDisplayName).toHaveText(testChannel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4907_3 - should display empty search state for find channels', async () => \{
			        // # Open find channels screen and search for a non-existent channel
			        const searchTerm = 'blahblahblahblah';
			        await FindChannelsScreen.open();
			        await FindChannelsScreen.searchInput.replaceText(searchTerm);
			
			        // * Verify empty search state for find channels
			        await wait(timeouts.ONE_SEC);
			        await expect(element(by.text(\`No matches found for “\$\{searchTerm\}”\`))).toBeVisible();
			        await expect(element(by.text('Check the spelling or try another search.'))).toBeVisible();
			
			        // # Go back to channel list screen
			        await FindChannelsScreen.close();
			    \});
			
			    it('MM-T4907_4 - should be able to find direct and group message channels', async () => \{
			        // # Create direct and group message channels, open find channels screen, and search for the direct message channel
			        const \{user: testOtherUser1\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'a'\});
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser1.id, testTeam.id);
			        const \{user: testOtherUser2\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'b'\});
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser2.id, testTeam.id);
			        const \{channel: directMessageChannel\} = await Channel.apiCreateDirectChannel(siteOneUrl, [testUser.id, testOtherUser1.id]);
			        const \{channel: groupMessageChannel\} = await Channel.apiCreateGroupChannel(siteOneUrl, [testUser.id, testOtherUser1.id, testOtherUser2.id]);
			        await FindChannelsScreen.open();
			        await FindChannelsScreen.searchInput.replaceText(testOtherUser1.username);
			
			        // * Verify search returns the target direct message channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(FindChannelsScreen.getFilteredChannelItemDisplayName(directMessageChannel.name)).toHaveText(testOtherUser1.username);
			
			        // # Search for the group message channel
			        await FindChannelsScreen.searchInput.replaceText(testOtherUser2.username);
			
			        // * Verify search returns the target group message channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(FindChannelsScreen.getFilteredChannelItemDisplayName(groupMessageChannel.name)).toHaveText(\`\$\{testOtherUser1.username\}, \$\{testOtherUser2.username\}, sysadmin\`);
			
			        // # Go back to channel list screen
			        await FindChannelsScreen.close();
			    \});
			
			    it('MM-T4907_5 - should be able to find an archived channel', async () => \{
			        // # Archive a channel, open find channels screen, and search for the archived channel
			        const \{channel: archivedChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, archivedChannel.id);
			        await Channel.apiDeleteChannel(siteOneUrl, archivedChannel.id);
			        await FindChannelsScreen.open();
			        await FindChannelsScreen.searchInput.replaceText(archivedChannel.name);
			
			        // * Verify search returns the target archived channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(FindChannelsScreen.getFilteredChannelItemDisplayName(archivedChannel.name)).toHaveText(archivedChannel.display_name);
			
			        // # Go back to channel list screen
			        await FindChannelsScreen.close();
			    \});
			
			    it('MM-T4907_6 - should be able to find a joined private channel and not find an unjoined private channel', async () => \{
			        // # Open find channels screen and search for a joined private channel
			        const \{channel: joinedPrivateChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'P', teamId: testTeam.id\});
			        const \{channel: unjoinedPrivateChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{type: 'P', teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, joinedPrivateChannel.id);
			        await FindChannelsScreen.open();
			        await FindChannelsScreen.searchInput.replaceText(joinedPrivateChannel.name);
			
			        // * Verify search returns the target joined private channel item
			        await wait(timeouts.ONE_SEC);
			        await expect(FindChannelsScreen.getFilteredChannelItemDisplayName(joinedPrivateChannel.name)).toHaveText(joinedPrivateChannel.display_name);
			
			        // # Search for an unjoined private channel
			        await FindChannelsScreen.searchInput.replaceText(unjoinedPrivateChannel.name);
			
			        // * Verify empty search state for find channels
			        await wait(timeouts.ONE_SEC);
			        await expect(element(by.text(\`No matches found for “\$\{unjoinedPrivateChannel.name\}”\`))).toBeVisible();
			
			        // # Go back to channel list screen
			        await FindChannelsScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\find_channels.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\leave_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Leave Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{team, user\} = await Setup.apiInit(siteOneUrl);
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4931_1 - should be able to leave a channel from channel info screen and confirm', async () => \{
			        // # Open a channel screen, open channel info screen, and tap on leave channel option and confirm
			        const \{channel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, channel.id);
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.leaveChannel(\{confirm: true\});
			
			        // * Verify on channel list screen and the channel left by the user does not appear on the list
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.getChannelItem(channelsCategory, channel.name)).not.toExist();
			    \});
			
			    it('MM-T4931_2 - should be able to leave a channel from channel info screen and cancel', async () => \{
			        // # Open a channel screen, open channel info screen, and tap on leave channel option and cancel
			        const \{channel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, channel.id);
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.leaveChannel(\{confirm: false\});
			
			        // * Verify still on channel info screen
			        await ChannelInfoScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4931_3 - should be able to leave a channel from channel quick actions', async () => \{
			        // # Open a channel screen, tap on channel quick actions button, and tap on leave channel option and confirm
			        const \{channel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, channel.id);
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await ChannelScreen.channelQuickActionsButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelScreen.leaveChannel(\{confirm: true\});
			
			        // * Verify on channel list screen and the channel left by the user does not appear on the list
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.getChannelItem(channelsCategory, channel.name)).not.toExist();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\leave_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\mute_and_unmute_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Mute and Unmute Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4930_1 - should be able to mute/unmute a channel from channel quick actions', async () => \{
			        // # Open a channel screen, tap on channel quick actions button, and tap on mute quick action to mute the channel
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.channelQuickActionsButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelScreen.muteQuickAction.tap();
			
			        // * Verify muted toast message appears
			        await wait(timeouts.ONE_SEC);
			        await expect(ChannelScreen.toastMessage).toHaveText('This channel was muted');
			        await waitFor(ChannelScreen.toastMessage).not.toExist().withTimeout(timeouts.TEN_SEC);
			
			        // # Tap on channel quick actions button and tap on muted quick action to unmute the channel
			        await ChannelScreen.channelQuickActionsButton.tap();
			        await wait(timeouts.ONE_SEC);
			        await ChannelScreen.unmuteQuickAction.tap();
			
			        // * Verify unmuted toast message appears
			        await wait(timeouts.ONE_SEC);
			        await expect(ChannelScreen.toastMessage).toHaveText('This channel was unmuted');
			        await waitFor(ChannelScreen.toastMessage).not.toExist().withTimeout(timeouts.TEN_SEC);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4930_2 - should be able to mute/unmute a channel from channel info screen', async () => \{
			        // # Open a channel screen, open channel info screen, and tap on mute action to mute the channel
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.muteAction.tap();
			
			        // * Verify channel is muted
			        await expect(ChannelInfoScreen.unmuteAction).toBeVisible();
			        await wait(timeouts.FOUR_SEC);
			
			        // # Tap on muted action to unmute the channel
			        await ChannelInfoScreen.unmuteAction.longPress();
			
			        // * Verify channel is unmuted
			        await expect(ChannelInfoScreen.muteAction).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\mute_and_unmute_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\unarchive_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{serverOneUrl\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    CreateOrEditChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{getAdminAccount, getRandomId, timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Channels - Unarchive Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			
			    beforeAll(async () => \{
			        // # Log in to server as admin
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(getAdminAccount());
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await waitFor(ChannelListScreen.channelListScreen).toBeVisible().withTimeout(timeouts.TWO_MIN);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4944_1 - should be able to unarchive a public channel and confirm', async () => \{
			        // # Create a public channel screen, open channel info screen, and tap on archive channel option and confirm
			        const channelDisplayName = \`Channel \$\{getRandomId()\}\`;
			        const channelName = channelDisplayName.replace(/ /, '-').toLowerCase();
			        await CreateOrEditChannelScreen.openCreateChannel();
			        await CreateOrEditChannelScreen.displayNameInput.replaceText(channelDisplayName);
			        await CreateOrEditChannelScreen.createButton.tap();
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.archivePublicChannel(\{confirm: true\});
			
			        // * Verify on public channel screen and archived post draft is displayed
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.postDraftArchived).toBeVisible();
			
			        // # Open channel info screen, tap on unarchive channel and confirm, close and re-open app to reload, and re-open unarchived public channel
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.unarchivePublicChannel(\{confirm: true\});
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, channelName);
			
			        // * Verify on unarchived public channel screen and active post draft is displayed
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.postDraft).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4944_2 - should be able to unarchive a private channel and confirm', async () => \{
			        // # Create a private channel screen, open channel info screen, and tap on archive channel option and confirm
			        const channelDisplayName = \`Channel \$\{getRandomId()\}\`;
			        const channelName = channelDisplayName.replace(/ /, '-').toLowerCase();
			        await CreateOrEditChannelScreen.openCreateChannel();
			        await CreateOrEditChannelScreen.toggleMakePrivateOn();
			        await CreateOrEditChannelScreen.displayNameInput.replaceText(channelDisplayName);
			        await CreateOrEditChannelScreen.createButton.tap();
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.archivePrivateChannel(\{confirm: true\});
			
			        // * Verify on private channel screen and archived post draft is displayed
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.postDraftArchived).toBeVisible();
			
			        // # Open channel info screen, tap on unarchive channel and confirm, close and re-open app to reload, and re-open unarchived private channel
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.unarchivePrivateChannel(\{confirm: true\});
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, channelName);
			
			        // * Verify on unarchived private channel screen and active post draft is displayed
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.postDraft).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\channels\\unarchive_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\at_mention.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Post,
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Alert\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    UserProfileScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - At-Mention', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			    let testOtherUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        (\{user: testOtherUser\} = await User.apiCreateUser(siteOneUrl));
			        await Team.apiAddUserToTeam(siteOneUrl, testOtherUser.id, testTeam.id);
			        await Channel.apiAddUserToChannel(siteOneUrl, testOtherUser.id, testChannel.id);
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4874_1 - should post at-mention as lowercase', async () => \{
			        // # Open a channel screen and post a message with lowercase at-mention
			        const camelCaseUsernameMessage = \`Message @\$\{testUser.username.substring(0, 1).toUpperCase()\}\$\{testUser.username.substring(1)\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(camelCaseUsernameMessage);
			
			        // * Verify at-mention is posted as lowercase
			        const \{post: lowerCasePost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(lowerCasePost.id, \`Message @\$\{testUser.username.toLowerCase()\}\`);
			
			        // # Post a message with uppercase at-mention
			        const upperCaseUsernameMessage = \`Message @\$\{testOtherUser.username.toUpperCase()\}\`;
			        await ChannelScreen.postMessage(upperCaseUsernameMessage);
			
			        // * Verify at-mention is posted as lowercase
			        const \{post: upperCasePost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(upperCasePost.id, \`Message @\$\{testOtherUser.username.toLowerCase()\}\`);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it.skip('MM-T4874_2 - should display confirmation dialog when posting @all, @channel, and @here -- UNSTABLE', async () => \{
			        // # Add more users to the channel, open a channel screen, and post @all
			        [...Array(3).keys()].forEach(async (key) => \{
			            const \{user\} = await User.apiCreateUser(siteOneUrl, \{prefix: \`a-\$\{key\}-\`\});
			            await Team.apiAddUserToTeam(siteOneUrl, user.id, testTeam.id);
			            await Channel.apiAddUserToChannel(siteOneUrl, user.id, testChannel.id);
			        \});
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postInput.replaceText('@all');
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify confirmation dialog is displayed
			        await expect(Alert.confirmSendingNotificationsTitle).toBeVisible();
			
			        // # Tap on confirm button
			        await Alert.confirmButton.tap();
			
			        // * Verify @all is posted
			        const \{post: atAllPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(atAllPost.id, '@all');
			
			        // # Post @channel
			        await ChannelScreen.postInput.clearText();
			        await ChannelScreen.postInput.replaceText('@channel');
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify confirmation dialog is displayed
			        await expect(Alert.confirmSendingNotificationsTitle).toBeVisible();
			
			        // # Tap on confirm button
			        await Alert.confirmButton.tap();
			
			        // * Verify @channel is posted
			        const \{post: atChannelPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(atChannelPost.id, '@channel');
			
			        // # Post @here
			        await ChannelScreen.postInput.clearText();
			        await ChannelScreen.postInput.replaceText('@here');
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify confirmation dialog is displayed
			        await expect(Alert.confirmSendingNotificationsTitle).toBeVisible();
			
			        // # Tap on confirm button
			        await Alert.confirmButton.tap();
			
			        // * Verify @here is posted
			        const \{post: atHerePost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(atHerePost.id, '@here');
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4874_3 - should be able to open user profile by tapping on at-mention', async () => \{
			        // # Open a channel screen, post a message with at-mention, and tap on at-mention
			        const message = \`@\$\{testUser.username\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await element(by.text(message)).tap(\{x: 5, y: 10\});
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify on user profile screen
			        await UserProfileScreen.toBeVisible();
			        await expect(UserProfileScreen.getUserProfilePicture(testUser.id)).toBeVisible();
			        await expect(UserProfileScreen.userDisplayName).toHaveText(\`@\$\{testUser.username\}\`);
			
			        // # Go back to channel list screen
			        await UserProfileScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\at_mention.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\channel_link.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Channel Link', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4877_1 - should be able to open joined channel by tapping on channel link from main channel', async () => \{
			        // # Open a channel screen and post a channel link to target channel
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const channelLink = \`\$\{serverOneUrl\}/\$\{testTeam.name\}/channels/\$\{targetChannel.name\}\`;
			        await ChannelScreen.postMessage(channelLink);
			
			        // # Tap on channel link
			        await element(by.text(channelLink)).tap(\{x: 5, y: 10\});
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify redirected to target channel
			        await expect(ChannelScreen.headerTitle).toHaveText(targetChannel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4877_2 - should be able to open joined channel by tapping on channel link from reply thread', async () => \{
			        // # Open a channel screen, post a channel link to target channel, tap on post to open reply thread, and tap on channel link
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const channelLink = \`\$\{serverOneUrl\}/\$\{testTeam.name\}/channels/\$\{targetChannel.name\}\`;
			        await ChannelScreen.postMessage(channelLink);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id);
			        await postListPostItem.tap(\{x: 1, y: 1\});
			        await element(by.text(channelLink)).tap(\{x: 5, y: 10\});
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify redirected to target channel
			        await expect(ChannelScreen.headerTitle).toHaveText(targetChannel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\channel_link.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\channel_mention.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Channel Mention', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4875_1 - should post channel mention as channel display name', async () => \{
			        // # Open a channel screen and post a channel name mention
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const channelNameMention = \`~\$\{targetChannel.name\}\`;
			        await ChannelScreen.postMessage(channelNameMention);
			
			        // * Verify post shows channel display name mention
			        const channelDisplayNameMention = \`~\$\{targetChannel.display_name\}\`;
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(post.id, channelDisplayNameMention);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4875_2 - should be able to open joined channel by tapping on channel mention', async () => \{
			        // # Open a channel screen, post a channel name mention, and tap on channel display name mention
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const channelNameMention = \`~\$\{targetChannel.name\}\`;
			        const channelDisplayNameMention = \`~\$\{targetChannel.display_name\}\`;
			        await ChannelScreen.postMessage(channelNameMention);
			        await element(by.text(channelDisplayNameMention)).tap(\{x: 5, y: 10\});
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify redirected to target channel
			        await expect(ChannelScreen.headerTitle).toHaveText(targetChannel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\channel_mention.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\emojis_and_reactions.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    EmojiPickerScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ReactionsScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Emojis and Reactions', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4862_1 - should be able to view recent reactions and add new reaction via post options', async () => \{
			        // # Open a channel screen, post a message, and open post options for message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			
			        // * Verify six default reactions are displayed
			        await expect(PostOptionsScreen.getReactionEmoji('+1')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('smiley')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('white_check_mark')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('heart')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('eyes')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('raised_hands')).toBeVisible();
			
			        // # Open emoji picker screen and add a new reaction
			        await EmojiPickerScreen.open(true);
			        await EmojiPickerScreen.searchInput.replaceText('clown_face');
			        await element(by.text('🤡')).tap();
			
			        // * Verify new reaction is added to the message
			        await expect(element(by.text('🤡').withAncestor(by.id(\`channel.post_list.post.\$\{post.id\}\`)))).toBeVisible();
			
			        // # Open post options for message
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			
			        // * Verify recent reactions are displayed, newest reaction first and then the first five default reactions
			        await expect(PostOptionsScreen.getReactionEmoji('clown_face')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('+1')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('smiley')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('white_check_mark')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('heart')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('eyes')).toBeVisible();
			        await expect(PostOptionsScreen.getReactionEmoji('raised_hands')).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await PostOptionsScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4862_2 - should be able to long press on a reaction to view the list of users who reacted', async () => \{
			        // # Open a channel screen, post a message, open post options for message, open emoji picker screen, and add a reaction
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await EmojiPickerScreen.open();
			        await EmojiPickerScreen.searchInput.replaceText('fire');
			        await element(by.text('🔥')).tap();
			
			        // * Verify reaction is added to the message
			        const reaction = element(by.text('🔥').withAncestor(by.id(\`channel.post_list.post.\$\{post.id\}\`)));
			        await expect(reaction).toBeVisible();
			
			        // # Long press on the reaction
			        await reaction.longPress();
			
			        // * Verify user who reacted with the emoji
			        await ReactionsScreen.toBeVisible();
			        const \{reactorItemEmojiAliases, reactorItemUserProfilePicture, reactorItemUserDisplayName, reactorItemUsername\} = ReactionsScreen.getReactorItem(testUser.id, 'fire');
			        await expect(reactorItemEmojiAliases).toHaveText(':fire:');
			        await expect(reactorItemUserProfilePicture).toBeVisible();
			        await expect(reactorItemUserDisplayName).toHaveText(\`\$\{testUser.first_name\} \$\{testUser.last_name\}\`);
			        await expect(reactorItemUsername).toHaveText(\` @\$\{testUser.username\}\`);
			
			        // # Go back to channel list screen
			        await ReactionsScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4862_3 - should be able to include emojis in a message and be able to find them in emoji bar and recently used section', async () => \{
			        // # Open a channel screen and post a message that includes emojis
			        const message = 'brown fox :fox_face: lazy dog :dog:';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is posted with emojis
			        const resolvedMessage = 'brown fox 🦊 lazy dog 🐶';
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, resolvedMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for message
			        await ChannelScreen.openPostOptionsFor(post.id, resolvedMessage);
			        await PostOptionsScreen.toBeVisible();
			
			        // * Verify emojis exist in emoji bar
			        await expect(element(by.text('🦊'))).toExist();
			        await expect(element(by.text('🐶'))).toExist();
			
			        // # Open emoji picker screen
			        await EmojiPickerScreen.open();
			
			        // * Verify emojis exist in recently used section
			        await expect(element(by.text('RECENTLY USED'))).toExist();
			        await expect(element(by.text('🦊')).atIndex(0)).toExist();
			        await expect(element(by.text('🐶')).atIndex(0)).toExist();
			
			        // # Go back to channel list screen
			        await EmojiPickerScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4862_4 - should display empty search state for emoji picker', async () => \{
			        // # Open a channel screen, post a message, open post options for message, open emoji picker screen, and search for a non-existent emoji
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const searchTerm = 'blahblahblahblah';
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await EmojiPickerScreen.open();
			        await EmojiPickerScreen.searchInput.replaceText(searchTerm);
			
			        // * Verify empty search state for emoji picker
			        await expect(element(by.text(\`No matches found for “\$\{searchTerm\}”\`))).toBeVisible();
			        await expect(element(by.text('Check the spelling or try another search.'))).toBeVisible();
			
			        // # Go back to channel list screen
			        await EmojiPickerScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\emojis_and_reactions.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\follow_and_unfollow_messsage.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Follow and Unfollow Message', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4863_1 - should be able to follow/unfollow a message via post options', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for message and tap on follow message option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.followThreadOption.tap();
			
			        // * Verify message is followed by user via post footer
			        const \{postListPostItemFooterFollowingButton\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await waitFor(postListPostItemFooterFollowingButton).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Open post options for message and tap on unfollow message option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.followingThreadOption.tap();
			
			        // * Verify message is not followed by user via post footer
			        await waitFor(postListPostItemFooterFollowingButton).not.toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4863_2 - should be able to unfollow a message via post footer', async () => \{
			        // # Open a channel screen, post a message, open post options for message, and tap on follow message option
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.followThreadOption.tap();
			
			        // * Verify message is followed by user via post footer
			        const \{postListPostItemFooterFollowingButton\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await waitFor(postListPostItemFooterFollowingButton).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Tap on following button via post footer
			        await postListPostItemFooterFollowingButton.tap();
			
			        // * Verify message is not followed by user via post footer
			        await waitFor(postListPostItemFooterFollowingButton).not.toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\follow_and_unfollow_messsage.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_block_quote.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown Block Quote', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4898_1 - should be able to display markdown block quote', async () => \{
			        // # Open a channel screen and post a markdown block quote
			        const message = 'this is a quote that i am making long so it wraps on mobile this is a quote that i am making long so it wraps on mobile this is a quote that i am making long so it wraps on mobile this is a quote that i am making long so it wraps on mobile';
			        const markdownBlockQuote = \`>\$\{message\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownBlockQuote);
			
			        // * Verify markdown block quote is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemBlockQuote\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemBlockQuote).toBeVisible();
			        await expect(element(by.text(message))).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_block_quote.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_code.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown Code', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4895_1 - should be able to display markdown code block', async () => \{
			        // # Open a channel screen and post a markdown code block
			        const line1 = 'let x = 10;';
			        const line2 = 'let y = 20;';
			        // eslint-disable-next-line no-template-curly-in-string
			        const line3 = 'console.log(\`sum: \$\{x + y\}\`);';
			        const message = \`\$\{line1\}\\n\$\{line2\}\\n\$\{line3\}\`;
			        const markdownCodeBlock = \`\\\`\\\`\\\`\\n\$\{message\}\\n\\\`\\\`\\\`\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownCodeBlock);
			
			        // * Verify markdown code block is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemCodeBlock\} = ChannelScreen.getPostListPostItem(post.id);
			        await waitFor(postListPostItemCodeBlock).toBeVisible().whileElement(by.id(ChannelScreen.postList.testID.flatList)).scroll(50, 'down');
			        await expect(postListPostItemCodeBlock).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4895_2- should be able to display markdown html', async () => \{
			        // # Open a channel screen and post a html
			        const message = '<html>\\n<body>\\n<span>This is html block</span>\\n</body>\\n</html>';
			        const markdownHtml = \`\\\`\\\`\\\`html\\n\$\{message\}\\n\\\`\\\`\\\`\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownHtml);
			
			        // * Verify markdown html is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemCodeBlock\} = ChannelScreen.getPostListPostItem(post.id);
			        await waitFor(postListPostItemCodeBlock).toBeVisible().whileElement(by.id(ChannelScreen.postList.testID.flatList)).scroll(50, 'down');
			        await expect(postListPostItemCodeBlock).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_code.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_heading.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown Heading', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4893_1 - should be able to display markdown heading', async () => \{
			        // # Open a channel screen and post a markdown heading
			        const message = 'Heading';
			        const markdownHeading = \`## \$\{message\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownHeading);
			
			        // * Verify markdown heading is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemHeading\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemHeading).toBeVisible();
			        await expect(element(by.text(message))).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_heading.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_image.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown Image', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4896_1 - should be able to display markdown image', async () => \{
			        // # Open a channel screen and post a markdown image
			        const markdownImage = '![Mattermost](https://docs.mattermost.com/_images/icon-76x76.png)';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownImage);
			
			        // * Verify markdown image is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemImage\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemImage).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4896_2 - should be able to display markdown image with link', async () => \{
			        // # Open a channel screen and post a markdown image with link
			        const markdownImage = '[![Mattermost](https://docs.mattermost.com/_images/icon-76x76.png)](https://github.com/mattermost/mattermost-server)';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownImage);
			
			        // * Verify markdown image with link is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemImage\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemImage).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_image.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_latex.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown Latex', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4900_1 - should be able to display markdown latex code block', async () => \{
			        // # Open a channel screen and post a markdown latex code block
			        // eslint-disable-next-line no-useless-escape
			        const message = 'X_k = \\sum_\{n=0\}^\{2N-1\} x_n \\cos \\left[\\frac\{\\pi\}\{N\} \\left(n+\\frac\{1\}\{2\}+\\frac\{N\}\{2\}\\right) \\left(k+\\frac\{1\}\{2\}\\right) \\right]';
			        const markdownLatexCodeBlock = \`\\\`\\\`\\\`latex\\n\$\{message\}\\n\\\`\\\`\\\`\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownLatexCodeBlock);
			
			        // * Verify markdown latex code block is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemLatexCodeBlock\} = ChannelScreen.getPostListPostItem(post.id);
			        await waitFor(postListPostItemLatexCodeBlock).toBeVisible().whileElement(by.id(ChannelScreen.postList.testID.flatList)).scroll(50, 'down');
			        await expect(postListPostItemLatexCodeBlock).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4900_2 - should be able to display markdown inline latex', async () => \{
			        // # Open a channel screen and post a markdown inline latex
			        // eslint-disable-next-line no-useless-escape
			        const message = 'X_k = \\\\sum_\{n=0\}^\{2N-1\} x_n \\\\cos \\\\left[\\\\frac\{\\\\pi\}\{N\} \\\\left(n+\\\\frac\{1\}\{2\}+\\\\frac\{N\}\{2\}\\\\right) \\\\left(k+\\\\frac\{1\}\{2\}\\\\right) \\\\right]';
			        const markdownInlineLatex = \`\$\$\{message\}\$\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownInlineLatex);
			
			        // * Verify markdown inline latex is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemInlineLatex\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemInlineLatex).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_latex.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_list.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown List', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it.skip('MM-T4894_1 - should be able to display markdown bullet list -- UNSTABLE', async () => \{
			        // # Open a channel screen and post a markdown bullet list
			        const item1 = 'item one';
			        const item2 = 'item two';
			        const item2SubPoint = 'item two sub-point';
			        const markdownBulletList = \`* \$\{item1\}\\n- \$\{item2\}\\n  + \$\{item2SubPoint\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownBulletList);
			
			        // * Verify markdown bullet list is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemListItem, postListPostItemListItemBullet\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemListItem.atIndex(0)).toBeVisible();
			        await expect(postListPostItemListItemBullet.atIndex(0)).toHaveText('•');
			        await expect(element(by.text(item1))).toBeVisible();
			        await expect(postListPostItemListItem.atIndex(1)).toBeVisible();
			        await expect(postListPostItemListItemBullet.atIndex(1)).toHaveText('•');
			        await expect(element(by.text(item2))).toBeVisible();
			        await expect(postListPostItemListItem.atIndex(2)).toBeVisible();
			        await expect(postListPostItemListItemBullet.atIndex(2)).toHaveText('◦');
			        await expect(element(by.text(item2SubPoint))).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4894_2 - should be able to display markdown ordered list', async () => \{
			        // # Open a channel screen and post a markdown ordered list
			        const item1 = 'Item one';
			        const item2 = 'Item two';
			        const item3 = 'Item three';
			        const markdownOrderedList = \`1. \$\{item1\}\\n1. \$\{item2\}\\n1. \$\{item3\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdownOrderedList);
			
			        // * Verify markdown ordered list is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemListItem, postListPostItemListItemBullet\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemListItem.atIndex(0)).toBeVisible();
			        await expect(postListPostItemListItemBullet.atIndex(0)).toHaveText('1.');
			        await expect(element(by.text(item1))).toBeVisible();
			        await expect(postListPostItemListItem.atIndex(1)).toBeVisible();
			        await expect(postListPostItemListItemBullet.atIndex(1)).toHaveText('2.');
			        await expect(element(by.text(item2))).toBeVisible();
			        await expect(postListPostItemListItem.atIndex(2)).toBeVisible();
			        await expect(postListPostItemListItemBullet.atIndex(2)).toHaveText('3.');
			        await expect(element(by.text(item3))).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_list.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_separator.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown Separator', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4897_1 - should be able to display markdown separator', async () => \{
			        // # Open a channel screen and post a markdown separator
			        const markdownSeparator = '---';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: markdownSeparator,
			        \});
			
			        // * Verify markdown separator is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemThematicBreak\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemThematicBreak).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_separator.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_table.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    TableScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Messaging - Markdown Table', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4899_1 - should be able to display markdown table', async () => \{
			        // # Open a channel screen and post a markdown table
			        const markdownTable =
			            '| A | B | C |\\n' +
			            '|:---|:---|:---|\\n' +
			            '| 1 | Name | Toast |\\n' +
			            '| 2 | Name | Server |\\n';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: markdownTable,
			        \});
			
			        // * Verify markdown table is displayed
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemTable\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemTable).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4899_2 - should be able to display markdown table with long text wrapped properly', async () => \{
			        // # Open a channel screen and post a markdown table with long text
			        const markdownTable =
			            '| Left header that wraps | Center header that wraps | Right header that wraps |\\n' +
			            '| :-- | :-: | --: |\\n' +
			            '| Left text that wraps row | Center text that wraps row | Right text that wraps row |\\n';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: markdownTable,
			        \});
			
			        // * Verify table is displayed with long text wrapped properly
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemTable, postListPostItemTableExpandButton\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemTable).toBeVisible();
			        await expect(element(by.text('Left header that wraps'))).toBeVisible();
			        await expect(element(by.text('Center header that wraps'))).toBeVisible();
			        await expect(element(by.text('Right header that wraps'))).toBeVisible();
			        await expect(element(by.text('Left text that wraps row'))).toBeVisible();
			        await expect(element(by.text('Center text that wraps row'))).toBeVisible();
			        await expect(element(by.text('Right text that wraps row'))).toBeVisible();
			
			        // # Expand to full view
			        await waitFor(postListPostItemTableExpandButton).toBeVisible().whileElement(by.id(ChannelScreen.postList.testID.flatList)).scroll(50, 'down');
			        await postListPostItemTableExpandButton.tap();
			
			        // * Verify on table screen with the markdown table
			        await TableScreen.toBeVisible();
			        await expect(element(by.text('Left header that wraps'))).toBeVisible();
			        await expect(element(by.text('Center header that wraps'))).toBeVisible();
			        await expect(element(by.text('Right header that wraps'))).toBeVisible();
			        await expect(element(by.text('Left text that wraps row'))).toBeVisible();
			        await expect(element(by.text('Center text that wraps row'))).toBeVisible();
			        await expect(element(by.text('Right text that wraps row'))).toBeVisible();
			
			        // # Go back to channel list screen
			        await TableScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4899_3 - should be able to open markdown table in full view and allow horizontal scroll', async () => \{
			        // # Open a channel screen and post a markdown table with more columns past horizontal view
			        const markdownTable =
			            '| Header | Header | Header | Header | Header | Header | Header | Header HS last |\\n' +
			            '| :-- | :-: | --: | --: | :-- | :-: | --: | --: |\\n' +
			            '| Left | Center | Right | Right | Left | Center | Right | Right |\\n'.repeat(7) +
			            '| Left | Center | Right | Right | Left | Center | Right | Right HS last |\\n';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: markdownTable,
			        \});
			
			        // * Verify table is displayed with some right columns not visible
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemTable, postListPostItemTableExpandButton\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemTable).toBeVisible();
			        await expect(element(by.text('Header HS last'))).not.toBeVisible();
			        await expect(element(by.text('Right HS last'))).not.toBeVisible();
			
			        // # Expand to full view
			        await waitFor(postListPostItemTableExpandButton).toBeVisible().whileElement(by.id(ChannelScreen.postList.testID.flatList)).scroll(50, 'down');
			        await postListPostItemTableExpandButton.tap();
			        await TableScreen.toBeVisible();
			        await expect(element(by.text('Header HS last'))).not.toBeVisible();
			        await expect(element(by.text('Right HS last'))).not.toBeVisible();
			
			        // * Verify table screen is scrollable to the right
			        await TableScreen.tableScrollView.scrollTo('right');
			        await expect(element(by.text('Header HS last'))).toBeVisible();
			        await expect(element(by.text('Right HS last'))).toBeVisible();
			
			        // # Go back to channel list screen
			        await TableScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4899_4 - should be able to open markdown table in full view and allow vertical scroll', async () => \{
			        // # Open a channel screen and post a markdown table with more rows past vertical view
			        const markdownTable =
			            '| Header | Header | Header VS last |\\n' +
			            '| :-- | :-: | --: |\\n' +
			            '| Left | Center | Right |\\n'.repeat(30) +
			            '| Left | Center | Right VS last |\\n';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: markdownTable,
			        \});
			
			        // * Verify table is displayed with some bottom rows not visible
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemTable, postListPostItemTableExpandButton\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemTable).toBeVisible();
			        await expect(element(by.text('Header VS last'))).toBeVisible();
			        await expect(element(by.text('Right VS last'))).not.toBeVisible();
			
			        // # Expand to full view
			        await waitFor(postListPostItemTableExpandButton).toBeVisible().whileElement(by.id(ChannelScreen.postList.testID.flatList)).scroll(50, 'down');
			        await postListPostItemTableExpandButton.tap();
			        await TableScreen.toBeVisible();
			        await expect(element(by.text('Header VS last'))).toBeVisible();
			        await expect(element(by.text('Right VS last'))).not.toBeVisible();
			
			        // * Verify table screen is scrollable to the bottom
			        const expectedElement = element(by.text('Right VS last'));
			        await waitFor(expectedElement).toBeVisible().whileElement(by.id(TableScreen.testID.tableScrollView)).scroll(50, 'down');
			        await expect(element(by.text('Header VS last'))).not.toBeVisible();
			        await expect(expectedElement).toBeVisible();
			
			        // # Go back to channel list screen
			        await TableScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4899_5 - should be able to open markdown table in full view and allow both horizontal and vertical scrolls', async () => \{
			        // # Open a channel screen and post a markdown table with more columns and rows past horizontal and vertical views
			        const markdownTable =
			            '| Header | Header | Header | Header | Header | Header | Header | Header last |\\n' +
			            '| :-- | :-: | --: | --: | :-- | :-: | --: | --: |\\n' +
			            '| Left | Center | Right | Right | Left | Center | Right | Right |\\n'.repeat(30) +
			            '| Left | Center | Right | Right | Left | Center | Right | Right last |\\n';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: markdownTable,
			        \});
			
			        // * Verify table is displayed with some right columns and bottom rows not visible
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemTable, postListPostItemTableExpandButton\} = ChannelScreen.getPostListPostItem(post.id);
			        await expect(postListPostItemTable).toBeVisible();
			        await expect(element(by.text('Header last'))).not.toBeVisible();
			        await expect(element(by.text('Right last'))).not.toBeVisible();
			
			        // # Expand to full view
			        await waitFor(postListPostItemTableExpandButton).toBeVisible().whileElement(by.id(ChannelScreen.postList.testID.flatList)).scroll(50, 'down');
			        await postListPostItemTableExpandButton.tap();
			        await TableScreen.toBeVisible();
			        await expect(element(by.text('Header last'))).not.toBeVisible();
			        await expect(element(by.text('Right last'))).not.toBeVisible();
			
			        // * Verify table screen is scrollable to the right and scrollable to the bottom
			        await TableScreen.tableScrollView.scrollTo('right');
			        await expect(element(by.text('Header last'))).toBeVisible();
			        await expect(element(by.text('Right last'))).not.toBeVisible();
			        const expectedElement = element(by.text('Right last'));
			        await waitFor(expectedElement).toBeVisible().whileElement(by.id(TableScreen.testID.tableScrollView)).scroll(50, 'down');
			        await expect(element(by.text('Header last'))).not.toBeVisible();
			        await expect(expectedElement).toBeVisible();
			
			        // # Go back to channel list screen
			        await TableScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\markdown_table.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_delete.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Message Delete', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4784_1 - should be able to delete a post message and confirm', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for the message that was just posted, tap delete option and confirm
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify post message is deleted
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4784_2 - should be able to delete a post message and cancel', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for the message that was just posted, tap delete option and cancel
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.deletePost(\{confirm: false\});
			
			        // * Verify post message is not deleted
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4784_3 - should be able to delete a post message from reply thread', async () => \{
			        // # Open a channel screen, post a message, and tap on the post to open reply thread
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: parentPostListPostItem\} = ChannelScreen.getPostListPostItem(parentPost.id, message);
			        await parentPostListPostItem.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Post a reply, open post options for the reply message, tap delete option and confirm
			        const replyMessage = \`\$\{message\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ChannelScreen.getPostListPostItem(replyPost.id, replyMessage);
			        await ThreadScreen.openPostOptionsFor(replyPost.id, replyMessage);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify reply message is deleted
			        await expect(replyPostListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_delete.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_draft.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Alert\} from '@support/ui/component';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isIos\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Message Draft', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const offTopicChannelName = 'off-topic';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4781_1 - should be able to create a message draft', async () => \{
			        // # Open a channel screen and create a message draft
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postInput.tap();
			        await ChannelScreen.postInput.replaceText(message);
			
			        // * Verify message exists in post draft and is not yet added to post list
			        if (isIos()) \{
			            await expect(ChannelScreen.postInput).toHaveValue(message);
			        \} else \{
			            await expect(ChannelScreen.postInput).toHaveText(message);
			        \}
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).not.toExist();
			
			        // # Switch to another channel and go back to original channel
			        await ChannelScreen.back();
			        await ChannelScreen.open(channelsCategory, offTopicChannelName);
			        await ChannelScreen.back();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			
			        // * Verify message draft still exists in post draft
			        if (isIos()) \{
			            await expect(ChannelScreen.postInput).toHaveValue(message);
			        \} else \{
			            await expect(ChannelScreen.postInput).toHaveText(message);
			        \}
			
			        // # Clear post draft and go back to channel list screen
			        await ChannelScreen.postInput.clearText();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4781_2 - should save message draft when app is closed then re-opened', async () => \{
			        // # Open a channel screen and create a message draft
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postInput.tap();
			        await ChannelScreen.postInput.replaceText(message);
			
			        // * Verify message draft exists in post draft
			        if (isIos()) \{
			            await expect(ChannelScreen.postInput).toHaveValue(message);
			        \} else \{
			            await expect(ChannelScreen.postInput).toHaveText(message);
			        \}
			
			        // # Send app to home and re-open
			        await device.sendToHome();
			        await device.launchApp(\{newInstance: false\});
			
			        // * Verify message draft still exists in post draft
			        if (isIos()) \{
			            await expect(ChannelScreen.postInput).toHaveValue(message);
			        \} else \{
			            await expect(ChannelScreen.postInput).toHaveText(message);
			        \}
			
			        // # Clear post draft and go back to channel list screen
			        await ChannelScreen.postInput.clearText();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4781_3 - should show character count warning when message exceeds character limit', async () => \{
			        // # Open a channel screen and create a message draft that exceeds character limit (> 16383)
			        let message = '1234567890'.repeat(1638) + '1234';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postInput.tap();
			        await ChannelScreen.postInput.replaceText(message);
			
			        // * Verify warning message is displayed and send button is disabled
			        await expect(Alert.messageLengthTitle).toBeVisible();
			        await expect(element(by.text('Your current message is too long. Current character count: 16384/16383'))).toBeVisible();
			        await Alert.okButton.tap();
			        await expect(ChannelScreen.sendButtonDisabled).toBeVisible();
			
			        // # Replace message draft with length less than the character limit (16383)
			        message = '1234567890'.repeat(1638) + '123';
			        await ChannelScreen.postInput.replaceText(message);
			
			        // * Verify warning message is not displayed and send button is enabled
			        await expect(Alert.messageLengthTitle).not.toBeVisible();
			        await expect(element(by.text('Your current message is too long. Current character count: 16383/16383'))).not.toBeVisible();
			        await expect(ChannelScreen.sendButton).toBeVisible();
			
			        // # Clear post draft and go back to channel list screen
			        await ChannelScreen.postInput.clearText();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4781_4 - should be able to create a message draft from reply thread -- KNOWN ISSUE: MM-50298', async () => \{
			        // # Open a channel screen, post a message, and tap on the post to open reply thread
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: parentPostListPostItem\} = ChannelScreen.getPostListPostItem(parentPost.id, message);
			        await parentPostListPostItem.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Create a reply message draft
			        const replyMessage = \`\$\{message\} reply\`;
			        await ThreadScreen.postInput.tap();
			        await ThreadScreen.postInput.replaceText(replyMessage);
			
			        // * Verify reply message exists in post draft and is not yet added to post list
			        if (isIos()) \{
			            await expect(ThreadScreen.postInput).toHaveValue(replyMessage);
			        \} else \{
			            await expect(ThreadScreen.postInput).toHaveText(replyMessage);
			        \}
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ThreadScreen.getPostListPostItem(post.id, replyMessage);
			        await expect(replyPostListPostItem).not.toExist();
			
			        // # Go back to channel screen and tap on parent post again
			        await ThreadScreen.back();
			        await parentPostListPostItem.tap();
			
			        // * Verify reply message draft still exists in post draft
			        if (isIos()) \{
			            await expect(ThreadScreen.postInput).toHaveValue(replyMessage);
			        \} else \{
			            await expect(ThreadScreen.postInput).toHaveText(replyMessage);
			        \}
			
			        // # Clear reply post draft and go back to channel list screen
			        await ThreadScreen.postInput.clearText();
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_draft.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_edit.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    EditPostScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Message Edit', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4783_1 - should be able to edit a post message and save', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: originalPostListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(originalPostListPostItem).toBeVisible();
			
			        // # Open post options for the message that was just posted and tap edit option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit post message and tap save button
			        const updatedMessage = \`\$\{message\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedMessage);
			        await EditPostScreen.saveButton.tap();
			
			        // * Verify post message is updated and displays edited indicator '(edited)'
			        const \{postListPostItem: updatedPostListPostItem, postListPostItemEditedIndicator\} = ChannelScreen.getPostListPostItem(post.id, updatedMessage);
			        await expect(updatedPostListPostItem).toBeVisible();
			        await expect(postListPostItemEditedIndicator).toHaveText('(edited)');
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4783_2 - should be able to edit a post message and cancel', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for the message that was just posted and tap edit option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit post message and tap close button
			        const updatedMessage = \`\$\{message\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedMessage);
			        await EditPostScreen.closeButton.tap();
			
			        // * Verify post message is not updated
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4783_3 - should be able to edit a post message from reply thread', async () => \{
			        // # Open a channel screen, post a message, and tap on the post to open reply thread
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: parentPostListPostItem\} = ChannelScreen.getPostListPostItem(parentPost.id, message);
			        await parentPostListPostItem.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Post a reply, open post options for the reply message and tap edit option
			        const replyMessage = \`\$\{message\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ThreadScreen.openPostOptionsFor(replyPost.id, replyMessage);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit reply post message and tap save button
			        const updatedReplyMessage = \`\$\{replyMessage\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedReplyMessage);
			        await EditPostScreen.saveButton.tap();
			
			        // * Verify reply post message is updated and displays edited indicator '(edited)'
			        const \{postListPostItem: updatedReplyPostListPostItem, postListPostItemEditedIndicator\} = ThreadScreen.getPostListPostItem(replyPost.id, updatedReplyMessage);
			        await expect(updatedReplyPostListPostItem).toBeVisible();
			        await expect(postListPostItemEditedIndicator).toHaveText('(edited)');
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_edit.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_post.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isAndroid, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Message Post', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4782_1 - should be able to post a message when send button is tapped', async () => \{
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			
			        // * Verify send button is disabled
			        await expect(ChannelScreen.sendButtonDisabled).toBeVisible();
			
			        // # Create a message draft
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.postInput.tap();
			        await ChannelScreen.postInput.replaceText(message);
			
			        // * Verify send button is enabled
			        await expect(ChannelScreen.sendButton).toBeVisible();
			
			        // # Tap send button
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify message is added to post list, cleared from post draft, and send button is disabled again
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			        await expect(ChannelScreen.postInput).not.toHaveValue(message);
			        await expect(ChannelScreen.sendButtonDisabled).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4782_2 - should be able to post a long message', async () => \{
			        // # Open a channel screen, post a long message, and a short message after
			        const longMessage = 'The quick brown fox jumps over the lazy dog.'.repeat(20);
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(longMessage);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.postMessage('short message');
			
			        // * Verify long message is posted and displays show more button (chevron down button)
			        if (isAndroid()) \{
			            await device.pressBack();
			            await wait(timeouts.ONE_SEC);
			        \}
			        const \{postListPostItem, postListPostItemShowLessButton, postListPostItemShowMoreButton\} = ChannelScreen.getPostListPostItem(post.id, longMessage);
			        await expect(postListPostItem).toBeVisible();
			        await expect(postListPostItemShowMoreButton).toBeVisible();
			
			        // # Tap on show more button on long message post
			        await postListPostItemShowMoreButton.tap();
			
			        // * Verify long message post displays show less button (chevron up button)
			        await expect(postListPostItemShowLessButton).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_post.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_reply.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Message Reply', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4785_1 - should be able to reply to a post via post options reply option', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for the message that was just posted, tap reply option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.replyPostOption.tap();
			
			        // * Verify on reply thread screen and parent post is shown
			        await ThreadScreen.toBeVisible();
			        const \{postListPostItem: threadParentPostListPostItem\} = ThreadScreen.getPostListPostItem(post.id, message);
			        await expect(threadParentPostListPostItem).toBeVisible();
			
			        // # Reply to parent post
			        const replyMessage = \`\$\{message\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			
			        // * Verify reply message is posted
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			        await expect(replyPostListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4785_2 - should be able to open reply thread by tapping on the post', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Tap on post to open thread
			        await postListPostItem.tap();
			
			        // * Verify on reply thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4785_3 - should not have reply option available on reply thread post options -- KNOWN ISSUE: MM-50206', async () => \{
			        // # Open a channel screen, post a message, and tap on the post
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await postListPostItem.tap();
			
			        // * Verify on reply thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Open post options for the parent message
			        await ThreadScreen.openPostOptionsFor(post.id, message);
			
			        // * Verify reply option is not available
			        await expect(PostOptionsScreen.replyPostOption).not.toExist();
			
			        // # Go back to channel list screen
			        await PostOptionsScreen.close();
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\message_reply.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\permalink.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Post,
			    Setup,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    PermalinkScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Permalink', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    const expectPermalinkTargetMessage = async (teamName: any, permalinkTargetPost: any, permalinkTargetChannelDiplayName: string) => \{
			        // # Open a channel screen, post a permalink to target post, and tap on permalink
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        const permalinkLabel = \`permalink-\$\{getRandomId()\}\`;
			        const permalinkMessage = \`[\$\{permalinkLabel\}](/\$\{teamName\}/pl/\$\{permalinkTargetPost.id\})\`;
			        await ChannelScreen.postMessage(permalinkMessage);
			        await element(by.text(permalinkLabel)).tap(\{x: 5, y: 10\});
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify on permalink screen and target post is displayed
			        await PermalinkScreen.toBeVisible();
			        const \{postListPostItem: permalinkPostListPostItem\} = PermalinkScreen.getPostListPostItem(permalinkTargetPost.id, permalinkTargetPost.message);
			        await expect(permalinkPostListPostItem).toBeVisible();
			
			        // # Jump to recent messages
			        await PermalinkScreen.jumpToRecentMessages();
			
			        // * Verify on channel screen and target post is displayed
			        await expect(ChannelScreen.headerTitle).toHaveText(permalinkTargetChannelDiplayName);
			        const \{postListPostItem: channelPostListPostItem\} = ChannelScreen.getPostListPostItem(permalinkTargetPost.id, permalinkTargetPost.message);
			        await expect(channelPostListPostItem).toBeVisible();
			    \};
			
			    it('MM-T4876_1 - should be able to jump to target public channel post by tapping on permalink with team name', async () => \{
			        // # Post a target message in a target public channel
			        const permalinkTargetMessage = \`Message \$\{getRandomId()\}\`;
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const permalinkTargetPost = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: targetChannel.id,
			            message: permalinkTargetMessage,
			        \});
			
			        await expectPermalinkTargetMessage(testTeam.name, permalinkTargetPost.post, targetChannel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4876_2 - should be able to jump to target public channel post by tapping on permalink with _redirect', async () => \{
			        // # Post a target message in a target public channel
			        const permalinkTargetMessage = \`Message \$\{getRandomId()\}\`;
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const permalinkTargetPost = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: targetChannel.id,
			            message: permalinkTargetMessage,
			        \});
			
			        await expectPermalinkTargetMessage('_redirect', permalinkTargetPost.post, targetChannel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4876_3 - should be able to jump to target DM post by tapping on permalink with team name', async () => \{
			        // # Post a target message in a target DM channel
			        const \{user: dmOtherUser\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'testchannel-1'\});
			        const \{channel: targetChannel\} = await Channel.apiCreateDirectChannel(siteOneUrl, [testUser.id, dmOtherUser.id]);
			        const permalinkTargetMessage = \`Message \$\{getRandomId()\}\`;
			        const permalinkTargetPost = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: targetChannel.id,
			            message: permalinkTargetMessage,
			        \});
			
			        await expectPermalinkTargetMessage(testTeam.name, permalinkTargetPost.post, dmOtherUser.username);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4876_4 - should be able to jump to target DM post by tapping on permalink with _redirect', async () => \{
			        // # Post a target message in a target DM channel
			        const \{user: dmOtherUser\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'testchannel-1'\});
			        const \{channel: targetChannel\} = await Channel.apiCreateDirectChannel(siteOneUrl, [testUser.id, dmOtherUser.id]);
			        const permalinkTargetMessage = \`Message \$\{getRandomId()\}\`;
			        const permalinkTargetPost = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: targetChannel.id,
			            message: permalinkTargetMessage,
			        \});
			
			        await expectPermalinkTargetMessage('_redirect', permalinkTargetPost.post, dmOtherUser.username);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\permalink.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\pin_and_unpin_message.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Pin and Unpin Message', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const pinnedText = 'Pinned';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4865_1 - should be able to pin/unpin a message via post options on channel screen', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for message and tap on pin to channel option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			
			        // * Verify pinned text is displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItemPreHeaderText\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemPreHeaderText).toHaveText(pinnedText);
			
			        // # Open post options for message and tap on unpin from channel option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.unpinPostOption.tap();
			
			        // * Verify pinned text is not displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        await expect(postListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4865_2 - should be able to pin/unpin a message via post options on thread screen', async () => \{
			        // # Open a channel screen, post a message, tap on post to open thread, open post options for message, and tap on pin to channel option
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await postListPostItem.tap();
			        await ThreadScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			
			        // * Verify pinned text is displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItemPreHeaderText\} = ThreadScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemPreHeaderText).toHaveText(pinnedText);
			
			        // # Open post options for message and tap on unpin from channel option
			        await ThreadScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.unpinPostOption.tap();
			
			        // * Verify pinned text is not displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        await expect(postListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\pin_and_unpin_message.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\save_and_unsave_message.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Messaging - Save and Unsave Message', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const savedText = 'Saved';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4864_1 - should be able to save/unsave a message via post options on channel screen', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for message and tap on save option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			
			        // * Verify saved text is displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItemPreHeaderText\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemPreHeaderText).toHaveText(savedText);
			
			        // # Open post options for message and tap on unsave option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.unsavePostOption.tap();
			
			        // * Verify saved text is not displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        await expect(postListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4864_2 - should be able to save/unsave a message via post options on thread screen', async () => \{
			        // # Open a channel screen, post a message, tap on post to open thread, open post options for message, and tap on save option
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await postListPostItem.tap();
			        await ThreadScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			
			        // * Verify saved text is displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItemPreHeaderText\} = ThreadScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemPreHeaderText).toHaveText(savedText);
			
			        // # Open post options for message and tap on unsave option
			        await ThreadScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.unsavePostOption.tap();
			
			        // * Verify saved text is not displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        await expect(postListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\messaging\\save_and_unsave_message.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\pinned_messages.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    EditPostScreen,
			    HomeScreen,
			    LoginScreen,
			    PermalinkScreen,
			    PostOptionsScreen,
			    PinnedMessagesScreen,
			    SavedMessagesScreen,
			    ServerScreen,
			    ThreadScreen,
			    ChannelInfoScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Search - Pinned Messages', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const pinnedText = 'Pinned';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4918_1 - should match elements on pinned messages screen', async () => \{
			        // # Open a channel screen, open channel info screen, and open pinned messages screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify basic elements on pinned messages screen
			        await expect(PinnedMessagesScreen.emptyTitle).toHaveText('No pinned messages yet');
			        await expect(PinnedMessagesScreen.emptyParagraph).toHaveText('To pin important messages, long-press on a message and choose Pin To Channel. Pinned messages will be visible to everyone in this channel.');
			
			        // # Go back to channel list screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4918_2 - should be able to display a pinned message in pinned messages screen and navigate to message channel', async () => \{
			        // # Open a channel screen, post a message, open post options for message, and tap on pin to channel option
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			
			        // * Verify pinned text is displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItemPreHeaderText\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemPreHeaderText).toHaveText(pinnedText);
			
			        // # Open channel info screen and open pinned messages screen
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify on pinned messages screen and pinned message is displayed
			        await PinnedMessagesScreen.toBeVisible();
			        const \{postListPostItem: pinnedMessagesPostListPostItem\} = PinnedMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(pinnedMessagesPostListPostItem).toBeVisible();
			
			        // # Tap on post and jump to recent messages
			        await pinnedMessagesPostListPostItem.tap();
			        await PermalinkScreen.jumpToRecentMessages();
			
			        // * Verify on channel screen and pinned message is displayed
			        await ChannelScreen.toBeVisible();
			        const \{postListPostItem: channelPostListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(channelPostListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4918_3 - should be able to edit, reply to, and delete a pinned message from pinned messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on pin to channel option, open channel info screen, and open pinned messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: pinnedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(pinnedPost.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify on pinned messages screen
			        await PinnedMessagesScreen.toBeVisible();
			
			        // # Open post options for pinned message and tap on edit option
			        await PinnedMessagesScreen.openPostOptionsFor(pinnedPost.id, message);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit post message and tap save button
			        const updatedMessage = \`\$\{message\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedMessage);
			        await EditPostScreen.saveButton.tap();
			
			        // * Verify post message is updated and displays edited indicator '(edited)'
			        const \{postListPostItem: updatedPostListPostItem, postListPostItemEditedIndicator\} = PinnedMessagesScreen.getPostListPostItem(pinnedPost.id, updatedMessage);
			        await expect(updatedPostListPostItem).toBeVisible();
			        await expect(postListPostItemEditedIndicator).toHaveText('(edited)');
			
			        // # Open post options for updated pinned message and tap on reply option
			        await PinnedMessagesScreen.openPostOptionsFor(pinnedPost.id, updatedMessage);
			        await PostOptionsScreen.replyPostOption.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Post a reply
			        const replyMessage = \`\$\{updatedMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			
			        // * Verify reply is posted
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			        await expect(replyPostListPostItem).toBeVisible();
			
			        // # Go back to pinned messages screen
			        await ThreadScreen.back();
			
			        // * Verify reply count and following button
			        const \{postListPostItem, postListPostItemFooterReplyCount, postListPostItemFooterFollowingButton\} = PinnedMessagesScreen.getPostListPostItem(pinnedPost.id, updatedMessage);
			        await expect(postListPostItemFooterReplyCount).toHaveText('1 reply');
			        await expect(postListPostItemFooterFollowingButton).toBeVisible();
			
			        // # Open post options for updated pinned message and delete post
			        await PinnedMessagesScreen.openPostOptionsFor(pinnedPost.id, updatedMessage);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify updated pinned message is deleted
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4918_4 - should be able to unpin a message from pinned messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on pin to channel option, open channel info screen, and open pinned messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: pinnedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(pinnedPost.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify on pinned messages screen
			        await PinnedMessagesScreen.toBeVisible();
			
			        // # Open post options for pinned message and tap on unpin from channel option
			        await PinnedMessagesScreen.openPostOptionsFor(pinnedPost.id, message);
			        await PostOptionsScreen.unpinPostOption.tap();
			
			        // * Verify pinned message is not displayed anymore
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItem\} = PinnedMessagesScreen.getPostListPostItem(pinnedPost.id, message);
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4918_5 - should be able to save/unsave a pinned message from pinned messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on pin to channel option, open channel info screen, and open pinned messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: pinnedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(pinnedPost.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify on pinned messages screen
			        await PinnedMessagesScreen.toBeVisible();
			
			        // # Open post options for pinned message, tap on save option, go back to channel list screen, and open saved messages screen
			        await PinnedMessagesScreen.openPostOptionsFor(pinnedPost.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			
			        // * Verify pinned message is displayed on saved messages screen
			        const \{postListPostItem\} = SavedMessagesScreen.getPostListPostItem(pinnedPost.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to pinned messages screen, open post options for pinned message, tap on usave option, go back to channel list screen, and open saved messages screen
			        await ChannelListScreen.open();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			        await PinnedMessagesScreen.openPostOptionsFor(pinnedPost.id, message);
			        await PostOptionsScreen.unsavePostOption.tap();
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			
			        // * Verify pinned message is not displayed anymore on saved messages screen
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\pinned_messages.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\recent_mentions.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelInfoScreen,
			    ChannelListScreen,
			    ChannelScreen,
			    EditPostScreen,
			    HomeScreen,
			    LoginScreen,
			    PermalinkScreen,
			    PinnedMessagesScreen,
			    PostOptionsScreen,
			    RecentMentionsScreen,
			    SavedMessagesScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Search - Recent Mentions', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4909_1 - should match elements on recent mentions screen', async () => \{
			        // # Open recent mentions screen
			        await RecentMentionsScreen.open();
			
			        // * Verify basic elements on recent mentions screen
			        await expect(RecentMentionsScreen.largeHeaderTitle).toHaveText('Recent Mentions');
			        await expect(RecentMentionsScreen.largeHeaderSubtitle).toHaveText('Messages you\\'ve been mentioned in');
			        await expect(RecentMentionsScreen.emptyTitle).toHaveText('No Mentions yet');
			        await expect(RecentMentionsScreen.emptyParagraph).toHaveText('You\\'ll see messages here when someone mentions you or uses terms you\\'re monitoring.');
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4909_2 - should be able to display a recent mention in recent mentions screen and navigate to message channel', async () => \{
			        // # Open a channel screen and post a message with at-mention to current user
			        const message = \`@\$\{testUser.username\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message with at-mention to current user is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen and open recent mentions screen
			        await ChannelScreen.back();
			        await RecentMentionsScreen.open();
			
			        // * Verify on recent mentions screen and recent mention is displayed with channel info
			        await RecentMentionsScreen.toBeVisible();
			        const \{postListPostItem: recentMentionsPostListPostItem, postListPostItemChannelInfoChannelDisplayName, postListPostItemChannelInfoTeamDisplayName\} = RecentMentionsScreen.getPostListPostItem(post.id, message);
			        await expect(recentMentionsPostListPostItem).toBeVisible();
			        await expect(postListPostItemChannelInfoChannelDisplayName).toHaveText(testChannel.display_name);
			        await expect(postListPostItemChannelInfoTeamDisplayName).toHaveText(testTeam.display_name);
			
			        // # Tap on post and jump to recent messages
			        await recentMentionsPostListPostItem.tap();
			        await PermalinkScreen.jumpToRecentMessages();
			
			        // * Verify on channel screen and recent mention is displayed
			        await ChannelScreen.toBeVisible();
			        const \{postListPostItem: channelPostListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(channelPostListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4909_3 - should be able to edit, reply to, and delete a recent mention from recent mentions screen', async () => \{
			        // # Open a channel screen, post a message with at-mention to current user, go back to channel list screen, and open recent mentions screen
			        const message = \`@\$\{testUser.username\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await RecentMentionsScreen.open();
			
			        // * Verify on recent mentions screen
			        await RecentMentionsScreen.toBeVisible();
			
			        // # Open post options for recent mention and tap on edit option
			        const \{post: mentionPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await RecentMentionsScreen.openPostOptionsFor(mentionPost.id, message);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit post message and tap save button
			        const updatedMessage = \`\$\{message\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedMessage);
			        await EditPostScreen.saveButton.tap();
			
			        // * Verify post message is updated and displays edited indicator '(edited)'
			        const \{postListPostItem: updatedPostListPostItem, postListPostItemEditedIndicator\} = RecentMentionsScreen.getPostListPostItem(mentionPost.id, updatedMessage);
			        await expect(updatedPostListPostItem).toBeVisible();
			        await expect(postListPostItemEditedIndicator).toHaveText('(edited)');
			
			        // # Open post options for recent mention and tap on reply option
			        await RecentMentionsScreen.openPostOptionsFor(mentionPost.id, updatedMessage);
			        await PostOptionsScreen.replyPostOption.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Post a reply
			        const replyMessage = \`\$\{message\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			
			        // * Verify reply is posted
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to recent mentions screen
			        await ThreadScreen.back();
			
			        // * Verify reply count and following button
			        const \{postListPostItemFooterReplyCount, postListPostItemFooterFollowingButton\} = RecentMentionsScreen.getPostListPostItem(mentionPost.id, updatedMessage);
			        await expect(postListPostItemFooterReplyCount).toHaveText('1 reply');
			        await expect(postListPostItemFooterFollowingButton).toBeVisible();
			
			        // # Open post options for updated recent mention and delete post
			        await RecentMentionsScreen.openPostOptionsFor(mentionPost.id, updatedMessage);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify updated recent mention is deleted
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4909_4 - should be able to save/unsave a recent mention from recent mentions screen', async () => \{
			        // # Open a channel screen, post a message with at-mention to current user, go back to channel list screen, and open recent mentions screen
			        const message = \`@\$\{testUser.username\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await RecentMentionsScreen.open();
			
			        // * Verify on recent mentions screen
			        await RecentMentionsScreen.toBeVisible();
			
			        // # Open post options for recent mention, tap on save option, and open saved messages screen
			        const \{post: mentionPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await RecentMentionsScreen.openPostOptionsFor(mentionPost.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			        await SavedMessagesScreen.open();
			
			        // * Verify recent mention is displayed on saved messages screen
			        const \{postListPostItem\} = SavedMessagesScreen.getPostListPostItem(mentionPost.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to recent mentions screen, open post options for recent mention, tap on usave option, and open saved messages screen
			        await RecentMentionsScreen.open();
			        await RecentMentionsScreen.openPostOptionsFor(mentionPost.id, message);
			        await PostOptionsScreen.unsavePostOption.tap();
			        await SavedMessagesScreen.open();
			
			        // * Verify recent mention is not displayed anymore on saved messages screen
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4909_5 - should be able to pin/unpin a recent mention from recent mentions screen', async () => \{
			        // # Open a channel screen, post a message with at-mention to current user, go back to channel list screen, and open recent mentions screen
			        const message = \`@\$\{testUser.username\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await RecentMentionsScreen.open();
			
			        // * Verify on recent mentions screen
			        await RecentMentionsScreen.toBeVisible();
			
			        // # Open post options for recent mention, tap on pin to channel option, go back to channel list screen, open the channel screen where recent mention is posted, open channel info screen, and open pinned messages screen
			        const \{post: mentionPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await RecentMentionsScreen.openPostOptionsFor(mentionPost.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			        await ChannelListScreen.open();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify recent mention is displayed on pinned messages screen
			        const \{postListPostItem\} = PinnedMessagesScreen.getPostListPostItem(mentionPost.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to recent mentions screen, open post options for recent mention, tap on unpin from channel option, go back to channel list screen, open the channel screen where recent mention is posted, open channel info screen, and open pinned messages screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			        await RecentMentionsScreen.open();
			        await RecentMentionsScreen.openPostOptionsFor(mentionPost.id, message);
			        await PostOptionsScreen.unpinPostOption.tap();
			        await ChannelListScreen.open();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify recent mention is not displayed anymore on pinned messages screen
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\recent_mentions.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\saved_messages.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelInfoScreen,
			    ChannelListScreen,
			    ChannelScreen,
			    EditPostScreen,
			    HomeScreen,
			    LoginScreen,
			    PermalinkScreen,
			    PinnedMessagesScreen,
			    PostOptionsScreen,
			    SavedMessagesScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Search - Saved Messages', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const savedText = 'Saved';
			    let testChannel: any;
			    let testTeam: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4910_1 - should match elements on saved messages screen', async () => \{
			        // # Open saved messages screen
			        await SavedMessagesScreen.open();
			
			        // * Verify basic elements on saved messages screen
			        await expect(SavedMessagesScreen.largeHeaderTitle).toHaveText('Saved Messages');
			        await expect(SavedMessagesScreen.largeHeaderSubtitle).toHaveText('All messages you\\'ve saved for follow up');
			        await expect(SavedMessagesScreen.emptyTitle).toHaveText('No saved messages yet');
			        await expect(SavedMessagesScreen.emptyParagraph).toHaveText('To save something for later, long-press on a message and choose Save from the menu. Saved messages are only visible to you.');
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4910_2 - should be able to display a saved message in saved messages screen and navigate to message channel', async () => \{
			        // # Open a channel screen, post a message, open post options for message, and tap on save option
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			
			        // * Verify saved text is displayed on the post pre-header
			        const \{postListPostItemPreHeaderText\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemPreHeaderText).toHaveText(savedText);
			
			        // # Go back to channel list screen and open saved messages screen
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			
			        // * Verify on saved messages screen and saved message is displayed with channel info
			        await SavedMessagesScreen.toBeVisible();
			        const \{postListPostItem: savedMessagesPostListPostItem, postListPostItemChannelInfoChannelDisplayName, postListPostItemChannelInfoTeamDisplayName\} = SavedMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(savedMessagesPostListPostItem).toBeVisible();
			        await expect(postListPostItemChannelInfoChannelDisplayName).toHaveText(testChannel.display_name);
			        await expect(postListPostItemChannelInfoTeamDisplayName).toHaveText(testTeam.display_name);
			
			        // # Tap on post and jump to recent messages
			        await savedMessagesPostListPostItem.tap();
			        await PermalinkScreen.jumpToRecentMessages();
			
			        // * Verify on channel screen and saved message is displayed
			        await ChannelScreen.toBeVisible();
			        const \{postListPostItem: channelPostListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(channelPostListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4910_3 - should be able to edit, reply to, and delete a saved message from saved messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on save option, go back to channel list screen, and open saved messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: savedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(savedPost.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			
			        // * Verify on saved messages screen
			        await SavedMessagesScreen.toBeVisible();
			
			        // # Open post options for saved message and tap on edit option
			        await SavedMessagesScreen.openPostOptionsFor(savedPost.id, message);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit post message and tap save button
			        const updatedMessage = \`\$\{message\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedMessage);
			        await EditPostScreen.saveButton.tap();
			
			        // * Verify post message is updated and displays edited indicator '(edited)'
			        const \{postListPostItem: updatedPostListPostItem, postListPostItemEditedIndicator\} = SavedMessagesScreen.getPostListPostItem(savedPost.id, updatedMessage);
			        await expect(updatedPostListPostItem).toBeVisible();
			        await expect(postListPostItemEditedIndicator).toHaveText('(edited)');
			
			        // # Open post options for updated saved message and tap on reply option
			        await SavedMessagesScreen.openPostOptionsFor(savedPost.id, updatedMessage);
			        await PostOptionsScreen.replyPostOption.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Post a reply
			        const replyMessage = \`\$\{updatedMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			
			        // * Verify reply is posted
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			        await expect(replyPostListPostItem).toBeVisible();
			
			        // # Go back to saved messages screen
			        await ThreadScreen.back();
			
			        // * Verify reply count and following button
			        const \{postListPostItem, postListPostItemFooterReplyCount, postListPostItemFooterFollowingButton\} = SavedMessagesScreen.getPostListPostItem(savedPost.id, updatedMessage);
			        await expect(postListPostItemFooterReplyCount).toHaveText('1 reply');
			        await expect(postListPostItemFooterFollowingButton).toBeVisible();
			
			        // # Open post options for updated saved message and delete post
			        await SavedMessagesScreen.openPostOptionsFor(savedPost.id, updatedMessage);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify updated saved message is deleted
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4910_4 - should be able to unsave a message from saved messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on save option, go back to channel list screen, and open saved messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: savedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(savedPost.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			
			        // * Verify on saved messages screen
			        await SavedMessagesScreen.toBeVisible();
			
			        // # Open post options for saved message and tap on unsave option
			        await SavedMessagesScreen.openPostOptionsFor(savedPost.id, message);
			        await PostOptionsScreen.unsavePostOption.tap();
			
			        // * Verify saved message is not displayed anymore
			        const \{postListPostItem\} = SavedMessagesScreen.getPostListPostItem(savedPost.id, message);
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4910_5 - should be able to pin/unpin a saved message from saved messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on save option, go back to channel list screen, and open saved messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post: savedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(savedPost.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			
			        // * Verify on saved messages screen
			        await SavedMessagesScreen.toBeVisible();
			
			        // # Open post options for saved message, tap on pin to channel option, go back to channel list screen, open the channel screen where saved message is posted, open channel info screen, and open pinned messages screen
			        await SavedMessagesScreen.openPostOptionsFor(savedPost.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			        await ChannelListScreen.open();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify saved message is displayed on pinned messages screen
			        const \{postListPostItem\} = PinnedMessagesScreen.getPostListPostItem(savedPost.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to saved messages screen, open post options for saved message, tap on unpin from channel option, go back to channel list screen, open the channel screen where saved message is posted, open channel info screen, and open pinned messages screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			        await SavedMessagesScreen.openPostOptionsFor(savedPost.id, message);
			        await PostOptionsScreen.unpinPostOption.tap();
			        await ChannelListScreen.open();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify saved message is not displayed anymore on pinned messages screen
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\saved_messages.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\search_messages.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Post,
			    Setup,
			    Team,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelInfoScreen,
			    ChannelListScreen,
			    ChannelScreen,
			    EditPostScreen,
			    HomeScreen,
			    LoginScreen,
			    PinnedMessagesScreen,
			    PostOptionsScreen,
			    SavedMessagesScreen,
			    SearchMessagesScreen,
			    ServerScreen,
			    TeamDropdownMenuScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Search - Search Messages', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5294_1 - should match elements on search messages screen', async () => \{
			        // # Open search messages screen
			        await SearchMessagesScreen.open();
			
			        // * Verify basic elements on search messages screen
			        await expect(SearchMessagesScreen.largeHeaderTitle).toHaveText('Search');
			        await expect(SearchMessagesScreen.searchInput).toBeVisible();
			        await expect(SearchMessagesScreen.searchModifierHeader).toHaveText('Search options');
			        await expect(SearchMessagesScreen.searchModifierFrom).toBeVisible();
			        await expect(SearchMessagesScreen.searchModifierIn).toBeVisible();
			        await expect(SearchMessagesScreen.searchModifierExclude).toBeVisible();
			        await expect(SearchMessagesScreen.searchModifierPhrases).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_2 - should be able to search messages from a specific user', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Tap on from-search-modifier, type in username, tap on user at-mention autocomplete, and tap on search key
			        await SearchMessagesScreen.searchModifierFrom.tap();
			        await SearchMessagesScreen.searchInput.typeText(testUser.username);
			        const \{atMentionItem\} = Autocomplete.getAtMentionItem(testUser.id);
			        await atMentionItem.tap();
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results contain messages from user
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = SearchMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(\`from: \$\{testUser.username\}\`).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_3 - should be able to search messages in a specific channel', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Tap on in-search-modifier, type in channel name, tap on channel mention autocomplete, and tap on search key
			        await SearchMessagesScreen.searchModifierIn.tap();
			        await SearchMessagesScreen.searchInput.typeText(testChannel.name);
			        const \{channelMentionItem\} = Autocomplete.getChannelMentionItem(testChannel.name);
			        await channelMentionItem.tap();
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results contain messages in channel
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = SearchMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(\`channel: \$\{testChannel.name\}\`).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_4 - should be able to search messages excluding search terms', async () => \{
			        // # Open a channel screen, post a message prefix plus non-excluded term, post another message prefix plus excluded term, go back to channel list screen, and open search messages screen
			        const excludedTerm = getRandomId();
			        const messagePrefix = 'Message';
			        const messageWithNonExcludedTerm = \`\$\{messagePrefix\} \$\{getRandomId()\}\`;
			        const messageWithExcludedTerm = \`\$\{messagePrefix\} \$\{excludedTerm\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(messageWithNonExcludedTerm);
			        const \{post: nonExcludedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: nonExcludedPostListPostItem\} = SearchMessagesScreen.getPostListPostItem(nonExcludedPost.id, messageWithNonExcludedTerm);
			        await ChannelScreen.postMessage(messageWithExcludedTerm);
			        const \{post: excludedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: excludedPostListPostItem\} = SearchMessagesScreen.getPostListPostItem(excludedPost.id, messageWithExcludedTerm);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Type in the message prefix, tap on excluded-search modifier, type in the excluded term, and tap on search key
			        await SearchMessagesScreen.searchInput.typeText(messagePrefix);
			        await SearchMessagesScreen.searchModifierExclude.tap();
			        await SearchMessagesScreen.searchInput.typeText(excludedTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results do not contain messages with excluded term
			        await expect(nonExcludedPostListPostItem).toBeVisible();
			        await expect(excludedPostListPostItem).not.toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(\`\$\{messagePrefix\} -\$\{excludedTerm\}\`).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_5 - should be able to search messages with phrases', async () => \{
			        // # Open a channel screen, post a message prefix plus non-included term, post another message prefix plus included term, go back to channel list screen, and open search messages screen
			        const includedTerm = getRandomId();
			        const messagePrefix = 'How are';
			        const messageWithNonIncludedTerm = \`\$\{messagePrefix\} \$\{getRandomId()\}\`;
			        const messageWithIncludedTerm = \`\$\{messagePrefix\} \$\{includedTerm\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(messageWithNonIncludedTerm);
			        const \{post: nonIncludedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: nonIncludedPostListPostItem\} = SearchMessagesScreen.getPostListPostItem(nonIncludedPost.id, messageWithNonIncludedTerm);
			        await ChannelScreen.postMessage(messageWithIncludedTerm);
			        const \{post: includedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: includedPostListPostItem\} = SearchMessagesScreen.getPostListPostItem(includedPost.id, messageWithIncludedTerm);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Type in the message prefix plus included term inside double quotes and tap on search key
			        await SearchMessagesScreen.searchModifierPhrases.tap();
			        await SearchMessagesScreen.searchInput.tapBackspaceKey();
			        await SearchMessagesScreen.searchInput.typeText(messageWithIncludedTerm);
			        await SearchMessagesScreen.searchModifierPhrases.tap();
			        await SearchMessagesScreen.searchInput.tapBackspaceKey();
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results only contain messages with included term
			        await expect(nonIncludedPostListPostItem).not.toBeVisible();
			        await expect(includedPostListPostItem).toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(\`"\$\{messageWithIncludedTerm\} "\`).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_6 - should be able to search messages using combination of modifiers', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Tap on from-search-modifier, type in username, tap on user at-mention autocomplete, tap on in-search-modifier, type in channel, tap on channel mention autocomplete, and tap on search key
			        await SearchMessagesScreen.searchModifierFrom.tap();
			        await SearchMessagesScreen.searchInput.typeText(testUser.username);
			        const \{atMentionItem\} = Autocomplete.getAtMentionItem(testUser.id);
			        await atMentionItem.tap();
			        await SearchMessagesScreen.searchModifierIn.tap();
			        await wait(timeouts.ONE_SEC);
			        await SearchMessagesScreen.searchInput.typeText(testChannel.name);
			        const \{channelMentionItem\} = Autocomplete.getChannelMentionItem(testChannel.name);
			        await channelMentionItem.tap();
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results only contain messages from user in channel
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = SearchMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(\`from: \$\{testUser.username\} channel: \$\{testChannel.name\}\`).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_7 - should be able to search messages using recent searches', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const searchTerm = getRandomId();
			        const message = \`Message \$\{searchTerm\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Type in a search term that will yield results and tap on search key
			        await SearchMessagesScreen.searchInput.typeText(searchTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results contain searched message
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = SearchMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Clear search input and tap on recent search item
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItem(searchTerm).tap();
			
			        // * Verify search results contain searched message
			        await expect(postListPostItem).toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(searchTerm).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_8 - should be able to search messages on a another joined team', async () => \{
			        // # As admin, create a second team, add user to the second team, create a new channel on second team, and add user to new channel; as user, terminate app and relaunch app
			        const \{team: testTeamTwo\} = await Team.apiCreateTeam(siteOneUrl, \{prefix: 'a'\});
			        await Team.apiAddUserToTeam(siteOneUrl, testUser.id, testTeamTwo.id);
			        const \{channel: testChannelTwo\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeamTwo.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, testChannelTwo.id);
			        await device.reloadReactNative();
			
			        // * Verify on first team
			        await expect(ChannelListScreen.headerTeamDisplayName).toHaveText(testTeam.display_name);
			
			        // # Post a message to the new channel on second team and open search messages screen
			        const searchTerm = getRandomId();
			        const message = \`Message \$\{searchTerm\}\`;
			        const \{post\} = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannelTwo.id,
			            message,
			        \});
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Tap on team picker button and tap on second team option
			        await SearchMessagesScreen.teamPickerButton.tap();
			        await TeamDropdownMenuScreen.getTeamIcon(testTeamTwo.id).tap();
			
			        // * Verify team picker button displays second team icon
			        await expect(SearchMessagesScreen.getTeamPickerIcon(testTeamTwo.id)).toBeVisible();
			
			        // # Type in a search term that will yield results for second team and tap on search key
			        await SearchMessagesScreen.searchInput.typeText(searchTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results contain searched message
			        const \{postListPostItem\} = SearchMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Tap on team picker button and tap on first team option
			        await SearchMessagesScreen.teamPickerButton.tap();
			        await TeamDropdownMenuScreen.getTeamIcon(testTeam.id).tap();
			
			        // * Verify team picker button displays first team icon and search results do not contain searched message
			        await expect(SearchMessagesScreen.getTeamPickerIcon(testTeam.id)).toBeVisible();
			        await expect(postListPostItem).not.toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(searchTerm).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_9 - should show empty search results screen when search result is empty', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Type in a search term that will yield no results and tap on search key
			        const searchTerm = getRandomId();
			        await SearchMessagesScreen.searchInput.typeText(searchTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify empty search state for search messages
			        await expect(element(by.text(\`No matches found for “\$\{searchTerm\}”\`))).toBeVisible();
			        await expect(element(by.text('Check the spelling or try another search.'))).toExist();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(searchTerm).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_10 - should be able to edit, reply to, and delete a searched message from search results screen', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const searchTerm = getRandomId();
			        const message = \`Message \$\{searchTerm\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Type in a search term that will yield results, tap on search key, open post options for searched message, and tap on edit option
			        await SearchMessagesScreen.searchInput.typeText(searchTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			        const \{post: searchedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await SearchMessagesScreen.openPostOptionsFor(searchedPost.id, message);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit post message and tap save button
			        const updatedMessage = \`\$\{message\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedMessage);
			        await EditPostScreen.saveButton.tap();
			
			        // * Verify post message is updated and displays edited indicator '(edited)'
			        const \{postListPostItem: updatedPostListPostItem, postListPostItemEditedIndicator\} = SearchMessagesScreen.getPostListPostItem(searchedPost.id, updatedMessage);
			        await expect(updatedPostListPostItem).toBeVisible();
			        await expect(postListPostItemEditedIndicator).toHaveText('(edited)');
			
			        // # Open post options for searched message and tap on reply option
			        await SearchMessagesScreen.openPostOptionsFor(searchedPost.id, updatedMessage);
			        await PostOptionsScreen.replyPostOption.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Post a reply
			        const replyMessage = \`\$\{message\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			
			        // * Verify reply is posted
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to search results screen
			        await ThreadScreen.back();
			
			        // * Verify reply count and following button
			        const \{postListPostItemFooterReplyCount, postListPostItemFooterFollowingButton\} = SearchMessagesScreen.getPostListPostItem(searchedPost.id, updatedMessage);
			        await expect(postListPostItemFooterReplyCount).toHaveText('1 reply');
			        await expect(postListPostItemFooterFollowingButton).toBeVisible();
			
			        // # Open post options for updated searched message and delete post
			        await SearchMessagesScreen.openPostOptionsFor(searchedPost.id, updatedMessage);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify updated searched message is deleted
			        await expect(postListPostItem).not.toExist();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(searchTerm).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_11 - should be able to save/unsave a searched message from search results screen', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const searchTerm = getRandomId();
			        const message = \`Message \$\{searchTerm\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Type in a search term that will yield results, tap on search key, open post options for searched message, tap on save option, and open saved messages screen
			        await SearchMessagesScreen.searchInput.typeText(searchTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			        const \{post: searchedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await SearchMessagesScreen.openPostOptionsFor(searchedPost.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			        await SavedMessagesScreen.open();
			
			        // * Verify searched message is displayed on saved messages screen
			        const \{postListPostItem\} = SavedMessagesScreen.getPostListPostItem(searchedPost.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to searched messages screen, open post options for searched message, tap on usave option, and open saved messages screen
			        await SearchMessagesScreen.open();
			        await SearchMessagesScreen.openPostOptionsFor(searchedPost.id, message);
			        await PostOptionsScreen.unsavePostOption.tap();
			        await SavedMessagesScreen.open();
			
			        // * Verify searched message is not displayed anymore on saved messages screen
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to searched messages screen, clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.open();
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(searchTerm).tap();
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T5294_12 - should be able to pin/unpin a searched message from search results screen', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, and open search messages screen
			        const searchTerm = getRandomId();
			        const message = \`Message \$\{searchTerm\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			
			        // * Verify on search messages screen
			        await SearchMessagesScreen.toBeVisible();
			
			        // # Type in a search term that will yield results, tap on search key, open post options for searched message, tap on pin to channel option, go back to channel list screen, open the channel screen where searched message is posted, open channel info screen, and open pinned messages screen
			        await SearchMessagesScreen.searchInput.typeText(searchTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			        const \{post: searchedPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await SearchMessagesScreen.openPostOptionsFor(searchedPost.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			        await ChannelListScreen.open();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify searched message is displayed on pinned messages screen
			        const \{postListPostItem\} = PinnedMessagesScreen.getPostListPostItem(searchedPost.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to searched messages screen, open post options for searched message, tap on unpin from channel option, go back to channel list screen, open the channel screen where searched message is posted, open channel info screen, and open pinned messages screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			        await SearchMessagesScreen.openPostOptionsFor(searchedPost.id, message);
			        await PostOptionsScreen.unpinPostOption.tap();
			        await ChannelListScreen.open();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify searched message is not displayed anymore on pinned messages screen
			        await expect(postListPostItem).not.toExist();
			
			        // # Go back to searched messages screen, clear search input, remove recent search item, and go back to channel list screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(searchTerm).tap();
			        await ChannelListScreen.open();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\search\\search_messages.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(12)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\server_login\\connect_to_server.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{serverOneUrl\} from '@support/test_config';
			import \{
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Server Login - Connect to Server', () => \{
			    const \{
			        connectButton,
			        connectButtonDisabled,
			        displayHelp,
			        headerDescription,
			        headerTitleConnectToServer,
			        headerWelcome,
			        serverDisplayNameInput,
			        serverUrlInput,
			        serverUrlInputError,
			    \} = ServerScreen;
			
			    beforeEach(async () => \{
			        // * Verify on server screen
			        await ServerScreen.toBeVisible();
			
			        // # Clear fields
			        await serverUrlInput.clearText();
			        await serverDisplayNameInput.clearText();
			    \});
			
			    it('MM-T4676_1 - should match elements on server screen', async () => \{
			        // * Verify basic elements on server screen
			        await expect(headerWelcome).toHaveText('Welcome');
			        await expect(headerTitleConnectToServer).toHaveText('Let’s Connect to a Server');
			        await expect(headerDescription).toHaveText('A server is your team\\'s communication hub accessed using a unique URL');
			        await expect(serverUrlInput).toBeVisible();
			        await expect(serverDisplayNameInput).toBeVisible();
			        await expect(displayHelp).toHaveText('Choose a display name for your server');
			        await expect(connectButtonDisabled).toBeVisible();
			    \});
			
			    it('MM-T4676_2 - should show disabled connect button on empty server url or server display name', async () => \{
			        // # Attempt to connect with empty server url and non-empty server display name
			        await serverUrlInput.replaceText('');
			        await serverDisplayNameInput.replaceText('Server 1');
			
			        // * Verify connect button is disabled
			        await expect(connectButtonDisabled).toBeVisible();
			
			        // # Attempt to connect with valid server url and empty server display name
			        await serverUrlInput.replaceText(serverOneUrl);
			        await serverDisplayNameInput.replaceText('');
			
			        // * Verify connect button is disabled
			        await expect(connectButtonDisabled).toBeVisible();
			    \});
			
			    it('MM-T4676_3 - should show invalid url error on invalid server url', async () => \{
			        // # Connect with invalid server url and non-empty server display name
			        const invalidServerUrl = 'invalid';
			        await serverUrlInput.replaceText(invalidServerUrl);
			        await serverDisplayNameInput.replaceText('Server 1');
			        await connectButton.tap();
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify invalid url error
			        await waitFor(serverUrlInputError).toExist().withTimeout(timeouts.TEN_SEC);
			        await expect(serverUrlInputError).toHaveText('Cannot connect to the server.');
			    \});
			
			    it('MM-T4676_4 - should show connection error on invalid ssl or invalid host', async () => \{
			        // # Connect with invalid ssl and non-empty server display name
			        const connectionError = 'Cannot connect to the server.';
			        await serverUrlInput.replaceText('expired.badssl.com');
			        await serverDisplayNameInput.replaceText('Server 1');
			        await connectButton.tap();
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify connection error
			        await waitFor(serverUrlInputError).toExist().withTimeout(timeouts.TEN_SEC);
			        await expect(serverUrlInputError).toHaveText(connectionError);
			
			        // # Connect with invalid host and valid server display name
			        await device.reloadReactNative();
			        await serverUrlInput.replaceText('wrong.host.badssl.com');
			        await serverDisplayNameInput.replaceText('Server 1');
			        await connectButton.tap();
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify connection error
			        await waitFor(serverUrlInputError).toExist().withTimeout(timeouts.TEN_SEC);
			        await expect(serverUrlInputError).toHaveText(connectionError);
			    \});
			
			    it('MM-T4676_5 - should show login screen on successful connection to server', async () => \{
			        // # Connect to server with valid server url and non-empty server display name
			        await serverUrlInput.replaceText(serverOneUrl);
			        await serverDisplayNameInput.replaceText('Server 1');
			        await connectButton.tap();
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify on login screen
			        await LoginScreen.toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\server_login\\connect_to_server.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\server_login\\login_by_email.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Server Login - Login by Email', () => \{
			    const \{
			        backButton,
			        descriptionEnterCredentials,
			        forgotPasswordButton,
			        passwordInput,
			        passwordInputError,
			        signinButton,
			        signinButtonDisabled,
			        titleLoginToAccount,
			        usernameInput,
			    \} = LoginScreen;
			    const serverOneDisplayName = 'Server 1';
			
			    beforeAll(async () => \{
			        // # Connect to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on login screen
			        await LoginScreen.toBeVisible();
			
			        // # Clear fields
			        await usernameInput.clearText();
			        await passwordInput.clearText();
			    \});
			
			    it('MM-T4677_1 - should match elements on login screen', async () => \{
			        // * Verify basic elements on login screen
			        await expect(backButton).toBeVisible();
			        await expect(titleLoginToAccount).toHaveText('Log In to Your Account');
			        await expect(descriptionEnterCredentials).toHaveText('Enter your login details below.');
			        await expect(usernameInput).toBeVisible();
			        await expect(passwordInput).toBeVisible();
			        await expect(forgotPasswordButton).toBeVisible();
			        await expect(signinButtonDisabled).toBeVisible();
			    \});
			
			    it('MM-T4677_2 - should show disabled signin button on empty username or password', async () => \{
			        // # Log in with empty username and non-empty password
			        await usernameInput.replaceText('');
			        await passwordInput.replaceText('password');
			
			        // * Verify signin button is disabled
			        await expect(signinButtonDisabled).toBeVisible();
			
			        // # Log in with non-empty username and empty password
			        await usernameInput.replaceText('username');
			        await passwordInput.replaceText('');
			
			        // * Verify signin button is disabled
			        await expect(signinButtonDisabled).toBeVisible();
			    \});
			
			    it('MM-T4677_3 - should show incorrect combination error on incorrect credentials', async () => \{
			        // # Log in with incorrect credentials
			        await usernameInput.replaceText('username');
			        await passwordInput.replaceText('password');
			        await signinButton.tap();
			
			        // * Verify incorrect combination error
			        await expect(passwordInputError).toHaveText('The email and password combination is incorrect');
			    \});
			
			    it('MM-T4677_4 - should show channel list screen on successful login', async () => \{
			        // # Log in to server with correct credentials
			        const \{team, user\} = await Setup.apiInit(siteOneUrl);
			        await usernameInput.replaceText(user.username);
			        await passwordInput.replaceText(user.password);
			        await signinButton.tap();
			
			        // * Verify on channel list screen and channel list header shows team display name and server display name
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.headerTeamDisplayName).toHaveText(team.display_name);
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\server_login\\login_by_email.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\server_login\\server_list.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    User,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    serverTwoUrl,
			    serverThreeUrl,
			    siteOneUrl,
			    siteTwoUrl,
			    siteThreeUrl,
			\} from '@support/test_config';
			import \{
			    Alert,
			\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    EditServerScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ServerListScreen,
			\} from '@support/ui/screen';
			import \{isAndroid, isIos, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Server Login - Server List', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const serverTwoDisplayName = 'Server 2';
			    const serverThreeDisplayName = 'Server 3';
			    let serverOneUser: any;
			    let serverTwoUser: any;
			    let serverThreeUser: any;
			
			    beforeAll(async () => \{
			        // # Log in to the first server
			        (\{user: serverOneUser\} = await Setup.apiInit(siteOneUrl));
			        await expect(ServerScreen.headerTitleConnectToServer).toBeVisible();
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(serverOneUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4691_1 - should match elements on server list screen', async () => \{
			        // # Open server list screen
			        await ServerListScreen.open();
			        await ServerListScreen.closeTutorial();
			
			        // * Verify basic elements on server list screen
			        await expect(ServerListScreen.serverListTitle).toHaveText('Your servers');
			        await expect(ServerListScreen.getServerItemActive(serverOneDisplayName)).toBeVisible();
			        await expect(ServerListScreen.addServerButton).toBeVisible();
			
			        // # Go back to channel list screen
			        await ServerListScreen.getServerItemActive(serverOneDisplayName).tap();
			    \});
			
			    it('MM-T4691_2 - should be able to add and log in to new servers', async () => \{
			        // * Verify on channel list screen of the first server
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			
			        // # Open server list screen
			        await ServerListScreen.open();
			        await ServerListScreen.serverListScreen.swipe('up');
			
			        // * Verify first server is active
			        await waitFor(ServerListScreen.getServerItemActive(serverOneDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			
			        // # Add a second server and log in to the second server
			        await User.apiAdminLogin(siteTwoUrl);
			        (\{user: serverTwoUser\} = await Setup.apiInit(siteTwoUrl));
			        await ServerListScreen.addServerButton.tap();
			        await expect(ServerScreen.headerTitleAddServer).toBeVisible();
			        await ServerScreen.connectToServer(serverTwoUrl, serverTwoDisplayName);
			        await LoginScreen.login(serverTwoUser);
			
			        // * Verify on channel list screen of the second server
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverTwoDisplayName);
			
			        // # Open server list screen
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			
			        // * Verify second server is active and first server is inactive
			        await waitFor(ServerListScreen.getServerItemActive(serverTwoDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await waitFor(ServerListScreen.getServerItemInactive(serverOneDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			
			        // # Add a third server and log in to the third server
			        await User.apiAdminLogin(siteThreeUrl);
			        (\{user: serverThreeUser\} = await Setup.apiInit(siteThreeUrl));
			        await ServerListScreen.addServerButton.tap();
			        await expect(ServerScreen.headerTitleAddServer).toBeVisible();
			        await ServerScreen.connectToServer(serverThreeUrl, serverThreeDisplayName);
			        await LoginScreen.login(serverThreeUser);
			
			        // * Verify on channel list screen of the third server
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverThreeDisplayName);
			
			        // # Open server list screen
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			
			        // * Verify third server is active, and first and second servers are inactive
			        await waitFor(ServerListScreen.getServerItemActive(serverThreeDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await waitFor(ServerListScreen.getServerItemInactive(serverOneDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await waitFor(ServerListScreen.getServerItemInactive(serverTwoDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			
			        // # Go back to first server
			        await ServerListScreen.getServerItemInactive(serverOneDisplayName).tap();
			    \});
			
			    it('MM-T4691_3 - should be able to switch to another existing server', async () => \{
			        // * Verify on channel list screen of the first server
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			
			        // # Open server list screen and tap on third server
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemInactive(serverThreeDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemInactive(serverThreeDisplayName).tap();
			
			        // * Verify on channel list screen of the third server
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverThreeDisplayName);
			
			        // # Open server list screen and go back to first server
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemInactive(serverOneDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemInactive(serverOneDisplayName).tap();
			    \});
			
			    it('MM-T4691_4 - should be able to edit server display name of active and inactive servers', async () => \{
			        // * Verify on channel list screen of the first server
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			
			        // # Open server list screen, swipe left on first server and tap on edit option
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemActive(serverOneDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemActive(serverOneDisplayName).swipe('left');
			        await ServerListScreen.getServerItemEditOption(serverOneDisplayName).tap();
			
			        // * Verify on edit server screen
			        await EditServerScreen.toBeVisible();
			
			        // # Enter the same first server display name
			        await EditServerScreen.serverDisplayNameInput.replaceText(serverOneDisplayName);
			
			        // * Verify save button is disabled
			        await expect(EditServerScreen.saveButtonDisabled).toBeVisible();
			
			        // # Enter a new first server display name
			        const newServerOneDisplayName = \`\$\{serverOneDisplayName\} new\`;
			        await EditServerScreen.serverDisplayNameInput.replaceText(newServerOneDisplayName);
			
			        // * Verify save button is enabled
			        await expect(EditServerScreen.saveButton).toBeVisible();
			
			        // # Tap on save button
			        await EditServerScreen.saveButton.tap();
			
			        // * Verify the new first server display name
			        await expect(ServerListScreen.getServerItemActive(newServerOneDisplayName)).toBeVisible();
			
			        // # Revert back to original first server display name and go back to first server
			        await ServerListScreen.getServerItemActive(newServerOneDisplayName).swipe('left');
			        await ServerListScreen.getServerItemEditOption(newServerOneDisplayName).tap();
			        await EditServerScreen.serverDisplayNameInput.replaceText(serverOneDisplayName);
			        await EditServerScreen.saveButton.tap();
			        await ServerListScreen.getServerItemActive(serverOneDisplayName).tap();
			    \});
			
			    it('MM-T4691_5 - should be able to remove a server from the list', async () => \{
			        // * Verify on channel list screen of the first server
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			
			        // # Open server list screen, swipe left on first server and tap on remove option
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemActive(serverOneDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemActive(serverOneDisplayName).swipe('left');
			        await ServerListScreen.getServerItemRemoveOption(serverOneDisplayName).tap();
			
			        // * Verify remove server alert is displayed
			        await expect(Alert.removeServerTitle(serverOneDisplayName)).toBeVisible();
			
			        // # Tap on remove button and go back to server list screen
			        await Alert.removeButton3.tap();
			        await wait(timeouts.ONE_SEC);
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			
			        // * Verify first server is removed
			        await expect(ServerListScreen.getServerItemActive(serverOneDisplayName)).not.toExist();
			        await expect(ServerListScreen.getServerItemInactive(serverOneDisplayName)).not.toExist();
			
			        // # Add first server back to the list and log in to the first server
			        await ServerListScreen.addServerButton.tap();
			        await expect(ServerScreen.headerTitleAddServer).toBeVisible();
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(serverOneUser);
			    \});
			
			    it('MM-T4691_6 - should be able to log out a server from the list', async () => \{
			        // * Verify on channel list screen of the first server
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			
			        // # Open server list screen, swipe left on third server and tap on logout option
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemInactive(serverThreeDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemInactive(serverThreeDisplayName).swipe('left');
			        await ServerListScreen.getServerItemLogoutOption(serverThreeDisplayName).tap();
			
			        // * Verify logout server alert is displayed
			        await expect(Alert.logoutTitle(serverThreeDisplayName)).toBeVisible();
			
			        // # Tap on logout button
			        await Alert.logoutButton3.tap();
			
			        // * Verify third server is logged out
			        await ServerListScreen.getServerItemInactive(serverThreeDisplayName).swipe('left');
			        await expect(ServerListScreen.getServerItemLoginOption(serverThreeDisplayName)).toBeVisible();
			
			        // # Go back to first server
			        await ServerListScreen.getServerItemActive(serverOneDisplayName).tap();
			    \});
			
			    it('MM-T4691_7 - should not be able to add server for an already existing server', async () => \{
			        // * Verify on channel list screen of the first server
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			
			        // # Open server list screen, attempt to add a server already logged in and with inactive session
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            // await ServerListScreen.closeTutorial();
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await ServerListScreen.addServerButton.tap();
			        await expect(ServerScreen.headerTitleAddServer).toBeVisible();
			        await ServerScreen.serverUrlInput.replaceText(serverTwoUrl);
			        if (isAndroid()) \{
			            await ServerScreen.serverUrlInput.tapReturnKey();
			        \}
			        await ServerScreen.serverDisplayNameInput.replaceText(serverTwoDisplayName);
			        if (isAndroid()) \{
			            await ServerScreen.serverDisplayNameInput.tapReturnKey();
			        \}
			
			        if (isIos()) \{
			            await ServerScreen.tapConnectButton();
			        \}
			
			        // * Verify same name server error
			        const sameNameServerError = 'You are using this name for another server.';
			        await expect(ServerScreen.serverDisplayNameInputError).toHaveText(sameNameServerError);
			
			        // # Attempt to add a server already logged in and with active session, with the same server display name
			        await ServerScreen.serverUrlInput.replaceText(serverOneUrl);
			        if (isAndroid()) \{
			            await ServerScreen.serverUrlInput.tapReturnKey();
			        \}
			        await ServerScreen.serverDisplayNameInput.replaceText(serverOneDisplayName);
			        if (isAndroid()) \{
			            await ServerScreen.serverDisplayNameInput.tapReturnKey();
			        \}
			
			        if (isIos()) \{
			            await ServerScreen.tapConnectButton();
			        \}
			
			        // * Verify same name server error
			        await expect(ServerScreen.serverDisplayNameInputError).toHaveText(sameNameServerError);
			
			        // # Close server screen, open server list screen, log out of second server, and go back to first server
			        await ServerScreen.close();
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemInactive(serverTwoDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemInactive(serverTwoDisplayName).swipe('left');
			        await ServerListScreen.getServerItemLogoutOption(serverTwoDisplayName).tap();
			        await Alert.logoutButton2.tap();
			        await ServerListScreen.getServerItemActive(serverOneDisplayName).tap();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\server_login\\server_list.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\account.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    AccountScreen,
			    ClockDisplaySettingsScreen,
			    CustomStatusScreen,
			    DisplaySettingsScreen,
			    EditProfileScreen,
			    EmailNotificationSettingsScreen,
			    EmojiPickerScreen,
			    HomeScreen,
			    LoginScreen,
			    MentionNotificationSettingsScreen,
			    NotificationSettingsScreen,
			    PushNotificationSettingsScreen,
			    ServerScreen,
			    SettingsScreen,
			    ThemeDisplaySettingsScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, isIos, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Smoke Test - Account', () => \{
			    const serverOneDisplayName = 'Server 1';
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{user\} = await Setup.apiInit(siteOneUrl);
			        testUser = user;
			
			        // # Log in to server and go to account screen
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			        await AccountScreen.open();
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on account screen
			        await AccountScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5114_1 - should be able to set user presence and custom status', async () => \{
			        // # Tap on user presence option and tap on online user status option
			        await AccountScreen.userPresenceOption.tap();
			        await wait(timeouts.ONE_SEC);
			        await AccountScreen.onlineUserStatusOption.tap();
			
			        // * Verify on account screen and verify user presence icon and label are for online user status
			        await AccountScreen.toBeVisible();
			        await expect(AccountScreen.getUserPresenceIndicator('online')).toBeVisible();
			        await expect(AccountScreen.getUserPresenceLabel('online')).toHaveText('Online');
			
			        // # Open custom status screen, pick an emoji and type in custom status, and tap on done button
			        const customStatusEmojiName = 'clown_face';
			        const customStatusText = \`Status \$\{getRandomId()\}\`;
			        const customStatusDuration = 'today';
			        await CustomStatusScreen.open();
			        await wait(timeouts.ONE_SEC);
			        await CustomStatusScreen.openEmojiPicker('default', true);
			        await EmojiPickerScreen.searchInput.replaceText(customStatusEmojiName);
			        await element(by.text('🤡')).tap();
			        await wait(timeouts.ONE_SEC);
			        await CustomStatusScreen.statusInput.replaceText(customStatusText);
			        await CustomStatusScreen.doneButton.tap();
			
			        // * Verify on account screen and custom status is set
			        await AccountScreen.toBeVisible();
			        const \{accountCustomStatusEmoji, accountCustomStatusText, accountCustomStatusExpiry\} = AccountScreen.getCustomStatus(customStatusEmojiName, customStatusDuration);
			        await expect(accountCustomStatusEmoji).toBeVisible();
			        await expect(accountCustomStatusText).toHaveText(customStatusText);
			        await expect(accountCustomStatusExpiry).toBeVisible();
			
			        // # Tap on clear button for custom status from display field
			        await AccountScreen.customStatusClearButton.tap();
			
			        // * Verify custom status is cleared from account screen
			        const defaultStatusText = 'Set a custom status';
			        await expect(accountCustomStatusEmoji).not.toExist();
			        await expect(accountCustomStatusText).toHaveText(defaultStatusText);
			        await expect(accountCustomStatusExpiry).not.toExist();
			    \});
			
			    it('MM-T5114_2 - should be able to edit profile', async () => \{
			        // # Open edit profile screen, edit fields, and tap on save button
			        const suffix = getRandomId(3);
			        await EditProfileScreen.open();
			        await EditProfileScreen.firstNameInput.replaceText(\`\$\{testUser.first_name\}\$\{suffix\}\`);
			        await EditProfileScreen.scrollView.tap(\{x: 1, y: 1\});
			        await EditProfileScreen.scrollView.scroll(100, 'down');
			        await EditProfileScreen.usernameInput.clearText();
			        await EditProfileScreen.usernameInput.typeText(\`\$\{testUser.username\}\$\{suffix\}\`);
			        await EditProfileScreen.saveButton.tap();
			
			        // * Verify on account screen and user full name and username are updated
			        await AccountScreen.toBeVisible();
			        const \{userInfoUserDisplayName, userInfoUsername\} = AccountScreen.getUserInfo(testUser.id);
			        await expect(userInfoUserDisplayName).toHaveText(\`\$\{testUser.first_name\}\$\{suffix\} \$\{testUser.last_name\} (\$\{testUser.nickname\})\`);
			        await expect(userInfoUsername).toHaveText(\`@\$\{testUser.username\}\$\{suffix\}\`);
			
			        // # Open edit profile screen, revert back to original field values, and tap on save button
			        await EditProfileScreen.open();
			        await EditProfileScreen.firstNameInput.replaceText(testUser.first_name);
			        await EditProfileScreen.scrollView.tap(\{x: 1, y: 1\});
			        await EditProfileScreen.scrollView.scroll(100, 'down');
			        await EditProfileScreen.usernameInput.clearText();
			        await EditProfileScreen.usernameInput.typeText(testUser.username);
			        await EditProfileScreen.saveButton.tap();
			
			        // * Verify on account screen and user full name and username are reverted back to original values
			        await AccountScreen.toBeVisible();
			        await expect(userInfoUserDisplayName).toHaveText(\`\$\{testUser.first_name\} \$\{testUser.last_name\} (\$\{testUser.nickname\})\`);
			        await expect(userInfoUsername).toHaveText(\`@\$\{testUser.username\}\`);
			    \});
			
			    it('MM-T5114_3 - should be able to set notification settings', async () => \{
			        // # Open settings screen, open notification settings screen, open mention notification settings screen, type in keywords, tap on back button, and go back to mention notification settings screen
			        const keywords = \`\$\{getRandomId()\},\$\{getRandomId()\}\`;
			        await SettingsScreen.open();
			        await NotificationSettingsScreen.open();
			        await MentionNotificationSettingsScreen.open();
			        await MentionNotificationSettingsScreen.keywordsInput.replaceText(keywords);
			        await MentionNotificationSettingsScreen.back();
			        await MentionNotificationSettingsScreen.open();
			
			        // * Verify keywords are saved
			        if (isIos()) \{
			            await expect(MentionNotificationSettingsScreen.keywordsInput).toHaveValue(keywords.toLowerCase());
			        \} else \{
			            await expect(MentionNotificationSettingsScreen.keywordsInput).toHaveText(keywords.toLowerCase());
			        \}
			
			        // # Go back to notification settings screen, open push notification settings screen, tap on mentions only option, tap on mobile away option, tap on back button, and go back to notification settings screen
			        await MentionNotificationSettingsScreen.back();
			        await PushNotificationSettingsScreen.open();
			        await PushNotificationSettingsScreen.mentionsOnlyOption.tap();
			        await PushNotificationSettingsScreen.mobileAwayOption.tap();
			        await PushNotificationSettingsScreen.back();
			        await PushNotificationSettingsScreen.open();
			
			        // * Verify mentions only option and mobile away option are selected
			        await expect(PushNotificationSettingsScreen.mentionsOnlyOptionSelected).toBeVisible();
			        await expect(PushNotificationSettingsScreen.mobileAwayOptionSelected).toBeVisible();
			
			        // # Go back to notification settings screen, open email notification settings screen, tap on immediately option, and tap on back button
			        await PushNotificationSettingsScreen.back();
			        await EmailNotificationSettingsScreen.open();
			        await EmailNotificationSettingsScreen.immediatelyOption.tap();
			        await EmailNotificationSettingsScreen.back();
			
			        // * Verify on notification settings screen and immediately is set
			        await NotificationSettingsScreen.toBeVisible();
			        await expect(NotificationSettingsScreen.emailNotificationsOptionInfo).toHaveText('Immediately');
			
			        // # Go back to account screen
			        await NotificationSettingsScreen.back();
			        await SettingsScreen.close();
			    \});
			
			    it('MM-T5114_4 - should be able to set display settings', async () => \{
			        // # Open settings screen, open display settings screen, open theme display settings screen, and tap on denim option
			        await SettingsScreen.open();
			        await DisplaySettingsScreen.open();
			        await ThemeDisplaySettingsScreen.open();
			        await ThemeDisplaySettingsScreen.denimOption.tap();
			
			        // * Verify on display settings screen and denim is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.themeOptionInfo).toHaveText('Denim');
			
			        // # Open clock display settings screen, select twelve hour option, and tap on back button
			        await ClockDisplaySettingsScreen.open();
			        await ClockDisplaySettingsScreen.twelveHourOption.tap();
			        await ClockDisplaySettingsScreen.back();
			
			        // * Verify on display settings screen and twelve hour is set
			        await DisplaySettingsScreen.toBeVisible();
			        await expect(DisplaySettingsScreen.clockDisplayOptionInfo).toHaveText('12-hour');
			
			        // # Go back to account screen
			        await DisplaySettingsScreen.back();
			        await SettingsScreen.close();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\account.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\autocomplete.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Autocomplete\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{expect\} from 'detox';
			
			describe('Smoke Test - Autocomplete', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open a channel screen
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			    \});
			
			    beforeEach(async () => \{
			        // # Clear post input
			        await ChannelScreen.postInput.clearText();
			
			        // * Verify autocomplete is not displayed
			        await Autocomplete.toBeVisible(false);
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await ChannelScreen.back();
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4886_1 - should be able to select and post at-mention suggestion', async () => \{
			        // # Type in "@" to activate at-mention autocomplete
			        await ChannelScreen.postInput.typeText('@');
			        await Autocomplete.toBeVisible();
			
			        // * Verify at-mention list is displayed
			        await expect(Autocomplete.sectionAtMentionList).toBeVisible();
			
			        // # Type in username
			        await ChannelScreen.postInput.typeText(testUser.username);
			
			        // * Verify at-mention autocomplete contains associated user suggestion
			        const \{atMentionItem\} = Autocomplete.getAtMentionItem(testUser.id);
			        await expect(atMentionItem).toBeVisible();
			
			        // # Select and post at-mention suggestion
			        await atMentionItem.tap();
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify at-mention suggestion is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(post.id, \`@\$\{testUser.username\}\`);
			    \});
			
			    it('MM-T4886_2 - should be able to select and post channel mention suggestion -- KNOWN ISSUE: MM-50351', async () => \{
			        // # Type in "~" to activate channel mention autocomplete
			        await ChannelScreen.postInput.typeText('~');
			        await Autocomplete.toBeVisible();
			
			        // * Verify channel mention list is displayed
			        await expect(Autocomplete.sectionChannelMentionList).toBeVisible();
			
			        // # Type in channel name
			        await ChannelScreen.postInput.typeText(testChannel.name);
			
			        // * Verify channel mention autocomplete contains associated channel suggestion
			        const \{channelMentionItem\} = Autocomplete.getChannelMentionItem(testChannel.name);
			        await expect(channelMentionItem).toBeVisible();
			
			        // # Select and post channel mention suggestion
			        await channelMentionItem.tap();
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify channel mention suggestion is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(post.id, \`~\$\{testChannel.display_name\}\`);
			    \});
			
			    it('MM-T4886_3 - should be able to select and post emoji suggestion', async () => \{
			        // # Type in ":" then first 2 characters of emoji name to activate emoji suggestion autocomplete
			        const emojiName = 'fox_face';
			        const emojiNameFirst2Chars = emojiName.substring(0, 2);
			        const emojiName3rdToLastChars = emojiName.substring(2);
			        await ChannelScreen.postInput.typeText(\`:\$\{emojiNameFirst2Chars\}\`);
			        await Autocomplete.toBeVisible();
			
			        // * Verify emoji suggestion list is displayed
			        await expect(Autocomplete.flatEmojiSuggestionList).toBeVisible();
			
			        // # Type in 3rd to last characters of emoji name
			        await ChannelScreen.postInput.typeText(emojiName3rdToLastChars);
			
			        // * Verify emoji suggestion autocomplete contains associated emoji suggestion
			        const \{emojiSuggestionItem\} = Autocomplete.getEmojiSuggestionItem(emojiName);
			        await expect(emojiSuggestionItem).toBeVisible();
			
			        // # Select and post emoji suggestion
			        await emojiSuggestionItem.tap();
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify emoji suggestion is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(post.id, '🦊');
			    \});
			
			    it('MM-T4886_4 - should be able to select and post slash suggestion -- KNOWN ISSUE: MM-50351', async () => \{
			        // # Type in "/" to activate slash suggestion autocomplete
			        await ChannelScreen.postInput.typeText('/');
			        await Autocomplete.toBeVisible();
			
			        // * Verify slash suggestion list is displayed
			        await expect(Autocomplete.flatSlashSuggestionList).toBeVisible();
			
			        // # Type in slash command name
			        const slashCommand = 'away';
			        await ChannelScreen.postInput.typeText(slashCommand);
			
			        // * Verify slash suggestion autocomplete contains associated slash command suggestion
			        const \{slashSuggestionItem\} = Autocomplete.getSlashSuggestionItem(slashCommand);
			        await expect(slashSuggestionItem).toBeVisible();
			
			        // # Select and post slash suggestion
			        await slashSuggestionItem.tap();
			        await ChannelScreen.sendButton.tap();
			
			        // * Verify slash suggestion is posted
			        await expect(element(by.text('You are now away'))).toBeVisible();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\autocomplete.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\channels.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Post,
			    Setup,
			    Team,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    BrowseChannelsScreen,
			    ChannelScreen,
			    ChannelInfoScreen,
			    ChannelListScreen,
			    CreateDirectMessageScreen,
			    CreateOrEditChannelScreen,
			    FindChannelsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Smoke Test - Channels', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4774_1 - should be able to join a new channel and switch to an existing channel', async () => \{
			        // # As admin, create a new channel so that user can join, then open browse channels screen and join the new channel
			        const \{channel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await BrowseChannelsScreen.open();
			        await BrowseChannelsScreen.searchInput.replaceText(channel.name);
			        await wait(timeouts.ONE_SEC);
			        await BrowseChannelsScreen.getChannelItem(channel.name).multiTap(2);
			
			        // * Verify on newly joined channel screen
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(channel.display_name);
			        await expect(ChannelScreen.introDisplayName).toHaveText(channel.display_name);
			
			        // # Go back to channel list screen and switch to an existing channel
			        await ChannelScreen.back();
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			
			        // * Verify on the other channel screen
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(testChannel.display_name);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4774_2 - should be able to create a channel and create a direct message', async () => \{
			        // # Open create channel screen and create a new channel
			        const displayName = \`Channel \$\{getRandomId()\}\`;
			        await CreateOrEditChannelScreen.openCreateChannel();
			        await CreateOrEditChannelScreen.displayNameInput.replaceText(displayName);
			        await CreateOrEditChannelScreen.createButton.tap();
			
			        // * Verify on newly created public channel
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(displayName);
			        await expect(ChannelScreen.introDisplayName).toHaveText(displayName);
			
			        // # As admin, create a new user to open direct message with, then go back to channel list screen, open create direct message screen and open direct message with new user
			        const \{user: newUser\} = await User.apiCreateUser(siteOneUrl);
			        const newUserDisplayName = newUser.username;
			        await Team.apiAddUserToTeam(siteOneUrl, newUser.id, testTeam.id);
			        await ChannelScreen.back();
			        await CreateDirectMessageScreen.open();
			        await CreateDirectMessageScreen.closeTutorial();
			        await CreateDirectMessageScreen.searchInput.replaceText(newUserDisplayName);
			        await wait(timeouts.ONE_SEC);
			        await CreateDirectMessageScreen.getUserItem(newUser.id).tap();
			        await CreateDirectMessageScreen.startButton.tap();
			
			        // * Verify on direct message channel screen for the new user
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(newUserDisplayName);
			        await expect(ChannelScreen.introDisplayName).toHaveText(newUserDisplayName);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4774_3 - should be able to post a message in a channel', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4774_4 - should be able to find and edit a channel', async () => \{
			        // # Open find channels screen, search for the channel to navigate to, and tap on the target channel item
			        await FindChannelsScreen.open();
			        await FindChannelsScreen.searchInput.replaceText(testChannel.name);
			        await wait(timeouts.ONE_SEC);
			        await FindChannelsScreen.getFilteredChannelItem(testChannel.name).tap();
			
			        // * Verify on target channel screen
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.headerTitle).toHaveText(testChannel.display_name);
			
			        // # Open channel info screen, open edit channel screen, edit channel info, and save changes
			        await ChannelInfoScreen.open();
			        await CreateOrEditChannelScreen.openEditChannel();
			        await CreateOrEditChannelScreen.headerInput.typeText('\\nheader1\\nheader2');
			        await CreateOrEditChannelScreen.saveButton.tap();
			
			        // * Verify on channel info screen and changes have been saved
			        await ChannelInfoScreen.toBeVisible();
			        await expect(element(by.text(\`Channel header: \$\{testChannel.display_name.toLowerCase()\}\\nheader1\\nheader2\`))).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4774_5 - should be able to favorite and mute a channel', async () => \{
			        // # Open a channel screen, open channel info screen, tap on favorite action to favorite the channel, and tap on mute action to mute the channel
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.favoriteAction.tap();
			        await ChannelInfoScreen.muteAction.tap();
			
			        // * Verify channel is favorited and muted
			        await expect(ChannelInfoScreen.unfavoriteAction).toBeVisible();
			        await expect(ChannelInfoScreen.unmuteAction).toBeVisible();
			
			        // # Tap on favorited action to unfavorite the channel and tap on muted action to unmute the channel
			        await ChannelInfoScreen.unfavoriteAction.tap();
			        await ChannelInfoScreen.unmuteAction.tap();
			
			        // * Verify channel is unfavorited and unmuted
			        await expect(ChannelInfoScreen.favoriteAction).toBeVisible();
			        await expect(ChannelInfoScreen.muteAction).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4774_6 - should be able to archive and leave a channel', async () => \{
			        // # Open a channel screen, open channel info screen, and tap on archive channel option and confirm
			        const \{channel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, channel.id);
			        await wait(timeouts.TWO_SEC);
			        await device.reloadReactNative();
			        await ChannelScreen.open(channelsCategory, channel.name);
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.archivePublicChannel(\{confirm: true\});
			
			        // * Verify on channel screen and post draft archived message is displayed
			        await ChannelScreen.toBeVisible();
			        await expect(ChannelScreen.postDraftArchived).toBeVisible();
			        await expect(element(by.text('You are viewing an archived channel. New messages cannot be posted.'))).toBeVisible();
			
			        // # Open channel info screen, and tap on leave channel option and confirm
			        await ChannelInfoScreen.open();
			        await ChannelInfoScreen.leaveChannel(\{confirm: true\});
			
			        // * Verify on channel list screen and the channel left by the user does not appear on the list
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.getChannelItem(channelsCategory, channel.name)).not.toExist();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\channels.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\messaging.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Channel,
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    EditPostScreen,
			    EmojiPickerScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Smoke Test - Messaging', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const savedText = 'Saved';
			    const pinnedText = 'Pinned';
			    let testChannel: any;
			    let testTeam: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, team, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testTeam = team;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4786_1 - should be able to post, edit, and delete a message', async () => \{
			        // # Open a channel screen and post a message
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is added to post list
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: originalPostListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(originalPostListPostItem).toBeVisible();
			
			        // # Open post options for the message that was just posted and tap edit option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.editPostOption.tap();
			
			        // * Verify on edit post screen
			        await EditPostScreen.toBeVisible();
			
			        // # Edit post message and tap save button
			        const updatedMessage = \`\$\{message\} edit\`;
			        await EditPostScreen.messageInput.replaceText(updatedMessage);
			        await EditPostScreen.saveButton.tap();
			
			        // * Verify post message is updated and displays edited indicator '(edited)'
			        const \{postListPostItem: updatedPostListPostItem, postListPostItemEditedIndicator\} = ChannelScreen.getPostListPostItem(post.id, updatedMessage);
			        await expect(updatedPostListPostItem).toBeVisible();
			        await expect(postListPostItemEditedIndicator).toHaveText('(edited)');
			
			        // # Open post options for the updated message, tap delete option and confirm
			        await ChannelScreen.openPostOptionsFor(post.id, updatedMessage);
			        await PostOptionsScreen.deletePost(\{confirm: true\});
			
			        // * Verify post message is deleted
			        await expect(updatedPostListPostItem).not.toExist();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4786_2 - should be able to reply to a message', async () => \{
			        // # Open a channel screen, post a message, and tap on the post
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await postListPostItem.tap();
			
			        // * Verify on reply thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Reply to parent post
			        const replyMessage = \`\$\{message\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			
			        // * Verify reply message is posted
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			        await expect(replyPostListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4786_3 - should be able to include emojis in a message and add reaction to a message', async () => \{
			        // # Open a channel screen and post a message that includes emojis
			        const message = 'The quick brown fox :fox_face: jumps over the lazy dog :dog:';
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify message is posted with emojis
			        const resolvedMessage = 'The quick brown fox 🦊 jumps over the lazy dog 🐶';
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(post.id, resolvedMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Open post options for message, open emoji picker screen, and add a reaction
			        await ChannelScreen.openPostOptionsFor(post.id, resolvedMessage);
			        await EmojiPickerScreen.open(true);
			        await EmojiPickerScreen.searchInput.replaceText('clown_face');
			        await element(by.text('🤡')).tap();
			
			        // * Verify reaction is added to the message
			        await waitFor(element(by.text('🤡').withAncestor(by.id(\`channel.post_list.post.\$\{post.id\}\`)))).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4786_4 - should be able to follow/unfollow a message, save/unsave a message, and pin/unpin a message', async () => \{
			        // # Open a channel screen, post a message, open post options for message, and tap on follow message option
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.followThreadOption.tap();
			
			        // * Verify message is followed by user via post footer
			        const \{postListPostItem, postListPostItemFooterFollowingButton\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await waitFor(postListPostItemFooterFollowingButton).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Tap on following button via post footer
			        await postListPostItemFooterFollowingButton.tap();
			
			        // * Verify message is not followed by user via post footer
			        await expect(postListPostItemFooterFollowingButton).not.toBeVisible();
			
			        // # Open post options for message and tap on save option
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			
			        // * Verify saved text is displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItemPreHeaderText: channelPostListPostItemPreHeaderText\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(channelPostListPostItemPreHeaderText).toHaveText(savedText);
			
			        // # Tap on post to open thread and tap on thread overview unsave button
			        await postListPostItem.tap();
			        await ThreadScreen.getThreadOverviewUnsaveButton().tap();
			
			        // * Verify saved text is not displayed on the post pre-header
			        await expect(channelPostListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Open post options for message and tap on pin to channel option
			        await ThreadScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			
			        // * Verify pinned text is displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        const \{postListPostItemPreHeaderText: threadPostListPostItemPreHeaderText\} = ThreadScreen.getPostListPostItem(post.id, message);
			        await expect(threadPostListPostItemPreHeaderText).toHaveText(pinnedText);
			
			        // # Go back to channel, open post options for message, and tap on unpin from channel option
			        await ThreadScreen.back();
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.unpinPostOption.tap();
			
			        // * Verify pinned text is not displayed on the post pre-header
			        await wait(timeouts.ONE_SEC);
			        await expect(channelPostListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4786_5 - should be able to post a message with at-mention and channel mention', async () => \{
			        // # Open a channel screen and post a message with at-mention and channel mention
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const message = \`Message @\$\{testUser.username\} ~\$\{targetChannel.name\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			
			        // * Verify at-mention is posted as lowercase and channel mention is posted as display name
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(post.id, \`Message @\$\{testUser.username.toLowerCase()\} ~\$\{targetChannel.display_name\}\`);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4786_6 - should be able to post labeled permalink and labeled channel link', async () => \{
			        // # Post a target message in a target channel
			        const permalinkTargetMessage = \`Message \$\{getRandomId()\}\`;
			        const \{channel: targetChannel\} = await Channel.apiCreateChannel(siteOneUrl, \{teamId: testTeam.id\});
			        await Channel.apiAddUserToChannel(siteOneUrl, testUser.id, targetChannel.id);
			        const permalinkTargetPost = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: targetChannel.id,
			            message: permalinkTargetMessage,
			        \});
			
			        // # Open a channel screen and post a message with labeled permalink to the target message and labeled channel link to the target channel
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        const permalinkLabel = \`permalink-\$\{getRandomId()\}\`;
			        const permalinkMessage = \`[\$\{permalinkLabel\}](/\$\{testTeam.name\}/pl/\$\{permalinkTargetPost.id\})\`;
			        const channelLinkLabel = \`channel-link-\$\{getRandomId()\}\`;
			        const channelLinkMessage = \`[\$\{channelLinkLabel\}](\$\{serverOneUrl\}/\$\{testTeam.name\}/channels/\$\{targetChannel.name\})\`;
			        const message = \`Message \$\{permalinkMessage\} \$\{channelLinkMessage\}\`;
			        await ChannelScreen.postMessage(message);
			
			        // * Verify permalink and channel link are posted as labeled links
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.hasPostMessage(post.id, \`Message \$\{permalinkLabel\} \$\{channelLinkLabel\}\`);
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4786_7 - should be able to post a message with markdown', async () => \{
			        // # Open a channel screen and post a message with markdown
			        const message = \`Message \$\{getRandomId()\}\`;
			        const markdown = \`#### \$\{message\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(markdown);
			
			        // * Verify message with markdown is posted
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItemHeading\} = ChannelScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItemHeading).toBeVisible();
			        await expect(element(by.text(message))).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\messaging.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\search.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelInfoScreen,
			    ChannelListScreen,
			    ChannelScreen,
			    HomeScreen,
			    LoginScreen,
			    PinnedMessagesScreen,
			    PostOptionsScreen,
			    RecentMentionsScreen,
			    SavedMessagesScreen,
			    SearchMessagesScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Smoke Test - Search', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4911_1 - should be able to display a recent mention on recent mentions screen', async () => \{
			        // # Open a channel screen, post a message with at-mention to current user, go back to channel list screen, and open recent mentions screen
			        const message = \`@\$\{testUser.username\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await RecentMentionsScreen.open();
			
			        // * Verify on recent mentions screen and recent mention is displayed
			        await RecentMentionsScreen.toBeVisible();
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = RecentMentionsScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4911_2 - should be able to display a saved message on saved messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on save option, go back to channel list screen, and open saved messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.savePostOption.tap();
			        await ChannelScreen.back();
			        await SavedMessagesScreen.open();
			
			        // * Verify on saved messages screen and saved message is displayed
			        await SavedMessagesScreen.toBeVisible();
			        const \{postListPostItem\} = SavedMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelListScreen.open();
			    \});
			
			    it('MM-T4911_3 - should be able to display a pinned message on pinned messages screen', async () => \{
			        // # Open a channel screen, post a message, open post options for message, tap on pin to channel option, open channel info screen, and open pinned messages screen
			        const message = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openPostOptionsFor(post.id, message);
			        await PostOptionsScreen.pinPostOption.tap();
			        await ChannelInfoScreen.open();
			        await PinnedMessagesScreen.open();
			
			        // * Verify on pinned messages screen and pinned message is displayed
			        await PinnedMessagesScreen.toBeVisible();
			        const \{postListPostItem\} = PinnedMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await PinnedMessagesScreen.back();
			        await ChannelInfoScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4911_4 - should be able to search for a message and display on search results screen', async () => \{
			        // # Open a channel screen, post a message, go back to channel list screen, open search messages screen, type in a search term that will yield results, and tap on search key
			        const searchTerm = getRandomId();
			        const message = \`Message \$\{searchTerm\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(message);
			        await ChannelScreen.back();
			        await SearchMessagesScreen.open();
			        await SearchMessagesScreen.searchInput.typeText(searchTerm);
			        await SearchMessagesScreen.searchInput.tapReturnKey();
			
			        // * Verify search results contain searched message
			        const \{post\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = SearchMessagesScreen.getPostListPostItem(post.id, message);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Clear search input, remove recent search item, and go back to channel list screen
			        await SearchMessagesScreen.searchClearButton.tap();
			        await SearchMessagesScreen.getRecentSearchItemRemoveButton(searchTerm).tap();
			        await ChannelListScreen.open();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\search.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\server_login.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Setup,
			    User,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			    serverTwoUrl,
			    siteTwoUrl,
			\} from '@support/test_config';
			import \{Alert\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerListScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{isAndroid, isIos, timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Smoke Test - Server Login', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const serverTwoDisplayName = 'Server 2';
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout(serverOneDisplayName);
			    \});
			
			    it('MM-T4675_1 - should be able to connect to a server, log in, and show channel list screen', async () => \{
			        // * Verify on server screen
			        await ServerScreen.toBeVisible();
			
			        // # Connect to server with valid server url and non-empty server display name
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			
			        // * Verify on login screen
			        await LoginScreen.toBeVisible();
			
			        // # Log in to server with correct credentials
			        const \{team, user\} = await Setup.apiInit(siteOneUrl);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen and channel list header shows team display name and server display name
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.headerTeamDisplayName).toHaveText(team.display_name);
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverOneDisplayName);
			    \});
			
			    it('MM-T4675_2 - should be able to add a new server and log-in-to/log-out-from the new server', async () => \{
			        // # Open server list screen
			        await ServerListScreen.open();
			        await ServerListScreen.closeTutorial();
			
			        // * Verify on server list screen
			        await ServerListScreen.toBeVisible();
			
			        // # Add a second server and log in to the second server
			        await User.apiAdminLogin(siteTwoUrl);
			        const \{user\} = await Setup.apiInit(siteTwoUrl);
			        await ServerListScreen.addServerButton.tap();
			        await expect(ServerScreen.headerTitleAddServer).toBeVisible();
			        await ServerScreen.connectToServer(serverTwoUrl, serverTwoDisplayName);
			        await LoginScreen.login(user);
			
			        // * Verify on channel list screen of the second server
			        await ChannelListScreen.toBeVisible();
			        await expect(ChannelListScreen.headerServerDisplayName).toHaveText(serverTwoDisplayName);
			
			        // # Go back to first server, open server list screen, swipe left on second server and tap on logout option
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemInactive(serverOneDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemInactive(serverOneDisplayName).tap();
			        await ServerListScreen.open();
			        if (isIos()) \{
			            await ServerListScreen.serverListTitle.swipe('up');
			        \} else if (isAndroid()) \{
			            await waitFor(ServerListScreen.serverListTitle).toBeVisible().withTimeout(timeouts.TWO_SEC);
			            await ServerListScreen.serverListTitle.swipe('up', 'fast', 0.1, 0.5, 0.3);
			        \}
			        await waitFor(ServerListScreen.getServerItemInactive(serverTwoDisplayName)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await ServerListScreen.getServerItemInactive(serverTwoDisplayName).swipe('left');
			        await ServerListScreen.getServerItemLogoutOption(serverTwoDisplayName).tap();
			
			        // * Verify logout server alert is displayed
			        await expect(Alert.logoutTitle(serverTwoDisplayName)).toBeVisible();
			
			        // # Tap on logout button
			        await Alert.logoutButton2.tap();
			
			        // * Verify second server is logged out
			        await ServerListScreen.getServerItemInactive(serverTwoDisplayName).swipe('left');
			        await expect(ServerListScreen.getServerItemLoginOption(serverTwoDisplayName)).toBeVisible();
			
			        // # Go back to first server
			        await ServerListScreen.getServerItemActive(serverOneDisplayName).tap();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\server_login.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\threads.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelScreen,
			    ChannelListScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    PermalinkScreen,
			    ServerScreen,
			    ThreadOptionsScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Smoke Test - Threads', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const savedText = 'Saved';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4811_1 - should be able to create a thread, follow/unfollow a thread, mark a thread as read/unread, and reply to thread', async () => \{
			        // # Create a thread and unfollow thread via thread navigation
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        await ThreadScreen.postMessage(\`\$\{parentMessage\} reply\`);
			        await ThreadScreen.followingButton.tap();
			
			        // * Verify thread is not followed by user via thread navigation
			        await expect(ThreadScreen.followButton).toBeVisible();
			
			        // # Follow thread via thread navigation
			        await ThreadScreen.followButton.tap();
			
			        // * Verify thread is followed by user via thread navigation
			        await expect(ThreadScreen.followingButton).toBeVisible();
			
			        // # Go back to channel list screen, then go to global threads screen, tap on all your threads button, open thread options for thread, tap on mark as unread option, and tap on unread threads button
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.markAsUnreadOption.tap();
			        await GlobalThreadsScreen.headerUnreadThreadsButton.tap();
			
			        // * Verify thread is displayed in unread threads section
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Open thread options for thread and tap on mark as read option
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.markAsReadOption.tap();
			
			        // * Verify thread is not displayed anymore in unread threads section
			        await wait(timeouts.ONE_SEC);
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).not.toBeVisible();
			
			        // # Tap on all your threads button, tap on the thread, and add new reply to thread
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			        const newReplyMessage = \`\$\{parentMessage\} new reply\`;
			        await ThreadScreen.postMessage(newReplyMessage);
			
			        // * Verify new reply is posted
			        const \{post: newReplyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ThreadScreen.getPostListPostItem(newReplyPost.id, newReplyMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4811_2 - should be able to save/unsave a thread and open a thread in channel', async () => \{
			        // # Create a thread, go back to channel list screen, then go to global threads screen, open thread options for thread, tap on save option, and tap on thread
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.saveThreadOption.tap();
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			
			        // * Verify saved text is displayed on the post pre-header
			        const \{postListPostItemPreHeaderText\} = ThreadScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await expect(postListPostItemPreHeaderText).toHaveText(savedText);
			
			        // # Go back to global threads screen, open thread options for thread, tap on save option, and tap on thread
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await wait(timeouts.ONE_SEC);
			        await ThreadOptionsScreen.unsaveThreadOption.tap();
			        await wait(timeouts.ONE_SEC);
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			
			        // * Verify saved text is not displayed on the post pre-header
			        await expect(postListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to global threads screen, open thread options for thread, tap on open in channel option, and jump to recent messages
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.openInChannelOption.tap();
			        await PermalinkScreen.jumpToRecentMessages();
			
			        // * Verify on channel screen and thread is displayed
			        await ChannelScreen.toBeVisible();
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\smoke_test\\threads.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\teams\\invite_people.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{Setup, User\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    Invite,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			\} from '@support/ui/screen';
			import \{isIos, timeouts\} from '@support/utils';
			import \{expect\} from 'detox';
			
			function systemDialog(label: string) \{
			    if (isIos()) \{
			        return element(by.label(label)).atIndex(0);
			    \}
			    return element(by.text(label));
			\}
			
			describe('Teams - Invite', () => \{
			    const serverOneDisplayName = 'Server 1';
			
			    let testTeam: any;
			    let testUser: any;
			    let testUser1: any;
			
			    beforeAll(async () => \{
			        const \{team, user\} = await Setup.apiInit(siteOneUrl);
			
			        testTeam = team;
			        testUser = user;
			
			        const \{user: user1\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'i'\});
			
			        testUser1 = user1;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        await device.reloadReactNative();
			
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			
			        // # Open invite screen
			        await Invite.open();
			    \});
			
			    afterAll(async () => \{
			        // # Close invite screen
			        await Invite.close();
			
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T5360 - should open the invite screen', async () => \{
			        // * Verify invite screen Header buttons
			        await expect(Invite.closeButton).toBeVisible();
			        await expect(Invite.sendButton).toBeVisible();
			
			        // * Verify Team data
			        await expect(Invite.teamDisplayName).toHaveText(testTeam.display_name);
			        await expect(Invite.teamIcon).toBeVisible();
			
			        // * Verify default Selection
			        await waitFor(Invite.screenSelection).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // * Verify Server data
			        await expect(Invite.serverDisplayName).toHaveText(serverOneDisplayName);
			
			        // * Verify Share Link
			        await expect(Invite.shareLinkButton).toBeVisible();
			
			        // * Verify Search bar
			        await expect(Invite.searchBarTitle).toBeVisible();
			        await expect(Invite.searchBarInput).toBeVisible();
			    \});
			
			    it('MM-T5221 - should be able to share a URL invite to the team', async () => \{
			        if (isIos()) \{
			            // # Tap on Share link
			            await Invite.shareLinkButton.tap();
			            const dialog = systemDialog(\`Join the \$\{testTeam.display_name\} team\`);
			
			            // * Verify share dialog is open
			            await expect(dialog).toExist();
			
			            // # Close share dialog
			            await dialog.swipe('down');
			        \} // no support for Android system dialogs by detox yet. See https://github.com/wix/Detox/issues/3227
			    \});
			
			    it('MM-T5361 - should show no results item in search list', async () => \{
			        const noUser = 'qwertyuiop';
			
			        // # Search for a non-existent user
			        await Invite.searchBarInput.replaceText(noUser);
			
			        // * Validate no results item in search list
			        await waitFor(Invite.getSearchListNoResults(noUser)).toBeVisible().withTimeout(timeouts.TWO_SEC);
			        await expect(Invite.getSearchListNoResultsText(noUser)).toHaveText(noUser);
			    \});
			
			    it('MM-T5362 - should be able to send email invite', async () => \{
			        const noUserEmailFormat = 'qwerty@ui.op';
			
			        // # Search for a non-existent user with email format
			        await Invite.searchBarInput.replaceText(noUserEmailFormat);
			
			        // * Validate email invite item in search list
			        await waitFor(Invite.getSearchListTextItem(noUserEmailFormat)).toBeVisible().withTimeout(timeouts.TWO_SEC);
			        await expect(Invite.getSearchListTextItemText(noUserEmailFormat)).toHaveText(noUserEmailFormat);
			
			        // # Select email invite item
			        await Invite.getSearchListTextItem(noUserEmailFormat).tap();
			        await expect(Invite.getSearchListTextItem(noUserEmailFormat)).not.toBeVisible();
			
			        // * Validate email invite is added to selected items
			        await expect(Invite.getSelectedItem(noUserEmailFormat)).toBeVisible();
			
			        // # Send invitation
			        await Invite.sendButton.tap();
			
			        // * Validate summary report sent
			        await waitFor(Invite.screenSummary).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await expect(Invite.getSummaryReportSent()).toBeVisible();
			        await expect(Invite.getSummaryReportNotSent()).not.toExist();
			        await expect(Invite.getSummaryReportTextItem(noUserEmailFormat)).toBeVisible();
			        await expect(Invite.getSummaryReportTextItemText(noUserEmailFormat)).toHaveText(noUserEmailFormat);
			    \});
			
			    it('MM-T5363 - should be able to send user invite', async () => \{
			        const username = \` @\$\{testUser1.username\}\`;
			
			        // # Search for an existent user
			        await Invite.searchBarInput.replaceText(testUser1.username);
			
			        // * Validate user item in search list
			        await waitFor(Invite.getSearchListUserItem(testUser1.id)).toBeVisible().withTimeout(timeouts.TWO_SEC);
			        await expect(Invite.getSearchListUserItemText(testUser1.id)).toHaveText(username);
			
			        // # Select user item
			        await Invite.getSearchListUserItem(testUser1.id).tap();
			        await expect(Invite.getSearchListUserItem(testUser1.id)).not.toBeVisible();
			
			        // * Validate user is added to selected items
			        await expect(Invite.getSelectedItem(testUser1.id)).toBeVisible();
			
			        // # Send invitation
			        await Invite.sendButton.tap();
			
			        // * Validate summary report sent
			        await waitFor(Invite.screenSummary).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await expect(Invite.getSummaryReportSent()).toBeVisible();
			        await expect(Invite.getSummaryReportNotSent()).not.toExist();
			        await expect(Invite.getSummaryReportUserItem(testUser1.id)).toBeVisible();
			        await expect(Invite.getSummaryReportUserItemText(testUser1.id)).toHaveText(username);
			    \});
			
			    it('MM-T5364 - should not be able to send user invite to user already in team', async () => \{
			        const username = \` @\$\{testUser1.username\}\`;
			
			        // # Search for an existent user already in team
			        await Invite.searchBarInput.replaceText(testUser1.username);
			
			        // * Validate user item in search list
			        await waitFor(Invite.getSearchListUserItem(testUser1.id)).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Select user item
			        await Invite.getSearchListUserItem(testUser1.id).tap();
			
			        // * Validate user is added to selected items
			        await expect(Invite.getSelectedItem(testUser1.id)).toBeVisible();
			
			        // # Send invitation
			        await Invite.sendButton.tap();
			
			        // * Validate summary report not sent
			        await expect(Invite.screenSummary).toBeVisible();
			        await expect(Invite.getSummaryReportSent()).not.toExist();
			        await expect(Invite.getSummaryReportNotSent()).toBeVisible();
			        await expect(Invite.getSummaryReportUserItem(testUser1.id)).toBeVisible();
			        await expect(Invite.getSummaryReportUserItemText(testUser1.id)).toHaveText(username);
			    \});
			
			    it('MM-T5365 - should handle both sent and not sent invites', async () => \{
			        const \{user: testUser2\} = await User.apiCreateUser(siteOneUrl, \{prefix: 'i'\});
			
			        const username1 = \` @\$\{testUser1.username\}\`;
			        const username2 = \` @\$\{testUser2.username\}\`;
			
			        // # Search for an existent user
			        await Invite.searchBarInput.replaceText(testUser2.username);
			
			        // * Validate user item in search list
			        await waitFor(Invite.getSearchListUserItem(testUser2.id)).toBeVisible().withTimeout(timeouts.TEN_SEC);
			
			        // # Select user item
			        await Invite.getSearchListUserItem(testUser2.id).tap();
			
			        // * Validate user is added to selected items
			        await expect(Invite.getSelectedItem(testUser2.id)).toBeVisible();
			
			        // # Search for a existent user already in team
			        await Invite.searchBarInput.replaceText(testUser1.username);
			
			        // # Wait for user item in search list
			        await waitFor(Invite.getSearchListUserItem(testUser1.id)).toExist().withTimeout(timeouts.TWO_SEC);
			
			        // # Select user item
			        await Invite.getSearchListUserItem(testUser1.id).tap();
			
			        // * Validate user is added to selected items
			        await expect(Invite.getSelectedItem(testUser1.id)).toBeVisible();
			
			        // # Send invitation
			        await Invite.sendButton.tap();
			
			        // * Validate summary
			        await waitFor(Invite.screenSummary).toBeVisible().withTimeout(timeouts.TEN_SEC);
			
			        // * Validate summary report not sent
			        await expect(Invite.getSummaryReportNotSent()).toBeVisible();
			        await expect(Invite.getSummaryReportUserItem(testUser1.id)).toBeVisible();
			        await expect(Invite.getSummaryReportUserItemText(testUser1.id)).toHaveText(username1);
			
			        // * Validate summary report sent
			        await waitFor(Invite.getSummaryReportSent()).toBeVisible().withTimeout(timeouts.TEN_SEC);
			        await expect(Invite.getSummaryReportUserItem(testUser2.id)).toBeVisible();
			        await expect(Invite.getSummaryReportUserItemText(testUser2.id)).toHaveText(username2);
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\teams\\invite_people.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\follow_and_unfollow_thread.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    PostOptionsScreen,
			    ServerScreen,
			    ThreadOptionsScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Threads - Follow and Unfollow Thread', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4806_1 - should be able to follow/unfollow a thread via thread navigation', async () => \{
			        // # Create a thread
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        await ThreadScreen.postMessage(\`\$\{parentMessage\} reply\`);
			
			        // * Verify thread is followed by user by default via thread navigation
			        await expect(ThreadScreen.followingButton).toBeVisible();
			
			        // # Unfollow thread via thread navigation
			        await ThreadScreen.followingButton.tap();
			
			        // * Verify thread is not followed by user via thread navigation
			        await expect(ThreadScreen.followButton).toBeVisible();
			
			        // # Follow thread via thread navigation
			        await ThreadScreen.followButton.tap();
			
			        // * Verify thread is followed by user via thread navigation
			        await expect(ThreadScreen.followingButton).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4806_2 - should be able to follow/unfollow a thread via post footer', async () => \{
			        // # Create a thread and go back to channel screen
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        await ThreadScreen.postMessage(\`\$\{parentMessage\} reply\`);
			        await ThreadScreen.back();
			
			        // * Verify thread is followed by user by default via post footer
			        const \{postListPostItemFooterFollowButton, postListPostItemFooterFollowingButton\} = ChannelScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await expect(postListPostItemFooterFollowingButton).toBeVisible();
			
			        // # Unfollow thread via post footer
			        await postListPostItemFooterFollowingButton.tap();
			
			        // * Verify thread is not followed by user via post footer
			        await expect(postListPostItemFooterFollowButton).toBeVisible();
			
			        // # Follow thread via post footer
			        await postListPostItemFooterFollowButton.tap();
			
			        // * Verify thread is followed by user via post footer
			        await expect(postListPostItemFooterFollowingButton).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4806_3 - should be able to follow/unfollow a thread via post options', async () => \{
			        // # Create a thread, go back to channel screen, and open post options for thread
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        await ThreadScreen.postMessage(\`\$\{parentMessage\} reply\`);
			        await ThreadScreen.back();
			        await ChannelScreen.openPostOptionsFor(parentPost.id, parentMessage);
			
			        // * Verify thread is followed by user by default via post options
			        await expect(PostOptionsScreen.followingThreadOption).toBeVisible();
			
			        // # Unfollow thread via post options
			        await PostOptionsScreen.followingThreadOption.tap();
			
			        // * Verify thread is not followed by user via post footer
			        const \{postListPostItemFooterFollowButton, postListPostItemFooterFollowingButton\} = ChannelScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await waitFor(postListPostItemFooterFollowButton).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Open post options for thread
			        await ChannelScreen.openPostOptionsFor(parentPost.id, parentMessage);
			
			        // * Verify thread is not followed by user via post options
			        await expect(PostOptionsScreen.followThreadOption).toBeVisible();
			
			        // # Tap on follow thread option
			        await PostOptionsScreen.followThreadOption.tap();
			
			        // * Verify thread is followed by user via post footer
			        await waitFor(postListPostItemFooterFollowingButton).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Open post options for thread
			        await ChannelScreen.openPostOptionsFor(parentPost.id, parentMessage);
			
			        // * Verify thread is followed by user via post options
			        await waitFor(PostOptionsScreen.followingThreadOption).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Go back to channel list screen
			        await PostOptionsScreen.close();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4806_4 - should be able to unfollow a thread via thread options', async () => \{
			        // # Create a thread, go back to channel list screen, then go to global threads screen, and tap on all your threads button
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			
			        // * Verify thread is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Open thread options for thread
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			
			        // * Verify thread is followed by user via thread options
			        await waitFor(ThreadOptionsScreen.followingThreadOption).toBeVisible().withTimeout(timeouts.TWO_SEC);
			
			        // # Tap on unfollow thread option
			        await ThreadOptionsScreen.followingThreadOption.tap();
			
			        // * Verify thread is not displayed anymore in all your threads section
			        await wait(timeouts.ONE_SEC);
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\follow_and_unfollow_thread.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\global_threads.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Threads - Global Threads', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			    let testUser: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			        testUser = user;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(testUser);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4805_1 - should match elements on global threads screen', async () => \{
			        // # Open global threads screen
			        await GlobalThreadsScreen.open();
			
			        // * Verify basic elements on global threads screen
			        await expect(GlobalThreadsScreen.headerAllThreadsButton).toBeVisible();
			        await expect(GlobalThreadsScreen.headerUnreadThreadsButton).toBeVisible();
			        await expect(GlobalThreadsScreen.headerMarkAllAsReadButton).toBeVisible();
			        await expect(GlobalThreadsScreen.emptyThreadsList).toBeVisible();
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			
			    it.skip('MM-T4805_2 - should be able to go to a thread a user started and followed -- UNSTABLE', async () => \{
			        // # Create a thread started by the current user which current user replied to
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			
			        // * Verify thread is followed by the current user by default
			        await expect(ThreadScreen.followingButton).toBeVisible();
			
			        // # Go back to channel list screen, then go to global threads screen, and tap on all your threads button
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			
			        // * Verify the thread started by the current user is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemThreadStarterUserDisplayName(parentPost.id)).toHaveText(testUser.username);
			        await expect(GlobalThreadsScreen.getThreadItemThreadStarterChannelDisplayName(parentPost.id)).toHaveText(testChannel.display_name.toUpperCase());
			        await expect(GlobalThreadsScreen.getThreadItemFooterReplyCount(parentPost.id)).toHaveText('1 reply');
			
			        // # Tap on the thread
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			        await expect(replyPostListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4805_3 - should not display a thread a user started but not followed', async () => \{
			        // # Create a thread started by the current user and current user unfollows the thread
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        await ThreadScreen.postMessage(\`\$\{parentMessage\} reply\`);
			        await ThreadScreen.followingButton.tap();
			
			        // * Verify thread is not followed by the current user
			        await expect(ThreadScreen.followButton).toBeVisible();
			
			        // # Go back to channel list screen, then go to global threads screen, and tap on all your threads button
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			
			        // * Verify the thread started by the current user is not displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			
			    it.skip('MM-T4805_4 - should be able to go to a thread a user replied to and followed -- UNSTABLE', async () => \{
			        // # Create a thread started by another user which the current user replied to
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        const \{post: parentPost\} = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: parentMessage,
			        \});
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        const \{post: replyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem: replyPostListPostItem\} = ThreadScreen.getPostListPostItem(replyPost.id, replyMessage);
			
			        // * Verify thread is followed by the current user by default after replying to post
			        await expect(ThreadScreen.followingButton).toBeVisible();
			
			        // # Go back to channel list screen, then go to global threads screen, and tap on all your threads button
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			
			        // * Verify the thread replied to by the current user is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemThreadStarterUserDisplayName(parentPost.id)).toHaveText('sysadmin');
			        await expect(GlobalThreadsScreen.getThreadItemThreadStarterChannelDisplayName(parentPost.id)).toHaveText(testChannel.display_name.toUpperCase());
			        await expect(GlobalThreadsScreen.getThreadItemFooterReplyCount(parentPost.id)).toHaveText('1 reply');
			
			        // # Tap on the thread
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			        await expect(replyPostListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4805_5 - should not display a thread a user replied to but not followed', async () => \{
			        // # Create a thread started by another user which the current user replied to and current user unfollows the thread
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        const \{post: parentPost\} = await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: parentMessage,
			        \});
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        await ThreadScreen.postMessage(\`\$\{parentMessage\} reply\`);
			        await ThreadScreen.followingButton.tap();
			
			        // * Verify thread is not followed by the current user
			        await expect(ThreadScreen.followButton).toBeVisible();
			
			        // # Go back to channel list screen, then go to global threads screen, and tap on all your threads button
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			
			        // * Verify the thread replied to by the current user is not displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\global_threads.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\mark_thread_as_read_and_unread.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{Alert\} from '@support/ui/component';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ThreadOptionsScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Threads - Mark Thread as Read and Unread', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4807_1 - should be able to mark a thread as read by opening thread', async () => \{
			        // # Create a thread started by the current user which another user replied to, go back to channel list screen, then go to global threads screen, and tap on unread threads button
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: \`\$\{parentMessage\} reply\`,
			            rootId: parentPost.id,
			        \});
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerUnreadThreadsButton.tap();
			
			        // * Verify thread is displayed as unread in unread threads section with unread dot badge and footer unread replies
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemUnreadDotBadge(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemFooterUnreadReplies(parentPost.id)).toHaveText('1 new reply');
			
			        // # Tap on the thread and go back to global threads screen
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			        await ThreadScreen.back();
			
			        // * Verify thread is not displayed anymore in unread threads section
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).not.toBeVisible();
			
			        // # Tap on all your threads button
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			
			        // * Verify thread is displayed as read in all your threads section without unread dot badge and with footer reply count
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemUnreadDotBadge(parentPost.id)).not.toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemFooterReplyCount(parentPost.id)).toHaveText('1 reply');
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4807_2 - should be able to mark a thread as read/unread via thread options', async () => \{
			        // # Create a thread started by the current user which another user replied to, go back to channel list screen, then go to global threads screen, and tap on unread threads button
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: \`\$\{parentMessage\} reply\`,
			            rootId: parentPost.id,
			        \});
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerUnreadThreadsButton.tap();
			
			        // * Verify thread is displayed as unread in unread threads section with unread dot badge and footer unread replies
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemUnreadDotBadge(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemFooterUnreadReplies(parentPost.id)).toHaveText('1 new reply');
			
			        // # Open thread options for thread and tap on mark as read option
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.markAsReadOption.tap();
			
			        // * Verify thread is not displayed anymore in unread threads section
			        await wait(timeouts.ONE_SEC);
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).not.toBeVisible();
			
			        // # Tap on all your threads button
			        await GlobalThreadsScreen.headerAllThreadsButton.tap();
			
			        // * Verify thread is displayed as read in all your threads section without unread dot badge and with footer reply count
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemUnreadDotBadge(parentPost.id)).not.toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemFooterReplyCount(parentPost.id)).toHaveText('1 reply');
			
			        // # Open thread options for thread and tap on mark as unread option
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.markAsUnreadOption.tap();
			
			        // * Verify thread is displayed as unread in all your threads section with unread dot badge and footer unread replies
			        await wait(timeouts.ONE_SEC);
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemUnreadDotBadge(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemFooterUnreadReplies(parentPost.id)).toHaveText('1 new reply');
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4807_3 - should be able to mark all threads as read', async () => \{
			        // # Create a thread started by the current user which another user replied to, go back to channel list screen, then go to global threads screen, and tap on unread threads button
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await Post.apiCreatePost(siteOneUrl, \{
			            channelId: testChannel.id,
			            message: \`\$\{parentMessage\} reply\`,
			            rootId: parentPost.id,
			        \});
			        await ChannelScreen.back();
			        await device.reloadReactNative();
			        await GlobalThreadsScreen.open();
			        await GlobalThreadsScreen.headerUnreadThreadsButton.tap();
			
			        // * Verify thread is displayed as unread in unread threads section with unread dot badge and footer unread replies
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemUnreadDotBadge(parentPost.id)).toBeVisible();
			        await expect(GlobalThreadsScreen.getThreadItemFooterUnreadReplies(parentPost.id)).toHaveText('1 new reply');
			
			        // # Tap on mark all as read button
			        await GlobalThreadsScreen.headerMarkAllAsReadButton.tap();
			
			        // * Verify mark all as read alert is displayed
			        await expect(Alert.markAllAsReadTitle).toBeVisible();
			
			        // # Tap on mark read button
			        await Alert.markReadButton.tap();
			
			        // * Verify thread is not displayed anymore and unread threads section is empty
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).not.toBeVisible();
			        await expect(GlobalThreadsScreen.emptyThreadsList).toBeVisible();
			
			        // # Go back to channel list screen
			        await GlobalThreadsScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\mark_thread_as_read_and_unread.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\open_thread_in_channel.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    PermalinkScreen,
			    ServerScreen,
			    ThreadOptionsScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId, timeouts, wait\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Threads - Open Thread in Channel', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4810_1 - should be able to open a thread in channel via thread options', async () => \{
			        // # Create a thread, go back to channel list screen, and then go to global threads screen
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			
			        // * Verify thread is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Open thread options for thread and tap open in channel option
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.openInChannelOption.tap();
			
			        // * Verify on permalink screen
			        await PermalinkScreen.toBeVisible();
			
			        // # Jump to recent messages
			        await PermalinkScreen.jumpToRecentMessages();
			
			        // * Verify on channel screen and thread is displayed
			        await ChannelScreen.toBeVisible();
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4810_2 - should be able to open a thread in channel by permalink', async () => \{
			        // # Create a thread, go back to channel list screen, and then go to global threads screen
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			
			        // * Verify thread is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Open thread options for thread, tap on copy link option, go back to channel list screen, go to another channel, post the permalink, and tap on permalink
			        const permalinkLabel = \`permalink-\$\{getRandomId()\}\`;
			        const permalinkMessage = \`[\$\{permalinkLabel\}](/_redirect/pl/\$\{parentPost.id\})\`;
			        await GlobalThreadsScreen.back();
			        await ChannelScreen.open(channelsCategory, 'off-topic');
			        await ChannelScreen.postMessage(permalinkMessage);
			        await element(by.text(permalinkLabel)).tap(\{x: 5, y: 10\});
			        await wait(timeouts.ONE_SEC);
			
			        // * Verify on permalink screen
			        await PermalinkScreen.toBeVisible();
			
			        // # Jump to recent messages
			        await PermalinkScreen.jumpToRecentMessages();
			
			        // * Verify on channel screen and thread is displayed
			        await ChannelScreen.toBeVisible();
			        const \{postListPostItem\} = ChannelScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\open_thread_in_channel.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\reply_to_thread.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ThreadOptionsScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Threads - Reply to Thread', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4809_1 - should be able to reply to a thread via thread options', async () => \{
			        // # Create a thread, go back to channel list screen, and then go to global threads screen
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			
			        // * Verify thread is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Open thread options for thread and tap on reply option
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.replyThreadOption.tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Add new reply to thread
			        const newReplyMessage = \`\$\{parentMessage\} new reply\`;
			        await ThreadScreen.postMessage(newReplyMessage);
			
			        // * Verify new reply is posted
			        const \{post: newReplyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ThreadScreen.getPostListPostItem(newReplyPost.id, newReplyMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.back();
			    \});
			
			    it('MM-T4809_2 - should be able to reply to a thread by opening thread', async () => \{
			        // # Create a thread, go back to channel list screen, and then go to global threads screen
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			
			        // * Verify thread is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Tap on the thread
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			
			        // * Verify on thread screen
			        await ThreadScreen.toBeVisible();
			
			        // # Add new reply to thread
			        const newReplyMessage = \`\$\{parentMessage\} new reply\`;
			        await ThreadScreen.postMessage(newReplyMessage);
			
			        // * Verify new reply is posted
			        const \{post: newReplyPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        const \{postListPostItem\} = ThreadScreen.getPostListPostItem(newReplyPost.id, newReplyMessage);
			        await expect(postListPostItem).toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\reply_to_thread.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\save_and_unsave_thread.e2e.ts', () => {
        const sourceCode = `
			// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
			// See LICENSE.txt for license information.
			
			// *******************************************************************
			// - [#] indicates a test step (e.g. # Go to a screen)
			// - [*] indicates an assertion (e.g. * Check the title)
			// - Use element testID when selecting an element. Create one if none.
			// *******************************************************************
			
			import \{
			    Post,
			    Setup,
			\} from '@support/server_api';
			import \{
			    serverOneUrl,
			    siteOneUrl,
			\} from '@support/test_config';
			import \{
			    ChannelListScreen,
			    ChannelScreen,
			    GlobalThreadsScreen,
			    HomeScreen,
			    LoginScreen,
			    ServerScreen,
			    ThreadOptionsScreen,
			    ThreadScreen,
			\} from '@support/ui/screen';
			import \{getRandomId\} from '@support/utils';
			import \{expect\} from 'detox';
			
			describe('Threads - Save and Unsave Thread', () => \{
			    const serverOneDisplayName = 'Server 1';
			    const channelsCategory = 'channels';
			    const savedText = 'Saved';
			    let testChannel: any;
			
			    beforeAll(async () => \{
			        const \{channel, user\} = await Setup.apiInit(siteOneUrl);
			        testChannel = channel;
			
			        // # Log in to server
			        await ServerScreen.connectToServer(serverOneUrl, serverOneDisplayName);
			        await LoginScreen.login(user);
			    \});
			
			    beforeEach(async () => \{
			        // * Verify on channel list screen
			        await ChannelListScreen.toBeVisible();
			    \});
			
			    afterAll(async () => \{
			        // # Log out
			        await HomeScreen.logout();
			    \});
			
			    it('MM-T4808_1 - should be able to save/unsave a thread via thread options', async () => \{
			        // # Create a thread, go back to channel list screen, and then go to global threads screen
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			
			        // * Verify thread is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Open thread options for thread, tap on save option, and tap on thread
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.saveThreadOption.tap();
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			
			        // * Verify saved text is displayed on the post pre-header
			        const \{postListPostItemPreHeaderText\} = ThreadScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await expect(postListPostItemPreHeaderText).toHaveText(savedText);
			
			        // # Go back to global threads screen, open thread options for thread, tap on save option, and tap on thread
			        await ThreadScreen.back();
			        await GlobalThreadsScreen.openThreadOptionsFor(parentPost.id);
			        await ThreadOptionsScreen.unsaveThreadOption.tap();
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			
			        // * Verify saved text is not displayed on the post pre-header
			        await expect(postListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			
			    it('MM-T4808_2 - should be able to save/unsave a thread via thread overview', async () => \{
			        // # Create a thread, go back to channel list screen, and then go to global threads screen
			        const parentMessage = \`Message \$\{getRandomId()\}\`;
			        await ChannelScreen.open(channelsCategory, testChannel.name);
			        await ChannelScreen.postMessage(parentMessage);
			        const \{post: parentPost\} = await Post.apiGetLastPostInChannel(siteOneUrl, testChannel.id);
			        await ChannelScreen.openReplyThreadFor(parentPost.id, parentMessage);
			        const replyMessage = \`\$\{parentMessage\} reply\`;
			        await ThreadScreen.postMessage(replyMessage);
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			        await GlobalThreadsScreen.open();
			
			        // * Verify thread is displayed
			        await expect(GlobalThreadsScreen.getThreadItem(parentPost.id)).toBeVisible();
			
			        // # Tap on thread and tap on thread overview save button
			        await GlobalThreadsScreen.getThreadItem(parentPost.id).tap();
			        await ThreadScreen.getThreadOverviewSaveButton().tap();
			
			        // * Verify saved text is displayed on the post pre-header
			        const \{postListPostItemPreHeaderText\} = ThreadScreen.getPostListPostItem(parentPost.id, parentMessage);
			        await expect(postListPostItemPreHeaderText).toHaveText(savedText);
			
			        // # Tap on thread overview unsave button
			        await ThreadScreen.getThreadOverviewUnsaveButton().tap();
			
			        // * Verify saved text is not displayed on the post pre-header
			        await expect(postListPostItemPreHeaderText).not.toBeVisible();
			
			        // # Go back to channel list screen
			        await ThreadScreen.back();
			        await ChannelScreen.back();
			    \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'mattermost_mattermost-mobile\\detox\\e2e\\test\\threads\\save_and_unsave_thread.e2e.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
});
