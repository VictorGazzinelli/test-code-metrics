const { extractFromSource } = require('../../src/extractor');

describe('frontity_frontity', () => {
    it('frontity_frontity\\e2e\\integration\\frontity-01\\amp-comscore-analytics.spec.ts', () => {
        const sourceCode = `
			describe("Comscore AMP", () => \{
			  it("should render the tags for the tracking IDs", () => \{
			    cy.visitSSR(
			      "http://localhost:3001/?frontity_name=amp-comscore-analytics"
			    ).then(() => \{
			      // The AMP library for analytics should exist.
			      cy.get(
			        "script[src='https://cdn.ampproject.org/v0/amp-analytics-0.1.js']"
			      ).should("exist");
			
			      // Two \`amp-analytics\` elements should have been rendered, each one with
			      // its corresponding tracking ID.
			      cy.get("amp-analytics[type='comscore'] > script").within((\$scripts) => \{
			        cy.wrap(\$scripts).should("have.length", 2);
			        cy.wrap(\$scripts.eq(0)).should(
			          "contain.text",
			          '\{"vars":\{"c2":"111111"\}\}'
			        );
			        cy.wrap(\$scripts.eq(1)).should(
			          "contain.text",
			          '\{"vars":\{"c2":"222222"\}\}'
			        );
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\amp-comscore-analytics.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\amp-google-analytics.spec.ts', () => {
        const sourceCode = `
			describe("Google Analytics AMP", () => \{
			  it("should render the tags for the tracking IDs", () => \{
			    cy.visitSSR(
			      "http://localhost:3001/?frontity_name=amp-google-analytics"
			    ).then(() => \{
			      // The AMP library for analytics should exist.
			      cy.get(
			        "script[src='https://cdn.ampproject.org/v0/amp-analytics-0.1.js']"
			      ).should("exist");
			
			      // Only one \`amp-analytics\` elements should have been rendered for all the
			      // tracking IDs
			      cy.get("amp-analytics[type='gtag']")
			        .should("exist")
			        .should("have.length", 1);
			
			      // The AMP config should contain all tracking IDs, variables and triggers.
			      cy.get("amp-analytics[type='gtag'] > script").should(
			        "contain.text",
			        JSON.stringify(\{
			          vars: \{
			            gtag_id: "UA-XXXXXXXX-X",
			            config: \{
			              "UA-XXXXXXXX-X": \{ groups: "default" \},
			              "UA-YYYYYYYY-Y": \{ groups: "default" \},
			            \},
			            someProp: "someValue",
			          \},
			          triggers: \{
			            button: \{
			              selector: "#the-button",
			              on: "click",
			              vars: \{
			                event_name: "login",
			                method: "Google",
			              \},
			            \},
			          \},
			        \})
			      );
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\amp-google-analytics.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\amp-google-tag-manager-analytics.spec.ts', () => {
        const sourceCode = `
			describe("Google Tag Manager AMP", () => \{
			  it("should render the tags for the tracking IDs", () => \{
			    cy.visitSSR(
			      "http://localhost:3001/?frontity_name=amp-google-tag-manager-analytics"
			    ).then(() => \{
			      // The AMP library for analytics should exist.
			      cy.get(
			        "script[src='https://cdn.ampproject.org/v0/amp-analytics-0.1.js']"
			      ).should("exist");
			
			      // Two \`amp-analytics\` elements should have been rendered, each one with
			      // its corresponding container ID.
			      cy.get("amp-analytics[config*='id=GTM-XXXXXX-X']").should("exist");
			      cy.get("amp-analytics[config*='id=GTM-YYYYYY-Y']").should("exist");
			
			      // Both should have the same AMP config.
			      cy.get("amp-analytics > script")
			        .should("have.length", 2)
			        .each((\$script) => \{
			          cy.wrap(\$script).should(
			            "contain.text",
			            '\{"vars":\{"someProp":"someValue"\}\}'
			          );
			        \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\amp-google-tag-manager-analytics.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\amp.spec.ts', () => {
        const sourceCode = `
			const assertTemplate = () => \{
			  cy.get("html").should("have.attr", "amp");
			  cy.get("style[amp-boilerplate]").should("exist");
			  cy.get("style[amp-custom]").should("exist");
			  cy.get("body script").should("not.exist");
			\};
			
			describe("AMP", () => \{
			  it("should render the template from the server", () => \{
			    cy.visitSSR("http://localhost:3001/?frontity_name=amp").then(() => \{
			      assertTemplate();
			
			      // The static content should contain only 2 style tags.
			      cy.get("style[amp-boilerplate]").should("have.length", 2);
			
			      // We can only have 1 style tag with custom styles (marked with the
			      // \`amp-custom attribute).
			      cy.get("style[amp-custom]").should("have.length", 1);
			
			      // We can have a max total of 3 style tag in an AMP page. Each one has one
			      // of the following attributes: amp-runtime, amp-boilerplate & amp-custom
			      cy.get("style").should("have.length", 3);
			    \});
			  \});
			
			  it("should render the template correctly", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=amp");
			
			    assertTemplate();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\amp.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\analytics.spec.js', () => {
        const sourceCode = `
			describe("Analytics package", () => \{
			  const pageviewHome = \{
			    link: "/",
			    title: "Homepage Title",
			  \};
			
			  const pageviewSomePost = \{
			    link: "/some-post/",
			    title: "Some Post Title",
			  \};
			
			  const pageviewSomeOtherPost = \{
			    link: "/some-other-post/",
			    title: "Some Post Title",
			  \};
			
			  const someEvent = \{
			    name: "some event",
			    payload: \{ content: "some content" \},
			  \};
			
			  const getAnalytics = (data) =>
			    cy.window().its("frontity").its("state").its("testAnalytics").its(data);
			
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=analytics");
			  \});
			
			  it("should have sent the first pageview", () => \{
			    getAnalytics("pageviews").its(0).should("deep.equal", pageviewHome);
			  \});
			
			  it("should sent a pageview if the page changes", () => \{
			    cy.get("button#change-link").click();
			    getAnalytics("pageviews").its(1).should("deep.equal", pageviewSomePost);
			  \});
			
			  it("should sent a pageview if the page changes and title is the same", () => \{
			    cy.get("button#change-link").click();
			    cy.get("button#change-link-post-2").click();
			    cy.go("back");
			    getAnalytics("pageviews").its(1).should("deep.equal", pageviewSomePost);
			    getAnalytics("pageviews")
			      .its(2)
			      .should("deep.equal", pageviewSomeOtherPost);
			    getAnalytics("pageviews").its(3).should("deep.equal", pageviewSomePost);
			  \});
			
			  it("should sent pageviews when going back or forward", () => \{
			    cy.get("button#change-link").click();
			    cy.go("back");
			    getAnalytics("pageviews").its(2).should("deep.equal", pageviewHome);
			
			    cy.go("forward");
			    getAnalytics("pageviews").its(3).should("deep.equal", pageviewSomePost);
			  \});
			
			  it("should send events", () => \{
			    cy.get("button#send-event").click();
			    cy.get("button#send-event").click();
			    cy.get("button#send-event").click();
			    getAnalytics("events").its(0).should("deep.equal", someEvent);
			    getAnalytics("events").its(1).should("deep.equal", someEvent);
			    getAnalytics("events").its(2).should("deep.equal", someEvent);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\comscore-analytics.spec.js', () => {
        const sourceCode = `
			describe("Comscore", () => \{
			  const pageviewHome = \{
			    title: "Homepage Title",
			    location: "http://localhost:3001/",
			  \};
			
			  const pageviewSomePost = \{
			    title: "Some Post Title",
			    location: "http://localhost:3001/some-post/",
			  \};
			
			  let ImageBackup;
			
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=comscore-analytics", \{
			      onBeforeLoad(win) \{
			        // Comscore requests are images so here
			        // we overwrite the \`Image\` class, just during this tests.
			
			        // Backup Image class.
			        ImageBackup = win.Image;
			
			        // Overwrite Image class.
			        Object.defineProperty(win, "Image", \{
			          value: class ImageMock \{
			            set src(source) \{
			              const url = new URL(source);
			              if (url.host === "sb.scorecardresearch.com") \{
			                win.comscoreRequests = win.comscoreRequests || [];
			                win.comscoreRequests.push(\{
			                  id: url.searchParams.get("c2"),
			                  title: url.searchParams.get("c8"),
			                  location: url.searchParams.get("c7"),
			                \});
			              \}
			            \}
			          \},
			        \});
			      \},
			    \});
			  \});
			
			  afterEach(() => \{
			    cy.window().then((win) => \{
			      // Restore Image class.
			      Object.defineProperty(win, "Image", \{
			        value: ImageBackup,
			      \});
			    \});
			  \});
			
			  it("should load the Comscore library", () => \{
			    cy.get(\`script[src="https://sb.scorecardresearch.com/beacon.js"][async]\`);
			  \});
			
			  it("should have sent the first pageview", () => \{
			    // Check that Comscore has sent the pageview with the correct title.
			    cy.window()
			      .its("comscoreRequests")
			      .its(0)
			      .should("deep.equal", \{ id: "111111", ...pageviewHome \});
			
			    cy.window()
			      .its("comscoreRequests")
			      .its(1)
			      .should("deep.equal", \{ id: "222222", ...pageviewHome \});
			  \});
			
			  it("should sent a pageview if the page changes", () => \{
			    cy.get("button#change-link").click();
			    cy.window()
			      .its("comscoreRequests")
			      .its(2)
			      .should("deep.equal", \{ id: "111111", ...pageviewSomePost \});
			
			    cy.window()
			      .its("comscoreRequests")
			      .its(3)
			      .should("deep.equal", \{ id: "222222", ...pageviewSomePost \});
			  \});
			
			  it("should sent pageviews when going back or forward", () => \{
			    cy.get("button#change-link").click();
			    cy.go("back");
			
			    cy.window()
			      .its("comscoreRequests")
			      .its(4)
			      .should("deep.equal", \{ id: "111111", ...pageviewHome \});
			
			    cy.window()
			      .its("comscoreRequests")
			      .its(5)
			      .should("deep.equal", \{ id: "222222", ...pageviewHome \});
			
			    cy.go("forward");
			
			    cy.window()
			      .its("comscoreRequests")
			      .its(6)
			      .should("deep.equal", \{ id: "111111", ...pageviewSomePost \});
			
			    cy.window()
			      .its("comscoreRequests")
			      .its(7)
			      .should("deep.equal", \{ id: "222222", ...pageviewSomePost \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\comscore-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\custom-configuration.spec.ts', () => {
        const sourceCode = `
			describe("Custom Configuration", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=custom-configuration");
			  \});
			
			  /**
			   * This is a simple functionality check to make sure the application
			   * is loaded and the aliases are working.
			   */
			  it("should render the theme with the aliased components package", () => \{
			    cy.get("h1#one").should("not.exist");
			    cy.get("h1").should("exist").should("have.text", "Default");
			    cy.get("button#set-to-1").click();
			    cy.get("h1#one").should("exist").should("have.text", "@@111@@");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\custom-configuration.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\custom-render.spec.ts', () => {
        const sourceCode = `
			describe("Custom Render", () => \{
			  it("should render the custom App wrapped", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=custom-render");
			
			    cy.get("#root #wrapper").should("exist");
			  \});
			
			  it("should render the custom links and scripts", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=custom-render");
			
			    // Custom head tag.
			    cy.get("link[rel=custom]").should("have.attr", "value", "render");
			
			    // Custom script tag.
			    cy.get("script#custom-render-script").should("exist");
			  \});
			
			  it("should have the same seed as on the server", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=custom-render");
			
			    cy.get("link[rel=seed]")
			      .invoke("attr", "value")
			      .then((seed) => \{
			        // The input field should have the server value.
			        cy.get("input[name=seed").should("have.attr", "value", seed);
			      \});
			  \});
			
			  it("should have the tags pushed via head and scripts API", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=custom-render");
			
			    cy.get("link[rel=head]").should("have.attr", "value", "custom");
			
			    // Script tag pushed via \`.scripts.push()\` API.
			    cy.get("script#pushed").should("exist");
			
			    // This asserts that the custom script executed as well.
			    cy.get("body").should("have.attr", "class", "pushed");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\custom-render.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\dynamic-public-path.spec.js', () => {
        const sourceCode = `
			import expect from "expect";
			
			describe("Dynamic Public Path", () => \{
			  describe("Frontity Settings", () => \{
			    beforeEach(() => \{
			      cy.visit("http://localhost:3001/dynamic-public-path/");
			    \});
			
			    it("should be able to render elements from dynamic components", () => \{
			      cy.get("[data-test-id='dynamic-div']").should(
			        "have.text",
			        "I am the Dynamic component"
			      );
			    \});
			
			    it("should be able to render other static assets", () => \{
			      cy.get("[data-test-id='image-1']")
			        .should("have.attr", "src")
			        .and("contain", "/dynamic-public-path/custom-static/images/");
			      cy.get("[data-test-id='image-1']")
			        .should("be.visible")
			        .and((\$img) => \{
			          expect(\$img[0].naturalWidth).toBeGreaterThan(0);
			        \});
			      cy.get("[data-test-id='image-2']")
			        .should("have.attr", "src")
			        .and("contain", "/dynamic-public-path/custom-static/images/");
			      cy.get("[data-test-id='image-2']")
			        .should("be.visible")
			        .and((\$img) => \{
			          expect(\$img[0].naturalWidth).toBeGreaterThan(0);
			        \});
			    \});
			
			    it("should be able to use javascript from dynamic components", () => \{
			      cy.get("[data-test-id='toggle-div']").should("have.text", "OFF");
			      cy.get("[data-test-id='toggle-button']").click();
			      cy.get("[data-test-id='toggle-div']").should("have.text", "ON");
			    \});
			  \});
			
			  describe("Frontity Query Option", () => \{
			    beforeEach(() => \{
			      cy.visit(
			        "http://localhost:3001/dynamic-public-path-2/?frontity_public_path=http://localhost:3001/dynamic-public-path/custom-static"
			      );
			    \});
			
			    it("should be able to render elements from dynamic components", () => \{
			      cy.get("[data-test-id='dynamic-div']").should(
			        "have.text",
			        "I am the Dynamic component"
			      );
			    \});
			
			    it("should be able to render other static assets", () => \{
			      cy.get("[data-test-id='image-1']")
			        .should("have.attr", "src")
			        .and(
			          "contain",
			          "http://localhost:3001/dynamic-public-path/custom-static/images/"
			        );
			      cy.get("[data-test-id='image-1']")
			        .should("be.visible")
			        .and((\$img) => \{
			          expect(\$img[0].naturalWidth).toBeGreaterThan(0);
			        \});
			      cy.get("[data-test-id='image-2']")
			        .should("have.attr", "src")
			        .and(
			          "contain",
			          "http://localhost:3001/dynamic-public-path/custom-static/images/"
			        );
			      cy.get("[data-test-id='image-2']")
			        .should("be.visible")
			        .and((\$img) => \{
			          expect(\$img[0].naturalWidth).toBeGreaterThan(0);
			        \});
			    \});
			
			    it("should be able to use javascript from dynamic components", () => \{
			      cy.get("[data-test-id='toggle-div']").should("have.text", "OFF");
			      cy.get("[data-test-id='toggle-button']").click();
			      cy.get("[data-test-id='toggle-div']").should("have.text", "ON");
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\dynamic-public-path.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\emotion.spec.js', () => {
        const sourceCode = `
			describe("Global", () => \{
			  it("should have a blue background, but not a red color", () => \{
			    cy.visit("/color-red?frontity_name=emotion");
			    cy.visit("/background-blue?frontity_name=emotion");
			    cy.get("body").should("have.css", "background-color", "rgb(0, 0, 255)");
			    cy.get("body").should("not.have.css", "color", "rgb(255, 0, 0)");
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("body").should("not.have.css", "background-color", "rgb(0, 0, 255)");
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("body").should("have.css", "background-color", "rgb(0, 0, 255)");
			  \});
			
			  it("should have a red color, but not a blue background", () => \{
			    cy.visit("/background-blue?frontity_name=emotion");
			    cy.visit("/color-red?frontity_name=emotion");
			    cy.get("body").should("not.have.css", "background-color", "rgb(0, 0, 255)");
			    cy.get("body").should("have.css", "color", "rgb(255, 0, 0)");
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("body").should("not.have.css", "color", "rgb(255, 0, 0)");
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("body").should("have.css", "color", "rgb(255, 0, 0)");
			  \});
			\});
			
			describe("styled", () => \{
			  it("should have a red color", () => \{
			    cy.visit("/styled-css?frontity_name=emotion");
			    cy.get("[data-test-id='styled-div']").should(
			      "have.css",
			      "color",
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should toggle the color", () => \{
			    cy.visit("/styled-css?frontity_name=emotion");
			    cy.get("[data-test-id='styled-div']").should(
			      "have.css",
			      "color",
			      "rgb(255, 0, 0)"
			    );
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='styled-div']").should(
			      "have.css",
			      "color",
			      "rgb(0, 0, 255)"
			    );
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='styled-div']").should(
			      "have.css",
			      "color",
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should have a Styled class name (autoLabel)", function () \{
			    const frontityModeProduction =
			      Cypress.env("FRONTITY_MODE") !== "development";
			
			    // If we are in production mode skip the test since the autoLabel works only
			    // in development.
			    if (frontityModeProduction) \{
			      this.skip();
			    \}
			
			    cy.visit("http://localhost:3001/styled-css?frontity_name=emotion");
			    cy.get("[data-test-id='styled-div']")
			      .should("have.attr", "class")
			      .and("contain", "Styled");
			  \});
			\});
			
			describe("css", () => \{
			  it("should have a red color", () => \{
			    cy.visit("/styled-css?frontity_name=emotion");
			    cy.get("[data-test-id='css-div']").should(
			      "have.css",
			      "color",
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should toggle the color", () => \{
			    cy.visit("/styled-css?frontity_name=emotion");
			    cy.get("[data-test-id='css-div']").should(
			      "have.css",
			      "color",
			      "rgb(255, 0, 0)"
			    );
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='css-div']").should(
			      "have.css",
			      "color",
			      "rgb(0, 0, 255)"
			    );
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='css-div']").should(
			      "have.css",
			      "color",
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should have a Styled class name (autoLabel)", function () \{
			    const frontityModeProduction =
			      Cypress.env("FRONTITY_MODE") !== "development";
			
			    // If we are in production mode skip the test since the autoLabel works only
			    // in development.
			    if (frontityModeProduction) \{
			      this.skip();
			    \}
			
			    cy.visit("http://localhost:3001/styled-css?frontity_name=emotion");
			    cy.get("[data-test-id='css-div']")
			      .should("have.attr", "class")
			      .and("contain", "CSS");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\emotion.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\fonts\\fonts.spec.js', () => {
        const sourceCode = `
			describe("Fonts", () => \{
			  it("should not load any fonts", () => \{
			    cy.visit("http://localhost:3001/empty?frontity_name=fonts");
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			  \});
			
			  it("should load the woff-1 font", () => \{
			    cy.visit("http://localhost:3001/woff-1?frontity_name=fonts");
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			  \});
			
			  it("should load the woff-2 font", () => \{
			    cy.visit("http://localhost:3001/woff-2?frontity_name=fonts");
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			  \});
			
			  it("should load the ttf font", () => \{
			    cy.visit("http://localhost:3001/ttf?frontity_name=fonts");
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			  \});
			
			  it("should load the all fonts", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=fonts");
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='div-with-font']").toMatchImageSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\fonts\\fonts.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\google-ad-manager.spec.js', () => {
        const sourceCode = `
			describe("Google Ad Manager", () => \{
			  it("should load the GPT library", () => \{
			    cy.visit("http://localhost:3001?frontity_name=google-ad-manager");
			    cy.get(
			      \`script[src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"]\`
			    );
			  \});
			
			  it("should render GPT ad units from fills", () => \{
			    // Go to home.
			    cy.visit("http://localhost:3001?frontity_name=google-ad-manager");
			
			    // Get ad unit from header.
			    cy.get("#header-ad > div").should("have.descendants", "iframe");
			
			    // Get ad unit from footer.
			    cy.get("#footer-ad > div").should("have.descendants", "iframe");
			
			    // Go to "/post/".
			    cy.get("button#change-link").click();
			
			    // Get ad unit from header.
			    cy.get("#header-ad_post > div").should("have.descendants", "iframe");
			
			    // Get ad unit from footer.
			    cy.get("#footer-ad_post > div").should("have.descendants", "iframe");
			
			    // Get ad unit from content.
			    cy.get("#content-ad_post > div").should("have.descendants", "iframe");
			  \});
			
			  it("should work using GPT component directly from libraries", () => \{
			    // Go to home.
			    cy.visit("http://localhost:3001?frontity_name=google-ad-manager");
			
			    // Go to "/post-with-gpt/".
			    cy.get("button#change-link-gpt").click();
			
			    // Get ad unit from content.
			    cy.get("#post-with-gpt-ad > div").should("have.descendants", "iframe");
			  \});
			
			  it("should ad the link to the container ID if data is passed", () => \{
			    // Go to home.
			    cy.visit("http://localhost:3001?frontity_name=google-ad-manager");
			
			    // Go to "/post/".
			    cy.get("button#change-link").click();
			
			    // Get ad unit from content ("/post/").
			    cy.get("#content-ad_post > div").should("have.descendants", "iframe");
			
			    // Get ad unit from content ("/next-post/").
			    cy.get("#content-ad_next-post > div").should("have.descendants", "iframe");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\google-ad-manager.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\google-analytics.spec.js', () => {
        const sourceCode = `
			const pageviewHome = \{
			  title: "Homepage Title",
			  link: "/",
			\};
			
			const pageviewSomePost = \{
			  title: "Some Post Title",
			  link: "/some-post/",
			\};
			
			describe("Google Analytics", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=google-analytics");
			
			    // Wait for Google Analytics to load its <script> and create \`window.ga\`.
			    cy.window().should("have.property", "gtag");
			  \});
			
			  it("should load the Google Analytics library", () => \{
			    // Make sure the <script> was created.
			    cy.get(\`script[src^="https://www.googletagmanager.com/gtag/js"][async]\`);
			
			    // Make sure the Google Analytics library has loaded.
			    cy.window().should("have.property", "gtag");
			  \});
			
			  it("should have sent the first pageview", () => \{
			    cy.window().its("gaCalls").its(0).its(2).should("deep.equal", \{
			      send_to: "UA-XXXXXX-X",
			      page_title: pageviewHome.title,
			      page_location: pageviewHome.link,
			    \});
			    cy.window().its("gaCalls").its(1).its(2).should("deep.equal", \{
			      send_to: "UA-YYYYYY-Y",
			      page_title: pageviewHome.title,
			      page_location: pageviewHome.link,
			    \});
			  \});
			
			  it("should sent a pageview if the page changes", () => \{
			    cy.get("button#change-link").click();
			
			    cy.window().its("gaCalls").its(2).its(2).should("deep.equal", \{
			      send_to: "UA-XXXXXX-X",
			      page_title: pageviewSomePost.title,
			      page_location: pageviewSomePost.link,
			    \});
			    cy.window().its("gaCalls").its(3).its(2).should("deep.equal", \{
			      send_to: "UA-YYYYYY-Y",
			      page_title: pageviewSomePost.title,
			      page_location: pageviewSomePost.link,
			    \});
			  \});
			
			  it("should sent pageviews when going back or forward", () => \{
			    cy.get("button#change-link").click();
			    cy.go("back");
			
			    cy.window().its("gaCalls").its(4).its(2).should("deep.equal", \{
			      send_to: "UA-XXXXXX-X",
			      page_title: pageviewHome.title,
			      page_location: pageviewHome.link,
			    \});
			    cy.window().its("gaCalls").its(5).its(2).should("deep.equal", \{
			      send_to: "UA-YYYYYY-Y",
			      page_title: pageviewHome.title,
			      page_location: pageviewHome.link,
			    \});
			
			    cy.go("forward");
			
			    cy.window().its("gaCalls").its(6).its(2).should("deep.equal", \{
			      send_to: "UA-XXXXXX-X",
			      page_title: pageviewSomePost.title,
			      page_location: pageviewSomePost.link,
			    \});
			    cy.window().its("gaCalls").its(7).its(2).should("deep.equal", \{
			      send_to: "UA-YYYYYY-Y",
			      page_title: pageviewSomePost.title,
			      page_location: pageviewSomePost.link,
			    \});
			  \});
			
			  it("should send events", () => \{
			    cy.get("button#send-event").click();
			
			    cy.window().its("gaCalls").its(2).its(2).should("include", \{
			      content: "some content",
			      send_to: "UA-XXXXXX-X",
			      value: undefined,
			      event_category: undefined,
			      event_label: undefined,
			    \});
			    cy.window().its("gaCalls").its(3).its(2).should("include", \{
			      content: "some content",
			      send_to: "UA-YYYYYY-Y",
			      value: undefined,
			      event_category: undefined,
			      event_label: undefined,
			    \});
			
			    // Change testEvent to send Google Analytics specific data.
			    const someEvent = \{
			      name: "some-action",
			      payload: \{
			        category: "some-category",
			        label: "some-label",
			        value: "some-value",
			      \},
			    \};
			    cy.window().then((win) => \{
			      win.frontity.state.testAnalytics.testEvent = someEvent;
			    \});
			
			    // Send event again.
			    cy.get("button#send-event").click();
			
			    cy.window().its("gaCalls").its(4).its(2).should("include", \{
			      send_to: "UA-XXXXXX-X",
			      value: someEvent.payload.value,
			      event_category: someEvent.payload.category,
			      event_label: someEvent.payload.label,
			    \});
			    cy.window().its("gaCalls").its(5).its(2).should("include", \{
			      send_to: "UA-YYYYYY-Y",
			      value: someEvent.payload.value,
			      event_category: someEvent.payload.category,
			      event_label: someEvent.payload.label,
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\google-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\google-tag-manager-analytics.spec.js', () => {
        const sourceCode = `
			describe("Google Tag Manager", () => \{
			  const pageviewHome = \{
			    event: "pageview",
			    link: "/",
			    title: "Homepage Title",
			  \};
			
			  const pageviewSomePost = \{
			    event: "pageview",
			    link: "/some-post/",
			    title: "Some Post Title",
			  \};
			
			  const someEvent = \{
			    event: "some event",
			    payload: \{ content: "some content" \},
			  \};
			
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=google-tag-manager");
			  \});
			
			  it("should load Google Tag Manager library", () => \{
			    cy.get(
			      \`script[src="https://www.googletagmanager.com/gtm.js?id=GTM-XXXXXX-X"]\`
			    );
			  \});
			
			  it("should have sent the first pageview", () => \{
			    cy.window().its("dataLayer").its(1).should("deep.equal", pageviewHome);
			  \});
			
			  it("should sent a pageview if the page changes", () => \{
			    cy.get("button#change-link").click();
			    cy.window().its("dataLayer").its(2).should("deep.equal", pageviewSomePost);
			  \});
			
			  it("should sent pageviews when going back or forward", () => \{
			    cy.get("button#change-link").click();
			    cy.go("back");
			    cy.window().its("dataLayer").its(3).should("deep.equal", pageviewHome);
			
			    cy.go("forward");
			    cy.window().its("dataLayer").its(4).should("deep.equal", pageviewSomePost);
			  \});
			
			  it("should send events", () => \{
			    // Wait for the first pageview to be sent.
			    cy.window().its("dataLayer").its(1).should("deep.equal", pageviewHome);
			    // Send event.
			    cy.get("button#send-event").click();
			    cy.window().its("dataLayer").its(2).should("deep.equal", someEvent);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\google-tag-manager-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\head.spec.js', () => {
        const sourceCode = `
			describe("Head", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?site=head");
			  \});
			
			  it("should be able to have a title", () => \{
			    cy.get("title").should("have.text", "The Title");
			  \});
			
			  it("should be able to have a meta for description", () => \{
			    cy.get("meta[name='description']").should(
			      "have.attr",
			      "content",
			      "The Description"
			    );
			  \});
			
			  it("should be able to have html attributes", () => \{
			    cy.get("html").should("have.attr", "lang", "en");
			  \});
			
			  it("should be able to execute javascript in a script tag", () => \{
			    cy.window().should("have.property", "scriptTest", "pass");
			  \});
			
			  it("should be able to have links", () => \{
			    cy.get("link[rel='canonical']").should(
			      "have.attr",
			      "href",
			      "http://mysite.com/example"
			    );
			  \});
			
			  it("should be able to change body attributes", () => \{
			    cy.get("body").should("have.attr", "class", "new-class");
			  \});
			
			  it("should be able to have nonscripts", () => \{
			    cy.get("noscript").should("contain.text", "foo.css");
			  \});
			
			  it("should be able to add inline CSS", () => \{
			    cy.get("body").should("have.css", "background-color");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\head.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\html2react.spec.js', () => {
        const sourceCode = `
			describe("Html2React", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=html2react");
			  \});
			
			  it("should pass state to processors", () => \{
			    cy.get("p").should("have.css", "color", "rgb(0, 0, 255)");
			  \});
			
			  it("should re-render when the state is updated", () => \{
			    cy.get("button#change-color").click();
			    cy.get("p").should("have.css", "color", "rgb(255, 0, 0)");
			  \});
			
			  it("should work with old processors", () => \{
			    cy.get("span#old-processors").should("have.text", "Yes");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\html2react.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\iframe.spec.js', () => {
        const sourceCode = `
			import expect from "expect";
			
			// eslint-disable-next-line jest/valid-describe
			describe("Native iframe lazy-load", \{ browser: "!firefox" \}, () => \{
			  beforeEach(() => \{
			    cy.viewport(360, 640);
			    cy.visit("http://localhost:3001?frontity_name=iframe");
			  \});
			
			  it("should render an iframe with a loading attribute and 'lazy' as value", () => \{
			    cy.scrollTo("topLeft");
			    cy.get("iframe").should("have.attr", "loading", "lazy");
			  \});
			\});
			
			describe("Iframe lazy-load with Intersection Observer", () => \{
			  beforeEach(() => \{
			    cy.viewport(360, 640);
			    cy.visit("http://localhost:3001?frontity_name=iframe", \{
			      onBeforeLoad(win) \{
			        Object.defineProperty(win.HTMLIFrameElement.prototype, "loading", \{
			          configurable: true,
			          writable: true,
			        \});
			        delete win.HTMLIFrameElement.prototype.loading;
			      \},
			    \});
			  \});
			
			  it("native lazy-load should not exist in iframe element", () => \{
			    return cy
			      .window()
			      .its("HTMLIFrameElement")
			      .then((HTMLIframeElement) => \{
			        expect("loading" in HTMLIframeElement.prototype).toBe(false);
			      \});
			  \});
			
			  it("should not be visible until it is lazy-loaded", () => \{
			    cy.scrollTo("topLeft");
			    cy.get("iframe")
			      .should("have.attr", "loading", "lazy")
			      .should("not.be.visible");
			  \});
			
			  it("should lazy-load iframe", () => \{
			    cy.scrollTo("topLeft");
			    cy.get("iframe")
			      .should("have.attr", "loading", "lazy")
			      .should("not.be.visible");
			    cy.get("iframe").scrollIntoView(\{ duration: 300 \}).should("be.visible");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\iframe.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\image.spec.js', () => {
        const sourceCode = `
			describe("Image lazy-loading (with native lazy-load)", () => \{
			  beforeEach(() => \{
			    cy.viewport(360, 640);
			    cy.visit("http://localhost:3001?frontity_name=image");
			  \});
			
			  it("should render an image with loading=lazy", () => \{
			    cy.scrollTo("topLeft");
			    cy.get("img[height]").should("have.attr", "loading", "lazy");
			  \});
			\});
			
			describe("amp-image", () => \{
			  beforeEach(() => \{
			    cy.viewport(360, 640);
			    cy.visit("http://localhost:3001/amp-image/?frontity_name=amp-image");
			  \});
			
			  it("should render an amp-image", () => \{
			    cy.scrollTo("topLeft");
			    cy.get("amp-img[height]").should("have.attr", "layout", "fill");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\image.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\loadable.spec.js', () => {
        const sourceCode = `
			describe("Loadable", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=loadable");
			  \});
			
			  it("should be able to render elements from dynamic components", () => \{
			    cy.get("[data-test-id='dynamic-div']").should(
			      "have.text",
			      "I am the Dynamic1 component"
			    );
			    cy.get("[data-test-id='dynamic2-div']").should(
			      "have.text",
			      "I am the Dynamic2 component"
			    );
			  \});
			
			  it("should be able to use javascript from dynamic components", () => \{
			    cy.get("[data-test-id='toggle-div']").should("have.text", "OFF");
			    cy.get("[data-test-id='toggle-button']").click();
			    cy.get("[data-test-id='toggle-div']").should("have.text", "ON");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\loadable.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\render.spec.ts', () => {
        const sourceCode = `
			import \{ ResolvePackages \} from "../../../packages/types/src/utils";
			import \{ Packages \} from "../../packages/render/types";
			
			type WindowWithFrontity = Cypress.AUTWindow & \{
			  frontity: ResolvePackages<Packages>;
			\};
			
			describe("Render", () => \{
			  it("should rerender component subscribe to data object only once", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=render");
			
			    // Stubs calls to REST API.
			    cy.intercept(
			      "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			      \{
			        fixture: "render/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			      \}
			    );
			
			    cy.window().then((win: WindowWithFrontity) => \{
			      win.frontity.actions.router.set("/post-1");
			    \});
			    cy.location("href").should("eq", "http://localhost:3001/post-1/");
			    cy.get("[data-test-id='content']").should("contain", "Post 1");
			    cy.get("[data-test-id='counter']").should("have.text", "Renders: 2");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\render.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\script.spec.js', () => {
        const sourceCode = `
			import expect from "expect";
			
			describe("Script", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=script");
			  \});
			
			  it("should load a external script from src url", () => \{
			    cy.get("[id='from-src']")
			      .should(
			        "have.attr",
			        "src",
			        "https://unpkg.com/moment@2.24.0/min/moment.min.js"
			      )
			      .should("have.attr", "async", "async");
			  \});
			
			  it("should access code from the external script", () => \{
			    cy.window()
			      .its("moment")
			      .should("exist")
			      .then((moment) => \{
			        expect(moment()._isAMomentObject).toBe(true);
			      \});
			  \});
			
			  it("should load inline script", () => \{
			    cy.get("[data-test-id='target']").should("have.text", "OFF");
			    cy.get("[data-test-id='toggle']").click();
			    cy.get("[data-test-id='target']").should("have.text", "ON");
			  \});
			
			  it("should pass down other props and data attributes", () => \{
			    cy.get("[id='with-props']")
			      .should("have.attr", "randomProp", "random")
			      .should("have.attr", "otherRandomProp", "otherRandom")
			      .should("have.attr", "class", "someClassName")
			      .should("have.attr", "data-value", "3")
			      .within(([\$script]) => \{
			        expect(typeof \$script.onload).toBe("function");
			      \});
			  \});
			
			  /**
			   * This one was added to check this bug was solved:
			   * https://github.com/frontity/frontity/issues/592.
			   */
			  it("should not fail when scripts are unmounted", () => \{
			    cy.get("[data-test-id='unmount-script']").click();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\script.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\server-extensibility.spec.ts', () => {
        const sourceCode = `
			describe("Server Extensibility", () => \{
			  it("should render the root component", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=server-extensibility");
			
			    cy.get('[data-test-id="frontity-root"]').should(
			      "contain",
			      "Server Extensibility"
			    );
			  \});
			
			  it("should get the robots.txt file from the custom middleware using \`get\` from \`koa-route\` and handler signature \`fn(\{ctx\})", () => \{
			    cy.request("/robots-one.txt?frontity_name=server-extensibility")
			      .its("body")
			      .should(
			        "equal",
			        "User-agent: *\\nAllow: /\\nSitemap: http://www.example.com/sitemap.xml"
			      );
			  \});
			
			  it("should get the robots.txt file from the custom middleware using \`get\` from \`koa-route\` and handler signature \`fn(ctx)", () => \{
			    cy.request("/robots-two.txt?frontity_name=server-extensibility")
			      .its("body")
			      .should(
			        "equal",
			        "User-agent: *\\nAllow: /\\nSitemap: http://www.example.com/sitemap.xml"
			      );
			  \});
			
			  it("should change the headers of the request using both signatures \`fn(ctx, next)\` and \`fn(\{ctx, next\})\`", () => \{
			    cy.request("/?frontity_name=server-extensibility")
			      .its("headers")
			      .then((headers) => \{
			        assert.equal(headers["x-frontity-test-one"], "One");
			        assert.equal(headers["x-frontity-test-two"], "Two");
			        assert.equal(headers["x-frontity-test-three"], "Three");
			      \});
			  \});
			
			  it("should have access to the state", () => \{
			    cy.request("/state?frontity_name=server-extensibility")
			      .its("body")
			      .should("equal", "https://frontity.server.extensibility");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\server-extensibility.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\slot-and-fill.spec.js', () => {
        const sourceCode = `
			describe("useFills", () => \{
			  it("should show empty slots", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=slot-and-fill");
			    cy.get("#useFills-slot1-empty")
			      .should("exist")
			      .should("have.text", "useFills slot 1 empty");
			    cy.get("#useFills-slot2-empty")
			      .should("exist")
			      .should("have.text", "useFills slot 2 empty");
			  \});
			
			  it("should show first Fill", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=slot-and-fill");
			    cy.get("#addFill1").click();
			    cy.get("#useFills-slot1-empty").should("not.exist");
			    cy.get("#Fill1").should("exist").should("have.text", "I am Fill1");
			    cy.get("#useFills-slot2-empty").should("exist");
			  \});
			
			  it("should show second Fill", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=slot-and-fill");
			    cy.get("#addFill2").click();
			    cy.get("#useFills-slot1-empty").should("not.exist");
			    cy.get("#Fill2").should("exist").should("have.text", "I am Fill2");
			    cy.get("#useFills-slot2-empty").should("exist");
			  \});
			
			  it("should show both Fills in priority order", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=slot-and-fill");
			    cy.get("#addFill1").click();
			    cy.get("#addFill2").click();
			    cy.get("#useFills-slot1-empty").should("not.exist");
			    cy.get("#useFills-slot1").should("have.text", "I am Fill2I am Fill1");
			    cy.get("#useFills-slot2-empty").should("exist");
			  \});
			
			  it("should show the debug fills when \`state.frontity.debug\` is true", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=slot-and-fill");
			    cy.get("#toggleDebug").click();
			    cy.get("#useFills-slot1-empty").should("not.exist");
			    cy.get("#useFills-slot2-empty").should("not.exist");
			    cy.get("[data-slot-name='slot 1']").should("exist");
			    cy.get("[data-slot-name='slot 2']").should("exist");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\slot-and-fill.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\smart-adserver.spec.ts', () => {
        const sourceCode = `
			/**
			 * Disable temporary these tests until the ad calls return content.
			 */
			describe.skip("Smart Adserver", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=smart-adserver");
			  \});
			
			  it("Should load the smart adserver library", () => \{
			    // \`256\` is the networkId defined in state.smartAdserver.networkId
			    cy.get(\`script[src="//ced.sascdn.com/tag/256/smart.js"][async]\`).should(
			      "exist"
			    );
			  \});
			
			  // ----- Testing the various component configurations ------
			  it("Should render the ad using the SmartAd component from the libraries", () => \{
			    cy.get("#test-smartad").should("have.descendants", "img");
			  \});
			
			  it("Should render the ad using the SmartAd component and a default tag id", () => \{
			    // Check that when there is no tagId specified the the id is "sas_" + \`formatId\`
			    cy.get("#default-tag-id").should("have.descendants", "#sas_19809");
			    cy.get("#default-tag-id > #sas_19809").should("have.descendants", "img");
			  \});
			
			  it("Should render the ad in an iframe", () => \{
			    cy.get("#iframe-ad").should("have.descendants", "iframe");
			  \});
			
			  it("Should render the ad in the slot", () => \{
			    cy.get("#hello").should("have.descendants", "img");
			  \});
			
			  it("Should unmount correctly and show the other ad in the other page", () => \{
			    // Go to "/other-page/".
			    cy.get("button#change-page").click();
			
			    cy.get("#other-page-ad").should("have.descendants", "img");
			  \});
			
			  it("Should set the minHeight on the ad container if it makes the 'std' call", () => \{
			    cy.get("#std-min-height").should("have.descendants", "iframe");
			
			    cy.get("#std-min-height").should("have.css", "min-height", "100px");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\smart-adserver.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\source-auth.spec.ts', () => {
        const sourceCode = `
			describe("Source Auth", () => \{
			  it("Should remove the auth token from the client", () => \{
			    cy.visit(
			      // We load the 'render' site but it doesn't matter as we're only
			      // interested in window.frontity which is present in every site
			      "http://localhost:3001/?frontity_name=render&frontity_source_auth=test"
			    );
			
			    cy.window().its("frontity.state.source.auth").should("be.undefined");
			    cy.window()
			      .its("frontity.state.frontity.options.sourceAuth")
			      .should("be.undefined");
			  \});
			
			  it("Should remove auth token in a site with SSR-only", () => \{
			    cy.visitSSR(
			      "http://localhost:3001/?frontity_name=render&frontity_source_auth=test"
			    );
			
			    cy.window().its("frontity.state.source.auth").should("be.undefined");
			    cy.window()
			      .its("frontity.state.frontity.options.sourceAuth")
			      .should("be.undefined");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\source-auth.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\switch.spec.js', () => {
        const sourceCode = `
			describe("Switch", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=switch");
			  \});
			
			  it("should render last component when no matching component is found", () => \{
			    cy.get("h1#one").should("not.exist");
			    cy.get("h1#two").should("not.exist");
			    cy.get("h1").should("exist").should("have.text", "Default");
			  \});
			
			  it("should render components with truthy condition", () => \{
			    cy.get("h1#default").should("exist").should("have.text", "Default");
			
			    cy.get("button#set-to-1").click();
			    cy.get("h1#one").should("exist").should("have.text", "One");
			    cy.get("h1#two").should("not.exist");
			    cy.get("h1#default").should("not.exist");
			
			    cy.get("button#set-to-2").click();
			    cy.get("h1#two").should("exist").should("have.text", "Two");
			    cy.get("h1#one").should("not.exist");
			    cy.get("h1#default").should("not.exist");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\switch.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\tiny-router.spec.js', () => {
        const sourceCode = `
			describe("Tiny Router", () => \{
			  beforeEach(() => \{
			    cy.visit("http://localhost:3001?frontity_name=tiny-router");
			  \});
			
			  it("should show render contents in home", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Home");
			  \});
			
			  it("should switch route when using set", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			
			    cy.get('button[data-button-id="switch-to-about"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			
			    cy.get('button[data-button-id="switch-to-home"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Home");
			  \});
			
			  it("should switch route when using set with \`push\`", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			
			    cy.get('button[data-button-id="switch-using-push"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			  \});
			
			  it("should switch route when using set with \`replace\`", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			
			    cy.get('button[data-button-id="switch-using-replace"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			  \});
			
			  it("should replace history entry when using set with \`replace\`", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Home");
			
			    cy.get('button[data-button-id="switch-using-push"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			
			    cy.get('button[data-button-id="switch-to-privacy-using-replace"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/privacy/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Privacy");
			
			    cy.go("back");
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Home");
			  \});
			
			  it("should recover state when moving back and forward in history", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			
			    cy.get('button[data-button-id="switch-using-state"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			    cy.get('[data-test-id="has-state"]')
			      .should("exist")
			      .should("have.text", "Router has state!");
			
			    cy.get('button[data-button-id="switch-to-home"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Home");
			    cy.get('[data-test-id="has-state"]').should("not.exist");
			
			    cy.go("back");
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			    cy.get('[data-test-id="has-state"]')
			      .should("exist")
			      .should("have.text", "Router has state!");
			
			    cy.go("back");
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Home");
			    cy.get('[data-test-id="has-state"]').should("not.exist");
			
			    cy.go("forward");
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			    cy.get('[data-test-id="has-state"]')
			      .should("exist")
			      .should("have.text", "Router has state!");
			  \});
			
			  it("should work if link doesn't have a trailing forward slash", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			
			    cy.get('button[data-button-id="switch-to-about-no-trailing"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			  \});
			
			  it("should work if initial link doesn't have a trailing slash", () => \{
			    // Visit directly a not normalized link.
			    cy.visit("http://localhost:3001/about?frontity_name=tiny-router");
			
			    // The link should be normalized.
			    cy.location("href").should("eq", "http://localhost:3001/about/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "About");
			
			    // Other links should work as expected (Frontity hasn't stopped working).
			    cy.get('button[data-button-id="switch-to-home"]').click();
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('[data-test-id="content"]')
			      .should("exist")
			      .should("have.text", "Home");
			  \});
			
			  it("should scroll to the element when a hash link is clicked", () => \{
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get('div[id="hash-element"]').isNotInViewport();
			    cy.get('a[data-link-id="hash-link"]').click();
			    cy.get('div[id="hash-element"]').isInViewport();
			    cy.location("href").should("eq", "http://localhost:3001/#hash-element");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\tiny-router.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\use-in-view.spec.js', () => {
        const sourceCode = `
			describe("UseInView", () => \{
			  const url = "http://localhost:3001/?frontity_name=use-in-view";
			
			  it("useInView should return supported true", () => \{
			    cy.visit(url);
			    cy.location("href").should("eq", url);
			    cy.get("#supported").should("exist").should("have.text", "supported: true");
			  \});
			
			  it("useInView should return supported false", () => \{
			    cy.visit(url + "&removeIO");
			    cy.location("href").should("eq", url + "&removeIO");
			    cy.window().its("IntersectionObserver").should("eq", undefined);
			    cy.get("#supported")
			      .should("exist")
			      .should("have.text", "supported: false");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\use-in-view.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\frontity-01\\use-infinite-scroll.spec.ts', () => {
        const sourceCode = `
			/* eslint-disable jest/valid-describe */
			// Add the experimental fetch polyfill only for these tests. The new
			// \`cy.intercept\` API doesn't allow to change the response of a given URL once
			// it has been set, so we need to still use \`cy.server\` and \`cy.router\` here for
			// some tests.
			//
			// See https://github.com/cypress-io/cypress/issues/9302.
			//
			// There is a PR that will address this issue:
			// https://github.com/cypress-io/cypress/pull/14513.
			Cypress.config(\{
			  experimentalFetchPolyfill: true,
			\} as any);
			
			/**
			 * Add a spy on the \`actions.source.fetch\` function.
			 *
			 * @returns Cypress chainable.
			 */
			const spyOnFetch = () =>
			  cy.window().then((w: any) => cy.spy(w.frontity.actions.source, "fetch"));
			
			/**
			 * Get the \`actions.source.fetch\` function. Useful to make assertions after
			 * using the \`spyOnFetch\` helper.
			 *
			 * @returns Cypress chainable that yields the \`actions.source.fetch\` function.
			 */
			const getFetchSpy = () =>
			  cy.window().then((w: any) => w.frontity.actions.source.fetch);
			
			// There is a bug in the Intersection Observer of the headless Chromium browsers
			// so we don't test it there. We don't test it in Firefox either because we
			// haven't figured out yet the problems of its scroll restoration. Issues:
			// - https://github.com/frontity/frontity/issues/427
			// - https://github.com/frontity/frontity/pull/749
			if (
			  Cypress.browser.family === "chromium" &&
			  Cypress.browser.majorVersion > 85
			) \{
			  describe("useArchiveInfiniteScroll", () => \{
			    it("should load next page", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			
			      // Scrolls back to top.
			      cy.scrollTo("top");
			      cy.location("href").should("eq", "http://localhost:3001/");
			    \});
			
			    it("should return \`isError\` true", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        status: 503,
			        response: \{\},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.get("[data-test='error']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/");
			
			      // Try fetching again.
			      cy.get("[data-test='fetch']").should("exist").click();
			      cy.get("[data-test='fetch']").should("not.exist");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='error']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/");
			
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Try one more time.
			      cy.get("[data-test='fetch']").should("exist").click();
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			    \});
			
			    it("should do nothing if deactivated", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Deactivates the infinite scroll hooks.
			      cy.get("[data-test=toggle-infinite-scroll]").should("exist").click();
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      spyOnFetch();
			
			      // Scrolls to bottom, the next page should not be fetched. We wait here a
			      // short period of time just to be sure the request for the next page was
			      // not made.
			
			      // The request (if made) is made asynchronously right after the bottom
			      // element is visible, so it's not important the amount of time.
			
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      getFetchSpy().should("not.have.been.called");
			
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/");
			    \});
			
			    it("should fetch pages until the limit is reached", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=3",
			        response: "fixture:use-infinite-scroll/page-3.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageThree");
			
			      // Set the infinite scroll limit to two pages.
			      cy.get("[data-test=limit-infinite-scroll]").should("exist").click();
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			
			      spyOnFetch();
			
			      // Scrolls to bottom, the next page should not be fetched. We wait here a
			      // short period of time just to be sure the request for the next page was
			      // not made.
			
			      // The request (if made) is made asynchronously right after the bottom
			      // element is visible, so it's not important the amount of time.
			
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      getFetchSpy().should("not.have.been.called");
			
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-3']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			
			      // Fetching it manually after the limit is reached should work as expected.
			      cy.get("[data-test='fetch']").should("exist").click();
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-3']").should("not.exist");
			      cy.wait("@pageThree");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-3']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/3/");
			    \});
			
			    it("should fetch pages until the last one is fetched", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=3",
			        response: "fixture:use-infinite-scroll/page-3.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageThree");
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			
			      // Scrolls to bottom to fetch last page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-3']").should("not.exist");
			      cy.wait("@pageThree");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-3']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/3/");
			
			      spyOnFetch();
			
			      // Scrolls to bottom, no more pages should be fetched. We wait here a short
			      // period of time just to be sure the request for the next page was not
			      // made.
			
			      // The request (if made) is made asynchronously right after the bottom
			      // element is visible, so it's not important the amount of time.
			
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      getFetchSpy().should("not.have.been.called");
			
			      cy.get("[data-test='last']").should("exist");
			      cy.location("href").should("eq", "http://localhost:3001/page/3/");
			    \});
			
			    it("should keep fetched pages when going back and forward", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=3",
			        response: "fixture:use-infinite-scroll/page-3.json",
			        headers: \{
			          "x-wp-total": 21,
			          "x-wp-totalpages": 3,
			        \},
			        delay: 300,
			      \}).as("pageThree");
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			
			      // Scrolls to bottom to fetch last page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-3']").should("not.exist");
			      cy.wait("@pageThree");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-3']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/3/");
			
			      // Go to a post.
			      cy.get("[data-test='post-21-link']").should("exist").click();
			      cy.get("[data-test='post-21']").should("exist");
			
			      // Then, go back.
			      cy.go("back");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='page-2']").should("exist");
			      cy.get("[data-test='page-3']").should("exist").should("be.visible");
			      cy.location("href").should("eq", "http://localhost:3001/page/3/");
			
			      // Go back again.
			      cy.go("back");
			      cy.get("[data-test='page-1']").should("not.exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.get("[data-test='page-3']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Go forward this time.
			      cy.go("forward");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='page-2']").should("exist");
			      cy.get("[data-test='page-3']").should("exist").should("be.visible");
			      cy.location("href").should("eq", "http://localhost:3001/page/3/");
			    \});
			
			    it("should create a new infinite scroll context when going directly to a ready archive", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			      cy.server();
			      cy.route(\{
			        url:
			          "https://domain.com/wp-json/wp/v2/posts?_embed=true&categories=2&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("categoryPageTwo");
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			
			      // Go directly to "/category/two/"
			      cy.get("[data-test='to-category-two']").should("exist").click();
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.location("href").should("eq", "http://localhost:3001/category/two/");
			
			      // Scrolls to bottom to fetch next page.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='page-2']").should("not.exist");
			      cy.wait("@categoryPageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").scrollIntoView();
			      cy.location("href").should(
			        "eq",
			        "http://localhost:3001/category/two/page/2/"
			      );
			
			      // Go back, the link should point to "/page/2/"
			      cy.go("back");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='page-2']").should("exist").should("be.visible");
			      cy.location("href").should("eq", "http://localhost:3001/page/2/");
			    \});
			  \});
			
			  describe("usePostTypeInfiniteScroll", \{ browser: "!firefox" \}, () => \{
			    it("should load next post", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Scrolls back to top.
			      cy.scrollTo("top");
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			    \});
			
			    it("should return \`isError\` true", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-10",
			        response: "fixture:use-infinite-scroll/post-last.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("lastPost");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        status: 503,
			        response: \{\},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-last-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-10/");
			      cy.wait("@lastPost");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-10']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='post-11']").should("not.exist");
			      cy.get("[data-test='error']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-10/");
			
			      // Try fetching again.
			      cy.get("[data-test='fetch']").should("exist").click();
			      cy.get("[data-test='fetch']").should("not.exist");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='error']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-10/");
			
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Try one more time.
			      cy.get("[data-test='fetch']").should("exist").click();
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='post-11']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='post-11']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-11/");
			    \});
			
			    it("should not fetch next page if deactivated", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-10",
			        response: "fixture:use-infinite-scroll/post-last.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("lastPost");
			
			      // Deactivate the infinite scroll hooks.
			      cy.get("[data-test=toggle-infinite-scroll]").should("exist").click();
			
			      // Go to post last post of page 1.
			      cy.get("[data-test='to-last-post'").should("exist").click();
			
			      cy.location("href").should("eq", "http://localhost:3001/post-10/");
			      cy.wait("@lastPost");
			      cy.get("[data-test='post-10']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Spy on \`actions.source.fetch\` and then scroll down.
			      spyOnFetch();
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      // The next page should not be requested.
			      getFetchSpy().should("have.not.been.called");
			      cy.get("[data-test='fetching']").should("not.exist");
			      // The next post should not be rendered.
			      cy.get("[data-test='post-11']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-10/");
			    \});
			
			    it("should not show or fetch next post if deactivated", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("firstPost");
			
			      // Deactivate the infinite scroll hooks.
			      cy.get("[data-test=toggle-infinite-scroll]").should("exist").click();
			
			      // Go to post last post of page 1.
			      cy.get("[data-test='to-first-post'").should("exist").click();
			
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@firstPost");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Spy on \`actions.source.fetch\` and then scroll down.
			      spyOnFetch();
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      // The next page should not be requested.
			      getFetchSpy().should("have.not.been.called");
			      cy.get("[data-test='fetching']").should("not.exist");
			      // The next post should not be rendered.
			      cy.get("[data-test='post-2']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			    \});
			
			    it("should render posts until the limit is reached", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      // Limit posts to 2.
			      cy.get("[data-test=limit-infinite-scroll]").should("exist").click();
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Scrolls to bottom to fetch next post.
			      spyOnFetch();
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      // The next page should not be requested.
			      getFetchSpy().should("have.not.been.called");
			      cy.get("[data-test='post-2']").should("exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Fetching it manually after the limit is reached should work as expected.
			      cy.get("[data-test='fetch']").should("exist").click();
			      cy.get("[data-test='post-3']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-3/");
			    \});
			
			    it("should fetch the next page of post if needed", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-10",
			        response: "fixture:use-infinite-scroll/post-last.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("lastPost");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-last-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-10/");
			      cy.wait("@lastPost");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-10']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='fetching']").should("exist");
			      cy.get("[data-test='post-11']").should("not.exist");
			      cy.wait("@pageTwo");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.get("[data-test='post-11']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-11/");
			    \});
			
			    it("should keep rendered posts when going back and forward", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-3']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-3/");
			
			      // Go directly to the posts page.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Then, go back.
			      cy.go("back");
			      cy.get("[data-test='archive']").should("not.exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("exist");
			      cy.get("[data-test='post-3']").should("exist").should("be.visible");
			      cy.location("href").should("eq", "http://localhost:3001/post-3/");
			
			      // Go back again.
			      cy.go("back");
			      cy.get("[data-test='archive']").should("not.exist");
			      cy.get("[data-test='post-1']").should("not.exist");
			      cy.get("[data-test='post-2']").should("not.exist");
			      cy.get("[data-test='post-3']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Go forward this time.
			      cy.go("forward");
			      cy.get("[data-test='archive']").should("not.exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("exist");
			      cy.get("[data-test='post-3']").should("exist").should("be.visible");
			      cy.location("href").should("eq", "http://localhost:3001/post-3/");
			    \});
			
			    it("should render posts from the previous archive", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/categories?slug=one",
			        response: "fixture:use-infinite-scroll/category-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryOne");
			      cy.route(\{
			        url: "/wp-json/wp/v2/posts?_embed=true&categories=1&page=1",
			        response: "fixture:use-infinite-scroll/category-page-1.json",
			        headers: \{
			          "x-wp-total": "2",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryPageOne");
			
			      // Changes url to \`/category/one\`.
			      cy.get("[data-test='to-category-one']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/category/one/");
			      cy.wait("@categoryPageOne");
			
			      // Go to the first post of the category.
			      cy.get("[data-test='post-1-link'").should("exist").click();
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom. The next post of the category ("post-7") should be
			      // rendered.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-7']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-7/");
			
			      // The second post of the post archive (the posts page) should not exist.
			      cy.get("[data-test='post-2']").should("not.exist");
			
			      // Scroll to bottom. No more pages should be fetched.
			      spyOnFetch();
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      // The next page should not be requested.
			      getFetchSpy().should("have.not.been.called");
			      cy.get("[data-test='last'").should("exist");
			    \});
			
			    it("should render posts from the specified archive", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/categories?slug=one",
			        response: "fixture:use-infinite-scroll/category-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryOne");
			      cy.route(\{
			        url: "/wp-json/wp/v2/posts?_embed=true&categories=1&page=1",
			        response: "fixture:use-infinite-scroll/category-page-1.json",
			        headers: \{
			          "x-wp-total": "2",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryPageOne");
			
			      // Specify the archive source as \`/category/one\`.
			      cy.get("[data-test='set-archive']").should("exist").click();
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			
			      // Go to the first post of the category.
			      cy.get("[data-test='post-1-link'").should("exist").click();
			      cy.wait("@categoryPageOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom. The next post of the category ("post-7") should be
			      // rendered.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-7']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-7/");
			
			      // The second post of the post archive (the posts page) should not exist.
			      cy.get("[data-test='post-2']").should("not.exist");
			    \});
			
			    it("should render posts from the posts page ('/')", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      spyOnFetch();
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      getFetchSpy().should("have.been.calledWith", "/");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			    \});
			
			    it("should render posts from the posts page  ('/blog/')", () => \{
			      cy.visit(
			        "http://localhost:3001/test/?frontity_name=use-infinite-scroll&frontity_posts_page=/blog/"
			      );
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      spyOnFetch();
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      getFetchSpy().should("have.been.calledWith", "/blog/");
			      getFetchSpy().should("have.not.been.calledWith", "/");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Scrolls back to top.
			      cy.scrollTo("top");
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			    \});
			
			    it("should render posts from the posts page ('blog')", () => \{
			      cy.visit(
			        "http://localhost:3001/test/?frontity_name=use-infinite-scroll&frontity_posts_page=blog"
			      );
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      spyOnFetch();
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      getFetchSpy().should("have.been.calledWith", "/blog/");
			      getFetchSpy().should("have.not.been.calledWith", "/");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Scrolls back to top.
			      cy.scrollTo("top");
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			    \});
			
			    it("should render posts from the previous archive (w/ subdir)", () => \{
			      cy.visit(
			        "http://localhost:3001/subdir/test/?frontity_name=use-infinite-scroll&frontity_subdirectory=/subdir"
			      );
			      cy.location("href").should("eq", "http://localhost:3001/subdir/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/categories?slug=one",
			        response: "fixture:use-infinite-scroll/category-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryOne");
			      cy.route(\{
			        url: "/wp-json/wp/v2/posts?_embed=true&categories=1&page=1",
			        response: "fixture:use-infinite-scroll/category-page-1.json",
			        headers: \{
			          "x-wp-total": "2",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryPageOne");
			
			      // Changes url to \`/category/one\`.
			      cy.get("[data-test='to-category-one']").should("exist").click();
			      cy.location("href").should(
			        "eq",
			        "http://localhost:3001/subdir/category/one/"
			      );
			      cy.wait("@categoryPageOne");
			
			      // Go to the first post of the category.
			      cy.get("[data-test='post-1-link'").should("exist").click();
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom. The next post of the category ("post-7") should be
			      // rendered.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-7']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-7/");
			
			      // The second post of the post archive (the posts page) should not exist.
			      cy.get("[data-test='post-2']").should("not.exist");
			
			      // Scroll to bottom. No more pages should be fetched.
			      spyOnFetch();
			      // eslint-disable-next-line cypress/no-unnecessary-waiting
			      cy.scrollTo("bottom").wait(300);
			
			      // The next page should not be requested.
			      getFetchSpy().should("have.not.been.called");
			      cy.get("[data-test='last'").should("exist");
			    \});
			
			    it("should render posts from the specified archive (w/ subdir)", () => \{
			      cy.visit(
			        "http://localhost:3001/subdir/test/?frontity_name=use-infinite-scroll&frontity_subdirectory=/subdir"
			      );
			      cy.location("href").should("eq", "http://localhost:3001/subdir/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/categories?slug=one",
			        response: "fixture:use-infinite-scroll/category-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryOne");
			      cy.route(\{
			        url: "/wp-json/wp/v2/posts?_embed=true&categories=1&page=1",
			        response: "fixture:use-infinite-scroll/category-page-1.json",
			        headers: \{
			          "x-wp-total": "2",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryPageOne");
			
			      // Specify the archive source as \`/category/one\`.
			      cy.get("[data-test='set-archive']").should("exist").click();
			
			      // Changes url to \`/subdir/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/");
			      cy.wait("@pageOne");
			
			      // Go to the first post of the category.
			      cy.get("[data-test='post-1-link'").should("exist").click();
			      cy.wait("@categoryPageOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom. The next post of the category ("post-7") should be
			      // rendered.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-7']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-7/");
			
			      // The second post of the post archive (the posts page) should not exist.
			      cy.get("[data-test='post-2']").should("not.exist");
			    \});
			
			    it("should render posts from the posts page ('/', w/ subdir)", () => \{
			      cy.visit(
			        "http://localhost:3001/subdir/test/?frontity_name=use-infinite-scroll&frontity_subdirectory=/subdir"
			      );
			      cy.location("href").should("eq", "http://localhost:3001/subdir/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      spyOnFetch();
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      getFetchSpy().should("have.been.calledWith", "/subdir/");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-2/");
			    \});
			
			    it("should render posts from the posts page  ('/blog/', w/ subdir)", () => \{
			      cy.visit(
			        "http://localhost:3001/subdir/test/?frontity_name=use-infinite-scroll&frontity_posts_page=/blog/&frontity_subdirectory=/subdir"
			      );
			      cy.location("href").should("eq", "http://localhost:3001/subdir/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      spyOnFetch();
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      getFetchSpy().should("have.been.calledWith", "/subdir/blog/");
			      getFetchSpy().should("have.not.been.calledWith", "/");
			      getFetchSpy().should("have.not.been.calledWith", "/subdir/");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-2/");
			
			      // Scrolls back to top.
			      cy.scrollTo("top");
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-1/");
			    \});
			
			    it("should render posts from the posts page ('blog', w/ subdir)", () => \{
			      cy.visit(
			        "http://localhost:3001/subdir/test/?frontity_name=use-infinite-scroll&frontity_posts_page=blog&frontity_subdirectory=/subdir"
			      );
			      cy.location("href").should("eq", "http://localhost:3001/subdir/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": 20,
			          "x-wp-totalpages": 2,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			
			      spyOnFetch();
			
			      // Changes url to \`/post-type\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-1/");
			      cy.wait("@postOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      getFetchSpy().should("have.been.calledWith", "/subdir/blog/");
			      getFetchSpy().should("have.not.been.calledWith", "/");
			      getFetchSpy().should("have.not.been.calledWith", "/subdir/");
			
			      // Scrolls to bottom to fetch next post.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-2/");
			
			      // Scrolls back to top.
			      cy.scrollTo("top");
			      cy.location("href").should("eq", "http://localhost:3001/subdir/post-1/");
			    \});
			
			    it("should ignore redirected links", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1-with-redirections.json",
			        headers: \{
			          "x-wp-total": 4,
			          "x-wp-totalpages": 1,
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url:
			          "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=some-post",
			        response: "fixture:use-infinite-scroll/some-post.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("somePost");
			
			      // Changes url to \`/some-post\`.
			      cy.get("[data-test='to-some-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/some-post/");
			      cy.wait("@somePost");
			      cy.wait("@pageOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post. As redirections are ignored, the
			      // next rendered post should be the post 4 (last-post).
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("not.exist"); // Internal redirect.
			      cy.get("[data-test='post-3']").should("not.exist"); // External redirect.
			      cy.get("[data-test='post-4']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/last-post/");
			
			      // Changes url to \`/\`.
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.get("[data-test='archive']").should("exist");
			      cy.get("[data-test='page-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/");
			
			      // Then, go back. The last post should be visible.
			      cy.go("back");
			
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("not.exist");
			      cy.get("[data-test='post-3']").should("not.exist");
			      cy.get("[data-test='post-4']").should("exist").should("be.visible");
			      cy.location("href").should("eq", "http://localhost:3001/last-post/");
			    \});
			
			    it("should change the archive when visiting a new one", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/categories?slug=one",
			        response: "fixture:use-infinite-scroll/category-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryOne");
			      cy.route(\{
			        url: "/wp-json/wp/v2/posts?_embed=true&categories=1&page=1",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": "2",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryPageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-11",
			        response: "fixture:use-infinite-scroll/post-11.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postEleven");
			
			      // Changes url to \`/post-1\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.wait("@pageOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post. It should be "/post-2"
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Changes url to \`/category/one\`.
			      cy.get("[data-test='to-category-one']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/category/one/");
			      cy.wait("@categoryPageOne");
			
			      // Go to the first post of the category.
			      cy.get("[data-test='post-11-link'").should("exist").click();
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-11']").should("exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-11/");
			
			      // Scrolls to bottom to fetch next post. It should be "/post-12"
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-11']").should("exist");
			      cy.get("[data-test='post-12']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-12/");
			
			      // Then, go back two times, "/post-2" should be visible.
			      cy.go(-2);
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("exist").should("be.visible");
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Get the next post, it should be "/post-3"
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("exist");
			      cy.get("[data-test='post-3']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-3/");
			    \});
			
			    it("should keep the archive while scrolling", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			
			      // Main archive ("/")
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=2",
			        response: "fixture:use-infinite-scroll/page-2.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageTwo");
			
			      // Category one ("/category/one")
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-last.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/categories?slug=one",
			        response: "fixture:use-infinite-scroll/category-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryOne");
			      cy.route(\{
			        url: "/wp-json/wp/v2/posts?_embed=true&categories=1&page=1",
			        response: "fixture:use-infinite-scroll/category-page-1.json",
			        headers: \{
			          "x-wp-total": "2",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("categoryPageOne");
			
			      // Changes url to "/".
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			      cy.wait("@pageOne");
			
			      // Go to the penultimate post of the first page.
			      cy.get("[data-test='post-9-link'").should("exist").click();
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-9']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-9/");
			
			      // Change the source archive to "/category/one".
			      cy.get("[data-test='set-archive'").should("exist").click();
			
			      // Changes url to "/".
			      cy.get("[data-test='to-archive']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/");
			
			      // Go to  "/post-1".
			      cy.get("[data-test='post-1-link'").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			
			      // The next one should be the post 7.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-7']").should("exist").scrollIntoView();
			      cy.get("[data-test='post-type']").should("exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-7/");
			
			      // Go back to "/post-9".
			      cy.go(-2);
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-9']").should("exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-9/");
			
			      // Scroll down. The next one should be the post 10.
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-10']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-10/");
			
			      // Scroll down again. The next one should be the post 11 (from "/").
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-11']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-11/");
			    \});
			
			    it("should create a new infinite scroll context when going directly to a ready post", () => \{
			      cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			      cy.location("href").should("eq", "http://localhost:3001/test/");
			
			      // Stubs calls to REST API.
			
			      // Main archive ("/")
			      cy.server();
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			        response: "fixture:use-infinite-scroll/post-1.json",
			        headers: \{
			          "x-wp-total": "1",
			          "x-wp-totalpages": "1",
			        \},
			        delay: 300,
			      \}).as("postOne");
			      cy.route(\{
			        url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			        response: "fixture:use-infinite-scroll/page-1.json",
			        headers: \{
			          "x-wp-total": "20",
			          "x-wp-totalpages": "2",
			        \},
			        delay: 300,
			      \}).as("pageOne");
			
			      // Changes url to \`/post-1\`.
			      cy.get("[data-test='to-first-post']").should("exist").click();
			      cy.location("href").should("eq", "http://localhost:3001/post-1/");
			      cy.wait("@postOne");
			      cy.wait("@pageOne");
			      cy.get("[data-test='post-type']").should("exist");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='fetching']").should("not.exist");
			
			      // Scrolls to bottom to fetch next post. It should be "/post-2".
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-1']").should("exist");
			      cy.get("[data-test='post-2']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			      // Go directly to "/post-7".
			      cy.get("[data-test='to-post-7']").should("exist").click();
			      cy.get("[data-test='post-1']").should("not.exist");
			      cy.get("[data-test='post-2']").should("not.exist");
			      cy.get("[data-test='post-7']").should("exist");
			      cy.location("href").should("eq", "http://localhost:3001/post-7/");
			
			      // Scrolls to bottom to fetch next post. It should be "/post-8".
			      cy.scrollTo("bottom");
			      cy.get("[data-test='post-1']").should("not.exist");
			      cy.get("[data-test='post-2']").should("not.exist");
			      cy.get("[data-test='post-7']").should("exist");
			      cy.get("[data-test='post-8']").should("exist").scrollIntoView();
			      cy.location("href").should("eq", "http://localhost:3001/post-8/");
			    \});
			  \});
			
			  it("should render posts from the posts page if the link includes a query string", () => \{
			    cy.visit("http://localhost:3001/test/?frontity_name=use-infinite-scroll");
			    cy.location("href").should("eq", "http://localhost:3001/test/");
			
			    // Stubs calls to REST API.
			    cy.server();
			    cy.route(\{
			      url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&page=1",
			      response: "fixture:use-infinite-scroll/page-1.json",
			      headers: \{
			        "x-wp-total": 20,
			        "x-wp-totalpages": 2,
			      \},
			      delay: 300,
			    \}).as("pageOne");
			    cy.route(\{
			      url: "https://domain.com/wp-json/wp/v2/posts?_embed=true&slug=post-1",
			      response: "fixture:use-infinite-scroll/post-1.json",
			      headers: \{
			        "x-wp-total": "1",
			        "x-wp-totalpages": "1",
			      \},
			      delay: 300,
			    \}).as("postOne");
			
			    spyOnFetch();
			
			    // Changes url to \`/post-type\`.
			    cy.get("[data-test='to-post-1-with-query']").click();
			
			    // This post has a query string in the link
			    cy.location("href").should("eq", "http://localhost:3001/post-1/?q=123/");
			    cy.wait("@postOne");
			    cy.get("[data-test='post-type']").should("exist");
			    cy.get("[data-test='post-1']").should("exist");
			    cy.get("[data-test='fetching']").should("not.exist");
			
			    getFetchSpy().should("have.been.calledWith", "/");
			
			    // Scrolls to bottom to fetch next post.
			    cy.scrollTo("bottom");
			    cy.get("[data-test='post-2']").scrollIntoView();
			    cy.location("href").should("eq", "http://localhost:3001/post-2/");
			
			    // Scrolls to bottom to fetch next post.
			    cy.scrollTo("bottom");
			    cy.get("[data-test='post-3']").scrollIntoView();
			    cy.location("href").should("eq", "http://localhost:3001/post-3/");
			  \});
			\}
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\frontity-01\\use-infinite-scroll.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(29)
    });
    it('frontity_frontity\\e2e\\integration\\misc-01\\robots.spec.ts', () => {
        const sourceCode = `
			// Remove the file before each run to ensure that we start with a clean project.
			// We pass the -f option so that it doesn't throw the error in case the file
			// don't exist.
			beforeEach(() => \{
			  cy.exec("rm -f project/robots.txt");
			\});
			
			// Also clean up after each test run so that we don't pollute the repo.
			afterEach(() => \{
			  cy.exec("rm -f project/robots.txt");
			\});
			
			describe("Robots", () => \{
			  it("should respond with a default robots.txt", () => \{
			    cy.request("/robots.txt")
			      .its("body")
			      .should("equal", "User-agent: *\\nAllow: /");
			  \});
			
			  it("should respect the robots.txt file if present", () => \{
			    const robots = "User-agent: google\\nAllow: /";
			    cy.writeFile("project/robots.txt", robots);
			    cy.request("/robots.txt").its("body").should("equal", robots);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\misc-01\\robots.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\amp.spec.ts', () => {
        const sourceCode = `
			import expect from "expect";
			import type \{ taskTypes \} from "../../plugins";
			
			const task: taskTypes = cy.task;
			
			describe("AMP", () => \{
			  before(() => \{
			    task("loadDatabase", \{
			      path: "./wp-data/amp/data.sql",
			    \});
			  \});
			
			  it("amp-iframe", () => \{
			    const url = "http://localhost:3001/amp-iframe/?frontity_name=amp-wordpress";
			
			    cy.validateAMP(url);
			    cy.visit(url);
			
			    cy.get("amp-iframe").should(
			      "have.attr",
			      "src",
			      "https://mars.frontity.org"
			    );
			  \});
			
			  it("amp-img", () => \{
			    const url = "http://localhost:3001/amp-img/?frontity_name=amp-wordpress";
			
			    cy.validateAMP(url);
			    cy.visit(url);
			    cy.get("amp-img > img")
			      .should("have.attr", "src")
			      .and("contain", "ciudad_perdida");
			  \});
			
			  it("amp-audio", () => \{
			    const url = "http://localhost:3001/amp-audio/?frontity_name=amp-wordpress";
			
			    cy.validateAMP(url);
			    cy.visit(url);
			    cy.get("amp-audio > audio").should((els) => \{
			      const audio = els[0] as HTMLAudioElement;
			      audio.play();
			
			      // You can play the audio element
			      expect(audio.duration > 0 && !audio.paused && !audio.muted).toBe(true);
			
			      audio.pause();
			    \});
			
			    // The placeholder & fallback for the second audio element should exist
			    cy.get("#audio-2 amp-audio div[placeholder]").should("exist");
			    cy.get("#audio-2 amp-audio div[fallback]").should("exist");
			
			    // Second audio element that we've created in WP on the same page
			    cy.get("#audio-2 amp-audio > audio").should((els) => \{
			      const audio = els[0] as HTMLAudioElement;
			      audio.play();
			
			      // You can play the audio element
			      expect(audio.duration > 0 && !audio.paused && !audio.muted).toBe(true);
			
			      audio.pause();
			    \});
			
			    // The src has to be served over HTTPS
			    cy.get("#audio-2 amp-audio > audio > source")
			      .should("have.attr", "src")
			      .and("contain", "https://");
			  \});
			
			  it("amp-video", () => \{
			    const url = "http://localhost:3001/amp-video/?frontity_name=amp-wordpress";
			
			    cy.validateAMP(url);
			    cy.visit(url);
			    cy.get("amp-video > video").should((els) => \{
			      const video = els[0] as HTMLVideoElement;
			      video.play();
			
			      // You can play the video element
			      expect(video.duration > 0 && !video.paused && !video.muted).toBe(true);
			
			      video.pause();
			    \});
			
			    // The placeholder & fallback for the second video element should exist
			    cy.get("#video-2 amp-video div[placeholder]").should("exist");
			    cy.get("#video-2 amp-video div[fallback]").should("exist");
			
			    // Second video element that we've created in WP on the same page
			    cy.get("#video-2 amp-video > video").should((els) => \{
			      const video = els[0] as HTMLVideoElement;
			      video.play();
			
			      // You can play the video element
			      expect(video.duration > 0 && !video.paused && !video.muted).toBe(true);
			
			      video.pause();
			    \});
			
			    // The src has to be served over HTTPS
			    cy.get("#video-2 amp-video > video > source")
			      .should("have.attr", "src")
			      .and("contain", "https://");
			  \});
			
			  it("amp-twitter", () => \{
			    const url =
			      "http://localhost:3001/amp-twitter/?frontity_name=amp-wordpress";
			
			    cy.validateAMP(url);
			    cy.visit(url);
			
			    cy.get("amp-twitter > iframe").should("exist");
			  \});
			
			  it("amp-youtube", () => \{
			    const url =
			      "http://localhost:3001/amp-youtube/?frontity_name=amp-wordpress";
			
			    cy.validateAMP(url);
			    cy.visit(url);
			
			    cy.get("amp-youtube > iframe")
			      .should("have.attr", "src")
			      .and("contain", "https://www.youtube.com/embed/dQw4w9WgXcQ");
			  \});
			
			  it("picture tag should render correctly", () => \{
			    const url = "http://localhost:3001/picture/?frontity_name=amp-wordpress";
			
			    cy.validateAMP(url);
			    cy.visit(url);
			
			    cy.get("amp-img > img")
			      .should("have.attr", "src")
			      .and("contain", "ciudad_perdida");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\amp.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-aioseop-3.spec.ts', () => {
        const sourceCode = `
			import \{ ResolvePackages \} from "../../../packages/types/src/utils";
			import Router from "../../../packages/router/types";
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			type WindowWithFrontity = Cypress.AUTWindow & \{
			  frontity: ResolvePackages<Router>;
			\};
			
			describe("Head Tags - All in One SEO Pack 3", () => \{
			  before(() => \{
			    task("installPlugin", \{ name: "all-in-one-seo-pack", version: "3.7.1" \});
			    task("installPlugin", \{ name: "rest-api-head-tags" \});
			    task("installPlugin", \{ name: "custom-post-type-ui" \});
			    task("loadDatabase", \{
			      path: "./wp-data/head-tags/aioseop.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			    task("removeAllPlugins");
			  \});
			
			  /**
			   * Generates the full url to be loaded and tested.
			   *
			   * @param link - The pathname to wich the test should navigate.
			   * @returns The full url.
			   */
			  const fullURL = (link: string) =>
			    \`http://localhost:3001\$\{link\}?frontity_name=head-tags\`;
			
			  /**
			   * Check the title for the current page is the given one.
			   *
			   * @param link - The given link.
			   * @param title - The page title for the given link.
			   */
			  const checkTitle = (link: string, title: string) => \{
			    it("should render the correct title", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get("title").should("contain", title);
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the canonical link has been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkCanonical = (link: string) => \{
			    it("should render the correct canonical link", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('link[rel="canonical"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the ld+json schema has been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkSchema = (link: string) => \{
			    it("should render the schema tag", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('script[type="application/ld+json"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Change the router value in Frontity.
			   *
			   * @param link - The link of the page.
			   */
			  const routerSet = (link: string) => \{
			    cy.window().then((win: WindowWithFrontity) => \{
			      win.frontity.actions.router.set(link);
			    \});
			  \};
			
			  /**
			   * Tests for posts.
			   */
			  describe("Post", () => \{
			    const link = "/hello-world/";
			    const title = "Hello world! | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			
			    /**
			     * The \`checkSchema()\` call was replaced here by a check that the schema
			     * tag simply exists and it is not empty.
			     *
			     * The reason for this is that the tag content is not the same for different
			     * versions of WordPress:
			     * - 5.4 : \`"commentsCount": "1",\`.
			     * - 5.5 : \`"commentsCount": 1,\`.
			     */
			    it("should render the schema tag", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('script[type="application/ld+json"]').should("not.be.empty");
			      \});
			    \});
			  \});
			
			  /**
			   * Tests for pages.
			   */
			  describe("Page", () => \{
			    const link = "/sample-page/";
			    const title = "Sample Page | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for categories.
			   */
			  describe("Category", () => \{
			    const link = "/category/nature/";
			    const title = "Nature | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for tags.
			   */
			  describe("Tag", () => \{
			    const link = "/tag/japan/";
			    const title = "Japan | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for authors.
			   */
			  describe("Author", () => \{
			    const link = "/author/luisherranz";
			    const title = "luisherranz | Test WP Site";
			
			    /**
			     * We don't check the schema here because it is not included by the
			     * _REST API - Head Tags_ plugin when used along with _All in One SEO Pack_,
			     * because it is not generated correctly for authors.
			     */
			    checkTitle(link, title);
			    checkCanonical(link);
			  \});
			
			  /**
			   * Tests for the homepage.
			   */
			  describe("Homepage", () => \{
			    const link = "/";
			    const title = "Test WP Site | Just another WordPress site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for custom post types.
			   */
			  describe("CPT", () => \{
			    const link = "/movie/the-terminator/";
			    const title = "The Terminator | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("CPT (archive)", () => \{
			    const title = "Movies | Test WP Site";
			    const link = "/movies/";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("Custom Taxonomy", () => \{
			    const link = "/actor/linda-hamilton/";
			    const title = "Linda Hamilton | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Test for the \`<title>\` tag while navigating through Frontity.
			   */
			  describe("Title tag", () => \{
			    it("should be correct while navigating", () => \{
			      cy.visit(fullURL("/"));
			
			      cy.get("title").should(
			        "contain",
			        "Test WP Site | Just another WordPress site"
			      );
			
			      routerSet("/hello-world/");
			      cy.get("title").should("contain", "Hello world! | Test WP Site");
			
			      routerSet("/sample-page/");
			      cy.get("title").should("contain", "Sample Page | Test WP Site");
			
			      routerSet("/category/nature/");
			      cy.get("title").should("contain", "Nature | Test WP Site");
			
			      routerSet("/tag/japan/");
			      cy.get("title").should("contain", "Japan | Test WP Site");
			
			      routerSet("/author/luisherranz");
			      cy.get("title").should("contain", "luisherranz | Test WP Site");
			
			      routerSet("/movie/the-terminator/");
			      cy.get("title").should("contain", "The Terminator | Test WP Site");
			
			      routerSet("/movies/");
			      cy.get("title").should("contain", "Movies | Test WP Site");
			
			      routerSet("/actor/linda-hamilton/");
			      cy.get("title").should("contain", "Linda Hamilton | Test WP Site");
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-aioseop-3.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-aioseop-4.spec.ts', () => {
        const sourceCode = `
			import \{ ResolvePackages \} from "../../../packages/types/src/utils";
			import Router from "../../../packages/router/types";
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			type WindowWithFrontity = Cypress.AUTWindow & \{
			  frontity: ResolvePackages<Router>;
			\};
			
			describe.skip("Head Tags - All in One SEO Pack ^4.0.16", () => \{
			  before(() => \{
			    task("installPlugin", \{ name: "all-in-one-seo-pack" \});
			    task("installPlugin", \{ name: "rest-api-head-tags" \});
			    task("installPlugin", \{ name: "custom-post-type-ui" \});
			    task("loadDatabase", \{
			      path: "./wp-data/head-tags/aioseop-4.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			    task("removeAllPlugins");
			  \});
			
			  /**
			   * Generates the full url to be loaded and tested.
			   *
			   * @param link - The pathname to wich the test should navigate.
			   * @returns The full url.
			   */
			  const fullURL = (link: string) =>
			    \`http://localhost:3001\$\{link\}?frontity_name=head-tags\`;
			
			  /**
			   * Check the title for the current page is the given one.
			   *
			   * @param link - The given link.
			   * @param title - The page title for the given link.
			   */
			  const checkTitle = (link: string, title: string) => \{
			    it("should render the correct title", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get("title").should("contain", title);
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the canonical link has been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkCanonical = (link: string) => \{
			    it("should render the correct canonical link", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('link[rel="canonical"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the ld+json schema has been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkSchema = (link: string) => \{
			    it("should render the schema tag", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('script[type="application/ld+json"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the Open Graph meta tags have been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkOpenGraphTags = (link: string) => \{
			    it("should render the Open Graph tags", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get(
			          \`
			        meta[property^="og:"],
			        meta[property^="article:"],
			        meta[property^="profile:"]
			        \`
			        ).each((meta) => \{
			          cy.wrap(meta).toMatchSnapshot();
			        \});
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the Twitter meta tags have been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkTwitterTags = (link: string) => \{
			    it("should render the Twitter tags", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('meta[property^="twitter:"]').each((meta) => \{
			          cy.wrap(meta).toMatchSnapshot();
			        \});
			      \});
			    \});
			  \};
			
			  /**
			   * Change the router value in Frontity.
			   *
			   * @param link - The link of the page.
			   */
			  const routerSet = (link: string) => \{
			    cy.window().then((win: WindowWithFrontity) => \{
			      win.frontity.actions.router.set(link);
			    \});
			  \};
			
			  /**
			   * Tests for posts.
			   */
			  describe("Post", () => \{
			    const link = "/hello-world/";
			    const title = "Hello world! | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkOpenGraphTags(link);
			    checkTwitterTags(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for pages.
			   */
			  describe("Page", () => \{
			    const link = "/sample-page/";
			    const title = "Sample Page | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkOpenGraphTags(link);
			    checkTwitterTags(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for categories.
			   */
			  describe("Category", () => \{
			    const link = "/category/nature/";
			    const title = "Nature | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for tags.
			   */
			  describe("Tag", () => \{
			    const link = "/tag/japan/";
			    const title = "Japan | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for authors.
			   */
			  describe("Author", () => \{
			    const link = "/author/luisherranz";
			    const title = "luisherranz | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for the homepage.
			   */
			  describe("Homepage", () => \{
			    const link = "/";
			    const title = "Test WP Site | Just another WordPress site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkOpenGraphTags(link);
			    checkTwitterTags(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for custom post types.
			   */
			  describe("CPT", () => \{
			    const link = "/movie/the-terminator/";
			    const title = "The Terminator | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkOpenGraphTags(link);
			    checkTwitterTags(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("CPT (archive)", () => \{
			    const title = "Movies | Test WP Site";
			    const link = "/movies/";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Tests for custom taxonomies.
			   */
			  describe("Custom Taxonomy", () => \{
			    const link = "/actor/linda-hamilton/";
			    const title = "Linda Hamilton | Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkSchema(link);
			  \});
			
			  /**
			   * Test for the \`<title>\` tag while navigating through Frontity.
			   */
			  describe("Title tag", () => \{
			    it("should be correct while navigating", () => \{
			      cy.visit(fullURL("/"));
			
			      cy.get("title").should(
			        "contain",
			        "Test WP Site | Just another WordPress site"
			      );
			
			      routerSet("/hello-world/");
			      cy.get("title").should("contain", "Hello world! | Test WP Site");
			
			      routerSet("/sample-page/");
			      cy.get("title").should("contain", "Sample Page | Test WP Site");
			
			      routerSet("/category/nature/");
			      cy.get("title").should("contain", "Nature | Test WP Site");
			
			      routerSet("/tag/japan/");
			      cy.get("title").should("contain", "Japan | Test WP Site");
			
			      routerSet("/author/luisherranz");
			      cy.get("title").should("contain", "luisherranz | Test WP Site");
			
			      routerSet("/movie/the-terminator/");
			      cy.get("title").should("contain", "The Terminator | Test WP Site");
			
			      routerSet("/movies/");
			      cy.get("title").should("contain", "Movies | Test WP Site");
			
			      routerSet("/actor/linda-hamilton/");
			      cy.get("title").should("contain", "Linda Hamilton | Test WP Site");
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-aioseop-4.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-wpseo.spec.ts', () => {
        const sourceCode = `
			import \{ ResolvePackages \} from "../../../packages/types/src/utils";
			import Router from "../../../packages/router/types";
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			type WindowWithFrontity = Cypress.AUTWindow & \{
			  frontity: ResolvePackages<Router>;
			\};
			
			describe("Head Tags - WP SEO", () => \{
			  before(() => \{
			    task("installPlugin", \{
			      name: "https://github.com/alleyinteractive/wp-seo/archive/main.zip",
			    \});
			    task("installPlugin", \{ name: "rest-api-head-tags" \});
			    task("installPlugin", \{ name: "custom-post-type-ui" \});
			    task("loadDatabase", \{
			      path: "./wp-data/head-tags/wpseo.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			    task("removeAllPlugins");
			  \});
			
			  /**
			   * Generates the full url to be loaded and tested.
			   *
			   * @param link - The pathname to wich the test should navigate.
			   * @returns The full url.
			   */
			  const fullURL = (link: string) =>
			    \`http://localhost:3001\$\{link\}?frontity_name=head-tags\`;
			
			  /**
			   * Check the title for the current page is the given one.
			   *
			   * @param link - The given link.
			   * @param title - The page title for the given link.
			   */
			  const checkTitle = (link: string, title: string) => \{
			    it("should render the correct title", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get("title").should("contain", title);
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the canonical link has been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkCanonical = (link: string) => \{
			    it("should render the correct canonical link", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('link[rel="canonical"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Ensure that the ld+json schema has been rendered.
			   *
			   * @param link - The given link.
			   */
			  const checkCustomTag = (link: string) => \{
			    it("should render a custom tag", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('meta[name="custom-tag"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Change the router value in Frontity.
			   *
			   * @param link - The link of the page.
			   */
			  const routerSet = (link: string) => \{
			    cy.window().then((win: WindowWithFrontity) => \{
			      win.frontity.actions.router.set(link);
			    \});
			  \};
			
			  /**
			   * Tests for posts.
			   */
			  describe("Post", () => \{
			    const link = "/hello-world/";
			    const title = "Post: Hello world! ~ Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for pages.
			   */
			  describe("Page", () => \{
			    const link = "/sample-page/";
			    const title = "Page: Sample Page ~ Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for categories.
			   */
			  describe("Category", () => \{
			    const link = "/category/nature/";
			    const title = "Nature archives ~ Test WP Site";
			
			    /**
			     * We don't check the canonical for any archive because it is not included
			     * by the WordPress theme when the WP SEO plugin is used.
			     */
			    checkTitle(link, title);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for tags.
			   */
			  describe("Tag", () => \{
			    const link = "/tag/japan/";
			    const title = "Japan archives ~ Test WP Site";
			
			    /**
			     * We don't check the canonical for any archive because it is not included
			     * by the WordPress theme when the WP SEO plugin is used.
			     */
			    checkTitle(link, title);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for authors.
			   */
			  describe("Author", () => \{
			    const link = "/author/luisherranz";
			    const title = "luisherranz, author at Test WP Site";
			
			    /**
			     * We don't check the canonical for any archive because it is not included
			     * by the WordPress theme when the WP SEO plugin is used.
			     */
			    checkTitle(link, title);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for the homepage.
			   */
			  describe("Homepage", () => \{
			    const link = "/";
			    const title = "Test WP Site ~ Just another WordPress site";
			
			    /**
			     * We don't check the canonical for any archive because it is not included
			     * by the WordPress theme when the WP SEO plugin is used.
			     */
			    checkTitle(link, title);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for custom post types.
			   */
			  describe("CPT", () => \{
			    const link = "/movie/the-terminator/";
			    const title = "Movie: The Terminator ~ Test WP Site";
			
			    checkTitle(link, title);
			    checkCanonical(link);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("CPT (archive)", () => \{
			    const title = "Movies archive ~ Test WP Site";
			    const link = "/movies/";
			
			    /**
			     * We don't check the canonical for any archive because it is not included
			     * by the WordPress theme when the WP SEO plugin is used.
			     */
			    checkTitle(link, title);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("Custom Taxonomy", () => \{
			    const link = "/actor/linda-hamilton/";
			    const title = "Linda Hamilton archives ~ Test WP Site";
			
			    /**
			     * We don't check the canonical for any archive because it is not included
			     * by the WordPress theme when the WP SEO plugin is used.
			     */
			    checkTitle(link, title);
			    checkCustomTag(link);
			  \});
			
			  /**
			   * Test for the \`<title>\` tag while navigating through Frontity.
			   */
			  describe("Title tag", () => \{
			    it("should be correct while navigating", () => \{
			      cy.visit(fullURL("/"));
			
			      cy.get("title").should(
			        "contain",
			        "Test WP Site ~ Just another WordPress site"
			      );
			
			      routerSet("/hello-world/");
			      cy.get("title").should("contain", "Post: Hello world! ~ Test WP Site");
			
			      routerSet("/sample-page/");
			      cy.get("title").should("contain", "Page: Sample Page ~ Test WP Site");
			
			      routerSet("/category/nature/");
			      cy.get("title").should("contain", "Nature archives ~ Test WP Site");
			
			      routerSet("/tag/japan/");
			      cy.get("title").should("contain", "Japan archives ~ Test WP Site");
			
			      routerSet("/author/luisherranz");
			      cy.get("title").should("contain", "luisherranz, author at Test WP Site");
			
			      routerSet("/movie/the-terminator/");
			      cy.get("title").should("contain", "Movie: The Terminator ~ Test WP Site");
			
			      routerSet("/movies/");
			      cy.get("title").should("contain", "Movies archive ~ Test WP Site");
			
			      routerSet("/actor/linda-hamilton/");
			      cy.get("title").should(
			        "contain",
			        "Linda Hamilton archives ~ Test WP Site"
			      );
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-wpseo.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-yoast-13.spec.ts', () => {
        const sourceCode = `
			import \{ ResolvePackages \} from "../../../packages/types/src/utils";
			import Router from "../../../packages/router/types";
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			type WindowWithFrontity = Cypress.AUTWindow & \{
			  frontity: ResolvePackages<Router>;
			\};
			
			describe("Head Tags - Yoast 13.5", () => \{
			  before(() => \{
			    task("installPlugin", \{ name: "wordpress-seo", version: "13.5" \});
			    task("installPlugin", \{ name: "rest-api-head-tags" \});
			    task("installPlugin", \{ name: "custom-post-type-ui" \});
			    task("loadDatabase", \{
			      path: "./wp-data/head-tags/yoast-13.5.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			    task("removeAllPlugins");
			  \});
			
			  /**
			   * Generates the full url to be loaded and tested.
			   *
			   * @param link - The pathname to wich the test should navigate.
			   * @returns The full url.
			   */
			  const fullURL = (link: string) =>
			    \`http://localhost:3001\$\{link\}?frontity_name=head-tags\`;
			
			  /**
			   * Check the title for the current page is the given one.
			   *
			   * @param link - The given link.
			   * @param title - The page title for the given link.
			   */
			  const checkTitle = (link: string, title: string) => \{
			    it("should render the correct title", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get("title").should("contain", title);
			      \});
			    \});
			  \};
			
			  /**
			   * Run a set of test to ensure the correct meta tags are being rendered.
			   *
			   * This way, snapshots are generated with a meaningful name and are easy to
			   * read and check by a human being.
			   *
			   * @param link - The given link.
			   * @remarks The <title> tag is not tested using snapshots. That's because the
			   * plugin we are using to generate snapshots gives an error when trying to
			   * generate a snapshot for that tag (it also doesn't work well with strings).
			   */
			  const checkMetaTags = (link: string) => \{
			    it("should render the correct canonical URL", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('link[rel="canonical"]').toMatchSnapshot();
			      \});
			    \});
			
			    it("should render the robots tag", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('meta[name="robots"]').toMatchSnapshot();
			      \});
			    \});
			
			    it("should render the Open Graph tags", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get(
			          \`
			        meta[property^="og:"],
			        meta[property^="article:"],
			        meta[property^="profile:"]
			        \`
			        ).each((meta) => \{
			          cy.wrap(meta).toMatchSnapshot();
			        \});
			      \});
			    \});
			
			    it("should render the Twitter tags", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('meta[name^="twitter:"]').each((meta) => \{
			          cy.wrap(meta).toMatchSnapshot();
			        \});
			      \});
			    \});
			
			    it("should render the schema tag", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('script[type="application/ld+json"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Change the router value in Frontity.
			   *
			   * @param link - The link of the page.
			   */
			  const routerSet = (link: string) => \{
			    cy.window().then((win: WindowWithFrontity) => \{
			      win.frontity.actions.router.set(link);
			    \});
			  \};
			
			  /**
			   * Tests for posts.
			   */
			  describe("Post", () => \{
			    const link = "/hello-world/";
			    const title = "Hello World From Yoast! - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for pages.
			   */
			  describe("Page", () => \{
			    const link = "/sample-page/";
			    const title = "Sample Page - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for categories.
			   */
			  describe("Category", () => \{
			    const link = "/category/nature/";
			    const title = "Nature Archives - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for tags.
			   */
			  describe("Tag", () => \{
			    const link = "/tag/japan/";
			    const title = "Japan Archives - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for authors.
			   */
			  describe("Author", () => \{
			    const link = "/author/luisherranz";
			    const title = "luisherranz, Author at Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for the homepage.
			   */
			  describe("Homepage", () => \{
			    const link = "/";
			    const title = "Test WP Site - Just another WordPress site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for custom post types.
			   */
			  describe("CPT", () => \{
			    const link = "/movie/the-terminator/";
			    const title = "The Terminator - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("CPT (archive)", () => \{
			    const title = "Movies Archive - Test WP Site";
			    const link = "/movies/";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("Custom Taxonomy", () => \{
			    const link = "/actor/linda-hamilton/";
			    const title = "Linda Hamilton Archives - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Test for the \`<title>\` tag while navigating through Frontity.
			   */
			  describe("Title tag", () => \{
			    it("should be correct while navigating", () => \{
			      cy.visit(fullURL("/"));
			
			      cy.get("title").should(
			        "contain",
			        "Test WP Site - Just another WordPress site"
			      );
			
			      routerSet("/hello-world/");
			      cy.get("title").should(
			        "contain",
			        "Hello World From Yoast! - Test WP Site"
			      );
			
			      routerSet("/sample-page/");
			      cy.get("title").should("contain", "Sample Page - Test WP Site");
			
			      routerSet("/category/nature/");
			      cy.get("title").should("contain", "Nature Archives - Test WP Site");
			
			      routerSet("/tag/japan/");
			      cy.get("title").should("contain", "Japan Archives - Test WP Site");
			
			      routerSet("/author/luisherranz");
			      cy.get("title").should("contain", "luisherranz, Author at Test WP Site");
			
			      routerSet("/movie/the-terminator/");
			      cy.get("title").should("contain", "The Terminator - Test WP Site");
			
			      routerSet("/movies/");
			      cy.get("title").should("contain", "Movies Archive - Test WP Site");
			
			      routerSet("/actor/linda-hamilton/");
			      cy.get("title").should(
			        "contain",
			        "Linda Hamilton Archives - Test WP Site"
			      );
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\head-tags-yoast-13.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\mars-theme-amp.spec.ts', () => {
        const sourceCode = `
			import expect from "expect";
			import amphtmlValidator, \{ Validator \} from "amphtml-validator";
			
			import type \{ taskTypes \} from "../../plugins";
			
			const task: taskTypes = cy.task;
			
			describe("mars-theme with AMP", () => \{
			  let validator: Validator;
			  before(async () => \{
			    validator = await amphtmlValidator.getInstance();
			  \});
			
			  before(() => \{
			    task("loadDatabase", \{
			      path: "./wp-data/amp-mars-theme/data.sql",
			    \});
			  \});
			
			  it("front page", () => \{
			    const url = "http://localhost:3001/?frontity_name=amp-mars-theme";
			
			    // The validator should only throw ONE error for missing rel=canonical link.
			    // This is because it's the reponsibility of the user to create the
			    // <link rel="canonical" /> tag.
			    cy.request("GET", url).then((response) => \{
			      const result = validator.validateString(response.body);
			      expect(result.errors).toHaveLength(1);
			      expect(result.errors[0].message).toBe(
			        "The mandatory tag 'link rel=canonical' is missing or incorrect."
			      );
			    \});
			
			    cy.visit(url);
			    cy.get("section > article").should("have.length", 2);
			  \});
			
			  it("individual post page", () => \{
			    const url =
			      "http://localhost:3001/the-white-heron/?frontity_name=amp-mars-theme";
			
			    // The validator should only throw ONE error for missing rel=canonical link.
			    // This is because it's the reponsibility of the user to create the
			    // <link rel="canonical" /> tag.
			    cy.request("GET", url).then((response) => \{
			      const result = validator.validateString(response.body);
			      expect(result.errors).toHaveLength(1);
			      expect(result.errors[0].message).toBe(
			        "The mandatory tag 'link rel=canonical' is missing or incorrect."
			      );
			    \});
			
			    cy.visit(url);
			
			    cy.get("figure.wp-block-image > amp-img").should("have.descendants", "img");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\mars-theme-amp.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\redirections.spec.ts', () => {
        const sourceCode = `
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			describe("Redirections", () => \{
			  before(() => \{
			    task("installPlugin", \{ name: "redirection" \});
			    task("loadDatabase", \{
			      path: "./wp-data/301-redirections/dump.sql",
			    \});
			  \});
			
			  it("Should redirect when loading the page directly", () => \{
			    cy.visit("http://localhost:3001/hello-world/?frontity_name=redirections");
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should redirect to the requested domain, not to \`state.frontity.url\`", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world/?frontity_name=redirections&frontity_url=http://my.frontity.site"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should not redirect server side when in embedded mode", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world/?frontity_name=redirections&frontity_embedded=true",
			      \{ failOnStatusCode: false \}
			    );
			
			    cy.location("href").should("eq", "http://localhost:3001/hello-world/");
			    cy.get("#post").should("not.exist");
			    cy.get("#404").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should not redirect server side when in embedded mode for 404", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world/?frontity_name=redirections&frontity_embedded=true&redirections=404",
			      \{ failOnStatusCode: false \}
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world/?redirections=404"
			    );
			    cy.get("#post").should("not.exist");
			    cy.get("#404").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should handle query params in a redirection", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world/?frontity_name=redirections&redirections=all"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/?redirections=all"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should handle query params in a redirection, and NOT redirect if NOT matching the RegExp", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world/?frontity_name=redirections&redirections=RegExp:/some-post",
			      \{ failOnStatusCode: false \}
			    );
			
			    // The RegExp is URI-encoded.
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world/?redirections=RegExp%3A%2Fsome-post"
			    );
			    cy.get("#404").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should redirect when navigating on the client", () => \{
			    cy.visit("http://localhost:3001?frontity_name=redirections");
			
			    // Go to the "redirected" page.
			    cy.get("#open-post").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should redirect when navigating on the client in embedded mode", () => \{
			    cy.visit(
			      "http://localhost:3001?frontity_name=redirections&frontity_embedded=true"
			    );
			
			    // Go to the "redirected" page.
			    cy.get("#open-post").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should redirect 404s when navigating on the client in embedded mode", () => \{
			    cy.visit(
			      "http://localhost:3001?frontity_name=redirections&frontity_embedded=true&redirections=404"
			    );
			
			    // Go to the "redirected" page.
			    cy.get("#open-post").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("The back and forward button should work fine when navigating", () => \{
			    cy.visit("http://localhost:3001?frontity_name=redirections");
			
			    // Go to the "redirected" page.
			    cy.get("#open-post").click();
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			
			    // Go back to the homepage.
			    cy.go("back");
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get("#archive").should("exist");
			    cy.get("#link-counter").should("contain.text", "4");
			
			    // Go to the "redirected" page again using the link.
			    cy.get("#open-post").click();
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "5");
			
			    // Go back to the homepage.
			    cy.go("back");
			    cy.location("href").should("eq", "http://localhost:3001/");
			    cy.get("#archive").should("exist");
			    cy.get("#link-counter").should("contain.text", "6");
			
			    // Go to the "redirected" page again using the forward button.
			    cy.go("forward");
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "7");
			  \});
			
			  it("Should not trigger a redirection when you prefetch the data for a (redirected) post", () => \{
			    cy.visit(
			      "http://localhost:3001/post-with-prefetch/?frontity_name=redirections"
			    );
			
			    // We need to wait to see if the redirection is triggered.
			    // eslint-disable-next-line cypress/no-unnecessary-waiting
			    cy.wait(3000);
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/post-with-prefetch/"
			    );
			
			    cy.get("#post").should("contain.text", "Post with prefetch");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work with a double redirection on the server", () => \{
			    cy.visit("http://localhost:3001/initial-url/?frontity_name=redirections");
			
			    cy.location("href").should("eq", "http://localhost:3001/final-url/");
			
			    cy.get("#post").should("contain.text", "Post: Doubly redirected post");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work with a double redirection on the client", () => \{
			    cy.visit("http://localhost:3001?frontity_name=redirections");
			
			    cy.get("#doubly-redirected").click();
			
			    cy.location("href").should("eq", "http://localhost:3001/final-url/");
			    cy.get("#post").should("contain.text", "Post: Doubly redirected post");
			    // This is 3 instead of 4 because the browser hides all the intermediate
			    // redirections and we only see the final one.
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should work with a 302 redirection on the server", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world-302?frontity_name=redirections"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work with a 302 redirection on the client", () => \{
			    cy.visit("http://localhost:3001?frontity_name=redirections");
			
			    cy.get("#302-redirection").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should work with a 307 redirection on the server", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world-307?frontity_name=redirections"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  // The 307 Redirections are failing due to a CORS issue on the client so this
			  // test is going to be disabled for the time being.
			  // eslint-disable-next-line
			  it.skip("Should work with a 307 redirection on the client", () => \{
			    cy.visit("http://localhost:3001?frontity_name=redirections");
			
			    cy.get("#307-redirection").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should work with a 308 redirection on the server", () => \{
			    cy.visit(
			      "http://localhost:3001/hello-world-308?frontity_name=redirections"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work with a 308 redirection on the client", () => \{
			    cy.visit("http://localhost:3001?frontity_name=redirections");
			
			    cy.get("#308-redirection").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should work when we create a redirection using the 'Ignore and pass parameters to the target' option in the server", () => \{
			    cy.visit(
			      "http://localhost:3001/should-preserve-query?frontity_name=redirections&a=1&b=2"
			    );
			
			    // Note that the queries are preserved and sorted after the redirection.
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/?a=1&b=2"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work when we create a redirection using the 'Ignore and pass parameters to the target' option in the client", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=redirections");
			
			    cy.get("#should-preserve-query").click();
			
			    // Note that the queries are preserved and sorted after the redirection.
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/?a=1&b=2"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should work with redirections that match a query string in the backend", () => \{
			    cy.visit(
			      "http://localhost:3001/match-query/?key=value&frontity_name=redirections"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/?key=value"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work with redirections defined directly in the state on the server", () => \{
			    cy.visit(
			      "http://localhost:3001/redirected-url/?frontity_name=redirections"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work with redirections defined directly in the state on the client", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=redirections");
			
			    cy.get("#redirection-stored-in-state").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "2");
			  \});
			
			  it("Should work with redirections defined as custom handlers in the server", () => \{
			    cy.visit(
			      "http://localhost:3001/urls-with-redirections/test/?frontity_name=redirections"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should work with redirections defined as custom handlers in the client", () => \{
			    cy.visit("http://localhost:3001/?frontity_name=redirections");
			
			    cy.get("#redirection-in-handler").click();
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/hello-world-redirected/"
			    );
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "3");
			  \});
			
			  it("Should redirect to an external domain on the server", () => \{
			    task("runCommand", \{
			      command:
			        "npx forever start ./node_modules/.bin/http-server --cors -p 8181 --proxy http://localhost:8080 -d false",
			    \});
			
			    cy.visit(
			      "http://localhost:3001/external-redirect/?frontity_name=redirections"
			    );
			
			    cy.location("href").should(
			      "eq",
			      "http://localhost:8181/hello-world-redirected/"
			    );
			    cy.get("h1").should("contain.text", "Hello world!");
			
			    task("runCommand", \{ command: "npx forever stopall" \});
			  \});
			
			  it("Should redirect to an external domain that has CORS on the client", () => \{
			    task("runCommand", \{
			      command:
			        "npx forever start ./node_modules/.bin/http-server --cors -p 8181 --proxy http://localhost:8080 -d false",
			    \});
			
			    cy.visit("http://localhost:3001/?frontity_name=redirections");
			
			    cy.get("#external-redirection").click();
			
			    cy.window()
			      .its("replaceLocationCalls")
			      .its(0)
			      .should("eq", "http://localhost:8181/hello-world-redirected/");
			
			    task("runCommand", \{ command: "npx forever stopall" \});
			  \});
			
			  it("Should redirect to an external domain that doesn't have CORS on the client", () => \{
			    task("runCommand", \{
			      command:
			        "npx forever start ./node_modules/.bin/http-server -p 8181 --proxy http://localhost:3001 -d false",
			    \});
			    cy.visit("http://localhost:3001/?frontity_name=redirections");
			
			    cy.get("#external-redirection").click();
			
			    cy.window()
			      .its("replaceLocationCalls")
			      .its(0)
			      .should("eq", "http://localhost:8080/external-redirect/");
			
			    task("runCommand", \{ command: "npx forever stopall" \});
			  \});
			
			  it("Should handle self-redirections gracefully when redirections=404", () => \{
			    // For this test we explicitly DO NOT create a post for /self-redirect-404/
			    // so that this request triggers a 404
			    cy.visit(
			      "http://localhost:3001/self-redirect-404/?frontity_name=redirections&redirections=404",
			      \{ failOnStatusCode: false \}
			    );
			
			    cy.get("#404").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it("Should handle self-redirections gracefully when redirections=all", () => \{
			    cy.visit(
			      "http://localhost:3001/self-redirect-all/?frontity_name=redirections&redirections=all"
			    );
			
			    cy.get("#post").should("exist");
			    cy.get("#link-counter").should("contain.text", "1");
			  \});
			
			  it('Should just redirect if the path is "the same" but the host is external (redirection is external)', () => \{
			    cy.visit(
			      "http://localhost:3001/external-self-redirect/?frontity_name=redirections&redirections=all",
			      \{ failOnStatusCode: false \}
			    );
			
			    // We are testing against an external domain but the example.com domain is
			    // provided by IANA https://www.iana.org/domains/reserved so it should
			    // remain there for as long as the internet exists :)
			    //
			    // Testing against a local proxy in this example is not viable becuse we'd
			    // end up in an infinite loop again
			    cy.location("href").should(
			      "eq",
			      "https://example.com/external-self-redirect/"
			    );
			
			    cy.get("h1").should("contain.text", "Example Domain");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\redirections.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(31)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\special-characters-in-url.spec.ts', () => {
        const sourceCode = `
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			describe("Special characters in the URL", () => \{
			  before(() => \{
			    task("loadDatabase", \{
			      path: "./wp-data/post-with-special-characters/dump.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			  \});
			
			  it("Should load the post", () => \{
			    cy.visit("http://localhost:3001?frontity_name=wp-basic-tests");
			    cy.get("[data-test-id='/testpost/']").click();
			
			    cy.get("[data-test-id='post']").contains("Post: testpost");
			    cy.location("href").should(
			      "eq",
			      "http://localhost:3001/test%e2%99%afpost%f0%9f%98%8a/"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\special-characters-in-url.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\wp-basic-tests.spec.ts', () => {
        const sourceCode = `
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			describe("WordPress REST API", () => \{
			  it("archives should work", () => \{
			    cy.visit("http://localhost:3001?frontity_name=wp-basic-tests");
			    cy.get("[data-test-id='1']").contains("/hello-world");
			  \});
			
			  it("posts should work", () => \{
			    cy.visit("http://localhost:3001/hello-world?frontity_name=wp-basic-tests");
			    cy.get("[data-test-id='post']").contains("Hello world");
			  \});
			\});
			
			describe("WordPress plugins", () => \{
			  before(() => \{
			    task("installPlugin", \{ name: "code-snippets" \});
			    task("loadDatabase", \{
			      path: "./wp-data/wp-basic-tests/code-snippets.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			    task("removeAllPlugins");
			  \});
			
			  it("should have a text injected by the Code Snippets plugin", () => \{
			    cy.visit("http://localhost:8080/");
			    cy.get("[data-test-id='code-snippet']").contains(
			      "Hello from WordPress plugin"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\wp-basic-tests.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\wp-comments.spec.ts', () => {
        const sourceCode = `
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			/**
			 * Explanation of the data found in the WordPress instance for this test suite.
			 *
			 * Strangely, the default comment with ID === 1 is not returned from the REST API in WP 5.4 and below.
			 * Because of that, this comment is deleted and by default, only the comment with ID === 2 is present in the database.
			 *
			 * Any subsequent comments added to WordPress, will have a comment ID of 3 or above.
			 *
			 */
			describe("wp-comments", () => \{
			  before(() => \{
			    task("installPlugin", \{
			      name: "code-snippets",
			    \});
			  \});
			
			  after(() => \{
			    task("removeAllPlugins");
			  \});
			
			  /**
			   * A helper to test that \`state.comments.forms\` object has properties with certain values.
			   *
			   * @param postId - The ID of the post for which a comment should be posted.
			   *
			   * @returns An object with a \`shouldHavePropertyWithValue()\` method for easily
			   * chaining it.
			   */
			  const commentForm = (postId: number) => (\{
			    shouldHavePropertyWithValue: (property: string, value: any) =>
			      cy
			        .window()
			        .its("frontity")
			        .its("state")
			        .its("comments")
			        .its("forms")
			        .its(postId)
			        .should("have.nested.property", property, value),
			  \});
			
			  /**
			   * A helper to test that \`state.source.comment\` object has properties with certain values.
			   *
			   * @param id - The ID of the comment.
			   *
			   * @returns An object with a \`shouldHavePropertyWithValue()\` method for easily
			   * chaining it.
			   */
			  const comment = (id: number) => (\{
			    shouldHavePropertyWithValue: (property: string, value: any) =>
			      cy
			        .window()
			        .its("frontity")
			        .its("state")
			        .its("source")
			        .its("comment")
			        .its(id)
			        .should("have.nested.property", property, value),
			  \});
			
			  /**
			   * A helper to test that \`state.source.data\` object has properties with certain values.
			   *
			   * @param postId - The key of the state object for the comments.
			   * @example \`@comments/60\`
			   * @returns An object with a \`shouldHavePropertyWithValue()\` method for easily
			   * chaining it.
			   */
			  const data = (postId: string) => (\{
			    shouldHavePropertyWithValue: (property: string, value: any) =>
			      cy
			        .window()
			        .its("frontity")
			        .its("state")
			        .its("source")
			        .its("data")
			        .its(postId)
			        .should("have.nested.property", property, value),
			  \});
			
			  describe("General tests that don't depend on particular WordPress settings", () => \{
			    beforeEach(() => \{
			      task("loadDatabase", \{
			        path: "./wp-data/wp-comments/code-snippets.sql",
			      \});
			      cy.visit("http://localhost:3001?frontity_name=wp-comments");
			    \});
			
			    afterEach(() => \{
			      task("resetDatabase");
			    \});
			
			    it("Should return an error when sending a comment for a non-existing post ID", () => \{
			      cy.get("#comment-wrong-id").click();
			
			      commentForm(9999).shouldHavePropertyWithValue("isError", true);
			      commentForm(9999).shouldHavePropertyWithValue(
			        "errorMessage",
			        "Sorry, you are not allowed to create this comment without a post."
			      );
			    \});
			
			    it("Should return an error when submitting a duplicate comment", () => \{
			      cy.visit("http://localhost:3001?frontity_name=wp-comments", \{
			        onBeforeLoad(win) \{
			          cy.stub(win.console, "warn").as("consoleWarn");
			        \},
			      \});
			
			      cy.get("#comment-ok").click();
			      commentForm(1).shouldHavePropertyWithValue("isSubmitted", true);
			      commentForm(1).shouldHavePropertyWithValue("isSubmitting", false);
			
			      cy.get("#comment-ok").click();
			      commentForm(1).shouldHavePropertyWithValue("isSubmitted", false);
			      commentForm(1).shouldHavePropertyWithValue("isSubmitting", false);
			
			      commentForm(1).shouldHavePropertyWithValue("isError", true);
			      commentForm(1).shouldHavePropertyWithValue(
			        "errorCode",
			        "comment_duplicate"
			      );
			      commentForm(1).shouldHavePropertyWithValue(
			        "errorMessage",
			        "Duplicate comment detected; it looks as though you&#8217;ve already said that!"
			      );
			    \});
			  \});
			
			  describe("Without the snippet added", () => \{
			    beforeEach(() => \{
			      // Load the database version without the following snippet:
			      /// add_filter( 'rest_allow_anonymous_comments', '__return_true' );
			      task("loadDatabase", \{
			        path: "./wp-data/wp-comments/no-code-snippets.sql",
			      \});
			    \});
			
			    afterEach(() => \{
			      task("resetDatabase");
			    \});
			
			    it("Should not allow the user to comment and return an error", () => \{
			      cy.visit("http://localhost:3001?frontity_name=wp-comments");
			
			      cy.get("#comment-ok").click();
			
			      commentForm(1).shouldHavePropertyWithValue("isError", true);
			      commentForm(1).shouldHavePropertyWithValue(
			        "errorCode",
			        "rest_comment_login_required"
			      );
			      commentForm(1).shouldHavePropertyWithValue(
			        "errorMessage",
			        "Sorry, you must be logged in to comment."
			      );
			    \});
			  \});
			
			  describe(\`With code snippets loaded\`, () => \{
			    beforeEach(() => \{
			      // Load the database version WITH the snippet:
			      /// add_filter( 'rest_allow_anonymous_comments', '__return_true' );
			      task("loadDatabase", \{
			        path: "./wp-data/wp-comments/code-snippets.sql",
			      \});
			    \});
			
			    afterEach(() => \{
			      task("resetDatabase");
			    \});
			
			    it("Should return an error when sending a comment without an email", () => \{
			      cy.visit("http://localhost:3001?frontity_name=wp-comments");
			      cy.get("#comment-no-email").click();
			
			      commentForm(1).shouldHavePropertyWithValue("isError", true);
			      commentForm(1).shouldHavePropertyWithValue(
			        "errorMessage",
			        "Creating a comment requires valid author name and email values."
			      );
			    \});
			
			    it("Should allow submitting a comment if email & name are not required", () => \{
			      // Disable the option to require the name and email to comment
			      task("updateOption", \{
			        name: "require_name_email",
			        value: 0,
			      \});
			
			      cy.visit("http://localhost:3001?frontity_name=wp-comments");
			      cy.get("#comment-no-email").click();
			
			      commentForm(1).shouldHavePropertyWithValue("isSubmitting", false);
			      commentForm(1).shouldHavePropertyWithValue("isSubmitted", true);
			
			      // Check that the new comment has been added to \`state.source.comment\`
			      comment(3).shouldHavePropertyWithValue("type", "comment");
			      comment(3).shouldHavePropertyWithValue("id", 3);
			    \});
			
			    it(\`Should be registered in order to post a comment if "Users must be registered and logged in to comment" is enabled\`, () => \{
			      // Require the user to be registered and logged in to comment
			      task("updateOption", \{
			        name: "comment_registration",
			        value: 1,
			      \});
			
			      cy.visit("http://localhost:3001?frontity_name=wp-comments");
			      cy.get("#comment-ok").click();
			
			      commentForm(1).shouldHavePropertyWithValue("isError", true);
			      commentForm(1).shouldHavePropertyWithValue(
			        "errorCode",
			        "rest_comment_login_required"
			      );
			      commentForm(1).shouldHavePropertyWithValue(
			        "errorMessage",
			        "Sorry, you must be logged in to comment."
			      );
			    \});
			
			    it(\`Should post a sub-comment correctly\`, () => \{
			      cy.visit("http://localhost:3001?frontity_name=wp-comments");
			
			      // fetch the existing (one) comment and wait till it's ready in state
			      cy.get("#fetch-comments").click();
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("isReady", true);
			
			      cy.get("#sub-comment").click();
			
			      commentForm(1).shouldHavePropertyWithValue("isSubmitting", false);
			      commentForm(1).shouldHavePropertyWithValue("isSubmitted", true);
			
			      // There should exist a sub-comment of the top-level comment
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("isReady", true);
			      data(\`@comments/1/\`).shouldHavePropertyWithValue(
			        "items[0].children[0].id",
			        3
			      );
			
			      // There should be a total of 2 comments now
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("total", 2);
			    \});
			
			    it(\`Should submit a form with an error and then submit correctly\`, () => \{
			      cy.visit("http://localhost:3001?frontity_name=wp-comments");
			
			      // fetch the existing (one) comment and wait tills it's ready in state
			      cy.get("#fetch-comments").click();
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("isReady", true);
			
			      // Send an incorrect comment and wait till the error has been returned
			      cy.get("#comment-no-email").click();
			      commentForm(1).shouldHavePropertyWithValue("isError", true);
			
			      // send a correct comment
			      cy.get("#comment-ok").click();
			
			      // The submission was successful and the form has been cleared
			      commentForm(1).shouldHavePropertyWithValue("isError", false);
			      commentForm(1).shouldHavePropertyWithValue("isSubmitting", false);
			      commentForm(1).shouldHavePropertyWithValue("isSubmitted", true);
			      commentForm(1).shouldHavePropertyWithValue("fields.content", "");
			
			      // Check that the new comment has been added to \`state.source.comment\`
			      comment(3).shouldHavePropertyWithValue("type", "comment");
			      comment(3).shouldHavePropertyWithValue("id", 3);
			
			      // The new comment has been added to \`state.source.data\` correctly
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("isReady", true);
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("items.length", 2);
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("items[1].id", 3);
			
			      // There should be a total of 2 comments now
			      data(\`@comments/1/\`).shouldHavePropertyWithValue("total", 2);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\wp-comments.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\wp-source-errors.spec.ts', () => {
        const sourceCode = `
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			describe("WP Source errors", () => \{
			  before(() => \{
			    task("installPlugin", \{ name: "code-snippets" \});
			    task("loadDatabase", \{
			      path: "./wp-data/wp-source/wp-source-errors.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			    task("removeAllPlugins");
			  \});
			
			  describe("Status codes", () => \{
			    it("should return a 200 status code", () => \{
			      cy.request("http://localhost:3001/?frontity_name=wp-source-errors")
			        .its("status")
			        .should("equal", 200);
			    \});
			
			    it("should return a 404 status code", () => \{
			      cy.request(\{
			        url:
			          "http://localhost:3001/?statusCode=404&frontity_name=wp-source-errors",
			        failOnStatusCode: false,
			      \})
			        .its("status")
			        .should("equal", 404);
			    \});
			
			    it("should return a 500 status code", () => \{
			      cy.request(\{
			        url:
			          "http://localhost:3001/?statusCode=500&frontity_name=wp-source-errors",
			        failOnStatusCode: false,
			      \})
			        .its("status")
			        .should("equal", 500);
			    \});
			  \});
			
			  describe("Data", () => \{
			    it("should have data populated correctly without errors", () => \{
			      cy.visit("http://localhost:3001/?frontity_name=wp-source-errors");
			      cy.get("[data-test-id='isError']").should("contain.text", "false");
			    \});
			
			    it("should have data populated correctly with 404 errors", () => \{
			      cy.visit(\{
			        url:
			          "http://localhost:3001/?statusCode=404&frontity_name=wp-source-errors",
			        failOnStatusCode: false,
			      \});
			      cy.get("[data-test-id='isError']").should("contain.text", "true");
			      cy.get("[data-test-id='is404']").should("contain.text", "true");
			      cy.get("[data-test-id='status']").should("contain.text", "404");
			    \});
			
			    it("should have data populated correctly with 500 errors", () => \{
			      cy.visit(\{
			        url:
			          "http://localhost:3001/?statusCode=500&frontity_name=wp-source-errors",
			        failOnStatusCode: false,
			      \});
			      cy.get("[data-test-id='isError']").should("contain.text", "true");
			      cy.get("[data-test-id='is404']").should("contain.text", "false");
			      cy.get("[data-test-id='status']").should("contain.text", "500");
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\wp-source-errors.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\e2e\\integration\\wordpress-01\\yoast-package.spec.ts', () => {
        const sourceCode = `
			import \{ ResolvePackages \} from "../../../packages/types/src/utils";
			import Router from "../../../packages/router/types";
			import type \{ taskTypes \} from "../../plugins";
			const task: taskTypes = cy.task;
			
			type WindowWithFrontity = Cypress.AUTWindow & \{
			  frontity: ResolvePackages<Router>;
			\};
			
			describe("Yoast Package", () => \{
			  before(() => \{
			    task("installPlugin", \{ name: "wordpress-seo" \});
			    task("installPlugin", \{ name: "code-snippets" \});
			    task("installPlugin", \{ name: "custom-post-type-ui" \});
			    task("loadDatabase", \{
			      path: "./wp-data/yoast-package/yoast-with-cpt.sql",
			    \});
			  \});
			
			  after(() => \{
			    task("resetDatabase");
			    task("removeAllPlugins");
			  \});
			
			  /**
			   * Generates the full url to be loaded and tested.
			   *
			   * @param link - The pathname to wich the test should navigate.
			   * @returns The full url.
			   */
			  const fullURL = (link: string) =>
			    \`http://localhost:3001\$\{link\}?frontity_name=yoast-package\`;
			
			  /**
			   * Check the title for the current page is the given one.
			   *
			   * @param link - The given link to execute the request.
			   * @param title - The page title for the given link.
			   */
			  const checkTitle = (link: string, title: string) => \{
			    it("should render the correct title", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get("title").should("contain", title);
			      \});
			    \});
			  \};
			
			  /**
			   * Run a set of test to ensure the correct meta tags are being rendered.
			   *
			   * This way, snapshots are generated with a meaningful name and are easy to
			   * read and check by a human being.
			   *
			   * @remarks The <title> tag is not tested using snapshots. That's because the
			   * plugin we are using to generate snapshots gives an error when trying to
			   * generate a snapshot for that tag (it also doesn't work well with strings).
			   * @param link - The link to execute the request against.
			   */
			  const checkMetaTags = (link: string) => \{
			    it("should render the correct canonical URL", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('link[rel="canonical"]').toMatchSnapshot();
			      \});
			    \});
			
			    it("should render the Open Graph tags", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get(
			          \`meta[property^="og:"],meta[property^="article:"],meta[property^="profile:"]\`
			        ).each((meta) => \{
			          cy.wrap(meta).toMatchSnapshot();
			        \});
			      \});
			    \});
			
			    it("should render the Twitter tags", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('meta[name^="twitter:"]').each((meta) => \{
			          cy.wrap(meta).toMatchSnapshot();
			        \});
			      \});
			    \});
			
			    it("should render the schema tag", () => \{
			      cy.visitSSR(fullURL(link)).then(() => \{
			        cy.get('script[type="application/ld+json"]').toMatchSnapshot();
			      \});
			    \});
			  \};
			
			  /**
			   * Change the router value in Frontity.
			   *
			   * @param link - The link of the page.
			   */
			  const routerSet = (link: string) => \{
			    cy.window().then((win: WindowWithFrontity) => \{
			      win.frontity.actions.router.set(link);
			    \});
			  \};
			
			  /**
			   * Tests for posts.
			   */
			  describe("Post", () => \{
			    const link = "/hello-world/";
			    const title = "Hello World From Yoast! - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for pages.
			   */
			  describe("Page", () => \{
			    const link = "/sample-page/";
			    const title = "Sample Page - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for categories.
			   */
			  describe("Category", () => \{
			    const link = "/category/nature/";
			    const title = "Nature Archives - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for tags.
			   */
			  describe("Tag", () => \{
			    const link = "/tag/japan/";
			    const title = "Japan Archives - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for authors.
			   */
			  describe("Author", () => \{
			    const link = "/author/luisherranz";
			    const title = "luisherranz, Author at Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for the homepage.
			   */
			  describe("Homepage", () => \{
			    const link = "/";
			    const title = "Test WP Site - Just another WordPress site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for custom post types.
			   */
			  describe("CPT", () => \{
			    const link = "/movie/the-terminator/";
			    const title = "The Terminator - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("CPT (archive)", () => \{
			    const title = "Movies Archive - Test WP Site";
			    const link = "/movies/";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Tests for archive of custom post types.
			   */
			  describe("Custom Taxonomy", () => \{
			    const link = "/actor/linda-hamilton/";
			    const title = "Linda Hamilton Archives - Test WP Site";
			
			    checkTitle(link, title);
			    checkMetaTags(link);
			  \});
			
			  /**
			   * Test for the \`<title>\` tag while navigating through Frontity.
			   */
			  describe("Title tag", () => \{
			    it("should be correct while navigating", () => \{
			      // Navigate to the root
			      cy.visit(\`http://localhost:3001/?frontity_name=yoast-package\`);
			
			      cy.get("title").should(
			        "contain",
			        "Test WP Site - Just another WordPress site"
			      );
			
			      routerSet("/hello-world/");
			      cy.get("title").should(
			        "contain",
			        "Hello World From Yoast! - Test WP Site"
			      );
			
			      routerSet("/sample-page/");
			      cy.get("title").should("contain", "Sample Page - Test WP Site");
			
			      routerSet("/category/nature/");
			      cy.get("title").should("contain", "Nature Archives - Test WP Site");
			
			      routerSet("/tag/japan/");
			      cy.get("title").should("contain", "Japan Archives - Test WP Site");
			
			      routerSet("/author/luisherranz");
			      cy.get("title").should("contain", "luisherranz, Author at Test WP Site");
			
			      routerSet("/movie/the-terminator/");
			      cy.get("title").should("contain", "The Terminator - Test WP Site");
			
			      routerSet("/movies/");
			      cy.get("title").should("contain", "Movies Archive - Test WP Site");
			
			      routerSet("/actor/linda-hamilton/");
			      cy.get("title").should(
			        "contain",
			        "Linda Hamilton Archives - Test WP Site"
			      );
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\integration\\wordpress-01\\yoast-package.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\amp-comscore-analytics.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("amp", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=amp-comscore-analytics");
			  \});
			
			  it("should render the tags for the tracking IDs", async function () \{
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('script[src=\\"https://cdn.ampproject.org/v0/amp-analytics-0.1.js\\"]')"
			      )
			    );
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelectorAll('amp-analytics[type=\\"comscore\\"] > script').length"
			      ),
			      2
			    );
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelectorAll('amp-analytics[type=\\"comscore\\"] > script')[0].text"
			      ),
			      '\{"vars":\{"c2":"111111"\}\}'
			    );
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelectorAll('amp-analytics[type=\\"comscore\\"] > script')[1].text"
			      ),
			      '\{"vars":\{"c2":"222222"\}\}'
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\amp-comscore-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\amp.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("amp", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=amp");
			  \});
			
			  it("should render the template from the server", async function () \{
			    assert(
			      await driver.executeScript("return document.querySelector('html[amp]')")
			    );
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('style[amp-boilerplate]')"
			      )
			    );
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('style[amp-custom]')"
			      )
			    );
			    assert(
			      !(await driver.executeScript(
			        "return document.querySelector('body script')"
			      ))
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\amp.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\analytics.spec.js', () => {
        const sourceCode = `
			// Generated by Selenium IDE
			const \{ By, until \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("analytics", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=analytics");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			  \});
			
			  const pageviewHome = \{
			    link: "/",
			    title: "Homepage Title",
			  \};
			
			  const pageviewSomePost = \{
			    link: "/some-post/",
			    title: "Some Post Title",
			  \};
			
			  const pageviewSomeOtherPost = \{
			    link: "/some-other-post/",
			    title: "Some Post Title",
			  \};
			
			  const someEvent = \{
			    name: "some event",
			    payload: \{ content: "some content" \},
			  \};
			
			  it("should send the first pageview", async function () \{
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.pageviews[0]"
			      ),
			      pageviewHome
			    );
			  \});
			
			  it("should send a pageview if the page changes", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.pageviews[1]"
			      ),
			      pageviewSomePost
			    );
			  \});
			
			  it("should send a pageview if the page changes and title is the same", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    await driver.findElement(By.id("change-link-post-2")).click();
			    await driver.manage().setTimeouts(\{ implicit: 2000 \});
			    await driver.executeScript("return window.history.back()");
			    await driver.manage().setTimeouts(\{ implicit: 2000 \});
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.pageviews[1]"
			      ),
			      pageviewSomePost
			    );
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.pageviews[2]"
			      ),
			      pageviewSomeOtherPost
			    );
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.pageviews[3]"
			      ),
			      pageviewSomePost
			    );
			  \});
			
			  it("should send pageviews when going back or forward", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    await driver.executeScript("return window.history.back()");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.pageviews[2]"
			      ),
			      pageviewHome
			    );
			
			    await driver.executeScript("return window.history.forward()");
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.pageviews[3]"
			      ),
			      pageviewSomePost
			    );
			  \});
			
			  it("should send events", async function () \{
			    await driver.findElement(By.id("send-event")).click();
			    await driver.findElement(By.id("send-event")).click();
			    await driver.findElement(By.id("send-event")).click();
			    await driver.manage().setTimeouts(\{ implicit: 2000 \});
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.events[0]"
			      ),
			      someEvent
			    );
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.events[1]"
			      ),
			      someEvent
			    );
			    assert.deepEqual(
			      await driver.executeScript(
			        "return window.frontity.state.testAnalytics.events[2]"
			      ),
			      someEvent
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\comscore-analytics.spec.js', () => {
        const sourceCode = `
			// Generated by Selenium IDE
			const \{ By, until \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("comscore-analytics", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=comscore-analytics");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			  \});
			
			  const pageviewHome = \{
			    title: "Homepage Title",
			    link: baseUrl + "/",
			  \};
			
			  const pageviewSomePost = \{
			    title: "Some Post Title",
			    link: baseUrl + "/some-post/",
			  \};
			
			  it("should load the Comscore library", async function () \{
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('script[src=\\"https://sb.scorecardresearch.com/beacon.js\\"][async]')"
			      )
			    );
			  \});
			
			  it("should send the first pageview", async function () \{
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[0]"),
			      \{ id: "111111", ...pageviewHome \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[1]"),
			      \{ id: "222222", ...pageviewHome \}
			    );
			  \});
			
			  it("should send a pageview if the page changes", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[2]"),
			      \{ id: "111111", ...pageviewSomePost \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[3]"),
			      \{ id: "222222", ...pageviewSomePost \}
			    );
			  \});
			
			  it("should send pageviews when going back or forward", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    await driver.executeScript("return window.history.back()");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[4]"),
			      \{ id: "111111", ...pageviewHome \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[5]"),
			      \{ id: "222222", ...pageviewHome \}
			    );
			    await driver.executeScript("return window.history.forward()");
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[6]"),
			      \{ id: "111111", ...pageviewSomePost \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.comscoreCalls[7]"),
			      \{ id: "222222", ...pageviewSomePost \}
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\comscore-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\emotion.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("Global", function () \{
			  it("should have a blue background, but not a red color", async function () \{
			    await driver.get(baseUrl + "/color-red?frontity_name=emotion");
			    await driver.get(baseUrl + "/background-blue?frontity_name=emotion");
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			    assert.notEqual(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.notEqual(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			  \});
			
			  it("should have a red color, but not a blue background", async function () \{
			    await driver.get(baseUrl + "/background-blue?frontity_name=emotion");
			    await driver.get(baseUrl + "/color-red?frontity_name=emotion");
			    assert.notEqual(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.notEqual(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			\});
			
			describe("styled", function () \{
			  it("should have a red color", async function () \{
			    await driver.get(baseUrl + "/styled-css?frontity_name=emotion");
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'styled-div\\']"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should toggle the color", async function () \{
			    await driver.get(baseUrl + "/styled-css?frontity_name=emotion");
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'styled-div\\']"))["color"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'styled-div\\']"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			\});
			
			describe("css", function () \{
			  it("should have a red color", async function () \{
			    await driver.get(baseUrl + "/styled-css?frontity_name=emotion");
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'css-div\\']"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should toggle the color", async function () \{
			    await driver.get(baseUrl + "/styled-css?frontity_name=emotion");
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'css-div\\']"))["color"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			    await driver.findElement(By.css('[data-test-id="toggle-button"]')).click();
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'css-div\\']"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\emotion.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\google-ad-manager.spec.js', () => {
        const sourceCode = `
			const \{ By, until \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("google-ad-manager", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=google-ad-manager");
			    await driver.wait(
			      until.elementLocated(By.css("#header-ad>div>iframe")),
			      5000
			    );
			  \});
			
			  it("should load the GPT library", async function () \{
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('script[src=\\"https://securepubads.g.doubleclick.net/tag/js/gpt.js\\"]')"
			      )
			    );
			  \});
			
			  it("should render GPT ad units from fills", async function () \{
			    assert((await driver.findElements(By.css("#header-ad>div>iframe"))).length);
			    assert((await driver.findElements(By.css("#footer-ad>div>iframe"))).length);
			    await driver.findElement(By.css("button#change-link")).click();
			    assert(
			      (await driver.findElements(By.css("#header-ad_post>div>iframe"))).length
			    );
			    assert(
			      (await driver.findElements(By.css("#footer-ad_post>div>iframe"))).length
			    );
			    assert(
			      (await driver.findElements(By.css("#content-ad_post>div>iframe"))).length
			    );
			  \});
			
			  it("should work using GPT component directly from libraries", async function () \{
			    await driver.findElement(By.css("button#change-link-gpt")).click();
			    assert(
			      (await driver.findElements(By.css("#post-with-gpt-ad>div>iframe"))).length
			    );
			  \});
			
			  it("should ad the link to the container ID if data is passed", async function () \{
			    await driver.findElement(By.css("button#change-link")).click();
			    assert(
			      (await driver.findElements(By.css("#content-ad_post>div>iframe"))).length
			    );
			    assert(
			      (await driver.findElements(By.css("#content-ad_next-post>div>iframe")))
			        .length
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\google-ad-manager.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\google-analytics.spec.js', () => {
        const sourceCode = `
			const \{ By, until \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("google-analytics", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=google-analytics");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			  \});
			
			  const pageviewHome = \{
			    title: "Homepage Title",
			    link: "/",
			  \};
			
			  const pageviewSomePost = \{
			    title: "Some Post Title",
			    link: "/some-post/",
			  \};
			
			  it("should load the Google Analytics library", async function () \{
			    // Make sure the <script> was created.
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('script[src=\\"https://www.googletagmanager.com/gtag/js?id=UA-XXXXXX-X\\"][async]')"
			      )
			    );
			  \});
			
			  it("should have sent the first pageview", async function () \{
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[0][2]"),
			      \{
			        page_location: pageviewHome.link,
			        page_title: pageviewHome.title,
			        send_to: "UA-XXXXXX-X",
			      \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[1][2]"),
			      \{
			        page_location: pageviewHome.link,
			        page_title: pageviewHome.title,
			        send_to: "UA-YYYYYY-Y",
			      \}
			    );
			  \});
			
			  it("should send a pageview if the page changes", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[2][2]"),
			      \{
			        page_location: pageviewSomePost.link,
			        page_title: pageviewSomePost.title,
			        send_to: "UA-XXXXXX-X",
			      \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[3][2]"),
			      \{
			        page_location: pageviewSomePost.link,
			        page_title: pageviewSomePost.title,
			        send_to: "UA-YYYYYY-Y",
			      \}
			    );
			  \});
			
			  it("should send pageviews when going back or forward", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    await driver.executeScript("return window.history.back()");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[4][2]"),
			      \{
			        page_location: pageviewHome.link,
			        page_title: pageviewHome.title,
			        send_to: "UA-XXXXXX-X",
			      \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[5][2]"),
			      \{
			        page_location: pageviewHome.link,
			        page_title: pageviewHome.title,
			        send_to: "UA-YYYYYY-Y",
			      \}
			    );
			    await driver.executeScript("return window.history.forward()");
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[6][2]"),
			      \{
			        page_location: pageviewSomePost.link,
			        page_title: pageviewSomePost.title,
			        send_to: "UA-XXXXXX-X",
			      \}
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[7][2]"),
			      \{
			        page_location: pageviewSomePost.link,
			        page_title: pageviewSomePost.title,
			        send_to: "UA-YYYYYY-Y",
			      \}
			    );
			  \});
			
			  it("should send events", async function () \{
			    await driver.findElement(By.id("send-event")).click();
			    await driver.manage().setTimeouts(\{ implicit: 2000 \});
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[2][2]['content']"),
			      "some content"
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[2][2]['send_to']"),
			      "UA-XXXXXX-X"
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[3][2]['content']"),
			      "some content"
			    );
			    assert.deepEqual(
			      await driver.executeScript("return window.gaCalls[3][2]['send_to']"),
			      "UA-YYYYYY-Y"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\google-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\google-tag-manager-analytics.spec.js', () => {
        const sourceCode = `
			const \{ By, until \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("google-tag-manager-analytics", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=google-tag-manager");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			  \});
			
			  const pageviewHome = \{
			    event: "pageview",
			    link: "/",
			    title: "Homepage Title",
			  \};
			
			  const pageviewSomePost = \{
			    event: "pageview",
			    link: "/some-post/",
			    title: "Some Post Title",
			  \};
			
			  const someEvent = \{
			    event: "some event",
			    payload: \{ content: "some content" \},
			  \};
			
			  it("should load Google Tag Manager library", async function () \{
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('script[src=\\"https://www.googletagmanager.com/gtm.js?id=GTM-XXXXXX-X\\"]')"
			      )
			    );
			  \});
			
			  it("should send the first pageview", async function () \{
			    assert.deepEqual(
			      await driver.executeScript("return window.dataLayer[1]"),
			      pageviewHome
			    );
			  \});
			
			  it("should send a pageview if the page changes", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.dataLayer[2]"),
			      pageviewSomePost
			    );
			  \});
			
			  it("should send pageviews when going back or forward", async function () \{
			    await driver.findElement(By.id("change-link")).click();
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    await driver.executeScript("return window.history.back()");
			    await driver.wait(until.titleIs("Homepage Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.dataLayer[3]"),
			      pageviewHome
			    );
			    await driver.executeScript("return window.history.forward()");
			    await driver.wait(until.titleIs("Some Post Title"), 5000);
			    assert.deepEqual(
			      await driver.executeScript("return window.dataLayer[4]"),
			      pageviewSomePost
			    );
			  \});
			
			  it("should send events", async function () \{
			    await driver.findElement(By.id("send-event")).click();
			    await driver.manage().setTimeouts(\{ implicit: 2000 \});
			    assert.deepEqual(
			      await driver.executeScript("return window.dataLayer[2]"),
			      someEvent
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\google-tag-manager-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\head.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("head", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?site=head");
			  \});
			
			  it("should have a title", async function () \{
			    assert.equal(await driver.getTitle(), "The Title");
			  \});
			
			  it("should have a meta for description", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector("meta[name=\\'description\\']").getAttribute("content")'
			      ),
			      "The Description"
			    );
			  \});
			
			  it("should have html attributes", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelector('html').getAttribute(\\"lang\\")"
			      ),
			      "en"
			    );
			  \});
			
			  it("should be able to execute javascript in a script tag", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.scriptTest"),
			      "pass"
			    );
			  \});
			
			  it("should have links", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector(\\'link[rel="canonical"]\\').getAttribute("href")'
			      ),
			      "http://mysite.com/example"
			    );
			  \});
			
			  it("should be able to change body attributes", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector("body").getAttribute("class")'
			      ),
			      "new-class"
			    );
			  \});
			
			  it("should be able to have nonscripts", async function () \{
			    assert(
			      (
			        await driver.executeScript(
			          'return document.querySelector("noscript").textContent'
			        )
			      ).includes("foo.css")
			    );
			  \});
			
			  it("should be able to add inline CSS", async function () \{
			    assert(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      )
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\head.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\html2react.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("html2react", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=html2react");
			  \});
			
			  it("should pass state to processors", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("p"))["color"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			  \});
			
			  it("should re-render when the state is updated", async function () \{
			    await driver.findElement(By.id("change-color")).click();
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("p"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should work with old processors", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector("span#old-processors").textContent'
			      ),
			      "Yes"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\html2react.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\loadable.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("loadable", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=loadable");
			  \});
			  it("should be able to render elements from dynamic components", async function () \{
			    assert(
			      (await driver
			        .findElement(By.css("[data-test-id='dynamic-div']"))
			        .getText()) == "I am the Dynamic1 component"
			    );
			    assert(
			      (await driver
			        .findElement(By.css("[data-test-id='dynamic2-div']"))
			        .getText()) == "I am the Dynamic2 component"
			    );
			  \});
			
			  it("should be able to use javascript from dynamic components", async function () \{
			    assert(
			      (await driver
			        .findElement(By.css("[data-test-id='toggle-div']"))
			        .getText()) == "OFF"
			    );
			    await driver.findElement(By.css("[data-test-id='toggle-button']")).click();
			    assert(
			      (await driver
			        .findElement(By.css("[data-test-id='toggle-div']"))
			        .getText()) == "ON"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\loadable.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\script.spec.js', () => {
        const sourceCode = `
			const \{ By, until \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("script", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=script");
			    await driver.wait(until.elementLocated(By.id("from-src")), 5000);
			  \});
			
			  it("should load a external script from src url", async function () \{
			    assert.equal(
			      await driver.findElement(By.id("from-src")).getAttribute("src"),
			      "https://unpkg.com/moment@2.24.0/min/moment.min.js"
			    );
			    assert(await driver.findElement(By.id("from-src")).getAttribute("async"));
			  \});
			
			  it("should access code from the external script", async function () \{
			    assert(
			      await driver.executeScript("return window.moment()._isAMomentObject")
			    );
			  \});
			
			  it("should load inline script", async function () \{
			    assert.equal(
			      await driver.findElement(By.css('[data-test-id="target"]')).getText(),
			      "OFF"
			    );
			    await driver.findElement(By.css('[data-test-id="toggle"]')).click();
			    assert.equal(
			      await driver.findElement(By.css('[data-test-id="target"]')).getText(),
			      "ON"
			    );
			  \});
			
			  it("should not fail when scripts are unmounted", async function () \{
			    await driver.findElement(By.css('[data-test-id="unmount-script"]')).click();
			    assert.equal(
			      await driver.findElement(By.css('[data-test-id="target"]')).getText(),
			      "OFF"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\script.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\slot-and-fill.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("slot-and-fill", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=slot-and-fill");
			  \});
			
			  it("should show empty slots", async function () \{
			    assert.equal(
			      await driver.findElement(By.id("useFills-slot1-empty")).getText(),
			      "useFills slot 1 empty"
			    );
			    assert.equal(
			      await driver.findElement(By.id("useFills-slot2-empty")).getText(),
			      "useFills slot 2 empty"
			    );
			    assert.equal(
			      await driver.findElement(By.id("SSRFill")).getText(),
			      "I am SSRFill"
			    );
			  \});
			
			  it("should show first Fill", async function () \{
			    await driver.findElement(By.id("addFill1")).click();
			    assert.equal(
			      await driver.findElement(By.id("Fill1")).getText(),
			      "I am Fill1"
			    );
			    assert(!(await driver.findElements(By.id("useFills-slot1-empty"))).length);
			    assert((await driver.findElements(By.id("useFills-slot2-empty"))).length);
			  \});
			
			  it("should show second Fill", async function () \{
			    await driver.findElement(By.id("addFill2")).click();
			    assert.equal(
			      await driver.findElement(By.id("Fill2")).getText(),
			      "I am Fill2"
			    );
			    assert(!(await driver.findElements(By.id("useFills-slot1-empty"))).length);
			    assert((await driver.findElements(By.id("useFills-slot2-empty"))).length);
			  \});
			
			  it("should show both Fills in priority order", async function () \{
			    await driver.findElement(By.id("addFill1")).click();
			    await driver.findElement(By.id("addFill2")).click();
			    assert.equal(
			      (await driver.findElement(By.id("useFills-slot1")).getText()).replace(
			        "\\n",
			        ""
			      ),
			      "I am Fill2I am Fill1"
			    );
			  \});
			
			  it("should show the debug fills when \`state.frontity.debug\` is true", async function () \{
			    await driver.findElement(By.id("toggleDebug")).click();
			    assert(!(await driver.findElements(By.id("useFills-slot1-empty"))).length);
			    assert(!(await driver.findElements(By.id("useFills-slot2-empty"))).length);
			    assert(
			      (await driver.findElements(By.css("[data-slot-name='slot 1']"))).length
			    );
			    assert(
			      (await driver.findElements(By.css("[data-slot-name='slot 2']"))).length
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\slot-and-fill.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\smart-adserver.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("smart-adserver", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=smart-adserver");
			    await driver.manage().setTimeouts(\{ implicit: 5000 \});
			  \});
			
			  it("should load the smart adserver library", async function () \{
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('script[src=\\"//ced.sascdn.com/tag/256/smart.js\\"][async]')"
			      )
			    );
			  \});
			
			  it("should render the ad using the SmartAd component from the libraries", async function () \{
			    assert((await driver.findElements(By.css("#test-smartad>img"))).length);
			  \});
			
			  it("should render the ad using the SmartAd component and a default tag id", async function () \{
			    assert(
			      (await driver.findElements(By.css("#default-tag-id>#sas_19809>img")))
			        .length
			    );
			  \});
			
			  it("should render the ad in an iframe", async function () \{
			    assert((await driver.findElements(By.css("#iframe-ad>div>iframe"))).length);
			  \});
			
			  it("should render the ad in the slot", async function () \{
			    assert((await driver.findElements(By.css("#hello>img"))).length);
			  \});
			
			  it("should unmount correctly and show the other ad in the other page", async function () \{
			    await driver.findElement(By.css("button#change-page")).click();
			    await driver.manage().setTimeouts(\{ implicit: 5000 \});
			    assert((await driver.findElements(By.css("#other-page-ad>img"))).length);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\smart-adserver.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\switch.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("switch", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=switch");
			  \});
			
			  it("should render last component when no matching component is found", async function () \{
			    assert.equal(
			      await driver.findElement(By.id("default")).getText(),
			      "Default"
			    );
			    assert(!(await driver.findElements(By.id("one"))).length);
			    assert(!(await driver.findElements(By.id("two"))).length);
			  \});
			
			  it("should render components with truthy condition", async function () \{
			    assert.equal(
			      await driver.findElement(By.id("default")).getText(),
			      "Default"
			    );
			
			    await driver.findElement(By.id("set-to-1")).click();
			    assert.equal(await driver.findElement(By.id("one")).getText(), "One");
			    assert(!(await driver.findElements(By.id("two"))).length);
			    assert(!(await driver.findElements(By.id("default"))).length);
			
			    await driver.findElement(By.id("set-to-2")).click();
			    assert.equal(await driver.findElement(By.id("two")).getText(), "Two");
			    assert(!(await driver.findElements(By.id("one"))).length);
			    assert(!(await driver.findElements(By.id("default"))).length);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\switch.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\tiny-router.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("tiny-router", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=tiny-router");
			  \});
			
			  it("should show render contents in home", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			  \});
			
			  it("should switch route when using set", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    await driver
			      .findElement(By.css('[data-button-id="switch-to-about"]'))
			      .click();
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			    await driver.executeScript("return window.history.back()");
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "Home"
			    );
			  \});
			
			  it("should switch route when using set with \`push\`", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    await driver
			      .findElement(By.css('[data-button-id="switch-using-push"]'))
			      .click();
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			  \});
			
			  it("should switch route when using set with \`replace\`", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    await driver
			      .findElement(By.css('[data-button-id="switch-using-replace"]'))
			      .click();
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			  \});
			
			  it("should replace history entry when using set with \`replace\`", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "Home"
			    );
			    await driver
			      .findElement(By.css('[data-button-id="switch-using-push"]'))
			      .click();
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			    await driver
			      .findElement(By.css('[data-button-id="switch-to-privacy-using-replace"]'))
			      .click();
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/privacy/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "Privacy"
			    );
			    await driver.executeScript("return window.history.back()");
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "Home"
			    );
			  \});
			
			  it("should recover state when moving back and forward in history", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    await driver
			      .findElement(By.css('button[data-button-id="switch-using-state"]'))
			      .click();
			
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="has-state"]'))
			        .getText()) == "Router has state!"
			    );
			    await driver.executeScript("return window.history.back()");
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "Home"
			    );
			    await driver.executeScript("return window.history.forward()");
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="has-state"]'))
			        .getText()) == "Router has state!"
			    );
			  \});
			
			  it("should work if link doesn't have a trailing forward slash", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    await driver
			      .findElement(
			        By.css('button[data-button-id="switch-to-about-no-trailing"]')
			      )
			      .click();
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\tiny-router.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\use-in-view.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("use-in-view", function () \{
			  let vars;
			  beforeEach(function () \{
			    vars = \{
			      url: baseUrl + "/?frontity_name=use-in-view",
			    \};
			  \});
			
			  it("useInView should return supported true", async function () \{
			    await driver.get(vars["url"]);
			    assert.equal(
			      await driver.executeScript("return window.location.href"),
			      vars["url"]
			    );
			    assert.equal(
			      await driver.findElement(By.id("supported")).getText(),
			      "supported: true"
			    );
			  \});
			
			  it("useInView should return supported false", async function () \{
			    await driver.get(vars["url"] + "&removeIO");
			    assert.equal(
			      await driver.executeScript("return window.location.href"),
			      vars["url"] + "&removeIO"
			    );
			    assert(!(await driver.executeScript("return window.IntersectionObserver")));
			    assert.equal(
			      await driver.findElement(By.id("supported")).getText(),
			      "supported: false"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\module\\use-in-view.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\amp-comscore-analytics.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("amp", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=amp-comscore-analytics");
			  \});
			
			  it("should render the tags for the tracking IDs", async function () \{
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('script[src=\\"https://cdn.ampproject.org/v0/amp-analytics-0.1.js\\"]')"
			      )
			    );
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelectorAll('amp-analytics[type=\\"comscore\\"] > script').length"
			      ),
			      2
			    );
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelectorAll('amp-analytics[type=\\"comscore\\"] > script')[0].text"
			      ),
			      '\{"vars":\{"c2":"111111"\}\}'
			    );
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelectorAll('amp-analytics[type=\\"comscore\\"] > script')[1].text"
			      ),
			      '\{"vars":\{"c2":"222222"\}\}'
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\amp-comscore-analytics.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\amp.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("amp", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=amp");
			  \});
			
			  it("should render the template from the server", async function () \{
			    assert(
			      await driver.executeScript("return document.querySelector('html[amp]')")
			    );
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('style[amp-boilerplate]')"
			      )
			    );
			    assert(
			      await driver.executeScript(
			        "return document.querySelector('style[amp-custom]')"
			      )
			    );
			    assert(
			      !(await driver.executeScript(
			        "return document.querySelector('body script')"
			      ))
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\amp.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\emotion.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("Global", function () \{
			  it("should have a blue background, but not a red color", async function () \{
			    await driver.get(baseUrl + "/color-red?frontity_name=emotion");
			    await driver.get(baseUrl + "/background-blue?frontity_name=emotion");
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			    assert.notEqual(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			
			  it("should have a red color, but not a blue background", async function () \{
			    await driver.get(baseUrl + "/background-blue?frontity_name=emotion");
			    await driver.get(baseUrl + "/color-red?frontity_name=emotion");
			    assert.notEqual(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			\});
			
			describe("styled", function () \{
			  it("should have a red color", async function () \{
			    await driver.get(baseUrl + "/styled-css?frontity_name=emotion");
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'styled-div\\']"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			\});
			
			describe("css", function () \{
			  it("should have a red color", async function () \{
			    await driver.get(baseUrl + "/styled-css?frontity_name=emotion");
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("[data-test-id=\\'css-div\\']"))["color"]'
			      ),
			      "rgb(255, 0, 0)"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\emotion.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\head.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("head", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?site=head");
			  \});
			
			  it("should have a title", async function () \{
			    assert.equal(await driver.getTitle(), "The Title");
			  \});
			
			  it("should have a meta for description", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector("meta[name=\\'description\\']").getAttribute("content")'
			      ),
			      "The Description"
			    );
			  \});
			
			  it("should have html attributes", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        "return document.querySelector('html').getAttribute(\\"lang\\")"
			      ),
			      "en"
			    );
			  \});
			
			  it("should be able to execute javascript in a script tag", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.scriptTest"),
			      "pass"
			    );
			  \});
			
			  it("should have links", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector(\\'link[rel="canonical"]\\').getAttribute("href")'
			      ),
			      "http://mysite.com/example"
			    );
			  \});
			
			  it("should be able to change body attributes", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector("body").getAttribute("class")'
			      ),
			      "new-class"
			    );
			  \});
			
			  it("should be able to have nonscripts", async function () \{
			    assert(
			      (
			        await driver.executeScript(
			          'return document.querySelector("noscript").textContent'
			        )
			      ).includes("foo.css")
			    );
			  \});
			
			  it("should be able to add inline CSS", async function () \{
			    assert(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("body"))["backgroundColor"]'
			      )
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\head.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\html2react.spec.js', () => {
        const sourceCode = `
			const assert = require("assert");
			
			describe("html2react", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=html2react");
			  \});
			
			  it("should pass state to processors", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return window.getComputedStyle(document.querySelector("p"))["color"]'
			      ),
			      "rgb(0, 0, 255)"
			    );
			  \});
			
			  it("should work with old processors", async function () \{
			    assert.equal(
			      await driver.executeScript(
			        'return document.querySelector("span#old-processors").textContent'
			      ),
			      "Yes"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\html2react.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\loadable.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("loadable", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=loadable");
			  \});
			  it("should be able to render elements from dynamic components", async function () \{
			    assert(
			      (await driver
			        .findElement(By.css("[data-test-id='dynamic-div']"))
			        .getText()) == "I am the Dynamic1 component"
			    );
			    assert(
			      (await driver
			        .findElement(By.css("[data-test-id='dynamic2-div']"))
			        .getText()) == "I am the Dynamic2 component"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\loadable.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\slot-and-fill.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("slot-and-fill", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=slot-and-fill");
			  \});
			
			  it("should show empty slots and SSR", async function () \{
			    assert.equal(
			      await driver.findElement(By.id("useFills-slot1-empty")).getText(),
			      "useFills slot 1 empty"
			    );
			    assert.equal(
			      await driver.findElement(By.id("useFills-slot2-empty")).getText(),
			      "useFills slot 2 empty"
			    );
			    assert.equal(
			      await driver.findElement(By.id("SSRFill")).getText(),
			      "I am SSRFill"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\slot-and-fill.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\switch.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("switch", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=switch");
			  \});
			
			  it("should render last component when no matching component is found", async function () \{
			    assert.equal(
			      await driver.findElement(By.id("default")).getText(),
			      "Default"
			    );
			    assert(!(await driver.findElements(By.id("one"))).length);
			    assert(!(await driver.findElements(By.id("two"))).length);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\switch.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\tiny-router.spec.js', () => {
        const sourceCode = `
			const \{ By \} = require("selenium-webdriver");
			const assert = require("assert");
			
			describe("tiny-router", function () \{
			  beforeEach(async function () \{
			    await driver.get(baseUrl + "/?frontity_name=tiny-router");
			  \});
			
			  it("should show render contents in home", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "Home"
			    );
			  \});
			
			  it("should switch route when using the link and going back and forward", async function () \{
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    await driver
			      .findElement(By.css('[data-link-id="switch-using-relative-link"]'))
			      .click();
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			    await driver.executeScript("return window.history.back()");
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "Home"
			    );
			    await driver.executeScript("return window.history.forward()");
			    assert.equal(
			      await driver.executeScript("return window.location.pathname"),
			      "/about/"
			    );
			    assert(
			      (await driver
			        .findElement(By.css('[data-test-id="content"]'))
			        .getText()) == "About"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\e2e\\selenium\\tests\\specs\\ssr\\tiny-router.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\amp\\src\\__tests__\\amp.server.test.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import \{ Packages \} from "../../types";
			import Amp from "..";
			
			jest.mock("@emotion/server/create-instance", () => () => (\{
			  extractCritical: jest.fn().mockImplementation((args) => args),
			\}));
			
			jest.mock("react-dom/server", () => (\{
			  renderToStaticMarkup: jest.fn().mockImplementation((args) => args),
			\}));
			
			describe("AMP server tests", () => \{
			  let store: InitializedStore<Packages>;
			
			  beforeEach(() => \{
			    // Initialize the store
			    store = createStore<Packages>(clone(Amp));
			
			    // We have to mock these since the \`createStore\` it's not the one used
			    // on the server and client.
			    store.libraries = \{
			      source: \{
			        parse: jest.fn(),
			        normalize: jest.fn(),
			        stringify: jest.fn(),
			      \},
			      frontity: \{
			        App: jest.fn().mockImplementation((args) => args),
			        render: jest.fn().mockImplementation((args) => args),
			        template: jest.fn().mockImplementation((args) => args),
			        head: [],
			        scripts: [],
			      \},
			      html2react: \{
			        processors: [],
			        Component: jest.fn(),
			      \},
			    \};
			  \});
			
			  test("The initial values are overwritten with the Amp ones", () => \{
			    const previousRender = store.libraries.frontity.render;
			    const previousTemplate = store.libraries.frontity.template;
			
			    store.actions.amp.beforeSSR();
			
			    expect(store.libraries.frontity.render).not.toEqual(previousRender);
			    expect(store.libraries.frontity.template).not.toEqual(previousTemplate);
			  \});
			
			  test("The \`render\` method uses the CacheProvider", () => \{
			    const previousRender = store.libraries.frontity.render;
			    const collectChunks = jest.fn().mockImplementation((args) => args);
			
			    // Call the beforeSSR action.
			    store.actions.amp.beforeSSR();
			
			    const render = store.libraries.frontity.render;
			    const result = render(\{ App: store.libraries.frontity.App, collectChunks \});
			
			    expect(result).toMatchSnapshot();
			
			    expect(collectChunks).toBeCalled();
			
			    // Previous render method should not be called.
			    expect(previousRender).not.toBeCalled();
			  \});
			
			  test("The \`template\` method uses the previous result", () => \{
			    const previousTemplate = store.libraries.frontity.template;
			
			    // Call the beforeSSR action.
			    store.actions.amp.beforeSSR();
			
			    const template = store.libraries.frontity.template;
			
			    expect(
			      template(\{
			        result: \{ html: "html", css: "css", ids: ["id1"] \},
			        head: [],
			        html: "initial",
			        scripts: [],
			      \})
			    ).toMatchSnapshot();
			
			    // The previous template should not be called. Total control of template.
			    expect(previousTemplate).not.toBeCalled();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\amp\\src\\__tests__\\amp.server.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\packages\\amp\\src\\__tests__\\amp.test.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import merge from "deepmerge";
			import wpSource from "@frontity/wp-source/src";
			import \{ Packages \} from "../../types";
			import Amp from "..";
			import html2react from "@frontity/html2react/src";
			
			let store: InitializedStore<Packages>;
			describe("AMP tests", () => \{
			  beforeEach(() => \{
			    // Initialize the store
			    store = createStore<Packages>(
			      merge(merge(clone(wpSource()), html2react), Amp)
			    );
			    store.state.source.url = "https://test.frontity.org/";
			  \});
			
			  test("final \`/amp\` path is removed", () => \{
			    store.actions.amp.init();
			    const \{ normalize \} = store.libraries.source;
			
			    expect(normalize("/amp")).toBe("/");
			    expect(normalize("/posts/amp/")).toBe("/posts/");
			    expect(normalize("/some-page/amp/")).toBe("/some-page/");
			    expect(normalize("/parent/some-page/amp/")).toBe("/parent/some-page/");
			    expect(normalize("/category/some/amp/")).toBe("/category/some/");
			    expect(normalize("/tag/some/amp/")).toBe("/tag/some/");
			    expect(normalize("/taxonomy/some/amp/")).toBe("/taxonomy/some/");
			
			    expect(normalize("/amp/?a=1&b=1#some-hash")).toBe("/?a=1&b=1#some-hash");
			    expect(normalize("/amp/page/3/?a=1&b=1#some-hash")).toBe(
			      "/page/3/?a=1&b=1#some-hash"
			    );
			    expect(normalize("/taxonomy/some/amp/?a=1&b=1#some-hash")).toBe(
			      "/taxonomy/some/?a=1&b=1#some-hash"
			    );
			    expect(normalize("/taxonomy/some/page/3/?a=1&b=1#some-hash")).toBe(
			      "/taxonomy/some/page/3/?a=1&b=1#some-hash"
			    );
			
			    // These ones are not correct, but it is expected because Frontity does not
			    // support using \`amp\` as a [term] (https://wordpress.org/support/article/glossary/#term)
			    // for the time being.
			    expect(normalize("/category/amp/")).toBe("/category/");
			    expect(normalize("/tag/amp/")).toBe("/tag/");
			    expect(normalize("/taxonomy/amp/")).toBe("/taxonomy/");
			    expect(normalize("/author/amp/")).toBe("/author/");
			  \});
			
			  test(\`Compare the output of libraries.source.normalize() between the AMP package and the default implementation\`, () => \{
			    // Get the reference to normalize() before it's overriden in the init() action.
			    const \{ normalize \} = store.libraries.source;
			    store.actions.amp.init();
			
			    // The implementation of normalize() from the AMP package.
			    const \{ normalize: normalizeAmp \} = store.libraries.source;
			
			    // Test that the implementation of normalize() from the amp package is not
			    // the same as the default one.
			    expect(normalize).not.toBe(normalizeAmp);
			
			    expect(normalize("/")).toEqual(normalizeAmp("/"));
			    expect(normalize("/some-post/")).toEqual(normalizeAmp("/some-post/"));
			    expect(normalize("/some-page/")).toEqual(normalizeAmp("/some-page/"));
			    expect(normalize("/parent/some-page/")).toEqual(
			      normalizeAmp("/parent/some-page/")
			    );
			    expect(normalize("/category/some/")).toEqual(
			      normalizeAmp("/category/some/")
			    );
			    expect(normalize("/tag/some/")).toEqual(normalizeAmp("/tag/some/"));
			    expect(normalize("/taxonomy/some/")).toEqual(
			      normalizeAmp("/taxonomy/some/")
			    );
			    expect(normalize("/?a=1&b=1#some-hash")).toEqual(
			      normalizeAmp("/?a=1&b=1#some-hash")
			    );
			    expect(normalize("/page/3/?a=1&b=1#some-hash")).toEqual(
			      normalizeAmp("/page/3/?a=1&b=1#some-hash")
			    );
			    expect(normalize("/taxonomy/some/?a=1&b=1#some-hash")).toEqual(
			      normalizeAmp("/taxonomy/some/?a=1&b=1#some-hash")
			    );
			    expect(normalize("/taxonomy/some/page/3/?a=1&b=1#some-hash")).toEqual(
			      normalizeAmp("/taxonomy/some/page/3/?a=1&b=1#some-hash")
			    );
			  \});
			
			  test("Compare the output of libraries.source.parse() between the AMP package and the default implementation", () => \{
			    // Get the reference to parse() before it's overriden in the init() action.
			    const \{ parse \} = store.libraries.source;
			    store.actions.amp.init();
			
			    // The implementation of parse() from the AMP package.
			    const \{ parse: parseAmp \} = store.libraries.source;
			
			    // Test that the implementation of parse() from the amp package is not
			    // the same as the default one.
			    expect(parse).not.toBe(parseAmp);
			
			    expect(parse("/")).toEqual(parseAmp("/"));
			    expect(parse("/some-post/")).toEqual(parseAmp("/some-post/"));
			    expect(parse("/some-page/")).toEqual(parseAmp("/some-page/"));
			    expect(parse("/parent/some-page/")).toEqual(parseAmp("/parent/some-page/"));
			    expect(parse("/category/some/")).toEqual(parseAmp("/category/some/"));
			    expect(parse("/tag/some/")).toEqual(parseAmp("/tag/some/"));
			    expect(parse("/taxonomy/some/")).toEqual(parseAmp("/taxonomy/some/"));
			    expect(parse("/?a=1&b=1#some-hash")).toEqual(
			      parseAmp("/?a=1&b=1#some-hash")
			    );
			    expect(parse("/page/3/?a=1&b=1#some-hash")).toEqual(
			      parseAmp("/page/3/?a=1&b=1#some-hash")
			    );
			    expect(parse("/taxonomy/some/?a=1&b=1#some-hash")).toEqual(
			      parseAmp("/taxonomy/some/?a=1&b=1#some-hash")
			    );
			    expect(parse("/taxonomy/some/page/3/?a=1&b=1#some-hash")).toEqual(
			      parseAmp("/taxonomy/some/page/3/?a=1&b=1#some-hash")
			    );
			  \});
			
			  test("Compare the output of libraries.source.stringify() between the AMP package and the default implementation", () => \{
			    // Get the reference to stringify() before it's overriden in the init() action.
			    const \{ stringify \} = store.libraries.source;
			    store.actions.amp.init();
			
			    // The implementation of stringify() from the AMP package.
			    const \{ stringify: stringifyAmp \} = store.libraries.source;
			
			    // Test that the implementation of stringify() from the amp package is not
			    // the same as the default one.
			    expect(stringify).not.toBe(stringifyAmp);
			
			    let linkParams: any = \{ path: "/some/path" \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{ path: "custom-list" \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{ path: "/some/path/", page: 2 \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{
			      path: "/some/path",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			    \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{
			      path: "/",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			    \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{ route: "/some/path" \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{ route: "custom-list" \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{ route: "/some/path/", page: 2 \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{
			      route: "/some/path",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			    \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			
			    linkParams = \{
			      route: "/",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			    \};
			    expect(stringify(linkParams)).toEqual(stringifyAmp(linkParams));
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\amp\\src\\__tests__\\amp.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\amp\\src\\__tests__\\processors.test.tsx', () => {
        const sourceCode = `
			import Html2React from "@frontity/html2react/src/libraries/component";
			import \{ HelmetProvider \} from "frontity";
			import \{ amp, toBeValidAmpHtml \} from "./__utilities__/amp-validator";
			import \{ FilledContext, HelmetData \} from "react-helmet-async";
			
			import processors from "../processors";
			import \{ render \} from "@testing-library/react";
			
			expect.extend(\{ toBeValidAmpHtml \});
			
			// Need to set that flag when testing with jest
			// https://github.com/staylor/react-helmet-async#usage-in-jest
			HelmetProvider.canUseDOM = false;
			
			const replaceHeadAttributes = (head: HelmetData) => head.script.toString();
			
			test("Validate amp-img", async () => \{
			  const \{ container \} = render(
			    <Html2React
			      html="<img src='test.img' width='300' height='300'></img>"
			      processors=\{processors\}
			    />
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-img
			      height="300"
			      layout="responsive"
			      src="test.img"
			      width="300"
			    />
			  \`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			test("Validate amp-img when height or width are a number", async () => \{
			  const \{ container \} = render(
			    <Html2React
			      html="<img src='test.img' width=300 height=300></img>"
			      processors=\{processors\}
			    />
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-img
			      height="300"
			      layout="responsive"
			      src="test.img"
			      width="300"
			    />
			  \`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			test("Validate amp-img when height and width are missing", async () => \{
			  const \{ container \} = render(
			    <Html2React html="<img src='test.img'></img>" processors=\{processors\} />
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-img
			      class="css-1aa2jcx-Html2React"
			      layout="fill"
			      src="test.img"
			    />
			  \`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			test("Validate amp-iframe", async () => \{
			  const helmetContext = \{\};
			
			  const \{ container \} = render(
			    <HelmetProvider context=\{helmetContext\}>
			      <Html2React
			        html="<iframe src='test.html' width='auto' height='300'/>"
			        processors=\{processors\}
			      />
			    </HelmetProvider>
			  );
			
			  const head = (helmetContext as FilledContext).helmet;
			
			  expect(head.script.toString()).toMatchInlineSnapshot(
			    \`"<script data-rh=\\\\"true\\\\" async custom-element=\\\\"amp-iframe\\\\" src=\\\\"https://cdn.ampproject.org/v0/amp-iframe-0.1.js\\\\"></script>"\`
			  );
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-iframe
			      height="300"
			      layout="fixed-height"
			      sandbox="allow-scripts allow-same-origin "
			      src="test.html"
			      title=""
			      width="auto"
			    />
			  \`);
			
			  // We replace the \`async="true"\` with just \`async\`
			  const headScript = replaceHeadAttributes(head);
			  expect(await amp(container.innerHTML, headScript)).toBeValidAmpHtml();
			\});
			
			test("amp-iframe should concatenate the sandbox properties", () => \{
			  const helmetContext = \{\};
			
			  const \{ container \} = render(
			    <HelmetProvider context=\{helmetContext\}>
			      <Html2React
			        html="<iframe sandbox='allow-scripts allow-popups' src='test.html' width='auto' height='300'/>"
			        processors=\{processors\}
			      />
			    </HelmetProvider>
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-iframe
			      height="300"
			      layout="fixed-height"
			      sandbox="allow-scripts allow-same-origin allow-scripts allow-popups"
			      src="test.html"
			      title=""
			      width="auto"
			    />
			  \`);
			\});
			
			test("Validate amp-video", async () => \{
			  const helmetContext = \{\};
			
			  const \{ container \} = render(
			    <HelmetProvider context=\{helmetContext\}>
			      <Html2React
			        html="<video 
			          width='250' 
			          height='150' 
			          src='video.mp4'  
			          autoplay
			          loop
			          controls
			          muted
			        ></video>"
			        processors=\{processors\}
			      />
			    </HelmetProvider>
			  );
			
			  const head = (helmetContext as FilledContext).helmet;
			
			  expect(head.script.toString()).toMatchInlineSnapshot(
			    \`"<script data-rh=\\\\"true\\\\" async custom-element=\\\\"amp-video\\\\" src=\\\\"https://cdn.ampproject.org/v0/amp-video-0.1.js\\\\"></script>"\`
			  );
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-video
			      autoplay=""
			      controls=""
			      height="250"
			      layout="responsive"
			      loop=""
			      muted=""
			      src="video.mp4"
			      width="250"
			    />
			  \`);
			
			  // We replace the \`async="true"\` with just \`async\`
			  const headScript = replaceHeadAttributes(head);
			  expect(await amp(container.innerHTML, headScript)).toBeValidAmpHtml();
			\});
			
			test("Validate amp-audio", async () => \{
			  const helmetContext = \{\};
			
			  const \{ container \} = render(
			    <HelmetProvider context=\{helmetContext\}>
			      <Html2React
			        html="<audio src='audio.mp3'></audio>"
			        processors=\{processors\}
			      />
			    </HelmetProvider>
			  );
			
			  const head = (helmetContext as FilledContext).helmet;
			
			  expect(head.script.toString()).toMatchInlineSnapshot(
			    \`"<script data-rh=\\\\"true\\\\" async custom-element=\\\\"amp-audio\\\\" src=\\\\"https://cdn.ampproject.org/v0/amp-audio-0.1.js\\\\"></script>"\`
			  );
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-audio
			      src="audio.mp3"
			    />
			  \`);
			
			  // We replace the \`async="true"\` with just \`async\`
			  const headScript = replaceHeadAttributes(head);
			  expect(await amp(container.innerHTML, headScript)).toBeValidAmpHtml();
			\});
			
			test("amp-audio with child elements", async () => \{
			  const helmetContext = \{\};
			
			  const \{ container \} = render(
			    <HelmetProvider context=\{helmetContext\}>
			      <Html2React
			        html="<audio controls>
			          <source src='http://frontity.com/audio.mp3'></source>
			          <div placeholder=''> this is a placeholder </div>
			          <div placeholder=''> this placeholder should be removed </div>
			          <p fallback=''> and this is a fallback </p>
			          <p fallback=''> this is a fallback should be removed</p>
			          <div> this element should be removed </div>
			        </audio>"
			        processors=\{processors\}
			      />
			    </HelmetProvider>
			  );
			
			  const head = (helmetContext as FilledContext).helmet;
			
			  expect(head.script.toString()).toMatchInlineSnapshot(
			    \`"<script data-rh=\\\\"true\\\\" async custom-element=\\\\"amp-audio\\\\" src=\\\\"https://cdn.ampproject.org/v0/amp-audio-0.1.js\\\\"></script>"\`
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-audio
			      controls=""
			    >
			      <source
			        src="https://frontity.com/audio.mp3"
			      />
			      <div
			        placeholder=""
			      >
			         this is a placeholder 
			      </div>
			      <p
			        fallback=""
			      >
			         and this is a fallback 
			      </p>
			    </amp-audio>
			  \`);
			\});
			
			test("amp-video with child elements", async () => \{
			  const helmetContext = \{\};
			
			  const \{ container \} = render(
			    <HelmetProvider context=\{helmetContext\}>
			      <Html2React
			        html="<video controls>
			          <source src='http://frontity.com/video.mp4'></source>
			          <track src='http://frontity.com/video1.mp4'></source>
			          <track src='http://frontity.com/video2.mp4'></source>
			          <div placeholder=''> this is a placeholder </div>
			          <div placeholder=''> this placeholder should be removed </div>
			          <p fallback=''> and this is a fallback </p>
			          <p fallback=''> this is a fallback should be removed</p>
			          <div> this element should be removed </div>
			        </video>"
			        processors=\{processors\}
			      />
			    </HelmetProvider>
			  );
			
			  const head = (helmetContext as FilledContext).helmet;
			
			  expect(head.script.toString()).toMatchInlineSnapshot(
			    \`"<script data-rh=\\\\"true\\\\" async custom-element=\\\\"amp-video\\\\" src=\\\\"https://cdn.ampproject.org/v0/amp-video-0.1.js\\\\"></script>"\`
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-video
			      controls=""
			      height="9"
			      layout="responsive"
			      width="16"
			    >
			      <source
			        src="https://frontity.com/video.mp4"
			      />
			      <track
			        src="https://frontity.com/video1.mp4"
			      />
			      <track
			        src="https://frontity.com/video2.mp4"
			      />
			      <div
			        placeholder=""
			      >
			         this is a placeholder 
			      </div>
			      <p
			        fallback=""
			      >
			         and this is a fallback 
			      </p>
			    </amp-video>
			  \`);
			\});
			
			test("<script /> elements should be removed", async () => \{
			  const \{ container \} = render(
			    <Html2React
			      html="<div><script src='test.js'></script></div>"
			      processors=\{processors\}
			    />
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`<div />\`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			test("Elements with prohibited class names should be removed", async () => \{
			  const \{ container \} = render(
			    <Html2React
			      html="
			      <div>
			        <div class='other -amp-test this-amp-is-allowed'></div>
			        <div class='other i-amp-test -this-i-amp-is-also-allowed'></div>
			      </div>"
			      processors=\{processors\}
			    />
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div
			        class="other this-amp-is-allowed"
			      />
			      <div
			        class="other -this-i-amp-is-also-allowed"
			      />
			    </div>
			  \`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			test("Elements with prohibited ID values should be removed", async () => \{
			  const \{ container \} = render(
			    <Html2React
			      html="
			      <div>
			        <div id='-amp-test' class='test1'></div>
			        <div id='i-amp-test' class='test2'></div>
			      </div>"
			      processors=\{processors\}
			    />
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <div>
			      <div
			        class="test1"
			      />
			      <div
			        class="test2"
			      />
			    </div>
			  \`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			test("Validate amp-twitter", async () => \{
			  const \{ container \} = render(<Html2React html="" processors=\{processors\} />);
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`null\`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			test("Adding 2 iframes should result in adding only 1 amp-iframe AMP script in the <head />", async () => \{
			  const helmetContext = \{\};
			
			  const \{ container \} = render(
			    <HelmetProvider context=\{helmetContext\}>
			      <Html2React
			        html="<iframe src='a.html' width='auto' height='5'/><iframe src='a.html' width='auto' height='5'/>"
			        processors=\{processors\}
			      />
			    </HelmetProvider>
			  );
			
			  const head = (helmetContext as FilledContext).helmet;
			
			  expect(head.script.toString()).toMatchInlineSnapshot(
			    \`"<script data-rh=\\\\"true\\\\" async custom-element=\\\\"amp-iframe\\\\" src=\\\\"https://cdn.ampproject.org/v0/amp-iframe-0.1.js\\\\"></script>"\`
			  );
			
			  // We replace the \`async="true"\` with just \`async\`
			  const headScript = replaceHeadAttributes(head);
			  expect(await amp(container.innerHTML, headScript)).toBeValidAmpHtml();
			\});
			
			test("picture element should be replaced with an img", async () => \{
			  const \{ container \} = render(
			    <Html2React
			      html='
			        <picture>
			          <source media="(min-width:650px)" srcset="img_pink_flowers.jpg" />
			          <source media="(min-width:465px)" srcset="img_white_flower.jpg" />
			          <img src="img_orange_flowers.jpg" alt="Flowers" style="width:auto;" width="300" height="100" />
			        </picture>'
			      processors=\{processors\}
			    />
			  );
			
			  expect(container.firstChild).toMatchInlineSnapshot(\`
			    <amp-img
			      alt="Flowers"
			      class="css-1gbrod6-Html2React"
			      height="100"
			      layout="responsive"
			      src="img_orange_flowers.jpg"
			      width="300"
			    />
			  \`);
			  expect(await amp(container.innerHTML)).toBeValidAmpHtml();
			\});
			
			describe("Transform http to https and warn about it", () => \{
			  const consoleWarn = jest.spyOn(global.console, "warn");
			
			  beforeEach(() => \{
			    consoleWarn.mockReset();
			  \});
			
			  test("amp-iframe", () => \{
			    const helmetContext = \{\};
			
			    const \{ container \} = render(
			      <HelmetProvider context=\{helmetContext\}>
			        <Html2React
			          html="<iframe src='http://frontity.org/test.html' width='auto' height='300'/>"
			          processors=\{processors\}
			        />
			      </HelmetProvider>
			    );
			
			    expect(
			      container.firstElementChild.getAttribute("src").startsWith("https://")
			    ).toBe(true);
			
			    expect(consoleWarn).toHaveBeenCalledTimes(1);
			    expect(consoleWarn.mock.calls[0][0]).toMatchInlineSnapshot(\`
			      "An element with src of https://frontity.org/test.html was found but AMP requires resources to be loaded over HTTPS.
			
			      Frontity will update the src attribute to point to the HTTPS version but you need to ensure that the asset is available over HTTPS.
			      Visit https://community.frontity.org for help! 
			      "
			    \`);
			  \});
			
			  test("amp-audio", () => \{
			    const helmetContext = \{\};
			    const consoleWarn = jest.spyOn(global.console, "warn");
			
			    const \{ container \} = render(
			      <HelmetProvider context=\{helmetContext\}>
			        <Html2React
			          html="<audio src='http://frontity.org/audio.mp3'></audio>"
			          processors=\{processors\}
			        />
			      </HelmetProvider>
			    );
			
			    expect(
			      container
			        .getElementsByTagName("amp-audio")[0]
			        .getAttribute("src")
			        .startsWith("https://")
			    ).toBe(true);
			
			    expect(consoleWarn).toHaveBeenCalledTimes(1);
			    expect(consoleWarn.mock.calls[0][0]).toMatchInlineSnapshot(\`
			      "An element with src of https://frontity.org/audio.mp3 was found but AMP requires resources to be loaded over HTTPS.
			
			      Frontity will update the src attribute to point to the HTTPS version but you need to ensure that the asset is available over HTTPS.
			      Visit https://community.frontity.org for help! 
			      "
			    \`);
			  \});
			
			  test("amp-video", () => \{
			    const helmetContext = \{\};
			    const consoleWarn = jest.spyOn(global.console, "warn");
			
			    const \{ container \} = render(
			      <HelmetProvider context=\{helmetContext\}>
			        <Html2React
			          html="<video 
			          width='250' 
			          height='150' 
			          src='http://frontity.org/video.mp4'  
			        ></video>"
			          processors=\{processors\}
			        />
			      </HelmetProvider>
			    );
			
			    expect(
			      container
			        .getElementsByTagName("amp-video")[0]
			        .getAttribute("src")
			        .startsWith("https://")
			    ).toBe(true);
			
			    expect(consoleWarn).toHaveBeenCalledTimes(1);
			    expect(consoleWarn.mock.calls[0][0]).toMatchInlineSnapshot(\`
			      "An element with src of https://frontity.org/video.mp4 was found but AMP requires resources to be loaded over HTTPS.
			
			      Frontity will update the src attribute to point to the HTTPS version but you need to ensure that the asset is available over HTTPS.
			      Visit https://community.frontity.org for help! 
			      "
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\amp\\src\\__tests__\\processors.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(18)
    });
    it('frontity_frontity\\packages\\analytics\\__tests__\\index.test.tsx', () => {
        const sourceCode = `
			import \{ createStore \} from "frontity";
			import analytics from "../src";
			
			describe("analytics.pageview", () => \{
			  test("runs all 'pageview' from other analytics packages", () => \{
			    const pkg1SendPageview = jest.fn();
			    const pkg2SendPageview = jest.fn();
			    const pkg3SendPageview = jest.fn();
			
			    const mergedPackages = \{
			      state: \{
			        analytics: \{
			          pageviews: \{
			            pkg1Analytics: true,
			            pkg2Analytics: true,
			            pkg3Analytics: false,
			          \},
			        \},
			      \},
			      actions: \{
			        ...analytics.actions,
			        pkg1Analytics: \{
			          pageview: () => pkg1SendPageview,
			        \},
			        pkg2Analytics: \{
			          pageview: () => pkg2SendPageview,
			        \},
			        pkg3Analytics: \{
			          pageview: () => pkg3SendPageview,
			        \},
			      \},
			    \};
			
			    const \{ actions \} = createStore(mergedPackages);
			
			    const pageview = \{
			      link: "/some/page",
			      title: "Some Title - My Site",
			    \};
			
			    actions.analytics.pageview(pageview);
			
			    expect(pkg1SendPageview).toHaveBeenCalledWith(pageview);
			    expect(pkg1SendPageview).toHaveBeenCalledTimes(1);
			    expect(pkg2SendPageview).toHaveBeenCalledWith(pageview);
			    expect(pkg2SendPageview).toHaveBeenCalledTimes(1);
			    expect(pkg3SendPageview).not.toHaveBeenCalled();
			  \});
			\});
			
			describe("analytics.event", () => \{
			  test("runs all 'event' from other analytics packages", () => \{
			    const pkg1Event = jest.fn();
			    const pkg2Event = jest.fn();
			    const pkg3Event = jest.fn();
			
			    const mergedPackages = \{
			      state: \{
			        analytics: \{
			          events: \{
			            pkg1Analytics: true,
			            pkg2Analytics: true,
			            pkg3Analytics: false,
			          \},
			        \},
			      \},
			      actions: \{
			        ...analytics.actions,
			        pkg1Analytics: \{
			          event: () => pkg1Event,
			        \},
			        pkg2Analytics: \{
			          event: () => pkg2Event,
			        \},
			        pkg3Analytics: \{
			          event: () => pkg3Event,
			        \},
			      \},
			    \};
			
			    const \{ actions \} = createStore(mergedPackages);
			
			    const event = \{
			      name: "some event",
			      payload: \{
			        category: "post",
			        action: "scroll",
			      \},
			    \};
			
			    actions.analytics.event(event);
			
			    expect(pkg1Event).toHaveBeenCalledWith(event);
			    expect(pkg1Event).toHaveBeenCalledTimes(1);
			    expect(pkg2Event).toHaveBeenCalledWith(event);
			    expect(pkg2Event).toHaveBeenCalledTimes(1);
			    expect(pkg3Event).not.toHaveBeenCalled();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\analytics\\__tests__\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\components\\link\\__tests__\\link.tests.tsx', () => {
        const sourceCode = `
			/* eslint-disable @typescript-eslint/ban-ts-comment */
			import \{ render, unmountComponentAtNode \} from "react-dom";
			import \{ act \} from "react-dom/test-utils";
			import \{ create \} from "react-test-renderer";
			import \{ mockIsIntersecting \} from "react-intersection-observer/test-utils";
			import \{ createStore, Provider \} from "../../../connect/src";
			import Link from "..";
			import \{ config \} from "../utils";
			
			let store;
			let container;
			let fetch: jest.Mock;
			let get: jest.Mock;
			
			beforeEach(() => \{
			  fetch = jest.fn();
			  get = jest.fn();
			  jest.useFakeTimers();
			  container = document.createElement("div");
			  document.body.appendChild(container);
			  window.scrollTo = jest.fn();
			  store = createStore(\{
			    state: \{
			      frontity: \{\},
			      theme: \{
			        autoPrefetch: "hover",
			      \},
			      source: \{
			        url: "http://backendurl.com",
			        get: () => get,
			      \},
			    \},
			    actions: \{
			      router: \{
			        set(link) \{
			          return link;
			        \},
			      \},
			      source: \{
			        fetch: () => fetch,
			      \},
			    \},
			  \});
			\});
			
			afterEach(() => \{
			  unmountComponentAtNode(container);
			  window.scrollTo = null;
			  container.remove();
			  container = null;
			\});
			
			describe("Link", () => \{
			  test("should render a regular link", () => \{
			    const LinkComponent = create(
			      <Provider value=\{store\}>
			        <Link link="/">This is a link</Link>
			      </Provider>
			    );
			
			    expect(LinkComponent.toJSON()).toMatchInlineSnapshot(\`
			      <a
			        href="/"
			        onClick=\{[Function]\}
			        target="_self"
			      >
			        This is a link
			      </a>
			    \`);
			  \});
			
			  test("should add classname if provided", () => \{
			    const LinkComponent = create(
			      <Provider value=\{store\}>
			        <Link link="/" className="custom-classname">
			          This is a link
			        </Link>
			      </Provider>
			    );
			
			    expect(LinkComponent.toJSON()).toMatchInlineSnapshot(\`
			      <a
			        className="custom-classname"
			        href="/"
			        onClick=\{[Function]\}
			        target="_self"
			      >
			        This is a link
			      </a>
			    \`);
			  \});
			
			  test("clicking a link works as expected", () => \{
			    const onClick = jest.fn();
			    const linkUrl = "/my-page";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} className="my-link" onClick=\{onClick\}>
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(onClick).toHaveBeenCalledTimes(1);
			    expect(window.scrollTo).toHaveBeenCalledWith(0, 0);
			    expect(store.actions.router.set).toHaveBeenCalledWith(linkUrl);
			  \});
			
			  test("clicking a link without scrolling", () => \{
			    const linkUrl = "/my-page";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} scroll=\{false\} className="my-link">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).toHaveBeenCalledWith(linkUrl);
			  \});
			
			  test("clicking a link with target=_blank does not do anything", () => \{
			    const linkUrl = "/my-page";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} target="_blank" className="my-link">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).not.toHaveBeenCalledWith(linkUrl);
			  \});
			
			  test("clicking a link that starts with http does not do anything", () => \{
			    const linkUrl = "https://externallink.com";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} className="my-link">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).not.toHaveBeenCalledWith(linkUrl);
			  \});
			
			  test("forcing a link to open in a new tab/window works", () => \{
			    const linkUrl = "/my-link";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} className="my-link">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			
			    act(() => \{
			      // ctrl + click
			      anchor.dispatchEvent(
			        new MouseEvent("click", \{ bubbles: true, ctrlKey: true \})
			      );
			    \});
			
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).not.toHaveBeenCalledWith(linkUrl);
			
			    act(() => \{
			      // shift + click
			      anchor.dispatchEvent(
			        new MouseEvent("click", \{ bubbles: true, shiftKey: true \})
			      );
			    \});
			
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).not.toHaveBeenCalledWith(linkUrl);
			
			    act(() => \{
			      // cmd + click
			      anchor.dispatchEvent(
			        new MouseEvent("click", \{ bubbles: true, metaKey: true \})
			      );
			    \});
			
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).not.toHaveBeenCalledWith(linkUrl);
			
			    act(() => \{
			      // middle mouse button
			      anchor.dispatchEvent(
			        new MouseEvent("click", \{ bubbles: true, button: 1 \})
			      );
			    \});
			
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).not.toHaveBeenCalledWith(linkUrl);
			  \});
			
			  test("it removes the source url from links", () => \{
			    const linkUrl = store.state.source.url + "/internal-link";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl\} className="my-link-2" replaceSourceUrls=\{false\}>
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			    const anchor2 = document.querySelector("a.my-link-2") as HTMLAnchorElement;
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			      anchor2.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(store.actions.router.set).toHaveBeenCalledWith("/internal-link");
			    expect(store.actions.router.set).toHaveBeenCalledTimes(1);
			    expect(anchor2.href).toEqual(linkUrl);
			  \});
			
			  test("it removes the source url from links if WordPress is multisite", () => \{
			    store.state.source.url = "http://backend.url/subsite/";
			
			    const linkUrl = store.state.source.url + "internal-link";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl\} className="my-link-2" replaceSourceUrls=\{false\}>
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			    const anchor2 = document.querySelector("a.my-link-2") as HTMLAnchorElement;
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			      anchor2.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(store.actions.router.set).toHaveBeenCalledWith("/internal-link");
			    expect(store.actions.router.set).toHaveBeenCalledTimes(1);
			    expect(anchor2.href).toEqual(linkUrl);
			  \});
			
			  test("it prepends the \`state.frontity.url\` pathname", () => \{
			    store.state.frontity.url = "https://frontityurl.com/blog";
			
			    const linkUrl = store.state.source.url + "/internal-link";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl\} className="my-link-2" replaceSourceUrls=\{false\}>
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			    const anchor2 = document.querySelector("a.my-link-2") as HTMLAnchorElement;
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			      anchor2.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(store.actions.router.set).toHaveBeenCalledWith(
			      "/blog/internal-link"
			    );
			    expect(store.actions.router.set).toHaveBeenCalledTimes(1);
			    expect(anchor2.href).toEqual(linkUrl);
			  \});
			
			  test("it takes into account the \`match\` property before replacing internal links", () => \{
			    const storeWithMatch = \{ ...store \};
			
			    // should only match /blog links
			    storeWithMatch.state.frontity.match = [
			      "https?:\\\\/\\\\/[^/]+\\\\/blog([^-\\\\w]|\$)",
			    ];
			
			    const linkThatDoesNotMatch = store.state.source.url + "/internal-link";
			    const linkThatMatches = store.state.source.url + "/blog/blog-link";
			
			    act(() => \{
			      render(
			        <Provider value=\{storeWithMatch\}>
			          <Link link=\{linkThatDoesNotMatch\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkThatMatches\} className="my-link-that-matches">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link") as HTMLAnchorElement;
			    const anchor2 = document.querySelector("a.my-link-that-matches");
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			      anchor2.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(store.actions.router.set).toHaveBeenCalledWith("/blog/blog-link");
			    expect(store.actions.router.set).not.toHaveBeenCalledWith("/internal-link");
			    expect(store.actions.router.set).toHaveBeenCalledTimes(1);
			    // the link that does not match should remain the same
			    expect(anchor.href).toEqual(linkThatDoesNotMatch);
			  \});
			
			  test("it does not fetch tel:, sms: and mailto: links", () => \{
			    const onClick = jest.fn();
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link
			            link="mailto:email@domain.com"
			            className="my-link"
			            onClick=\{onClick\}
			          >
			            This is a link
			          </Link>
			          <Link
			            link="tel:1-562-867-5309"
			            className="my-link-2"
			            onClick=\{onClick\}
			          >
			            This is a link
			          </Link>
			          <Link
			            link="sms:+18664504185&body=Hi%2520there"
			            className="my-link-3"
			            onClick=\{onClick\}
			          >
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.router, "set");
			
			    const anchor = document.querySelector("a.my-link");
			    const anchor2 = document.querySelector("a.my-link-2");
			    const anchor3 = document.querySelector("a.my-link-3");
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			      anchor2.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			      anchor3.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(onClick).not.toHaveBeenCalled();
			    expect(window.scrollTo).not.toHaveBeenCalled();
			    expect(store.actions.router.set).not.toHaveBeenCalled();
			  \});
			\});
			
			describe("Link prefetching", () => \{
			  test("disabling works", () => \{
			    const linkUrl1 = "/post-name";
			    const linkUrl2 = "/post-name-2";
			    const storeAllMode = \{ ...store \};
			    storeAllMode.state.theme.autoPrefetch = "all";
			
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			    jest.spyOn(store.actions.source, "fetch");
			
			    act(() => \{
			      render(
			        <Provider value=\{storeAllMode\}>
			          <Link link=\{linkUrl1\} prefetch=\{false\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl2\} className="my-link-2">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.runAllTimers();
			
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(1);
			    expect(store.actions.source.fetch).not.toHaveBeenCalledWith(linkUrl1);
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl2);
			  \});
			
			  test("does not prefetch if it is disabled", () => \{
			    const linkUrl1 = "/post-name";
			    const linkUrl2 = "/post-name-2";
			    const storeNoPrefetchMode = \{ ...store \};
			    storeNoPrefetchMode.state.theme.autoPrefetch = "no";
			
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			    jest.spyOn(store.actions.source, "fetch");
			
			    act(() => \{
			      render(
			        <Provider value=\{storeNoPrefetchMode\}>
			          <Link link=\{linkUrl1\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl2\} className="my-link-2">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.runAllTimers();
			
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(0);
			    expect(store.actions.source.fetch).not.toHaveBeenCalledWith(linkUrl1);
			    expect(store.actions.source.fetch).not.toHaveBeenCalledWith(linkUrl2);
			  \});
			
			  test("does not prefetch if setting is missing", () => \{
			    const linkUrl1 = "/post-name";
			    const linkUrl2 = "/post-name-2";
			    const storeNoPrefetchMode = \{ ...store \};
			    delete storeNoPrefetchMode.state.theme.autoPrefetch;
			
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			    jest.spyOn(store.actions.source, "fetch");
			
			    act(() => \{
			      render(
			        <Provider value=\{storeNoPrefetchMode\}>
			          <Link link=\{linkUrl1\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl2\} className="my-link-2">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.runAllTimers();
			
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(0);
			    expect(store.actions.source.fetch).not.toHaveBeenCalledWith(linkUrl1);
			    expect(store.actions.source.fetch).not.toHaveBeenCalledWith(linkUrl2);
			  \});
			
			  test("does not run on slow connections", () => \{
			    const linkUrl1 = "/post-name";
			    const storeAllMode = \{ ...store \};
			    storeAllMode.state.theme.autoPrefetch = "all";
			
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			    jest.spyOn(store.actions.source, "fetch");
			    // simulate save data mode
			    // @ts-ignore
			    (navigator as Navigator & \{ connection \}).connection = \{ saveData: true \};
			    act(() => \{
			      render(
			        <Provider value=\{storeAllMode\}>
			          <Link link=\{linkUrl1\} className="my-link">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(0);
			    expect(store.actions.source.fetch).not.toHaveBeenCalledWith(linkUrl1);
			
			    // @ts-ignore
			    (navigator as Navigator & \{ connection \}).connection = \{ saveData: false \};
			  \});
			
			  test("all mode works", () => \{
			    const linkUrl1 = "/post-name-all-1";
			    const linkUrl2 = "/post-name-all-2";
			    const linkUrl3 = "/post-name-all-3";
			    const linkUrl4 = "/post-name-all-4";
			    const linkUrl5 = "/post-name-all-5";
			    const storeAllMode = \{ ...store \};
			    storeAllMode.state.theme.autoPrefetch = "all";
			
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			    jest.spyOn(store.actions.source, "fetch");
			
			    act(() => \{
			      render(
			        <Provider value=\{storeAllMode\}>
			          <Link link=\{linkUrl1\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl2\} className="my-link-2">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl3\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl4\} className="my-link-2">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl5\} className="my-link-2">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl1\} className="my-link-3">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl2\} className="my-link-4">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.runAllTimers();
			
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(5);
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl1);
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl2);
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl3);
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl4);
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl5);
			  \});
			
			  test("hover mode works", () => \{
			    const linkUrl = "/post-name-hover-1";
			    const linkUrlNoPrefetch = "/post-name-hover-2";
			
			    act(() => \{
			      render(
			        <Provider value=\{store\}>
			          <Link link=\{linkUrl\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl\} className="my-link-2">
			            This is a link
			          </Link>
			          <Link link=\{linkUrlNoPrefetch\} className="my-link-3">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    jest.spyOn(store.actions.source, "fetch");
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			
			    const anchor = document.querySelector("a.my-link");
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("mouseover", \{ bubbles: true \}));
			    \});
			    jest.runAllTimers();
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl);
			
			    // if data is already avaliable no need to prefetch again.
			    get.mockReturnValue(\{ isReady: true, isFetching: false \});
			
			    act(() => \{
			      anchor.dispatchEvent(new MouseEvent("mouseover", \{ bubbles: true \}));
			    \});
			    jest.runAllTimers();
			
			    const anchor2 = document.querySelector("a.my-link-2");
			
			    act(() => \{
			      anchor2.dispatchEvent(new MouseEvent("mouseover", \{ bubbles: true \}));
			    \});
			
			    jest.runAllTimers();
			    // a link that was not prefetched should not call fetch, it should go through the router instead
			    const anchor3 = document.querySelector("a.my-link-3");
			
			    act(() => \{
			      anchor3.dispatchEvent(new MouseEvent("click", \{ bubbles: true \}));
			    \});
			
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(1);
			  \});
			
			  test("in-view mode works", () => \{
			    const linkUrl = "/post-name-hover-1";
			    const linkUrl2 = "/post-name-hover-2";
			
			    const storeInViewMode = \{ ...store \};
			    storeInViewMode.state.theme.autoPrefetch = "in-view";
			
			    jest.spyOn(store.actions.source, "fetch");
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			
			    act(() => \{
			      render(
			        <Provider value=\{storeInViewMode\}>
			          <Link link=\{linkUrl\} className="my-link">
			            This is a link
			          </Link>
			          <Link link=\{linkUrl2\} className="my-link-2">
			            This is a link
			          </Link>
			        </Provider>,
			        container
			      );
			    \});
			
			    const anchor = document.querySelector("a.my-link");
			    mockIsIntersecting(anchor, true);
			    jest.runAllTimers();
			
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl);
			    expect(store.actions.source.fetch).not.toHaveBeenCalledWith(linkUrl2);
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(1);
			
			    const anchor2 = document.querySelector("a.my-link-2");
			    mockIsIntersecting(anchor2, true);
			    jest.runAllTimers();
			
			    expect(store.actions.source.fetch).toHaveBeenCalledWith(linkUrl2);
			    expect(store.actions.source.fetch).toHaveBeenCalledTimes(2);
			  \});
			
			  test("works in batches", () => \{
			    const links = [
			      "/post-name-1",
			      "/post-name-2",
			      "/post-name-3",
			      "/post-name-4",
			      "/post-name-5",
			      "/post-name-6",
			      "/post-name-7",
			      "/post-name-8",
			      "/post-name-9",
			      "/post-name-10",
			    ];
			
			    const storeInViewMode = \{ ...store \};
			    storeInViewMode.state.theme.autoPrefetch = "all";
			
			    jest.spyOn(store.actions.source, "fetch");
			    get.mockReturnValue(\{ isReady: false, isFetching: false \});
			
			    act(() => \{
			      render(
			        <Provider value=\{storeInViewMode\}>
			          \{links.map((link, i) => (
			            <Link key=\{link\} link=\{link\} className=\{\`my-link-\$\{i\}\`\}>
			              This is a link
			            </Link>
			          ))\}
			        </Provider>,
			        container
			      );
			    \});
			
			    const numBatches = links.length / config.requestsPerBatch;
			
			    for (let i = 1; i < numBatches; i++) \{
			      // process batch
			      jest.runOnlyPendingTimers();
			      expect(store.actions.source.fetch).toHaveBeenCalledTimes(
			        config.requestsPerBatch * i
			      );
			    \}
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\link\\__tests__\\link.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(20)
    });
    it('frontity_frontity\\packages\\components\\link\\__tests__\\utils.tests.ts', () => {
        const sourceCode = `
			import \{ isExternalUrl, removeSourceUrl \} from "../utils";
			
			describe("removeSourceUrl", () => \{
			  it("removes source url", () => \{
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/post-name-1",
			        sourceUrl: "https://backendurl.com",
			      \})
			    ).toEqual("/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "https://backendurl.com/post-name-1/",
			        sourceUrl: "http://backendurl.com",
			      \})
			    ).toEqual("/post-name-1/");
			
			    expect(
			      removeSourceUrl(\{
			        link: "https://backendurl.com/post-name-1",
			        sourceUrl: "https://backendurl.com",
			      \})
			    ).toEqual("/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/post-name-1",
			        sourceUrl: "https://backendurl.com/",
			      \})
			    ).toEqual("/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/post-name-1?a=1&b=3&d=3",
			        sourceUrl: "https://backendurl.com/",
			      \})
			    ).toEqual("/post-name-1?a=1&b=3&d=3");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/post-name-1#id",
			        sourceUrl: "https://backendurl.com/",
			      \})
			    ).toEqual("/post-name-1#id");
			  \});
			
			  it("removes source url when the backend url contains a folder", () => \{
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1",
			        sourceUrl: "https://backendurl.com/folder",
			      \})
			    ).toEqual("/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1/",
			        sourceUrl: "https://backendurl.com/folder",
			      \})
			    ).toEqual("/post-name-1/");
			
			    expect(
			      removeSourceUrl(\{
			        link: "https://backendurl.com/folder/post-name-1",
			        sourceUrl: "https://backendurl.com/folder",
			      \})
			    ).toEqual("/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1",
			        sourceUrl: "https://backendurl.com/folder/",
			      \})
			    ).toEqual("/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1?a=1&b=3&d=3",
			        sourceUrl: "https://backendurl.com/folder",
			      \})
			    ).toEqual("/post-name-1?a=1&b=3&d=3");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1#id",
			        sourceUrl: "https://backendurl.com/folder/",
			      \})
			    ).toEqual("/post-name-1#id");
			  \});
			
			  it("adds subdirectory if frontity url contains it", () => \{
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1",
			        sourceUrl: "https://backendurl.com/folder",
			        frontityUrl: "https://frontityurl.com/subdir/",
			      \})
			    ).toEqual("/subdir/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1/",
			        sourceUrl: "https://backendurl.com/folder",
			        frontityUrl: "http://frontityurl.com/subdir/",
			      \})
			    ).toEqual("/subdir/post-name-1/");
			
			    expect(
			      removeSourceUrl(\{
			        link: "https://backendurl.com/folder/post-name-1",
			        sourceUrl: "https://backendurl.com/folder",
			        frontityUrl: "https://frontityurl.com/subdir",
			      \})
			    ).toEqual("/subdir/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1",
			        sourceUrl: "https://backendurl.com/folder/",
			        frontityUrl: "http://frontityurl.com/subdir",
			      \})
			    ).toEqual("/subdir/post-name-1");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1?a=1&b=3&d=3",
			        sourceUrl: "https://backendurl.com/folder",
			        frontityUrl: "https://frontityurl.com/subdir/",
			      \})
			    ).toEqual("/subdir/post-name-1?a=1&b=3&d=3");
			
			    expect(
			      removeSourceUrl(\{
			        link: "http://backendurl.com/folder/post-name-1#id",
			        sourceUrl: "https://backendurl.com/folder/",
			        frontityUrl: "http://frontityurl.com/subdir/",
			      \})
			    ).toEqual("/subdir/post-name-1#id");
			  \});
			\});
			
			describe("isExternalUrl", () => \{
			  it("checks for mailto links", () => \{
			    expect(isExternalUrl("mailto:email@domain.com")).toBe(true);
			    expect(
			      isExternalUrl(
			        "mailto:email@domain.com?subject=The%20subject&body=This%20is%20a%20message%20body"
			      )
			    ).toBe(true);
			    expect(isExternalUrl("mailto:name1@mail.com,name2@mail.com")).toBe(true);
			  \});
			
			  it("checks for tel and sms links", () => \{
			    expect(isExternalUrl("tel:1-562-867-5309")).toBe(true);
			    expect(
			      isExternalUrl(
			        "sms:+18664504185&body=Hi%2520there%252C%2520I%2527d%2520like%2520to%2520place%2520an%2520order%2520for..."
			      )
			    ).toBe(true);
			  \});
			
			  it("checks for absolute urls", () => \{
			    expect(isExternalUrl("http://url.com")).toBe(true);
			    expect(isExternalUrl("https://url.com")).toBe(true);
			  \});
			
			  it("returns false for relative (internal) urls", () => \{
			    expect(isExternalUrl("/post-name")).toBe(false);
			    expect(isExternalUrl("/page-name")).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\link\\__tests__\\utils.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\packages\\components\\__tests__\\iframe.jsdom.tests.tsx', () => {
        const sourceCode = `
			/* eslint-disable no-global-assign */
			/* eslint-disable @typescript-eslint/no-empty-function */
			import \{ Provider, createStore \} from "@frontity/connect";
			
			/**
			 * @jest-environment jsdom
			 */
			
			import TestRenderer from "react-test-renderer";
			import useInView from "@frontity/hooks/use-in-view";
			import Iframe from "../iframe";
			
			jest.mock("@frontity/hooks/use-in-view", () => (\{
			  __esModule: true,
			  default: jest.fn(),
			\}));
			
			describe("Iframe", () => \{
			  const mockedUseInView = useInView as jest.MockedFunction<typeof useInView>;
			
			  beforeEach(() => \{
			    delete (HTMLIFrameElement as any).prototype.loading;
			    Object.defineProperty(window, "IntersectionObserver", \{
			      writable: true,
			      value: jest.fn(),
			    \});
			  \});
			
			  afterEach(() => \{
			    mockedUseInView.mockReset();
			  \});
			
			  test('works when loading === "eager"', () => \{
			    const loading: "lazy" | "eager" = "eager";
			
			    const props = \{
			      title: "Iframe title",
			      src: "https://iframe-src.com/iframe",
			      className: "fake-class-name",
			      height: 500,
			      loading,
			    \};
			
			    mockedUseInView.mockReturnValue(\{
			      ref: () => \{\},
			      inView: false,
			      supported: true,
			    \});
			
			    const result = TestRenderer.create(<Iframe \{...props\} />).toJSON();
			    expect(result).toMatchSnapshot();
			  \});
			
			  test("works with native lazy load and component did not mount", () => \{
			    (HTMLIFrameElement as any).prototype.loading = true;
			
			    const store = createStore(\{
			      state: \{
			        frontity: \{ rendering: "ssr" \},
			      \},
			    \});
			
			    mockedUseInView.mockReturnValue(\{
			      ref: () => \{\},
			      inView: false,
			      supported: true,
			    \});
			
			    const props = \{
			      title: "Iframe title",
			      src: "https://iframe-src.com/iframe",
			      className: "fake-class-name",
			      loading: "lazy" as const,
			      height: 300,
			    \};
			
			    const result = TestRenderer.create(
			      <Provider value=\{store\}>
			        <Iframe \{...props\} />
			      </Provider>
			    );
			    expect(result.toJSON()).toMatchSnapshot();
			  \});
			
			  test("works with native lazy load and component did mount", () => \{
			    (HTMLIFrameElement as any).prototype.loading = true;
			
			    const store = createStore(\{
			      state: \{
			        frontity: \{ rendering: "csr" \},
			      \},
			    \});
			
			    mockedUseInView.mockReturnValue(\{
			      ref: () => \{\},
			      inView: false,
			      supported: true,
			    \});
			
			    const props = \{
			      title: "Iframe title",
			      src: "https://iframe-src.com/iframe",
			      className: "fake-class-name",
			      loading: "lazy" as const,
			      height: 300,
			    \};
			
			    const result = TestRenderer.create(
			      <Provider value=\{store\}>
			        <Iframe \{...props\} />
			      </Provider>
			    );
			    expect(result.toJSON()).toMatchSnapshot();
			  \});
			
			  test("works with \`IntersectionObserver\` if \`height\` prop is not specified", () => \{
			    (HTMLIFrameElement as any).prototype.loading = true;
			
			    const store = createStore(\{
			      state: \{
			        frontity: \{ rendering: "csr" \},
			      \},
			    \});
			
			    mockedUseInView.mockReturnValue(\{
			      ref: () => \{\},
			      inView: false,
			      supported: true,
			    \});
			
			    const props = \{
			      title: "Iframe title",
			      src: "https://iframe-src.com/iframe",
			      className: "fake-class-name",
			      loading: "lazy" as const,
			    \};
			
			    const result = TestRenderer.create(
			      <Provider value=\{store\}>
			        <Iframe \{...props\} />
			      </Provider>
			    );
			    expect(result.toJSON()).toMatchSnapshot();
			  \});
			
			  test("works with \`IntersectionObserver\` and is out of view", () => \{
			    const store = createStore(\{
			      state: \{
			        frontity: \{ rendering: "csr" \},
			      \},
			    \});
			
			    mockedUseInView.mockReturnValue(\{
			      ref: () => \{\},
			      inView: false,
			      supported: true,
			    \});
			
			    const props = \{
			      title: "Iframe title",
			      src: "https://iframe-src.com/iframe",
			      className: "fake-class-name",
			      height: 300,
			    \};
			
			    const result = TestRenderer.create(
			      <Provider value=\{store\}>
			        <Iframe \{...props\} />
			      </Provider>
			    );
			    expect(result.toJSON()).toMatchSnapshot();
			  \});
			
			  test("works without \`IntersectionObserver\` and component did mount", () => \{
			    const store = createStore(\{
			      state: \{
			        frontity: \{ rendering: "csr" \},
			      \},
			    \});
			
			    const props = \{
			      title: "Iframe title",
			      src: "https://iframe-src.com/iframe",
			      className: "fake-class-name",
			      loading: "lazy" as const,
			      height: 300,
			    \};
			
			    mockedUseInView.mockReturnValue(\{
			      ref: undefined,
			      inView: true,
			      supported: false,
			    \});
			
			    const iframe = TestRenderer.create(
			      <Provider value=\{store\}>
			        <Iframe \{...props\} />
			      </Provider>
			    ).toJSON();
			    expect(iframe).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\__tests__\\iframe.jsdom.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\packages\\components\\__tests__\\iframe.node.tests.tsx', () => {
        const sourceCode = `
			/**
			 * @jest-environment node
			 */
			
			import TestRenderer from "react-test-renderer";
			import \{ HelmetProvider \} from "frontity";
			import \{ FilledContext \} from "react-helmet-async";
			import Iframe from "../iframe";
			
			describe("Iframe", () => \{
			  test('It\\'s a normal iframe if loading === "eager"', () => \{
			    const loading: "lazy" | "eager" = "eager";
			    const props = \{
			      title: "Some fake title",
			      src: "https://fake-src.com",
			      className: "fake-class-name",
			      loading,
			    \};
			
			    const iframe = TestRenderer.create(<Iframe \{...props\} />).toJSON();
			    expect(iframe).toMatchSnapshot();
			  \});
			
			  test("works on server (without height)", () => \{
			    const props = \{
			      title: "Some fake title",
			      src: "https://frontity.com",
			      className: "fake-class-name",
			    \};
			
			    const helmetContext = \{\} as FilledContext;
			    const iframe = TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <Iframe \{...props\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = helmetContext.helmet;
			
			    expect(iframe).toMatchSnapshot();
			    expect(head.script.toString()).toMatchSnapshot();
			    expect(head.noscript.toString()).toMatchSnapshot();
			  \});
			
			  test("works on server (with height)", () => \{
			    const props = \{
			      title: "Some fake alt text",
			      src: "https://fake-src.com",
			      className: "fake-class-name",
			      height: 300,
			    \};
			
			    const helmetContext = \{\} as FilledContext;
			    const iframe = TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <Iframe \{...props\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = helmetContext.helmet;
			
			    expect(iframe).toMatchSnapshot();
			    expect(head.script.toString()).toMatchSnapshot();
			    expect(head.noscript.toString()).toMatchSnapshot();
			  \});
			
			  test("props are preserved", () => \{
			    const props = \{
			      title: "Some fake alt text",
			      src: "https://fake-src.com",
			      className: "fake-class-name",
			      height: 300,
			      id: "iframe-id",
			    \};
			
			    const helmetContext = \{\} as FilledContext;
			    const iframe = TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <Iframe \{...props\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = helmetContext.helmet;
			
			    expect(iframe).toMatchSnapshot();
			    expect(head.script.toString()).toMatchSnapshot();
			    expect(head.noscript.toString()).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\__tests__\\iframe.node.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\components\\__tests__\\image.jsdom.tests.tsx', () => {
        const sourceCode = `
			/* eslint-disable @typescript-eslint/ban-ts-comment */
			/* eslint-disable @typescript-eslint/no-empty-function */
			/* eslint-disable no-global-assign */
			
			/**
			 * @jest-environment jsdom
			 */
			
			import TestRenderer from "react-test-renderer";
			import Image from "../image";
			
			jest.mock("@frontity/hooks/use-in-view", () => (\{
			  __esModule: true,
			  default: jest.fn(),
			\}));
			
			// Mock only useConnect in the 'frontity' module
			jest.mock("frontity", () => (\{
			  // @ts-ignore
			  ...jest.requireActual("frontity"),
			  useConnect: () => (\{
			    state: \{
			      frontity: \{
			        mode: "html",
			      \},
			    \},
			  \}),
			\}));
			
			describe("Image", () => \{
			  test('works when loading === "eager"', () => \{
			    const props: React.ImgHTMLAttributes<HTMLImageElement> = \{
			      alt: "Some fake alt text",
			      src: "https://fake-src.com/fake-image.jpg",
			      srcSet:
			        "https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w",
			      className: "fake-class-name",
			      loading: "eager",
			    \};
			
			    const result = TestRenderer.create(<Image \{...props\} />).toJSON();
			    expect(result).toMatchInlineSnapshot(\`
			      <img
			        alt="Some fake alt text"
			        className="frontity-lazy-image fake-class-name"
			        loading="eager"
			        src="https://fake-src.com/fake-image.jpg"
			        srcSet="https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w"
			      />
			    \`);
			  \});
			
			  test('works when loading === "lazy"', () => \{
			    const props: React.ImgHTMLAttributes<HTMLImageElement> = \{
			      alt: "Some fake alt text",
			      src: "https://fake-src.com/fake-image.jpg",
			      srcSet:
			        "https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w",
			      className: "fake-class-name",
			      loading: "lazy",
			    \};
			
			    const result = TestRenderer.create(<Image \{...props\} />);
			    expect(result.toJSON()).toMatchInlineSnapshot(\`
			      <img
			        alt="Some fake alt text"
			        className="frontity-lazy-image fake-class-name"
			        loading="lazy"
			        src="https://fake-src.com/fake-image.jpg"
			        srcSet="https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w"
			      />
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\__tests__\\image.jsdom.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\components\\__tests__\\image.node.tests.tsx', () => {
        const sourceCode = `
			/* eslint-disable @typescript-eslint/ban-ts-comment */
			
			/**
			 * @jest-environment node
			 */
			
			import TestRenderer from "react-test-renderer";
			import Image from "../image";
			
			// Mock only useConnect in the 'frontity' module
			jest.mock("frontity", () => (\{
			  // @ts-ignore
			  ...jest.requireActual("frontity"),
			  useConnect: () => (\{
			    state: \{
			      frontity: \{
			        mode: "html",
			      \},
			    \},
			  \}),
			\}));
			
			describe("Image", () => \{
			  test('It\\'s a normal image if loading === "eager"', () => \{
			    const loading: "lazy" | "eager" = "eager";
			    const props = \{
			      alt: "Some fake alt text",
			      src: "https://fake-src.com/fake-image.jpg",
			      srcSet:
			        "https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w",
			      className: "fake-class-name",
			      loading,
			    \};
			
			    const image = TestRenderer.create(<Image \{...props\} />).toJSON();
			    expect(image).toMatchInlineSnapshot(\`
			      <img
			        alt="Some fake alt text"
			        className="frontity-lazy-image fake-class-name"
			        loading="eager"
			        src="https://fake-src.com/fake-image.jpg"
			        srcSet="https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w"
			      />
			    \`);
			  \});
			
			  test("works on server (without height)", () => \{
			    const props = \{
			      alt: "Some fake alt text",
			      src: "https://fake-src.com/fake-image.jpg",
			      srcSet:
			        "https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w",
			      className: "fake-class-name",
			    \};
			
			    const image = TestRenderer.create(<Image \{...props\} />).toJSON();
			    expect(image).toMatchInlineSnapshot(\`
			      <img
			        alt="Some fake alt text"
			        className="frontity-lazy-image fake-class-name"
			        loading="lazy"
			        src="https://fake-src.com/fake-image.jpg"
			        srcSet="https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w"
			      />
			    \`);
			  \});
			
			  test("works on server (with height)", () => \{
			    const props = \{
			      alt: "Some fake alt text",
			      src: "https://fake-src.com/fake-image.jpg",
			      srcSet:
			        "https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w",
			      className: "fake-class-name",
			      height: 300,
			    \};
			
			    const image = TestRenderer.create(<Image \{...props\} />).toJSON();
			    expect(image).toMatchInlineSnapshot(\`
			      <img
			        alt="Some fake alt text"
			        className="frontity-lazy-image fake-class-name"
			        height=\{300\}
			        loading="lazy"
			        src="https://fake-src.com/fake-image.jpg"
			        srcSet="https://fake-src.com/fake-image.jpg?w=300 300w, https://fake-src.com/fake-image.jpg?w=150 150w"
			      />
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\__tests__\\image.node.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\packages\\components\\__tests__\\script.tests.tsx', () => {
        const sourceCode = `
			import \{ act, create \} from "react-test-renderer";
			import Script from "../script";
			
			describe("Script", () => \{
			  test("should not render a script tag without code or src", () => \{
			    let root;
			    act(() => \{
			      root = create(<Script id="script-1">\{"let index = 0;"\}</Script>);
			    \});
			
			    // This is here to make sure the virtual dom tree does not return anything.
			    expect(root.toJSON()).toMatchInlineSnapshot(\`null\`);
			    expect(document.body.querySelector("#script-1")).toBeNull();
			  \});
			
			  test("should render a script tag with src", () => \{
			    act(() => \{
			      create(<Script id="script-2" src="source" />);
			    \});
			
			    expect(document.body.querySelector("#script-2")).toMatchInlineSnapshot(\`
			      <script
			        id="script-2"
			        src="source"
			      />
			    \`);
			  \});
			
			  test("should not render the passed children with src", () => \{
			    act(() => \{
			      create(
			        <Script
			          id="script-3"
			          src="source-with-children"
			        >\{\`let children = null;\`\}</Script>
			      );
			    \});
			
			    expect(document.body.querySelector("#script-3")).toMatchInlineSnapshot(\`
			      <script
			        id="script-3"
			        src="source-with-children"
			      />
			    \`);
			  \});
			
			  test("should execute the code", () => \{
			    act(() => \{
			      create(<Script id="script-4" code="global.__i__ = Infinity;" />);
			    \});
			
			    expect(document.body.querySelector("#script-4")).toBeNull();
			    expect(global["__i__"]).toEqual(Infinity);
			  \});
			
			  test("should remove the script tag at unmount", () => \{
			    let root;
			    act(() => \{
			      root = create(<Script id="script-5" src="source-for-unmount" />);
			    \});
			
			    expect(document.body.querySelector("#script-5")).toMatchInlineSnapshot(\`
			      <script
			        id="script-5"
			        src="source-for-unmount"
			      />
			    \`);
			
			    act(() => \{
			      root.unmount();
			    \});
			
			    expect(document.body.querySelector("#script-5")).toBeNull();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\__tests__\\script.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\components\\__tests__\\switch.tests.tsx', () => {
        const sourceCode = `
			import * as React from "react";
			import \{ create \} from "react-test-renderer";
			import Switch from "../switch";
			
			// Test components
			const TestArchive: React.FC<\{ when?: boolean; someProp?: string \}> = () => \{
			  return <h1>Test Archive Component</h1>;
			\};
			
			const TestBlog: React.FC<\{ when?: boolean \}> = () => \{
			  return <h1>Test Blog Component</h1>;
			\};
			
			// Default test component
			const Default: React.FC<\{ someProp?: string \}> = () => \{
			  return <h1>Default Component</h1>;
			\};
			
			describe("Switch", () => \{
			  test("should render the default component if no match was found", () => \{
			    const SwitchComponent = create(
			      <Switch>
			        <TestArchive when=\{"archive" !== "archive"\} />
			        <TestBlog when=\{"blog" !== "blog"\} />
			        <Default />
			      </Switch>
			    );
			
			    expect(SwitchComponent.toJSON()).toMatchSnapshot();
			  \});
			
			  test("should render the first component that match", () => \{
			    const SwitchComponent = create(
			      <Switch>
			        <TestArchive when=\{"archive" === "archive"\} />
			        <TestBlog when=\{"blog" === "blog"\} />
			        <Default />
			      </Switch>
			    );
			
			    expect(SwitchComponent.toJSON()).toMatchSnapshot();
			  \});
			
			  test("should return null if no component match", () => \{
			    const SwitchComponent = create(
			      <Switch>
			        <TestArchive when=\{"archive" !== "archive"\} />
			        <TestBlog when=\{"blog" !== "blog"\} />
			      </Switch>
			    );
			
			    expect(SwitchComponent.toJSON()).toMatchSnapshot();
			  \});
			
			  test("should pass down any prop that the matching component receives", () => \{
			    const SwitchComponent = create(
			      <Switch>
			        <TestArchive when=\{true\} someProp="prop value" />
			      </Switch>
			    );
			
			    expect(SwitchComponent.root.findByType(TestArchive).props).toEqual(\{
			      someProp: "prop value",
			    \});
			  \});
			
			  test("should pass down any prop of the default component", () => \{
			    const SwitchComponent = create(
			      <Switch>
			        <Default someProp="prop value" />
			      </Switch>
			    );
			
			    expect(SwitchComponent.root.findByType(Default).props).toEqual(\{
			      someProp: "prop value",
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\components\\__tests__\\switch.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\comscore-analytics\\src\\components\\__tests__\\index.test.tsx', () => {
        const sourceCode = `
			/**
			 * @jest-environment node
			 */
			
			import TestRenderer from "react-test-renderer";
			import \{ HelmetProvider \} from "frontity";
			import \{ State \} from "frontity/types";
			import \{ FilledContext \} from "react-helmet-async";
			import \{ Root as ComscoreAnalytics \} from "..";
			import \{ Packages \} from "../../../types";
			
			const getState = (): State<Packages> => (\{
			  frontity: \{\},
			  analytics: \{
			    pageviews: \{ comscoreAnalytics: true \},
			    events: \{\},
			  \},
			  comscoreAnalytics: \{\},
			\});
			
			describe("Comscore Analytics Component", () => \{
			  test("should render script for all tracking IDs", () => \{
			    const state = getState();
			
			    state.comscoreAnalytics.trackingIds = ["111111", "222222"];
			
			    const helmetContext = \{\};
			    TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <ComscoreAnalytics state=\{state\} actions=\{null\} libraries=\{null\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = (helmetContext as FilledContext).helmet;
			
			    expect(head.script.toComponent()).toMatchSnapshot();
			    expect(head.noscript.toComponent()).toMatchSnapshot();
			  \});
			
			  test("should render a script for a single tracking ID", () => \{
			    const state = getState();
			
			    state.comscoreAnalytics.trackingId = "333333";
			
			    const helmetContext = \{\};
			    TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <ComscoreAnalytics state=\{state\} actions=\{null\} libraries=\{null\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = (helmetContext as FilledContext).helmet;
			
			    expect(head.script.toComponent()).toMatchSnapshot();
			    expect(head.noscript.toComponent()).toMatchSnapshot();
			  \});
			
			  test("should not render if no tracking IDs are specified", () => \{
			    const state = getState();
			
			    const helmetContext = \{\};
			    TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <ComscoreAnalytics state=\{state\} actions=\{null\} libraries=\{null\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = (helmetContext as FilledContext).helmet;
			
			    expect(head.script.toComponent()).toMatchSnapshot();
			    expect(head.noscript.toComponent()).toMatchSnapshot();
			  \});
			\});
			
			describe("Comscore Analytics Component (AMP)", () => \{
			  test("should render script for all tracking IDs", () => \{
			    const state = getState();
			    state.frontity.mode = "amp";
			    state.comscoreAnalytics.trackingIds = ["111111", "222222"];
			
			    const helmetContext = \{\};
			    const app = TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <ComscoreAnalytics state=\{state\} actions=\{null\} libraries=\{null\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = (helmetContext as FilledContext).helmet;
			
			    expect(head.script.toComponent()).toMatchSnapshot();
			    expect(app).toMatchSnapshot();
			  \});
			
			  test("should render a script for a single tracking ID", () => \{
			    const state = getState();
			    state.frontity.mode = "amp";
			    state.comscoreAnalytics.trackingId = "333333";
			
			    const helmetContext = \{\};
			    const app = TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <ComscoreAnalytics state=\{state\} actions=\{null\} libraries=\{null\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = (helmetContext as FilledContext).helmet;
			
			    expect(head.script.toComponent()).toMatchSnapshot();
			    expect(app).toMatchSnapshot();
			  \});
			
			  test("should not render if no tracking IDs are specified", () => \{
			    const state = getState();
			    state.frontity.mode = "amp";
			
			    const helmetContext = \{\};
			    const app = TestRenderer.create(
			      <HelmetProvider context=\{helmetContext\}>
			        <ComscoreAnalytics state=\{state\} actions=\{null\} libraries=\{null\} />
			      </HelmetProvider>
			    ).toJSON();
			    const head = (helmetContext as FilledContext).helmet;
			
			    expect(head.script.toComponent()).toMatchSnapshot();
			    expect(app).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\comscore-analytics\\src\\components\\__tests__\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\packages\\connect\\src\\__tests__\\connect.tests.js', () => {
        const sourceCode = `
			import \{ Component \} from "react";
			import \{ create, act \} from "react-test-renderer";
			import * as error from "@frontity/error";
			import connect, \{ Provider, createStore, useConnect \} from "..";
			
			let store;
			
			const Comp = () => <div>component from library</div>;
			
			beforeEach(() => \{
			  store = createStore(\{
			    state: \{
			      prop1: 1,
			      prop2: (\{ state \}) => state.prop1 + 1,
			      prop3: (\{ state \}) => (num) => state.prop1 + num,
			    \},
			    actions: \{
			      action1: (\{ state \}) => \{
			        state.prop1 = 2;
			      \},
			      action2: (\{ state \}) => (num) => \{
			        state.prop1 = num;
			      \},
			    \},
			    libraries: \{
			      Comp,
			    \},
			  \});
			\});
			
			describe("connect", () => \{
			  it("should pass state to functional components", () => \{
			    const Comp = (\{ state \}) => <div>\{state.prop1\}</div>;
			    const Connected = connect(Comp);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should allow to pass state directly without Provider", () => \{
			    const Comp = (\{ state \}) => <div>\{state.namespace.prop1\}</div>;
			    const Connected = connect(Comp);
			    const props = \{ state: \{ namespace: \{ prop1: "1" \} \} \};
			    const app = create(<Connected \{...props\} />);
			    expect(app).toMatchInlineSnapshot(\`
			      <div>
			        1
			      </div>
			    \`);
			  \});
			
			  it("should pass state to class components", () => \{
			    class Comp extends Component \{
			      render() \{
			        return <div>\{this.props.state.prop1\}</div>;
			      \}
			    \}
			    const Connected = connect(Comp);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass derived state", () => \{
			    const Comp = (\{ state \}) => <div>\{state.prop2\}</div>;
			    const Connected = connect(Comp);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass derived state functions", () => \{
			    const Comp = (\{ state \}) => <div>\{state.prop3(2)\}</div>;
			    const Connected = connect(Comp);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass actions and react to changes", () => \{
			    const Comp1 = (\{ actions \}) => (
			      <button onClick=\{actions.action1\}>change prop1</button>
			    );
			    const Comp2 = (\{ state \}) => <div>\{state.prop1\}</div>;
			    const Connected1 = connect(Comp1);
			    const Connected2 = connect(Comp2);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected1 />
			        <Connected2 />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			    const rootInstance = app.root;
			    const button = rootInstance.findByType("button");
			    act(() => button.props.onClick());
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass actions and react to derived changes", () => \{
			    const Comp1 = (\{ actions \}) => (
			      <button onClick=\{actions.action1\}>change prop1</button>
			    );
			    const Comp2 = (\{ state \}) => <div>\{state.prop2\}</div>;
			    const Connected1 = connect(Comp1);
			    const Connected2 = connect(Comp2);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected1 />
			        <Connected2 />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			    const rootInstance = app.root;
			    const button = rootInstance.findByType("button");
			    act(() => button.props.onClick());
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass actions with params and react to changes", () => \{
			    const Comp1 = (\{ actions \}) => (
			      <button onClick=\{() => actions.action2(4)\}>change prop1</button>
			    );
			    const Comp2 = (\{ state \}) => <div>\{state.prop1\}</div>;
			    const Connected1 = connect(Comp1);
			    const Connected2 = connect(Comp2);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected1 />
			        <Connected2 />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			    const rootInstance = app.root;
			    const button = rootInstance.findByType("button");
			    act(() => button.props.onClick());
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass other props passed to store", () => \{
			    const Comp = (\{ libraries \}) => \{
			      const Comp = libraries.Comp;
			      return (
			        <div>
			          <Comp />
			        </div>
			      );
			    \};
			    const Connected = connect(Comp);
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should not inject props if \`injectProps\` option is \`false\`", () => \{
			    const Comp = (\{ state, actions, libraries \}) => \{
			      const hasState = (!!state).toString();
			      const hasActions = (!!actions).toString();
			      const hasLibraries = (!!libraries).toString();
			
			      return (
			        <>
			          <div>hasState: \{hasState\}</div>
			          <div>hasActions: \{hasActions\}</div>
			          <div>hasLibraries: \{hasLibraries\}</div>
			        </>
			      );
			    \};
			    const Connected = connect(Comp, \{ injectProps: false \});
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should inject props if \`options\` object is empty", () => \{
			    const Comp = (\{ state, actions, libraries \}) => \{
			      const hasState = (!!state).toString();
			      const hasActions = (!!actions).toString();
			      const hasLibraries = (!!libraries).toString();
			
			      return (
			        <>
			          <div>hasState: \{hasState\}</div>
			          <div>hasActions: \{hasActions\}</div>
			          <div>hasLibraries: \{hasLibraries\}</div>
			        </>
			      );
			    \};
			    const Connected = connect(Comp, \{\});
			    const app = create(
			      <Provider value=\{store\}>
			        <Connected />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			\});
			
			describe("useConnect", () => \{
			  it("should pass state, derived state and derived state functions", () => \{
			    const Comp = connect(() => \{
			      const \{ state \} = useConnect();
			      return (
			        <>
			          <div>\{state.prop1\}</div>
			          <div>\{state.prop2\}</div>
			          <div>\{state.prop3(2)\}</div>
			        </>
			      );
			    \});
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass actions and actions with params", () => \{
			    const Comp = connect(() => \{
			      const \{ state, actions \} = useConnect();
			      return (
			        <>
			          <button id="no-params" onClick=\{() => actions.action1()\}>
			            change prop1
			          </button>
			          <button id="with-params" onClick=\{() => actions.action2(3)\}>
			            change prop1 with params
			          </button>
			          <div>\{state.prop1\}</div>
			        </>
			      );
			    \});
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			    const rootInstance = app.root;
			    const button1 = rootInstance.findByProps(\{ id: "no-params" \});
			    act(() => button1.props.onClick());
			    expect(app).toMatchSnapshot();
			    const button2 = rootInstance.findByProps(\{ id: "with-params" \});
			    act(() => button2.props.onClick());
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should pass libraries", () => \{
			    const Comp = connect(() => \{
			      const \{ libraries \} = useConnect();
			      return <libraries.Comp />;
			    \});
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			    expect(app).toMatchSnapshot();
			  \});
			
			  it("should log a warning if the component is not connected", () => \{
			    // eslint-disable-next-line no-import-assign
			    error.warn = jest.fn();
			
			    const Comp = () => \{
			      const \{ state \} = useConnect();
			      return <div>\{state.prop1\}</div>;
			    \};
			    const ConnectedComp = connect(Comp);
			
			    act(() => \{
			      create(
			        <Provider value=\{store\}>
			          <Comp />
			          <ConnectedComp />
			        </Provider>
			      );
			    \});
			
			    expect(error.warn).toHaveBeenCalledTimes(1);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\connect\\src\\__tests__\\connect.tests.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(15)
    });
    it('frontity_frontity\\packages\\connect\\src\\__tests__\\create-store.tests.js', () => {
        const sourceCode = `
			import \{ createStore, isObservable, getSnapshot \} from "..";
			
			let config = \{\};
			let store = null;
			
			const delay = () => new Promise((resolve) => setTimeout(resolve, 100));
			
			beforeEach(() => \{
			  config = \{
			    state: \{
			      prop1: 1,
			      nested1: \{
			        prop2: 2,
			        prop3: (\{ state \}) => state.prop1 + state.nested1.prop2,
			        prop4: (\{ state \}) => (num) => state.nested1.prop3 + num,
			        prop5: 0,
			        prop6: (\{ state, libraries \}) => \{
			          const \{ prop3, prop4 \} = state.nested1;
			          return libraries.nested1.sum(prop3, prop4(0));
			        \},
			      \},
			    \},
			    actions: \{
			      action1: (\{ state \}) => \{
			        state.prop1 = "action1";
			      \},
			      nested1: \{
			        action2: (\{ state \}) => \{
			          state.prop1 = "action2";
			          return state.prop1;
			        \},
			      \},
			      nested2: \{
			        nested3: \{
			          action3: (\{ state \}) => \{
			            state.nested1.prop5 = state.nested1.prop3;
			          \},
			          action4: (\{ state \}) => \{
			            state.nested1.prop5 = state.nested1.prop4(2);
			          \},
			          action5: (\{ state \}) => (num) => \{
			            state.nested1.prop5 = state.nested1.prop4(num);
			          \},
			        \},
			      \},
			      action6: async (\{ state \}) => \{
			        await delay();
			        state.prop1 = "action6";
			        return state.prop1;
			      \},
			      action7: (\{ state \}) => async (num) => \{
			        await delay();
			        state.prop1 = num;
			      \},
			      action8: (\{ actions \}) => \{
			        actions.action1();
			      \},
			      action9: async (\{ state, actions \}) => \{
			        const prop1 = state.prop1;
			        await actions.action7(3);
			        state.prop1 = \`\$\{state.prop1\} \$\{prop1\}\`;
			      \},
			      action10: () => \{
			        throw new Error("action10 error");
			      \},
			      action11: async () => \{
			        throw new Error("action11 error");
			      \},
			    \},
			    libraries: \{
			      nested1: \{
			        sum: (...args) => args.reduce((a, b) => a + b, 0),
			      \},
			    \},
			  \};
			
			  store = createStore(config);
			\});
			
			describe("createStore", () => \{
			  it("should return state and actions", () => \{
			    expect(store.state.prop1).toBe(1);
			    expect(typeof store.actions.action1).toBe("function");
			    expect(typeof store.actions.nested1.action2).toBe("function");
			    expect(typeof store.actions.nested2.nested3.action3).toBe("function");
			  \});
			
			  it("should return observable state", () => \{
			    expect(isObservable(store.state)).toBe(true);
			  \});
			
			  it("should return unobservable actions", () => \{
			    expect(isObservable(store.actions)).toBe(false);
			  \});
			
			  it("should include arbitrary properties", () => \{
			    store = createStore(\{ ...config, something: "else" \});
			    expect(store.something).toBe("else");
			  \});
			
			  it("should create two different stores", () => \{
			    const store1 = createStore(\{
			      state: \{ prop1: 1, prop2: (\{ state \}) => state.prop1 * 2 \},
			    \});
			    const store2 = createStore(\{
			      state: \{ prop1: 2, prop2: (\{ state \}) => state.prop1 * 2 \},
			    \});
			    expect(store1.state.prop2).toBe(2);
			    expect(store2.state.prop2).toBe(4);
			  \});
			
			  it("should inject \`libraries\` to derived properties", () => \{
			    expect(store.state.nested1.prop6).toBe(6);
			  \});
			\});
			
			describe("createStore actions", () => \{
			  it("should be able to mutate state", () => \{
			    store.actions.action1();
			    expect(store.state.prop1).toBe("action1");
			  \});
			
			  it("should be able to access derived state", () => \{
			    store.actions.nested2.nested3.action3();
			    expect(store.state.nested1.prop5).toBe(3);
			  \});
			
			  it("should be able to access derived state functions", () => \{
			    store.actions.nested2.nested3.action4();
			    expect(store.state.nested1.prop5).toBe(5);
			  \});
			
			  it("should accept parameters", async () => \{
			    store.actions.nested2.nested3.action5(3);
			    expect(store.state.nested1.prop5).toBe(6);
			  \});
			
			  it("should return a promise that can be awaited", () => \{
			    const store = createStore(config);
			    return store.actions.action6().then(() => \{
			      expect(store.state.prop1).toBe("action6");
			    \});
			  \});
			
			  it("should return a promise that can be awaited even with params", () => \{
			    const store = createStore(config);
			    return store.actions.action7(7).then(() => \{
			      expect(store.state.prop1).toBe(7);
			    \});
			  \});
			
			  it("should run other actions", () => \{
			    store.actions.action8();
			    expect(store.state.prop1).toBe("action1");
			  \});
			
			  it("should be able to wait for other actions", async () => \{
			    await store.actions.action9();
			    expect(store.state.prop1).toBe("3 1");
			  \});
			
			  it("should not return anything", () => \{
			    expect(store.actions.nested1.action2()).toBe(undefined);
			  \});
			
			  it("should not return anything even with promises", async () => \{
			    const res = await store.actions.action6();
			    expect(res).toBe(undefined);
			  \});
			
			  it("should catch an error thrown inside of an action", () => \{
			    const store = createStore(config);
			    let error = \{\};
			
			    try \{
			      store.actions.action10();
			      throw new Error("This line should never be reached");
			    \} catch (e) \{
			      error = e;
			    \}
			
			    expect(error.message).toBe("action10 error");
			  \});
			
			  it("should catch an error thrown inside of an async action", async () => \{
			    const store = createStore(config);
			    let error = \{\};
			
			    try \{
			      await store.actions.action11();
			      throw new Error("This line should never be reached");
			    \} catch (e) \{
			      error = e;
			    \}
			
			    expect(error.message).toBe("action11 error");
			  \});
			\});
			
			describe("createStore getSnapshot", () => \{
			  it("should be able retrieve a serializable snapshot", () => \{
			    expect(getSnapshot(store.state)).toMatchSnapshot();
			    store.actions.nested2.nested3.action5(3);
			    expect(getSnapshot(store.state)).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\connect\\src\\__tests__\\create-store.tests.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(19)
    });
    it('frontity_frontity\\packages\\connect\\src\\__tests__\\types.tests.tsx', () => {
        const sourceCode = `
			import connect, \{ useConnect, createStore \} from "..";
			import \{
			  Action,
			  AsyncAction,
			  Derived,
			  Connect,
			  Package,
			\} from "@frontity/types";
			
			const delay = () => new Promise((resolve) => setTimeout(resolve, 100));
			
			interface Config extends Package \{
			  state: \{
			    namespace1: \{
			      prop1: number;
			      prop2: number;
			      prop3: Derived<Config, number>;
			      prop4: Derived<Config, number, number>;
			      prop5: number;
			    \};
			  \};
			  actions: \{
			    namespace1: \{
			      action1: Action<Config>;
			      action2: Action<Config>;
			    \};
			    namespace2: \{
			      action3: Action<Config>;
			      action4: Action<Config>;
			      action5: Action<Config, number>;
			      action6: AsyncAction<Config>;
			      action7: AsyncAction<Config, number>;
			    \};
			  \};
			  libraries?: \{
			    namespace1: \{
			      prop6: number;
			    \};
			  \};
			\}
			
			const config: Config = \{
			  state: \{
			    namespace1: \{
			      prop1: 1,
			      prop2: 2,
			      prop3: (\{ state \}) => state.namespace1.prop1 + state.namespace1.prop2,
			      prop4: (\{ state \}) => (num) => state.namespace1.prop3 + num,
			      prop5: 5,
			    \},
			  \},
			  actions: \{
			    namespace1: \{
			      action1: (\{ state \}) => \{
			        state.namespace1.prop1 = 11;
			      \},
			      action2: (\{ state \}) => \{
			        state.namespace1.prop1 = 12;
			      \},
			    \},
			    namespace2: \{
			      action3: (\{ state, actions \}) => \{
			        actions.namespace1.action1();
			        actions.namespace2.action5(1);
			        state.namespace1.prop5 = state.namespace1.prop3;
			      \},
			      action4: (\{ state \}) => \{
			        state.namespace1.prop5 = state.namespace1.prop4(4);
			      \},
			      action5: (\{ state \}) => (num) => \{
			        state.namespace1.prop5 = state.namespace1.prop4(num);
			      \},
			      action6: async (\{ state \}) => \{
			        await delay();
			        state.namespace1.prop1 = 6;
			      \},
			      action7: (\{ state, libraries \}) => async (num) => \{
			        await delay();
			        state.namespace1.prop1 = num;
			        const n: number = libraries.namespace1.prop6;
			      \},
			    \},
			  \},
			  libraries: \{
			    namespace1: \{
			      prop6: 6,
			    \},
			  \},
			\};
			
			test("After creating a store all derived state and actions are fine", () => \{
			  const store = createStore(config);
			
			  const prop1: number = store.state.namespace1.prop1;
			  const prop2: number = store.state.namespace1.prop2;
			  const prop3: number = store.state.namespace1.prop3;
			  const prop4: number = store.state.namespace1.prop4(1);
			  const prop5: number = store.state.namespace1.prop5;
			  const prop6: number = store.libraries.namespace1.prop6;
			
			  store.actions.namespace1.action1();
			  store.actions.namespace1.action2();
			  store.actions.namespace2.action3();
			  store.actions.namespace2.action4();
			  store.actions.namespace2.action5(1);
			
			  const asyncFn = async () => \{
			    await store.actions.namespace2.action6();
			    await store.actions.namespace2.action7(7);
			  \};
			\});
			
			type Props = Connect<
			  Config,
			  \{
			    ownProp1: number;
			    optionalProp2?: string;
			  \}
			>;
			
			let Component: (props: Props) => JSX.Element;
			
			test("Injected state and actions are fine", () => \{
			  // eslint-disable-next-line react/display-name
			  Component = (\{ state, actions, libraries, ownProp1, optionalProp2 \}) => \{
			    const prop1: number = state.namespace1.prop1;
			    const prop2: number = state.namespace1.prop2;
			    const prop3: number = state.namespace1.prop3;
			    const prop4: number = state.namespace1.prop4(1);
			    const prop5: number = state.namespace1.prop5;
			    const prop6: number = libraries.namespace1.prop6;
			
			    actions.namespace1.action1();
			    actions.namespace1.action2();
			    actions.namespace2.action3();
			    actions.namespace2.action4();
			    actions.namespace2.action5(1);
			
			    const ownProp1Const: number = ownProp1;
			    const ownProp2Const: string = optionalProp2;
			
			    return <div>My connected component</div>;
			  \};
			\});
			
			test("Connected components only require own props", () => \{
			  const ConnectedComponent = connect(Component);
			  () => <ConnectedComponent ownProp1=\{1\} />;
			\});
			
			test("connect can receive \`inpectProps\` option", () => \{
			  connect(Component, \{ injectProps: false \});
			\});
			
			test("useConnect returns the proper types", () => \{
			  const Component = () => \{
			    const \{ state, actions, libraries \} = useConnect<Config>();
			
			    const prop1: number = state.namespace1.prop1;
			    const prop2: number = state.namespace1.prop2;
			    const prop3: number = state.namespace1.prop3;
			    const prop4: number = state.namespace1.prop4(1);
			    const prop5: number = state.namespace1.prop5;
			    const prop6: number = libraries.namespace1.prop6;
			
			    actions.namespace1.action1();
			    actions.namespace1.action2();
			    actions.namespace2.action3();
			    actions.namespace2.action4();
			    actions.namespace2.action5(1);
			
			    return <div>My useConnect component</div>;
			  \};
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\connect\\src\\__tests__\\types.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\core\\src\\config\\babel\\__tests__\\index.tests.ts', () => {
        const sourceCode = `
			import getBabel from "..";
			
			test("Babel returns for development", () => \{
			  expect(getBabel()).toMatchSnapshot();
			\});
			
			test("Babel returns for production", () => \{
			  expect(getBabel()).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\config\\babel\\__tests__\\index.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\core\\src\\config\\webpack\\__tests__\\index.tests.ts', () => {
        const sourceCode = `
			import * as hash from "hash-it";
			import * as path from "path";
			import getWebpack from "..";
			
			jest.mock("path");
			const mockedPath = path as jest.Mocked<typeof path>;
			mockedPath.resolve.mockImplementation((_, ...dirs) => dirs.join("/"));
			
			jest.mock("hash-it");
			const mockedHash = hash as jest.Mocked<typeof hash>;
			mockedHash.default.mockReturnValue("123");
			
			const babel = \{
			  development: \{
			    es5: \{ presets: ["es5-development"], plugins: [] \},
			    module: \{ presets: ["module-development"], plugins: [] \},
			    server: \{ presets: ["server-development"], plugins: [] \},
			  \},
			  production: \{
			    es5: \{ presets: ["es5-production"], plugins: [] \},
			    module: \{ presets: ["module-production"], plugins: [] \},
			    server: \{ presets: ["server-production"], plugins: [] \},
			  \},
			\};
			
			const frontity = \{
			  outDir: "build",
			\};
			
			const entryPoints = [
			  \{
			    name: "server",
			    path: "./build/bundling/entry-points/server.js",
			  \},
			  \{
			    name: "site-1",
			    path: "./build/bundling/entry-points/site-1/client.js",
			  \},
			  \{
			    name: "site-2",
			    path: "./build/bundling/entry-points/site-1/client.js",
			  \},
			];
			
			test("Webpack returns for development", () => \{
			  expect(
			    getWebpack(\{
			      mode: "development",
			      babel: babel["development"],
			      frontity,
			      entryPoints,
			    \})
			  ).toMatchSnapshot();
			\});
			
			test("Webpack returns for production", () => \{
			  expect(
			    getWebpack(\{
			      mode: "production",
			      babel: babel["production"],
			      frontity,
			      entryPoints,
			    \})
			  ).toMatchSnapshot();
			\});
			
			test("Webpack includes the Bundle Analyzer plugin if specified", () => \{
			  const \{ es5, module, server \} = getWebpack(\{
			    mode: "production",
			    babel: babel["production"],
			    frontity,
			    entryPoints,
			    analyze: true,
			  \});
			
			  expect(es5.plugins).toMatchSnapshot();
			  expect(module.plugins).toMatchSnapshot();
			  expect(server.plugins).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\config\\webpack\\__tests__\\index.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\packages\\core\\src\\config\\webpack\\__tests__\\modules.tests.ts', () => {
        const sourceCode = `
			import \{ exclude \} from "../modules";
			
			describe("Transpilation excludes", () => \{
			  it("should exclude webpack from transpilation", () => \{
			    const paths = [
			      "../webpack",
			      "node_modules/webpack",
			      "node_modules/webpack/",
			      "node_modules/webpack/internal.js",
			    ];
			    for (const path of paths) \{
			      expect(exclude.some((regex) => regex.exec(path))).toBe(true);
			      expect(
			        exclude.some((regex) => regex.exec(path.replace(/\\//g, "\\\\")))
			      ).toBe(true);
			    \}
			  \});
			
			  it("should exclude core-js from transpilation", () => \{
			    const paths = [
			      "../core-js",
			      "node_modules/core-js",
			      "node_modules/core-js/",
			      "node_modules/core-js/internal.js",
			    ];
			    for (const path of paths) \{
			      expect(exclude.some((regex) => regex.exec(path))).toBe(true);
			      expect(
			        exclude.some((regex) => regex.exec(path.replace(/\\//g, "\\\\")))
			      ).toBe(true);
			    \}
			  \});
			
			  it("should exclude regenerator-runtime from transpilation", () => \{
			    const paths = [
			      "../regenerator-runtime",
			      "node_modules/regenerator-runtime",
			      "node_modules/regenerator-runtime/",
			      "node_modules/regenerator-runtime/internal.js",
			    ];
			    for (const path of paths) \{
			      expect(exclude.some((regex) => regex.exec(path))).toBe(true);
			      expect(
			        exclude.some((regex) => regex.exec(path.replace(/\\//g, "\\\\")))
			      ).toBe(true);
			    \}
			  \});
			
			  it("should not exclude package with webpack names from transpilation", () => \{
			    const paths = [
			      "../my-webpack-package",
			      "node_modules/my-webpack-package",
			      "node_modules/my-webpack-package/",
			      "node_modules/my-webpack-package/internal.js",
			    ];
			    for (const path of paths) \{
			      expect(exclude.some((regex) => regex.exec(path))).toBe(false);
			      expect(
			        exclude.some((regex) => regex.exec(path.replace(/\\//g, "\\\\")))
			      ).toBe(false);
			    \}
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\config\\webpack\\__tests__\\modules.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\create-symlinks.test.ts', () => {
        const sourceCode = `
			import mock from "mock-fs";
			import createSymlinks from "../create-symlinks";
			import \{ lstatSync, realpathSync \} from "fs";
			import \{ tmpdir \} from "os";
			
			// We pretend that we're running the command in some project directory, but really we just get an absolute path to a temp directory
			const projectDir = realpathSync(tmpdir());
			
			afterEach(() => \{
			  // We need to restore the mock, otherwise it breaks jest
			  //github.com/tschaub/mock-fs#example
			  mock.restore();
			\});
			
			beforeEach(() => \{
			  // The createSymLinks step is using the CWD to determine the running dir, so we're "mocking" it
			  process.env.CWD = projectDir;
			\});
			
			describe("Create Symlink", () => \{
			  test("should create symlink if path is valid and exist", async () => \{
			    mock(\{
			      [\`\$\{projectDir\}/package.json\`]: \`\{
			          "name": "someDep",
			          "dependencies": \{
			            "someDep": "./packages/someDep"
			          \}
			        \}\`,
			      [\`\$\{projectDir\}/packages/someDep\`]: \{
			        "package.json": \`\{ name: "someDep" \}\`,
			      \},
			    \});
			
			    await createSymlinks();
			
			    const stats = lstatSync("./node_modules/someDep");
			    expect(stats.isSymbolicLink()).toBe(true);
			  \});
			
			  test("should create symlink if package path is prefixed with file:", async () => \{
			    mock(\{
			      [\`\$\{projectDir\}/package.json\`]: \`\{
			          "name": "someDep",
			          "dependencies": \{
			            "dep-with-file": "file:./packages/dep-with-file"
			          \}
			        \}\`,
			      [\`\$\{projectDir\}/packages/dep-with-file\`]: \{
			        "package.json": \`\{ name: "dep-with-file" \}\`,
			      \},
			    \});
			
			    await createSymlinks();
			
			    const stats = lstatSync("./node_modules/dep-with-file");
			    expect(stats.isSymbolicLink()).toBe(true);
			  \});
			
			  test("should throw error if package does not exist", async () => \{
			    const packageName = "dep-with-file";
			
			    mock(\{
			      [\`\$\{projectDir\}/package.json\`]: \`\{
			        "name": "someDep",
			        "dependencies": \{
			          "\$\{packageName\}": "file:./packages/\$\{packageName\}"
			        \}
			      \}\`,
			    \});
			
			    await expect(createSymlinks()).rejects.toThrow(
			      \`\$\{projectDir\}/packages/\$\{packageName\} for \$\{packageName\} does not exist.\`
			    );
			  \});
			
			  test("should throw error if path is not a valid packaged", async () => \{
			    const packageName = "dep-with-file";
			
			    mock(\{
			      [\`\$\{projectDir\}/package.json\`]: \`\{
			        "name": "someDep",
			        "dependencies": \{
			          "\$\{packageName\}": "file:./packages/\$\{packageName\}"
			        \}
			      \}\`,
			      [\`\$\{projectDir\}/packages/\$\{packageName\}\`]: \{\},
			    \});
			
			    await expect(createSymlinks()).rejects.toThrow(
			      \`\$\{packageName\} is not a valid node package.\`
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\create-symlinks.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\entry-points.test.ts', () => {
        const sourceCode = `
			import * as fsExtra from "fs-extra";
			import \{
			  generateClientEntryPoints,
			  generateServerEntryPoint,
			  checkForPackages,
			  entryPoint,
			\} from "../entry-points";
			import * as entryExists from "../entry-exists";
			
			jest.mock("fs-extra");
			jest.mock("../entry-exists");
			
			const mockedFsExtra = fsExtra as jest.Mocked<typeof fsExtra>;
			const mockedEntryExists = entryExists as jest.Mocked<typeof entryExists>;
			
			const site = [
			  \{
			    name: "site-1",
			    mode: "default",
			    packages: ["package1", "package2"],
			  \},
			];
			const sites = [
			  \{
			    name: "site-html",
			    mode: "default",
			    packages: ["package1", "package2", "package2"],
			  \},
			  \{
			    name: "site-amp",
			    mode: "amp",
			    packages: ["package1", "package3"],
			  \},
			  \{
			    name: "site-2",
			    mode: "default",
			    packages: ["package1"],
			  \},
			];
			
			beforeEach(() => \{
			  mockedFsExtra.writeFile.mockReset();
			  mockedFsExtra.ensureDir.mockReset();
			  mockedFsExtra.ensureDir.mockImplementation(() => \{
			    // Silence.
			  \});
			  mockedFsExtra.pathExists.mockReset();
			  mockedFsExtra.pathExists.mockImplementation(() => Promise.resolve(true));
			  mockedEntryExists.default.mockImplementation((path) => \{
			    if (path === "package1/src/index") return Promise.resolve(".ts");
			    if (path === "package2/src/client") return Promise.resolve(".ts");
			    if (path === "package2/src/server") return Promise.resolve(".ts");
			    if (path === "package3/src/index") return Promise.resolve(".ts");
			    if (path === "package3/src/client") return Promise.resolve(".ts");
			    if (path === "package3/src/server/index") return Promise.resolve(".ts");
			    if (path === "package3/src/amp/client/index") return Promise.resolve(".ts");
			    if (path === "package3/src/amp/server") return Promise.resolve(".ts");
			    return Promise.resolve(false);
			  \});
			\});
			
			describe("generateClientEntryPoints", () => \{
			  test("should avoid creating the client file at all if packages have no entry points", async () => \{
			    mockedEntryExists.default.mockImplementation(() => Promise.resolve(false));
			    const bundles = await generateClientEntryPoints(\{
			      sites: site,
			      outDir: "/build",
			      mode: "production",
			    \});
			    expect(mockedFsExtra.writeFile.mock.calls.length).toBe(0);
			    expect(bundles).toMatchSnapshot();
			  \});
			
			  test("should write one client entry point", async () => \{
			    const bundles = await generateClientEntryPoints(\{
			      sites: site,
			      outDir: "/build",
			      mode: "production",
			    \});
			    expect(mockedFsExtra.ensureDir.mock.calls[0]).toMatchSnapshot();
			    expect(\{
			      in: site,
			      out: mockedFsExtra.writeFile.mock.calls[0],
			    \}).toMatchSnapshot();
			    expect(bundles).toMatchSnapshot();
			  \});
			
			  test("should write multiple client entry points", async () => \{
			    const bundles = await generateClientEntryPoints(\{
			      sites,
			      outDir: "/build",
			      mode: "production",
			    \});
			    expect(mockedFsExtra.ensureDir.mock.calls).toMatchSnapshot();
			    expect(\{
			      in: sites,
			      out: mockedFsExtra.writeFile.mock.calls,
			    \}).toMatchSnapshot();
			    expect(bundles).toMatchSnapshot();
			  \});
			
			  test("should write HMR code if in development", async () => \{
			    await generateClientEntryPoints(\{
			      sites: site,
			      outDir: "/build",
			      mode: "development",
			    \});
			    expect(mockedFsExtra.writeFile.mock.calls[0][1]).toMatchSnapshot();
			  \});
			\});
			
			describe("generateServerEntryPoint", () => \{
			  test("should write one server entry point for one site", async () => \{
			    const bundles = await generateServerEntryPoint(\{
			      sites: site,
			      outDir: "/build",
			    \});
			    expect(\{
			      in: site,
			      out: mockedFsExtra.writeFile.mock.calls[0],
			    \}).toMatchSnapshot();
			    expect(bundles).toMatchSnapshot();
			  \});
			
			  test("should write one server entry point for multiple sites", async () => \{
			    const bundles = await generateServerEntryPoint(\{ sites, outDir: "/build" \});
			    expect(\{
			      in: sites,
			      out: mockedFsExtra.writeFile.mock.calls,
			    \}).toMatchSnapshot();
			    expect(bundles).toMatchSnapshot();
			  \});
			\});
			
			describe("checkForPackages", () => \{
			  test("should not throw if all packages are found", async () => \{
			    await expect(checkForPackages(\{ sites: site \})).resolves.toBe(undefined);
			  \});
			
			  test("should throw if one package is not found", async () => \{
			    mockedFsExtra.pathExists.mockImplementation(() => Promise.resolve(false));
			    await expect(checkForPackages(\{ sites: site \})).rejects.toThrow(
			      'The package "package1" doesn\\'t seem to be installed. Make sure you did "npm install package1"'
			    );
			  \});
			\});
			
			describe("entryPoint", () => \{
			  test("should return client in amp mode when it exists", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/client") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/client");
			  \});
			
			  test("should return client in amp mode when it's a folder", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/client/index")
			        return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/client/index");
			  \});
			
			  test("should return index in amp mode when client doesn't exist", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp");
			  \});
			
			  test("should return index in amp mode when client doesn't exist and it's in a folder", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/index") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/index");
			  \});
			
			  test("should return default client in amp mode when amp folder doesn't exist", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/client");
			  \});
			
			  test("should return default client in amp mode when amp folder doesn't exist and it's a folder", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client/index") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/client/index");
			  \});
			
			  test("should return default index in amp mode when amp folder doesn't exist", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/index");
			  \});
			
			  test("should not return path when none exist", async () => \{
			    mockedEntryExists.default.mockImplementation(() => \{
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("");
			  \});
			
			  test("should return server in amp mode when it exists", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/server") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/server") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "server",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/server");
			  \});
			
			  test("should return server in amp mode when it exists but it's in a folder", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/server") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/server/index")
			        return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "server",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/server/index");
			  \});
			
			  test("should return index in amp mode when server doesn't exist", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/server") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "server",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp");
			  \});
			
			  test("should return index in amp mode when server doesn't exist but it's in a folder", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/server") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/index") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "server",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/index");
			  \});
			
			  test("should return only the type in amp mode when it exists", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/client") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/client");
			  \});
			
			  test("should return the type in amp mode when default exists", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/client") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp/client");
			  \});
			
			  test("should not return the type in amp mode when it doesn't exist", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/amp/client") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "amp",
			      type: "server",
			    \});
			    await expect(entry).toBe("@org/pkg/src/amp");
			  \});
			
			  test("should return no-mode client in default mode", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/client") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/default") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/default/client") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "default",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/client");
			  \});
			
			  test("should return no-mode index in default mode", async () => \{
			    mockedEntryExists.default.mockImplementation((path) => \{
			      if (path === "@org/pkg/src/index") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/default") return Promise.resolve(".ts");
			      if (path === "@org/pkg/src/default/client") return Promise.resolve(".ts");
			      return Promise.resolve(false);
			    \});
			    const entry = await entryPoint(\{
			      name: "@org/pkg",
			      mode: "default",
			      type: "client",
			    \});
			    await expect(entry).toBe("@org/pkg/src/index");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\entry-points.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(25)
    });
    it('frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\read-configuration.test.ts', () => {
        const sourceCode = `
			import mock from "mock-fs";
			import \{ realpathSync \} from "fs";
			import \{ tmpdir \} from "os";
			import \{ readConfigurationsFromConfigFiles \} from "../read-configuration";
			
			const projectDir = realpathSync(tmpdir());
			
			describe("Read configurations", () => \{
			  beforeEach(() => \{
			    process.env.CWD = projectDir;
			  \});
			  afterEach(() => \{
			    mock.restore();
			  \});
			  it("Should read and return configuration functions based on the name exports", async () => \{
			    const sites = [
			      \{
			        name: "one",
			        mode: "default",
			        packages: ["foo", "bar"],
			      \},
			    ];
			
			    mock(\{
			      // We only mock \`foo\` package so we can test that the \`bar\` package is excluded
			      [\`\$\{projectDir\}/node_modules/foo/frontity.config.js\`]: \`
			        // We use the commonjs syntax since otherwise Jest will not be able to read this 'mocked' file
			        module.exports.fooConfig = () => \{\};
			        \`,
			    \});
			
			    // Reading the current configurations
			    const configs = await readConfigurationsFromConfigFiles(sites);
			
			    // Expect the configs to contain only an entry, called \`fooConfig\`
			    expect(configs).toMatchInlineSnapshot(\`
			      Object \{
			        "default": Array [
			          Object \{
			            "fooConfig": [Function],
			          \},
			        ],
			        "fooConfig": Array [
			          [Function],
			        ],
			      \}
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\read-configuration.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\ts-node-ignore.test.ts', () => {
        const sourceCode = `
			import ignore from "../ts-node-ignore";
			
			const ignoreRegExp = new RegExp(ignore[0]);
			
			describe("ts-node ignores", () => \{
			  it("should ignore javascript files inside node_modules", () => \{
			    const paths = [
			      "node_modules/index.js",
			      "node_modules/some-package/index.js",
			      "node_modules/@org/some-package/index.js",
			      "node_modules/@org/some-package/folder/index.js",
			    ];
			    for (const path of paths) \{
			      expect(ignoreRegExp.test(path)).toBe(true);
			      expect(ignoreRegExp.test(path.replace(/\\//g, "\\\\"))).toBe(true);
			    \}
			  \});
			
			  it("should not ignore typescript files", () => \{
			    const paths = [
			      "index.ts",
			      "node_modules/index.ts",
			      "node_modules/some-package/index.ts",
			      "node_modules/@org/some-package/index.ts",
			      "node_modules/@org/some-package/folder/index.ts",
			    ];
			    for (const path of paths) \{
			      expect(ignoreRegExp.test(path)).toBe(false);
			      expect(ignoreRegExp.test(path.replace(/\\//g, "\\\\"))).toBe(false);
			    \}
			  \});
			
			  it("should not ignore frontity settings", () => \{
			    const paths = ["frontity.settings.js", "frontity.settings.ts"];
			    for (const path of paths) \{
			      expect(ignoreRegExp.test(path)).toBe(false);
			      expect(ignoreRegExp.test(path.replace(/\\//g, "\\\\"))).toBe(false);
			    \}
			  \});
			
			  it("should not ignore javascript files outside node_modules", () => \{
			    const paths = [
			      "index.js",
			      "some-package/index.js",
			      "@org/some-package/index.js",
			    ];
			    for (const path of paths) \{
			      expect(ignoreRegExp.test(path)).toBe(false);
			      expect(ignoreRegExp.test(path.replace(/\\//g, "\\\\"))).toBe(false);
			    \}
			  \});
			
			  it("should not ignore frontity.config files", () => \{
			    const paths = [
			      "node_modules/@org/some-package/frontity.config.js",
			      "node_modules/some-package/frontity.config.js",
			      "some-package/frontity.config.js",
			      "node_modules/@org/some-package/frontity.config.ts",
			      "node_modules/some-package/frontity.config.ts",
			      "some-package/frontity.config.ts",
			    ];
			    for (const path of paths) \{
			      expect(ignoreRegExp.test(path)).toBe(false);
			      expect(ignoreRegExp.test(path.replace(/\\//g, "\\\\"))).toBe(false);
			    \}
			  \});
			
			  it("should not ignore packages from \`@frontity\`", () => \{
			    const paths = [
			      "node_modules/@frontity/some-package/index.js",
			      "@frontity/some-package/index.js",
			    ];
			    for (const path of paths) \{
			      expect(ignoreRegExp.test(path)).toBe(false);
			      expect(ignoreRegExp.test(path.replace(/\\//g, "\\\\"))).toBe(false);
			    \}
			  \});
			
			  it("should not ignore packages with \`frontity\` in the name", () => \{
			    const paths = [
			      "node_modules/@org/some-frontity-package/index.js",
			      "node_modules/some-frontity-package/index.js",
			    ];
			    for (const path of paths) \{
			      expect(ignoreRegExp.test(path)).toBe(false);
			      expect(ignoreRegExp.test(path.replace(/\\//g, "\\\\"))).toBe(false);
			    \}
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\scripts\\utils\\__tests__\\ts-node-ignore.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\error-handling.test.ts', () => {
        const sourceCode = `
			import \{ errorHandling \} from "../error-handling";
			import Koa from "koa";
			import request from "supertest";
			
			let app: Koa<Koa.DefaultState, Koa.DefaultContext> = null;
			let ctx: Koa.DefaultContext = null;
			
			beforeEach(() => \{
			  process.env.NODE_ENV = "test";
			  app = new Koa();
			  app.use((context, next) => \{
			    ctx = context;
			    next();
			  \});
			\});
			
			describe("errorHandling", () => \{
			  it("should set the X-Frontity-Dev header in development", async () => \{
			    app.use(errorHandling);
			    await request(app.callback()).get("/");
			    expect(ctx.response.get("X-Frontity-Dev")).toBe("true");
			  \});
			
			  it("should not set the X-Frontity-Dev header in production", async () => \{
			    process.env.NODE_ENV = "production";
			    app.use(errorHandling);
			    await request(app.callback()).get("/");
			    expect(ctx.response.has("X-Frontity-Dev")).toBe(false);
			  \});
			
			  it("should return the error message in development", async () => \{
			    app.use(errorHandling);
			    app.use(() => \{
			      throw new Error("Something bad happened");
			    \});
			    await request(app.callback()).get("/");
			    expect(ctx.body).toBe("Something bad happened");
			    expect(ctx.response.get("X-Frontity-Dev")).toBe("true");
			  \});
			
			  it("should return an error in production", async () => \{
			    process.env.NODE_ENV = "production";
			    app.use(async (_, next) => \{
			      await expect(() => next()).rejects.toThrow();
			    \});
			    app.use(errorHandling);
			    app.use(() => \{
			      throw new Error("Something bad happened");
			    \});
			    await request(app.callback()).get("/");
			    expect(ctx.response.has("X-Frontity-Dev")).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\error-handling.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\scripts-stats.test.ts', () => {
        const sourceCode = `
			import \{ scriptsStats \} from "../scripts-stats";
			import \{ init \} from "../init";
			import \{ createKoaContext \} from "./__utilities__/create-koa-context";
			import \{ fakeNext \} from "./__utilities__/fake-next";
			
			describe("scriptStats", () => \{
			  it("should define the stats on context", async () => \{
			    const ctx: any = createKoaContext();
			
			    await init(ctx, fakeNext);
			    await scriptsStats(ctx, fakeNext);
			
			    expect(ctx.frontity.stats).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\scripts-stats.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\server-side-rendering.test.ts', () => {
        const sourceCode = `
			import \{ serverSideRendering \} from "../server-side-rendering";
			import \{ fakeNext \} from "./__utilities__/fake-next";
			
			jest.mock("@loadable/server", () => (\{
			  ChunkExtractor: function ChunkExtractor() \{
			    this.collectChunks = jest.fn();
			    this.getLinkTags = jest
			      .fn()
			      .mockReturnValue(['<link rel="chunk-extractor-link" />']);
			    this.getScriptTags = jest
			      .fn()
			      .mockReturnValue(["<script chunk-extractor-script></script>"]);
			  \},
			\}));
			
			jest.mock("../../utils/stats", () => (\{
			  hasEntryPoint: jest.fn().mockReturnValue(true),
			  getBothScriptTags: jest
			    .fn()
			    .mockReturnValue("<script get-both-scripts></script>"),
			\}));
			
			jest.mock("../../utils/head", () => () => (\{
			  head: ['<link rel="helmet-link" />'],
			  bodyAttributes: 'helment-attr="body"',
			  htmlAttributes: 'helment-attr="html"',
			\}));
			
			const createPredefinedContext = (\{
			  stats = \{\},
			  render = null,
			  template = null,
			  App = null,
			\} = \{\}) => (\{
			  frontity: \{
			    stats: \{
			      moduleStats: false,
			      es5Stats: false,
			      ...stats,
			    \},
			    settings: \{
			      name: "test",
			    \},
			    store: \{
			      actions: [],
			      state: \{
			        FRONTITY_TEST: true,
			        frontity: \{
			          options: \{
			            publicPath: "/static",
			          \},
			        \},
			      \},
			      libraries: \{
			        frontity: \{
			          render: render || jest.fn().mockReturnValue("render()"),
			          template: template || jest.fn().mockReturnValue("template()"),
			          App: App || \`<App />\`,
			          head: [],
			          scripts: [],
			        \},
			      \},
			    \},
			    helmetContext: \{ helmet: \{\} \},
			  \},
			\});
			
			describe("serverSideRendering", () => \{
			  it("should render with the predefined entries", async () => \{
			    const ctx: any = createPredefinedContext();
			
			    await serverSideRendering(ctx, fakeNext);
			
			    // After the first pass we expect the body to be defined
			    // with the template output.
			    expect(ctx.body).toEqual("template()");
			  \});
			
			  it("should render with the given render and template", async () => \{
			    const ctx: any = createPredefinedContext(\{
			      stats: \{
			        moduleStats: true,
			        es5Stats: true,
			      \},
			      render: () => \{
			        return "<div>App</div>";
			      \},
			      template: (\{ html, head, scripts, htmlAttributes, bodyAttributes \}) => \{
			        return \`
			                    <template>
			                        \$\{html\}
			                        htmlAttributes=[\$\{htmlAttributes\}]
			                        bodyAttributes=[\$\{bodyAttributes\}]
			                        <head>
			                            \$\{head.filter(Boolean).join("\\n")\}
			                        </head>
			                        <scripts>
			                            \$\{scripts.filter(Boolean).join("\\n")\}
			                        </scripts>
			                    </template>
			                \`;
			      \},
			    \});
			
			    await serverSideRendering(ctx, fakeNext);
			
			    // After the first pass we expect the body to be defined
			    // with the template output.
			    expect(ctx.body).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\server-side-rendering.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\settings-and-store.test.ts', () => {
        const sourceCode = `
			import \{ settingsAndStore \} from "../settings-and-store";
			import \{ fakeNext \} from "./__utilities__/fake-next";
			import \{ getSettings \} from "@frontity/file-settings";
			
			jest.mock("@frontity/file-settings", () => (\{
			  getSettings: jest.fn().mockReturnValue(async () => \{
			    await Promise.resolve();
			  \}),
			\}));
			
			jest.mock("../../store", () =>
			  jest.fn().mockReturnValue(\{
			    actions: [],
			    libraries: \{
			      frontity: \{\},
			    \},
			  \})
			);
			
			describe("settingsAndStore", () => \{
			  it("should define settings and store", async () => \{
			    const packages: any = \{\};
			    const ctx: any = \{
			      frontity: \{\},
			      href: "/",
			      query: \{ frontity_name: "test" \},
			    \};
			
			    // Create the middleware
			    const middleware = settingsAndStore(packages);
			
			    // Call the middleware
			    await middleware(ctx, fakeNext);
			
			    expect(ctx.frontity.store).toMatchSnapshot();
			    expect(ctx.frontity.settings).toMatchSnapshot();
			  \});
			
			  it("should use the last name if \`frontity_name\` is a list", async () => \{
			    const packages: any = \{\};
			    const ctx: any = \{
			      frontity: \{\},
			      href: "/",
			      query: \{
			        frontity_name: ["first-name", "last-name"],
			      \},
			    \};
			
			    // Create the middleware
			    const middleware = settingsAndStore(packages);
			
			    // Call the middleware
			    await middleware(ctx, fakeNext);
			
			    expect(getSettings).toHaveBeenCalledWith(\{
			      name: "last-name",
			      url: "/",
			    \});
			    expect(getSettings).not.toHaveBeenCalledWith(\{
			      name: "first-name",
			      url: "/",
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\server\\middlewares\\__tests__\\settings-and-store.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\core\\src\\server\\utils\\__tests__\\custom-chunk-extractor.tests.ts', () => {
        const sourceCode = `
			import \{ CustomChunkExtractor \} from "../custom-chunk-extractor";
			
			// eslint-disable-next-line @typescript-eslint/no-empty-function
			function MockedChunkExtractor() \{\}
			MockedChunkExtractor.prototype.getPreAssets = () => \{
			  return [
			    \{ filename: "file.module.js", linkType: "preload" \},
			    \{ filename: "file.es5.js", linkType: "preload" \},
			  ];
			\};
			
			jest.mock("@loadable/server", () => (\{
			  ChunkExtractor: MockedChunkExtractor,
			\}));
			
			describe("CustomChunkExtractor", () => \{
			  it('Should replace "preload" with "modulepreload" only for module files', () => \{
			    const instance = new CustomChunkExtractor(\{ stats: \{\}, entrypoints: null \});
			    const results = instance.getPreAssets();
			
			    expect(results).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "filename": "file.module.js",
			          "linkType": "modulepreload",
			        \},
			        Object \{
			          "filename": "file.es5.js",
			          "linkType": "preload",
			        \},
			      ]
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\server\\utils\\__tests__\\custom-chunk-extractor.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\core\\src\\server\\utils\\__tests__\\initial-state.tests.ts', () => {
        const sourceCode = `
			import initialState from "../initial-state";
			
			const settings = \{
			  name: "site",
			  mode: "default",
			  match: ["https://www.site-1.com"],
			  state: \{
			    frontity: \{
			      url: "https://site.com",
			      prop1: "prop1",
			      menu1: ["item1"],
			      options: \{\},
			    \},
			  \},
			  packages: [
			    \{
			      name: "package1",
			      active: true,
			      state: \{
			        frontity: \{
			          prop1: "overwritten by package1",
			          menu1: ["item2", "item3"],
			        \},
			        package1: \{
			          prop2: "prop2",
			        \},
			      \},
			    \},
			    \{
			      name: "package2",
			      active: true,
			      state: \{
			        frontity: \{
			          prop1: "overwritten by package2",
			        \},
			        package2: \{
			          prop3: "prop2",
			        \},
			      \},
			    \},
			  ],
			\};
			
			describe("initialState", () => \{
			  it("should return a valid initial state", () => \{
			    const url = new URL("https://site.com/post");
			    expect(initialState(\{ settings, url \})).toMatchSnapshot();
			  \});
			
			  it("should return a valid initial link", () => \{
			    const url = new URL("https://site.com/category/nature/page/2");
			    expect(initialState(\{ settings, url \}).frontity.initialLink).toBe(
			      "/category/nature/page/2"
			    );
			  \});
			
			  it("should return a valid initial link with home", () => \{
			    const url = new URL("https://site.com");
			    expect(initialState(\{ settings, url \}).frontity.initialLink).toBe("/");
			  \});
			
			  it("should return a valid initial link with query", () => \{
			    const url = new URL("https://site.com/page/2?some=query");
			    expect(initialState(\{ settings, url \}).frontity.initialLink).toBe(
			      "/page/2?some=query"
			    );
			  \});
			
			  it("should return a valid initial link with hash", () => \{
			    const url = new URL("https://site.com/page/2#some-hash");
			    expect(initialState(\{ settings, url \}).frontity.initialLink).toBe(
			      "/page/2#some-hash"
			    );
			  \});
			
			  it("should return a valid initial link with query and hash", () => \{
			    const url = new URL("https://site.com/page/2?some=query#some-hash");
			    expect(initialState(\{ settings, url \}).frontity.initialLink).toBe(
			      "/page/2?some=query#some-hash"
			    );
			  \});
			
			  it("should return a ssr rendering on the server", () => \{
			    const url = new URL("https://site.com/page/2?some=query#some-hash");
			    expect(initialState(\{ settings, url \}).frontity.rendering).toBe("ssr");
			  \});
			
			  it("should return a server platform on the server", () => \{
			    const url = new URL("https://site.com/page/2?some=query#some-hash");
			    expect(initialState(\{ settings, url \}).frontity.platform).toBe("server");
			  \});
			
			  it("should set \`frontity.options.publicPath\` using the value from \`frontity.settings\`", async () => \{
			    const url = new URL("https://site.com/post");
			
			    settings.state.frontity.options = \{ publicPath: "/custom-settings-path" \};
			
			    expect(initialState(\{ settings, url \}).frontity.options)
			      .toMatchInlineSnapshot(\`
			      Object \{
			        "publicPath": "/custom-settings-path",
			      \}
			    \`);
			
			    settings.state.frontity.options = \{\};
			  \});
			
			  it("should set the frontity.options correctly", () => \{
			    process.env.FRONTITY_INTERNAL_PUBLIC_PATH = "/custom-env-path";
			
			    const url = new URL(
			      "https://site.com/page/2?frontity_name=some-site&frontity_source_auth=some-token&frontity_public_path=/custom-query-path"
			    );
			
			    // The frontity_name & frontity_source_auth should be present in the options
			    expect(initialState(\{ settings, url \}).frontity.options)
			      .toMatchInlineSnapshot(\`
			      Object \{
			        "name": "some-site",
			        "publicPath": "/custom-query-path",
			        "sourceAuth": "some-token",
			      \}
			    \`);
			
			    delete process.env.FRONTITY_INTERNAL_PUBLIC_PATH;
			  \});
			
			  it("should set \`frontity.options.publicPath\` using the env variable \`FRONTITY_INTERNAL_PUBLIC_PATH\`", () => \{
			    process.env.FRONTITY_INTERNAL_PUBLIC_PATH = "/custom-env-path";
			
			    const url = new URL("https://site.com/post");
			
			    expect(initialState(\{ settings, url \}).frontity.options)
			      .toMatchInlineSnapshot(\`
			      Object \{
			        "publicPath": "/custom-env-path",
			      \}
			    \`);
			
			    delete process.env.FRONTITY_INTERNAL_PUBLIC_PATH;
			  \});
			
			  it("should remove frontity_name & frontity_source_auth from the initialLink", () => \{
			    const url = new URL(
			      "https://site.com/page/2?frontity_name=mySite&otherParam=value&frontity_source_auth=hello"
			    );
			
			    // The frontity_name & frontity_source_auth should be removed but \`otherParam\` should not!
			    expect(initialState(\{ settings, url \}).frontity.initialLink).toBe(
			      "/page/2?otherParam=value"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\server\\utils\\__tests__\\initial-state.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('frontity_frontity\\packages\\core\\src\\server\\utils\\__tests__\\stats.tests.ts', () => {
        const sourceCode = `
			import \{ hasEntryPoint, getBothScriptTags \} from "../stats";
			
			describe("hasEntryPoint", () => \{
			  test("should return true if the entry points exists", () => \{
			    const stats = \{ assetsByChunkName: \{ "chunk-1": "chunk-1.js" \} \};
			    expect(hasEntryPoint(\{ site: "chunk-1", stats \})).toBe(true);
			  \});
			  test("should return false if the entry points doesn't exist", () => \{
			    const stats = \{ assetsByChunkName: \{\} \};
			    expect(hasEntryPoint(\{ site: "chunk-1", stats \})).toBe(false);
			  \});
			\});
			
			describe("getBothScriptTags", () => \{
			  test("should return both es5 and module tags in development", () => \{
			    const moduleStats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.module.js",
			        "chunk-2": "chunk-2.module.js",
			      \},
			    \};
			    const es5Stats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.es5.js",
			        "chunk-2": "chunk-2.es5.js",
			      \},
			    \};
			    const extractor = \{
			      publicPath: "/public-path/",
			      getMainAssets: () => [
			        \{ filename: "chunk-1.module.js" \},
			        \{ filename: "chunk-2.module.js" \},
			      ],
			      getRequiredChunksScriptTag: (arg: \{\}) =>
			        !!arg && "<script>REQ-CHUNK-SCRIPT-TAG</script>",
			    \};
			    expect(
			      getBothScriptTags(\{ moduleStats, es5Stats, extractor \})
			    ).toMatchSnapshot();
			  \});
			
			  test("should return both es5 and module tags in production", () => \{
			    const moduleStats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.module.123.js",
			        "chunk-2": "chunk-2.module.123.js",
			      \},
			    \};
			    const es5Stats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.es5.456.js",
			        "chunk-2": "chunk-2.es5.456.js",
			      \},
			    \};
			    const extractor = \{
			      publicPath: "/public-path/",
			      getMainAssets: () => [
			        \{ filename: "chunk-1.module.123.js" \},
			        \{ filename: "chunk-2.module.123.js" \},
			      ],
			      getRequiredChunksScriptTag: (arg: \{\}) =>
			        !!arg && "<script>REQ-CHUNK-SCRIPT-TAG</script>",
			    \};
			    expect(
			      getBothScriptTags(\{ moduleStats, es5Stats, extractor \})
			    ).toMatchSnapshot();
			  \});
			
			  test("should work with secondary chunks in development", () => \{
			    const moduleStats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.module.js",
			        "chunk-2": "chunk-2.module.js",
			        "chunk-1~chunk-2": "chunk-1~chunk-2.module.js",
			      \},
			    \};
			    const es5Stats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.es5.js",
			        "chunk-2": "chunk-2.es5.js",
			        "chunk-1~chunk-2": "chunk-1~chunk-2.es5.js",
			      \},
			    \};
			    const extractor = \{
			      publicPath: "/public-path/",
			      getMainAssets: () => [
			        \{ filename: "chunk-1.module.js" \},
			        \{ filename: "chunk-2.module.js" \},
			        \{ filename: "chunk-1~chunk-2.module.js" \},
			      ],
			      getRequiredChunksScriptTag: (arg: \{\}) =>
			        !!arg && "<script>REQ-CHUNK-SCRIPT-TAG</script>",
			    \};
			    expect(
			      getBothScriptTags(\{ moduleStats, es5Stats, extractor \})
			    ).toMatchSnapshot();
			  \});
			
			  test("should work with secondary chunks in production", () => \{
			    const moduleStats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.module.123.js",
			        "chunk-2": "chunk-2.module.123.js",
			        "chunk-1~chunk-2": "chunk-1~chunk-2.module.123.js",
			      \},
			    \};
			    const es5Stats = \{
			      assetsByChunkName: \{
			        "chunk-1": "chunk-1.es5.456.js",
			        "chunk-2": "chunk-2.es5.456.js",
			        "chunk-1~chunk-2": "chunk-1~chunk-2.es5.456.js",
			      \},
			    \};
			    const extractor = \{
			      publicPath: "/public-path/",
			      getMainAssets: () => [
			        \{ filename: "chunk-1.module.123.js" \},
			        \{ filename: "chunk-2.module.123.js" \},
			        \{ filename: "chunk-1~chunk-2.module.123.js" \},
			      ],
			      getRequiredChunksScriptTag: (arg: \{\}) =>
			        !!arg && "<script>REQ-CHUNK-SCRIPT-TAG</script>",
			    \};
			    expect(
			      getBothScriptTags(\{ moduleStats, es5Stats, extractor \})
			    ).toMatchSnapshot();
			  \});
			\});
			
			test("should return correct chunk URLs in development (publicPath has a specified domain)", () => \{
			  const moduleStats = \{
			    assetsByChunkName: \{
			      "chunk-1": "chunk-1.module.js",
			      "chunk-2": "chunk-2.module.js",
			    \},
			  \};
			  const es5Stats = \{
			    assetsByChunkName: \{
			      "chunk-1": "chunk-1.es5.js",
			      "chunk-2": "chunk-2.es5.js",
			    \},
			  \};
			  const extractor = \{
			    publicPath: "http://localhost:3000/public-path/",
			    getMainAssets: () => [
			      \{ filename: "chunk-1.module.js" \},
			      \{ filename: "chunk-2.module.js" \},
			    ],
			    getRequiredChunksScriptTag: (arg: \{\}) =>
			      !!arg && "<script>REQ-CHUNK-SCRIPT-TAG</script>",
			  \};
			  expect(
			    getBothScriptTags(\{ moduleStats, es5Stats, extractor \})
			  ).toMatchSnapshot();
			\});
			
			test("should return correct chunk URLs in production (publicPath has a specified domain)", () => \{
			  const moduleStats = \{
			    assetsByChunkName: \{
			      "chunk-1": "chunk-1.module.123.js",
			      "chunk-2": "chunk-2.module.123.js",
			    \},
			  \};
			  const es5Stats = \{
			    assetsByChunkName: \{
			      "chunk-1": "chunk-1.es5.456.js",
			      "chunk-2": "chunk-2.es5.456.js",
			    \},
			  \};
			  const extractor = \{
			    publicPath: "http://localhost:3000/public-path/",
			    getMainAssets: () => [
			      \{ filename: "chunk-1.module.123.js" \},
			      \{ filename: "chunk-2.module.123.js" \},
			    ],
			    getRequiredChunksScriptTag: (arg: \{\}) =>
			      !!arg && "<script>REQ-CHUNK-SCRIPT-TAG</script>",
			  \};
			  expect(
			    getBothScriptTags(\{ moduleStats, es5Stats, extractor \})
			  ).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\server\\utils\\__tests__\\stats.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\packages\\core\\src\\utils\\__tests__\\get-variable.tests.ts', () => {
        const sourceCode = `
			import getVariable from "../get-variable";
			
			describe("getVariable", () => \{
			  it("should generate different variable names for different packages", () => \{
			    expect(getVariable("@org/package", "mode")).not.toBe(
			      getVariable("org-package", "mode")
			    );
			    expect(getVariable("@org/package", "mode")).not.toBe(
			      getVariable("org.package", "mode")
			    );
			    expect(getVariable("org-package", "mode")).not.toBe(
			      getVariable("org.package", "mode")
			    );
			    expect(getVariable("@org/package", "default")).not.toBe(
			      getVariable("@org/package", "amp")
			    );
			  \});
			  it("should allow scopes starting with numbers", () => \{
			    expect(() =>
			      eval("var " + getVariable("@123/package", "mode"))
			    ).not.toThrow();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\utils\\__tests__\\get-variable.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\core\\src\\utils\\__tests__\\merge-packages.tests.tsx', () => {
        const sourceCode = `
			import mergePackages from "../merge-packages";
			
			class MyLib \{
			  init() \{
			    return "initialized";
			  \}
			\}
			
			const state = \{
			  frontity: \{
			    debug: false,
			    mode: "default",
			    packages: ["package-1", "package-2", "package-3"],
			  \},
			\};
			
			const Namespace1 = () => <div>namespace1</div>;
			const Namespace2 = () => <div>namespace2</div>;
			const Namespace3 = () => <div>namespace3</div>;
			const Namespace4 = () => <div>namespace4</div>;
			
			const packages = \{
			  package_1_default: \{
			    name: "package1",
			    roots: \{
			      namespace1: Namespace1,
			      namespace2: Namespace2,
			    \},
			    state: \{
			      frontity: \{
			        debug: true,
			      \},
			      namespace1: \{
			        prop1: "prop1",
			        array1: ["item1"],
			      \},
			      namespace2: \{
			        prop2: "prop2",
			      \},
			    \},
			    actions: \{
			      namespace1: \{
			        action1: () => \{
			          // Logic.
			        \},
			      \},
			    \},
			  \},
			  package_2_default: \{
			    name: "package2",
			    roots: \{
			      namespace3: Namespace3,
			    \},
			    state: \{
			      namespace1: \{
			        prop1: "prop1 overwritten by package_2",
			        array1: ["item2", "item3"],
			      \},
			      namespace3: \{
			        prop3: "prop3",
			      \},
			    \},
			    actions: \{
			      namespace1: \{
			        action2: () => () => \{
			          // Logic.
			        \},
			      \},
			    \},
			    libraries: \{
			      namespace3: \{
			        lib1: "lib1",
			        lib2: new MyLib(),
			      \},
			    \},
			  \},
			  package_3_default: () => (\{
			    name: "package3",
			    roots: \{
			      namespace4: Namespace4,
			    \},
			    state: \{
			      namespace4: \{
			        prop4: "prop4",
			      \},
			    \},
			    libraries: \{
			      namespace4: \{
			        lib2: "lib2",
			      \},
			    \},
			  \}),
			\};
			
			describe("mergePackages", () => \{
			  it("should output a merged packages", () => \{
			    const merged = mergePackages(\{ packages, state \});
			    expect(merged).toMatchSnapshot();
			  \});
			
			  it("should output allow complex object like class instances", () => \{
			    const merged = mergePackages(\{ packages, state \});
			    expect(merged.libraries.namespace3.lib2.init()).toBe("initialized");
			  \});
			
			  it("should deep clone state", () => \{
			    const merged = mergePackages(\{ packages, state \});
			    expect(state.frontity).not.toBe(merged.state.frontity);
			    expect(packages.package_2_default.state.namespace3).not.toBe(
			      merged.state.namespace3
			    );
			  \});
			
			  it("should overwrite arrays if the 'overwriteArrays' option is true", () => \{
			    const \{ state: initialState \} = mergePackages(\{ packages, state \});
			    const merged = mergePackages(\{
			      packages,
			      state: initialState,
			      overwriteArrays: true,
			    \});
			    expect(merged.state.namespace1.array1).toEqual(["item1", "item2", "item3"]);
			  \});
			
			  it("should deep clone state if the 'overwriteArrays' option is true", () => \{
			    const merged = mergePackages(\{ packages, state, overwriteArrays: true \});
			    expect(state.frontity).not.toBe(merged.state.frontity);
			    expect(packages.package_2_default.state.namespace3).not.toBe(
			      merged.state.namespace3
			    );
			  \});
			
			  it("should not use debug mode in production", () => \{
			    const nodeEnv = process.env.NODE_ENV;
			    process.env.NODE_ENV = "production";
			    const merged = mergePackages(\{ packages, state, overwriteArrays: true \});
			    expect(merged.state.frontity.debug).toBe(false);
			    process.env.NODE_ENV = nodeEnv;
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\utils\\__tests__\\merge-packages.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\packages\\core\\src\\utils\\__tests__\\snake-to-camel.tests.ts', () => {
        const sourceCode = `
			import snakeToCamel from "../snake-to-camel";
			
			describe("snakeToCamel", () => \{
			  it("should work with underscores", () => \{
			    expect(snakeToCamel("some_thing")).toBe("someThing");
			  \});
			
			  it("should work with hyphens", () => \{
			    expect(snakeToCamel("some-thing")).toBe("someThing");
			  \});
			
			  it("should work with numbers", () => \{
			    expect(snakeToCamel("some_thing_0x_extra")).toBe("someThing0xExtra");
			  \});
			
			  it("should work with points", () => \{
			    expect(snakeToCamel("some_.thing")).toBe("some.thing");
			  \});
			
			  it("should work with ~", () => \{
			    expect(snakeToCamel("some_~thing")).toBe("some~thing");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\core\\src\\utils\\__tests__\\snake-to-camel.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\error\\__tests__\\index.test.ts', () => {
        const sourceCode = `
			import \{ warn, error \} from "..";
			
			beforeEach(() => \{
			  process.env.NODE_ENV = "test";
			\});
			
			describe("error", () => \{
			  test("In development, throw the full message", () => \{
			    expect(() => error("This is wrong")).toThrow(
			      new Error(
			        "This is wrong\\nVisit https://community.frontity.org for help! \\n"
			      )
			    );
			  \});
			
			  test("In production, throw the short message", () => \{
			    process.env.NODE_ENV = "production";
			    expect(() => error("This is wrong")).toThrow(new Error("This is wrong"));
			  \});
			
			  test("In development, console.error the full message", () => \{
			    console.error = jest.fn();
			    expect(() => error("This is wrong", \{ throw: false \})).not.toThrow();
			    expect(console.error).toHaveBeenCalledTimes(1);
			    expect(console.error).toHaveBeenLastCalledWith(
			      "This is wrong\\nVisit https://community.frontity.org for help! \\n"
			    );
			  \});
			
			  test("In production, console.error the short message", () => \{
			    process.env.NODE_ENV = "production";
			    console.error = jest.fn();
			    expect(() => error("This is wrong", \{ throw: false \})).not.toThrow();
			    expect(console.error).toHaveBeenCalledTimes(1);
			    expect(console.error).toHaveBeenLastCalledWith("This is wrong");
			  \});
			\});
			
			describe("warn", () => \{
			  test("In development, warn the full message", () => \{
			    console.warn = jest.fn();
			    warn("This is a warning");
			    expect(console.warn).toHaveBeenCalledTimes(1);
			    expect(console.warn).toHaveBeenLastCalledWith(
			      "This is a warning\\nVisit https://community.frontity.org for help! \\n"
			    );
			  \});
			
			  test("In production, do not warn", () => \{
			    process.env.NODE_ENV = "production";
			    console.warn = jest.fn();
			    warn("This is a warning");
			    expect(console.warn).toHaveBeenCalledTimes(0);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\error\\__tests__\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\packages\\file-settings\\src\\__tests__\\getAllSites.tests.ts', () => {
        const sourceCode = `
			import getAllSites from "../getAllSites";
			import * as importSettings from "../importSettings";
			import mockedMonoSettings from "./mocks/getAllSites/monoSettings.json";
			import mockedMultiSettings from "./mocks/getAllSites/multiSettings.json";
			import mockedDeactivatedPackage from "./mocks/getAllSites/deactivatedPackage.json";
			
			jest.mock("../importSettings");
			
			describe("getAllSites", () => \{
			  const mockedImportSettings = importSettings as jest.Mocked<
			    typeof importSettings
			  >;
			
			  afterEach(() => \{
			    mockedImportSettings.default.mockReset();
			  \});
			
			  test("should work when \`allSettings\` is an object", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedMonoSettings);
			    const result = await getAllSites();
			    expect(result).toEqual([
			      \{
			        name: "mono-settings",
			        mode: "default",
			        packages: ["@frontity/theme", "@frontity/wp-source"],
			      \},
			    ]);
			  \});
			
			  test("should work when \`allSettings\` is an array", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedMultiSettings);
			    const result = await getAllSites();
			    expect(result).toEqual([
			      \{
			        name: "settings-default",
			        mode: "default",
			        packages: ["@frontity/theme-default", "@frontity/wp-source-default"],
			      \},
			      \{
			        name: "settings-amp",
			        mode: "amp",
			        packages: ["@frontity/theme-amp", "@frontity/wp-source-amp"],
			      \},
			    ]);
			  \});
			
			  test("should filter out inactive packages", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedDeactivatedPackage);
			    const result = await getAllSites();
			    expect(result).toEqual([
			      \{
			        name: "mono-settings",
			        mode: "default",
			        packages: ["@frontity/theme"],
			      \},
			    ]);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\file-settings\\src\\__tests__\\getAllSites.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\packages\\file-settings\\src\\__tests__\\getSettings.tests.ts', () => {
        const sourceCode = `
			import getSettings from "../getSettings";
			import * as importSettings from "../importSettings";
			import mockedMonoSettings from "./mocks/getSettings/monoSettings.json";
			import mockedSettingsWithLengthOne from "./mocks/getSettings/settingsWithLengthOne.json";
			import mockedSettingsWithNames from "./mocks/getSettings/settingsWithNames.json";
			import mockedSettingsWithOneMatch from "./mocks/getSettings/settingsWithOneMatch.json";
			import mockedSettingsWithMatches from "./mocks/getSettings/settingsWithMatches.json";
			
			jest.mock("../importSettings");
			
			describe("getSettings", () => \{
			  const mockedImportSettings = importSettings as jest.Mocked<
			    typeof importSettings
			  >;
			
			  afterEach(() => \{
			    mockedImportSettings.default.mockReset();
			  \});
			
			  test("should work when \`allSettings\` is not an array", async () => \{
			    mockedImportSettings.default.mockResolvedValueOnce(mockedMonoSettings);
			    const settings = await getSettings(\{ url: "https://frontity.org" \});
			    expect(settings.name).toBe("mono-settings");
			  \});
			
			  test("should work when \`allSettings\` is an array of length 1", async () => \{
			    mockedImportSettings.default.mockResolvedValueOnce(
			      mockedSettingsWithLengthOne
			    );
			    const settings = await getSettings(\{ url: "https://frontity.org" \});
			    expect(settings.name).toBe("settings-with-length-one");
			  \});
			
			  test("should work when \`name\` is passed as a param", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedSettingsWithNames);
			    const settings = [
			      await getSettings(\{
			        name: "settings-one",
			      \}),
			      await getSettings(\{
			        name: "settings-two",
			      \}),
			    ];
			    expect(settings[0].name).toBe("settings-one");
			    expect(settings[1].name).toBe("settings-two");
			  \});
			
			  test("should throw when an unexistent \`name\` is passed as a param", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedSettingsWithNames);
			    await expect(
			      getSettings(\{ name: "fake-name", url: "https://frontity.org" \})
			    ).rejects.toThrow("Do not exist any settings named 'fake-name'.");
			  \});
			
			  test("should work when one of the settings matches \`url\`", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedSettingsWithOneMatch);
			    const settings = await getSettings(\{
			      url: "https://frontity.org/amp/",
			    \});
			    expect(settings.name).toBe("settings-with-match");
			  \});
			
			  test("should work when more than one of the settings matches \`url\`", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedSettingsWithMatches);
			    const settings = await getSettings(\{
			      url: "https://frontity.org/page/about-us",
			    \});
			    expect(settings.name).toBe("settings-with-large-match");
			  \});
			
			  test("should work when none of the settings matches \`url\` but one doesn't have \`match\` defined", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedSettingsWithOneMatch);
			    const settings = await getSettings(\{
			      url: "https://frontity.org",
			    \});
			    expect(settings.name).toBe("settings-without-match");
			  \});
			
			  test("should work when none of the settings matches \`url\` and all have \`match\` defined", async () => \{
			    mockedImportSettings.default.mockResolvedValue(mockedSettingsWithMatches);
			    const settings = await getSettings(\{
			      url: "https://not.frontity.org",
			    \});
			    expect(settings.name).toBe("settings-with-short-match");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\file-settings\\src\\__tests__\\getSettings.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\packages\\file-settings\\src\\__tests__\\normalizeSettings.tests.ts', () => {
        const sourceCode = `
			import normalizeSettings from "../normalizeSettings";
			import * as validateSettings from "../validateSettings";
			import mockedMonoSettings from "./mocks/normalizeSettings/monoSettings.json";
			import mockedMultiSettings from "./mocks/normalizeSettings/multiSettings.json";
			import expectedMono from "./mocks/normalizeSettings/expectedMono.json";
			import expectedMulti from "./mocks/normalizeSettings/expectedMulti.json";
			
			jest.mock("../validateSettings");
			
			describe("normalizeSettings", () => \{
			  test("should work when param \`settings\` is an object", () => \{
			    const result = normalizeSettings(mockedMonoSettings);
			    expect(validateSettings.default).toHaveBeenCalled();
			    expect(result).toEqual(expectedMono);
			  \});
			
			  test("should work when param \`settings\` is an array", () => \{
			    const result = normalizeSettings(mockedMultiSettings);
			    expect(validateSettings.default).toHaveBeenCalled();
			    expect(result).toEqual(expectedMulti);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\file-settings\\src\\__tests__\\normalizeSettings.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\file-settings\\src\\__tests__\\validateSettings.tests.ts', () => {
        const sourceCode = `
			import validateSettings from "../validateSettings";
			import mockedSettingsMissingName from "./mocks/validateSettings/settingsMissingName.json";
			import mockedSettingsRepeatedName from "./mocks/validateSettings/settingsRepeatedName.json";
			import mockedPackageMissingName from "./mocks/validateSettings/packageMissingName.json";
			import mockedPackageRepeatedName from "./mocks/validateSettings/packageRepeatedName.json";
			import mockedMonoSettings from "./mocks/normalizeSettings/monoSettings.json";
			
			describe("validateSettings", () => \{
			  test("should throw if some multi settings is missing its name", () => \{
			    expect(() => validateSettings(mockedSettingsMissingName as any)).toThrow(
			      "All the settings must have a unique name."
			    );
			  \});
			
			  test("should throw if some multi settings has a repeated name", () => \{
			    expect(() => validateSettings(mockedSettingsRepeatedName)).toThrow(
			      "All the settings must have a unique name."
			    );
			  \});
			
			  test("should not throw if mono settings is missing its name", () => \{
			    expect(() => validateSettings(mockedMonoSettings)).not.toThrow();
			  \});
			
			  test("should throw if some package is missing its name", () => \{
			    expect(() => validateSettings(mockedPackageMissingName as any)).toThrow(
			      "All the packages must have a unique name."
			    );
			  \});
			
			  test("should throw if some package has a repeated name", () => \{
			    expect(() => validateSettings(mockedPackageRepeatedName as any)).toThrow(
			      "All the packages must have a unique name."
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\file-settings\\src\\__tests__\\validateSettings.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\frontity\\cli-e2e\\docker\\create.test.ts', () => {
        const sourceCode = `
			import execa from "execa";
			import \{ readFile \} from "fs-extra";
			import \{ resolve as resolvePath \} from "path";
			import \{ testContainer \} from "./utils";
			
			beforeAll(async () => \{
			  if (process.env.CI) return;
			
			  // Remove the dist output.
			  await execa.command("rm -rf dist", \{ stdio: "inherit" \});
			
			  // Compile the TS source to JS.
			  await execa.command("npm run build", \{ stdio: "inherit" \});
			
			  // Build the "base" docker image that contains our CLI.
			  await execa.command("docker build -t frontity-cli .", \{ stdio: "inherit" \});
			\});
			
			afterAll(async () => \{
			  await execa.command("docker rmi frontity-cli");
			\});
			
			describe("npx frontity create", () => \{
			  describe("typescript", () => \{
			    it("should create a new typescript project cloning @frontity/mars-theme-typescript", () =>
			      testContainer(async (\{ runCommand \}) => \{
			        await runCommand(
			          \`node dist/src/cli/index.js create --no-prompt test-frontity-app --typescript\`
			        );
			        const root = await runCommand("ls -a test-frontity-app");
			        expect(root).toMatchInlineSnapshot(\`
			          ".
			          ..
			          README.md
			          favicon.ico
			          frontity.settings.ts
			          node_modules
			          package-lock.json
			          package.json
			          packages
			          tsconfig.json"
			        \`);
			
			        const pkgs = await runCommand("ls -a test-frontity-app/packages");
			        expect(pkgs).toMatchInlineSnapshot(\`
			          ".
			          ..
			          mars-theme-typescript"
			        \`);
			      \}));
			  \});
			
			  describe("git", () => \{
			    it("should not add git if git is installed but git settings are missing", () =>
			      testContainer(async (\{ runCommand \}) => \{
			        await runCommand("apk add git");
			        await runCommand(
			          \`node dist/src/cli/index.js create --no-prompt --theme @frontity/mars-theme test-frontity-app\`,
			          \{ stdio: "inherit" \}
			        );
			
			        const output = await runCommand("ls -a test-frontity-app");
			
			        expect(output).toEqual(expect.not.stringMatching(/\\.git\$/m));
			        expect(output).toEqual(expect.not.stringMatching(/\\.gitignore\$/m));
			      \}));
			
			    it("should not add git if git is not installed", () =>
			      testContainer(async (\{ runCommand \}) => \{
			        await runCommand(
			          \`node dist/src/cli/index.js create --no-prompt --theme @frontity/mars-theme test-frontity-app\`
			        );
			
			        const output = await runCommand("ls -a test-frontity-app");
			        expect(output).toEqual(expect.not.stringMatching(/\\.git\$/m));
			        expect(output).toEqual(expect.not.stringMatching(/\\.gitignore\$/m));
			      \}));
			
			    it("should add git if git is installed and configured", () =>
			      testContainer(async (\{ runCommand \}) => \{
			        await runCommand("apk add git");
			        await runCommand('git config --global user.email "user@frontity.com"');
			        await runCommand('git config --global user.name "Test User"');
			
			        await runCommand(
			          \`node dist/src/cli/index.js create --no-prompt --theme @frontity/mars-theme test-frontity-app\`,
			          \{ stdio: "inherit" \}
			        );
			
			        const output = await runCommand("ls -a test-frontity-app");
			        expect(output).toEqual(expect.stringMatching(/\\.git\$/m));
			        expect(output).toEqual(expect.stringMatching(/\\.gitignore\$/m));
			      \}));
			
			    it("should add .gitignore when a git repo already exists", () =>
			      testContainer(async (\{ runCommand \}) => \{
			        await runCommand("apk add git");
			        await runCommand('git config --global user.email "user@frontity.com"');
			        await runCommand('git config --global user.name "Test User"');
			        await runCommand("git init test-frontity-app");
			
			        await runCommand(
			          \`node dist/src/cli/index.js create --no-prompt --theme @frontity/mars-theme test-frontity-app\`,
			          \{ stdio: "inherit" \}
			        );
			
			        const output = await runCommand("ls -a test-frontity-app");
			        expect(output).toEqual(expect.stringMatching(/\\.git\$/m));
			        expect(output).toEqual(expect.stringMatching(/\\.gitignore\$/m));
			
			        // The .gitignore should be the same as the template file.
			        const gitignore = await runCommand("cat test-frontity-app/.gitignore");
			        const template = await readFile(
			          resolvePath(__dirname, "../../templates/gitignore-template"),
			          \{ encoding: "utf8" \}
			        );
			        expect(gitignore).toEqual(template);
			      \}));
			
			    it("should add .gitignore when a inside a parent git repo", () =>
			      testContainer(async (\{ runCommand \}) => \{
			        await runCommand("apk add git");
			        await runCommand('git config --global user.email "user@frontity.com"');
			        await runCommand('git config --global user.name "Test User"');
			        await runCommand("git init");
			
			        await runCommand(
			          \`node dist/src/cli/index.js create --no-prompt --theme @frontity/mars-theme test-frontity-app\`,
			          \{ stdio: "inherit" \}
			        );
			
			        const output = await runCommand("ls -a test-frontity-app");
			        expect(output).toEqual(expect.not.stringMatching(/\\.git\$/m));
			        expect(output).toEqual(expect.stringMatching(/\\.gitignore\$/m));
			
			        // The .gitignore should be the same as the template file.
			        const gitignore = await runCommand("cat test-frontity-app/.gitignore");
			        const template = await readFile(
			          resolvePath(__dirname, "../../templates/gitignore-template"),
			          \{ encoding: "utf8" \}
			        );
			        expect(gitignore).toEqual(template);
			      \}));
			
			    it("should append to .gitignore when it already exist", () =>
			      testContainer(async (\{ runCommand \}) => \{
			        await runCommand("apk add git");
			        await runCommand('git config --global user.email "user@frontity.com"');
			        await runCommand('git config --global user.name "Test User"');
			        await runCommand("git init test-frontity-app");
			
			        // Create the .gitignore
			        await runCommand('echo "test" > test-frontity-app/.gitignore');
			
			        let output = await runCommand("ls -a test-frontity-app");
			        expect(output).toEqual(expect.stringMatching(/\\.gitignore\$/m));
			
			        await runCommand(
			          \`node dist/src/cli/index.js create --no-prompt --theme @frontity/mars-theme test-frontity-app\`,
			          \{ stdio: "inherit" \}
			        );
			
			        // The first line should be \`test\` because it was the original content of
			        // the .gitignore file.
			        output = await runCommand("cat test-frontity-app/.gitignore");
			        expect(output).toMatchInlineSnapshot(\`
			                  "test
			                  node_modules
			                  build"
			              \`);
			      \}));
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\cli-e2e\\docker\\create.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\packages\\frontity\\cli-e2e\\filesystem\\create.test.ts', () => {
        const sourceCode = `
			import \{ readdir, readFile, remove \} from "fs-extra";
			import \{ resolve as resolvePath \} from "path";
			import execa from "execa";
			
			describe("npx frontity create", () => \{
			  it("should create the initial files", async () => \{
			    try \{
			      await execa.command(
			        \`ts-node src/cli/index.ts create --no-prompt --theme @frontity/mars-theme test-frontity-app\`,
			        \{ stdio: "inherit" \}
			      );
			
			      expect(await readdir("test-frontity-app")).toMatchInlineSnapshot(\`
			        Array [
			          ".gitignore",
			          "README.md",
			          "favicon.ico",
			          "frontity.settings.js",
			          "node_modules",
			          "package-lock.json",
			          "package.json",
			          "packages",
			        ]
			        \`);
			    \} finally \{
			      await remove("test-frontity-app");
			    \}
			  \});
			
			  it("should add a .gitignore file even if inside a git repo", async () => \{
			    try \{
			      await execa.command(
			        \`ts-node src/cli/index.ts create --no-prompt --theme @frontity/mars-theme test-frontity-app\`,
			        \{ stdio: "inherit" \}
			      );
			
			      // The .gitignore should be the same as the template file.
			      const gitignore = await readFile("test-frontity-app/.gitignore", "utf8");
			      const template = await readFile(
			        resolvePath(__dirname, "../../templates/gitignore-template"),
			        \{ encoding: "utf8" \}
			      );
			      expect(gitignore).toEqual(template);
			    \} finally \{
			      await remove("test-frontity-app");
			    \}
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\cli-e2e\\filesystem\\create.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\build.ci.test.ts', () => {
        const sourceCode = `
			import build from "../build";
			import * as utils from "../../utils";
			import * as buildCmd from "../../commands/build";
			import \{ EventPromised \} from "../../utils/eventPromised";
			
			jest.mock("../../commands/build");
			
			const mockedUtils = utils as any;
			const mockedDev = buildCmd as jest.Mocked<typeof buildCmd>;
			
			describe("build", () => \{
			  beforeEach(() => \{
			    mockedUtils.isFrontityProjectRoot = jest.fn();
			    mockedUtils.errorLogger = jest.fn(() => \{
			      throw new Error("Process terminated");
			    \});
			    mockedDev.default.mockReset();
			    mockedDev.default.mockReturnValue(
			      new EventPromised((resolve) => resolve())
			    );
			  \});
			
			  test("should receive default values", async () => \{
			    await build(\{\});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should get values from ENV variables", async () => \{
			    process.env.FRONTITY_BUILD_TARGET = "es5";
			    process.env.FRONTITY_BUILD_DEVELOPMENT = "true";
			    process.env.FRONTITY_BUILD_PUBLIC_PATH = "/public/path";
			    process.env.FRONTITY_BUILD_ANALYZE = "true";
			
			    await build(\{\});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should ignore ENV variables for passed arguments", async () => \{
			    process.env.FRONTITY_BUILD_TARGET = "es5";
			    process.env.FRONTITY_BUILD_DEVELOPMENT = "true";
			    process.env.FRONTITY_BUILD_PUBLIC_PATH = "/public/path";
			    process.env.FRONTITY_BUILD_ANALYZE = "true";
			
			    await build(\{
			      target: "module",
			      development: false,
			      publicPath: "/static",
			      analyze: false,
			    \});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should fail if an invalid target is passed", async () => \{
			    try \{
			      await build(\{ target: "not-valid-target" \});
			    \} catch (error) \{
			      // Ignore error.
			    \}
			    expect(mockedDev.default).not.toHaveBeenCalled();
			    expect(mockedUtils.errorLogger.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\build.ci.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\create-package.cli.test.ts', () => {
        const sourceCode = `
			import createPackage from "../create-package";
			import inquirer from "inquirer";
			import * as utils from "../../utils";
			import * as createCmd from "../../commands/create-package";
			import \{ EventPromised \} from "../../utils/eventPromised";
			
			jest.mock("inquirer");
			jest.mock("../../commands/create-package");
			
			const mockedInquirer = inquirer as jest.Mocked<typeof inquirer>;
			const mockedUtils = utils as any;
			const mockedExit = jest.spyOn(process, "exit");
			const mockedCreate = createCmd as jest.Mocked<typeof createCmd>;
			
			describe("create-package", () => \{
			  beforeEach(() => \{
			    mockedInquirer.prompt.mockRestore();
			    mockedUtils.isFrontityProjectRoot = jest.fn();
			    mockedUtils.errorLogger = jest.fn();
			    mockedCreate.default.mockReset();
			    mockedCreate.default.mockReturnValue(
			      new EventPromised((resolve) => resolve())
			    );
			    mockedExit.mockRestore();
			    mockedExit.mockImplementation(() => \{
			      throw new Error();
			    \});
			  \});
			
			  test("should not ask for passed options", async () => \{
			    const name = "example-theme";
			    const namespace = "theme";
			    const prompt = true;
			    await createPackage(\{ name, namespace, prompt \});
			    expect(mockedInquirer.prompt).not.toHaveBeenCalled();
			  \});
			
			  test("should ask for missing name", async () => \{
			    mockedInquirer.prompt.mockResolvedValueOnce(\{ name: "example-theme" \});
			
			    const name = undefined;
			    const namespace = "theme";
			    const prompt = true;
			    await createPackage(\{ name, namespace, prompt \});
			    expect(mockedInquirer.prompt).toHaveBeenCalled();
			    expect(mockedInquirer.prompt.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should ask for missing namespace", async () => \{
			    mockedInquirer.prompt.mockResolvedValueOnce(\{ namespace: "theme" \});
			
			    const name = "example-theme";
			    const namespace = undefined;
			    const prompt = true;
			    await createPackage(\{ name, namespace, prompt \});
			    expect(mockedInquirer.prompt).toHaveBeenCalled();
			    expect(mockedInquirer.prompt.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should respect the --no-prompt flag", () => \{\});
			
			  test.todo("should fail in a invalid directory");
			  test.todo("should work in a valid directory");
			  test.todo("should fail with an invalid name");
			  test.todo("should work with a valid name");
			  test.todo("should work with a valid name with scope");
			  test.todo("should fail with an invalid namespace");
			  test.todo("should work with a valid namespace");
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\create-package.cli.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\create.cli.test.ts', () => {
        const sourceCode = `
			import \{ resolve \} from "path";
			import omit from "lodash.omit";
			
			import create from "../create";
			import \{ EventPromised \} from "../../utils/eventPromised";
			import * as createCmd from "../../commands/create";
			import * as inquirer from "inquirer";
			import * as utils from "../../utils";
			
			jest.mock("../../commands/create");
			jest.mock("inquirer");
			
			const mockedCreateCmd = createCmd as jest.Mocked<typeof createCmd>;
			const mockedInquirer = inquirer as jest.Mocked<typeof inquirer>;
			const mockedUtils = utils as any;
			
			describe("CLI create", () => \{
			  beforeEach(() => \{
			    mockedCreateCmd.default.mockReset();
			    mockedCreateCmd.default.mockReturnValue(
			      new EventPromised((resolve) => resolve())
			    );
			    mockedInquirer.prompt.mockReset();
			    mockedUtils.errorLogger = jest.fn((error) => \{
			      throw error;
			    \});
			
			    delete process.env.FRONTITY_CREATE_TYPESCRIPT;
			    delete process.env.FRONTITY_CREATE_NO_GIT;
			  \});
			
			  const options = \{
			    name: undefined,
			    typescript: undefined,
			    noGit: undefined,
			    useCwd: undefined,
			    theme: undefined,
			    prompt: true,
			  \};
			
			  test("frontity create", async () => \{
			    mockedInquirer.prompt
			      .mockResolvedValueOnce(\{
			        name: "test-project",
			      \})
			      .mockResolvedValueOnce(\{
			        theme: "test-theme",
			      \})
			      .mockResolvedValueOnce("n");
			
			    await create(options);
			
			    expect(mockedInquirer.prompt).toHaveBeenCalledTimes(2);
			    expect(mockedInquirer.prompt.mock.calls[0][0]).toMatchObject([
			      \{ message: "Enter a name for the project:" \},
			    ]);
			    expect(mockedInquirer.prompt.mock.calls[1][0]).toMatchObject([
			      \{ message: "Pick a starter theme to clone:" \},
			    ]);
			
			    // expect(mockedInquirer.prompt.mock.calls[2][0]).toMatchObject([
			    //   \{ message: "Do you want to receive framework updates by email?" \},
			    //   \{ message: "Please, enter your email:" \},
			    // ]);
			    expect(mockedInquirer.prompt.mock.calls).toMatchSnapshot();
			  \});
			
			  test("frontity create 'test-project'", async () => \{
			    mockedInquirer.prompt
			      .mockResolvedValueOnce(\{
			        theme: "test-theme",
			      \})
			      .mockResolvedValueOnce("n");
			
			    const name = "test-project";
			    await create(\{ ...options, name \});
			
			    const params = mockedCreateCmd.default.mock.calls[0][0];
			    // omit path because it can vary depending on environment
			    expect(omit(params, "path")).toMatchSnapshot();
			
			    expect(mockedCreateCmd.default).toHaveBeenCalledWith(\{
			      name: "test-project",
			      theme: "test-theme",
			      typescript: false,
			      noGit: false,
			      path: resolve(process.cwd(), name),
			    \});
			  \});
			
			  test("frontity create 'test-project' --typescript", async () => \{
			    mockedInquirer.prompt.mockResolvedValueOnce("Y");
			
			    const name = "test-project";
			    const typescript = true;
			
			    await create(\{ ...options, name, typescript \});
			
			    const params = mockedCreateCmd.default.mock.calls[0][0];
			    // omit path because it can vary depending on environment
			    expect(omit(params, "path")).toMatchSnapshot();
			
			    expect(mockedCreateCmd.default).toHaveBeenCalledWith(\{
			      name: name,
			      theme: "@frontity/mars-theme-typescript",
			      typescript,
			      noGit: false,
			      path: resolve(process.cwd(), name),
			    \});
			  \});
			
			  test("frontity create 'test-project' --no-git", async () => \{
			    mockedInquirer.prompt
			      .mockResolvedValueOnce(\{
			        theme: "test-theme",
			      \})
			      .mockResolvedValueOnce("Y");
			
			    const name = "test-project";
			    const noGit = true;
			
			    await create(\{ ...options, name, noGit \});
			
			    const params = mockedCreateCmd.default.mock.calls[0][0];
			    // omit path because it can vary depending on environment
			    expect(omit(params, "path")).toMatchSnapshot();
			
			    expect(mockedCreateCmd.default).toHaveBeenCalledWith(\{
			      name: name,
			      theme: "test-theme",
			      typescript: false,
			      noGit: true,
			      path: resolve(process.cwd(), name),
			    \});
			  \});
			
			  test("frontity create --no-prompt", async () => \{
			    await expect(
			      create(\{ ...options, typescript: true, prompt: false \})
			    ).rejects.toThrow("You need to provide the name for the project.");
			  \});
			
			  test("FRONTITY_CREATE__NAME='test-project'; frontity create --no-prompt", async () => \{
			    const name = "test-project";
			    process.env.FRONTITY_CREATE_NAME = name;
			
			    await create(\{ ...options, prompt: false \});
			
			    const params = mockedCreateCmd.default.mock.calls[0][0];
			    // Omit path because it can vary depending on environment.
			    expect(omit(params, "path")).toMatchSnapshot();
			
			    expect(mockedCreateCmd.default).toHaveBeenCalledWith(\{
			      name,
			      theme: "@frontity/mars-theme",
			      typescript: false,
			      noGit: false,
			      path: resolve(process.cwd(), name),
			    \});
			  \});
			
			  test("FRONTITY_CREATE_TYPESCRIPT='true'; frontity create 'test-project' --no-prompt", async () => \{
			    const name = "test-project";
			    process.env.FRONTITY_CREATE_TYPESCRIPT = "true";
			
			    await create(\{ ...options, name, prompt: false \});
			
			    const params = mockedCreateCmd.default.mock.calls[0][0];
			    // omit path because it can vary depending on environment
			    expect(omit(params, "path")).toMatchSnapshot();
			
			    expect(mockedCreateCmd.default).toHaveBeenCalledWith(\{
			      name,
			      theme: "@frontity/mars-theme-typescript",
			      typescript: true,
			      noGit: false,
			      path: resolve(process.cwd(), name),
			    \});
			  \});
			
			  test("FRONTITY_CREATE_NO_GIT='true'; frontity create 'test-project' --no-prompt", async () => \{
			    const name = "test-project";
			    process.env.FRONTITY_CREATE_NO_GIT = "true";
			
			    await create(\{ ...options, name, prompt: false \});
			
			    const params = mockedCreateCmd.default.mock.calls[0][0];
			    // omit path because it can vary depending on environment
			    expect(omit(params, "path")).toMatchSnapshot();
			
			    expect(mockedCreateCmd.default).toHaveBeenCalledWith(\{
			      name,
			      theme: "@frontity/mars-theme",
			      noGit: true,
			      typescript: false,
			      path: resolve(process.cwd(), name),
			    \});
			  \});
			
			  test("frontity create 'test-project' --theme 'test-theme'", async () => \{
			    mockedInquirer.prompt.mockResolvedValueOnce("n");
			
			    const name = "test-project";
			    const theme = "test-theme";
			    await create(\{ ...options, name, theme \});
			
			    const params = mockedCreateCmd.default.mock.calls[0][0];
			    // omit path because it can vary depending on environment
			    expect(omit(params, "path")).toMatchSnapshot();
			
			    expect(mockedCreateCmd.default).toHaveBeenCalledWith(\{
			      name,
			      theme,
			      typescript: false,
			      noGit: false,
			      path: resolve(process.cwd(), name),
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\create.cli.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\dev.ci.test.ts', () => {
        const sourceCode = `
			import dev from "../dev";
			import * as utils from "../../utils";
			import * as devCmd from "../../commands/dev";
			import \{ EventPromised \} from "../../utils/eventPromised";
			
			jest.mock("../../commands/dev");
			
			const mockedUtils = utils as any;
			const mockedDev = devCmd as jest.Mocked<typeof devCmd>;
			
			describe("dev", () => \{
			  beforeEach(() => \{
			    mockedUtils.isFrontityProjectRoot = jest.fn();
			    mockedUtils.errorLogger = jest.fn(() => \{
			      throw new Error("Process terminated");
			    \});
			    mockedDev.default.mockReset();
			    mockedDev.default.mockReturnValue(
			      new EventPromised((resolve) => resolve())
			    );
			  \});
			
			  test("should receive default values", async () => \{
			    await dev(\{\});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should get values from ENV variables", async () => \{
			    process.env.FRONTITY_DEV_TARGET = "es5";
			    process.env.FRONTITY_DEV_PORT = "3001";
			    process.env.FRONTITY_DEV_HTTPS = "true";
			    process.env.FRONTITY_DEV_PRODUCTION = "true";
			    process.env.FRONTITY_DEV_PUBLIC_PATH = "/public/path";
			    process.env.FRONTITY_DEV_DONT_OPEN_BROWSER = "true";
			    process.env.FRONTITY_DEV_ANALYZE = "true";
			
			    await dev(\{\});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should ignore ENV variables for passed arguments", async () => \{
			    process.env.FRONTITY_DEV_TARGET = "es5";
			    process.env.FRONTITY_DEV_PORT = "3001";
			    process.env.FRONTITY_DEV_HTTPS = "true";
			    process.env.FRONTITY_DEV_PRODUCTION = "true";
			    process.env.FRONTITY_DEV_PUBLIC_PATH = "/public/path";
			    process.env.FRONTITY_DEV_DONT_OPEN_BROWSER = "true";
			    process.env.FRONTITY_DEV_ANALYZE = "true";
			
			    await dev(\{
			      target: "module",
			      port: "4000",
			      https: false,
			      production: false,
			      publicPath: "/static",
			      dontOpenBrowser: false,
			      analyze: false,
			    \});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should fail if an invalid target is passed", async () => \{
			    try \{
			      await dev(\{ target: "not-valid-target" \});
			    \} catch (error) \{
			      // Ignore error.
			    \}
			    expect(mockedDev.default).not.toHaveBeenCalled();
			    expect(mockedUtils.errorLogger.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should fail if an invalid port is passed", async () => \{
			    try \{
			      await dev(\{ port: "not-valid-port" \});
			    \} catch (error) \{
			      // Ignore error.
			    \}
			    expect(mockedDev.default).not.toHaveBeenCalled();
			    expect(mockedUtils.errorLogger.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\dev.ci.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\serve.ci.test.ts', () => {
        const sourceCode = `
			import serve from "../serve";
			import * as utils from "../../utils";
			import * as serveCmd from "../../commands/serve";
			import \{ EventPromised \} from "../../utils/eventPromised";
			
			jest.mock("../../commands/serve");
			
			const mockedUtils = utils as any;
			const mockedDev = serveCmd as jest.Mocked<typeof serveCmd>;
			
			describe("serve", () => \{
			  beforeEach(() => \{
			    mockedUtils.isFrontityProjectRoot = jest.fn();
			    mockedUtils.errorLogger = jest.fn(() => \{
			      throw new Error("Process terminated");
			    \});
			    mockedDev.default.mockReset();
			    mockedDev.default.mockReturnValue(
			      new EventPromised((resolve) => resolve())
			    );
			  \});
			
			  test("should receive default values", async () => \{
			    await serve(\{\});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should get values from ENV variables", async () => \{
			    process.env.FRONTITY_SERVE_PORT = "3001";
			    process.env.FRONTITY_SERVE_HTTPS = "true";
			
			    await serve(\{\});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should ignore ENV variables for passed arguments", async () => \{
			    process.env.FRONTITY_SERVE_PORT = "3001";
			    process.env.FRONTITY_SERVE_HTTPS = "true";
			
			    await serve(\{
			      port: "4000",
			      https: false,
			    \});
			    expect(mockedDev.default.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should fail if an invalid port is passed", async () => \{
			    try \{
			      await serve(\{ port: "not-valid-port" \});
			    \} catch (error) \{
			      // Ignore error.
			    \}
			    expect(mockedDev.default).not.toHaveBeenCalled();
			    expect(mockedUtils.errorLogger.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\cli\\__tests__\\serve.ci.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\build.test.ts', () => {
        const sourceCode = `
			import build from "../build";
			import * as core from "@frontity/core";
			import * as choosePort from "../../utils/choosePort";
			
			jest.mock("@frontity/core");
			jest.mock("../../utils/choosePort");
			
			const mockedCore = core as jest.Mocked<typeof core>;
			const mockedChoosePort = choosePort as jest.Mocked<typeof choosePort>;
			
			describe("build", () => \{
			  beforeEach(() => \{
			    mockedCore.build.mockReset();
			    mockedChoosePort.default.mockReset();
			    mockedChoosePort.default.mockImplementation(() => 3000);
			  \});
			
			  test("gets the correct default values when it receives an empty object", async () => \{
			    await build(\{\});
			    expect(mockedCore.build.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\build.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\create-package.test.ts', () => {
        const sourceCode = `
			import createPackage from "../create-package";
			import * as steps from "../../steps/";
			import * as stepsCmd from "../../steps/create-package";
			
			jest.mock("../../steps/");
			jest.mock("../../steps/create-package");
			
			const mockedSteps = steps as jest.Mocked<typeof steps>;
			const mockedStepsCmd = stepsCmd as jest.Mocked<typeof stepsCmd>;
			
			describe("create-package", () => \{
			  beforeEach(() => \{
			    mockedStepsCmd.createPackageJson.mockReset();
			    mockedStepsCmd.createSrcIndexJs.mockReset();
			    mockedStepsCmd.installPackage.mockReset();
			    mockedSteps.ensureProjectDir.mockReset();
			    mockedSteps.revertProgress.mockReset();
			  \});
			
			  test("goes through all steps", async () => \{
			    await createPackage(\{
			      name: "my-package",
			      namespace: "myPackage",
			      projectPath: "/User/Frontity/Code/my-frontity-project",
			      packagePath: "./packages",
			    \});
			
			    expect(mockedSteps.ensureProjectDir.mock.calls).toMatchSnapshot();
			    expect(mockedStepsCmd.createPackageJson.mock.calls).toMatchSnapshot();
			    expect(mockedStepsCmd.createSrcIndexJs.mock.calls).toMatchSnapshot();
			    expect(mockedStepsCmd.installPackage.mock.calls).toMatchSnapshot();
			    expect(mockedSteps.revertProgress).not.toHaveBeenCalled();
			  \});
			
			  test("should revert changes if something fail and files have been created", async () => \{
			    // Project directory exist.
			    mockedSteps.ensureProjectDir.mockResolvedValue(true);
			
			    // It fails while creating \`package.json\` file.
			    mockedStepsCmd.createPackageJson.mockRejectedValue(
			      new Error("Random error")
			    );
			
			    try \{
			      await createPackage(\{
			        name: "my-package",
			        namespace: "myPackage",
			        projectPath: "/User/Frontity/Code/my-frontity-project",
			        packagePath: "./packages",
			      \});
			    \} catch (error) \{
			      // Error is thrown again after being catched by \`createPackage\`.
			    \}
			
			    // Other steps are not called.
			    expect(mockedStepsCmd.createSrcIndexJs).not.toHaveBeenCalled();
			    expect(mockedStepsCmd.installPackage).not.toHaveBeenCalled();
			
			    // Changes are reverted.
			    expect(mockedSteps.revertProgress.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\create-package.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\create.test.ts', () => {
        const sourceCode = `
			/* eslint-disable jest/no-try-expect, jest/no-conditional-expect */
			import create from "../create";
			import * as steps from "../../steps";
			import * as utils from "../../utils";
			
			jest.mock("../../steps");
			
			const mockedSteps = steps as jest.Mocked<typeof steps>;
			
			const mockedHasGit = jest.spyOn(utils, "hasGit");
			const mockedIsInGitRepository = jest.spyOn(utils, "isInGitRepository");
			
			describe("create", () => \{
			  beforeEach(() => \{
			    mockedSteps.normalizeOptions.mockReset();
			    mockedSteps.normalizeOptions.mockImplementation(
			      (_defaultOptions, passedOptions) => passedOptions
			    );
			    mockedSteps.ensureProjectDir.mockReset();
			    mockedSteps.createPackageJson.mockReset();
			    mockedSteps.createFrontitySettings.mockReset();
			    mockedSteps.createTsConfig.mockReset();
			    mockedSteps.cloneStarterTheme.mockReset();
			    mockedSteps.installDependencies.mockReset();
			    mockedSteps.initializeGit.mockReset();
			    mockedSteps.createGitignore.mockReset();
			    mockedSteps.revertProgress.mockReset();
			
			    mockedHasGit.mockReset().mockReturnValue(true);
			    mockedIsInGitRepository.mockReset().mockReturnValue(false);
			  \});
			
			  test("goes through all steps", async () => \{
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			      theme: "@frontity/mars-theme",
			      typescript: false,
			    \};
			    await create(options);
			    expect(mockedSteps.normalizeOptions.mock.calls[0][1]).toMatchSnapshot();
			    expect(mockedSteps.ensureProjectDir.mock.calls).toMatchSnapshot();
			    expect(mockedSteps.createPackageJson.mock.calls).toMatchSnapshot();
			    expect(mockedSteps.createFrontitySettings.mock.calls).toMatchSnapshot();
			    expect(mockedSteps.cloneStarterTheme.mock.calls).toMatchSnapshot();
			    expect(mockedSteps.installDependencies.mock.calls).toMatchSnapshot();
			    expect(mockedSteps.createGitignore.mock.calls).toMatchSnapshot();
			    expect(mockedSteps.initializeGit.mock.calls).toMatchSnapshot();
			  \});
			
			  test("works correctly when \`options.typescript\` is false", async () => \{
			    // Restore the original implementation
			    const \{ normalizeOptions \} = jest.requireActual("../../steps");
			    mockedSteps.normalizeOptions.mockImplementation(normalizeOptions);
			
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			      theme: "@frontity/mars-theme",
			      typescript: false,
			    \};
			
			    await create(options);
			
			    expect(mockedSteps.createPackageJson).toHaveBeenCalledWith(
			      options.name,
			      options.theme,
			      options.path,
			      options.typescript
			    );
			    expect(mockedSteps.createFrontitySettings).toHaveBeenCalledWith(
			      "js",
			      options.name,
			      options.path,
			      "@frontity/mars-theme"
			    );
			  \});
			
			  test("works correctly when \`options.typescript\` is true", async () => \{
			    // Restore the original implementation
			    const \{ normalizeOptions \} = jest.requireActual("../../steps");
			    mockedSteps.normalizeOptions.mockImplementation(normalizeOptions);
			
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			      theme: "@frontity/mars-theme",
			      typescript: true,
			    \};
			
			    await create(options);
			
			    expect(mockedSteps.createPackageJson).toHaveBeenCalledWith(
			      options.name,
			      options.theme,
			      options.path,
			      options.typescript
			    );
			    expect(mockedSteps.createFrontitySettings).toHaveBeenCalledWith(
			      "ts",
			      options.name,
			      options.path,
			      "@frontity/mars-theme"
			    );
			    expect(mockedSteps.createTsConfig).toHaveBeenCalledWith(options.path);
			  \});
			
			  test("works correctly when \`options.noGit\` is true", async () => \{
			    const \{ normalizeOptions \} = jest.requireActual("../../steps");
			    mockedSteps.normalizeOptions.mockImplementation(normalizeOptions);
			
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			      noGit: true,
			    \};
			
			    await create(options);
			    expect(mockedSteps.initializeGit).not.toHaveBeenCalled();
			  \});
			
			  test("initializeGit is called with the path of the project", async () => \{
			    const \{ normalizeOptions \} = jest.requireActual("../../steps");
			    mockedSteps.normalizeOptions.mockImplementation(normalizeOptions);
			
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			
			    await create(options);
			    expect(mockedSteps.initializeGit).toHaveBeenCalledWith(options.path);
			  \});
			
			  test("initializeGit is NOT called if git is not installed", async () => \{
			    mockedHasGit.mockReturnValue(false);
			
			    const \{ normalizeOptions \} = jest.requireActual("../../steps");
			    mockedSteps.normalizeOptions.mockImplementation(normalizeOptions);
			
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			
			    await create(options);
			    expect(mockedSteps.initializeGit).not.toHaveBeenCalled();
			    expect(mockedSteps.createGitignore).not.toHaveBeenCalled();
			  \});
			
			  test("works correctly if we are in a git repository", async () => \{
			    mockedIsInGitRepository.mockReturnValue(true);
			
			    const \{ normalizeOptions \} = jest.requireActual("../../steps");
			    mockedSteps.normalizeOptions.mockImplementation(normalizeOptions);
			
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			
			    await create(options);
			
			    // If we are already in a git repo, we don't want to call initializeGit
			    expect(mockedSteps.initializeGit).not.toHaveBeenCalled();
			    expect(mockedSteps.createGitignore).toHaveBeenCalledWith(options.path);
			  \});
			
			  test("calls removeProgress on error with dirExisted=true", async () => \{
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			    mockedSteps.ensureProjectDir.mockResolvedValueOnce(true);
			
			    try \{
			      const error = new Error("Mocked Error");
			      mockedSteps.createPackageJson.mockImplementation(() => \{
			        throw error;
			      \});
			
			      await create(options);
			    \} catch (err) \{
			      expect(err.message).toBe("Mocked Error");
			      expect(mockedSteps.revertProgress).toHaveBeenCalledWith(
			        true,
			        options.path
			      );
			    \}
			  \});
			
			  test("calls removeProgress on error with dirExisted=false", async () => \{
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			    mockedSteps.ensureProjectDir.mockResolvedValueOnce(false);
			
			    try \{
			      const error = new Error("Mocked Error");
			      mockedSteps.createPackageJson.mockImplementation(() => \{
			        throw error;
			      \});
			
			      await create(options);
			      throw new Error("This should not be reached");
			    \} catch (err) \{
			      expect(err.message).toBe("Mocked Error");
			      expect(mockedSteps.revertProgress).toHaveBeenCalledWith(
			        false,
			        options.path
			      );
			    \}
			  \});
			
			  test("does not call removeProgress if ensureProjectDir throws error", async () => \{
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			
			    try \{
			      const error = new Error("Mocked Error");
			      mockedSteps.ensureProjectDir.mockImplementation(async () => \{
			        throw error;
			      \});
			
			      await create(options);
			      throw new Error("This should never be reached");
			    \} catch (err) \{
			      expect(err.message).toBe("Mocked Error");
			      expect(mockedSteps.revertProgress).not.toHaveBeenCalled();
			    \}
			  \});
			
			  test("uses the emitter passed to log messages", async () => \{
			    const emitter = \{ emit: jest.fn() \};
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			    await create(options);
			    expect(emitter.emit.mock.calls).toMatchSnapshot();
			  \});
			
			  test("Bubbling up the error", async () => \{
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			
			    try \{
			      const error = new Error("Mocked Error");
			      mockedSteps.ensureProjectDir.mockImplementation(async () => \{
			        throw error;
			      \});
			
			      await create(options);
			    \} catch (err) \{
			      expect(err.message).toBe("Mocked Error");
			    \}
			  \});
			
			  test("If no theme is specified, clone the default", async () => \{
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			    \};
			
			    // Restore the original implementation
			    const \{ normalizeOptions \} = jest.requireActual("../../steps");
			    mockedSteps.normalizeOptions.mockImplementation(normalizeOptions);
			
			    mockedSteps.ensureProjectDir.mockResolvedValueOnce(false);
			
			    await create(options);
			
			    expect(mockedSteps.cloneStarterTheme).toHaveBeenCalledTimes(1);
			    expect(mockedSteps.cloneStarterTheme).toHaveBeenCalledWith(
			      "@frontity/mars-theme",
			      options.path
			    );
			  \});
			
			  test("Clone the specified theme", async () => \{
			    const options = \{
			      name: "random-name",
			      path: "/path/to/project",
			      theme: "@frontity/twentytwenty-theme",
			    \};
			
			    await create(options);
			
			    expect(mockedSteps.cloneStarterTheme).toHaveBeenCalledTimes(1);
			    expect(mockedSteps.cloneStarterTheme).toHaveBeenCalledWith(
			      options.theme,
			      options.path
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\create.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(14)
    });
    it('frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\dev.test.ts', () => {
        const sourceCode = `
			import dev from "../dev";
			import * as core from "@frontity/core";
			import * as choosePort from "../../utils/choosePort";
			
			jest.mock("@frontity/core");
			jest.mock("../../utils/choosePort");
			
			const mockedCore = core as jest.Mocked<typeof core>;
			const mockedChoosePort = choosePort as jest.Mocked<typeof choosePort>;
			
			describe("dev", () => \{
			  beforeEach(() => \{
			    mockedCore.dev.mockReset();
			    mockedChoosePort.default.mockReset();
			    mockedChoosePort.default.mockImplementation(() => 3000);
			  \});
			
			  test("gets the correct default values when it receives an empty object", async () => \{
			    await dev(\{\});
			    expect(mockedCore.dev.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\dev.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\serve.test.ts', () => {
        const sourceCode = `
			import serve from "../serve";
			import * as core from "@frontity/core";
			import * as choosePort from "../../utils/choosePort";
			
			jest.mock("@frontity/core");
			jest.mock("../../utils/choosePort");
			
			const mockedCore = core as jest.Mocked<typeof core>;
			const mockedChoosePort = choosePort as jest.Mocked<typeof choosePort>;
			
			describe("serve", () => \{
			  beforeEach(() => \{
			    mockedCore.serve.mockReset();
			    mockedChoosePort.default.mockReset();
			    mockedChoosePort.default.mockImplementation(() => 3000);
			  \});
			
			  test("gets the correct default values when it receives an empty object", async () => \{
			    await serve(\{\});
			    expect(mockedCore.serve.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\commands\\__tests__\\serve.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\frontity\\src\\steps\\__tests__\\steps.test.ts', () => {
        const sourceCode = `
			import \{
			  normalizeOptions,
			  ensureProjectDir,
			  createPackageJson,
			  createFrontitySettings,
			  createTsConfig,
			  cloneStarterTheme,
			  installDependencies,
			  downloadFavicon,
			  revertProgress,
			\} from "../";
			import \{ createPackageJson as createPackageJsonForPackage \} from "../create-package";
			
			import * as utils from "../../utils";
			import * as fsExtra from "fs-extra";
			import * as fetch from "node-fetch";
			import * as path from "path";
			import * as childProcess from "child_process";
			import * as tar from "tar";
			
			jest.mock("../../utils");
			jest.mock("fs-extra");
			jest.mock("path");
			jest.mock("node-fetch");
			jest.mock("child_process");
			jest.mock("tar");
			
			// Manually define the overload that we are mocking because TypeScript is not
			// able to know which one we are using when we use \`.mockResolvedValue\`.
			type Readdir = (
			  path: fsExtra.PathLike,
			  options?:
			    | \{ encoding: BufferEncoding | null; withFileTypes?: false \}
			    | BufferEncoding
			    | null
			) => Promise<string[]>;
			
			const mockedUtils = utils as jest.Mocked<typeof utils>;
			const mockedFsExtra = fsExtra as jest.Mocked<typeof fsExtra>;
			const mockedFetch = fetch as jest.Mocked<typeof fetch>;
			const mockedPath = path as jest.Mocked<typeof path>;
			const mockedChildProcess = childProcess as jest.Mocked<typeof childProcess>;
			const mockedTar = tar as jest.Mocked<typeof tar>;
			const mockedReaddir: jest.MockedFunction<Readdir> = fsExtra.readdir as any;
			
			beforeEach(() => \{
			  mockedPath.resolve.mockImplementation((...dirs) =>
			    dirs.join("/").replace("./", "")
			  );
			\});
			
			describe("normalizeOptions", () => \{
			  beforeEach(() => \{
			    mockedUtils.isPackageNameValid.mockReset();
			  \});
			
			  test("returns merged options", () => \{
			    const defaultOptions = \{
			      path: "/default/path/to/project",
			      typescript: false,
			      packages: ["frontity", "@frontity/file-settings"],
			      theme: "@frontity/mars-theme",
			    \};
			    const passedOptions = \{
			      name: "Some Random Name",
			      path: "/path/to/project",
			      theme: "@frontity/saturn-theme",
			    \};
			    const expectedOptions = \{
			      name: "some-random-name",
			      path: passedOptions.path,
			      typescript: defaultOptions.typescript,
			      packages: defaultOptions.packages,
			      theme: passedOptions.theme,
			    \};
			    mockedUtils.isPackageNameValid.mockReturnValue(true);
			    const result = normalizeOptions(defaultOptions, passedOptions);
			    expect(result).toEqual(expectedOptions);
			  \});
			
			  test("throws if \`options.name\` is not valid", () => \{
			    const defaultOptions = \{
			      path: "/default/path/to/project",
			      typescript: false,
			      packages: ["frontity", "@frontity/file-settings"],
			      theme: "@frontity/mars-theme",
			    \};
			    const passedOptions = \{
			      name: "Some, Random Name",
			    \};
			    mockedUtils.isPackageNameValid.mockReturnValue(false);
			    expect(() => normalizeOptions(defaultOptions, passedOptions)).toThrow(
			      "The name of the package is not valid. Please enter a valid one (only letters and dashes)."
			    );
			  \});
			\});
			
			describe("ensureProjectDir", () => \{
			  beforeEach(() => \{
			    mockedFsExtra.ensureDir.mockReset();
			    mockedReaddir.mockReset();
			    mockedFsExtra.pathExists.mockReset();
			  \});
			
			  test("works when passing a non existent path", async () => \{
			    const path = "/path/to/project";
			    mockedFsExtra.pathExists.mockImplementation(() => Promise.resolve(false));
			    const dirExisted = await ensureProjectDir(path);
			    expect(dirExisted).toBe(false);
			    expect(mockedFsExtra.pathExists.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.ensureDir.mock.calls).toMatchSnapshot();
			    expect(mockedReaddir).not.toHaveBeenCalled();
			  \});
			
			  test("works when passing an existent path with an empty repo", async () => \{
			    const path = "/path/to/project";
			    mockedReaddir.mockResolvedValue([
			      "README.md",
			      ".git",
			      ".gitignore",
			      "LICENSE",
			    ]);
			    mockedFsExtra.pathExists.mockImplementation(() => Promise.resolve(true));
			    const dirExisted = await ensureProjectDir(path);
			    expect(dirExisted).toBe(true);
			    expect(mockedFsExtra.pathExists.mock.calls).toMatchSnapshot();
			    expect(mockedReaddir.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.ensureDir).not.toHaveBeenCalled();
			  \});
			
			  test("throws when passing an non-empty path", async () => \{
			    const path = "/path/to/project";
			    mockedFsExtra.pathExists.mockImplementation(() => Promise.resolve(true));
			    mockedReaddir.mockResolvedValue(["file-that-should-not-exist"]);
			    await expect(ensureProjectDir(path)).rejects.toThrow(
			      "The directory passed to \`create\` function is not empty"
			    );
			  \});
			\});
			
			describe("createPackageJson", () => \{
			  beforeEach(() => \{
			    mockedFsExtra.writeFile.mockReset();
			    mockedUtils.fetchPackageVersion.mockReset();
			    mockedUtils.fetchPackageVersion.mockResolvedValue("1.0.0");
			  \});
			
			  test('works with a theme like "@frontity/mars-theme"', async () => \{
			    const name = "random-name";
			    const theme = "@frontity/mars-theme";
			    const path = "/path/to/project";
			    const typescript = false;
			
			    await createPackageJson(name, theme, path, typescript);
			    expect(mockedUtils.fetchPackageVersion.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			
			  test('works with a theme like "mars-theme"', async () => \{
			    const name = "random-name";
			    const theme = "random-theme";
			    const path = "/path/to/project";
			    const typescript = false;
			
			    await createPackageJson(name, theme, path, typescript);
			    expect(mockedUtils.fetchPackageVersion.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			
			  test('works when "typescript" is true', async () => \{
			    const name = "random-name";
			    const theme = "random-theme";
			    const path = "/path/to/project";
			    const typescript = true;
			
			    await createPackageJson(name, theme, path, typescript);
			    expect(mockedUtils.fetchPackageVersion.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			\});
			
			describe("createFrontitySettings", () => \{
			  beforeEach(() => \{
			    mockedFsExtra.readFile.mockReset();
			    mockedFsExtra.readFile.mockResolvedValueOnce("\$settings\$" as any);
			    mockedFsExtra.writeFile.mockReset();
			  \});
			
			  test("works when extension is \`js\`", async () => \{
			    const name = "random-name";
			    const path = "/path/to/project";
			    const extension = "js";
			    const theme = "@frontity/mars-theme";
			
			    await createFrontitySettings(extension, name, path, theme);
			    expect(mockedFsExtra.readFile).toHaveBeenCalled();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			
			  test("works when extension is \`ts\`", async () => \{
			    const name = "random-name";
			    const path = "/path/to/project";
			    const extension = "ts";
			    const theme = "@frontity/mars-theme";
			
			    await createFrontitySettings(extension, name, path, theme);
			    expect(mockedFsExtra.readFile).toHaveBeenCalled();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			\});
			
			describe("createTsConfig", () => \{
			  beforeEach(() => \{
			    mockedFsExtra.readFile.mockReset();
			    mockedFsExtra.readFile.mockResolvedValueOnce("\$tsconfig\$" as any);
			    mockedFsExtra.writeFile.mockReset();
			  \});
			
			  test('works as expected"', async () => \{
			    const path = "/path/to/project";
			
			    await createTsConfig(path);
			    expect(mockedFsExtra.readFile).toHaveBeenCalled();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			\});
			
			describe("cloneStarterTheme", () => \{
			  beforeEach(() => \{
			    mockedFsExtra.readFile.mockReset();
			    mockedFsExtra.readFile.mockResolvedValueOnce(
			      JSON.stringify(\{
			        dependencies: \{
			          "@frontity/mars-theme": "./packages/mars-theme",
			        \},
			      \}) as any
			    );
			    mockedFsExtra.ensureDir.mockReset();
			    mockedUtils.isThemeNameValid.mockReset();
			    mockedReaddir.mockReset();
			    mockedReaddir.mockResolvedValueOnce(["file.tgz"]);
			    mockedFsExtra.remove.mockReset();
			    mockedChildProcess.exec.mockReset();
			    (mockedChildProcess as any).exec.mockImplementation(
			      (
			        _command: string,
			        _options: Record<string, unknown>,
			        resolve: (...args: any) => any
			      ) => \{
			        resolve();
			      \}
			    );
			    mockedTar.extract.mockReset();
			  \});
			
			  test("works as expected", async () => \{
			    const path = "/path/to/project";
			    const theme = "@frontity/mars-theme";
			
			    mockedUtils.isThemeNameValid.mockReturnValue(true);
			    await cloneStarterTheme(theme, path);
			    expect(mockedFsExtra.readFile.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.ensureDir.mock.calls).toMatchSnapshot();
			    expect(mockedUtils.isThemeNameValid.mock.calls).toMatchSnapshot();
			    expect(mockedChildProcess.exec.mock.calls).toMatchSnapshot();
			    expect(mockedReaddir.mock.calls).toMatchSnapshot();
			    expect(mockedTar.extract.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.remove.mock.calls).toMatchSnapshot();
			  \});
			
			  test("throws if the theme name is not valid", async () => \{
			    const path = "/path/to/project";
			    const theme = "@frontity/mars-theme";
			
			    mockedUtils.isThemeNameValid.mockReturnValue(false);
			    await expect(cloneStarterTheme(path, theme)).rejects.toThrow(
			      "The name of the theme is not a valid npm package name."
			    );
			  \});
			\});
			
			describe("downloadFavicon", () => \{
			  beforeEach(() => \{
			    mockedFetch.default.mockReset();
			    (mockedFetch as any).default.mockResolvedValue(\{
			      body: \{
			        pipe: jest.fn(),
			      \},
			    \});
			    mockedFsExtra.createWriteStream.mockReset();
			    (mockedFsExtra as any).createWriteStream.mockReturnValue(\{
			      on: jest.fn((_event, callback) => callback()),
			    \});
			  \});
			
			  test("works as expected", async () => \{
			    const path = "/path/to/project";
			
			    await downloadFavicon(path);
			    expect(mockedFetch.default.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.createWriteStream.mock.calls).toMatchSnapshot();
			  \});
			\});
			
			describe("installDependencies", () => \{
			  beforeEach(() => \{
			    mockedChildProcess.exec.mockReset();
			    (mockedChildProcess as any).exec.mockImplementation(
			      (
			        _command: string,
			        _options: Record<string, unknown>,
			        resolve: (...args: any) => any
			      ) => \{
			        resolve();
			      \}
			    );
			  \});
			
			  test("works as expected", async () => \{
			    const path = "/path/to/project";
			
			    await installDependencies(path);
			    expect(mockedChildProcess.exec.mock.calls).toMatchSnapshot();
			  \});
			\});
			
			describe("revertProgress", () => \{
			  beforeEach(() => \{
			    mockedReaddir.mockReset();
			    mockedFsExtra.remove.mockReset();
			  \});
			
			  test("works if the project directory existed", async () => \{
			    const dirExisted = true;
			    const path = "/path/to/project";
			
			    mockedReaddir.mockResolvedValue([
			      "frontity.settings.js",
			      "package.json",
			      "packages",
			      "favicon.ico",
			      "node_modules",
			      "package-lock.json",
			    ]);
			    await revertProgress(dirExisted, path);
			    expect(mockedReaddir.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.remove.mock.calls).toMatchSnapshot();
			  \});
			
			  test("works if the project directory didn't exist", async () => \{
			    const dirExisted = false;
			    const path = "/path/to/project";
			
			    await revertProgress(dirExisted, path);
			    expect(mockedFsExtra.remove.mock.calls).toMatchSnapshot();
			  \});
			\});
			
			describe("createPackageJson for create-package", () => \{
			  beforeEach(() => \{
			    mockedFsExtra.writeFile.mockReset();
			    mockedUtils.fetchPackageVersion.mockReset();
			    mockedUtils.fetchPackageVersion.mockResolvedValue("1.0.0");
			  \});
			
			  test('works with a theme like "@frontity/mars-theme"', async () => \{
			    const name = "random-name";
			    const namespace = "test";
			    const theme = "@frontity/mars-theme";
			    const path = "/path/to/project";
			
			    await createPackageJsonForPackage(name, namespace, theme, path);
			    expect(mockedUtils.fetchPackageVersion.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			
			  test('works with a theme like "random-theme"', async () => \{
			    const name = "random-name";
			    const namespace = "test";
			    const theme = "random-theme";
			    const path = "/path/to/project";
			
			    await createPackageJsonForPackage(name, namespace, theme, path);
			    expect(mockedUtils.fetchPackageVersion.mock.calls).toMatchSnapshot();
			    expect(mockedFsExtra.writeFile.mock.calls).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\steps\\__tests__\\steps.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(19)
    });
    it('frontity_frontity\\packages\\frontity\\src\\utils\\decode\\__tests__\\decode.test.ts', () => {
        const sourceCode = `
			import decodeServer from "../server";
			import decodeClient from "../client";
			import * as he from "he";
			
			jest.mock("he");
			
			const mockedHe = he as jest.Mocked<typeof he>;
			
			describe("decode", () => \{
			  beforeEach(() => \{
			    mockedHe.decode.mockReset();
			    mockedHe.decode.mockImplementation(jest.requireActual("he").decode);
			  \});
			
			  test("works on server", () => \{
			    const result = decodeServer("&amp;");
			    expect(result).toBe("&");
			  \});
			
			  test("works on client", () => \{
			    const result = decodeClient("&amp;");
			    expect(result).toBe("&");
			  \});
			
			  test("decodes numeric entities", () => \{
			    const numeric = "blog&#8217;s";
			    const client = decodeClient(numeric);
			    expect(client).toBe("blogs");
			    const server = decodeServer(numeric);
			    expect(server).toBe("blogs");
			  \});
			
			  test("client preserves the whitespace", () => \{
			    const result = decodeClient("  &amp; ");
			    expect(result).toBe("  & ");
			  \});
			
			  test("server preserves the whitespace", () => \{
			    const result = decodeServer("  &amp; ");
			    expect(result).toBe("  & ");
			  \});
			
			  test("handles different characters", () => \{
			    const client = decodeClient("&equiv; &gamma; &#8217;");
			    expect(client).toBe("  ");
			    const server = decodeServer("&equiv; &gamma; &#8217;");
			    expect(server).toBe("  ");
			  \});
			
			  test("call he.decode if html contains a character that basic decode cannot not handle", () => \{
			    decodeServer("&nbsp; &Bscr;");
			    expect(mockedHe.decode).toHaveBeenCalledTimes(1);
			  \});
			
			  test("does not call he.decode if html contains a character that we can handle with basic decode", () => \{
			    const result = decodeServer(" &amp; &apos;");
			    expect(result).toBe(" & '");
			
			    expect(mockedHe.decode).toHaveBeenCalledTimes(0);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\utils\\decode\\__tests__\\decode.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\packages\\frontity\\src\\utils\\slot-and-fill\\__tests__\\slot.tests.tsx', () => {
        const sourceCode = `
			import \{
			  create,
			  ReactTestRenderer,
			  ReactTestRendererJSON,
			\} from "react-test-renderer";
			import \{ createStore \} from "../../..";
			import \{ Provider \} from "@frontity/connect";
			import Slot from "../slot";
			
			/**
			 * This is a type guard for app.toJSON(), because it can return either a
			 * ReactTestRendererJSON or a ReactTestRendererJSON[] and TypeScript doesn't
			 * know which one is it.
			 *
			 * When we use this function, we know it is a ReactTestRendererJSON and
			 * therefore we want to access its properties, like \`app.toJSON().children\` or
			 * \`app.toJSON().props\`.
			 *
			 * @param app - The app generated by \`create\`.
			 *
			 * @returns The result of app.toJSON() but making sure it's not an array.
			 */
			export const toJson = (app: ReactTestRenderer): ReactTestRendererJSON => \{
			  if (!Array.isArray(app.toJSON()))
			    return app.toJSON() as ReactTestRendererJSON;
			  throw new Error("Please use the toJsonArray function instead.");
			\};
			
			/**
			 * This is a type guard for app.toJSON(), because it can return either a
			 * ReactTestRendererJSON or a ReactTestRendererJSON[] and TypeScript doesn't
			 * know which one is it.
			 *
			 * When we use this function, we know it is a ReactTestRendererJSON[] and
			 * therefore we want to access its elements, like \`app.toJSON()[0].props\`.
			 *
			 * @param app - The app generated by \`create\`.
			 *
			 * @returns The result of app.toJSON() but making sure it's an array.
			 */
			export const toJsonArray = (
			  app: ReactTestRenderer
			): ReactTestRendererJSON[] => \{
			  if (Array.isArray(app.toJSON()))
			    return app.toJSON() as ReactTestRendererJSON[];
			  throw new Error("Please use the toJson function instead.");
			\};
			
			let store;
			
			const SimpleFill = () => <div>Im a Fill</div>;
			const DataFill = (\{ data \}) => <div>\{data\}</div>;
			const PropFill = (\{ whateverProp \}) => <div>\{whateverProp\}</div>;
			const AllPropsFill = (allProps) => (
			  <div>\{JSON.stringify(allProps, null, 2)\}</div>
			);
			
			beforeEach(() => \{
			  store = createStore(\{
			    state: \{
			      source: \{
			        get: jest.fn(() => () => "This would normally be data for this route"),
			      \},
			      router: \{\},
			      fills: \{
			        namespace1: \{
			          "simple fill": \{
			            slot: "slot 1",
			            library: "namespace1.SimpleFill",
			          \},
			          "fill with data": \{
			            slot: "slot 2",
			            library: "namespace1.DataFill",
			          \},
			          "fill with a prop": \{
			            slot: "slot 3",
			            library: "namespace1.PropFill",
			          \},
			          "fill with overriden prop": \{
			            slot: "slot 4",
			            library: "namespace1.PropFill",
			            props: \{
			              whateverProp: "This should render instead",
			            \},
			          \},
			          "fill 5.1": \{
			            slot: "slot 5",
			            library: "namespace1.AllPropsFill",
			          \},
			          "fill 5.2": \{
			            slot: "slot 5",
			            library: "namespace1.AllPropsFill",
			          \},
			        \},
			      \},
			    \},
			    libraries: \{
			      fills: \{
			        namespace1: \{
			          SimpleFill,
			          DataFill,
			          PropFill,
			          AllPropsFill,
			        \},
			      \},
			    \},
			  \});
			\});
			
			describe("Slot", () => \{
			  it("should work in the most basic case", () => \{
			    const app = create(
			      <Provider value=\{store\}>
			        <Slot name="slot 1" />
			      </Provider>
			    );
			
			    expect(toJson(app).children[0]).toEqual("Im a Fill");
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should render children as a fallback", () => \{
			    const app = create(
			      <Provider value=\{store\}>
			        <Slot name="this slot does not exist">fallback</Slot>
			      </Provider>
			    );
			
			    expect(toJson(app)).toEqual("fallback");
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should read the data from state.source and pass it to the Fill", () => \{
			    const app = create(
			      <Provider value=\{store\}>
			        <Slot name="slot 2" />
			      </Provider>
			    );
			
			    expect(toJson(app).children[0]).toEqual(
			      "This would normally be data for this route"
			    );
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should pass the data prop to the Fill", () => \{
			    const app = create(
			      <Provider value=\{store\}>
			        <Slot name="slot 2" data=\{"Data passed as prop"\} />
			      </Provider>
			    );
			
			    expect(toJson(app).children[0]).toEqual("Data passed as prop");
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should pass any other extra prop to the Fill", () => \{
			    const app = create(
			      <Provider value=\{store\}>
			        <Slot name="slot 3" whateverProp=\{"Data passed as prop"\} />
			      </Provider>
			    );
			
			    expect(toJson(app).children[0]).toEqual("Data passed as prop");
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should override the prop provided by the theme creator with the one given by the user", () => \{
			    const app = create(
			      <Provider value=\{store\}>
			        <Slot name="slot 4" whateverProp=\{"This should NOT render"\} />
			      </Provider>
			    );
			
			    expect(toJson(app).children[0]).toEqual("This should render instead");
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should render 2 elements with all props", () => \{
			    const app = create(
			      <Provider value=\{store\}>
			        <Slot name="slot 5" />
			      </Provider>
			    );
			
			    expect(toJsonArray(app).length).toEqual(2); // We render 2 elements
			    expect(toJsonArray(app)).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\utils\\slot-and-fill\\__tests__\\slot.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\packages\\frontity\\src\\utils\\slot-and-fill\\__tests__\\use-fills.test.tsx', () => {
        const sourceCode = `
			import \{ create, act \} from "react-test-renderer";
			import \{ createStore, connect \} from "../../..";
			import \{ Provider \} from "@frontity/connect";
			import useFills from "../use-fills";
			import \{ toJson, toJsonArray \} from "./slot.tests";
			
			let store;
			
			// Spy on the console.warn calls
			const warn = jest.spyOn(global.console, "warn");
			
			const FillComponent = (\{ name, number \}) => (
			  <div id="test-fill" data-number=\{number\} data-name=\{name\}>
			    Im a Fill
			  </div>
			);
			
			beforeEach(() => \{
			  warn.mockClear();
			
			  store = createStore(\{
			    actions: \{
			      fillActions: \{
			        setNumber: (\{ state \}) => (number: number) => \{
			          state.fills.namespace1["test fill 1"].props.number = number;
			        \},
			      \},
			    \},
			    state: \{
			      fills: \{
			        namespace1: \{
			          "test fill 1": \{
			            slot: "slot 1",
			            library: "namespace1.FillComponent",
			            props: \{
			              number: 1,
			            \},
			          \},
			          "test fill 2": \{
			            slot: "slot 2",
			            library: "namespace1.FillComponent",
			          \},
			        \},
			        namespace2: \{
			          "test fill 3": \{
			            slot: "slot 3",
			            library: "namespace2.FillComponent",
			            priority: 1,
			            props: \{
			              number: 3,
			            \},
			          \},
			        \},
			      \},
			    \},
			    libraries: \{
			      fills: \{
			        namespace1: \{
			          FillComponent,
			        \},
			        namespace2: \{
			          FillComponent,
			        \},
			      \},
			    \},
			  \});
			\});
			
			describe("useFills", () => \{
			  it("should work in the most basic case", () => \{
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(toJson(app).props).toEqual(\{
			      id: "test-fill",
			      "data-number": 1,
			      "data-name": "namespace1 - test fill 1",
			    \});
			    expect(toJson(app).children[0]).toEqual("Im a Fill");
			
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should work when the slot does not exist", () => \{
			    const Comp = connect(() => \{
			      const fills = useFills("slot that does not exist");
			
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should remind to specify the slot name if called without arguments", () => \{
			    const warn = jest.spyOn(global.console, "warn");
			
			    const Comp = connect(() => \{
			      // This is just to trick typescript to allow us to call
			      // useFills without any arguments
			      const useFills2: any = useFills;
			      const fills = useFills2();
			
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(warn.mock.calls[0][0]).toMatch(
			      "You should pass the name of the slot that you would like to fill!"
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should warn when the Fill component is not found in libraries", () => \{
			    const warn = jest.spyOn(global.console, "warn");
			
			    const Comp = connect(() => \{
			      // This is just to trick typescript to allow us to call
			      // useFills without any arguments
			      const useFills2: any = useFills;
			      const fills = useFills2();
			
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(warn.mock.calls[0][0]).toMatch(
			      "You should pass the name of the slot that you would like to fill!"
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should not return the fill when library is not specified", () => \{
			    delete store.state.fills.namespace1["test fill 1"].library;
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should not return the fill when library doesn't match a component in libraries", () => \{
			    store.state.fills.namespace1["test fill 1"].library = "FillComponent";
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should not return the fill when the slot is not specified", () => \{
			    delete store.state.fills.namespace1["test fill 1"].slot;
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should work when \`state.fills\` is missing", () => \{
			    delete store.state.fills;
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should work when \`state.fills\` doesn't contain any fills", () => \{
			    store.state.fills = \{\};
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			      expect(fills).toEqual([]);
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    expect(toJson(app)).toEqual(null);
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should re-render the fill when updating the props", () => \{
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    act(() => \{
			      store.actions.fillActions.setNumber(43);
			    \});
			
			    expect(toJson(app).props).toEqual(\{
			      id: "test-fill",
			      "data-number": 43,
			      "data-name": "namespace1 - test fill 1",
			    \});
			    expect(toJson(app).children[0]).toEqual("Im a Fill");
			
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should render the fills in the order of priority", () => \{
			    store.state.fills.namespace2["test fill 3"].slot = "slot 1";
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    // This fill should come first
			    expect(toJsonArray(app)[0].props).toEqual(\{
			      id: "test-fill",
			      "data-number": 3,
			      "data-name": "namespace2 - test fill 3",
			    \});
			
			    // This fill should come second
			    expect(toJsonArray(app)[1].props).toEqual(\{
			      id: "test-fill",
			      "data-number": 1,
			      "data-name": "namespace1 - test fill 1",
			    \});
			
			    expect(toJsonArray(app)).toMatchSnapshot();
			  \});
			
			  it("should skip rendering the fills with value \`false\`", () => \{
			    store.state.fills.namespace2["test fill 3"].slot = "slot 1";
			    store.state.fills.namespace1["test fill 1"] = false;
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    // We should only render 1 component.
			    expect(toJson(app).props).toEqual(\{
			      id: "test-fill",
			      "data-number": 3,
			      "data-name": "namespace2 - test fill 3",
			    \});
			
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			
			  it("should render the debug slots when \`state.frontity.debug\` is true", () => \{
			    store.state.frontity = \{ debug: true \};
			
			    const Comp = connect(() => \{
			      const fills = useFills("slot 1");
			
			      return (
			        <>
			          \{fills.map((\{ Fill, props, key \}) => (
			            <Fill key=\{key\} name=\{key\} \{...props\} />
			          ))\}
			        </>
			      );
			    \});
			
			    const app = create(
			      <Provider value=\{store\}>
			        <Comp />
			      </Provider>
			    );
			
			    // We should only render 1 component.
			    expect(toJson(app).props["data-slot-name"]).toBe("slot 1");
			
			    expect(toJson(app)).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\utils\\slot-and-fill\\__tests__\\use-fills.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(13)
    });
    it('frontity_frontity\\packages\\frontity\\src\\utils\\__tests__\\is-derived.test.ts', () => {
        const sourceCode = `
			import isDerived from "../is-derived";
			import \{ createStore \} from "../../";
			
			/**
			 * A mocked package implementation.
			 */
			const packageImpl = \{
			  state: \{
			    theme: \{
			      prop: "regular prop",
			      derived: (\{ state \}) => \`not a \$\{state.theme.prop\}!\`,
			    \},
			  \},
			\};
			
			describe("isDerived", () => \{
			  it("should return \`true\` for derived props", () => \{
			    const \{ state \} = createStore(packageImpl);
			    expect(isDerived(state.theme, "derived")).toBe(true);
			  \});
			
			  it("should return \`false\` for non-derived props", () => \{
			    const \{ state \} = createStore(packageImpl);
			    expect(isDerived(state.theme, "prop")).toBe(false);
			  \});
			
			  it("should return \`false\` for derived props that were overwritten", () => \{
			    const \{ state \} = createStore(packageImpl);
			    state.theme.derived = "not anymore";
			    expect(isDerived(state.theme, "derived")).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\utils\\__tests__\\is-derived.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\packages\\frontity\\src\\utils\\__tests__\\url.test.ts', () => {
        const sourceCode = `
			import FrontityURL from "../url";
			
			describe("URL", () => \{
			  it("should work like the built-in URL", () => \{
			    const url = "https://domain.com/path?query=a";
			    expect(new FrontityURL(url)).toEqual(new URL(url));
			  \});
			
			  it("should warn with the deprecation message", () => \{
			    const warn = jest.spyOn(global.console, "warn");
			    new FrontityURL("http://domain.com");
			    expect(warn).toHaveBeenCalledTimes(1);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\utils\\__tests__\\url.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\frontity\\src\\utils\\__tests__\\utils.test.ts', () => {
        const sourceCode = `
			import \{
			  isPackageNameValid,
			  fetchPackageVersion,
			  isNamespaceValid,
			  toCamelCase,
			\} from "../";
			import * as fetch from "node-fetch";
			
			describe("isPackageNameValid", () => \{
			  describe("package.json requirements", () => \{
			    // Tests extracted from https://docs.npmjs.com/files/package.json#name
			    test("The name must be less than or equal to 214 characters", () => \{
			      const str214length = new Array(215).join("a");
			      expect(isPackageNameValid(str214length)).toBe(false);
			    \});
			    test("The name cant start with a dot", () => \{
			      const strStartWithDot = ".aaa";
			      expect(isPackageNameValid(strStartWithDot)).toBe(false);
			    \});
			    test("The name cant start with an underscore", () => \{
			      const strStartWithUnderscore = "_aaa";
			      expect(isPackageNameValid(strStartWithUnderscore)).toBe(false);
			    \});
			    test("New packages must not have uppercase letters in the name", () => \{
			      const strUppercase1 = "Aaa";
			      const strUppercase2 = "aAa";
			      const strUppercase3 = "aaA";
			      expect(isPackageNameValid(strUppercase1)).toBe(false);
			      expect(isPackageNameValid(strUppercase2)).toBe(false);
			      expect(isPackageNameValid(strUppercase3)).toBe(false);
			    \});
			    test("The name cant contain any non-URL-safe characters", () => \{
			      // Unsafe characters extracted from this site:
			      // https://perishablepress.com/stop-using-unsafe-characters-in-urls/
			      const unsafeChars = "\$+!*'(),;?:=&@/";
			      unsafeChars.split("").map((char) => \{
			        expect(isPackageNameValid(\`a\$\{char\}a\`)).toBe(false);
			      \});
			    \});
			  \});
			  describe("Unix and Windows folder name requirements", () => \{
			    test("The folder name cant contain any non-safe characters", () => \{
			      // Unsafe characters extracted from this question:
			      // https://serverfault.com/questions/242110/which-common-charecters-are-illegal-in-unix-and-windows-filesystems
			      const unsafeChars = '\\\\/:*?"<>|';
			      unsafeChars.split("").map((char) => \{
			        expect(isPackageNameValid(\`a\$\{char\}a\`)).toBe(false);
			      \});
			    \});
			  \});
			  describe("Use a valid package", () => \{
			    test("A plain name is working", () => \{
			      // Unsafe characters extracted from this question:
			      // https://serverfault.com/questions/242110/which-common-charecters-are-illegal-in-unix-and-windows-filesystems
			      expect(isPackageNameValid("frontity")).toBe(true);
			    \});
			    test("A name with dots is working", () => \{
			      // Unsafe characters extracted from this question:
			      // https://serverfault.com/questions/242110/which-common-charecters-are-illegal-in-unix-and-windows-filesystems
			      expect(isPackageNameValid("frontity.org.cool")).toBe(true);
			    \});
			    test("A name with dots and dashes is working", () => \{
			      // Unsafe characters extracted from this question:
			      // https://serverfault.com/questions/242110/which-common-charecters-are-illegal-in-unix-and-windows-filesystems
			      expect(isPackageNameValid("frontity-org.cool")).toBe(true);
			    \});
			    test("A name with more than one dash is working", () => \{
			      // Unsafe characters extracted from this question:
			      // https://serverfault.com/questions/242110/which-common-charecters-are-illegal-in-unix-and-windows-filesystems
			      expect(isPackageNameValid("frontity-org-cool")).toBe(true);
			    \});
			  \});
			\});
			
			describe("fetchPackageVersion", () => \{
			  const mockedFetch = jest.spyOn(fetch, "default");
			
			  beforeEach(() => \{
			    mockedFetch.mockReset();
			  \});
			
			  test("should return the latest version if found in the NPM registry", async () => \{
			    mockedFetch.mockResolvedValueOnce(
			      new fetch.Response(\`\{"dist-tags":\{"latest":"1.0.0"\}\}\`)
			    );
			    await expect(fetchPackageVersion("some-package")).resolves.toBe("1.0.0");
			    expect(mockedFetch).toHaveBeenCalledWith(
			      "https://registry.npmjs.com/some-package"
			    );
			  \});
			
			  test("should throw an error otherwise", async () => \{
			    mockedFetch.mockResolvedValueOnce(
			      new fetch.Response(\`\{"error":"Not found"\}\`)
			    );
			    await expect(fetchPackageVersion("non-existent")).rejects.toThrow();
			    expect(mockedFetch).toHaveBeenCalledWith(
			      "https://registry.npmjs.com/non-existent"
			    );
			  \});
			\});
			
			describe("Namespace", () => \{
			  test("isNamespaceValid", () => \{
			    expect(isNamespaceValid("namespace")).toBe(true);
			    expect(isNamespaceValid("namespaceCamelCasedItsFine")).toBe(true);
			    expect(isNamespaceValid("namespace-dash-separated")).toBe(false);
			    expect(isNamespaceValid("namespace-Dash-Separated-with-UpperCased")).toBe(
			      false
			    );
			  \});
			  test("toCamelCase", () => \{
			    // These should not get transformed since they do not contain invalid chars
			    expect(toCamelCase("namespace")).toBe("namespace");
			    expect(toCamelCase("namespaceCamelCasedItsFine")).toBe(
			      "namespaceCamelCasedItsFine"
			    );
			
			    // The next two should be converted to camelCase
			    expect(toCamelCase("namespace-dash-separated")).toBe(
			      "namespaceDashSeparated"
			    );
			    expect(toCamelCase("namespace-Dash-Separated-with-UpperCased")).toBe(
			      "namespaceDashSeparatedWithUpperCased"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\frontity\\src\\utils\\__tests__\\utils.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(14)
    });
    it('frontity_frontity\\packages\\google-ad-manager\\src\\components\\__tests__\\google-publisher-tag.test.tsx', () => {
        const sourceCode = `
			import TestRenderer from "react-test-renderer";
			import GooglePublisherTag from "../google-publisher-tag";
			
			describe("GooglePublisherTag", () => \{
			  test("should use \`id\` as the container ID if data is not specified", () => \{
			    const gpt = TestRenderer.create(
			      <GooglePublisherTag
			        id="gpt-id-123"
			        unit="/1234567/sport/"
			        size=\{[320, 100]\}
			      />
			    ).toJSON();
			
			    expect(gpt).toMatchInlineSnapshot(\`
			      <div
			        className="css-urmuyr-GooglePublisherTag"
			        id="gpt-id-123"
			      />
			    \`);
			  \});
			
			  test("should append \`link\` to the container ID if data is specified", () => \{
			    const gpt = TestRenderer.create(
			      <GooglePublisherTag
			        id="gpt-id-123"
			        unit="/1234567/sport/"
			        size=\{[320, 100]\}
			        data=\{\{ link: "/2020/08/post-with-long-link/" \}\}
			      />
			    ).toJSON();
			
			    expect(gpt).toMatchInlineSnapshot(\`
			      <div
			        className="css-urmuyr-GooglePublisherTag"
			        id="gpt-id-123_2020_08_post-with-long-link"
			      />
			    \`);
			  \});
			
			  test("should render the container with the minimum size", () => \{
			    const gpt = TestRenderer.create(
			      <GooglePublisherTag
			        id="gpt-id-123"
			        unit="/1234567/sport/"
			        size=\{[
			          [320, 100],
			          [300, 600],
			        ]\}
			      />
			    ).toJSON();
			
			    expect(gpt).toMatchInlineSnapshot(\`
			      <div
			        className="css-1o73ait-GooglePublisherTag"
			        id="gpt-id-123"
			      />
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\google-ad-manager\\src\\components\\__tests__\\google-publisher-tag.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\packages\\google-analytics\\src\\components\\__tests__\\index.test.tsx', () => {
        const sourceCode = `
			/**
			 * @jest-environment node
			 */
			
			import TestRenderer from "react-test-renderer";
			import \{ HelmetProvider \} from "frontity";
			import \{ State \} from "frontity/types";
			import \{ FilledContext \} from "react-helmet-async";
			import \{ Root as GoogleAnalytics \} from "..";
			import \{ Packages \} from "../../../types";
			
			const getState = (): State<Packages> => (\{
			  frontity: \{\},
			  analytics: \{
			    pageviews: \{ googleAnalytics: true \},
			    events: \{\},
			  \},
			  googleAnalytics: \{\},
			\});
			
			/**
			 * Render a mocked instance of the Google Analytics' root component.
			 *
			 * @param state - Frontity state object.
			 * @returns The rendered component in JSON format, along with the head
			 * attributes.
			 */
			const renderGtag = (state: State<Packages>) => \{
			  const helmetContext = \{\};
			  const rendered = TestRenderer.create(
			    <HelmetProvider context=\{helmetContext\}>
			      <GoogleAnalytics state=\{state\} actions=\{null\} libraries=\{null\} />
			    </HelmetProvider>
			  ).toJSON();
			  const head = (helmetContext as FilledContext).helmet;
			
			  return \{ rendered, head \};
			\};
			
			/**
			 * Get the AMP configuration of an \`amp-analytics\` tag. Useful for
			 * snapshot testing.
			 *
			 * @param instance - React instance in JSON format.
			 * @returns Object representing the AMP config.
			 */
			const getAmpConfig = (instance) =>
			  JSON.parse(instance.children[0].props.dangerouslySetInnerHTML.__html);
			
			describe("GoogleAnalytics", () => \{
			  it("works with a single tracking ID", () => \{
			    const state = getState();
			
			    state.googleAnalytics.trackingId = "UA-XXXXXXX-X";
			
			    const \{ head \} = renderGtag(state);
			
			    expect(head.script.toComponent()).toMatchInlineSnapshot(\`
			      Array [
			        <script
			          async=\{true\}
			          data-rh=\{true\}
			          src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXX-X"
			        />,
			        <script
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": "
			      window.dataLayer = window.dataLayer || [];
			      window.gtag = function gtag()\{dataLayer.push(arguments);\}
			      gtag('js', new Date());
			
			      gtag('config', 'UA-XXXXXXX-X');
			      ",
			            \}
			          \}
			          data-rh=\{true\}
			        />,
			      ]
			    \`);
			  \});
			
			  it("works with multiple traking IDs", () => \{
			    const state = getState();
			
			    state.googleAnalytics.trackingIds = ["UA-XXXXXXX-X", "UA-YYYYYYY-Y"];
			
			    const \{ head \} = renderGtag(state);
			
			    expect(head.script.toComponent()).toMatchInlineSnapshot(\`
			      Array [
			        <script
			          async=\{true\}
			          data-rh=\{true\}
			          src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXX-X"
			        />,
			        <script
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": "
			      window.dataLayer = window.dataLayer || [];
			      window.gtag = function gtag()\{dataLayer.push(arguments);\}
			      gtag('js', new Date());
			
			      gtag('config', 'UA-XXXXXXX-X');
			      gtag('config', 'UA-YYYYYYY-Y');
			      ",
			            \}
			          \}
			          data-rh=\{true\}
			        />,
			      ]
			    \`);
			  \});
			
			  it("doesn't add anything if there's no tracking IDs", () => \{
			    const state = getState();
			
			    const \{ head \} = renderGtag(state);
			
			    expect(head.script.toComponent()).toMatchInlineSnapshot(\`Array []\`);
			  \});
			\});
			
			describe("Google Analytics (AMP)", () => \{
			  it("works with a single tracking ID", () => \{
			    const state = getState();
			
			    state.frontity.mode = "amp";
			    state.googleAnalytics.trackingId = "UA-XXXXXXX-X";
			
			    const \{ rendered \} = renderGtag(state);
			
			    expect(rendered).toMatchInlineSnapshot(\`
			      <amp-analytics
			        data-credentials="include"
			        type="gtag"
			      >
			        <script
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": "\{\\\\"vars\\\\":\{\\\\"gtag_id\\\\":\\\\"UA-XXXXXXX-X\\\\",\\\\"config\\\\":\{\\\\"UA-XXXXXXX-X\\\\":\{\\\\"groups\\\\":\\\\"default\\\\"\}\}\}\}",
			            \}
			          \}
			          type="application/json"
			        />
			      </amp-analytics>
			    \`);
			  \});
			
			  it("only renders a single tag for multiple tracking IDs", () => \{
			    const state = getState();
			
			    state.frontity.mode = "amp";
			    state.googleAnalytics.trackingIds = ["UA-XXXXXXX-X", "UA-YYYYYYY-Y"];
			
			    const \{ rendered \} = renderGtag(state);
			
			    // The two tracking IDs should be included in \`vars.config\`.
			    expect(getAmpConfig(rendered).vars.config).toMatchInlineSnapshot(\`
			      Object \{
			        "UA-XXXXXXX-X": Object \{
			          "groups": "default",
			        \},
			        "UA-YYYYYYY-Y": Object \{
			          "groups": "default",
			        \},
			      \}
			    \`);
			  \});
			
			  it("should merge tracking IDs with the AMP config", () => \{
			    const state = getState();
			
			    state.frontity.mode = "amp";
			    state.googleAnalytics.trackingIds = ["UA-XXXXXXX-X", "UA-YYYYYYY-Y"];
			    state.googleAnalytics.ampConfig = \{
			      vars: \{
			        customVar: "customValue",
			      \},
			      triggers: \{
			        customTrigger: \{
			          on: "page-load",
			          request: "event",
			        \},
			      \},
			    \};
			
			    const \{ rendered \} = renderGtag(state);
			
			    // The two tracking IDs should be included in \`vars.config\`.
			    expect(getAmpConfig(rendered)).toMatchInlineSnapshot(\`
			      Object \{
			        "triggers": Object \{
			          "customTrigger": Object \{
			            "on": "page-load",
			            "request": "event",
			          \},
			        \},
			        "vars": Object \{
			          "config": Object \{
			            "UA-XXXXXXX-X": Object \{
			              "groups": "default",
			            \},
			            "UA-YYYYYYY-Y": Object \{
			              "groups": "default",
			            \},
			          \},
			          "customVar": "customValue",
			          "gtag_id": "UA-XXXXXXX-X",
			        \},
			      \}
			    \`);
			  \});
			
			  it("allows adding tracking IDs directly in the AMP config", () => \{
			    const state = getState();
			
			    state.frontity.mode = "amp";
			    state.googleAnalytics.trackingIds = ["UA-XXXXXXX-X", "UA-YYYYYYY-Y"];
			    state.googleAnalytics.ampConfig = \{
			      vars: \{
			        config: \{
			          "UA-ZZZZZZZ-Z": \{
			            groups: "default",
			          \},
			        \},
			      \},
			    \};
			
			    const \{ rendered \} = renderGtag(state);
			
			    expect(getAmpConfig(rendered).vars.config).toMatchInlineSnapshot(\`
			      Object \{
			        "UA-XXXXXXX-X": Object \{
			          "groups": "default",
			        \},
			        "UA-YYYYYYY-Y": Object \{
			          "groups": "default",
			        \},
			        "UA-ZZZZZZZ-Z": Object \{
			          "groups": "default",
			        \},
			      \}
			    \`);
			  \});
			
			  it("allows configuring a tracking ID in the AMP config", () => \{
			    const state = getState();
			
			    state.frontity.mode = "amp";
			    state.googleAnalytics.trackingId = "UA-XXXXXXX-X";
			    state.googleAnalytics.ampConfig = \{
			      vars: \{
			        config: \{
			          "UA-XXXXXXX-X": \{
			            linker: \{ domains: ["example.com", "example2.com"] \},
			          \},
			        \},
			      \},
			    \};
			
			    const \{ rendered \} = renderGtag(state);
			
			    expect(getAmpConfig(rendered).vars.config).toMatchInlineSnapshot(\`
			      Object \{
			        "UA-XXXXXXX-X": Object \{
			          "groups": "default",
			          "linker": Object \{
			            "domains": Array [
			              "example.com",
			              "example2.com",
			            ],
			          \},
			        \},
			      \}
			    \`);
			  \});
			
			  it("renders the \`amp-analytics\` tag if the AMP config has tracking IDs", () => \{
			    const state = getState();
			
			    state.frontity.mode = "amp";
			    state.googleAnalytics.ampConfig = \{
			      vars: \{
			        gtag_id: "UA-XXXXXXX-X",
			        config: \{
			          "UA-XXXXXXX-X": \{ groups: "default" \},
			        \},
			      \},
			    \};
			
			    const \{ rendered \} = renderGtag(state);
			
			    expect(rendered).toMatchInlineSnapshot(\`
			      <amp-analytics
			        data-credentials="include"
			        type="gtag"
			      >
			        <script
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": "\{\\\\"vars\\\\":\{\\\\"gtag_id\\\\":\\\\"UA-XXXXXXX-X\\\\",\\\\"config\\\\":\{\\\\"UA-XXXXXXX-X\\\\":\{\\\\"groups\\\\":\\\\"default\\\\"\}\}\}\}",
			            \}
			          \}
			          type="application/json"
			        />
			      </amp-analytics>
			    \`);
			  \});
			\});
			
			it("doesn't add anything if there's neither tracking IDs nor AMP config", () => \{
			  const warn = jest.spyOn(global.console, "warn");
			  const state = getState();
			
			  state.frontity.mode = "amp";
			
			  const \{ rendered \} = renderGtag(state);
			
			  expect(rendered).toMatchInlineSnapshot(\`null\`);
			  expect(warn.mock.calls[0][0]).toMatchInlineSnapshot(\`
			    "No tracking ID was found neither in \\\`state.google.analytics.trackingId\\\` nor in \\\`state.google.analytics.ampConfig\\\`. The \\\`<amp-analytics>\\\` tag will not be rendered.
			    Visit https://community.frontity.org for help! 
			    "
			  \`);
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\google-analytics\\src\\components\\__tests__\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(10)
    });
    it('frontity_frontity\\packages\\google-tag-manager-analytics\\src\\components\\__tests__\\index.test.tsx', () => {
        const sourceCode = `
			/**
			 * @jest-environment node
			 */
			
			import TestRenderer from "react-test-renderer";
			import \{ HelmetProvider \} from "frontity";
			import \{ State \} from "frontity/types";
			import \{ FilledContext \} from "react-helmet-async";
			import \{ Root as GoogleTagManager \} from "..";
			import \{ Packages \} from "../../../types";
			
			const getState = (): State<Packages> => (\{
			  frontity: \{\},
			  analytics: \{
			    pageviews: \{ googleTagManagerAnalytics: true \},
			    events: \{\},
			  \},
			  googleTagManagerAnalytics: \{\},
			\});
			
			/**
			 * Render a mocked instance of the Google Tag Manager's root component.
			 *
			 * @param state - Frontity state object.
			 * @returns The rendered component in JSON format, along with the head
			 * attributes.
			 */
			const renderGTM = (state: State<Packages>) => \{
			  const helmetContext = \{\};
			  const rendered = TestRenderer.create(
			    <HelmetProvider context=\{helmetContext\}>
			      <GoogleTagManager state=\{state\} actions=\{null\} libraries=\{null\} />
			    </HelmetProvider>
			  ).toJSON();
			  const head = (helmetContext as FilledContext).helmet;
			
			  return \{ rendered, head \};
			\};
			
			describe("GoogleTagManager", () => \{
			  test("works with a single container id", () => \{
			    // Instantiate the Frontity state and specify the \`containerId\` prop.
			    const state = getState();
			    state.googleTagManagerAnalytics.containerId = "GTM-XXXXXXX";
			
			    // Render the GTM's root component.
			    const \{ rendered, head \} = renderGTM(state);
			
			    // The GTM's script library with the specified container ID should have been
			    // rendered, an also an inline script that adds the \`gtm.start\` event.
			    expect(head.script.toComponent()).toMatchInlineSnapshot(\`
			      Array [
			        <script
			          async=\{true\}
			          data-rh=\{true\}
			          src="https://www.googletagmanager.com/gtm.js?id=GTM-XXXXXXX"
			        />,
			        <script
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": "
			              var dataLayer = window.dataLayer || [];
			              dataLayer.push(\{
			                \\\\"gtm.start\\\\": new Date().getTime(),
			                event: \\\\"gtm.js\\\\",
			              \})
			              ",
			            \}
			          \}
			          data-rh=\{true\}
			        />,
			      ]
			    \`);
			
			    // A \`<noscript>\` tag with an \`<iframe>\` should be rendered as well, to make
			    // GTM work when JS is not available.
			    expect(rendered).toMatchInlineSnapshot(\`
			      <noscript>
			        <style
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": ".css-llz5b9-GtmCode\{display:none;visibility:hidden;\}",
			            \}
			          \}
			          data-emotion="css llz5b9-GtmCode"
			        />
			        <iframe
			          className="css-llz5b9-GtmCode"
			          height="0"
			          src="https://www.googletagmanager.com/ns.html?id=GTM-XXXXXXX"
			          title="GTM-XXXXXXX"
			          width="0"
			        />
			      </noscript>
			    \`);
			  \});
			
			  test("works with multiple container ids", () => \{
			    // Instantiate the Frontity state and specify the \`containerIds\` array prop.
			    const state = getState();
			
			    state.googleTagManagerAnalytics.containerIds = [
			      "GTM-XXXXXXX",
			      "GTM-YYYYYYY",
			    ];
			
			    // Render the GTM's root component.
			    const \{ rendered, head \} = renderGTM(state);
			
			    // The GTM's script library should have been rendered twice, one for each
			    // container ID specified. The inline script pushing the \`gtm.start\` event
			    // should be rendered once.
			    expect(head.script.toComponent()).toMatchInlineSnapshot(\`
			      Array [
			        <script
			          async=\{true\}
			          data-rh=\{true\}
			          src="https://www.googletagmanager.com/gtm.js?id=GTM-XXXXXXX"
			        />,
			        <script
			          async=\{true\}
			          data-rh=\{true\}
			          src="https://www.googletagmanager.com/gtm.js?id=GTM-YYYYYYY"
			        />,
			        <script
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": "
			              var dataLayer = window.dataLayer || [];
			              dataLayer.push(\{
			                \\\\"gtm.start\\\\": new Date().getTime(),
			                event: \\\\"gtm.js\\\\",
			              \})
			              ",
			            \}
			          \}
			          data-rh=\{true\}
			        />,
			      ]
			    \`);
			
			    // Two \`<noscript>\` elements should have been rendered this time, one for
			    // each container ID.
			    expect(rendered).toMatchInlineSnapshot(\`
			      Array [
			        <noscript>
			          <style
			            dangerouslySetInnerHTML=\{
			              Object \{
			                "__html": ".css-llz5b9-GtmCode\{display:none;visibility:hidden;\}",
			              \}
			            \}
			            data-emotion="css llz5b9-GtmCode"
			          />
			          <iframe
			            className="css-llz5b9-GtmCode"
			            height="0"
			            src="https://www.googletagmanager.com/ns.html?id=GTM-XXXXXXX"
			            title="GTM-XXXXXXX"
			            width="0"
			          />
			        </noscript>,
			        <noscript>
			          <style
			            dangerouslySetInnerHTML=\{
			              Object \{
			                "__html": ".css-llz5b9-GtmCode\{display:none;visibility:hidden;\}",
			              \}
			            \}
			            data-emotion="css llz5b9-GtmCode"
			          />
			          <iframe
			            className="css-llz5b9-GtmCode"
			            height="0"
			            src="https://www.googletagmanager.com/ns.html?id=GTM-YYYYYYY"
			            title="GTM-YYYYYYY"
			            width="0"
			          />
			        </noscript>,
			      ]
			    \`);
			  \});
			
			  test("doesn't add anything if there's no container ids", () => \{
			    // Instantiate the Frontity state with no container IDs.
			    const state = getState();
			
			    // Render the GTM's root component.
			    const \{ rendered, head \} = renderGTM(state);
			
			    // Nothing should be rendered this time.
			    expect(head.script.toComponent()).toMatchInlineSnapshot(\`Array []\`);
			    expect(rendered).toMatchInlineSnapshot(\`null\`);
			  \});
			\});
			
			describe("GoogleTagManager (AMP)", () => \{
			  test("works with a single container id", () => \{
			    // Instantiate the Frontity state, adding a container ID.
			    const state = getState();
			    state.frontity.mode = "amp";
			    state.googleTagManagerAnalytics.containerId = "GTM-XXXXXXX";
			
			    // Render the GTM's root component.
			    const \{ rendered \} = renderGTM(state);
			
			    // An \`<amp-analytics>\` tag should have been rendered for the given
			    // container ID.
			    expect(rendered).toMatchInlineSnapshot(\`
			      <amp-analytics
			        config="https://www.googletagmanager.com/amp.json?id=GTM-XXXXXXX;Tag Manager.url=SOURCE_URL"
			        data-credentials="include"
			      />
			    \`);
			  \});
			
			  test("works with a single container id and config", () => \{
			    // Instantiate the Frontity state, adding a container ID and a configuration
			    // object for the \`amp-analytics\` tag.
			    const state = getState();
			    state.frontity.mode = "amp";
			    state.googleTagManagerAnalytics.containerId = "GTM-XXXXXXX";
			    state.googleTagManagerAnalytics.ampConfig = \{
			      vars: \{
			        someProp: "someValue",
			      \},
			    \};
			
			    // Render the GTM's root component.
			    const \{ rendered \} = renderGTM(state);
			
			    // If the \`ampConfig\` prop is set, the value should have been included as a
			    // JSON script inside the \`amp-analytics\` tag.
			    expect(rendered).toMatchInlineSnapshot(\`
			      <amp-analytics
			        config="https://www.googletagmanager.com/amp.json?id=GTM-XXXXXXX;Tag Manager.url=SOURCE_URL"
			        data-credentials="include"
			      >
			        <script
			          dangerouslySetInnerHTML=\{
			            Object \{
			              "__html": "\{\\\\"vars\\\\":\{\\\\"someProp\\\\":\\\\"someValue\\\\"\}\}",
			            \}
			          \}
			          type="application/json"
			        />
			      </amp-analytics>
			    \`);
			  \});
			
			  test("works with multiple container ids", () => \{
			    // Instantiate the Frontity state, adding two container IDs.
			    const state = getState();
			    state.frontity.mode = "amp";
			    state.googleTagManagerAnalytics.containerIds = [
			      "GTM-XXXXXXX",
			      "GTM-YYYYYYY",
			    ];
			
			    // Render the GTM's root component.
			    const \{ rendered \} = renderGTM(state);
			
			    // Two \`<amp-analytics>\` tags should have been rendered, one for each given
			    // container ID.
			    expect(rendered).toMatchInlineSnapshot(\`
			      Array [
			        <amp-analytics
			          config="https://www.googletagmanager.com/amp.json?id=GTM-XXXXXXX;Tag Manager.url=SOURCE_URL"
			          data-credentials="include"
			        />,
			        <amp-analytics
			          config="https://www.googletagmanager.com/amp.json?id=GTM-YYYYYYY;Tag Manager.url=SOURCE_URL"
			          data-credentials="include"
			        />,
			      ]
			    \`);
			  \});
			
			  test("works with multiple container ids and config", () => \{
			    // Instantiate the Frontity state, adding two container IDs and a config
			    // object for the \`amp-analytics\` tags.
			    const state = getState();
			    state.frontity.mode = "amp";
			    state.googleTagManagerAnalytics.containerIds = [
			      "GTM-XXXXXXX",
			      "GTM-YYYYYYY",
			    ];
			    state.googleTagManagerAnalytics.ampConfig = \{
			      vars: \{
			        someProp: "someValue",
			      \},
			    \};
			
			    // Render the GTM's root component.
			    const \{ rendered \} = renderGTM(state);
			
			    // Two \`<amp-analytics>\` tags should have been rendered, one for each given
			    // container ID, and both sharing the same configuration object.
			    expect(rendered).toMatchInlineSnapshot(\`
			      Array [
			        <amp-analytics
			          config="https://www.googletagmanager.com/amp.json?id=GTM-XXXXXXX;Tag Manager.url=SOURCE_URL"
			          data-credentials="include"
			        >
			          <script
			            dangerouslySetInnerHTML=\{
			              Object \{
			                "__html": "\{\\\\"vars\\\\":\{\\\\"someProp\\\\":\\\\"someValue\\\\"\}\}",
			              \}
			            \}
			            type="application/json"
			          />
			        </amp-analytics>,
			        <amp-analytics
			          config="https://www.googletagmanager.com/amp.json?id=GTM-YYYYYYY;Tag Manager.url=SOURCE_URL"
			          data-credentials="include"
			        >
			          <script
			            dangerouslySetInnerHTML=\{
			              Object \{
			                "__html": "\{\\\\"vars\\\\":\{\\\\"someProp\\\\":\\\\"someValue\\\\"\}\}",
			              \}
			            \}
			            type="application/json"
			          />
			        </amp-analytics>,
			      ]
			    \`);
			  \});
			
			  test("doesn't add anything if there's no container ids", () => \{
			    // Instantiate the Frontity state mocking the \`amp\` package.
			    const state = getState();
			    state.frontity.mode = "amp";
			
			    // Render the GTM's root component.
			    const \{ rendered, head \} = renderGTM(state);
			
			    // Nothing should be rendered this time.
			    expect(head.script.toComponent()).toMatchInlineSnapshot(\`Array []\`);
			    expect(rendered).toMatchInlineSnapshot(\`null\`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\google-tag-manager-analytics\\src\\components\\__tests__\\index.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\packages\\head-tags\\src\\__tests__\\state.tests.ts', () => {
        const sourceCode = `
			import clone from "clone-deep";
			import merge from "deepmerge";
			import \{ State \} from "frontity/types";
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import wpSource from "@frontity/wp-source/src";
			import \{ DateData \} from "@frontity/source/types/data";
			import \{ Packages, HeadTag \} from "../../types";
			import headTagsPackage from "..";
			import \{
			  mockPostEntity,
			  mockPostType,
			  mockTaxonomy,
			  mockAuthor,
			\} from "./mocks/utils";
			
			// Spy \`console.warn\`
			const warn = jest.spyOn(global.console, "warn");
			
			// Mock Frontity state.
			let store: InitializedStore<Packages>;
			beforeEach(() => \{
			  warn.mockClear();
			
			  // Create store.
			  const config: Packages = merge(clone(wpSource()), clone(headTagsPackage));
			
			  // Mock router state.
			  config.state.router = \{ link: "/", state: \{\} \};
			  // Mock site url.
			  config.state.frontity = \{ url: "https://mars.frontity.org" \};
			  // Initialize store.
			  store = createStore(config);
			\});
			
			describe("state.headTags.get() (post entity)", () => \{
			  const setUpState = (state: State<Packages>, headTags?: HeadTag[]) => \{
			    // Populate source state.
			    const \{ post, data \} = mockPostEntity(headTags);
			    state.source.post = post;
			    state.source.data = data;
			
			    // Populate router state.
			    state.router.link = "/post-1/";
			
			    // Set the source API.
			    state.source.api = "https://test.frontity.org/wp-json";
			  \};
			
			  test("returns an empty array if \`head_tags\` is undefined", () => \{
			    const headTags = undefined;
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toEqual([]);
			  \});
			
			  test("returns elements without attributes (title)", () => \{
			    const headTags: HeadTag[] = [
			      \{ tag: "title", content: "Post 1 - Frontity" \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("returns elements without content (meta tags)", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "meta",
			        attributes: \{
			          name: "robots",
			          content:
			            "max-snippet:-1, max-image-preview:large, max-video-preview:-1",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transforms links that point to WordPress pages", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/post-1/",
			        \},
			      \},
			      \{
			        tag: "meta",
			        attributes: \{
			          property: "og:url",
			          content: "https://test.frontity.org/post-1/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "shortlink",
			          href: "https://test.frontity.org/?p=1",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("doesn't change links that don't point to WordPress pages", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "meta",
			        attributes: \{
			          property: "og:image",
			          content:
			            "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			        \},
			      \},
			      \{
			        tag: "meta",
			        attributes: \{
			          name: "twitter:image",
			          content:
			            "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "dns-prefetch",
			          href: "//s.w.org",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Feed",
			          href: "https://test.frontity.org/feed/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Comments Feed",
			          href: "https://test.frontity.org/comments/feed/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Post 1 Comments Feed",
			          href: "https://test.frontity.org/post-1/feed/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "EditURI",
			          type: "application/rsd+xml",
			          title: "RSD",
			          href: "https://test.frontity.org/xmlrpc.php?rsd",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "wlwmanifest",
			          type: "application/wlwmanifest+xml",
			          href: "https://test.frontity.org/wp-includes/wlwmanifest.xml",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/json+oembed",
			          href:
			            "https://test.frontity.org/wp-json/oembed/1.0/embed?url=http%3A%2F%2Ftest.frontity.org%2Fpost-1%2F",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "text/xml+oembed",
			          href:
			            "https://test.frontity.org/wp-json/oembed/1.0/embed?url=http%3A%2F%2Ftest.frontity.org%2Fpost-1%2F&format=xml",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "pingback",
			          href: "https://test.frontity.org/xmlrpc.php",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transform links inside ld+json data", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			          class: "yoast-schema-graph yoast-schema-graph--main",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change...
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			              potentialAction: \{
			                "@type": "SearchAction",
			                target: "https://test.frontity.org/?s=\{search_term_string\}",
			              \},
			            \},
			            \{
			              "@type": "ImageObject",
			              "@id": "https://test.frontity.org/post-1/#primaryimage",
			              // ...except this one.
			              url:
			                "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transforms links appropiately when WP is in a subdirectory", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/subdir/post-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/subdir/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/subdir/#website",
			              url: "https://test.frontity.org/subdir/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Change API prop
			    store.state.source.api = "https://test.frontity.org/subdir/wp-json/";
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transforms links appropiately when Frontity is in a subdirectory", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/subdir/post-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/subdir/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/subdir/#website",
			              url: "https://test.frontity.org/subdir/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Change API and Frontity URL prop
			    store.state.frontity.url = "https://frontity.org/mars/";
			    store.state.source.api = "https://test.frontity.org/subdir/wp-json/";
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("shows a warning message if \`state.frontity.url\` is not defined", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/subdir/post-1/", // should change
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Remove \`state.frontity.url\`.
			    delete store.state.frontity.url;
			
			    const warn = jest.spyOn(global.console, "warn");
			
			    // Test current head tags.
			    store.state.headTags.get(store.state.router.link);
			
			    expect(warn).toHaveBeenCalled();
			    expect(warn.mock.calls).toMatchSnapshot();
			  \});
			
			  test('shows a warning message if a <script type="ld+json"> could not be parsed', () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: \`\{
			  "@context": "https://schema.org",
			  "@graph": [
			    \{
			      "@type": "WebPage",
			      "@id": "https://test.frontity.org/wrong-title/#webpage",
			      "url": "https://test.frontity.org/wrong-title/",
			      "inLanguage": "en-US",
			      "name": "Wrong title with "quotes" - frontity",
			      "isPartOf": \{
			        "@id": "https://test.frontity.org/#website"
			      \}
			    \}
			  ]
			\}\`,
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Test current head tags.
			    store.state.headTags.get(store.state.router.link);
			
			    expect(warn).toHaveBeenCalled();
			    expect(warn.mock.calls).toMatchSnapshot();
			  \});
			
			  test("doesn't transform links if \`state.headTags.transformLinks\` = false", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/post-1/", // should not change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should not change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`transformLinks\` to false.
			    store.state.headTags.transformLinks = false;
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("doesn't transform links if \`source.api\` and \`frontity.url\` are the same site", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/post-1/", // should not change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should not change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`frontity.url\` to the same site.
			    store.state.frontity.url = "https://test.frontity.org/";
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transform links using a custom \`base\` value", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://different.frontity.org/blog/post-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://different.frontity.org/blog/#website",
			              url: "https://different.frontity.org/blog/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`transformLinks\` to false.
			    const \{ transformLinks \} = store.state.headTags;
			    if (transformLinks)
			      transformLinks.base = "https://different.frontity.org/blog/";
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transform links using a custom \`ignore\` value", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "meta",
			        attributes: \{
			          name: "twitter:image",
			          // should change
			          content:
			            "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Feed",
			          // SHOULD NOT CHANGE
			          href: "https://test.frontity.org/do-not-change/me/",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`transformLinks\` to false.
			    const \{ transformLinks \} = store.state.headTags;
			    if (transformLinks) \{
			      transformLinks.base = "https://test.frontity.org/";
			      transformLinks.ignore = "do\\\\-not\\\\-change";
			    \}
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			\});
			
			describe("state.headTags.get() (post entity, using \`state.source.url\`)", () => \{
			  const setUpState = (state: State<Packages>, headTags?: HeadTag[]) => \{
			    // Populate source state.
			    const \{ post, data \} = mockPostEntity(headTags);
			    state.source.post = post;
			    state.source.data = data;
			
			    // Populate router state.
			    state.router.link = "/post-1/";
			
			    // Set the source URL.
			    state.source.url = "https://test.frontity.org/";
			  \};
			
			  test("returns an empty array if \`head_tags\` is undefined", () => \{
			    const headTags = undefined;
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toEqual([]);
			  \});
			
			  test("returns elements without attributes (title)", () => \{
			    const headTags: HeadTag[] = [
			      \{ tag: "title", content: "Post 1 - Frontity" \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("returns elements without content (meta tags)", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "meta",
			        attributes: \{
			          name: "robots",
			          content:
			            "max-snippet:-1, max-image-preview:large, max-video-preview:-1",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transforms links that point to WordPress pages", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/post-1/",
			        \},
			      \},
			      \{
			        tag: "meta",
			        attributes: \{
			          property: "og:url",
			          content: "https://test.frontity.org/post-1/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "shortlink",
			          href: "https://test.frontity.org/?p=1",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("doesn't change links that don't point to WordPress pages", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "meta",
			        attributes: \{
			          property: "og:image",
			          content:
			            "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			        \},
			      \},
			      \{
			        tag: "meta",
			        attributes: \{
			          name: "twitter:image",
			          content:
			            "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "dns-prefetch",
			          href: "//s.w.org",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Feed",
			          href: "https://test.frontity.org/feed/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Comments Feed",
			          href: "https://test.frontity.org/comments/feed/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Post 1 Comments Feed",
			          href: "https://test.frontity.org/post-1/feed/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "EditURI",
			          type: "application/rsd+xml",
			          title: "RSD",
			          href: "https://test.frontity.org/xmlrpc.php?rsd",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "wlwmanifest",
			          type: "application/wlwmanifest+xml",
			          href: "https://test.frontity.org/wp-includes/wlwmanifest.xml",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/json+oembed",
			          href:
			            "https://test.frontity.org/wp-json/oembed/1.0/embed?url=http%3A%2F%2Ftest.frontity.org%2Fpost-1%2F",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "text/xml+oembed",
			          href:
			            "https://test.frontity.org/wp-json/oembed/1.0/embed?url=http%3A%2F%2Ftest.frontity.org%2Fpost-1%2F&format=xml",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "pingback",
			          href: "https://test.frontity.org/xmlrpc.php",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transform links inside ld+json data", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			          class: "yoast-schema-graph yoast-schema-graph--main",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change...
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			              potentialAction: \{
			                "@type": "SearchAction",
			                target: "https://test.frontity.org/?s=\{search_term_string\}",
			              \},
			            \},
			            \{
			              "@type": "ImageObject",
			              "@id": "https://test.frontity.org/post-1/#primaryimage",
			              // ...except this one.
			              url:
			                "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transforms links appropiately when WP is in a subdirectory", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/subdir/post-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/subdir/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/subdir/#website",
			              url: "https://test.frontity.org/subdir/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Change URL prop
			    store.state.source.url = "https://test.frontity.org/subdir/";
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transforms links appropiately when Frontity is in a subdirectory", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/subdir/post-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/subdir/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/subdir/#website",
			              url: "https://test.frontity.org/subdir/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Change API and Frontity URL prop
			    store.state.frontity.url = "https://frontity.org/mars/";
			    store.state.source.url = "https://test.frontity.org/subdir/";
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("shows a warning message if \`state.frontity.url\` is not defined", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/subdir/post-1/", // should change
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Remove \`state.frontity.url\`.
			    delete store.state.frontity.url;
			
			    const warn = jest.spyOn(global.console, "warn");
			
			    // Test current head tags.
			    store.state.headTags.get(store.state.router.link);
			
			    expect(warn).toHaveBeenCalled();
			    expect(warn.mock.calls).toMatchSnapshot();
			  \});
			
			  test('shows a warning message if a <script type="ld+json"> could not be parsed', () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: \`\{
			  "@context": "https://schema.org",
			  "@graph": [
			    \{
			      "@type": "WebPage",
			      "@id": "https://test.frontity.org/wrong-title/#webpage",
			      "url": "https://test.frontity.org/wrong-title/",
			      "inLanguage": "en-US",
			      "name": "Wrong title with "quotes" - frontity",
			      "isPartOf": \{
			        "@id": "https://test.frontity.org/#website"
			      \}
			    \}
			  ]
			\}\`,
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Test current head tags.
			    store.state.headTags.get(store.state.router.link);
			
			    expect(warn).toHaveBeenCalled();
			    expect(warn.mock.calls).toMatchSnapshot();
			  \});
			
			  test("doesn't transform links if \`state.headTags.transformLinks\` = false", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/post-1/", // should not change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should not change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`transformLinks\` to false.
			    store.state.headTags.transformLinks = false;
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("doesn't transform links if \`source.url\` and \`frontity.url\` are the same site", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/post-1/", // should not change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should not change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`frontity.url\` to the same site.
			    store.state.frontity.url = store.state.source.url;
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transform links using a custom \`base\` value", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://different.frontity.org/blog/post-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://different.frontity.org/blog/#website",
			              url: "https://different.frontity.org/blog/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`transformLinks\` to false.
			    const \{ transformLinks \} = store.state.headTags;
			    if (transformLinks)
			      transformLinks.base = "https://different.frontity.org/blog/";
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			
			  test("transform links using a custom \`ignore\` value", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "meta",
			        attributes: \{
			          name: "twitter:image",
			          // should change
			          content:
			            "https://test.frontity.org/wp-content/uploads/2019/12/img.jpg",
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "alternate",
			          type: "application/rss+xml",
			          title: "frontity  Feed",
			          // SHOULD NOT CHANGE
			          href: "https://test.frontity.org/do-not-change/me/",
			        \},
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			
			    // Set \`transformLinks\` to false.
			    const \{ transformLinks \} = store.state.headTags;
			    if (transformLinks) \{
			      transformLinks.base = "https://test.frontity.org/";
			      transformLinks.ignore = "do\\\\-not\\\\-change";
			    \}
			
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			\});
			
			describe("state.headTags.get() (post type)", () => \{
			  const setUpState = (state: State<Packages>, headTags?: HeadTag[]) => \{
			    // Populate source state.
			    const \{ type, data \} = mockPostType(headTags);
			    state.source.type = type;
			    state.source.data = data;
			
			    // Populate router state.
			    state.router.link = "/";
			
			    // Set the source API.
			    state.source.api = "https://test.frontity.org/wp-json";
			  \};
			
			  test("works with post types", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "next",
			          href: "https://test.frontity.org/page/2/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			\});
			
			describe("state.headTags.get() (taxonomy)", () => \{
			  const setUpState = (state: State<Packages>, headTags?: HeadTag[]) => \{
			    // Populate source state.
			    const \{ category, data \} = mockTaxonomy(headTags);
			    state.source.category = category;
			    state.source.data = data;
			
			    // Populate router state.
			    state.router.link = "/category/cat-1/";
			
			    // Set the source API.
			    state.source.api = "https://test.frontity.org/wp-json";
			  \};
			
			  test("works with taxonomies", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/category/cat-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "next",
			          href: "https://test.frontity.org/category/cat-1/page/2/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			\});
			
			describe("state.headTags.get() (author)", () => \{
			  const setUpState = (state: State<Packages>, headTags?: HeadTag[]) => \{
			    // Populate source state.
			    const \{ author, data \} = mockAuthor(headTags);
			    state.source.author = author;
			    state.source.data = data;
			
			    // Populate router state.
			    state.router.link = "/author/author-1/";
			
			    // Set the source API.
			    state.source.api = "https://test.frontity.org/wp-json";
			  \};
			
			  test("works with auhors", () => \{
			    const headTags: HeadTag[] = [
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "canonical",
			          href: "https://test.frontity.org/author/author-1/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "next",
			          href: "https://test.frontity.org/author/author-1/page/2/", // should change
			        \},
			      \},
			      \{
			        tag: "link",
			        attributes: \{
			          rel: "https://api.w.org/",
			          href: "https://test.frontity.org/wp-json/", // should not change
			        \},
			      \},
			      \{
			        tag: "script",
			        attributes: \{
			          type: "application/ld+json",
			        \},
			        content: JSON.stringify(\{
			          "@context": "https://schema.org",
			          "@graph": [
			            \{
			              // All these links should change
			              "@type": "WebSite",
			              "@id": "https://test.frontity.org/#website",
			              url: "https://test.frontity.org/",
			            \},
			          ],
			        \}),
			      \},
			    ];
			    // Populate all state.
			    setUpState(store.state, headTags);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			\});
			
			describe("state.headTags.get() (no entity)", () => \{
			  const setUpState = (state: State<Packages>) => \{
			    // Populate source state.
			    state.source.data = \{
			      "/2019/12/": \{
			        items: [],
			        isArchive: true,
			        isDate: true,
			        year: 2019,
			        month: 12,
			        day: undefined,
			        isFetching: false,
			        isReady: true,
			        link: "/2019/12/",
			        route: "/2019/12/",
			        query: \{\},
			        page: 1,
			      \} as DateData,
			    \};
			
			    // Populate router state.
			    state.router.link = "/2019/12/";
			  \};
			
			  test("returns an empty array if there is no entity for current link", () => \{
			    // Populate all state.
			    setUpState(store.state);
			    // Test current head tags.
			    expect(store.state.headTags.get(store.state.router.link)).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\head-tags\\src\\__tests__\\state.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(32)
    });
    it('frontity_frontity\\packages\\hooks\\use-archive-infinite-scroll\\__tests__\\types.test.tsx', () => {
        const sourceCode = `
			import useArchiveInfiniteScroll from "../";
			
			() => \{
			  useArchiveInfiniteScroll();
			
			  useArchiveInfiniteScroll(\{\});
			
			  useArchiveInfiniteScroll(\{
			    limit: 1,
			    active: false,
			    fetchInViewOptions: \{
			      root: null,
			      rootMargin: "",
			      threshold: 1,
			      triggerOnce: true,
			    \},
			    routeInViewOptions: \{
			      root: document.createElement("div"),
			      rootMargin: "",
			      threshold: 0.5,
			      triggerOnce: false,
			    \},
			  \});
			
			  return null;
			\};
			
			//eslint-disable-next-line @typescript-eslint/no-empty-function
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-archive-infinite-scroll\\__tests__\\types.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\hooks\\use-archive-infinite-scroll\\__tests__\\use-archive-infinite-scroll.test.tsx', () => {
        const sourceCode = `
			import React from "react";
			import \{ render \} from "react-dom";
			import clone from "clone-deep";
			import \{ act, Simulate \} from "react-dom/test-utils";
			import \{ useConnect \} from "frontity";
			import useInfiniteScroll from "../../use-infinite-scroll";
			import * as useArchiveInfiniteScroll from "../";
			
			jest.mock("../../use-infinite-scroll", () => (\{
			  __esModule: true,
			  default: jest.fn(),
			\}));
			
			jest.mock("frontity", () => (\{
			  useConnect: jest.fn(),
			  connect: jest.fn((fn) => fn),
			  css: jest.fn(),
			\}));
			
			const App = (\{ options \}: \{ options?: any \}) => \{
			  useArchiveInfiniteScroll.default(options);
			  return <div />;
			\};
			
			const AppWithButton = (\{ options \}: \{ options?: any \}) => \{
			  const \{ fetchNext \} = useArchiveInfiniteScroll.default(options);
			  return (
			    <div>
			      <button onClick=\{fetchNext\}>Fetch Next</button>
			    </div>
			  );
			\};
			
			let container: HTMLDivElement;
			
			const spiedUseArchiveInfiniteScroll = jest.spyOn(
			  useArchiveInfiniteScroll,
			  "default"
			);
			const mockedUseInfiniteScroll = useInfiniteScroll as jest.MockedFunction<
			  typeof useInfiniteScroll
			>;
			const mockedUseConnect = useConnect as jest.MockedFunction<typeof useConnect>;
			const sourceGet = jest.fn();
			const sourceFetch = jest.fn();
			const routerUpdateState = jest.fn();
			
			const browserState: \{ [key: string]: unknown; infiniteScroll?: unknown \} = \{
			  someOtherPackage: \{\},
			\};
			const initialStore = \{
			  state: \{
			    router: \{
			      link: "/",
			      state: browserState,
			    \},
			    source: \{
			      get: sourceGet,
			    \},
			  \},
			  actions: \{
			    source: \{ fetch: sourceFetch \},
			    router: \{ updateState: routerUpdateState \},
			  \},
			\};
			let store = initialStore;
			
			beforeEach(() => \{
			  store = clone(initialStore);
			  container = document.createElement("div");
			  container.id = "container";
			  document.body.appendChild(container);
			  mockedUseConnect.mockReturnValue(store);
			\});
			
			afterEach(() => \{
			  document.body.removeChild(container);
			  container = null;
			  spiedUseArchiveInfiniteScroll.mockClear();
			  mockedUseInfiniteScroll.mockReset();
			  mockedUseConnect.mockReset();
			  sourceGet.mockReset();
			  sourceFetch.mockReset();
			  routerUpdateState.mockReset();
			\});
			
			describe("useArchiveInfiniteScroll", () => \{
			  test("should update the browser state on mount (without existing state)", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        links: ["/"],
			      \},
			    \});
			  \});
			
			  test("should update the browser state on mount (with existing state)", () => \{
			    store.state.router.state.infiniteScroll = \{
			      limit: 2,
			      links: ["/", "/page/2/", "/page/3/"],
			    \};
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/3/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        limit: 2,
			        links: ["/", "/page/2/", "/page/3/"],
			      \},
			    \});
			  \});
			
			  test("should update the browser state on mount (with options)", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App options=\{\{ limit: 3 \}\} />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        limit: 3,
			        links: ["/"],
			      \},
			    \});
			  \});
			
			  test("should not update the browser state if \`options.active\` is false", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App options=\{\{ active: false \}\} />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).not.toHaveBeenCalled();
			  \});
			
			  test("should return the right object", () => \{
			    store.state.router.link = "/page/2/";
			    store.state.router.state.infiniteScroll = \{
			      links: ["/", "/page/2/", "/page/3/"],
			    \};
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/3/",
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseArchiveInfiniteScroll).toHaveReturnedWith(\{
			      pages: [
			        \{
			          key: "/",
			          link: "/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/page/2/",
			          link: "/page/2/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/page/3/",
			          link: "/page/3/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLast\` false when the last page is not ready", () => \{
			    store.state.router.link = "/page/2/";
			    store.state.router.state.infiniteScroll = \{
			      links: ["/", "/page/2/", "/page/3/"],
			    \};
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/3/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseArchiveInfiniteScroll).toHaveReturnedWith(\{
			      pages: [
			        \{
			          key: "/",
			          link: "/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/page/2/",
			          link: "/page/2/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/page/3/",
			          link: "/page/3/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` true when limit has been reached, there is next page, and it's not being fetched", () => \{
			    store.state.router.state.infiniteScroll = \{ links: ["/"] \};
			
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      next: "/page/2/",
			      isArchive: true,
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseArchiveInfiniteScroll).toHaveReturnedWith(\{
			      pages: [
			        \{
			          key: "/",
			          link: "/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: true,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` false and \`isFetching\` true when limit has been reached, there is next page but is already being fetched", () => \{
			    store.state.router.state.infiniteScroll = \{ links: ["/", "/page/2/"] \};
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/2/",
			      next: "/page/3/",
			      isArchive: true,
			      isReady: false,
			      isFetching: true,
			    \});
			
			    act(() => \{
			      render(<App options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseArchiveInfiniteScroll).toHaveReturnedWith(\{
			      pages: [
			        \{
			          key: "/",
			          link: "/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/page/2/",
			          link: "/page/2/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: true,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` false when limit has been reached but there isn't a next page", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseArchiveInfiniteScroll).toHaveReturnedWith(\{
			      pages: [
			        \{
			          key: "/",
			          link: "/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` false when the limit has not been reached", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      next: "/page/2/",
			      isArchive: true,
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App options=\{\{ limit: 3 \}\} />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseArchiveInfiniteScroll).toHaveReturnedWith(\{
			      pages: [
			        \{
			          key: "/",
			          link: "/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isError\` true when current page is unavailable", () => \{
			    store.state.router.state.infiniteScroll = \{ links: ["/", "/page/2/"] \};
			
			    sourceGet.mockReturnValue(\{
			      isReady: true,
			      isError: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUseArchiveInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseArchiveInfiniteScroll).toHaveReturnedWith(\{
			      pages: [
			        \{
			          key: "/",
			          link: "/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/page/2/",
			          link: "/page/2/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: true,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("\`fetchNext\` should fetch next page if it's not ready and not fetching", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      next: "/page/2/",
			      isArchive: true,
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<AppWithButton options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/2/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        links: ["/", "/page/2/"],
			      \},
			    \});
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/page/2/");
			  \});
			
			  test("\`fetchNext\` should not fetch next page if it's ready", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      next: "/page/2/",
			      isArchive: true,
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<AppWithButton options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/2/",
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        links: ["/", "/page/2/"],
			      \},
			    \});
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should not fetch next page if it's fetching", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      next: "/page/2/",
			      isArchive: true,
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<AppWithButton options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/2/",
			      isReady: false,
			      isFetching: true,
			    \});
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        links: ["/", "/page/2/"],
			      \},
			    \});
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should do nothing if there isn't next page", () => \{
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<AppWithButton options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/2/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should do nothing if the next page is already in the links", () => \{
			    store.state.router.state.infiniteScroll = \{
			      links: ["/page/2/", "/"],
			    \};
			
			    sourceGet.mockReturnValue(\{
			      link: "/",
			      next: "/page/2/",
			      isArchive: true,
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<AppWithButton options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockReturnValue(\{
			      link: "/page/2/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should do nothing if \`options.active\` is false", () => \{
			    store.state.router.link = "/page-one/";
			
			    sourceGet.mockReturnValue(\{
			      link: "/page-one/",
			      next: "/page-two/",
			      isArchive: true,
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<AppWithButton options=\{\{ active: false \}\} />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockReturnValue(\{
			      link: "/page-two/",
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should request the last page if \`isError\` is true", () => \{
			    store.state.router.link = "/page-one/";
			
			    sourceGet.mockReturnValue(\{
			      isReady: true,
			      isFetching: false,
			      isError: true,
			    \});
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/page-one/", \{ force: true \});
			  \});
			\});
			
			describe("Wrapper", () => \{
			  test("should return children if IntersectionObserver is not supported", () => \{
			    const Wrapper = useArchiveInfiniteScroll.wrapperGenerator(\{ link: "/" \});
			
			    sourceGet.mockReturnValue(\{
			      isReady: true,
			    \});
			
			    mockedUseInfiniteScroll.mockReturnValue(\{ supported: false \});
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should return null if the current element is not ready", () => \{
			    const Wrapper = useArchiveInfiniteScroll.wrapperGenerator(\{ link: "/" \});
			
			    sourceGet.mockReturnValue(\{
			      isReady: false,
			    \});
			
			    mockedUseInfiniteScroll.mockReturnValue(\{ supported: false \});
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should return children inside a wrapper", () => \{
			    store.state.router.state.infiniteScroll = \{ limit: 1 \};
			    const Wrapper = useArchiveInfiniteScroll.wrapperGenerator(\{ link: "/" \});
			
			    sourceGet.mockReturnValue(\{ isReady: true \});
			
			    mockedUseInfiniteScroll.mockReturnValue(\{
			      supported: true,
			      fetchRef: jest.fn(),
			      routeRef: jest.fn(),
			    \} as any);
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should return children and fetcher inside a wrapper", () => \{
			    const Wrapper = useArchiveInfiniteScroll.wrapperGenerator(\{ link: "/" \});
			
			    sourceGet.mockReturnValue(\{ isReady: true \});
			
			    mockedUseInfiniteScroll.mockReturnValue(\{
			      supported: true,
			      fetchRef: jest.fn(),
			      routeRef: jest.fn(),
			    \} as any);
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should call \`useInfiniteScroll\` with \`currentLink\` and \`nextLink\`", () => \{
			    const Wrapper = useArchiveInfiniteScroll.wrapperGenerator(\{ link: "/" \});
			
			    const firstData = \{
			      next: "/page/2/",
			      isArchive: true,
			      isReady: true,
			    \};
			    const secondData = \{
			      link: "/page/2/",
			      isReady: false,
			    \};
			
			    sourceGet
			      // The first state.source.get() of the ArchiveWrapper, which needs it to
			      // check if there is a next page.
			      .mockReturnValueOnce(firstData)
			      // The second state.source.get() of the ArchiveWrapper, which needs it to
			      // get the link of the next page.
			      .mockReturnValueOnce(secondData)
			      // The state.source.get() of the InternalWrapper, which needs it to see if
			      // the current link is ready or is an error.
			      .mockReturnValueOnce(firstData);
			
			    mockedUseInfiniteScroll.mockReturnValue(\{
			      supported: true,
			      fetchRef: jest.fn(),
			      routeRef: jest.fn(),
			    \} as any);
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledWith(\{
			      currentLink: "/",
			      nextLink: "/page/2/",
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-archive-infinite-scroll\\__tests__\\use-archive-infinite-scroll.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(23)
    });
    it('frontity_frontity\\packages\\hooks\\use-in-view\\__tests__\\use-in-view.test.tsx', () => {
        const sourceCode = `
			import ReactDOM from "react-dom";
			import \{ act \} from "react-dom/test-utils";
			import * as useInView from "../";
			
			let container: HTMLDivElement;
			
			beforeEach(() => \{
			  container = document.createElement("div");
			  document.body.appendChild(container);
			  jest.spyOn(useInView, "default");
			  Object.defineProperty(window, "IntersectionObserver", \{
			    writable: true,
			    value: jest.fn(),
			  \});
			\});
			
			afterEach(() => \{
			  document.body.removeChild(container);
			  container = null;
			\});
			
			const App = () => \{
			  useInView.default();
			  return <div />;
			\};
			
			test("useInView should return the right values if IntersectionObserver is supported", () => \{
			  act(() => \{
			    ReactDOM.render(<App />, container);
			  \});
			
			  expect(useInView.default).toHaveReturnedWith(\{
			    inView: expect.any(Boolean),
			    ref: expect.any(Function),
			    supported: true,
			  \});
			\});
			
			test("useInView should return the right values if IntersectionObserver is not supported", () => \{
			  Object.defineProperty(window, "IntersectionObserver", \{ value: undefined \});
			
			  act(() => \{
			    ReactDOM.render(<App />, container);
			  \});
			
			  expect(useInView.default).toHaveReturnedWith(\{
			    inView: true,
			    ref: undefined,
			    supported: false,
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-in-view\\__tests__\\use-in-view.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\hooks\\use-infinite-scroll\\__tests__\\types.test.tsx', () => {
        const sourceCode = `
			import useInfiniteScroll from "../";
			
			() => \{
			  useInfiniteScroll(\{
			    currentLink: "/page-one/",
			  \});
			
			  useInfiniteScroll(\{
			    currentLink: "/page-one/",
			    nextLink: "/page-two/",
			    fetchInViewOptions: \{
			      root: null,
			      rootMargin: "",
			      threshold: 1,
			      triggerOnce: true,
			    \},
			    routeInViewOptions: \{
			      root: document.createElement("div"),
			      rootMargin: "",
			      threshold: 0.5,
			      triggerOnce: false,
			    \},
			  \});
			
			  return null;
			\};
			
			//eslint-disable-next-line @typescript-eslint/no-empty-function
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-infinite-scroll\\__tests__\\types.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\hooks\\use-infinite-scroll\\__tests__\\use-infinite-scroll.test.tsx', () => {
        const sourceCode = `
			import React from "react";
			import \{ render \} from "react-dom";
			import clone from "clone-deep";
			import \{ act \} from "react-dom/test-utils";
			import \{ useConnect \} from "frontity";
			import useInView from "../../use-in-view";
			import * as useInfiniteScroll from "../../use-infinite-scroll";
			
			jest.mock("../../use-in-view", () => (\{
			  __esModule: true,
			  default: jest.fn(),
			\}));
			
			jest.mock("frontity", () => (\{
			  useConnect: jest.fn(),
			\}));
			
			const App = (\{
			  currentLink,
			  nextLink = undefined,
			  fetchInViewOptions = undefined,
			  routeInViewOptions = undefined,
			\}) => \{
			  useInfiniteScroll.default(\{
			    currentLink,
			    nextLink,
			    fetchInViewOptions,
			    routeInViewOptions,
			  \});
			  return <div />;
			\};
			
			let container: HTMLDivElement;
			
			const spiedUseInfiniteScroll = jest.spyOn(useInfiniteScroll, "default");
			const mockedUseInView = useInView as jest.MockedFunction<typeof useInView>;
			const mockedUseConnect = useConnect as jest.MockedFunction<typeof useConnect>;
			const sourceGet = jest.fn();
			const sourceFetch = jest.fn();
			const routerSet = jest.fn();
			const routerUpdateState = jest.fn();
			
			const browserState: \{ [key: string]: unknown; infiniteScroll?: unknown \} = \{
			  someOtherPackage: \{\},
			\};
			const initialStore = \{
			  state: \{
			    source: \{ get: sourceGet \},
			    router: \{ link: "/", state: browserState \},
			  \},
			  actions: \{
			    source: \{ fetch: sourceFetch \},
			    router: \{ set: routerSet, updateState: routerUpdateState \},
			  \},
			\};
			let store = initialStore;
			
			beforeEach(() => \{
			  store = clone(initialStore);
			  container = document.createElement("div");
			  document.body.appendChild(container);
			  mockedUseConnect.mockReturnValue(store);
			\});
			
			afterEach(() => \{
			  document.body.removeChild(container);
			  container = null;
			  spiedUseInfiniteScroll.mockClear();
			  mockedUseInView.mockReset();
			  mockedUseConnect.mockReset();
			  sourceGet.mockReset();
			  sourceFetch.mockReset();
			  routerSet.mockReset();
			  routerUpdateState.mockReset();
			\});
			
			describe("useInfiniteScroll", () => \{
			  test("should return supported false if IntersectionObserver is not supported.", () => \{
			    mockedUseInView.mockReturnValue(\{
			      ref: undefined,
			      inView: true,
			      supported: false,
			    \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2" />, container);
			    \});
			
			    expect(spiedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(mockedUseInView).toHaveBeenCalledTimes(2);
			    expect(spiedUseInfiniteScroll).toHaveReturnedWith(\{ supported: false \});
			  \});
			
			  test("should use default values for \`fetchInViewOptions\` and \`routeInViewOptions\`", () => \{
			    mockedUseInView.mockReturnValue(\{
			      ref: undefined,
			      inView: true,
			      supported: false,
			    \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2" />, container);
			    \});
			
			    expect(mockedUseInView).toHaveBeenCalledTimes(2);
			    expect(mockedUseInView).toHaveBeenNthCalledWith(1, \{
			      rootMargin: "400px 0px",
			      triggerOnce: true,
			    \});
			    expect(mockedUseInView).toHaveBeenNthCalledWith(2, \{
			      rootMargin: "-80% 0% -19.9999% 0%",
			    \});
			  \});
			
			  test("should use \`fetchInViewOptions\` if passed as parameter", () => \{
			    mockedUseInView.mockReturnValue(\{
			      ref: undefined,
			      inView: true,
			      supported: false,
			    \});
			
			    const fetchInViewOptions = \{
			      rootMargin: "200px",
			      triggetOnce: false,
			    \};
			
			    act(() => \{
			      render(
			        <App
			          currentLink="/"
			          nextLink="/page/2"
			          fetchInViewOptions=\{fetchInViewOptions\}
			        />,
			        container
			      );
			    \});
			
			    expect(mockedUseInView).toHaveBeenCalledTimes(2);
			    expect(mockedUseInView).toHaveBeenNthCalledWith(1, fetchInViewOptions);
			  \});
			
			  test("should use \`routeInViewOptions\` if passed as parameter", () => \{
			    mockedUseInView.mockReturnValue(\{
			      ref: undefined,
			      inView: true,
			      supported: false,
			    \});
			
			    const routeInViewOptions = \{
			      rootMargin: "-50% 0% -49.9999% 0%",
			    \};
			
			    act(() => \{
			      render(
			        <App
			          currentLink="/"
			          nextLink="/page/2"
			          routeInViewOptions=\{routeInViewOptions\}
			        />,
			        container
			      );
			    \});
			
			    expect(mockedUseInView).toHaveBeenCalledTimes(2);
			    expect(mockedUseInView).toHaveBeenNthCalledWith(2, routeInViewOptions);
			  \});
			
			  test("should fetch the current link if not ready/fetching on mount", () => \{
			    mockedUseInView.mockReturnValue(\{
			      ref: jest.fn(),
			      inView: false,
			      supported: true,
			    \});
			
			    sourceGet.mockReturnValue(\{
			      isReady: false,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App currentLink="/" />, container);
			    \});
			
			    expect(sourceGet).toHaveBeenCalledWith("/");
			    expect(sourceFetch).toHaveBeenCalledWith("/");
			  \});
			
			  test("should not fetch if \`nextLink\` is undefined", () => \{
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \});
			
			    sourceGet.mockReturnValue(\{
			      isReady: true,
			      isFetching: false,
			    \});
			
			    act(() => \{
			      render(<App currentLink="/" />, container);
			    \});
			
			    expect(sourceGet).toHaveBeenCalledTimes(1);
			    expect(sourceGet).toHaveBeenCalledWith("/");
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should fetch \`nextLink\` if first reference is in view", () => \{
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			        link: "/",
			      \})
			      .mockReturnValueOnce(\{
			        isReady: false,
			        isFetching: false,
			        link: "/page/2/",
			      \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2/" />, container);
			    \});
			
			    expect(sourceGet).toHaveBeenCalledTimes(2);
			    expect(sourceGet).toHaveBeenNthCalledWith(1, "/");
			    expect(sourceGet).toHaveBeenNthCalledWith(2, "/page/2/");
			    expect(sourceFetch).toHaveBeenCalledWith("/page/2/");
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      infiniteScroll: \{ links: ["/"] \},
			      someOtherPackage: \{\},
			    \});
			  \});
			
			  test("should update browser state if first reference is in view and it's ready", () => \{
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			        link: "/",
			      \})
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			        link: "/page/2/",
			      \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2/" />, container);
			    \});
			
			    expect(sourceGet).toHaveBeenCalledTimes(2);
			    expect(sourceGet).toHaveBeenNthCalledWith(1, "/");
			    expect(sourceGet).toHaveBeenNthCalledWith(2, "/page/2/");
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{ links: ["/", "/page/2/"] \},
			    \});
			  \});
			
			  test("should not fetch \`nextLink\` nor update browser state if \`nextLink\` is already in links", () => \{
			    store.state.router.state.infiniteScroll = \{
			      links: ["/post-3/", "/post-1/", "/post-2/"],
			    \};
			
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			        link: "/post-2/",
			      \})
			      .mockReturnValueOnce(\{
			        isReady: false,
			        isFetching: false,
			        link: "/post-3/",
			      \});
			
			    act(() => \{
			      render(<App currentLink="/post-2/" nextLink="/post-3/" />, container);
			    \});
			
			    expect(sourceFetch).not.toHaveBeenCalled();
			    expect(routerUpdateState).not.toHaveBeenCalled();
			  \});
			
			  test("should not fetch \`nextLink\` if it's already fetching", () => \{
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			        link: "/",
			      \})
			      .mockReturnValueOnce(\{
			        isReady: false,
			        isFetching: true,
			        link: "/page/2/",
			      \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2/" />, container);
			    \});
			
			    expect(sourceFetch).not.toHaveBeenCalled();
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      infiniteScroll: \{ links: ["/"] \},
			      someOtherPackage: \{\},
			    \});
			  \});
			
			  test("should not fetch \`nextLink\` if it's already ready", () => \{
			    store.state.router.state.infiniteScroll = \{ links: ["/"] \};
			
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			        link: "/",
			      \})
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			        link: "/page/2/",
			      \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2/" />, container);
			    \});
			
			    expect(sourceFetch).not.toHaveBeenCalled();
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{ links: ["/", "/page/2/"] \},
			    \});
			  \});
			
			  test("should change route if second reference is in view", () => \{
			    store.state.router.link = "/page/2/";
			    store.state.router.state.infiniteScroll = \{ links: ["/", "/page/2/"] \};
			
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			      \})
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			      \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2/" />, container);
			    \});
			
			    expect(routerSet).toHaveBeenCalledTimes(1);
			    expect(routerSet).toHaveBeenCalledWith("/", \{
			      method: "replace",
			      state: \{
			        someOtherPackage: \{\},
			        infiniteScroll: \{ links: ["/", "/page/2/"] \},
			      \},
			    \});
			  \});
			
			  test("should not change route if \`currentLink\` is equal to the current url", () => \{
			    store.state.router.link = "/";
			    store.state.router.state.infiniteScroll = \{ links: ["/", "/page/2/"] \};
			
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: true,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			      \})
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			      \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2/" />, container);
			    \});
			
			    expect(routerSet).not.toHaveBeenCalled();
			  \});
			
			  test("should return the right object if \`IntersectionObserver\` is supported", () => \{
			    mockedUseInView
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \})
			      .mockReturnValueOnce(\{
			        ref: jest.fn(),
			        inView: false,
			        supported: true,
			      \});
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			      \})
			      .mockReturnValueOnce(\{
			        isReady: true,
			        isFetching: false,
			      \});
			
			    act(() => \{
			      render(<App currentLink="/" nextLink="/page/2/" />, container);
			    \});
			
			    expect(spiedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUseInfiniteScroll).toHaveReturnedWith(\{
			      supported: true,
			      routeRef: expect.any(Function),
			      fetchRef: expect.any(Function),
			      routeInView: false,
			      fetchInView: false,
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-infinite-scroll\\__tests__\\use-infinite-scroll.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(14)
    });
    it('frontity_frontity\\packages\\hooks\\use-post-type-infinite-scroll\\__tests__\\types.test.tsx', () => {
        const sourceCode = `
			import usePostTypeInfiniteSCroll from "../";
			
			() => \{
			  usePostTypeInfiniteSCroll();
			
			  usePostTypeInfiniteSCroll(\{\});
			
			  usePostTypeInfiniteSCroll(\{
			    limit: 2,
			    active: true,
			    archive: "/forced-archive/",
			    fallback: "/default-archive/",
			    fetchInViewOptions: \{
			      root: null,
			      rootMargin: "",
			      threshold: 1,
			      triggerOnce: true,
			    \},
			    routeInViewOptions: \{
			      root: document.createElement("div"),
			      rootMargin: "",
			      threshold: 0.5,
			      triggerOnce: false,
			    \},
			  \});
			
			  return null;
			\};
			
			//eslint-disable-next-line @typescript-eslint/no-empty-function
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-post-type-infinite-scroll\\__tests__\\types.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\hooks\\use-post-type-infinite-scroll\\__tests__\\use-post-type-infinite-scroll.test.tsx', () => {
        const sourceCode = `
			import React from "react";
			import \{ render \} from "react-dom";
			import clone from "clone-deep";
			import \{ act, Simulate \} from "react-dom/test-utils";
			import \{ useConnect \} from "frontity";
			import useInfiniteScroll from "../../use-infinite-scroll";
			import * as usePostTypeInfiniteScroll from "../";
			
			jest.mock("../../use-infinite-scroll", () => (\{
			  __esModule: true,
			  default: jest.fn(),
			\}));
			
			jest.mock("frontity", () => (\{
			  useConnect: jest.fn(),
			  connect: jest.fn((fn) => fn),
			  css: jest.fn(),
			\}));
			
			const spiedUsePostTypeInfiniteScroll = jest.spyOn(
			  usePostTypeInfiniteScroll,
			  "default"
			);
			const mockedUseInfiniteScroll = useInfiniteScroll as jest.MockedFunction<
			  typeof useInfiniteScroll
			>;
			const mockedUseConnect = useConnect as jest.MockedFunction<typeof useConnect>;
			const sourceGet = jest.fn();
			const sourceFetch = jest.fn();
			const routerUpdateState = jest.fn();
			
			const App = (\{ options \}: \{ options?: any \}) => \{
			  usePostTypeInfiniteScroll.default(options);
			  return <div />;
			\};
			
			const AppWithButton = (\{ options \}: \{ options?: any \}) => \{
			  const \{ fetchNext \} = usePostTypeInfiniteScroll.default(options);
			  return (
			    <div>
			      <button onClick=\{fetchNext\}>Fetch Next</button>
			    </div>
			  );
			\};
			
			let container: HTMLDivElement;
			
			const browserState: \{ [key: string]: unknown; infiniteScroll?: unknown \} = \{
			  someOtherPackage: \{\},
			\};
			const initialStore = \{
			  state: \{
			    router: \{
			      link: "/post-one/",
			      previous: null,
			      state: browserState,
			    \},
			    source: \{
			      get: sourceGet,
			    \},
			  \},
			  actions: \{
			    source: \{ fetch: sourceFetch \},
			    router: \{ updateState: routerUpdateState \},
			  \},
			\};
			let store = initialStore;
			
			beforeEach(() => \{
			  store = clone(initialStore);
			  container = document.createElement("div");
			  container.id = "container";
			  document.body.appendChild(container);
			  mockedUseConnect.mockReturnValue(store);
			\});
			
			afterEach(() => \{
			  document.body.removeChild(container);
			  container = null;
			  spiedUsePostTypeInfiniteScroll.mockClear();
			  mockedUseInfiniteScroll.mockReset();
			  mockedUseConnect.mockReset();
			  sourceGet.mockReset();
			  sourceFetch.mockReset();
			  routerUpdateState.mockReset();
			\});
			
			describe("usePostTypeInfiniteScroll", () => \{
			  test("should update the browser state on mount (whithout existing state)", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      infiniteScroll: \{
			        archive: "/",
			        pages: ["/"],
			        links: ["/post-one/"],
			      \},
			      someOtherPackage: \{\},
			    \});
			  \});
			
			  test("should update the browser state on mount (with existing state)", () => \{
			    store.state.router.state.infiniteScroll = \{
			      limit: 3,
			      archive: "/",
			      links: ["/post-one/"],
			      pages: ["/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        limit: 3,
			        archive: "/",
			        pages: ["/"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test("should update the browser state with \`limit\` options", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        limit: 1,
			        archive: "/",
			        pages: ["/"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test("should update the browser state with \`archive\` set to the value in \`options.archive\`", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive")
			        ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			        : undefined,
			    \}));
			
			    act(() => \{
			      render(<App options=\{\{ archive: "@options-archive" \}\} />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "@options-archive",
			        pages: ["@options-archive"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test("should update the browser state with \`archive\` set to the value already in state", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive")
			        ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			        : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "/initial-archive/",
			        pages: ["/initial-archive/"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test("should update the browser state with \`archive\` set to the value in \`state.router.previous\` if that's an archive", () => \{
			    store.state.router.previous = "/previous-archive/";
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive")
			        ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			        : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "/previous-archive/",
			        pages: ["/previous-archive/"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test('should update the browser state with \`archive\` set to "/" if the value in \`state.router.previous\` is not an archive', () => \{
			    store.state.router.previous = "/previous-archive/";
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "/",
			        pages: ["/"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test("should update the browser state with \`archive\` set to the value in \`options.fallback\`", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App options=\{\{ fallback: "@fallback-archive" \}\} />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "@fallback-archive",
			        pages: ["@fallback-archive"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test('should update the browser state with \`archive\` set to "/"', () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "/",
			        pages: ["/"],
			        links: ["/post-one/"],
			      \},
			    \});
			  \});
			
			  test("should not update the browser state if \`options.active\` is false", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App options=\{\{ active: false \}\} />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).not.toHaveBeenCalled();
			  \});
			
			  test("should request the archive if not ready and not fetching", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/",
			      isFetching: false,
			      isArchive: true,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/");
			  \});
			
			  test("should not request the archive if \`options.active\` is false", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/",
			      isFetching: false,
			    \}));
			
			    act(() => \{
			      render(<App options=\{\{ active: false \}\} />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should not request the archive if it's ready", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: true,
			      items: [],
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should not request the archive if it's fetching", () => \{
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: false,
			      isFetching: true,
			      isArchive: true,
			      items: [],
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should request next page on last item", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/initial-archive/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next:
			        link === "/initial-archive/" ? "/initial-archive/page/2/" : undefined,
			      isReady: link !== "/initial-archive/page/2/",
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive") ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(2);
			    expect(routerUpdateState).toHaveBeenNthCalledWith(2, \{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "/initial-archive/",
			        pages: ["/initial-archive/", "/initial-archive/page/2/"],
			        links: ["/post-one/"],
			      \},
			    \});
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/initial-archive/page/2/");
			  \});
			
			  test("should not request next page on last item if \`options.active\` is false", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/initial-archive/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next:
			        link === "/initial-archive/" ? "/initial-archive/page/2/" : undefined,
			      isReady: link !== "/initial-archive/page/2/",
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive") ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    act(() => \{
			      render(<App options=\{\{ active: false \}\} />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should not request next page on last item if there isn't next page", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/initial-archive/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/initial-archive/page/2/",
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive") ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should not request next page on last item if has reached limit", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/initial-archive/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next:
			        link === "/initial-archive/" ? "/initial-archive/page/2/" : undefined,
			      isReady: link !== "/initial-archive/page/2/",
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive") ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    act(() => \{
			      render(<App options=\{\{ limit: 1 \}\} />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should not request next page if it's not on last item", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/initial-archive/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next:
			        link === "/initial-archive/" ? "/initial-archive/page/2/" : undefined,
			      isReady: link !== "/initial-archive/page/2/",
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive")
			        ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			        : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should not fetch next page if ready", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/initial-archive/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next:
			        link === "/initial-archive/" ? "/initial-archive/page/2/" : undefined,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("archive"),
			      items: link.includes("archive") ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(2);
			    expect(routerUpdateState).toHaveBeenNthCalledWith(2, \{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "/initial-archive/",
			        pages: ["/initial-archive/", "/initial-archive/page/2/"],
			        links: ["/post-one/"],
			      \},
			    \});
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should not fetch next page if fetching", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/initial-archive/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next:
			        link === "/initial-archive/" ? "/initial-archive/page/2/" : undefined,
			      isReady: link !== "/initial-archive/page/2/",
			      isFetching: link === "/initial-archive/page/2/",
			      isArchive: link.includes("archive"),
			      items: link.includes("archive") ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledTimes(2);
			    expect(routerUpdateState).toHaveBeenNthCalledWith(2, \{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        archive: "/initial-archive/",
			        pages: ["/initial-archive/", "/initial-archive/page/2/"],
			        links: ["/post-one/"],
			      \},
			    \});
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("should return the right object", () => \{
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link === "/",
			      items:
			        link === "/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/post-two/",
			          link: "/post-two/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLast\` true for second last link if last link is not ready", () => \{
			    store.state.router.link = "/post-two/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/initial-archive/",
			      pages: ["/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/post-two/",
			      isFetching: false,
			      isArchive: link === "/",
			      items:
			        link === "/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/post-two/",
			          link: "/post-two/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` true if has reached limit and there is next item and is not fetching", () => \{
			    store.state.router.link = "/post-two/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/",
			      limit: 2,
			      pages: ["/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link === "/",
			      items:
			        link === "/"
			          ? [
			              \{ link: "/post-one/" \},
			              \{ link: "/post-two/" \},
			              \{ link: "/post-three/" \},
			            ]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/post-two/",
			          link: "/post-two/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: true,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` false and \`isFetching\` true if next item is fetching", () => \{
			    store.state.router.link = "/post-two/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/",
			      limit: 2,
			      pages: ["/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/post-three/",
			      isFetching: link === "/post-three/",
			      isArchive: link === "/",
			      items:
			        link === "/"
			          ? [
			              \{ link: "/post-one/" \},
			              \{ link: "/post-two/" \},
			              \{ link: "/post-three/" \},
			            ]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/post-two/",
			          link: "/post-two/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: true,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` false and \`isFetching\` true if next page is fetching", () => \{
			    store.state.router.link = "/post-two/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/",
			      limit: 2,
			      pages: ["/", "/page/2/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: link === "/page/2/",
			      isArchive: !link.includes("post"),
			      items: !link.includes("post")
			        ? [\{ link: link + "post-one/" \}, \{ link: link + "post-two/" \}]
			        : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/post-two/",
			          link: "/post-two/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: true,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` false if there isn't a next item", () => \{
			    store.state.router.link = "/post-two/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/",
			      limit: 2,
			      pages: ["/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link === "/",
			      items:
			        link === "/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/post-two/",
			          link: "/post-two/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isLimit\` false if limit hasn't been reached", () => \{
			    store.state.router.link = "/post-two/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/",
			      limit: 2,
			      pages: ["/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link === "/",
			      items:
			        link === "/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: false,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isError\` true when current post is unavailable", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/",
			      limit: 3,
			      pages: ["/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => \{
			      if (link === "/post-one/") \{
			        return \{
			          link: "/post-one/",
			          next: "/post-two",
			          isReady: true,
			          isFetching: false,
			          isError: false,
			        \};
			      \}
			
			      if (link === "/post-two/") \{
			        return \{
			          isReady: true,
			          isFetching: false,
			          isError: true,
			        \};
			      \}
			
			      return \{
			        link,
			        isReady: true,
			        isFetching: false,
			        isArchive: link === "/",
			        items:
			          link === "/"
			            ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			            : undefined,
			      \};
			    \});
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			        \{
			          key: "/post-two/",
			          link: "/post-two/",
			          isLast: false,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: true,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("should return \`isError\` true when current page is unavailable", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      archive: "/",
			      limit: 2,
			      pages: ["/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => \{
			      if (link === "/") \{
			        return \{
			          isReady: true,
			          isFetching: false,
			          isError: true,
			        \};
			      \}
			
			      return \{
			        link,
			        isReady: true,
			        isFetching: false,
			        items:
			          link === "/"
			            ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			            : undefined,
			      \};
			    \});
			
			    act(() => \{
			      render(<App />, container);
			    \});
			
			    expect(spiedUsePostTypeInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(spiedUsePostTypeInfiniteScroll).toHaveReturnedWith(\{
			      posts: [
			        \{
			          key: "/post-one/",
			          link: "/post-one/",
			          isLast: true,
			          Wrapper: expect.any(Function),
			        \},
			      ],
			      isLimit: false,
			      isFetching: false,
			      isError: true,
			      fetchNext: expect.any(Function),
			    \});
			  \});
			
			  test("\`fetchNext\` should fetch next item", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/post-two/",
			      isFetching: false,
			      isArchive: link === "/page-one/",
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        limit: 1,
			        archive: "/page-one/",
			        pages: ["/page-one/"],
			        links: ["/post-one/", "/post-two/"],
			      \},
			    \});
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/post-two/");
			  \});
			
			  test("\`fetchNext\` should fetch next page and next item", async () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next: link === "/page-one/" ? "/page-two/" : undefined,
			      isReady: !link.includes("two"),
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}]
			          : link === "/page-two/"
			          ? [\{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next: link === "/page-one/" ? "/page-two/" : undefined,
			      isReady: link !== "/post-two/",
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}]
			          : link === "/page-two/"
			          ? [\{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    const fetchNext = act(async () => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(routerUpdateState).toHaveBeenCalledWith(\{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        limit: 1,
			        archive: "/page-one/",
			        pages: ["/page-one/", "/page-two/"],
			        links: ["/post-one/"],
			      \},
			    \});
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/page-two/");
			
			    await fetchNext;
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(2);
			    expect(routerUpdateState).toHaveBeenNthCalledWith(2, \{
			      someOtherPackage: \{\},
			      infiniteScroll: \{
			        limit: 1,
			        archive: "/page-one/",
			        pages: ["/page-one/", "/page-two/"],
			        links: ["/post-one/", "/post-two/"],
			      \},
			    \});
			    expect(sourceFetch).toHaveBeenCalledTimes(2);
			    expect(sourceFetch).toHaveBeenNthCalledWith(2, "/post-two/");
			  \});
			
			  test("\`fetchNext\` should not fetch next page if it's ready", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next: link === "/page-one/" ? "/page-two/" : undefined,
			      isReady: link !== "/post-two/",
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}]
			          : link === "/page-two/"
			          ? [\{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(2);
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/post-two/");
			  \});
			
			  test("\`fetchNext\` should not fetch next page if it's fetching", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next: link === "/page-one/" ? "/page-two/" : undefined,
			      isReady: !link.includes("two"),
			      isFetching: link === "/page-two/",
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}]
			          : link === "/page-two/"
			          ? [\{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      next: link === "/page-one/" ? "/page-two/" : undefined,
			      isReady: link !== "/post-two/",
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}]
			          : link === "/page-two/"
			          ? [\{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(2);
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/post-two/");
			  \});
			
			  test("\`fetchNext\` should not fetch next item if it's ready or fetching", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			
			    routerUpdateState.mockClear();
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/post-two/",
			      isFetching: link === "/post-two/",
			    \}));
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should do nothing if \`options.active\` is false", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton options=\{\{ active: false \}\} />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should do nothing if there isn't a next item and there isn't a next page", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items: link === "/page-one/" ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should do nothing if next item is already in links", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/", "/post-two/"],
			    \};
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isFetching: false,
			      isArchive: link.includes("page"),
			      items:
			        link === "/page-one/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).not.toHaveBeenCalled();
			  \});
			
			  test("\`fetchNext\` should request the last page if \`isError\` is true", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => \{
			      if (link === "/page-one/") \{
			        return \{
			          isReady: true,
			          isFetching: false,
			          isError: true,
			        \};
			      \}
			
			      return \{
			        link,
			        isReady: link !== "/post-two/",
			        isFetching: false,
			        isArchive: link === "/page-one/",
			        items:
			          link === "/page-one/"
			            ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			            : undefined,
			      \};
			    \});
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/page-one/", \{ force: true \});
			  \});
			
			  test("\`fetchNext\` should request the last post if \`isError\` is true", () => \{
			    store.state.router.link = "/post-one/";
			    store.state.router.state.infiniteScroll = \{
			      limit: 1,
			      archive: "/page-one/",
			      pages: ["/page-one/"],
			      links: ["/post-one/"],
			    \};
			
			    sourceGet.mockImplementation((link) => \{
			      if (link === "/post-one/") \{
			        return \{
			          isReady: true,
			          isFetching: false,
			          isError: true,
			        \};
			      \}
			
			      return \{
			        link,
			        isReady: link !== "/post-two/",
			        isFetching: false,
			        isArchive: link === "/page-one/",
			        items:
			          link === "/page-one/"
			            ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			            : undefined,
			      \};
			    \});
			
			    act(() => \{
			      render(<AppWithButton />, container);
			    \});
			
			    routerUpdateState.mockClear();
			
			    act(() => \{
			      Simulate.click(container.querySelector("button"));
			    \});
			
			    expect(routerUpdateState).not.toHaveBeenCalled();
			    expect(sourceFetch).toHaveBeenCalledTimes(1);
			    expect(sourceFetch).toHaveBeenCalledWith("/post-one/", \{ force: true \});
			  \});
			\});
			
			describe("Wrapper", () => \{
			  test("should return children if IntersectionObserver is not supported", () => \{
			    const Wrapper = usePostTypeInfiniteScroll.wrapperGenerator(\{
			      link: "/post-one/",
			    \});
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isArchive: link === "/",
			      items: link === "/" ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    mockedUseInfiniteScroll.mockReturnValueOnce(\{
			      supported: false,
			    \});
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should return null if the current element is not ready", () => \{
			    const Wrapper = usePostTypeInfiniteScroll.wrapperGenerator(\{
			      link: "/post-one/",
			    \});
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: link !== "/post-one/",
			      isArchive: link === "/",
			      items: link === "/" ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    mockedUseInfiniteScroll.mockReturnValueOnce(\{
			      supported: true,
			      fetchRef: jest.fn(),
			      routeRef: jest.fn(),
			      fetchInView: false,
			      routeInView: false,
			    \});
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should return children and fetcher inside a wrapper", () => \{
			    const Wrapper = usePostTypeInfiniteScroll.wrapperGenerator(\{
			      link: "/post-one/",
			    \});
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isArchive: link === "/",
			      items: link === "/" ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    mockedUseInfiniteScroll.mockReturnValueOnce(\{
			      supported: true,
			      fetchRef: jest.fn(),
			      routeRef: jest.fn(),
			      fetchInView: false,
			      routeInView: false,
			    \});
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should return only children inside the wrapper if limit reached", () => \{
			    store.state.router.state.infiniteScroll = \{ limit: 1 \};
			    const Wrapper = usePostTypeInfiniteScroll.wrapperGenerator(\{
			      link: "/post-one/",
			    \});
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isArchive: link === "/",
			      items: link === "/" ? [\{ link: "/post-one/" \}] : undefined,
			    \}));
			
			    mockedUseInfiniteScroll.mockReturnValue(\{
			      supported: true,
			      fetchRef: jest.fn(),
			      routeRef: jest.fn(),
			      fetchInView: false,
			      routeInView: false,
			    \});
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(container).toMatchSnapshot();
			  \});
			
			  test("should call \`useInfiniteScroll\` with \`currentLink\` and \`nextLink\`", () => \{
			    store.state.router.state.infiniteScroll = \{ pages: ["/"] \};
			    const Wrapper = usePostTypeInfiniteScroll.wrapperGenerator(\{
			      link: "/post-one/",
			    \});
			
			    sourceGet.mockImplementation((link) => (\{
			      link,
			      isReady: true,
			      isArchive: link === "/",
			      items:
			        link === "/"
			          ? [\{ link: "/post-one/" \}, \{ link: "/post-two/" \}]
			          : undefined,
			    \}));
			
			    mockedUseInfiniteScroll.mockReturnValueOnce(\{
			      supported: true,
			      fetchRef: jest.fn(),
			      routeRef: jest.fn(),
			      fetchInView: false,
			      routeInView: false,
			    \});
			
			    act(() => \{
			      render(
			        <Wrapper key="fake-key">
			          <div id="children" />
			        </Wrapper>,
			        container
			      );
			    \});
			
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledTimes(1);
			    expect(mockedUseInfiniteScroll).toHaveBeenCalledWith(\{
			      currentLink: "/post-one/",
			      nextLink: "/post-two/",
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-post-type-infinite-scroll\\__tests__\\use-post-type-infinite-scroll.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(45)
    });
    it('frontity_frontity\\packages\\hooks\\use-post-type-infinite-scroll\\__tests__\\utils.tests.ts', () => {
        const sourceCode = `
			import \{ getLinksFromPages \} from "../utils";
			
			describe("getLinksFromPages", () => \{
			  const sourceGet = jest.fn();
			  beforeEach(() => \{
			    sourceGet.mockReset();
			  \});
			
			  it("should work with no links", () => \{
			    const pages = ["/"];
			    const firstLink = "/post-1";
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [],
			      \})
			      .mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			      ]
			    \`);
			  \});
			
			  it("should work with one link", () => \{
			    const pages = ["/"];
			    const firstLink = "/post-1";
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-1",
			          \},
			        ],
			      \})
			      .mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			      ]
			    \`);
			  \});
			
			  it("should work if the first link is in the second page", () => \{
			    const pages = ["/", "/page/2"];
			    const firstLink = "/post-1";
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-2",
			          \},
			        ],
			      \})
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-3",
			          \},
			          \{
			            link: "/post-1",
			          \},
			          \{
			            link: "/post-4",
			          \},
			        ],
			      \})
			      .mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			        "/post-2",
			        "/post-3",
			        "/post-4",
			      ]
			    \`);
			  \});
			
			  it("should not break with an empty array of pages", () => \{
			    const pages = [];
			    const firstLink = "/post-1";
			
			    sourceGet.mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			      ]
			    \`);
			  \});
			
			  it("should remove duplicated links on different pages", () => \{
			    const pages = ["/", "/page/2"];
			    const firstLink = "/post-4";
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-4",
			          \},
			          \{
			            link: "/post-3",
			          \},
			          \{
			            link: "/post-2",
			          \},
			        ],
			      \})
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-3",
			          \},
			          \{
			            link: "/post-2",
			          \},
			          \{
			            link: "/post-1",
			          \},
			        ],
			      \})
			      .mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-4",
			        "/post-3",
			        "/post-2",
			        "/post-1",
			      ]
			    \`);
			  \});
			
			  it("should remove redirected links", () => \{
			    const pages = ["/", "/page/2"];
			    const firstLink = "/post-1";
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-1",
			          \},
			          \{
			            link: "/post-2",
			          \},
			          \{
			            link: "/post-3",
			          \},
			        ],
			      \})
			      .mockImplementation((link) => \{
			        if (link === "/post-2")
			          return \{
			            isRedirection: true,
			            location: "/post-1",
			          \};
			
			        if (link === "/post-3")
			          return \{
			            isRedirection: true,
			            isExternal: true,
			            location: "https://external.location",
			          \};
			
			        return \{ link \};
			      \});
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			      ]
			    \`);
			  \});
			
			  it("should skip pages that are not ready yet", () => \{
			    const pages = ["/", "/page/2"];
			    const firstLink = "/post-1";
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-1",
			          \},
			          \{
			            link: "/post-2",
			          \},
			        ],
			      \})
			      .mockReturnValueOnce(\{
			        isFetching: true,
			        isReady: false,
			      \})
			      .mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			        "/post-2",
			      ]
			    \`);
			  \});
			
			  it("should work with pages that are being updated", () => \{
			    const pages = ["/", "/page/2"];
			    const firstLink = "/post-1";
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-1",
			          \},
			          \{
			            link: "/post-2",
			          \},
			        ],
			      \})
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isFetching: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-3",
			          \},
			        ],
			      \})
			      .mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			        "/post-2",
			        "/post-3",
			      ]
			    \`);
			  \});
			
			  it("should skip pages that are not an archive (e.g. errors)", () => \{
			    const pages = ["/", "/page/2"];
			    const firstLink = "/post-1";
			
			    sourceGet
			      .mockReturnValueOnce(\{
			        isArchive: true,
			        isReady: true,
			        items: [
			          \{
			            link: "/post-1",
			          \},
			          \{
			            link: "/post-2",
			          \},
			        ],
			      \})
			      .mockReturnValueOnce(\{
			        isError: true,
			        isReady: true,
			        is408: true,
			        errorStatus: 408,
			        errorStatusMessage: "Request Timeout",
			      \})
			      .mockImplementation((link) => (\{ link \}));
			
			    expect(getLinksFromPages(\{ pages, firstLink, sourceGet \}))
			      .toMatchInlineSnapshot(\`
			      Array [
			        "/post-1",
			        "/post-2",
			      ]
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\hooks\\use-post-type-infinite-scroll\\__tests__\\utils.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('frontity_frontity\\packages\\html2react\\processors\\__tests__\\iframe.test.tsx', () => {
        const sourceCode = `
			import \{ render \} from "@testing-library/react";
			import Html2React from "../../src/libraries/component";
			import iframe from "../iframe";
			
			jest.mock("@frontity/components/iframe", () => "mocked-iframe");
			
			describe("Iframe Processor", () => \{
			  it("should process iframes from src", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html="<iframe src='https://frontity.org' title='Frontity' width='500' />"
			        processors=\{[iframe]\}
			      />
			    );
			
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should process iframes from data-src", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html="<iframe data-src='https://frontity.org' title='Frontity' width='500' />"
			        processors=\{[iframe]\}
			      />
			    );
			
			    expect(container).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\processors\\__tests__\\iframe.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\html2react\\processors\\__tests__\\image.test.tsx', () => {
        const sourceCode = `
			import \{ render \} from "@testing-library/react";
			import Html2React from "../../src/libraries/component";
			import image from "../image";
			
			jest.mock("@frontity/components/image", () => "mocked-img");
			
			describe("Image Processor", () => \{
			  it("should process images from src", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html="<img src='https://frontity.org/logo.png' alt='Frontity' width='500' />"
			        processors=\{[image]\}
			      />
			    );
			
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should process images from data-src", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html="<img data-src='https://frontity.org/logo.png' alt='Frontity' width='500' />"
			        processors=\{[image]\}
			      />
			    );
			
			    expect(container).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\processors\\__tests__\\image.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\html2react\\processors\\__tests__\\link.test.tsx', () => {
        const sourceCode = `
			import \{ render \} from "@testing-library/react";
			import Html2React from "../../src/libraries/component";
			import link from "../link";
			
			jest.mock("@frontity/components/link", () => "mocked-link");
			
			describe("Link Processor", () => \{
			  it("should replace all anchor tags with links", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html="<a href='http://my-link.com/post-name'>My Link</a><a href='http://my-link.com/post-name'>My Link 2</a>"
			        processors=\{[link]\}
			      />
			    );
			
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should not replace anchor tags starting with #", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html="<a href='#id'>My Link</a><a href='http://my-link.com/post-name'>My Link 2</a>"
			        processors=\{[link]\}
			      />
			    );
			
			    expect(container).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\processors\\__tests__\\link.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\html2react\\processors\\__tests__\\script.test.tsx', () => {
        const sourceCode = `
			import \{ render \} from "@testing-library/react";
			import \{ createStore \} from "@frontity/connect";
			import \{ Html2React \} from "../../src/libraries/component";
			import Html2ReactPackage from "../../src";
			
			const store = createStore(Html2ReactPackage);
			
			jest.mock("@frontity/components/script", () => "mocked-script");
			
			describe("Script processor", () => \{
			  it("should process a script with src", () => \{
			    const \{ container \} = render(
			      <Html2React html=\{'<script src="/some-js-file.js" />'\} \{...store\} />
			    );
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should not process scripts with a non valid type", () => \{
			    const \{ container \} = render(
			      <Html2React html=\{'<script src="/" type="non-valid" />'\} \{...store\} />
			    );
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should process scripts with a valid type", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html=\{'<script src="/" type="application/javascript" />'\}
			        \{...store\}
			      />
			    );
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should process a script with code", () => \{
			    const \{ container \} = render(
			      <Html2React html=\{'<script>const some = "code";</script>'\} \{...store\} />
			    );
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should set data-src to src if provided", () => \{
			    const \{ container \} = render(
			      <Html2React html=\{'<script data-src="/some-js-file.js" />'\} \{...store\} />
			    );
			    expect(container).toMatchSnapshot();
			  \});
			
			  it("should process a script with type=module", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html=\{'<script type="module">const some="code";</script>'\}
			        \{...store\}
			      />
			    );
			    expect(container).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\processors\\__tests__\\script.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\packages\\html2react\\processors\\__tests__\\slot-block.test.tsx', () => {
        const sourceCode = `
			import \{ render \} from "@testing-library/react";
			import Html2React from "../../src/libraries/component";
			import gutenbergSlot from "../slot-block";
			
			jest.mock("frontity", () => (\{
			  Slot: jest.fn((\{ name \}) => <slot name=\{name\}>mocked slot</slot>),
			  connect: jest.fn((comp) => comp),
			  decode: jest.fn((str) => str),
			  warn: jest.fn(),
			\}));
			
			describe("Slot Block processor", () => \{
			  it("should process an slot created with Gutenberg", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html='<div class="wp-block-frontity-frontity-slot" data-frontity-slot-name="Some Slot Name"></div>'
			        processors=\{[gutenbergSlot]\}
			      />
			    );
			
			    expect(container).toMatchInlineSnapshot(\`
			      <div>
			        <slot
			          name="Some Slot Name"
			        >
			          mocked slot
			        </slot>
			      </div>
			    \`);
			  \});
			
			  it("should ignore an slot without name", () => \{
			    const \{ container \} = render(
			      <Html2React
			        html='<div class="wp-block-frontity-frontity-slot"></div>'
			        processors=\{[gutenbergSlot]\}
			      />
			    );
			
			    expect(container).toMatchInlineSnapshot(\`<div />\`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\processors\\__tests__\\slot-block.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\html2react\\src\\libraries\\__tests__\\component.tests.tsx', () => {
        const sourceCode = `
			/* eslint-disable @typescript-eslint/no-empty-function */
			import TestRenderer from "react-test-renderer";
			import Component from "../component";
			import parse from "../parse";
			import htmlMock from "./mocks/html";
			
			describe("Component", () => \{
			  const libraries = \{
			    html2react: \{
			      parse,
			      processors: [],
			    \},
			  \};
			  const Html2React = Component as any;
			
			  test("works just fine", () => \{
			    libraries.html2react.processors = [
			      \{
			        name: "priority-15",
			        priority: 15,
			        test: () => false,
			        processor: () => \{\},
			      \},
			      \{
			        name: "priority-5",
			        priority: 5,
			        test: () => false,
			        processor: () => \{\},
			      \},
			      \{
			        name: "priority-none",
			        test: () => false,
			        processor: () => \{\},
			      \},
			    ];
			
			    expect(libraries.html2react.processors[0].name).toBe("priority-15");
			    expect(libraries.html2react.processors[1].name).toBe("priority-5");
			    expect(libraries.html2react.processors[2].name).toBe("priority-none");
			
			    const result = TestRenderer.create(
			      <Html2React html=\{htmlMock\} libraries=\{libraries\} />
			    ).toJSON();
			
			    expect(libraries.html2react.processors[0].name).toBe("priority-5");
			    expect(libraries.html2react.processors[1].name).toBe("priority-none");
			    expect(libraries.html2react.processors[2].name).toBe("priority-15");
			    expect(result).toMatchSnapshot();
			  \});
			
			  test("Should not pass classname to custom elements", () => \{
			    const html = \`<my-custom-component style="height: auto;">\`;
			
			    const result = TestRenderer.create(
			      <Html2React html=\{html\} libraries=\{libraries\} />
			    );
			
			    // Should not pass className to the custom component and pass the class instead
			    expect(result.toJSON()).toMatchInlineSnapshot(\`
			      .emotion-0 \{
			        height: auto;
			      \}
			
			      <my-custom-component
			        class="emotion-0"
			      />
			    \`);
			  \});
			
			  test("Should pass 'class' to custom elements", () => \{
			    const html = \`<my-custom-component class="test hello">\`;
			
			    const result = TestRenderer.create(
			      <Html2React html=\{html\} libraries=\{libraries\} />
			    );
			
			    // Should preserve the class on the component
			    expect(result.toJSON()).toMatchInlineSnapshot(\`
			      <my-custom-component
			        class="test hello"
			      />
			    \`);
			  \});
			
			  test("Should not pass classname to custom elements and concatenate class names", () => \{
			    const html = \`<my-custom-component style="height: auto;" class="test">\`;
			
			    const result = TestRenderer.create(
			      <Html2React html=\{html\} libraries=\{libraries\} />
			    );
			
			    // Should concatenate the class from the attribute with the one generated by
			    // emotion
			    expect(result.toJSON()).toMatchInlineSnapshot(\`
			      .emotion-0 \{
			        height: auto;
			      \}
			
			      <my-custom-component
			        class="test emotion-0"
			      />
			    \`);
			  \});
			
			  test("Should handle children and multiple props correctly", () => \{
			    const html = \`
			    <my-custom-component prop1="test" class="test class" id="1">
			      <div> test </div> 
			      <div> test 2 </div> 
			    </my-custom-component>\`;
			
			    const result = TestRenderer.create(
			      <Html2React html=\{html\} libraries=\{libraries\} />
			    );
			
			    expect(result.toJSON()).toMatchInlineSnapshot(\`
			      <my-custom-component
			        class="test class"
			        id="1"
			        prop1="test"
			      >
			        <div>
			           test 
			        </div>
			        <div>
			           test 2 
			        </div>
			      </my-custom-component>
			    \`);
			  \});
			
			  test("Should handle nested custom components correctly", () => \{
			    const html = \`
			    <my-custom-component class="test" style="color: red;">
			      <my-nested-custom-component>
			    </my-custom-component>\`;
			
			    const result = TestRenderer.create(
			      <Html2React html=\{html\} libraries=\{libraries\} />
			    );
			
			    expect(result.toJSON()).toMatchInlineSnapshot(\`
			      .emotion-0 \{
			        color: red;
			      \}
			
			      <my-custom-component
			        class="test emotion-0"
			      >
			        <my-nested-custom-component />
			      </my-custom-component>
			    \`);
			  \});
			
			  test("When you pass a className prop, it should not overwrite the class prop", () => \{
			    const html = \`<div class="test" className="className"></div>\`;
			
			    const result = TestRenderer.create(
			      <Html2React html=\{html\} libraries=\{libraries\} />
			    );
			
			    // Should have a \`class\`
			    expect(result.toJSON()).toMatchInlineSnapshot(\`
			      <div
			        className="test"
			      />
			    \`);
			
			    expect(result.toJSON()).toMatchObject(\{
			      props: \{ className: "test" \},
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\src\\libraries\\__tests__\\component.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\packages\\html2react\\src\\libraries\\__tests__\\parse.tests.ts', () => {
        const sourceCode = `
			import parse from "../parse";
			import htmlMock from "./mocks/html";
			import \{ Element \} from "../../../types";
			
			describe("parse", () => \{
			  test("should return the right HTML tree", () => \{
			    const result = parse(htmlMock);
			    expect(result).toMatchSnapshot();
			  \});
			
			  test("decodes the characters in links correctly", () => \{
			    const result = parse(
			      '<a href="https://test.com/?param1=1&amp;param2=2"> test link </a>'
			    ) as Element[];
			
			    expect(result[0].props.href).toBe("https://test.com/?param1=1&param2=2");
			  \});
			
			  test("maps from HTML attributes to react props", () => \{
			    const result = parse(
			      '<div class="test-class"> test </div> <label for="nothing"></label>'
			    ) as Element[];
			
			    expect((result[0].props as any).class).toBeUndefined();
			    expect(result[0].props.className).toBe("test-class");
			    expect((result[1].props as any).for).toBeUndefined();
			    expect(result[1].props.htmlFor).toBe("nothing");
			  \});
			
			  test("maps from SVG attributes to react props", () => \{
			    const resultOne = parse(
			      '<svg viewBox="0 0 60 60" version="1.1" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"></svg>'
			    ) as Element[];
			
			    expect((resultOne[0].props as any)["xmlns:xlink"]).toBeUndefined();
			    expect((resultOne[0].props as any).xmlnsXlink).toBe(
			      "https://www.w3.org/1999/xlink"
			    );
			
			    const resultTwo = parse(
			      '<g stroke-width="1" fill-rule="evenodd"></g>'
			    ) as Element[];
			
			    expect((resultTwo[0].props as any)["stroke-width"]).toBeUndefined();
			    expect((resultTwo[0].props as any).strokeWidth).toBe("1");
			    expect((resultTwo[0].props as any)["fill-rule"]).toBeUndefined();
			    expect((resultTwo[0].props as any).fillRule).toBe("evenodd");
			  \});
			
			  test("should not map data attributes as SVG attributes", () => \{
			    const result = parse(
			      '<div data-src="https://frontity.org"></div>'
			    ) as Element[];
			
			    expect((result[0].props as any)["data-src"]).toBe("https://frontity.org");
			    expect((result[0].props as any).dataSrc).toBeUndefined();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\src\\libraries\\__tests__\\parse.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\html2react\\__tests__\\types.test.ts', () => {
        const sourceCode = `
			import \{ expectType \} from "frontity/types/helpers";
			import \{ Processor, Node, Element, Text, Comment \} from "../types";
			
			// 1. Processor by default accepts Element, Text or Comment.
			const proc1: Processor = \{
			  test: (\{ node \}) => \{
			    expectType<"element" | "text" | "comment">(node.type);
			
			    if (node.type === "element") expectType<Element>(node);
			    if (node.type === "text") expectType<Text>(node);
			    if (node.type === "comment") expectType<Comment>(node);
			
			    return true;
			  \},
			  processor: (\{ node \}) => \{
			    expectType<"element" | "text" | "comment">(node.type);
			
			    if (node.type === "element") expectType<Element>(node);
			    if (node.type === "text") expectType<Text>(node);
			    if (node.type === "comment") expectType<Comment>(node);
			
			    return node;
			  \},
			\};
			
			// 2. Processor with default Element should receive correct types.
			const proc2: Processor<Element> = \{
			  test: (\{ node \}) => \{
			    expectType<Element>(node);
			    expectType<string | React.ComponentType>(node.component);
			    expectType<Element>(node.parent);
			    expectType<Node[]>(node.children);
			
			    // Test CSS prop.
			    expectType<Element["props"]["css"]>(node.props.css);
			
			    // Test some HTML props.
			    expectType<string>(node.props.id);
			    expectType<string>(node.props.className);
			    expectType<string>(node.props.src);
			    expectType<string>(node.props.srcSet);
			
			    return true;
			  \},
			  processor: (\{ node \}) => \{
			    expectType<Element>(node);
			    expectType<string | React.ComponentType>(node.component);
			    expectType<Element>(node.parent);
			    expectType<Node[]>(node.children);
			
			    // Test CSS prop.
			    expectType<Element["props"]["css"]>(node.props.css);
			
			    // Test some HTML props.
			    expectType<string>(node.props.id);
			    expectType<string>(node.props.className);
			    expectType<string>(node.props.src);
			    expectType<string>(node.props.srcSet);
			
			    return node;
			  \},
			\};
			
			// 3. Element can be extended with custom props.
			interface CustomElement extends Element \{
			  props: Element["props"] & \{
			    hasCustomProp: true;
			  \};
			\}
			
			const proc3: Processor<CustomElement> = \{
			  test: (\{ node \}) => \{
			    expectType<Element>(node);
			    expectType<CustomElement>(node);
			    expectType<true>(node.props.hasCustomProp);
			
			    return true;
			  \},
			  processor: (\{ node \}) => \{
			    expectType<Element>(node);
			    expectType<CustomElement>(node);
			    expectType<true>(node.props.hasCustomProp);
			
			    return node;
			  \},
			\};
			
			// 4. Element can be extended with custom relatives.
			interface MyElementParent extends Element \{
			  props: Element["props"] & \{
			    isParent: true;
			  \};
			\}
			
			interface MyElementChild extends Element \{
			  props: Element["props"] & \{
			    isChild: true;
			  \};
			  parent: MyElement;
			\}
			
			interface MyElement extends Element \{
			  props: Element["props"] & \{
			    isElement: true;
			  \};
			  parent: MyElementParent;
			  children: [Element, Text, Comment, MyElementChild];
			\}
			
			const proc4: Processor<MyElement> = \{
			  test: (\{ node \}) => \{
			    // Test node.
			    expectType<MyElement>(node);
			    expectType<true>(node.props.isElement);
			    // Test parent.
			    expectType<MyElementParent>(node.parent);
			    expectType<true>(node.parent.props.isParent);
			    // Test children.
			    expectType<Element>(node.children[0]);
			    expectType<Text>(node.children[1]);
			    expectType<Comment>(node.children[2]);
			    expectType<MyElementChild>(node.children[3]);
			    expectType<true>(node.children[3].props.isChild);
			    expectType<MyElement>(node.children[3].parent);
			
			    return true;
			  \},
			  processor: (\{ node \}) => \{
			    // Test node.
			    expectType<MyElement>(node);
			    expectType<true>(node.props.isElement);
			    // Test parent.
			    expectType<MyElementParent>(node.parent);
			    expectType<true>(node.parent.props.isParent);
			    // Test children.
			    expectType<Element>(node.children[0]);
			    expectType<Text>(node.children[1]);
			    expectType<Comment>(node.children[2]);
			    expectType<MyElementChild>(node.children[3]);
			    expectType<true>(node.children[3].props.isChild);
			    expectType<MyElement>(node.children[3].parent);
			
			    return node;
			  \},
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\html2react\\__tests__\\types.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\router\\__tests__\\types.test.ts', () => {
        const sourceCode = `
			import Router from "../types";
			
			const router: Router = \{
			  state: \{
			    router: \{
			      link: "/some-path/page/2/?k1=v1",
			      state: \{
			        initial: "/some-path/",
			        pages: [1, 2],
			      \},
			    \},
			  \},
			  actions: \{
			    router: \{
			      set: (state) => (link, options) => \{
			        /* do something */
			      \},
			      updateState: (state) => (browserState) => \{
			        /* do something */
			      \},
			    \},
			  \},
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\router\\__tests__\\types.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\smart-adserver\\src\\components\\__tests__\\smart-ad.test.tsx', () => {
        const sourceCode = `
			import TestRenderer from "react-test-renderer";
			import SmartAd from "../smart-ad";
			import SmartAdserver from "../../../types";
			import \{ State \} from "frontity/types";
			import \{ Provider as ConnectProvider \} from "@frontity/connect";
			
			describe("SmartAdserver", () => \{
			  const getState = (): State<SmartAdserver> => (\{
			    smartAdserver: \{
			      isLoaded: true,
			    \},
			    fills: \{
			      smartAdserver: \{\},
			    \},
			  \});
			
			  test("Should render the SmartAd component", () => \{
			    const state = getState();
			
			    const smartAd = TestRenderer.create(
			      <ConnectProvider value=\{\{ state \}\}>
			        <SmartAd
			          callType="std"
			          siteId=\{1\}
			          pageId=\{1\}
			          formatId=\{1\}
			          tagId="test-smartad"
			          minHeight=\{200\}
			        />
			      </ConnectProvider>
			    ).toJSON();
			
			    expect(smartAd).toMatchInlineSnapshot(\`
			      <div
			        className="css-12102i0-SmartAd"
			        id="test-smartad"
			      />
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\smart-adserver\\src\\components\\__tests__\\smart-ad.test.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\source\\src\\__tests__\\data.tests.ts', () => {
        const sourceCode = `
			import \{ expectType \} from "frontity/types/helpers";
			import \{
			  // Types.
			  Data,
			  ErrorData,
			  ArchiveData,
			  TaxonomyData,
			  TermData,
			  CategoryData,
			  TagData,
			  AuthorData,
			  PostTypeArchiveData,
			  PostArchiveData,
			  DateData,
			  PostTypeData,
			  PostData,
			  PageData,
			  AttachmentData,
			  SearchData,
			  HomeData,
			  RedirectionData,
			\} from "../../types/data";
			import \{
			  // Type Guards.
			  isError,
			  isArchive,
			  isSearch,
			  isTerm,
			  isTaxonomy,
			  isCategory,
			  isTag,
			  isAuthor,
			  isDate,
			  isPostTypeArchive,
			  isPostArchive,
			  isPostType,
			  isPost,
			  isPage,
			  isAttachment,
			  isHome,
			  isRedirection,
			\} from "../data";
			import \{
			  // Data instances.
			  onlyStatus,
			  notFound,
			  term,
			  category,
			  tag,
			  author,
			  postTypeArchive,
			  postArchive,
			  dateArchive,
			  termWithSearchData,
			  categoryWithSearchData,
			  tagWithSearchData,
			  authorWithSearchData,
			  postTypeArchiveWithSearchData,
			  postArchiveWithSearchData,
			  dateArchiveWithSearchData,
			  postType,
			  post,
			  page,
			  attachment,
			  oldTaxonomy,
			  redirection,
			\} from "../../__tests__/mocks/data";
			
			describe("Data type guards", () => \{
			  // eslint-disable-next-line jest/expect-expect
			  test("Types are well defined", () => \{
			    const data: Data = onlyStatus;
			
			    if (isError(data)) \{
			      expectType<Data>(data);
			      expectType<ErrorData>(data);
			    \}
			
			    if (isArchive(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			    \}
			
			    if (isTerm(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<TermData>(data);
			      expectType<TaxonomyData>(data);
			    \}
			
			    // Type composition nesting other checks.
			    if (isTerm(data)) \{
			      if (isSearch(data)) \{
			        expectType<Data>(data);
			        expectType<ArchiveData>(data);
			        expectType<TermData>(data);
			        expectType<TermData & SearchData>(data);
			        expectType<TaxonomyData>(data);
			        expectType<TaxonomyData & SearchData>(data);
			      \}
			    \}
			
			    // Types can be composited in the same condition.
			    if (isTerm(data) && isSearch(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<TermData>(data);
			      expectType<TermData & SearchData>(data);
			      expectType<TaxonomyData>(data);
			      expectType<TaxonomyData & SearchData>(data);
			    \}
			
			    if (isCategory(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<TermData>(data);
			      expectType<TaxonomyData>(data);
			      expectType<CategoryData>(data);
			      if (isSearch(data)) expectType<CategoryData & SearchData>(data);
			    \}
			
			    if (isTag(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<TermData>(data);
			      expectType<TaxonomyData>(data);
			      expectType<TagData>(data);
			      if (isSearch(data)) expectType<TagData & SearchData>(data);
			    \}
			
			    if (isAuthor(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<AuthorData>(data);
			      if (isSearch(data)) expectType<AuthorData & SearchData>(data);
			    \}
			
			    if (isPostTypeArchive(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<PostTypeArchiveData>(data);
			      if (isSearch(data)) expectType<PostTypeArchiveData & SearchData>(data);
			    \}
			
			    if (isPostArchive(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<PostTypeArchiveData>(data);
			      expectType<PostArchiveData>(data);
			      if (isSearch(data)) expectType<PostArchiveData & SearchData>(data);
			      if (isHome(data)) expectType<PostArchiveData & HomeData>(data);
			    \}
			
			    if (isDate(data)) \{
			      expectType<Data>(data);
			      expectType<ArchiveData>(data);
			      expectType<DateData>(data);
			      if (isSearch(data)) expectType<DateData & SearchData>(data);
			    \}
			
			    if (isPostType(data)) \{
			      expectType<Data>(data);
			      expectType<PostTypeData>(data);
			    \}
			
			    if (isPost(data)) \{
			      expectType<Data>(data);
			      expectType<PostTypeData>(data);
			      expectType<PostData>(data);
			    \}
			
			    if (isPage(data)) \{
			      expectType<Data>(data);
			      expectType<PostTypeData>(data);
			      expectType<PageData>(data);
			      if (isHome(data)) expectType<PageData & HomeData>(data);
			    \}
			
			    if (isAttachment(data)) \{
			      expectType<Data>(data);
			      expectType<PostTypeData>(data);
			      expectType<AttachmentData>(data);
			    \}
			
			    if (isRedirection(data)) \{
			      expectType<Data>(data);
			      expectType<RedirectionData>(data);
			    \}
			  \});
			
			  test("\`isError\` should only recognize error data", () => \{
			    expect(isError(onlyStatus)).toBe(false);
			    // Error.
			    expect(isError(notFound)).toBe(true);
			    // Terms.
			    expect(isError(term)).toBe(false);
			    expect(isError(termWithSearchData)).toBe(false);
			    expect(isError(category)).toBe(false);
			    expect(isError(categoryWithSearchData)).toBe(false);
			    expect(isError(tag)).toBe(false);
			    expect(isError(tagWithSearchData)).toBe(false);
			    // Author
			    expect(isError(author)).toBe(false);
			    expect(isError(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isError(postTypeArchive)).toBe(false);
			    expect(isError(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isError(postArchive)).toBe(false);
			    expect(isError(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isError(dateArchive)).toBe(false);
			    expect(isError(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isError(postType)).toBe(false);
			    expect(isError(post)).toBe(false);
			    expect(isError(page)).toBe(false);
			    expect(isError(attachment)).toBe(false);
			    // Redirection Type
			    expect(isError(redirection)).toBe(false);
			  \});
			
			  test("\`isArchive\` should recognize archive data", () => \{
			    expect(isArchive(onlyStatus)).toBe(false);
			    // Error.
			    expect(isArchive(notFound)).toBe(false);
			    // Terms.
			    expect(isArchive(term)).toBe(true);
			    expect(isArchive(termWithSearchData)).toBe(true);
			    expect(isArchive(category)).toBe(true);
			    expect(isArchive(categoryWithSearchData)).toBe(true);
			    expect(isArchive(tag)).toBe(true);
			    expect(isArchive(tagWithSearchData)).toBe(true);
			    // Author
			    expect(isArchive(author)).toBe(true);
			    expect(isArchive(authorWithSearchData)).toBe(true);
			    // Post Type archive
			    expect(isArchive(postTypeArchive)).toBe(true);
			    expect(isArchive(postTypeArchiveWithSearchData)).toBe(true);
			    expect(isArchive(postArchive)).toBe(true);
			    expect(isArchive(postArchiveWithSearchData)).toBe(true);
			    // Date Archive
			    expect(isArchive(dateArchive)).toBe(true);
			    expect(isArchive(dateArchiveWithSearchData)).toBe(true);
			    // Post Types.
			    expect(isArchive(postType)).toBe(false);
			    expect(isArchive(post)).toBe(false);
			    expect(isArchive(page)).toBe(false);
			    expect(isArchive(attachment)).toBe(false);
			    // Redirection Type
			    expect(isArchive(redirection)).toBe(false);
			  \});
			
			  test("\`isTerm\` should recognize term data", () => \{
			    expect(isTerm(onlyStatus)).toBe(false);
			    // Error.
			    expect(isTerm(notFound)).toBe(false);
			    // Terms.
			    expect(isTerm(term)).toBe(true);
			    expect(isTerm(termWithSearchData)).toBe(true);
			    expect(isTerm(category)).toBe(true);
			    expect(isTerm(categoryWithSearchData)).toBe(true);
			    expect(isTerm(tag)).toBe(true);
			    expect(isTerm(tagWithSearchData)).toBe(true);
			    // Deprecated Taxonomy
			    expect(isTerm(oldTaxonomy)).toBe(true);
			    // Author
			    expect(isTerm(author)).toBe(false);
			    expect(isTerm(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isTerm(postTypeArchive)).toBe(false);
			    expect(isTerm(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isTerm(postArchive)).toBe(false);
			    expect(isTerm(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isTerm(dateArchive)).toBe(false);
			    expect(isTerm(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isTerm(postType)).toBe(false);
			    expect(isTerm(post)).toBe(false);
			    expect(isTerm(page)).toBe(false);
			    expect(isTerm(attachment)).toBe(false);
			    // Redirection Type
			    expect(isTerm(redirection)).toBe(false);
			  \});
			
			  test("\`isTaxonomy\` (deprecated) should recognize term data", () => \{
			    expect(isTaxonomy(onlyStatus)).toBe(false);
			    // Error.
			    expect(isTaxonomy(notFound)).toBe(false);
			    // Terms.
			    expect(isTaxonomy(term)).toBe(true);
			    expect(isTaxonomy(termWithSearchData)).toBe(true);
			    expect(isTaxonomy(category)).toBe(true);
			    expect(isTaxonomy(categoryWithSearchData)).toBe(true);
			    expect(isTaxonomy(tag)).toBe(true);
			    expect(isTaxonomy(tagWithSearchData)).toBe(true);
			    // Deprecated Taxonomy
			    expect(isTaxonomy(oldTaxonomy)).toBe(true);
			    // Author
			    expect(isTaxonomy(author)).toBe(false);
			    expect(isTaxonomy(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isTaxonomy(postTypeArchive)).toBe(false);
			    expect(isTaxonomy(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isTaxonomy(postArchive)).toBe(false);
			    expect(isTaxonomy(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isTaxonomy(dateArchive)).toBe(false);
			    expect(isTaxonomy(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isTaxonomy(postType)).toBe(false);
			    expect(isTaxonomy(post)).toBe(false);
			    expect(isTaxonomy(page)).toBe(false);
			    expect(isTaxonomy(attachment)).toBe(false);
			    // Redirection Type
			    expect(isTaxonomy(redirection)).toBe(false);
			  \});
			
			  test("\`isCategory\` should recognize category data", () => \{
			    expect(isCategory(onlyStatus)).toBe(false);
			    // Error.
			    expect(isCategory(notFound)).toBe(false);
			    // Terms.
			    expect(isCategory(term)).toBe(false);
			    expect(isCategory(termWithSearchData)).toBe(false);
			    expect(isCategory(category)).toBe(true);
			    expect(isCategory(categoryWithSearchData)).toBe(true);
			    expect(isCategory(tag)).toBe(false);
			    expect(isCategory(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isCategory(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isCategory(author)).toBe(false);
			    expect(isCategory(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isCategory(postTypeArchive)).toBe(false);
			    expect(isCategory(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isCategory(postArchive)).toBe(false);
			    expect(isCategory(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isCategory(dateArchive)).toBe(false);
			    expect(isCategory(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isCategory(postType)).toBe(false);
			    expect(isCategory(post)).toBe(false);
			    expect(isCategory(page)).toBe(false);
			    expect(isCategory(attachment)).toBe(false);
			    // Redirection Type
			    expect(isCategory(redirection)).toBe(false);
			  \});
			
			  test("\`isTag\` should recognize tag data", () => \{
			    expect(isTag(onlyStatus)).toBe(false);
			    // Error.
			    expect(isTag(notFound)).toBe(false);
			    // Terms.
			    expect(isTag(term)).toBe(false);
			    expect(isTag(termWithSearchData)).toBe(false);
			    expect(isTag(category)).toBe(false);
			    expect(isTag(categoryWithSearchData)).toBe(false);
			    expect(isTag(tag)).toBe(true);
			    expect(isTag(tagWithSearchData)).toBe(true);
			    // Deprecated Taxonomy
			    expect(isTag(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isTag(author)).toBe(false);
			    expect(isTag(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isTag(postTypeArchive)).toBe(false);
			    expect(isTag(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isTag(postArchive)).toBe(false);
			    expect(isTag(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isTag(dateArchive)).toBe(false);
			    expect(isTag(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isTag(postType)).toBe(false);
			    expect(isTag(post)).toBe(false);
			    expect(isTag(page)).toBe(false);
			    expect(isTag(attachment)).toBe(false);
			    // Redirection Type
			    expect(isTag(redirection)).toBe(false);
			  \});
			
			  test("\`isAuthor\` should recognize author data", () => \{
			    expect(isAuthor(onlyStatus)).toBe(false);
			    // Error.
			    expect(isAuthor(notFound)).toBe(false);
			    // Terms.
			    expect(isAuthor(term)).toBe(false);
			    expect(isAuthor(termWithSearchData)).toBe(false);
			    expect(isAuthor(category)).toBe(false);
			    expect(isAuthor(categoryWithSearchData)).toBe(false);
			    expect(isAuthor(tag)).toBe(false);
			    expect(isAuthor(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isAuthor(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isAuthor(author)).toBe(true);
			    expect(isAuthor(authorWithSearchData)).toBe(true);
			    // Post Type archive
			    expect(isAuthor(postTypeArchive)).toBe(false);
			    expect(isAuthor(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isAuthor(postArchive)).toBe(false);
			    expect(isAuthor(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isAuthor(dateArchive)).toBe(false);
			    expect(isAuthor(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isAuthor(postType)).toBe(false);
			    expect(isAuthor(post)).toBe(false);
			    expect(isAuthor(page)).toBe(false);
			    expect(isAuthor(attachment)).toBe(false);
			    // Redirection Type
			    expect(isAuthor(redirection)).toBe(false);
			  \});
			
			  test("\`isPostTypeArchive\` should recognize post type archive data", () => \{
			    expect(isPostTypeArchive(onlyStatus)).toBe(false);
			    // Error.
			    expect(isPostTypeArchive(notFound)).toBe(false);
			    // Terms.
			    expect(isPostTypeArchive(term)).toBe(false);
			    expect(isPostTypeArchive(termWithSearchData)).toBe(false);
			    expect(isPostTypeArchive(category)).toBe(false);
			    expect(isPostTypeArchive(categoryWithSearchData)).toBe(false);
			    expect(isPostTypeArchive(tag)).toBe(false);
			    expect(isPostTypeArchive(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isPostTypeArchive(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isPostTypeArchive(author)).toBe(false);
			    expect(isPostTypeArchive(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isPostTypeArchive(postTypeArchive)).toBe(true);
			    expect(isPostTypeArchive(postTypeArchiveWithSearchData)).toBe(true);
			    expect(isPostTypeArchive(postArchive)).toBe(true);
			    expect(isPostTypeArchive(postArchiveWithSearchData)).toBe(true);
			    // Date Archive
			    expect(isPostTypeArchive(dateArchive)).toBe(false);
			    expect(isPostTypeArchive(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isPostTypeArchive(postType)).toBe(false);
			    expect(isPostTypeArchive(post)).toBe(false);
			    expect(isPostTypeArchive(page)).toBe(false);
			    expect(isPostTypeArchive(attachment)).toBe(false);
			    // Redirection Type
			    expect(isPostTypeArchive(redirection)).toBe(false);
			  \});
			
			  test("\`isPostArchive\` should recognize post archive data", () => \{
			    expect(isPostArchive(onlyStatus)).toBe(false);
			    // Error.
			    expect(isPostArchive(notFound)).toBe(false);
			    // Terms.
			    expect(isPostArchive(term)).toBe(false);
			    expect(isPostArchive(termWithSearchData)).toBe(false);
			    expect(isPostArchive(category)).toBe(false);
			    expect(isPostArchive(categoryWithSearchData)).toBe(false);
			    expect(isPostArchive(tag)).toBe(false);
			    expect(isPostArchive(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isPostArchive(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isPostArchive(author)).toBe(false);
			    expect(isPostArchive(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isPostArchive(postTypeArchive)).toBe(false);
			    expect(isPostArchive(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isPostArchive(postArchive)).toBe(true);
			    expect(isPostArchive(postArchiveWithSearchData)).toBe(true);
			    // Date Archive
			    expect(isPostArchive(dateArchive)).toBe(false);
			    expect(isPostArchive(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isPostArchive(postType)).toBe(false);
			    expect(isPostArchive(post)).toBe(false);
			    expect(isPostArchive(page)).toBe(false);
			    expect(isPostArchive(attachment)).toBe(false);
			    // Redirection Type
			    expect(isPostArchive(redirection)).toBe(false);
			  \});
			
			  test("\`isDate\` should recognize date archive data", () => \{
			    expect(isDate(onlyStatus)).toBe(false);
			    // Error.
			    expect(isDate(notFound)).toBe(false);
			    // Terms.
			    expect(isDate(term)).toBe(false);
			    expect(isDate(termWithSearchData)).toBe(false);
			    expect(isDate(category)).toBe(false);
			    expect(isDate(categoryWithSearchData)).toBe(false);
			    expect(isDate(tag)).toBe(false);
			    expect(isDate(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isDate(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isDate(author)).toBe(false);
			    expect(isDate(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isDate(postTypeArchive)).toBe(false);
			    expect(isDate(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isDate(postArchive)).toBe(false);
			    expect(isDate(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isDate(dateArchive)).toBe(true);
			    expect(isDate(dateArchiveWithSearchData)).toBe(true);
			    // Post Types.
			    expect(isDate(postType)).toBe(false);
			    expect(isDate(post)).toBe(false);
			    expect(isDate(page)).toBe(false);
			    expect(isDate(attachment)).toBe(false);
			    // Redirection Type
			    expect(isDate(redirection)).toBe(false);
			  \});
			
			  test("\`isSearch\` should recognize search data", () => \{
			    expect(isSearch(onlyStatus)).toBe(false);
			    // Error.
			    expect(isSearch(notFound)).toBe(false);
			    // Terms.
			    expect(isSearch(term)).toBe(false);
			    expect(isSearch(termWithSearchData)).toBe(true);
			    expect(isSearch(category)).toBe(false);
			    expect(isSearch(categoryWithSearchData)).toBe(true);
			    expect(isSearch(tag)).toBe(false);
			    expect(isSearch(tagWithSearchData)).toBe(true);
			    // Deprecated Taxonomy
			    expect(isSearch(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isSearch(author)).toBe(false);
			    expect(isSearch(authorWithSearchData)).toBe(true);
			    // Post Type archive
			    expect(isSearch(postTypeArchive)).toBe(false);
			    expect(isSearch(postTypeArchiveWithSearchData)).toBe(true);
			    expect(isSearch(postArchive)).toBe(false);
			    expect(isSearch(postArchiveWithSearchData)).toBe(true);
			    // Date Archive
			    expect(isSearch(dateArchive)).toBe(false);
			    expect(isSearch(dateArchiveWithSearchData)).toBe(true);
			    // Post Types.
			    expect(isSearch(postType)).toBe(false);
			    expect(isSearch(post)).toBe(false);
			    expect(isSearch(page)).toBe(false);
			    expect(isSearch(attachment)).toBe(false);
			    // Redirection Type
			    expect(isSearch(redirection)).toBe(false);
			  \});
			
			  test("\`isPostType\` should recognize post type data", () => \{
			    expect(isPostType(onlyStatus)).toBe(false);
			    // Error.
			    expect(isPostType(notFound)).toBe(false);
			    // Terms.
			    expect(isPostType(term)).toBe(false);
			    expect(isPostType(termWithSearchData)).toBe(false);
			    expect(isPostType(category)).toBe(false);
			    expect(isPostType(categoryWithSearchData)).toBe(false);
			    expect(isPostType(tag)).toBe(false);
			    expect(isPostType(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isPostType(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isPostType(author)).toBe(false);
			    expect(isPostType(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isPostType(postTypeArchive)).toBe(false);
			    expect(isPostType(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isPostType(postArchive)).toBe(false);
			    expect(isPostType(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isPostType(dateArchive)).toBe(false);
			    expect(isPostType(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isPostType(postType)).toBe(true);
			    expect(isPostType(post)).toBe(true);
			    expect(isPostType(page)).toBe(true);
			    expect(isPostType(attachment)).toBe(true);
			    // Redirection Type
			    expect(isPostType(redirection)).toBe(false);
			  \});
			
			  test("\`isPost\` should recognize post data", () => \{
			    expect(isPost(onlyStatus)).toBe(false);
			    // Error.
			    expect(isPost(notFound)).toBe(false);
			    // Terms.
			    expect(isPost(term)).toBe(false);
			    expect(isPost(termWithSearchData)).toBe(false);
			    expect(isPost(category)).toBe(false);
			    expect(isPost(categoryWithSearchData)).toBe(false);
			    expect(isPost(tag)).toBe(false);
			    expect(isPost(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isPost(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isPost(author)).toBe(false);
			    expect(isPost(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isPost(postTypeArchive)).toBe(false);
			    expect(isPost(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isPost(postArchive)).toBe(false);
			    expect(isPost(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isPost(dateArchive)).toBe(false);
			    expect(isPost(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isPost(postType)).toBe(false);
			    expect(isPost(post)).toBe(true);
			    expect(isPost(page)).toBe(false);
			    expect(isPost(attachment)).toBe(false);
			
			    // Redirection Type
			    expect(isPost(redirection)).toBe(false);
			  \});
			
			  test("\`isPage\` should recognize page data", () => \{
			    expect(isPage(onlyStatus)).toBe(false);
			    // Error.
			    expect(isPage(notFound)).toBe(false);
			    // Terms.
			    expect(isPage(term)).toBe(false);
			    expect(isPage(termWithSearchData)).toBe(false);
			    expect(isPage(category)).toBe(false);
			    expect(isPage(categoryWithSearchData)).toBe(false);
			    expect(isPage(tag)).toBe(false);
			    expect(isPage(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isPage(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isPage(author)).toBe(false);
			    expect(isPage(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isPage(postTypeArchive)).toBe(false);
			    expect(isPage(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isPage(postArchive)).toBe(false);
			    expect(isPage(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isPage(dateArchive)).toBe(false);
			    expect(isPage(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isPage(postType)).toBe(false);
			    expect(isPage(post)).toBe(false);
			    expect(isPage(page)).toBe(true);
			    expect(isPage(attachment)).toBe(false);
			    // Redirection Type
			    expect(isPage(redirection)).toBe(false);
			  \});
			
			  test("\`isAttachment\` should recognize attachment data", () => \{
			    expect(isAttachment(onlyStatus)).toBe(false);
			    // Error.
			    expect(isAttachment(notFound)).toBe(false);
			    // Terms.
			    expect(isAttachment(term)).toBe(false);
			    expect(isAttachment(termWithSearchData)).toBe(false);
			    expect(isAttachment(category)).toBe(false);
			    expect(isAttachment(categoryWithSearchData)).toBe(false);
			    expect(isAttachment(tag)).toBe(false);
			    expect(isAttachment(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isAttachment(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isAttachment(author)).toBe(false);
			    expect(isAttachment(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isAttachment(postTypeArchive)).toBe(false);
			    expect(isAttachment(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isAttachment(postArchive)).toBe(false);
			    expect(isAttachment(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isAttachment(dateArchive)).toBe(false);
			    expect(isAttachment(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isAttachment(postType)).toBe(false);
			    expect(isAttachment(post)).toBe(false);
			    expect(isAttachment(page)).toBe(false);
			    expect(isAttachment(attachment)).toBe(true);
			    // Redirection Type
			    expect(isAttachment(redirection)).toBe(false);
			  \});
			
			  test("\`isHome\` should recognize the home data", () => \{
			    expect(isHome(onlyStatus)).toBe(false);
			    // Error.
			    expect(isHome(notFound)).toBe(false);
			    // Terms.
			    expect(isHome(term)).toBe(false);
			    expect(isHome(termWithSearchData)).toBe(false);
			    expect(isHome(category)).toBe(false);
			    expect(isHome(categoryWithSearchData)).toBe(false);
			    expect(isHome(tag)).toBe(false);
			    expect(isHome(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isHome(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isHome(author)).toBe(false);
			    expect(isHome(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isHome(postTypeArchive)).toBe(false);
			    expect(isHome(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isHome(postArchive)).toBe(true);
			    expect(isHome(postArchiveWithSearchData)).toBe(true);
			    // Date Archive
			    expect(isHome(dateArchive)).toBe(false);
			    expect(isHome(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isHome(postType)).toBe(false);
			    expect(isHome(post)).toBe(false);
			    expect(isHome(page)).toBe(false);
			    expect(isHome(attachment)).toBe(false);
			    // Redirection Type
			    expect(isHome(redirection)).toBe(false);
			  \});
			
			  test("\`isRedirection\` should recognize the redirection data", () => \{
			    expect(isRedirection(onlyStatus)).toBe(false);
			    // Error.
			    expect(isRedirection(notFound)).toBe(false);
			    // Terms.
			    expect(isRedirection(term)).toBe(false);
			    expect(isRedirection(termWithSearchData)).toBe(false);
			    expect(isRedirection(category)).toBe(false);
			    expect(isRedirection(categoryWithSearchData)).toBe(false);
			    expect(isRedirection(tag)).toBe(false);
			    expect(isRedirection(tagWithSearchData)).toBe(false);
			    // Deprecated Taxonomy
			    expect(isRedirection(oldTaxonomy)).toBe(false);
			    // Author
			    expect(isRedirection(author)).toBe(false);
			    expect(isRedirection(authorWithSearchData)).toBe(false);
			    // Post Type archive
			    expect(isRedirection(postTypeArchive)).toBe(false);
			    expect(isRedirection(postTypeArchiveWithSearchData)).toBe(false);
			    expect(isRedirection(postArchive)).toBe(false);
			    expect(isRedirection(postArchiveWithSearchData)).toBe(false);
			    // Date Archive
			    expect(isRedirection(dateArchive)).toBe(false);
			    expect(isRedirection(dateArchiveWithSearchData)).toBe(false);
			    // Post Types.
			    expect(isRedirection(postType)).toBe(false);
			    expect(isRedirection(post)).toBe(false);
			    expect(isRedirection(page)).toBe(false);
			    expect(isRedirection(attachment)).toBe(false);
			    expect(isRedirection(attachment)).toBe(false);
			    // Redirection Type
			    expect(isRedirection(redirection)).toBe(true);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\source\\src\\__tests__\\data.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(18)
    });
    it('frontity_frontity\\packages\\source\\src\\__tests__\\entities.tests.ts', () => {
        const sourceCode = `
			import * as typeGuards from "../entities";
			import * as mocks from "../../__tests__/mocks/entities";
			
			describe("Entities type guards", () => \{
			  test("\`isPostTypeEntity\` should recognize post type entities", () => \{
			    expect(typeGuards.isPostTypeEntity(mocks.post)).toBe(true);
			    expect(typeGuards.isPostTypeEntity(mocks.page)).toBe(true);
			    expect(typeGuards.isPostTypeEntity(mocks.attachment)).toBe(true);
			    expect(typeGuards.isPostTypeEntity(mocks.comment)).toBe(true);
			    expect(typeGuards.isPostTypeEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isPostTypeEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isPostTypeEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isPostTypeEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isPostEntity\` should recognize only post entities", () => \{
			    expect(typeGuards.isPostEntity(mocks.post)).toBe(true);
			    expect(typeGuards.isPostEntity(mocks.page)).toBe(false);
			    expect(typeGuards.isPostEntity(mocks.attachment)).toBe(false);
			    expect(typeGuards.isPostEntity(mocks.comment)).toBe(false);
			    expect(typeGuards.isPostEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isPostEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isPostEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isPostEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isPageEntity\` should recognize only page entities", () => \{
			    expect(typeGuards.isPageEntity(mocks.post)).toBe(false);
			    expect(typeGuards.isPageEntity(mocks.page)).toBe(true);
			    expect(typeGuards.isPageEntity(mocks.attachment)).toBe(false);
			    expect(typeGuards.isPageEntity(mocks.comment)).toBe(false);
			    expect(typeGuards.isPageEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isPageEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isPageEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isPageEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isAttachmentEntity\` should recognize only attachment entities", () => \{
			    expect(typeGuards.isAttachmentEntity(mocks.post)).toBe(false);
			    expect(typeGuards.isAttachmentEntity(mocks.page)).toBe(false);
			    expect(typeGuards.isAttachmentEntity(mocks.attachment)).toBe(true);
			    expect(typeGuards.isAttachmentEntity(mocks.comment)).toBe(false);
			    expect(typeGuards.isAttachmentEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isAttachmentEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isAttachmentEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isAttachmentEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isCommentEntity\` should recognize only comment entities", () => \{
			    expect(typeGuards.isCommentEntity(mocks.post)).toBe(false);
			    expect(typeGuards.isCommentEntity(mocks.page)).toBe(false);
			    expect(typeGuards.isCommentEntity(mocks.attachment)).toBe(false);
			    expect(typeGuards.isCommentEntity(mocks.comment)).toBe(true);
			    expect(typeGuards.isCommentEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isCommentEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isCommentEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isCommentEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isTermEntity\` should recognize term entities", () => \{
			    expect(typeGuards.isTermEntity(mocks.post)).toBe(false);
			    expect(typeGuards.isTermEntity(mocks.page)).toBe(false);
			    expect(typeGuards.isTermEntity(mocks.attachment)).toBe(false);
			    expect(typeGuards.isTermEntity(mocks.comment)).toBe(false);
			    expect(typeGuards.isTermEntity(mocks.category)).toBe(true);
			    expect(typeGuards.isTermEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isTermEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isTermEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isAuthorEntity\` should recognize author entities", () => \{
			    expect(typeGuards.isAuthorEntity(mocks.post)).toBe(false);
			    expect(typeGuards.isAuthorEntity(mocks.page)).toBe(false);
			    expect(typeGuards.isAuthorEntity(mocks.attachment)).toBe(false);
			    expect(typeGuards.isAuthorEntity(mocks.comment)).toBe(false);
			    expect(typeGuards.isAuthorEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isAuthorEntity(mocks.author)).toBe(true);
			    expect(typeGuards.isAuthorEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isAuthorEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isTaxonomyEntity\` should recognize taxonomy entities", () => \{
			    expect(typeGuards.isTaxonomyEntity(mocks.post)).toBe(false);
			    expect(typeGuards.isTaxonomyEntity(mocks.page)).toBe(false);
			    expect(typeGuards.isTaxonomyEntity(mocks.attachment)).toBe(false);
			    expect(typeGuards.isTaxonomyEntity(mocks.comment)).toBe(false);
			    expect(typeGuards.isTaxonomyEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isTaxonomyEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isTaxonomyEntity(mocks.taxonomy)).toBe(true);
			    expect(typeGuards.isTaxonomyEntity(mocks.postType)).toBe(false);
			  \});
			
			  test("\`isTypeEntity\` should recognize type entities", () => \{
			    expect(typeGuards.isTypeEntity(mocks.post)).toBe(false);
			    expect(typeGuards.isTypeEntity(mocks.page)).toBe(false);
			    expect(typeGuards.isTypeEntity(mocks.attachment)).toBe(false);
			    expect(typeGuards.isTypeEntity(mocks.comment)).toBe(false);
			    expect(typeGuards.isTypeEntity(mocks.category)).toBe(false);
			    expect(typeGuards.isTypeEntity(mocks.author)).toBe(false);
			    expect(typeGuards.isTypeEntity(mocks.taxonomy)).toBe(false);
			    expect(typeGuards.isTypeEntity(mocks.postType)).toBe(true);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\source\\src\\__tests__\\entities.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('frontity_frontity\\packages\\source\\types\\__tests__\\data.tests.ts', () => {
        const sourceCode = `
			import \{ Data, TaxonomyData \} from "../data";
			import \{ expectType \} from "frontity/types/helpers";
			import \{
			  onlyStatus,
			  notFound,
			  term,
			  termWithSearchData,
			  category,
			  categoryWithSearchData,
			  tag,
			  tagWithSearchData,
			  author,
			  authorWithSearchData,
			  postTypeArchive,
			  postTypeArchiveWithSearchData,
			  postArchive,
			  postArchiveWithSearchData,
			  dateArchive,
			  dateArchiveWithSearchData,
			  postType,
			  post,
			  page,
			  attachment,
			  redirection,
			\} from "../../__tests__/mocks/data";
			
			const data: Record<string, Data> = \{\};
			
			// As long as it extends \`Data\`, any object can be added to \`data\`.
			data.onlyStatus = onlyStatus;
			data.notFound = notFound;
			data.term = term;
			data.termWithSearchData = termWithSearchData;
			data.category = category;
			data.categoryWithSearchData = categoryWithSearchData;
			data.tag = tag;
			data.tagWithSearchData = tagWithSearchData;
			data.author = author;
			data.authorWithSearchData = authorWithSearchData;
			data.postTypeArchive = postTypeArchive;
			data.postTypeArchiveWithSearchData = postTypeArchiveWithSearchData;
			data.postArchive = postArchive;
			data.postArchiveWithSearchData = postArchiveWithSearchData;
			data.dateArchive = dateArchive;
			data.dateArchiveWithSearchData = dateArchiveWithSearchData;
			data.postType = postType;
			data.post = post;
			data.page = page;
			data.attachment = attachment;
			data.redirection = redirection;
			
			// Check that TermData and TaxonomyData are equivalent.
			const taxonomy: TaxonomyData = term;
			expectType<true>(taxonomy.isTaxonomy);
			expectType<true>(taxonomy.isTerm);
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\source\\types\\__tests__\\data.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\source\\types\\__tests__\\entity.tests.ts', () => {
        const sourceCode = `
			import \{ Entity \} from "../entities";
			import \{
			  author,
			  category,
			  tag,
			  post,
			  attachment,
			  postType,
			  taxonomy,
			\} from "../../__tests__/mocks/entities";
			
			const entity: Record<string, Entity> = \{\};
			
			// As long as it extends \`Entity\`, any object can be added to \`Entity\`.
			entity.author = author;
			entity.category = category;
			entity.tag = tag;
			entity.post = post;
			entity.attachment = attachment;
			entity.postType = postType;
			entity.taxonomy = taxonomy;
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\source\\types\\__tests__\\entity.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\source\\types\\__tests__\\source.tests.ts', () => {
        const sourceCode = `
			import \{ Action, Derived, Settings \} from "frontity/types";
			import Source from "../../types";
			
			// Source.
			const source1 = (libraries: Source["libraries"]): Source => \{
			  const myInternalArray = [];
			
			  return \{
			    state: \{
			      source: \{
			        get: (\{ state \}) => (link) => state.source.data[""],
			        entity: (\{ state \}) => <T>(link) => state.source.post[1] as T,
			        url: "https://test.frontity.org",
			        data: \{\},
			        category: \{\},
			        tag: \{\},
			        post: \{\},
			        page: \{\},
			        author: \{\},
			        attachment: \{\},
			        type: \{\},
			        taxonomy: \{\},
			        redirections: "no",
			      \},
			    \},
			    actions: \{
			      source: \{
			        fetch: (\{ state \}) => async (link) => \{\},
			      \},
			    \},
			    libraries: \{
			      source: \{
			        parse: () => (\{ path: "" \}),
			        stringify: () => "/route/",
			        normalize: () => "/route/",
			      \},
			    \},
			  \};
			\};
			
			// Extended Source.
			interface MySource extends Source \{
			  name: "my-source-package";
			  state: \{
			    source: Source["state"]["source"] & \{
			      // And other props.
			      api: Derived<MySource, string> | string;
			      myOwnProp: string;
			    \};
			  \};
			  actions: Source["actions"] & \{
			    // And other actions.
			    source: \{
			      myOwnAction: Action<MySource>;
			    \};
			  \};
			\}
			
			const source2: MySource = \{
			  name: "my-source-package",
			  state: \{
			    source: \{
			      url: (\{ state \}) => "https://test.frontity.org/",
			      api: (\{ state \}) => state.source.url,
			      get: (\{ state \}) => (link) => state.source.data[""],
			      entity: (\{ state \}) => <T>(link) => state.source.post[1] as T,
			      data: \{\},
			      category: \{\},
			      tag: \{\},
			      post: \{\},
			      page: \{\},
			      author: \{\},
			      attachment: \{\},
			      myOwnProp: "some value",
			      type: \{\},
			      taxonomy: \{\},
			      redirections: "no",
			    \},
			  \},
			  actions: \{
			    source: \{
			      fetch: (\{ state \}) => async (link) => \{\},
			      myOwnAction: (\{ state \}) => \{\},
			    \},
			  \},
			  libraries: \{
			    source: \{
			      parse: () => (\{ path: "" \}),
			      stringify: () => "/route/",
			      normalize: () => "/route/",
			    \},
			  \},
			\};
			
			// Package settings from extended Source.
			// -- No settings, no namespace;
			const settings1: Settings<MySource> = \{
			  packages: [
			    \{
			      name: "my-source-package",
			    \},
			  ],
			\};
			// -- No settings, only one namespace selected;
			const settings2: Settings<MySource> = \{
			  packages: [
			    \{
			      name: "my-source-package",
			    \},
			  ],
			\};
			// -- Settings;
			const settings3: Settings<MySource> = \{
			  packages: [
			    \{
			      name: "my-source-package",
			      state: \{
			        source: \{
			          api: "https://tes.frontity.org/wp-json",
			        \},
			      \},
			    \},
			  ],
			\};
			// -- Settings;
			const settings4: Settings<MySource> = \{
			  packages: [
			    \{
			      name: "my-source-package",
			      state: \{
			        source: \{
			          url: "https://tes.frontity.org",
			        \},
			      \},
			    \},
			  ],
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\source\\types\\__tests__\\source.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\tiny-router\\src\\__tests__\\index.test.ts', () => {
        const sourceCode = `
			import * as frontity from "frontity";
			import * as frontityError from "@frontity/error";
			import \{ Context \} from "frontity/types";
			import tinyRouter from "..";
			import \{ Packages \} from "../../types";
			import \{ SetOptions \} from "@frontity/router/types";
			import \{ RedirectionData \} from "@frontity/source/types";
			
			let config: any;
			let normalize: jest.Mock;
			let fetch: jest.Mock;
			let get: jest.Mock;
			
			const createStore = (config) => frontity.createStore<Packages>(config);
			
			const spiedPushState = jest.spyOn(window.history, "pushState");
			const spiedReplaceState = jest.spyOn(window.history, "replaceState");
			
			beforeEach(() => \{
			  normalize = jest.fn().mockImplementation((link) => \{
			    const \{ pathname, search, hash \} = new URL(link, "https://dummy.com");
			    return pathname + search + hash;
			  \});
			  fetch = jest.fn();
			  get = jest.fn().mockReturnValue(\{ isReady: false, isFetching: false \});
			
			  config = \{
			    name: "@frontity/tiny-router",
			    state: \{
			      frontity: \{
			        platform: "client",
			        initialLink: "/initial/link/",
			      \},
			      router: \{ ...tinyRouter.state.router \},
			      source: \{
			        get: () => get,
			        data: \{\},
			      \},
			    \},
			    actions: \{
			      router: \{
			        ...tinyRouter.actions.router,
			      \},
			      source: \{
			        fetch: () => fetch,
			      \},
			    \},
			    libraries: \{
			      source: \{
			        normalize,
			      \},
			    \},
			  \};
			\});
			
			afterEach(() => \{
			  jest.clearAllMocks();
			\});
			
			describe("actions", () => \{
			  describe("set", () => \{
			    it("should work just with links", () => \{
			      const store = createStore(config);
			      const link = "/some-post/";
			
			      store.actions.router.set(link);
			
			      expect(normalize).toHaveBeenCalledWith(link);
			      expect(spiedPushState).toHaveBeenCalledTimes(1);
			      expect(store.state.router.link).toBe(link);
			    \});
			
			    it("should work with full URLs", () => \{
			      const store = createStore(config);
			      const link = "https://blog.example/some-post/page/3/?some=query";
			
			      store.actions.router.set(link);
			
			      expect(normalize).toHaveBeenCalledWith(link);
			      expect(store.state.router.link).toBe("/some-post/page/3/?some=query");
			      expect(spiedPushState).toHaveBeenCalledTimes(1);
			    \});
			
			    it("should not create new history entry if link is the same", () => \{
			      const store = createStore(config);
			
			      const link = "/some-post/";
			
			      store.actions.router.set(link);
			      expect(spiedPushState).toHaveBeenCalledTimes(1);
			
			      store.actions.router.set(link);
			      expect(spiedPushState).toHaveBeenCalledTimes(1);
			    \});
			
			    it("should populate latest link, method and state", () => \{
			      const store = createStore(config);
			      const link = "/some-post/page/3/?some=query";
			      const options: SetOptions = \{
			        method: "replace",
			        state: \{
			          initial: 1,
			          pages: [1, 2, 3],
			        \},
			      \};
			
			      store.actions.router.set(link, options);
			
			      expect(store.state.router.link).toBe(link);
			      expect(store.state.router.state).toEqual(options.state);
			    \});
			
			    it("should populate previous link if current link and next link are different", () => \{
			      const store = createStore(config);
			
			      const current = "/";
			      const next = "/page/2/";
			
			      store.state.router.link = current;
			
			      store.actions.router.set(next);
			      expect(store.state.router.link).toBe(next);
			      expect(store.state.router.previous).toBe(current);
			    \});
			
			    it("should not populate previous link if current link and next link are the same", () => \{
			      const store = createStore(config);
			
			      const current = "/page/2/";
			      const next = "/page/2/";
			
			      store.state.router.link = current;
			
			      store.actions.router.set(next);
			      expect(store.state.router.link).toBe(next);
			      expect(store.state.router.previous).toBeUndefined();
			    \});
			
			    it("should follow the \`options.method\` in the client", () => \{
			      const store = createStore(config);
			      store.state.frontity.platform = "client";
			
			      const link = "/some-post/";
			      const options: SetOptions = \{
			        method: "push",
			      \};
			
			      store.actions.router.set(link, options);
			      expect(spiedPushState).toHaveBeenCalledTimes(1);
			
			      const link2 = "/other-post/";
			      options.method = "replace";
			
			      store.actions.router.set(link2, options);
			      expect(spiedReplaceState).toHaveBeenCalledTimes(1);
			    \});
			
			    it("should clone the history state and store it in \`window.history\`", () => \{
			      const store = createStore(config);
			      store.state.frontity.platform = "client";
			
			      const link = "/some-post/";
			      const options: SetOptions = \{
			        method: "push",
			        state: \{
			          initial: 1,
			          pages: [1, 2, 3],
			        \},
			      \};
			
			      store.actions.router.set(link, options);
			      expect(store.state.router.state).toEqual(options.state);
			      expect(window.history.state).toEqual(options.state);
			      expect(window.history.state).not.toBe(options.state);
			      expect(window.history.state.pages).not.toBe(options.state.pages);
			
			      options.method = "replace";
			
			      store.actions.router.set(link, options);
			      expect(store.state.router.state).toEqual(options.state);
			      expect(window.history.state).toEqual(options.state);
			      expect(window.history.state).not.toBe(options.state);
			      expect(window.history.state.pages).not.toBe(options.state.pages);
			    \});
			
			    it("should fetch if \`autoFetch\` is enabled", () => \{
			      const store = createStore(config);
			      store.state.frontity.platform = "client";
			
			      let link = "/first-link/";
			
			      store.actions.router.set(link);
			      expect(fetch).toHaveBeenCalledTimes(1);
			      expect(fetch).toHaveBeenLastCalledWith(link);
			
			      link = "/second-link/";
			
			      store.actions.router.set(link, \{ method: "replace" \});
			      expect(fetch).toHaveBeenCalledTimes(2);
			      expect(fetch).toHaveBeenLastCalledWith(link);
			    \});
			
			    it("should redirect to the final link if there is an internal redirection", () => \{
			      const store = createStore(config);
			
			      get.mockReturnValue(\{
			        isReady: true,
			        isFetching: false,
			        link: "/initial-url/",
			        route: "/initial-url/",
			        page: 1,
			        query: \{\},
			        isRedirection: true,
			        isExternal: false,
			        location: "https://backend.com/final-url/",
			      \});
			
			      store.actions.router.set("/initial-url");
			
			      expect(store.state.router.link).toBe("/final-url/");
			    \});
			
			    it("should redirect to the final link if there is an external redirection", () => \{
			      const store = createStore(config);
			
			      get.mockReturnValue(\{
			        isReady: true,
			        isFetching: false,
			        link: "/initial-url/",
			        route: "/initial-url/",
			        page: 1,
			        query: \{\},
			        isRedirection: true,
			        isExternal: true,
			        location: "https://external.com/final-url",
			      \});
			
			      window.replaceLocation = jest.fn();
			
			      store.actions.router.set("/initial-url");
			
			      expect(window.replaceLocation).toHaveBeenCalledWith(
			        "https://external.com/final-url"
			      );
			    \});
			  \});
			
			  describe("updateState", () => \{
			    test("should replace the current browser state with the new state", () => \{
			      const store = createStore(config);
			      const currentState = \{
			        links: ["/"],
			      \};
			
			      const link = store.state.router.link;
			      store.state.router.state = currentState;
			
			      const nextState = \{
			        links: ["/", "/page/2/"],
			      \};
			
			      expect(store.state.router.link).toBe(link);
			      expect(store.state.router.state).toEqual(currentState);
			
			      store.actions.router.updateState(nextState);
			
			      expect(store.state.router.link).toBe(link);
			      expect(store.state.router.state).toEqual(nextState);
			      expect(spiedReplaceState).toHaveBeenCalledTimes(1);
			      expect(spiedReplaceState).toHaveBeenCalledWith(nextState, "");
			    \});
			  \});
			
			  describe("init", () => \{
			    it("should populate the initial link", () => \{
			      const store = createStore(config);
			      store.state.frontity.platform = "server";
			
			      store.actions.router.init();
			
			      // check that first state is correct
			      expect(normalize).toHaveBeenCalledTimes(1);
			      expect(normalize).toHaveBeenCalledWith("/initial/link/");
			      expect(store.state.router.link).toBe("/initial/link/");
			    \});
			
			    it("should fire \`replaceState\` in the init to populate the history state", () => \{
			      config.state.frontity.platform = "client";
			      const store = createStore(config);
			      store.state.router.state = \{ some: "state" \};
			
			      store.actions.router.init();
			
			      expect(spiedReplaceState).toHaveBeenCalledTimes(1);
			      expect(window.history.state).toEqual(store.state.router.state);
			    \});
			
			    it('should add event handler for "popstate" events', () => \{
			      config.state.frontity.platform = "client";
			      const store = createStore(config);
			      store.actions.router.init();
			
			      const pathname = "/about-us/";
			      const search = "?id=3&search=value";
			      const hash = "#element";
			      const link = pathname + search + hash;
			
			      const oldLocation = window.location;
			      delete window.location;
			      (window.location as any) = \{ pathname, search, hash \};
			
			      // Checks that there is an event listener handleling \`popstate\`.
			      window.dispatchEvent(
			        new PopStateEvent("popstate", \{ state: \{ some: "different state" \} \})
			      );
			
			      expect(store.state.router.link).toBe(link);
			      expect(store.state.router.state).toEqual(\{ some: "different state" \});
			      expect(store.state.router.state).not.toBe(\{ some: "different state" \});
			
			      window.location = oldLocation;
			    \});
			
			    it("should trigger a new \`action.router.set\` if the current data object is an internal redirection", () => \{
			      config.state.frontity.platform = "client";
			      const store = createStore(config);
			      get.mockImplementation((_) => store.state.source.data["/"]);
			
			      store.actions.router.init();
			
			      const redirection: RedirectionData = \{
			        isReady: true,
			        isFetching: false,
			        link: "/initial-url/",
			        route: "/initial-url/",
			        page: 1,
			        query: \{\},
			        isRedirection: true,
			        redirectionStatus: 301,
			        isExternal: false,
			        location: "https://backend.com/final-url/",
			      \};
			      store.state.source.data["/"] = redirection;
			
			      expect(store.state.router.link).toBe("/final-url/");
			    \});
			
			    it("should do SSR if the current data object is an external redirection", () => \{
			      config.state.frontity.platform = "client";
			      const store = createStore(config);
			      get.mockImplementation((_) => store.state.source.data["/"]);
			      window.replaceLocation = jest.fn();
			
			      store.actions.router.init();
			
			      const redirection: RedirectionData = \{
			        isReady: true,
			        isFetching: false,
			        link: "/initial-url/",
			        route: "/initial-url/",
			        page: 1,
			        query: \{\},
			        isRedirection: true,
			        redirectionStatus: 301,
			        isExternal: true,
			        location: "https://external.com/final-url/",
			      \};
			      store.state.source.data["/"] = redirection;
			
			      expect(window.replaceLocation).toHaveBeenCalledWith(
			        "https://external.com/final-url/"
			      );
			    \});
			  \});
			
			  describe("beforeSSR", () => \{
			    it("should warn if autoFetch is enabled but there is no source pkg", () => \{
			      const ctx = \{\} as Context<Packages>;
			      get.mockReturnValue(\{\});
			      const frontityWarn = jest.spyOn(frontityError, "warn");
			      const store = createStore(config);
			      store.actions.source = undefined;
			      store.actions.router.beforeSSR(ctx);
			
			      expect(frontityWarn).toHaveBeenCalledTimes(1);
			      expect(frontityWarn).toHaveBeenCalledWith(
			        "You are trying to use autoFetch but no source package is installed."
			      );
			    \});
			
			    it("should fetch if autoFetch is enabled", () => \{
			      const ctx = \{\} as Context<Packages>;
			      get.mockReturnValue(\{\});
			
			      const store = createStore(config);
			      store.state.frontity.platform = "server";
			      store.libraries.source = undefined;
			
			      store.actions.router.init();
			      store.actions.router.beforeSSR(ctx);
			
			      expect(fetch).toHaveBeenCalledTimes(1);
			      expect(fetch).toHaveBeenCalledWith("/initial/link/");
			    \});
			
			    it("should change the context status if there is an error", async () => \{
			      const ctx = \{ ctx: \{\} \} as Context<Packages>;
			      get.mockReturnValue(\{ isError: true, errorStatus: 123 \});
			
			      const store = createStore(config);
			
			      await store.actions.router.beforeSSR(ctx);
			
			      expect(ctx.ctx.status).toBe(123);
			    \});
			
			    it("should change the context status if there is an internal redirection", async () => \{
			      const ctx = (\{
			        ctx: \{
			          URL: new URL("https://localhost/"),
			          redirect: jest.fn(),
			        \},
			      \} as unknown) as Context<Packages>;
			      get.mockReturnValue(\{
			        isReady: true,
			        isRedirection: true,
			        redirectionStatus: 123,
			        isExternal: false,
			        location: "https://backend.com/final-url/?query=value#hash",
			      \});
			      const store = createStore(config);
			      store.state.frontity.url = "https://domain.com";
			
			      await store.actions.router.beforeSSR(ctx);
			
			      expect(ctx.ctx.redirect).toHaveBeenCalledWith(
			        "/final-url/?query=value#hash"
			      );
			      expect(ctx.ctx.status).toBe(123);
			    \});
			
			    it("should change the context status if there is an external redirection", async () => \{
			      const ctx = (\{
			        ctx: \{
			          URL: new URL("https://localhost/"),
			          redirect: jest.fn(),
			        \},
			      \} as unknown) as Context<Packages>;
			      get.mockReturnValue(\{
			        isReady: true,
			        isRedirection: true,
			        redirectionStatus: 123,
			        isExternal: true,
			        location: "https://external.com/final-url/?query=value#hash",
			      \});
			      const store = createStore(config);
			
			      await store.actions.router.beforeSSR(ctx);
			
			      expect(ctx.ctx.redirect).toHaveBeenCalledWith(
			        "https://external.com/final-url/?query=value#hash"
			      );
			      expect(ctx.ctx.status).toBe(123);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\tiny-router\\src\\__tests__\\index.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(22)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\action.tests.ts', () => {
        const sourceCode = `
			import \{ Action, AsyncAction, ServerAction \} from "../action";
			import Package from "../package";
			import Derived from "../derived";
			
			interface Package1 extends Package \{
			  name: "package-1";
			  state: \{
			    namespace1: \{
			      prop1: string;
			      prop2: number;
			      prop3: Derived<Package1, string>;
			      prop4: Derived<Package1, string, number>;
			      array1: string[];
			      nested1: \{
			        prop5: Derived<Package1, string, number>;
			        array2: number[];
			        nested2: \{
			          prop6: Derived<Package1, string>;
			        \};
			      \};
			    \};
			  \};
			  actions: \{
			    namespace1: \{
			      action1: Action<Package1>;
			      action2: AsyncAction<Package1>;
			    \};
			    namespace2: \{
			      action3: Action<Package1, string>;
			      action4: AsyncAction<Package1, number>;
			      action5: Action<Package1, number, string, number, string, number, string>;
			      action6: Action<Package, number> | Action<Package, number, string>;
			      action7: ServerAction<Package>;
			    \};
			  \};
			  libraries: \{
			    namespace1: \{
			      lib1: string;
			    \};
			  \};
			\}
			
			const package1: Package1 = \{
			  name: "package-1",
			  state: \{
			    namespace1: \{
			      prop1: "prop1",
			      prop2: 2,
			      prop3: (\{ state \}) => state.namespace1.prop1,
			      prop4: (\{ state \}) => (str) => str.length + state.namespace1.prop2,
			      array1: ["item1", "item2"],
			      nested1: \{
			        prop5: (\{ state \}) => (str) => str.length + state.namespace1.prop2,
			        array2: [3, 4],
			        nested2: \{
			          prop6: (\{ state \}) => state.namespace1.prop1,
			        \},
			      \},
			    \},
			  \},
			  actions: \{
			    namespace1: \{
			      // Action without params.
			      action1: (\{ state, actions, libraries \}) => \{
			        state.namespace1.prop1 = "newProp";
			        state.namespace1.prop2 = 3;
			
			        state.namespace1.prop3 = "asdf";
			
			        // Check that prop3 is a string (and not a function).
			        const str1: string = state.namespace1.prop3;
			
			        // Check that prop4 returns a number (and not a function).
			        const num1: number = state.namespace1.prop4("123");
			
			        // Check that nested derived state functions are processed correctly.
			        const num2: number = state.namespace1.nested1.prop5("123");
			
			        // Check that nested nested derived state is processed correctly.
			        const str2: string = state.namespace1.nested1.nested2.prop6;
			
			        // Check that arrays are fine.
			        state.namespace1.array1.map((item: string): string => item);
			
			        // Check that nested arrays are fine.
			        state.namespace1.nested1.array2.map((item: number): number => item + 1);
			
			        // Check that actions are accesible.
			        actions.namespace1.action2();
			        actions.namespace2.action3("123");
			
			        // Check that libraries are accesible.
			        const str3: string = libraries.namespace1.lib1;
			
			        // Check that actions with multiple parameters work.
			        actions.namespace2.action5(1, "2", 3, "4", 5, "6");
			
			        // Check that actions with optional parameters work.
			        actions.namespace2.action6(1);
			        actions.namespace2.action6(1, "2");
			      \},
			      // Async Action without params.
			      action2: async (\{ state, actions \}) => \{
			        state.namespace1.prop1 = "newProp";
			        await Promise.resolve();
			        const str1: string = state.namespace1.prop3;
			        await Promise.resolve();
			        const num1: number = state.namespace1.prop4("123");
			        actions.namespace2.action3("123");
			        await actions.namespace1.action2();
			        await actions.namespace2.action4(123);
			      \},
			    \},
			    namespace2: \{
			      // Action with params.
			      action3: (\{ state \}) => (str) => \{
			        state.namespace1.prop1 = str;
			        const str1: string = state.namespace1.prop3 + str;
			        const num1: number = state.namespace1.prop4(str);
			      \},
			      // Async Action with params.
			      action4: (\{ state \}) => async (num) => \{
			        state.namespace1.prop2 = num;
			        await Promise.resolve();
			        const num1: number = state.namespace1.prop4("123") + num;
			        await Promise.resolve();
			        const num2: number = state.namespace1.nested1.prop5("123") + num;
			      \},
			      // Action with mutilple parameters.
			      action5: (\{ state, actions \}) => (num1, str1, num2, str2, num3, str3) => \{
			        state.namespace1.prop2 = num1;
			        state.namespace1.prop1 = str1;
			        state.namespace1.prop2 = num2;
			        state.namespace1.prop1 = str2;
			        state.namespace1.prop2 = num3;
			        state.namespace1.prop1 = str3;
			      \},
			      // Action with optional parameters.
			      action6: (\{ state \}) => (num, str) => \{
			        state.namespace1.prop2 = num;
			        state.namespace1.prop1 = str;
			      \},
			      action7: (\{ state \}) => async (\{ ctx, state: state2 \}) => \{
			        const num: number = state.namespace1.prop2;
			        const num2: number = state2.namespace1.prop2;
			        const num3: number = ctx.state.namepsace1.prop2;
			      \},
			    \},
			  \},
			  libraries: \{
			    namespace1: \{
			      lib1: "lib1",
			    \},
			  \},
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\action.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\config.tests.ts', () => {
        const sourceCode = `
			import \{
			  BabelCustomizer,
			  WebpackCustomizer,
			  FrontityCustomizer,
			\} from "../config";
			
			const webpack: WebpackCustomizer = (\{ config, target, mode \}) => \{
			  config.mode = "development";
			  config.output = \{
			    filename: "output",
			  \};
			  target = "es5";
			  mode = "production";
			\};
			
			const babel: BabelCustomizer = (\{ config, target, mode \}) => \{
			  config.plugins.push("some-babel-plugin");
			  config.plugins.push(["some-babel-plugin", \{ option1: "value1" \}]);
			  target = "module";
			  mode = "development";
			\};
			
			const frontity: FrontityCustomizer = (\{ config, mode \}) => \{
			  config.outDir = "dist";
			  mode = "production";
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\config.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\connect.tests.tsx', () => {
        const sourceCode = `
			import * as React from "react";
			import Connect, \{ ConnectFunction \} from "../connect";
			import \{ FilterInjectedProps \} from "../utils";
			import \{ Action, AsyncAction \} from "../action";
			import Package from "../package";
			import Derived from "../derived";
			
			interface Package1 extends Package \{
			  name: "package-1";
			  state: \{
			    namespace1: \{
			      prop1: string;
			      prop2: number;
			      prop3: Derived<Package1, string>;
			      prop4: Derived<Package1, string, number>;
			      array1: string[];
			      nested1: \{
			        prop5: Derived<Package1, string, number>;
			        array2: number[];
			        nested2: \{
			          prop6: Derived<Package1, string>;
			        \};
			      \};
			    \};
			  \};
			  actions: \{
			    namespace1: \{
			      action1: Action<Package1>;
			      action2: AsyncAction<Package1>;
			    \};
			    namespace2: \{
			      action3: Action<Package1, string>;
			      action4: AsyncAction<Package1, number>;
			    \};
			  \};
			  libraries: \{
			    namespace3: \{
			      library1: () => void;
			      Component1: React.FC<\{ html: string \}>;
			      Component2: React.ComponentClass<\{ html: string \}>;
			    \};
			  \};
			\}
			
			interface OwnProps \{
			  ownProp1: string;
			  name: string;
			\}
			
			const Component1: React.FC<Connect<Package1, \{ html: string \}>> = (\{
			  state,
			  actions,
			  libraries,
			  html,
			\}) => \{
			  state;
			  actions;
			  libraries;
			  return <div>\{html\}</div>;
			\};
			
			class Component2 extends React.Component<Connect<Package1, \{ html: string \}>> \{
			  render() \{
			    this.props.state;
			    this.props.actions;
			    this.props.libraries;
			    return <div>\{this.props.html\}</div>;
			  \}
			\}
			
			const connect: ConnectFunction = (comp) => comp;
			
			const ConnectedComponent1 = connect(Component1);
			const ConnectedComponent2 = connect(Component2);
			connect(Component1, \{ injectProps: false \});
			connect(Component2, \{ injectProps: false \});
			
			const internalProps: Connect<Package1, OwnProps> = \{
			  state: \{
			    namespace1: \{
			      prop1: "prop1",
			      prop2: 2,
			      prop3: "prop3",
			      prop4: (str) => str.length,
			      array1: ["array1"],
			      nested1: \{
			        prop5: (str) => str.length,
			        array2: [2],
			        nested2: \{
			          prop6: "prop6",
			        \},
			      \},
			    \},
			  \},
			  actions: \{
			    namespace1: \{
			      action1: () => \{\},
			      action2: async () => \{\},
			    \},
			    namespace2: \{
			      action3: (str) => \{
			        const str2: string = str;
			      \},
			      action4: async (num) => \{
			        const num2: number = num;
			      \},
			    \},
			  \},
			  libraries: \{
			    namespace3: \{
			      library1: () => \{\},
			      Component1: ConnectedComponent1,
			      Component2: ConnectedComponent2,
			    \},
			  \},
			  ownProp1: "ownProp1",
			  name: "nameProp",
			\};
			
			internalProps.actions.namespace1.action1();
			internalProps.actions.namespace1.action2();
			internalProps.actions.namespace2.action3("123");
			internalProps.actions.namespace2.action4(123);
			
			const externalProps: FilterInjectedProps<Connect<Package1, OwnProps>> = \{
			  ownProp1: "ownProp1",
			  name: "nameProp",
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\connect.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\derived.tests.ts', () => {
        const sourceCode = `
			import Package from "../package";
			import Derived from "../derived";
			
			interface Package1 extends Package \{
			  state: \{
			    namespace1: \{
			      prop1: string;
			      prop2: number;
			      prop3: Derived<Package1, string>;
			      prop4: Derived<Package1, string, number>;
			      unionDerivedProp1: Derived<Package1, string> | string;
			      unionDerivedProp2: Derived<Package1, string> | string;
			      nested1: \{
			        prop5: Derived<Package1, string, number>;
			        nested2: \{
			          prop6: Derived<Package1, string>;
			        \};
			      \};
			    \};
			  \};
			  libraries: \{
			    namespace1: \{
			      func1: (s: string) => string;
			    \};
			  \};
			\}
			
			const package1: Package1 = \{
			  state: \{
			    namespace1: \{
			      prop1: "prop1",
			      prop2: 2,
			      // Check that prop3 is a string (and not a function). Also, check that
			      // derived state can access libraries.
			      prop3: (\{ state, libraries \}) =>
			        libraries.namespace1.func1(state.namespace1.prop3),
			      // Check that prop4 returns a number (and not a function).
			      prop4: (\{ state \}) => (str) => state.namespace1.nested1.prop5(str),
			      unionDerivedProp1: (\{ state \}) => state.namespace1.unionDerivedProp1,
			      unionDerivedProp2: "A string works as well",
			      nested1: \{
			        // Check that nested derived state functions are processed correctly.
			        prop5: (\{ state \}) => (str) => state.namespace1.prop4(str),
			        nested2: \{
			          // Check that nested nested derived state is processed correctly.
			          prop6: (\{ state \}) => state.namespace1.prop1.toLowerCase(),
			        \},
			      \},
			    \},
			  \},
			  libraries: \{
			    namespace1: \{
			      func1: (s) => s.trim(),
			    \},
			  \},
			\};
			
			// I have to "use" the package1, otherwise eslint will complain.
			package1.name = "test";
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\derived.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\merge-packages.tests.ts', () => {
        const sourceCode = `
			import Package from "../package";
			import \{ Action, AsyncAction \} from "../action";
			import Derived from "../derived";
			import MergePackages from "../merge-packages";
			import \{ expectType \} from "../helpers";
			
			/**
			 * Package using the types of \`Package1\`, \`Package2\` and \`Package3\` for derived
			 * props and actions.
			 */
			interface Package1 extends Package \{
			  name: "package-1";
			  state: \{
			    namespace1: \{
			      prop1: string;
			      prop2: Derived<Packages, string>;
			    \};
			  \};
			  actions: \{
			    namespace1: \{
			      action1: Action<Packages>;
			    \};
			  \};
			\}
			
			interface Package2 extends Package \{
			  name: "package-2";
			  state: \{
			    namespace2: \{
			      prop3: Derived<Package2, boolean>;
			    \};
			  \};
			  actions: \{
			    namespace2: \{
			      action2: Action<Package2, string>;
			      action3: AsyncAction<Package2, string>;
			    \};
			  \};
			  libraries: \{
			    namespace1: \{
			      library1: () => void;
			    \};
			  \};
			\}
			
			interface Package3 extends Package \{
			  name: "package-3";
			  state: \{
			    namespace3: \{
			      prop4: Derived<Package3, string, boolean>;
			    \};
			  \};
			  libraries: \{
			    namespace1: \{
			      library2: () => void;
			    \};
			  \};
			\}
			
			/**
			 * All packages merged together.
			 */
			type Packages = MergePackages<Package1, Package2, Package3>;
			
			const packages: Package1 = \{
			  name: "package-1",
			  state: \{
			    namespace1: \{
			      prop1: "prop1",
			      prop2: (\{ state, libraries \}) => \{
			        // Test merged state.
			        expectType<string>(state.namespace1.prop1);
			        expectType<string>(state.namespace1.prop2);
			        expectType<boolean>(state.namespace2.prop3);
			        expectType<(str: string) => boolean>(state.namespace3.prop4);
			
			        // Test merged libraries
			        expectType<() => void>(libraries.namespace1.library1);
			        expectType<() => void>(libraries.namespace1.library2);
			
			        return "";
			      \},
			    \},
			  \},
			  actions: \{
			    namespace1: \{
			      action1: (\{ state, actions, libraries \}) => \{
			        // Test merged state.
			        expectType<string>(state.namespace1.prop1);
			        expectType<string>(state.namespace1.prop2);
			        expectType<boolean>(state.namespace2.prop3);
			        expectType<(str: string) => boolean>(state.namespace3.prop4);
			
			        // Test merged actions.
			        expectType<() => void>(actions.namespace1.action1);
			        expectType<(str: string) => void>(actions.namespace2.action2);
			        expectType<(str: string) => Promise<void>>(actions.namespace2.action3);
			
			        // Test merged libraries
			        expectType<() => void>(libraries.namespace1.library1);
			        expectType<() => void>(libraries.namespace1.library2);
			      \},
			    \},
			  \},
			\};
			
			describe("MergePackages", () => \{
			  // eslint-disable-next-line jest/expect-expect
			  it("generates the correct types", () => \{
			    // Tested in package1 definition.
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\merge-packages.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\package.tests.ts', () => {
        const sourceCode = `
			import Settings from "../settings";
			import Package from "../package";
			import \{ Action, AsyncAction \} from "../action";
			import Derived from "../derived";
			import \{ Server, AsyncServer \} from "../server";
			
			// Custom package extending from Package.
			interface Package1 extends Package \{
			  name: "package-1";
			  state: \{
			    namespace1: \{
			      prop1: string;
			      prop2: Derived<Package1, string>;
			    \};
			    namespace2: \{
			      prop3: string;
			      nested1: \{
			        prop4: Derived<Package1, string, number>;
			      \};
			    \};
			  \};
			  actions: \{
			    namespace1: \{
			      action1: Action<Package1>;
			      action2: AsyncAction<Package1>;
			    \};
			    namespace2: \{
			      action3: Action<Package1, string>;
			      action4: AsyncAction<Package1, string>;
			    \};
			  \};
			  libraries: \{
			    namespace1: \{
			      library1: () => void;
			    \};
			  \};
			  server: \{
			    namespace1: \{
			      server1: Server<Package1>;
			      server2: AsyncServer<Package1>;
			    \};
			  \};
			\}
			
			// Package1 implementation.
			const package1: Package1 = \{
			  name: "package-1",
			  state: \{
			    namespace1: \{
			      prop1: "prop1",
			      prop2: (\{ state \}) => "",
			    \},
			    namespace2: \{
			      prop3: "prop3",
			      nested1: \{
			        prop4: (\{ state \}) => (str) => 1,
			      \},
			    \},
			  \},
			  actions: \{
			    namespace1: \{
			      action1: (\{ state, actions, libraries \}) => \{\},
			      action2: async (\{ state, actions, libraries \}) => \{\},
			    \},
			    namespace2: \{
			      action3: (\{ state \}) => (str) => \{
			        str.startsWith("");
			      \},
			      action4: (\{ state \}) => async (str) => \{
			        str.startsWith("");
			      \},
			    \},
			  \},
			  libraries: \{
			    namespace1: \{
			      library1: () => \{\},
			    \},
			  \},
			  server: \{
			    namespace1: \{
			      server1: (\{ ctx, next, state, actions, libraries, server \}, next2) => \{\},
			      server2: async (
			        \{ ctx, next, state, actions, libraries, server \},
			        next2
			      ) => \{\},
			    \},
			  \},
			\};
			
			// Settings from Package1.
			const package2: Settings<Package1> = \{
			  packages: [
			    \{
			      name: "package-1",
			    \},
			  ],
			\};
			
			// Two different settings extending from Package.
			interface Package2 extends Package \{
			  name: "package-2";
			  state: \{
			    namespace2: \{
			      prop2: string;
			      prop3?: number;
			    \};
			    namespace3: \{
			      prop4: boolean;
			    \};
			  \};
			\}
			
			const package3: Settings<Package1 | Package2> = \{
			  packages: [
			    \{
			      name: "package-1",
			      state: \{
			        namespace1: \{
			          prop1: "",
			        \},
			      \},
			    \},
			    \{
			      name: "package-2",
			      state: \{
			        namespace2: \{
			          prop2: "",
			        \},
			      \},
			    \},
			  ],
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\package.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\server.tests.ts', () => {
        const sourceCode = `
			import \{ Action, AsyncAction \} from "../action";
			import \{ Server, AsyncServer \} from "../server";
			import Package from "../package";
			import Derived from "../derived";
			
			interface Package1 extends Package \{
			  name: "package-1";
			  state: \{
			    namespace1: \{
			      prop1: string;
			      prop2: number;
			      prop3: Derived<Package1, string>;
			      prop4: Derived<Package1, string, number>;
			      array1: string[];
			      nested1: \{
			        prop5: Derived<Package1, string, number>;
			        array2: number[];
			        nested2: \{
			          prop6: Derived<Package1, string>;
			        \};
			      \};
			    \};
			  \};
			  actions: \{
			    namespace1: \{
			      action1: Action<Package1>;
			      action2: AsyncAction<Package1>;
			    \};
			    namespace2: \{
			      action3: Action<Package1, string>;
			      action4: AsyncAction<Package1, number>;
			      action5: Action<Package1, number, string, number, string, number, string>;
			      action6: Action<Package, number> | Action<Package, number, string>;
			    \};
			  \};
			  libraries: \{
			    namespace1: \{
			      lib1: string;
			    \};
			  \};
			  server: \{
			    namespace1: \{
			      server1: Server<Package1>;
			      server2: AsyncServer<Package1>;
			    \};
			    namespace2: \{
			      server3: Server<Package1>;
			      server4: AsyncServer<Package1>;
			    \};
			  \};
			\}
			
			const package1: Package1 = \{
			  name: "package-1",
			  state: \{
			    namespace1: \{
			      prop1: "prop1",
			      prop2: 2,
			      prop3: (\{ state \}) => state.namespace1.prop1,
			      prop4: (\{ state \}) => (str) => str.length + state.namespace1.prop2,
			      array1: ["item1", "item2"],
			      nested1: \{
			        prop5: (\{ state \}) => (str) => str.length + state.namespace1.prop2,
			        array2: [3, 4],
			        nested2: \{
			          prop6: (\{ state \}) => state.namespace1.prop1,
			        \},
			      \},
			    \},
			  \},
			  actions: \{
			    namespace1: \{
			      // Action without params.
			      action1: () => \{\},
			      // Async Action without params.
			      action2: async () => \{\},
			    \},
			    namespace2: \{
			      // Action with params.
			      action3: () => (str) => \{\},
			      // Async Action with params.
			      action4: () => async (num) => \{\},
			      // Action with mutilple parameters.
			      action5: () => (num1, str1, num2, str2, num3, str3) => \{\},
			      // Action with optional parameters.
			      action6: () => (num, str) => \{\},
			    \},
			  \},
			  libraries: \{
			    namespace1: \{
			      lib1: "lib1",
			    \},
			  \},
			  server: \{
			    namespace1: \{
			      server1: (\{ ctx, state, actions, libraries, server, next \}, next2) => \{
			        // Can access and modify Koa ctx.
			        const status: number = ctx.status;
			        ctx.status = 418;
			
			        // Can modify state.
			        state.namespace1.prop1 = "newProp";
			        state.namespace1.prop2 = 3;
			
			        state.namespace1.prop3 = "asdf";
			
			        // Check that prop3 is a string (and not a function).
			        const str1: string = state.namespace1.prop3;
			
			        // Check that prop4 returns a number (and not a function).
			        const num1: number = state.namespace1.prop4("123");
			
			        // Check that nested derived state functions are processed correctly.
			        const num2: number = state.namespace1.nested1.prop5("123");
			
			        // Check that nested nested derived state is processed correctly.
			        const str2: string = state.namespace1.nested1.nested2.prop6;
			
			        // Check that arrays are fine.
			        state.namespace1.array1.map((item: string): string => item);
			
			        // Check that nested arrays are fine.
			        state.namespace1.nested1.array2.map((item: number): number => item + 1);
			
			        // Check that actions are accesible.
			        actions.namespace1.action2();
			        actions.namespace2.action3("123");
			
			        // Check that libraries are accesible.
			        const str3: string = libraries.namespace1.lib1;
			
			        // Check that actions with multiple parameters work.
			        actions.namespace2.action5(1, "2", 3, "4", 5, "6");
			
			        // Check that actions with optional parameters work.
			        actions.namespace2.action6(1);
			        actions.namespace2.action6(1, "2");
			
			        // Check that other server middleware is accessible.
			        server.namespace1.server2(ctx, next);
			        server.namespace1.server2(\{ ...ctx, ctx, next: next2 \}, next);
			        server.namespace2.server3(ctx, next);
			      \},
			      server2: async (\{ ctx, server, next \}, next2) => \{
			        // Check that can await next.
			        await next();
			        await next2();
			
			        // Check that can await other middleware.
			        await server.namespace2.server4(ctx, next);
			      \},
			    \},
			    namespace2: \{
			      server3: () => \{\},
			      server4: async () => \{\},
			    \},
			  \},
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\server.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\settings.tests.ts', () => {
        const sourceCode = `
			import \{ Settings \} from "..";
			
			// Settings
			// 1. Minimal mono settings.
			const settings1: Settings = \{
			  packages: [],
			\};
			
			// 2. Minimal multi settings.
			const settings2: Settings = [
			  \{
			    name: "site-1",
			    packages: [],
			  \},
			];
			
			// 3. Settings with minimal base settings, name and mode.
			const settings3: Settings = \{
			  name: "site",
			  mode: "default",
			  state: \{
			    url: "https://mysite.com",
			  \},
			  packages: [],
			\};
			
			// 4. Settings with full base settings.
			const settings4: Settings = \{
			  name: "site",
			  mode: "default",
			  state: \{
			    frontity: \{
			      url: "https://mysite.com",
			    \},
			  \},
			  packages: [],
			\};
			
			// 5. Settings with string packages.
			const settings5: Settings = \{
			  packages: ["package-1", "package-2"],
			\};
			
			// 6. Settings with minimal object packages.
			const settings6: Settings = \{
			  packages: [
			    \{
			      name: "package-1",
			    \},
			    \{
			      name: "package-2",
			    \},
			  ],
			\};
			
			// 7. Settings with full object package.
			const settings7: Settings = \{
			  packages: [
			    \{
			      name: "package-1",
			      active: true,
			      state: \{
			        namespace3: \{
			          someSetting: "some setting of namespace 1",
			          someArray: ["array 1", "array 2"],
			        \},
			        namespace2: \{
			          otherSetting: "other setting of namespace 2",
			        \},
			      \},
			    \},
			  ],
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\settings.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\types\\__tests__\\state.tests.ts', () => {
        const sourceCode = `
			import State from "../state";
			import Package from "../package";
			import Derived from "../derived";
			
			interface Package1 extends Package \{
			  name: "package-1";
			  state: \{
			    namespace1: \{
			      prop1: string;
			      prop2: number;
			      prop3: Derived<Package1, string>;
			      prop4: Derived<Package1, string, number>;
			      array1: string[];
			      nested1: \{
			        prop5: Derived<Package1, string, number>;
			        array2: number[];
			        nested2: \{
			          prop6: Derived<Package1, string>;
			        \};
			      \};
			    \};
			  \};
			\}
			
			const state1: State<Package1> = \{
			  namespace1: \{
			    prop1: "prop1",
			    prop2: 2,
			    prop3: "prop3",
			    prop4: (str) => \{
			      const str2: string = str;
			      return 4;
			    \},
			    array1: ["item1", "item2"],
			    nested1: \{
			      prop5: (str) => \{
			        const str2: string = str;
			        return 5;
			      \},
			      array2: [3, 4],
			      nested2: \{
			        prop6: "prop6",
			      \},
			    \},
			  \},
			\};
			
			test("Types are fine!", () => \{\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\types\\__tests__\\state.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\wp-comments\\src\\__tests__\\actions.submit.test.ts', () => {
        const sourceCode = `
			import * as frontity from "frontity";
			import * as frontityError from "@frontity/error";
			import clone from "clone-deep";
			import \{ createStore \} from "@frontity/connect";
			import \{ mergeDeepRight \} from "ramda";
			import wpSource from "@frontity/wp-source/src";
			
			import wpComments from "..";
			import \{ Packages \} from "../../types";
			import \{ mockResponse, fromEntries \} from "./mocks/helpers";
			
			const fetch = jest.spyOn(frontity, "fetch").mockResolvedValue(undefined);
			const warn = jest.spyOn(frontityError, "warn");
			jest.spyOn(Date, "now").mockReturnValue(1594161555147);
			
			describe("actions.comments.submit", () => \{
			  beforeEach(() => \{
			    fetch.mockClear();
			    warn.mockClear();
			  \});
			
			  test("should use the fields passed as argument", async () => \{
			    // The post ID.
			    const postId = 60;
			
			    // Mock packages with the API specified in state.source.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Send a comment but do not wait for the response.
			    store.actions.comments
			      .submit(postId, \{
			        content: "Hello world!",
			        authorName: "Frontibotito",
			        authorEmail: "frontibotito@frontity.org",
			        authorURL: "https://frontity.org",
			      \})
			      .catch(() => \{
			        // Do nothing if it fails.
			      \});
			
			    // Check the comment was sent.
			    expect(fetch).toHaveBeenCalledTimes(1);
			
			    // Check \`fetch\` was called with the correct params.
			    const [[url, options]] = fetch.mock.calls;
			
			    // Check that the request URL is correct.
			    expect(url).toBe("https://test.frontity.org/wp-json/wp/v2/comments");
			
			    // Check that the request parameters are correct.
			    expect(options).toMatchInlineSnapshot(\`
			      Object \{
			        "body": URLSearchParams \{\},
			        "headers": Object \{
			          "Content-Type": "application/x-www-form-urlencoded",
			        \},
			        "method": "POST",
			      \}
			    \`);
			
			    // Check that the request body is correct.
			    expect(fromEntries((options.body as URLSearchParams).entries()))
			      .toMatchInlineSnapshot(\`
			      Object \{
			        "author_email": "frontibotito@frontity.org",
			        "author_name": "Frontibotito",
			        "author_url": "https://frontity.org",
			        "content": "Hello world!",
			        "post": "60",
			      \}
			    \`);
			
			    // Check that the populated state is correct.
			    expect(store.state.comments.forms[postId]).toMatchInlineSnapshot(\`
			      Object \{
			        "errorCode": "",
			        "errorMessage": "",
			        "errorStatusCode": null,
			        "fields": Object \{
			          "authorEmail": "frontibotito@frontity.org",
			          "authorName": "Frontibotito",
			          "authorURL": "https://frontity.org",
			          "content": "Hello world!",
			        \},
			        "isError": false,
			        "isSubmitted": false,
			        "isSubmitting": true,
			      \}
			    \`);
			  \});
			
			  test("should use the form fields", async () => \{
			    // The post ID.
			    const postId = 60;
			
			    // Mock packages with the API specified in state.source.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			        comments: \{
			          forms: \{
			            [postId]: \{
			              fields: \{
			                content: "Hello world!",
			                authorName: "Frontibotito",
			                authorEmail: "frontibotito@frontity.org",
			                parent: 0,
			                authorURL: "https://frontity.org",
			              \},
			            \},
			          \},
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Send a comment but do not wait for the response.
			    store.actions.comments.submit(postId).catch(() => \{
			      // Do nothing if it fails.
			    \});
			
			    // Check the comment was sent.
			    expect(fetch).toHaveBeenCalledTimes(1);
			
			    // Check \`fetch\` was called with the correct params.
			    const [[url, options]] = fetch.mock.calls;
			
			    // Check that the request URL is correct.
			    expect(url).toBe("https://test.frontity.org/wp-json/wp/v2/comments");
			
			    // Check that the request parameters are correct.
			    expect(options).toMatchInlineSnapshot(\`
			      Object \{
			        "body": URLSearchParams \{\},
			        "headers": Object \{
			          "Content-Type": "application/x-www-form-urlencoded",
			        \},
			        "method": "POST",
			      \}
			    \`);
			
			    // Check that the request body is correct.
			    expect(fromEntries((options.body as URLSearchParams).entries()))
			      .toMatchInlineSnapshot(\`
			      Object \{
			        "author_email": "frontibotito@frontity.org",
			        "author_name": "Frontibotito",
			        "author_url": "https://frontity.org",
			        "content": "Hello world!",
			        "parent": "0",
			        "post": "60",
			      \}
			    \`);
			
			    // Check that the populated state is correct.
			    // The form should still be submitting.
			    expect(store.state.comments.forms[postId]).toMatchInlineSnapshot(\`
			      Object \{
			        "errorCode": "",
			        "errorMessage": "",
			        "errorStatusCode": null,
			        "fields": Object \{
			          "authorEmail": "frontibotito@frontity.org",
			          "authorName": "Frontibotito",
			          "authorURL": "https://frontity.org",
			          "content": "Hello world!",
			          "parent": 0,
			        \},
			        "isError": false,
			        "isSubmitted": false,
			        "isSubmitting": true,
			      \}
			    \`);
			  \});
			
			  test("should populate an error if ID is wrong", async () => \{
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // WordPress should return a 403 if the post ID is wrong.
			    fetch.mockResolvedValue(
			      mockResponse(
			        \{
			          code: "rest_comment_invalid_post_id",
			          message:
			            "Sorry, you are not allowed to create this comment without a post.",
			          data: \{ status: 403 \},
			        \},
			        \{ status: 403 \}
			      )
			    );
			
			    // An invalid post ID.
			    const postId = +9000;
			
			    // Send a comment and wait for the response.
			    const submission = store.actions.comments.submit(postId, \{
			      content: "Hello world!",
			      authorName: "Frontibotito",
			      authorEmail: "frontibotito@frontity.org",
			      authorURL: "https://frontity.org",
			    \});
			
			    // Get the form data.
			    const form = store.state.comments.forms[postId];
			
			    // Check the submission is in progress.
			    expect(form.isSubmitting).toBe(true);
			
			    await submission;
			
			    // The submission should have failed.
			    expect(form.isSubmitting).toBe(false);
			    expect(form.isError).toBe(true);
			    expect(form.errorMessage).toMatchInlineSnapshot(
			      \`"Sorry, you are not allowed to create this comment without a post."\`
			    );
			  \});
			
			  test("should populate an error if authorEmail is empty or incorrect", async () => \{
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // WordPress returns an 400 response with a message if the authorEmail is wrong.
			    fetch.mockResolvedValue(
			      mockResponse(
			        \{
			          code: "rest_comment_author_data_required",
			          message:
			            "Creating a comment requires valid author name and email values.",
			          data: \{ status: 400 \},
			        \},
			        \{ status: 400 \}
			      )
			    );
			
			    // The post ID.
			    const postId = 60;
			
			    // Send a comment and wait for the response.
			    const submission = store.actions.comments.submit(postId, \{
			      authorName: "Frontibotito",
			      content: "Hello world!",
			      authorEmail: "",
			      authorURL: "https://frontity.org",
			    \});
			
			    // Get the form data.
			    const form = store.state.comments.forms[postId];
			
			    // Check the submission is in progress.
			    expect(form.isSubmitting).toBe(true);
			
			    await submission;
			
			    // The submission should have failed.
			    expect(form.isSubmitting).toBe(false);
			    expect(form.isError).toBe(true);
			    expect(form.errorMessage).toMatchInlineSnapshot(
			      \`"Creating a comment requires valid author name and email values."\`
			    );
			  \});
			
			  test("should populate an error if authorName is empty or incorrect", async () => \{
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // WordPress returns an OK response with a message if the email ID is wrong.
			    fetch.mockResolvedValue(
			      mockResponse(
			        \{
			          code: "rest_comment_author_data_required",
			          message:
			            "Creating a comment requires valid author name and email values.",
			          data: \{ status: 400 \},
			        \},
			        \{ status: 400 \}
			      )
			    );
			
			    // The post ID.
			    const postId = 60;
			
			    // Send a comment and wait for the response.
			    const submission = store.actions.comments.submit(postId, \{
			      authorName: "Frontibotito",
			      content: "Hello world!",
			      authorEmail: "",
			      authorURL: "https://frontity.org",
			    \});
			
			    // Get the form data.
			    const form = store.state.comments.forms[postId];
			
			    // Check the submission is in progress.
			    expect(form.isSubmitting).toBe(true);
			
			    await submission;
			
			    // The submission should have failed.
			    expect(form.isSubmitting).toBe(false);
			    expect(form.isError).toBe(true);
			    expect(form.errorMessage).toMatchInlineSnapshot(
			      \`"Creating a comment requires valid author name and email values."\`
			    );
			  \});
			
			  test("should populate an error if duplicated", async () => \{
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // WordPress returns an 409 Conflict response with a message if the comment
			    // was already submitted.
			    fetch.mockResolvedValue(
			      mockResponse(
			        \{
			          code: "comment_duplicate",
			          message:
			            "Duplicate comment detected; it looks as though you&#8217;ve already said that!",
			          data: \{
			            status: 409,
			          \},
			        \},
			        \{ status: 409 \}
			      )
			    );
			
			    // A post ID.
			    const postId = 60;
			
			    // Send a comment and wait for the response.
			    const submission = store.actions.comments.submit(postId, \{
			      content: "Same comment again.",
			      authorName: "Frontibotito",
			      authorEmail: "frontibotito@frontity.org",
			      authorURL: "https://frontity.org",
			    \});
			
			    // Get the form data.
			    const form = store.state.comments.forms[postId];
			
			    // Check the submission is in progress.
			    expect(form.isSubmitting).toBe(true);
			
			    await submission;
			
			    // The submission should have failed.
			    expect(form.isSubmitting).toBe(false);
			    expect(form.isError).toBe(true);
			    expect(form.errorMessage).toMatchInlineSnapshot(
			      \`"Duplicate comment detected; it looks as though you&#8217;ve already said that!"\`
			    );
			  \});
			
			  test("should indicate if the comment was not accepted yet", async () => \{
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpSource()), clone(wpComments));
			    const store = createStore<Packages>(packages);
			    store.state.source.api = "https://test.frontity.org/wp-json";
			    store.actions.source.init();
			
			    // A post ID.
			    const postId = 60;
			
			    // WordPress returns 201 when a comment was successfully submitted.
			    fetch.mockResolvedValue(
			      mockResponse(
			        \{
			          id: 123,
			          post: postId,
			          parent: 0,
			          author: 0,
			          authorName: "Frontitbotito",
			          authorURL: "",
			          date: "2020-08-26T21:45:06",
			          content: \{ rendered: "<p>Hello world!</p>\\n" \},
			          link: "http://localhost:8080/hello-world/#comment-2",
			          status: "hold",
			          type: "comment",
			        \},
			
			        \{
			          status: 201,
			        \}
			      )
			    );
			
			    // Send a comment and wait for the response.
			    const submission = store.actions.comments.submit(postId, \{
			      content: "Hello world!",
			      authorName: "Frontibotito",
			      authorEmail: "frontibotito@frontity.org",
			      authorURL: "https://frontity.org",
			    \});
			
			    // Get the form data.
			    const form = store.state.comments.forms[postId];
			
			    // Check the submission is in progress.
			    expect(form.isSubmitting).toBe(true);
			
			    await submission;
			
			    // The submission should have succeed (but not approved yet).
			    expect(form.isSubmitting).toBe(false);
			    expect(form.isSubmitted).toBe(true);
			    expect(form.isError).toBe(false);
			  \});
			
			  test("should indicate if the comment was accepted", async () => \{
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpSource()), clone(wpComments));
			    const store = createStore<Packages>(packages);
			    store.state.source.url = "https://test.frontity.org/";
			    store.actions.source.init();
			
			    type Api = Packages["libraries"]["source"]["api"];
			    const api = store.libraries.source.api as jest.Mocked<Api>;
			    api.get = jest.fn();
			
			    // Initialize the state.
			    // There are no comments, but we nee
			    api.get.mockResolvedValueOnce(mockResponse([]));
			    await store.actions.source.fetch("@comments/60");
			
			    // A post ID.
			    const postId = 60;
			
			    // WordPress returns 201 when a comment was successfully submitted.
			    fetch.mockResolvedValue(
			      mockResponse(
			        \{
			          id: 123,
			          post: postId,
			          parent: 0,
			          author: 0,
			          authorName: "Frontitbotito",
			          authorURL: "",
			          date: "2020-08-26T21:45:06",
			          content: \{
			            rendered: "<p>Hello world!</p>\\n",
			          \},
			          link: "http://localhost:8080/hello-world/#comment-2",
			          status: "approved",
			          type: "comment",
			        \},
			
			        \{
			          status: 201,
			        \}
			      )
			    );
			
			    // Send a comment and wait for the response.
			    const submission = store.actions.comments.submit(postId, \{
			      content: "Hello world!",
			      authorName: "Frontibotito",
			      authorEmail: "frontibotito@frontity.org",
			      authorURL: "https://frontity.org",
			    \});
			
			    // Get the form data.
			    const form = store.state.comments.forms[postId];
			
			    // Check the submission is in progress.
			    expect(form.isSubmitting).toBe(true);
			
			    await submission;
			
			    // The submission should have succeeded and is approved.
			    expect(form.isSubmitting).toBe(false);
			    expect(form.isSubmitted).toBe(true);
			    expect(form.isError).toBe(false);
			
			    // The comment is ready has been added to the items
			    expect(store.state.source.get(\`@comments/\$\{postId\}\`))
			      .toMatchInlineSnapshot(\`
			      Object \{
			        "isComments": true,
			        "isFetching": false,
			        "isReady": true,
			        "items": Array [
			          Object \{
			            "id": 123,
			            "type": "comment",
			          \},
			        ],
			        "link": "@comments/60/",
			        "page": 1,
			        "postId": 60,
			        "query": Object \{\},
			        "route": "@comments/60/",
			        "total": 1,
			        "totalPages": 1,
			        "type": "comments",
			      \}
			    \`);
			
			    // The fields should have been reset.
			    expect(store.state.comments.forms[postId]).toMatchInlineSnapshot(\`
			      Object \{
			        "errorCode": "",
			        "errorMessage": "",
			        "errorStatusCode": null,
			        "fields": Object \{
			          "content": "",
			        \},
			        "isError": false,
			        "isSubmitted": true,
			        "isSubmitting": false,
			      \}
			    \`);
			  \});
			
			  test("should populate an error in any other case", async () => \{
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Any random error.
			    fetch.mockResolvedValue(mockResponse(undefined, \{ status: 500 \}));
			
			    // A post ID.
			    const postId = 60;
			
			    // Send a comment and wait for the response.
			    const submission = store.actions.comments.submit(postId, \{
			      content: "Hello world!",
			      authorName: "Frontibotito",
			      authorEmail: "frontibotito@frontity.org",
			      authorURL: "https://frontity.org",
			    \});
			
			    // Get the form data.
			    const form = store.state.comments.forms[postId];
			
			    // Check the submission is in progress.
			    expect(form.isSubmitting).toBe(true);
			
			    await submission;
			
			    // The submission failed with a 500 error.
			    expect(form.isSubmitting).toBe(false);
			    expect(form.isError).toBe(true);
			    expect(form.errorMessage).toMatchInlineSnapshot(
			      \`"Unexpected error: Internal Server Error"\`
			    );
			  \});
			
			  test("should overwrite submitted props each time is called", async () => \{
			    // A post ID.
			    const postId = 60;
			
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			        comments: \{
			          forms: \{
			            [postId]: \{
			              isSubmitted: false,
			              isSubmitting: false,
			              isError: false,
			              errorMessage: "",
			              errorCode: "",
			              errors: \{\},
			              fields: \{
			                content: "Hello world!",
			                authorName: "Frontibotito",
			                authorEmail: "frontibotito@frontity.org",
			                parent: 0,
			                authorURL: "https://frontity.org",
			              \},
			            \},
			          \},
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Send a comment and do not wait for the response.
			    store.actions.comments
			      .submit(postId, \{
			        content: "Other comment!",
			        authorName: "Other author",
			        authorEmail: "other@email.test",
			        authorURL: "https://other.url.test",
			        parent: 123,
			      \})
			      .catch(() => \{
			        // Do nothing.
			      \});
			
			    const form = store.state.comments.forms[postId];
			
			    // The submission should have been overwritten.
			    expect(form).toMatchInlineSnapshot(\`
			      Object \{
			        "errorCode": "",
			        "errorMessage": "",
			        "errorStatusCode": null,
			        "errors": Object \{\},
			        "fields": Object \{
			          "authorEmail": "other@email.test",
			          "authorName": "Other author",
			          "authorURL": "https://other.url.test",
			          "content": "Other comment!",
			          "parent": 123,
			        \},
			        "isError": false,
			        "isSubmitted": false,
			        "isSubmitting": true,
			      \}
			    \`);
			  \});
			
			  test("should show a warning message if a submission is pending", async () => \{
			    // A post ID.
			    const postId = 60;
			
			    // Mock packages with the API specified and some form.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        source: \{
			          api: "https://test.frontity.org/wp-json/",
			          url: "https://test.frontity.org/",
			        \},
			        comments: \{
			          forms: \{
			            [postId]: \{
			              isSubmitted: false,
			              isSubmitting: true, // <-- This is the key property for this test
			              isError: false,
			              errorMessage: "",
			              errorCode: "",
			              errors: \{\},
			              fields: \{
			                content: "Hello world!",
			                authorName: "Frontibotito",
			                authorEmail: "frontibotito@frontity.org",
			                parent: 0,
			                authorURL: "https://frontity.org",
			              \},
			            \},
			          \},
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Send a comment and do not wait for the response.
			    store.actions.comments
			      .submit(postId, \{
			        content: "Other comment!",
			        authorName: "Other author",
			        authorEmail: "other@email.test",
			        authorURL: "https://other.url.test",
			        parent: 123,
			      \})
			      .catch(() => \{
			        // Do nothing.
			      \});
			
			    const form = store.state.comments.forms[postId];
			
			    // The submission should not be sent.
			    expect(fetch).not.toHaveBeenCalled();
			    expect(form).toMatchInlineSnapshot(\`
			      Object \{
			        "errorCode": "",
			        "errorMessage": "",
			        "errors": Object \{\},
			        "fields": Object \{
			          "authorEmail": "frontibotito@frontity.org",
			          "authorName": "Frontibotito",
			          "authorURL": "https://frontity.org",
			          "content": "Hello world!",
			          "parent": 0,
			        \},
			        "isError": false,
			        "isSubmitted": false,
			        "isSubmitting": true,
			      \}
			    \`);
			
			    // Check that a warning message was shown instead.
			    expect(warn.mock.calls).toMatchInlineSnapshot(\`
			      Array [
			        Array [
			          "You cannot submit a comment to the same post if another is already pending.",
			        ],
			      ]
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-comments\\src\\__tests__\\actions.submit.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(11)
    });
    it('frontity_frontity\\packages\\wp-comments\\src\\__tests__\\actions.updateFields.test.ts', () => {
        const sourceCode = `
			import clone from "clone-deep";
			import \{ createStore \} from "@frontity/connect";
			import \{ mergeDeepRight \} from "ramda";
			
			import wpComments from "..";
			import \{ Packages \} from "../../types";
			
			describe("actions.comments.updateFields", () => \{
			  test("should init the form object if it does not exist", () => \{
			    const store = createStore<Packages>(clone(wpComments));
			    const postId = 60;
			
			    // Pass \`comment\` field.
			    store.actions.comments.updateFields(postId, \{
			      content: "Hello world!",
			    \});
			
			    expect(store.state.comments.forms).toMatchInlineSnapshot(\`
			      Object \{
			        "60": Object \{
			          "errorCode": "",
			          "errorMessage": "",
			          "errorStatusCode": null,
			          "fields": Object \{
			            "content": "Hello world!",
			          \},
			          "isError": false,
			          "isSubmitted": false,
			          "isSubmitting": false,
			        \},
			      \}
			    \`);
			  \});
			
			  test("should update a single property", () => \{
			    // Specify a post ID where the comment is meant to be published.
			    const postId = 60;
			
			    // Mock packages with the API specified in state.source.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        comments: \{
			          forms: \{
			            [postId]: \{
			              fields: \{
			                content: "Hello world!",
			                authorName: "John Doe",
			                authorEmail: "johndoe@email.test",
			                authorURL: "",
			                parent: 0,
			              \},
			            \},
			          \},
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Change \`comment\` from "Hello world!" to "Hi everybody!".
			    store.actions.comments.updateFields(postId, \{
			      content: "Hi everybody!",
			    \});
			
			    expect(store.state.comments.forms).toMatchInlineSnapshot(\`
			      Object \{
			        "60": Object \{
			          "fields": Object \{
			            "authorEmail": "johndoe@email.test",
			            "authorName": "John Doe",
			            "authorURL": "",
			            "content": "Hi everybody!",
			            "parent": 0,
			          \},
			        \},
			      \}
			    \`);
			  \});
			
			  test("should update all properties specified", () => \{
			    // Specify a post ID where the comment is meant to be published.
			    const postId = 60;
			
			    // Mock packages with the API specified in state.source.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        comments: \{
			          forms: \{
			            [postId]: \{
			              fields: \{
			                content: "Hello world!",
			                authorName: "John Doe",
			                authorEmail: "hello@johndoe.test",
			              \},
			            \},
			          \},
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Change all form fields.
			    store.actions.comments.updateFields(postId, \{
			      authorName: "Jane Doe",
			      content: "Hi everybody!",
			      authorEmail: "hi@janedoe.test",
			      parent: 123,
			      authorURL: "https://janedoe.test",
			    \});
			
			    expect(store.state.comments.forms).toMatchInlineSnapshot(\`
			      Object \{
			        "60": Object \{
			          "fields": Object \{
			            "authorEmail": "hi@janedoe.test",
			            "authorName": "Jane Doe",
			            "authorURL": "https://janedoe.test",
			            "content": "Hi everybody!",
			            "parent": 123,
			          \},
			        \},
			      \}
			    \`);
			  \});
			
			  test("should reset all fields if nothing passed", () => \{
			    // Specify a post ID where the comment is meant to be published.
			    const postId = 60;
			
			    // Mock packages with the API specified in state.source.
			    const packages: any = mergeDeepRight(clone(wpComments), \{
			      state: \{
			        comments: \{
			          forms: \{
			            [postId]: \{
			              fields: \{
			                content: "Hello world!",
			                authorName: "John Doe",
			                authorEmail: "hello@johndoe.test",
			              \},
			            \},
			          \},
			        \},
			      \},
			    \});
			
			    // Create store from mocked packages.
			    const store = createStore<Packages>(packages as Packages);
			
			    // Change all form fields.
			    store.actions.comments.updateFields(postId);
			
			    // Only \`content\` should remain
			    expect(store.state.comments.forms).toMatchInlineSnapshot(\`
			      Object \{
			        "60": Object \{
			          "errorCode": "",
			          "errorMessage": "",
			          "errorStatusCode": null,
			          "fields": Object \{
			            "content": "",
			          \},
			          "isError": false,
			          "isSubmitted": false,
			          "isSubmitting": false,
			        \},
			      \}
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-comments\\src\\__tests__\\actions.updateFields.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\wp-comments\\src\\__tests__\\commentsHandler.test.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import wpSource from "@frontity/wp-source/src";
			import clone from "clone-deep";
			import \{ mergeDeepRight \} from "ramda";
			import wpComments from "../";
			import \{ Packages \} from "../../types";
			import \{ mockResponse, mockComment \} from "./mocks/helpers";
			
			type Api = Packages["libraries"]["source"]["api"];
			
			let store: InitializedStore<Packages>;
			let api: jest.Mocked<Api>;
			
			beforeEach(() => \{
			  const packages: any = mergeDeepRight(clone(wpSource()), clone(wpComments));
			  store = createStore<Packages>(packages);
			  store.state.source.url = "https://test.frontity.org/";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			  api.get = jest.fn();
			\});
			
			describe("commentsHandler", () => \{
			  test("should populate comments correctly", async () => \{
			    api.get.mockResolvedValueOnce(
			      mockResponse([
			        mockComment(\{ post: 60, id: 2 \}),
			        mockComment(\{ post: 60, id: 1 \}),
			      ])
			    );
			
			    await store.actions.source.fetch("@comments/60");
			
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(api.get.mock.calls[0]).toMatchSnapshot();
			    expect(store.state.source.comment).toMatchSnapshot();
			    expect(store.state.source.get("@comments/60")).toMatchSnapshot();
			  \});
			
			  test("should work fine if there are no comments", async () => \{
			    api.get.mockResolvedValueOnce(mockResponse([]));
			
			    await store.actions.source.fetch("@comments/60");
			
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(api.get.mock.calls[0]).toMatchSnapshot();
			    expect(store.state.source.comment).toMatchSnapshot();
			    expect(store.state.source.get("@comments/60")).toMatchSnapshot();
			  \});
			
			  test("should request more pages if there are more than 100 comments", async () => \{
			    // We use these headers to pretend that the responses contain many more
			    // comments than they actually have.
			    const responseProps = \{
			      headers: \{
			        "X-WP-TotalPages": "3",
			        "X-WP-Total": "201",
			      \},
			    \};
			
			    api.get
			      .mockResolvedValueOnce(
			        mockResponse([mockComment(\{ post: 60, id: 201 \})], responseProps)
			      )
			      .mockResolvedValueOnce(
			        mockResponse([mockComment(\{ post: 60, id: 101 \})], responseProps)
			      )
			      .mockResolvedValueOnce(
			        mockResponse([mockComment(\{ post: 60, id: 1 \})], responseProps)
			      );
			
			    await store.actions.source.fetch("@comments/60");
			
			    expect(api.get).toHaveBeenCalledTimes(3);
			    expect(api.get.mock.calls[0]).toMatchSnapshot();
			    expect(store.state.source.comment).toMatchSnapshot();
			    expect(store.state.source.get("@comments/60")).toMatchSnapshot();
			  \});
			
			  test("should handle replies correctly", async () => \{
			    api.get.mockResolvedValueOnce(
			      mockResponse([
			        mockComment(\{ post: 60, id: 3, parent: 2 \}),
			        mockComment(\{ post: 60, id: 2 \}),
			        mockComment(\{ post: 60, id: 1 \}),
			      ])
			    );
			
			    await store.actions.source.fetch("@comments/60");
			
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(api.get.mock.calls[0]).toMatchSnapshot();
			    expect(store.state.source.comment).toMatchSnapshot();
			    expect(store.state.source.get("@comments/60")).toMatchSnapshot();
			  \});
			
			  test("should handle replies correctly when more than one page", async () => \{
			    // We use these headers to pretend that the responses contain many more
			    // comments than they actually have.
			    const responseProps = \{
			      headers: \{
			        "X-WP-TotalPages": "2",
			        "X-WP-Total": "103",
			      \},
			    \};
			
			    api.get
			      .mockResolvedValueOnce(
			        mockResponse(
			          [
			            mockComment(\{ post: 60, id: 3, parent: 2 \}),
			            mockComment(\{ post: 60, id: 2 \}),
			            mockComment(\{ post: 60, id: 1 \}),
			          ],
			          responseProps
			        )
			      )
			      .mockResolvedValueOnce(
			        mockResponse(
			          [
			            mockComment(\{ post: 60, id: 6 \}),
			            mockComment(\{ post: 60, id: 5, parent: 4 \}),
			            mockComment(\{ post: 60, id: 4, parent: 3 \}),
			          ],
			          responseProps
			        )
			      );
			
			    await store.actions.source.fetch("@comments/60");
			
			    expect(api.get).toHaveBeenCalledTimes(2);
			    expect(api.get.mock.calls[0]).toMatchSnapshot();
			    expect(store.state.source.comment).toMatchSnapshot();
			    expect(store.state.source.get("@comments/60")).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-comments\\src\\__tests__\\commentsHandler.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\wp-comments\\src\\__tests__\\insertComment.test.ts', () => {
        const sourceCode = `
			import clone from "clone-deep";
			import \{ mergeDeepRight \} from "ramda";
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import wpSource from "@frontity/wp-source/src";
			
			import \{ mockResponse, mockComment \} from "./mocks/helpers";
			import wpComments, \{ insertComment \} from "../";
			import \{ Packages \} from "../../types";
			import \{ populate \} from "@frontity/wp-source/src/libraries";
			import Router from "../../../router/types";
			
			type Api = Packages["libraries"]["source"]["api"];
			
			let store: InitializedStore<Packages & Router>;
			let api: jest.Mocked<Api>;
			
			beforeEach(async () => \{
			  const packages: any = mergeDeepRight(clone(wpSource()), clone(wpComments));
			
			  store = createStore<Packages & Router>(packages);
			  store.state.source.url = "https://test.frontity.org/";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			  api.get = jest.fn();
			
			  // Let's insert 1 comment into the state
			  api.get.mockResolvedValueOnce(
			    mockResponse([
			      mockComment(\{ post: 60, id: 1 \}),
			      mockComment(\{ post: 60, id: 2, parent: 1 \}),
			    ])
			  );
			
			  await store.actions.source.fetch("@comments/60");
			\});
			
			describe("Inserting a comment", () => \{
			  test("should add 1 new comment correctly", async () => \{
			    const comment = mockComment(\{ post: 60, id: 3 \});
			    const response = mockResponse(comment);
			    const \{ state \} = store;
			
			    const \{ id, type \} = comment;
			    const commentItem = \{ id, type \};
			
			    await populate(\{ response, state \});
			    insertComment(commentItem, state);
			
			    expect((store.state.source.get("@comments/60") as any).items)
			      .toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "children": Array [
			            Object \{
			              "id": 2,
			              "type": "comment",
			            \},
			          ],
			          "id": 1,
			          "type": "comment",
			        \},
			        Object \{
			          "id": 3,
			          "type": "comment",
			        \},
			      ]
			    \`);
			  \});
			
			  test("should add a reply comment correctly", async () => \{
			    const comment = mockComment(\{ post: 60, id: 3, parent: 1 \});
			    const response = mockResponse(comment);
			    const \{ state \} = store;
			
			    await populate(\{ response, state \});
			
			    const \{ id, type \} = comment;
			    insertComment(\{ id, type \}, state);
			
			    expect((store.state.source.get("@comments/60") as any).items)
			      .toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "children": Array [
			            Object \{
			              "id": 2,
			              "type": "comment",
			            \},
			            Object \{
			              "id": 3,
			              "type": "comment",
			            \},
			          ],
			          "id": 1,
			          "type": "comment",
			        \},
			      ]
			    \`);
			  \});
			
			  test("should add a nested reply comment correctly", async () => \{
			    const comment = mockComment(\{ post: 60, id: 3, parent: 2 \});
			    const response = mockResponse(comment);
			    const \{ state \} = store;
			
			    const \{ id, type \} = comment;
			
			    await populate(\{ response, state \});
			    insertComment(\{ id, type \}, state);
			
			    expect((store.state.source.get("@comments/60") as any).items)
			      .toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "children": Array [
			            Object \{
			              "children": Array [
			                Object \{
			                  "id": 3,
			                  "type": "comment",
			                \},
			              ],
			              "id": 2,
			              "type": "comment",
			            \},
			          ],
			          "id": 1,
			          "type": "comment",
			        \},
			      ]
			    \`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-comments\\src\\__tests__\\insertComment.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(3)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\utils\\__tests__\\capitalize.test.ts', () => {
        const sourceCode = `
			import capitalize from "../capitalize";
			
			describe("capitalize", () => \{
			  test("should work with a single word", () => \{
			    expect(capitalize("word")).toBe("Word");
			  \});
			  test("should work with words separated by ' '", () => \{
			    expect(capitalize("some word")).toBe("SomeWord");
			  \});
			  test("should work with words separated by '-'", () => \{
			    expect(capitalize("other-some-word")).toBe("OtherSomeWord");
			  \});
			  test("should work with words separated by '_'", () => \{
			    expect(capitalize("another_some_word")).toBe("AnotherSomeWord");
			  \});
			  test("should work with words separated by any number of  ' ', '-' or '_'", () => \{
			    expect(capitalize("Some str---Cap _- test")).toBe("SomeStrCapTest");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\utils\\__tests__\\capitalize.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\utils\\__tests__\\validateDate.test.ts', () => {
        const sourceCode = `
			import validateDate from "../../utils/validateDate";
			
			describe("validate date", () => \{
			  test("2020/01/01", () => \{
			    validateDate(2020, 1, 1);
			  \});
			
			  test("2019 is not a leap year", () => \{
			    expect(() => \{
			      validateDate(2019, 2, 29);
			    \}).toThrowErrorMatchingInlineSnapshot(\`"29 is a wrong day number"\`);
			  \});
			
			  test("2020 is a leap year", () => \{
			    validateDate(2020, 2, 29);
			  \});
			
			  test("Invalid year", () => \{
			    expect(() => \{
			      validateDate(2222, 2, 2);
			    \}).toThrowErrorMatchingInlineSnapshot(\`"2222 is a wrong year number"\`);
			  \});
			
			  test("Invalid month", () => \{
			    expect(() => \{
			      validateDate(2019, 0, 15);
			    \}).toThrowErrorMatchingInlineSnapshot(\`"0 is a wrong month number"\`);
			  \});
			
			  test("Invalid day", () => \{
			    expect(() => \{
			      validateDate(2019, 2, 0);
			    \}).toThrowErrorMatchingInlineSnapshot(\`"0 is a wrong day number"\`);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\utils\\__tests__\\validateDate.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\author.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore, observe \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../../../";
			import WpSource from "../../../../types";
			import Api from "../../api";
			// JSON mocks
			import \{ mockResponse \} from "./mocks/helpers";
			import author1 from "./mocks/author/author-1.json";
			import author1Posts from "./mocks/author/author-1-posts.json";
			import author1PostsPage2 from "./mocks/author/author-1-posts-page-2.json";
			import author1PostsCpt from "./mocks/author/author-1-posts-cpt.json";
			import \{ isSearch \} from "@frontity/source";
			
			let store: InitializedStore<WpSource>;
			let api: jest.Mocked<Api>;
			beforeEach(() => \{
			  store = createStore<WpSource>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			\});
			
			describe("author", () => \{
			  test("doesn't exist in source.author", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([author1]))
			      .mockResolvedValueOnce(
			        mockResponse(author1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("was populated but not accessed", async () => \{
			    // Add author to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(author1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(author1PostsPage2, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Observe changes in isFetching and isReady properties
			    const dataState = [];
			    observe(() => \{
			      const \{ isFetching, isReady \} = store.state.source.get(
			        "/author/author-1/page/2/"
			      );
			      dataState.push(\{ isFetching, isReady \});
			    \});
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/page/2/");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			    // Values history of isFetching and isReady
			    expect(dataState).toEqual([
			      // First values are from a different object.
			      \{ isFetching: false, isReady: false \},
			      // Fetch starts.
			      \{ isFetching: true, isReady: false \},
			      // Intermediate values.
			      \{ isFetching: false, isReady: false \},
			      // Fetch ends.
			      \{ isFetching: false, isReady: true \},
			    ]);
			  \});
			
			  test("overwrites the data when fetched with \{ force: true \}", async () => \{
			    // Define the JSON response for the author with the name updated.
			    const updatedAuthor = \{ ...author1, name: "Author 2" \};
			
			    // Do the same for the posts that were written by that author.
			    const updatedPosts = clone(author1Posts);
			    updatedPosts.forEach((post) => (post._embedded.author = [updatedAuthor]));
			
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      // First \`actions.source.fetch()\` call.
			      .mockResolvedValueOnce(mockResponse(author1))
			      .mockResolvedValueOnce(
			        mockResponse(author1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      )
			      // Second \`actions.source.fetch()\` call, with the author name updated.
			      .mockResolvedValueOnce(mockResponse(updatedAuthor))
			      .mockResolvedValueOnce(
			        mockResponse(updatedPosts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			
			    // Fetch author posts for the first time.
			    await store.actions.source.fetch("/author/author-1/");
			    expect(store.state.source.author["1"].name).toEqual("Author 1");
			
			    // Fetch entities with \{ force: true \}.
			    await store.actions.source.fetch("/author/author-1/", \{ force: true \});
			
			    // Make sure that api.get() was called twice for each \`source.fetch()\`.
			    expect(api.get).toHaveBeenCalledTimes(4);
			
			    expect(store.state.source).toMatchSnapshot();
			    expect(store.state.source.author["1"].name).toEqual("Author 2");
			  \});
			
			  test("fetchs from a different endpoint with extra params", async () => \{
			    // Add custom post endpoint and params
			    store.state.source.postEndpoint = "multiple-post-type";
			    store.state.source.params = \{ type: ["post", "cpt"] \};
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([author1]))
			      .mockResolvedValueOnce(
			        mockResponse(author1PostsCpt, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("returns 404 if author doesn't exist in WP", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValue(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/author/non-existent/");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("returns 404 if the page fetched is out of range", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([author1]))
			      .mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/page/3");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("doesn't return 404 if the first page is empty", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([author1]))
			      .mockResolvedValueOnce(
			        mockResponse([], \{
			          "X-WP-Total": "0",
			          "X-WP-TotalPages": "0",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("doesn't return 404 if the first page is empty (no headers)", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([author1]))
			      .mockResolvedValueOnce(mockResponse([], \{\}));
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("is requested with any query param", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([author1]))
			      .mockResolvedValueOnce(
			        mockResponse(author1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/?some=param");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("is requested with a search param", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([author1]))
			      .mockResolvedValueOnce(
			        mockResponse(author1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/author/author-1/?s=findAuthor");
			
			    const data = store.state.source.data["/author/author-1/?s=findAuthor"];
			    expect(isSearch(data)).toBe(true);
			    expect(isSearch(data) && data.searchQuery).toBe("findAuthor");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\author.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(10)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\category.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore, observe \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../../../";
			import WpSource from "../../../../types";
			import Api from "../../api";
			// JSON mocks
			import \{ mockResponse \} from "./mocks/helpers";
			import cat1 from "./mocks/category/cat-1.json";
			import cat1Posts from "./mocks/category/cat-1-posts.json";
			import cat1PostsPage2 from "./mocks/category/cat-1-posts-page-2.json";
			import cat1PostsCpt from "./mocks/category/cat-1-posts-cpt.json";
			
			let store: InitializedStore<WpSource>;
			let api: jest.Mocked<Api>;
			beforeEach(() => \{
			  store = createStore<WpSource>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			\});
			
			describe("category", () => \{
			  test("doesn't exist in source.category", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(
			        mockResponse(cat1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("was populated but not accessed", async () => \{
			    // Add category to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse([cat1]),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(cat1PostsPage2, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Observe changes in isFetching and isReady properties
			    const dataState = [];
			    observe(() => \{
			      const \{ isFetching, isReady \} = store.state.source.get(
			        "/category/cat-1/page/2/"
			      );
			      dataState.push(\{ isFetching, isReady \});
			    \});
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/page/2/");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			    // Values history of isFetching and isReady
			    expect(dataState).toEqual([
			      // First values are from a different object.
			      \{ isFetching: false, isReady: false \},
			      // Fetch starts.
			      \{ isFetching: true, isReady: false \},
			      // Intermediate values.
			      \{ isFetching: false, isReady: false \},
			      // Fetch ends.
			      \{ isFetching: false, isReady: true \},
			    ]);
			  \});
			
			  test("fetchs from a different endpoint with extra params", async () => \{
			    // Add custom post endpoint and params
			    store.state.source.postEndpoint = "multiple-post-type";
			    store.state.source.params = \{ type: ["post", "cpt"] \};
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(
			        mockResponse(cat1PostsCpt, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("returns 404 if category doesn't exist in WP", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValue(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/category/non-existent/");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("returns 404 if the page fetched is out of range", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/page/3");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("doesn't return 404 if the first page is empty", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(
			        mockResponse([], \{
			          "X-WP-Total": "0",
			          "X-WP-TotalPages": "0",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("doesn't return 404 if the first page is empty (no headers)", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(mockResponse([], \{\}));
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("is requested with any query param", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(
			        mockResponse(cat1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/?some=param");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("with a search", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(
			        mockResponse(cat1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "3",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/?s=some+search");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("with a search with pagination", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([cat1]))
			      .mockResolvedValueOnce(
			        mockResponse(cat1PostsPage2, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "3",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/category/cat-1/page/2?s=some+search");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("Unknown URL should return a 404 even if it's substring matches a path", async () => \{
			    api.get = jest.fn((_) =>
			      Promise.resolve(
			        mockResponse(cat1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      )
			    );
			
			    await store.actions.source.fetch("/category/undefined/cat-1/");
			
			    expect(
			      (store.state.source.data as any)["/category/undefined/cat-1/"]
			        .errorStatusText
			    ).toBe(
			      "You have tried to access content at route: /category/undefined/cat-1/ but it does not exist"
			    );
			
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\category.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(11)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\date.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../../../";
			import WpSource from "../../../../types";
			import Api from "../../api";
			// JSON mocks
			import \{ mockResponse \} from "./mocks/helpers";
			import date2019Posts from "./mocks/date/2019-posts.json";
			import date2019PostsPage2 from "./mocks/date/2019-posts-page-2.json";
			import date201901Posts from "./mocks/date/2019-01-posts.json";
			import date20190101Posts from "./mocks/date/2019-01-01-posts.json";
			import date20190101PostsCpt from "./mocks/date/2019-01-01-posts-cpt.json";
			
			let store: InitializedStore<WpSource>;
			let api: jest.Mocked<Api>;
			beforeEach(() => \{
			  store = createStore<WpSource>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			\});
			
			describe("date", () => \{
			  test("get two pages of year 2019", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(
			        mockResponse(date2019Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      )
			      .mockResolvedValueOnce(
			        mockResponse(date2019PostsPage2, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/2019/");
			    await store.actions.source.fetch("/2019/page/2/");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("get two pages of year 2019 (with query params)", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(
			        mockResponse(date2019Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      )
			      .mockResolvedValueOnce(
			        mockResponse(date2019PostsPage2, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/2019/?some=param");
			    await store.actions.source.fetch("/2019/page/2/?some=param");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("get two pages of year 2019 (with search)", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(
			        mockResponse(date2019Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "3",
			        \})
			      )
			      .mockResolvedValueOnce(
			        mockResponse(date2019PostsPage2, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "3",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/2019/?s=some+search");
			    await store.actions.source.fetch("/2019/page/2/?s=some+search");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("get January, 2019", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(date201901Posts, \{
			        "X-WP-Total": "2",
			        "X-WP-TotalPages": "1",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/2019/01/");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("get January 1, 2019", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(date20190101Posts, \{
			        "X-WP-Total": "1",
			        "X-WP-TotalPages": "1",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/2019/01/01");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("fetchs from a different endpoint with extra params", async () => \{
			    // Add custom post endpoint and params
			    store.state.source.postEndpoint = "multiple-post-type";
			    store.state.source.params = \{ type: ["post", "cpt"] \};
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(date20190101PostsCpt, \{
			        "X-WP-Total": "2",
			        "X-WP-TotalPages": "1",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/2019/01/01");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("returns 404 if the page fetched is empty", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/2020/");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("overwrites the data when fetched with \{ force: true \}", async () => \{
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(
			        mockResponse(date2019Posts, \{
			          "X-WP-Total": "3",
			          "X-WP-TotalPages": "1",
			        \})
			      )
			      .mockResolvedValueOnce(
			        mockResponse(date2019PostsPage2, \{
			          "X-WP-Total": "3",
			          "X-WP-TotalPages": "1",
			        \})
			      );
			
			    // Fetch the data for the first page
			    await store.actions.source.fetch("/2019/");
			
			    // Fetch the data again (this time returning \`date2019PostsPage2\`)
			    await store.actions.source.fetch("/2019/", \{
			      force: true,
			    \});
			
			    // Make sure that api.get() was called for each \`source.fetch()\`
			    expect(api.get).toHaveBeenCalledTimes(2);
			
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("An invalid month of the year should return a 404", async () => \{
			    await store.actions.source.fetch("/2020/99/");
			
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("An invalid day of the month should return a 404", async () => \{
			    await store.actions.source.fetch("/2020/12/77");
			
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("An invalid day AND month should return a 404", async () => \{
			    await store.actions.source.fetch("/2020/999/999");
			
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\date.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(11)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\post-archive.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../../../";
			import WpSource from "../../../../types";
			import Api from "../../api";
			// JSON mocks
			import \{ mockResponse \} from "./mocks/helpers";
			import posts from "./mocks/post-archive/posts.json";
			import posts2 from "./mocks/post-archive/posts-page-2.json";
			import postsCpt from "./mocks/post-archive/posts-cpt.json";
			
			let store: InitializedStore<WpSource>;
			let api: jest.Mocked<Api>;
			beforeEach(() => \{
			  store = createStore<WpSource>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			\});
			
			describe("post archive", () => \{
			  test("works with first page", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(posts, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with pagination", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(posts2, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/page/2/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("fetchs from a different endpoint with extra params", async () => \{
			    // Add custom post endpoint and params
			    store.state.source.postEndpoint = "multiple-post-type";
			    store.state.source.params = \{ type: ["post", "cpt"] \};
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(postsCpt, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(posts, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/?some=param");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params and pagination", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(posts2, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/page/2/?some=param");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with search", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(posts, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/?s=some+search");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with search and pagination", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(posts2, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/page/2/?s=some+search");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("overwrites the data when fetched with \{ force: true \}", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(
			        mockResponse(posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      )
			      .mockResolvedValueOnce(
			        mockResponse(posts2, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			
			    // Fetch entities
			    await store.actions.source.fetch("/");
			
			    await store.actions.source.fetch("/", \{ force: true \});
			
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\post-archive.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(8)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\post-type-with-query.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../../..";
			import WpSource from "../../../../types";
			import Api from "../../api";
			// JSON mocks
			import \{ mockResponse \} from "./mocks/helpers";
			import page1 from "./mocks/post-type/page-1.json";
			import post1 from "./mocks/post-type/post-1.json";
			import post1withType from "./mocks/post-type/post-1-with-type.json";
			import cpt11 from "./mocks/post-type/cpt-11.json";
			import \{ ServerError, isError \} from "@frontity/source";
			import \{ PostEntity \} from "@frontity/source/types";
			
			interface WpSourceAndCpt extends WpSource \{
			  state: WpSource["state"] & \{
			    source: WpSource["state"]["source"] & \{
			      cpt: Record<string, PostEntity>;
			    \};
			  \};
			\}
			
			let store: InitializedStore<WpSourceAndCpt>;
			let api: jest.Mocked<Api>;
			beforeEach(() => \{
			  store = createStore<WpSourceAndCpt>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			\});
			
			describe("postType", () => \{
			  test("returns 404 if not found", async () => \{
			    // Mock Api responses We have to use this form instead of:
			    // .mockResolvedValueOnce(mockResponse([])) because the latter always
			    // returns the same instance of Response. which results in error because
			    // response.json() can only be run once
			    api.get = jest.fn((_) =>
			      Promise.reject(new ServerError("Not Found", 404, "Not Found"))
			    );
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("should contain the correct error code on error", async () => \{
			    // Mock Api responses
			    api.get = jest.fn(async (_) => \{
			      throw new ServerError("Bad Request", 400, "Bad Request");
			    \});
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1");
			    const data = store.state.source.data["/?p=1"];
			    expect(isError(data)).toBe(true);
			    expect(isError(data) && data.is400).toBe(true);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			
			describe("post", () => \{
			  test("doesn't exist in source.post", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(post1));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("exists in source.post", async () => \{
			    // Add post to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(post1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1");
			    expect(api.get).not.toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (doesn't exist in source.post)", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(post1));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1&some=param");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (exists in source.post)", async () => \{
			    // Add post to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(post1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1&some=param");
			    expect(api.get).not.toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with unordered query params (doesn't exist in source.post)", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(post1));
			    // Fetch entities
			    await store.actions.source.fetch("/?z=v1&p=1&a=v2");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with unordered query params (exists in source.post)", async () => \{
			    // Add post to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(post1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn();
			    // Fetch entities
			    await store.actions.source.fetch("/?z=v1&p=1&a=v2");
			    expect(api.get).not.toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with types embedded", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(post1withType));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("uses the auth token to fetch an unpublished draft", async () => \{
			    // Mock auht token.
			    store.state.source.auth = "Bearer TOKEN";
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(post1));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1");
			    expect(api.get.mock.calls[0]).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "auth": "Bearer TOKEN",
			          "endpoint": "posts/1",
			          "params": Object \{
			            "_embed": true,
			          \},
			        \},
			      ]
			    \`);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("populates an error when using an invalid auth token", async () => \{
			    // Mock auht token.
			    store.state.source.auth = "Bearer INVALID";
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockRejectedValueOnce(new ServerError("Forbidden", 403, "Forbidden"));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=1");
			    expect(api.get.mock.calls[0]).toMatchInlineSnapshot(\`
			      Array [
			        Object \{
			          "auth": "Bearer INVALID",
			          "endpoint": "posts/1",
			          "params": Object \{
			            "_embed": true,
			          \},
			        \},
			      ]
			    \`);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			
			describe("page", () => \{
			  test("doesn't exist in source.page", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(page1));
			    // Fetch entities
			    await store.actions.source.fetch("/?page_id=1");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("exists in source.page", async () => \{
			    // Add page to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(page1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn();
			    // Fetch entities
			    await store.actions.source.fetch("/?page_id=1");
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (doesn't exist in source.page)", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(page1));
			    // Fetch entities
			    await store.actions.source.fetch("/?page_id=1&some=param");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (exists in source.page)", async () => \{
			    // Add page to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(page1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/?page_id=1&some=param");
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			
			describe("custom post type", () => \{
			  test("works with custom post types (doesn't exist in source.post)", async () => \{
			    store.state.source.postTypes = [
			      \{
			        endpoint: "cpts",
			        type: "cpt",
			      \},
			    ];
			    // Execute init and create handlers for CPT.
			    store.actions.source.init();
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse(cpt11));
			    // Fetch entities
			    await store.actions.source.fetch("/?p=11&post_type=cpt");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with custom post types (exists in source.post)", async () => \{
			    store.state.source.postTypes = [
			      \{
			        endpoint: "cpts",
			        type: "cpt",
			      \},
			    ];
			    // Execute init and create handlers for CPT.
			    store.actions.source.init();
			    const response = mockResponse(cpt11);
			    // Add post to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response,
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/?post_type=cpt&p=11");
			    expect(api.get).not.toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\post-type-with-query.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(17)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\post-type.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../../../";
			import WpSource from "../../../../types";
			import Api from "../../api";
			// JSON mocks
			import \{ mockResponse \} from "./mocks/helpers";
			import attachment1 from "./mocks/post-type/attachment-1.json";
			import page1 from "./mocks/post-type/page-1.json";
			import page1WithParent from "./mocks/post-type/page-1-with-parent.json";
			import childPageWithParentSameSlug from "./mocks/post-type/child-page-with-parent-same-slug.json";
			import post1 from "./mocks/post-type/post-1.json";
			import post1Revision from "./mocks/post-type/post-1-revision.json";
			import post1withType from "./mocks/post-type/post-1-with-type.json";
			import cpt11 from "./mocks/post-type/cpt-11.json";
			import cpt11WithParent from "./mocks/post-type/cpt-11-with-parent.json";
			import \{ ServerError, isError, isPostType \} from "@frontity/source";
			import \{ PostEntity \} from "@frontity/source/types";
			
			interface WpSourceAndCpt extends WpSource \{
			  state: WpSource["state"] & \{
			    source: WpSource["state"]["source"] & \{
			      cpt: Record<string, PostEntity>;
			    \};
			  \};
			\}
			
			let store: InitializedStore<WpSourceAndCpt>;
			let api: jest.Mocked<Api>;
			let postTypeHandler: jest.SpyInstance;
			let customPostTypeHandler: jest.SpyInstance;
			
			beforeEach(() => \{
			  store = createStore<WpSourceAndCpt>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org";
			  store.state.source.postTypes = [
			    \{
			      type: "cpt",
			      endpoint: "cpts",
			      archive: "/cpt",
			    \},
			  ];
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			  postTypeHandler = jest.spyOn(
			    store.libraries.source.handlers.find(
			      (handler) => handler.name === "post type"
			    ),
			    "func"
			  );
			  customPostTypeHandler = jest.spyOn(
			    store.libraries.source.handlers.find((handler) => handler.name === "cpt"),
			    "func"
			  );
			  postTypeHandler.mockClear();
			  customPostTypeHandler.mockClear();
			\});
			
			describe("postType", () => \{
			  test("returns 404 if not found", async () => \{
			    // Mock Api responses
			    // We have to use this form instead of:
			    // .mockResolvedValueOnce(mockResponse([]))
			    // because the latter always returns the same instance of Response.
			    // which results in error because response.json() can only be run once
			    api.get = jest.fn((_) => Promise.resolve(mockResponse([])));
			
			    // Fetch entities
			    await store.actions.source.fetch("/non-existent/");
			    expect(api.get).toHaveBeenCalledTimes(3);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("should contain the correct error code on error", async () => \{
			    // Mock Api responses
			    api.get = jest.fn(async (_) => \{
			      throw new ServerError("statusText", 400, "statusText");
			    \});
			
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/");
			
			    const data = store.state.source.data["/post-1/"];
			    expect(isError(data)).toBe(true);
			    expect(isError(data) && data.is400).toBe(true);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			
			describe("post", () => \{
			  test("doesn't exist in source.post", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([post1]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/");
			    expect(store.state.source).toMatchSnapshot();
			    expect(postTypeHandler).toHaveBeenCalled();
			  \});
			
			  test("exists in source.post", async () => \{
			    // Add post to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(post1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn();
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(api.get).not.toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("fetchs from a different endpoint with extra params", async () => \{
			    // Add custom post endpoint and params
			    store.state.source.postEndpoint = "multiple-post-type";
			    store.state.source.params = \{ type: ["post", "cpt"] \};
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([cpt11]));
			    // Fetch entities
			    await store.actions.source.fetch("/cpt/cpt-11");
			    expect(postTypeHandler).not.toHaveBeenCalled();
			    expect(customPostTypeHandler).toHaveBeenCalled();
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (doesn't exist in source.post)", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([post1]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/?some=param");
			    expect(store.state.source).toMatchSnapshot();
			    expect(postTypeHandler).toHaveBeenCalled();
			  \});
			
			  test("works with query params (exists in source.post)", async () => \{
			    // Add post to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(post1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn();
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/?some=param");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(api.get).not.toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with types embedded", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([post1withType]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("applies the latest revision if it is a preview", async () => \{
			    // Mock auth token
			    store.state.source.auth = "Bearer TOKEN";
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([post1]))
			      .mockResolvedValueOnce(mockResponse([post1Revision]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/?preview=true");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			
			    // Get updated props from the post that was fetched.
			    const \{ title, content, excerpt \} = store.state.source.post[1];
			    expect(\{ title, content, excerpt \}).toMatchInlineSnapshot(\`
			      Object \{
			        "content": Object \{
			          "rendered": "Content from revision 11",
			        \},
			        "excerpt": Object \{
			          "rendered": "Excerpt from revision 11",
			        \},
			        "title": Object \{
			          "rendered": "Title from revision 11",
			        \},
			      \}
			    \`);
			  \});
			
			  test("previews works even when per_page is manually set", async () => \{
			    // Mock auth token
			    store.state.source.auth = "Bearer TOKEN";
			    store.state.source.params.per_page = 3;
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([post1]))
			      .mockResolvedValueOnce(mockResponse([post1Revision]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/?preview=true");
			    expect(api.get).toHaveBeenNthCalledWith(2, \{
			      auth: "Bearer TOKEN",
			      endpoint: "posts/1/revisions",
			      params: \{ per_page: 1 \},
			    \});
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("populates an error if it is a preview with an invalid token", async () => \{
			    // Mock auth token
			    store.state.source.auth = "Bearer INVALID";
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([post1]))
			      .mockRejectedValueOnce(new ServerError("Forbidden", 403, "Forbidden"));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/?preview=true");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("ignores the preview parameter if there is no auth token", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([post1]))
			      .mockRejectedValueOnce(new ServerError("Forbidden", 403, "Forbidden"));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/?preview=true");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			
			describe("page", () => \{
			  test("doesn't exist in source.page", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([]))
			      .mockResolvedValueOnce(mockResponse([page1]));
			    // Fetch entities
			    await store.actions.source.fetch("/page-1/");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("exists in source.page", async () => \{
			    // Add page to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(page1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/page-1/");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (doesn't exist in source.page)", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([]))
			      .mockResolvedValueOnce(mockResponse([page1]));
			    // Fetch entities
			    await store.actions.source.fetch("/page-1/?some=param");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (exists in source.page)", async () => \{
			    // Add page to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(page1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/page-1/?some=param");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("can have a parent", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([]))
			      .mockResolvedValueOnce(mockResponse([page1WithParent]));
			    // Fetch entities
			    await store.actions.source.fetch("/parent/page-1/");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("can have a parent with the same slug", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse(childPageWithParentSameSlug));
			
			    await store.actions.source.fetch("/parent/page-1/");
			    const childData = store.state.source.data["/parent/page-1/"];
			    expect(childData.isReady).toBe(true);
			
			    // at this point both /parent/page-1 and /page-1 should already be in state.
			    const parentData = store.state.source.data["/page-1/"];
			    expect(parentData.link).toBe("/page-1/");
			
			    // however it's not "ready" yet.
			    await store.actions.source.fetch("/page-1/");
			    expect(parentData.isReady).toBe(true);
			
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			
			describe("attachment", () => \{
			  test("doesn't exist in source.attachment", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([]))
			      .mockResolvedValueOnce(mockResponse([attachment1]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/attachment-1/");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("exists in source.attachment", async () => \{
			    // Add attachment to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(attachment1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValue(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/attachment-1/");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (doesn't exist in source.attachment)", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([]))
			      .mockResolvedValueOnce(mockResponse([attachment1]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/attachment-1/?some=param");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (exists in source.attachment)", async () => \{
			    // Add attachment to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(attachment1),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValue(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/post-1/attachment-1/?some=param");
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("overwrites the data when fetched with \{ force: true \}", async () => \{
			    api.get = jest.fn((_) => Promise.resolve(mockResponse([post1])));
			
			    // Fetch entities
			    await store.actions.source.fetch("/post-1");
			
			    // Restore the mock (just change the ID)
			    api.get = jest.fn((_) =>
			      Promise.resolve(mockResponse([\{ ...post1, id: 2 \}]))
			    );
			
			    // Fetch again
			    await store.actions.source.fetch("/post-1", \{ force: true \});
			
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			
			    // Should have the new ID now
			    const data = store.state.source.get("/post-1");
			    expect(isPostType(data) && data.id).toEqual(2);
			
			    // Delete the IDs because there are different
			    const firstPost = store.state.source.post[1];
			    const secondPost = store.state.source.post[2];
			    delete firstPost.id;
			    delete secondPost.id;
			
			    expect(firstPost).toMatchObject(secondPost);
			  \});
			
			  test("Every unknown URL should return a 404 even if it's substring matches a path", async () => \{
			    api.get = jest.fn((_) =>
			      Promise.resolve(
			        mockResponse([
			          \{
			            id: 1,
			            slug: "post-1",
			            type: "post",
			            link: "https://test.frontity.org/post-1/",
			          \},
			        ])
			      )
			    );
			
			    await store.actions.source.fetch("/undefined/post-1/");
			
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("Every unknown URL should return a 404 even if it's substring matches a path 2", async () => \{
			    api.get = jest.fn((_) =>
			      Promise.resolve(
			        mockResponse([
			          \{
			            id: 1,
			            slug: "post-1",
			            type: "post",
			            link: "https://test.frontity.org/post-1/",
			          \},
			        ])
			      )
			    );
			
			    await store.actions.source.fetch("/does/not/exist/");
			
			    expect(postTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			
			describe("custom post type", () => \{
			  test("doesn't exist in source.page", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([cpt11]));
			    // Fetch entities
			    await store.actions.source.fetch("/cpt/cpt-11/");
			    expect(postTypeHandler).not.toHaveBeenCalled();
			    expect(customPostTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("exists in source.page", async () => \{
			    // Add page to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(cpt11),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/cpt/cpt-11/");
			    expect(postTypeHandler).not.toHaveBeenCalled();
			    expect(customPostTypeHandler).toHaveBeenCalled();
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (doesn't exist in source.page)", async () => \{
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([cpt11]));
			    // Fetch entities
			    await store.actions.source.fetch("/cpt/cpt-11/?some=param");
			    expect(postTypeHandler).not.toHaveBeenCalled();
			    expect(customPostTypeHandler).toHaveBeenCalled();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with query params (exists in source.page)", async () => \{
			    // Add page to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(cpt11),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([cpt11]));
			    // Fetch entities
			    await store.actions.source.fetch("/cpt/cpt-11/?some=param");
			    expect(postTypeHandler).not.toHaveBeenCalled();
			    expect(customPostTypeHandler).toHaveBeenCalled();
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("works with custom post types with parent pages", async () => \{
			    // Add page to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse(cpt11WithParent),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(mockResponse([cpt11WithParent]));
			    // Fetch entities
			    await store.actions.source.fetch("/cpt/parent/cpt-11/");
			    expect(postTypeHandler).not.toHaveBeenCalled();
			    expect(customPostTypeHandler).toHaveBeenCalled();
			    expect(api.get).toHaveBeenCalledTimes(0);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\post-type.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(30)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\tag.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore, observe \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../../../";
			import WpSource from "../../../../types";
			import Api from "../../api";
			// JSON mocks
			import \{ mockResponse \} from "./mocks/helpers";
			import tag1 from "./mocks/tag/tag-1.json";
			import tag1Posts from "./mocks/tag/tag-1-posts.json";
			import tag1PostsPage2 from "./mocks/tag/tag-1-posts-page-2.json";
			import tag1PostsCpt from "./mocks/tag/tag-1-posts-cpt.json";
			
			let store: InitializedStore<WpSource>;
			let api: jest.Mocked<Api>;
			beforeEach(() => \{
			  store = createStore<WpSource>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org";
			  store.actions.source.init();
			  api = store.libraries.source.api as jest.Mocked<Api>;
			\});
			
			describe("tag", () => \{
			  test("doesn't exist in source.tag", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(
			        mockResponse(tag1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("was populated but not accessed", async () => \{
			    // Add tag to the store
			    await store.libraries.source.populate(\{
			      state: store.state,
			      response: mockResponse([tag1]),
			    \});
			    // Mock Api responses
			    api.get = jest.fn().mockResolvedValueOnce(
			      mockResponse(tag1PostsPage2, \{
			        "X-WP-Total": "5",
			        "X-WP-TotalPages": "2",
			      \})
			    );
			    // Observe changes in isFetching and isReady properties
			    const dataState = [];
			    observe(() => \{
			      const \{ isFetching, isReady \} = store.state.source.get(
			        "/tag/tag-1/page/2/"
			      );
			      dataState.push(\{ isFetching, isReady \});
			    \});
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/page/2/");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			    // Values history of isFetching and isReady
			    expect(dataState).toEqual([
			      // First values are from a different object.
			      \{ isFetching: false, isReady: false \},
			      // Fetch starts.
			      \{ isFetching: true, isReady: false \},
			      // Intermediate values.
			      \{ isFetching: false, isReady: false \},
			      // Fetch ends.
			      \{ isFetching: false, isReady: true \},
			    ]);
			  \});
			
			  test("fetchs from a different endpoint with extra params", async () => \{
			    // Add custom post endpoint and params
			    store.state.source.postEndpoint = "multiple-post-type";
			    store.state.source.params = \{ type: ["post", "cpt"] \};
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(
			        mockResponse(tag1PostsCpt, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/");
			    expect(api.get.mock.calls).toMatchSnapshot();
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("returns 404 if tag doesn't exist in WP", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValue(mockResponse([], \{\}, \{ status: 404 \}));
			
			    // Fetch entities
			    await store.actions.source.fetch("/tag/non-existent/");
			    expect(api.get).toHaveBeenCalledTimes(1);
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("returns 404 if the page fetched is out of range", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(mockResponse([]));
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/page/3");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("doesn't return 404 if the first page is empty", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(
			        mockResponse([], \{
			          "X-WP-Total": "0",
			          "X-WP-TotalPages": "0",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("doesn't return 404 if the first page is empty (no headers)", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(mockResponse([], \{\}));
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("is requested with any query param", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(
			        mockResponse(tag1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "2",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/?some=param");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("with a search", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(
			        mockResponse(tag1Posts, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "3",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/?s=some+search");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			
			  test("with a search with pagination", async () => \{
			    // Mock Api responses
			    api.get = jest
			      .fn()
			      .mockResolvedValueOnce(mockResponse([tag1]))
			      .mockResolvedValueOnce(
			        mockResponse(tag1PostsPage2, \{
			          "X-WP-Total": "5",
			          "X-WP-TotalPages": "3",
			        \})
			      );
			    // Fetch entities
			    await store.actions.source.fetch("/tag/tag-1/page/2?s=some+search");
			    expect(store.state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\handlers\\__tests__\\tag.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(10)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\schemas\\__tests__\\entity.tests.ts', () => {
        const sourceCode = `
			import \{ normalize \} from "normalizr";
			// https://test.frontity.org/?rest_route=/wp/v2/posts/60&_embed=true
			import post60 from "./mocks/post-60.json";
			// https://test.frontity.org/?rest_route=/wp/v2/categories/7&_embed=true
			import category7 from "./mocks/category-7.json";
			// https://test.frontity.org/?rest_route=/wp/v2/tags/10&_embed=true
			import tag10 from "./mocks/tag-10.json";
			// https://test.frontity.org/?rest_route=/wp/v2/users/4&_embed=true
			import author4 from "./mocks/author-4.json";
			// https://test.frontity.org/?rest_route=/wp/v2/media/193&_embed=true
			import media193 from "./mocks/media-193.json";
			// https://test.frontity.org/?rest_route=/wp/v2/pages/184&_embed=true
			import page184 from "./mocks/page-with-subpage.json";
			// https://test.frontity.org/?rest_route=/wp/v2/comments/5
			import comment5 from "./mocks/comment-5.json";
			
			import latestMovie from "./mocks/latest-movie.json";
			import postType from "./mocks/post-type.json";
			
			import \{ entity \} from "../";
			
			test("Convert post using entity", () => \{
			  const \{ entities \} = normalize(post60, entity);
			  expect(entities.postEntity[60]).toMatchSnapshot();
			  expect(entities.attachmentEntity[62]).toMatchSnapshot();
			  expect(entities.categoryEntity[3]).toMatchSnapshot();
			  expect(entities.tagEntity[10]).toMatchSnapshot();
			  expect(entities.authorEntity[4]).toMatchSnapshot();
			  expect(entities.taxonomyEntity.post).toMatchSnapshot();
			  expect(entities.commentEntity[5]).toMatchSnapshot();
			\});
			
			test("Convert a category using entity", () => \{
			  const \{ entities \} = normalize(category7, entity);
			  expect(entities.categoryEntity[7]).toMatchSnapshot();
			\});
			
			test("Convert a tag using entity", () => \{
			  const \{ entities \} = normalize(tag10, entity);
			  expect(entities.tagEntity[10]).toMatchSnapshot();
			\});
			
			test("Convert a author using entity", () => \{
			  const \{ entities \} = normalize(author4, entity);
			  expect(entities.authorEntity[4]).toMatchSnapshot();
			\});
			
			test("Convert an attachment using entity", () => \{
			  const \{ entities \} = normalize(media193, entity);
			  expect(entities.attachmentEntity[193]).toMatchSnapshot();
			\});
			
			test("Convert a page using entity and ignore subpages", () => \{
			  const \{ entities \} = normalize(page184, entity);
			  expect(entities.postEntity[184]).toMatchSnapshot();
			  expect(entities.postEntity[211]).toBe(undefined);
			\});
			
			test("Convert a latest taxonomy using entity", () => \{
			  const \{ entities \} = normalize(latestMovie, entity);
			  expect(entities.taxonomyEntity.movie).toMatchSnapshot();
			\});
			
			test("Convert a post type using entity", () => \{
			  const \{ entities \} = normalize(postType, entity);
			  expect(entities.postType.post).toMatchSnapshot();
			\});
			
			test("Convert a comment using entity", () => \{
			  const \{ entities \} = normalize(comment5, entity);
			  expect(entities.commentEntity[5]).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\schemas\\__tests__\\entity.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(9)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\schemas\\__tests__\\list.tests.ts', () => {
        const sourceCode = `
			import \{ normalize \} from "normalizr";
			// https://test.frontity.org/?rest_route=/wp/v2/posts&categories=7&_embed=true
			import category7 from "./mocks/posts-from-category-7.json";
			// https://test.frontity.org/?rest_route=/wp/v2/categories&_embed=true&per_page=3
			import categoriesList from "./mocks/categories-list.json";
			// https://test.frontity.org/?rest_route=/wp/v2/tags&_embed=true
			import tagsList from "./mocks/tags-list.json";
			// https://test.frontity.org/?rest_route=/wp/v2/users&_embed=true
			import authorList from "./mocks/author-list.json";
			// https://test.frontity.org/?rest_route=/wp/v2/media&_embed=true
			import mediaList from "./mocks/media-list.json";
			// https://test.frontity.org/?rest_route=/wp/v2/media&_embed=true
			import commentList from "./mocks/post-60-comments.json";
			
			import \{ list \} from "../";
			
			test("Convert list of posts using list", () => \{
			  const \{ entities \} = normalize(category7, list);
			  expect(entities).toMatchSnapshot();
			\});
			
			test("Convert a category list", () => \{
			  const \{ entities \} = normalize(categoriesList, list);
			  expect(entities).toMatchSnapshot();
			\});
			
			test("Convert a tag list", () => \{
			  const \{ entities \} = normalize(tagsList, list);
			  expect(entities).toMatchSnapshot();
			\});
			
			test("Convert a author list", () => \{
			  const \{ entities \} = normalize(authorList, list);
			  expect(entities).toMatchSnapshot();
			\});
			
			test("Convert a media list", () => \{
			  const \{ entities \} = normalize(mediaList, list);
			  expect(entities).toMatchSnapshot();
			\});
			
			test("Convert a comment list", () => \{
			  const \{ entities \} = normalize(commentList, list);
			  expect(entities).toMatchSnapshot();
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\schemas\\__tests__\\list.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(6)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\api.tests.ts', () => {
        const sourceCode = `
			import * as frontity from "frontity";
			import Api from "../api";
			import \{ Response as NodeResponse \} from "node-fetch";
			
			const response = (new NodeResponse() as unknown) as Response;
			const mockedFetch: jest.MockedFunction<typeof fetch> = jest.fn();
			(frontity.fetch as typeof fetch) = mockedFetch;
			mockedFetch.mockResolvedValue(response);
			
			const lastFetch = () => mockedFetch.mock.calls.slice(-1)[0][0];
			const api = new Api();
			
			describe("api", () => \{
			  test("get from WP.org without params", async () => \{
			    api.get(\{
			      api: "https://test.frontity.org/wp-json",
			      endpoint: "posts",
			    \});
			    expect(lastFetch()).toBe("https://test.frontity.org/wp-json/wp/v2/posts");
			  \});
			
			  test("get from WP.org without params 2", () => \{
			    api.get(\{
			      api: "https://test.frontity.org/wp-json/",
			      endpoint: "posts/12",
			    \});
			    expect(lastFetch()).toBe(
			      "https://test.frontity.org/wp-json/wp/v2/posts/12"
			    );
			  \});
			
			  test("get from WP.org with params", () => \{
			    api.get(\{
			      api: "https://test.frontity.org/wp-json/",
			      endpoint: "posts",
			      params: \{ _embed: true, include: "12,13,14" \},
			    \});
			    expect(lastFetch()).toBe(
			      "https://test.frontity.org/wp-json/wp/v2/posts?_embed=true&include=12,13,14"
			    );
			  \});
			
			  test("get from WP.org with empty params", () => \{
			    api.get(\{
			      api: "https://test.frontity.org/wp-json/",
			      endpoint: "posts",
			      params: \{\},
			    \});
			    expect(lastFetch()).toBe("https://test.frontity.org/wp-json/wp/v2/posts");
			  \});
			
			  test("get from WP.org with an array in params", () => \{
			    api.get(\{
			      api: "https://test.frontity.org/wp-json/",
			      endpoint: "posts",
			      params: \{
			        _embed: true,
			        type: ["post", "page"],
			      \},
			    \});
			    expect(lastFetch()).toBe(
			      "https://test.frontity.org/wp-json/wp/v2/posts?_embed=true&type[]=post&type[]=page"
			    );
			  \});
			
			  test("get from WP.org and a different namespace", () => \{
			    api.get(\{
			      api: "https://test.frontity.org/wp-json/",
			      endpoint: "/discovery/v1",
			      params: \{ link: "/the-beauties-of-gullfoss" \},
			    \});
			    expect(lastFetch()).toBe(
			      "https://test.frontity.org/wp-json/discovery/v1?link=/the-beauties-of-gullfoss"
			    );
			  \});
			
			  test("get from WP.com without params", () => \{
			    api.get(\{
			      api: "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org",
			      endpoint: "posts",
			      isWpCom: true,
			    \});
			    expect(lastFetch()).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org/posts"
			    );
			  \});
			
			  test("get from WP.com with params", () => \{
			    const endpoint = "posts";
			    const isWpCom = true;
			    const params = \{ _embed: true, include: "12,13,14" \};
			    api.get(\{
			      endpoint,
			      params,
			      api: "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org/",
			      isWpCom,
			    \});
			    expect(lastFetch()).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org/posts?_embed=true&include=12,13,14"
			    );
			  \});
			
			  test("get from WP.com with empty params", () => \{
			    api.get(\{
			      api: "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org",
			      endpoint: "posts",
			      isWpCom: true,
			      params: \{\},
			    \});
			    expect(lastFetch()).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org/posts"
			    );
			  \});
			
			  test("ignore params with 'undefined' value", () => \{
			    api.get(\{
			      api: "https://test.frontity.org/wp-json/",
			      endpoint: "posts",
			      params: \{ ignoreMe: undefined \},
			    \});
			    expect(lastFetch()).toBe("https://test.frontity.org/wp-json/wp/v2/posts");
			  \});
			
			  test("get from api specified with the init function", () => \{
			    api.init(\{
			      api: "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org",
			      isWpCom: true,
			    \});
			    api.get(\{
			      endpoint: "posts",
			    \});
			    expect(lastFetch()).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org/posts"
			    );
			    api.get(\{
			      endpoint: "posts",
			      params: \{ _embed: true, include: "12,13,14" \},
			    \});
			    expect(lastFetch()).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/test.frontity.org/posts?_embed=true&include=12,13,14"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\api.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(11)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\auth-header.test.ts', () => {
        const sourceCode = `
			import clone from "clone-deep";
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import * as frontity from "frontity";
			
			import wpSource from "../..";
			import \{ mockResponse \} from "../handlers/__tests__/mocks/helpers";
			import WpSource from "../../../types";
			import \{ Package \} from "frontity/types";
			
			const mockedFetch: jest.MockedFunction<typeof fetch> = jest.fn((_) =>
			  Promise.resolve(mockResponse(\{ id: 1 \}))
			);
			(frontity.fetch as typeof fetch) = mockedFetch;
			
			let store: InitializedStore<WpSource & Package>;
			
			beforeEach(() => \{
			  store = createStore<WpSource>(clone(wpSource()));
			  store.state.source.api = "https://test.frontity.org/wp-json";
			\});
			
			it("should add the Authorization header when fetching a post", async () => \{
			  store.actions.source.init();
			
			  // Get the entites, passing the auth information.
			  await store.libraries.source.api.get(\{
			    endpoint: "post",
			    auth: "Hello test",
			  \});
			
			  expect(mockedFetch.mock.calls).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        "https://test.frontity.org/wp-json/wp/v2/post",
			        Object \{
			          "headers": Object \{
			            "Authorization": "Hello test",
			          \},
			        \},
			      ],
			    ]
			  \`);
			\});
			
			it("should pass the value of FRONTITY_SOURCE_AUTH to state.source.auth", async () => \{
			  const authToken = "test-1";
			
			  // Add the token to the env variable
			  process.env.FRONTITY_SOURCE_AUTH = authToken;
			
			  // Initialize wp-source package
			  store.actions.source.init();
			
			  expect(store.state.source.auth).toBe(authToken);
			\});
			
			it("should pass the frontitySourceAuth option to state.source.auth", async () => \{
			  const authToken = "test-2";
			
			  store.state.frontity = \{ options: \{ sourceAuth: authToken \} \};
			
			  // Initialize wp-source package
			  store.actions.source.init();
			
			  expect(store.state.source.auth).toBe(authToken);
			\});
			
			it("should use the value from \`options\` if both the state.source.auth and FRONTITY_SOURCE_AUTH are set", async () => \{
			  // Add the token to the env variable
			  process.env.FRONTITY_SOURCE_AUTH = "This is not used";
			
			  store.state.frontity = \{
			    options: \{
			      sourceAuth: "This is used indeed",
			    \},
			  \};
			
			  // Initialize wp-source package
			  store.actions.source.init();
			
			  expect(store.state.source.auth).toBe("This is used indeed");
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\auth-header.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(4)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\get-match.tests.ts', () => {
        const sourceCode = `
			/* eslint-disable @typescript-eslint/no-empty-function */
			import \{ getMatch \} from "../get-match";
			
			describe("getMatch", () => \{
			  describe("pattern", () => \{
			    it("should match a normal pattern", () => \{
			      expect(
			        getMatch(\{ route: "/" \}, [
			          \{
			            pattern: "/",
			            name: "home",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ]).name
			      ).toBe("home");
			    \});
			
			    it("should respect priorities", () => \{
			      expect(
			        getMatch(\{ route: "/" \}, [
			          \{
			            pattern: "/",
			            name: "home",
			            func: () => \{\},
			            priority: 10,
			          \},
			          \{
			            pattern: "/",
			            name: "home-with-higher-priority",
			            func: () => \{\},
			            priority: 9,
			          \},
			        ]).name
			      ).toBe("home-with-higher-priority");
			    \});
			
			    it("should match complex patterns", () => \{
			      expect(
			        getMatch(\{ route: "/category/nature" \}, [
			          \{
			            pattern: "/",
			            name: "home",
			            func: () => \{\},
			            priority: 10,
			          \},
			          \{
			            pattern: "/category/:slug",
			            name: "category",
			            func: () => \{\},
			            priority: 20,
			          \},
			        ]).name
			      ).toBe("category");
			    \});
			
			    it("should return parameters", () => \{
			      expect(
			        getMatch(\{ route: "/some-post" \}, [
			          \{
			            pattern: "/:slug",
			            name: "post",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ]).params.slug
			      ).toBe("some-post");
			    \});
			
			    it("should return nested parameters", () => \{
			      expect(
			        getMatch(\{ route: "/some-category/some-post" \}, [
			          \{
			            pattern: "/(.*)?/:slug",
			            name: "post",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ]).params.slug
			      ).toBe("some-post");
			    \});
			
			    it("should return null if there's no match", () => \{
			      expect(
			        getMatch(\{ route: "/some-post" \}, [
			          \{
			            pattern: "/",
			            name: "home",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ])
			      ).toBe(null);
			    \});
			
			    it("should ignore queries when using pattern", () => \{
			      expect(
			        getMatch(\{ route: "/some-post/" \}, [
			          \{
			            pattern: "/(.*)?/:slug",
			            name: "post",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ]).name
			      ).toBe("post");
			    \});
			
			    it("should match the correct handler and not be confused by the query", () => \{
			      expect(
			        getMatch(\{ route: "/some-type/some-post" \}, [
			          \{
			            pattern: "/some-type/:postSlug/:attachmentSlug",
			            name: "some-type attachment",
			            func: () => \{\},
			            priority: 10,
			          \},
			          \{
			            pattern: "/some-type/:slug",
			            name: "some-type",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ]).name
			      ).toBe("some-type");
			    \});
			  \});
			
			  describe("regexp", () => \{
			    it("should work with regexps", () => \{
			      expect(
			        getMatch(\{ link: "/some-post" \}, [
			          \{
			            pattern: "RegExp:/some-post",
			            name: "post",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ]).name
			      ).toBe("post");
			    \});
			
			    it("should work with queries", () => \{
			      expect(
			        getMatch(\{ link: "/some-post/?some-query=some-value" \}, [
			          \{
			            pattern: "RegExp:(\\\\?|&)some-query=",
			            name: "post",
			            func: () => \{\},
			            priority: 10,
			          \},
			        ]).name
			      ).toBe("post");
			    \});
			
			    it("should return named capture groups", () => \{
			      expect(
			        getMatch(
			          \{ link: "/some-post/?some-query=some-value&other-query=other-value" \},
			          [
			            \{
			              pattern: "RegExp:(\\\\?|&)some-query=(?<someQuery>[^&\$]+)",
			              name: "post",
			              func: () => \{\},
			              priority: 10,
			            \},
			          ]
			        ).params.someQuery
			      ).toBe("some-value");
			    \});
			  \});
			
			  describe("combined", () => \{
			    it("should work with queries", () => \{
			      expect(
			        getMatch(
			          \{ link: "/some-post/?some-query=some-value", route: "/some-post/" \},
			          [
			            \{
			              pattern: "RegExp:(\\\\?|&)some-query=",
			              name: "post by regexp",
			              func: () => \{\},
			              priority: 10,
			            \},
			            \{
			              pattern: "/some-post/",
			              name: "post by path",
			              func: () => \{\},
			              priority: 10,
			            \},
			          ]
			        ).name
			      ).toBe("post by regexp");
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\get-match.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\handlers.com.test.ts', () => {
        const sourceCode = `
			import \{ wpCom \} from "../patterns";
			import \{ getMatch \} from "../get-match";
			import * as handlers from "../handlers";
			
			// Add handlers
			const wpComHandlers = [...wpCom];
			
			describe("getMatch (wp.com patterns)", () => \{
			  // pattern: "/",
			  // handler: postArchive
			  test("post archive", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/" \}, wpComHandlers);
			    expect(func).toBe(handlers.postArchive);
			    expect(params).toMatchObject(\{\});
			  \});
			
			  // pattern: "/category/:slug",
			  // handler: category
			  test("category", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/category/nature" \},
			      wpComHandlers
			    );
			    expect(func).toBe(handlers.category);
			    expect(params).toMatchObject(\{ slug: "nature" \});
			  \});
			
			  // pattern: "/category/(.*)/:slug", // subcategories
			  // handler: category
			  test("subcategory", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/category/nature/subcat/subsubcat" \},
			      wpComHandlers
			    );
			    expect(func).toBe(handlers.category);
			    expect(params).toMatchObject(\{ slug: "subsubcat" \});
			  \});
			
			  // pattern: "/tag/:slug",
			  // handler: tag
			  test("tag", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/tag/japan" \}, wpComHandlers);
			    expect(func).toBe(handlers.tag);
			    expect(params).toMatchObject(\{ slug: "japan" \});
			  \});
			
			  // pattern: "/author/:slug",
			  // handler: author
			  test("author", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/author/luisherranz" \},
			      wpComHandlers
			    );
			    expect(func).toBe(handlers.author);
			    expect(params).toMatchObject(\{ slug: "luisherranz" \});
			  \});
			
			  // pattern: "/:year(\\\\d+)/:month(\\\\d+)?/:day(\\\\d+)?",
			  // handler: date
			  test("date (year)", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016" \}, wpComHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016" \});
			  \});
			
			  test("date (year) with slash", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016/" \}, wpComHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016" \});
			  \});
			
			  test("date (year/month)", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016/10" \}, wpComHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016", month: "10" \});
			  \});
			
			  test("date (year/month/day)", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016/10/25" \}, wpComHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016", month: "10", day: "25" \});
			  \});
			
			  // pattern: "/:year(\\\\d+)/:month(\\\\d+)/:day(\\\\d+)/:slug", // day & name
			  // handler: post
			  test("post (day & name)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/2016/10/25/the-beauties-of-gullfoss" \},
			      wpComHandlers
			    );
			    expect(func).toBe(handlers.post);
			    expect(params).toMatchObject(\{ slug: "the-beauties-of-gullfoss" \});
			  \});
			
			  // pattern: ":slug", // page name
			  // handler: page
			  test("post name / page / attachment (without parent)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/post-or-page-or-attachment" \},
			      wpComHandlers
			    );
			    expect(func).toBe(handlers.page);
			    expect(params).toMatchObject(\{ slug: "post-or-page-or-attachment" \});
			  \});
			
			  // pattern: "/(.*)/:slug", // subpages
			  // handler: page
			  test("subpage / attachment", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/about-us/location" \},
			      wpComHandlers
			    );
			    expect(func).toBe(handlers.page);
			    expect(params).toMatchObject(\{ slug: "location" \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\handlers.com.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(12)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\handlers.custom.tests.ts', () => {
        const sourceCode = `
			/* eslint-disable jest/expect-expect */
			import \{ getMatch \} from "../get-match";
			
			const patterns = \{
			  postArchive: "/",
			  category: "/category/:slug",
			  tag: "/tag/:slug",
			  author: "/author/:name",
			  date: "/:year(\\\\d+)/:month(\\\\d+)?/:day(\\\\d+)?",
			  postOrPage: "/:slug",
			  attachment: "/:year(\\\\d+)/:postSlug/:attachmentSlug",
			  customList: "custom-list",
			  carousel: "carousel-:postId(\\\\d+)",
			  anyName: ":name",
			\};
			
			// Mock handlers from patterns
			const handlers = Object.keys(patterns).map((name) => (\{
			  name: name,
			  priority: 10,
			  pattern: patterns[name],
			  func: jest.fn(() => Promise.resolve()),
			\}));
			
			// Test 'handler' is executed with the correct params
			const testMatch = (name, route, params): void => \{
			  const match = getMatch(\{ route \}, handlers);
			  expect(match.func).toEqual(handlers.find((p) => p.name === name).func);
			  expect(match.params).toEqual(params);
			\};
			
			describe("getMatch", () => \{
			  test("match different routes", async () => \{
			    testMatch("postArchive", "/", \{\});
			    testMatch("category", "/category/nature", \{ slug: "nature" \});
			    testMatch("tag", "/tag/japan", \{ slug: "japan" \});
			    testMatch("author", "/author/alan", \{ name: "alan" \});
			    testMatch("date", "/2019", \{ year: "2019" \});
			    testMatch("date", "/2019/04", \{ year: "2019", month: "04" \});
			    testMatch("date", "/2019/04/20", \{
			      year: "2019",
			      month: "04",
			      day: "20",
			    \});
			    testMatch("postOrPage", "/the-beauties-of-gullfoss", \{
			      slug: "the-beauties-of-gullfoss",
			    \});
			    testMatch("postOrPage", "/about-us", \{ slug: "about-us" \});
			    testMatch("attachment", "/2019/the-beauties-of-gullfoss/waterfall", \{
			      year: "2019",
			      postSlug: "the-beauties-of-gullfoss",
			      attachmentSlug: "waterfall",
			    \});
			    testMatch("customList", "custom-list", \{\});
			    testMatch("carousel", "carousel-60", \{ postId: "60" \});
			    testMatch("anyName", "whatever", \{ name: "whatever" \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\handlers.custom.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\handlers.org.test.ts', () => {
        const sourceCode = `
			import \{ wpOrg \} from "../patterns";
			import \{ getMatch \} from "../get-match";
			import * as handlers from "../handlers";
			
			// Add handlers
			const wpOrgHandlers = [...wpOrg];
			
			describe("getMatch (wp.org patterns)", () => \{
			  // pattern: "/",
			  // handler: postArchive
			  test("post archive", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/" \}, wpOrgHandlers);
			    expect(func).toBe(handlers.postArchive);
			    expect(params).toMatchObject(\{\});
			  \});
			
			  // pattern: "/category/:slug",
			  // handler: category
			  test("category", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/category/nature" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.category);
			    expect(params).toMatchObject(\{ slug: "nature" \});
			  \});
			
			  // pattern: "/category/(.*)/:slug", // subcategories
			  // handler: category
			  test("subcategory", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/category/nature/subcat/subsubcat" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.category);
			    expect(params).toMatchObject(\{ slug: "subsubcat" \});
			  \});
			
			  // pattern: "/tag/:slug",
			  // handler: tag
			  test("tag", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/tag/japan" \}, wpOrgHandlers);
			    expect(func).toBe(handlers.tag);
			    expect(params).toMatchObject(\{ slug: "japan" \});
			  \});
			
			  // pattern: "/author/:slug",
			  // handler: author
			  test("author", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/author/luisherranz" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.author);
			    expect(params).toMatchObject(\{ slug: "luisherranz" \});
			  \});
			
			  // pattern: "/:year(\\\\d+)/:month(\\\\d+)?/:day(\\\\d+)?",
			  // handler: date
			  test("date (year)", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016" \}, wpOrgHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016" \});
			  \});
			
			  test("date (year) with slash", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016/" \}, wpOrgHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016" \});
			  \});
			
			  test("date (year/month)", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016/10" \}, wpOrgHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016", month: "10" \});
			  \});
			
			  test("date (year/month/day)", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/2016/10/25" \}, wpOrgHandlers);
			    expect(func).toBe(handlers.date);
			    expect(params).toMatchObject(\{ year: "2016", month: "10", day: "25" \});
			  \});
			
			  // pattern: "/:year(\\\\d+)/:month(\\\\d+)/:day(\\\\d+)/:slug", // day & name
			  // handler: post
			  test("post (day & name)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/2016/10/25/the-beauties-of-gullfoss" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.postType);
			    expect(params).toMatchObject(\{ slug: "the-beauties-of-gullfoss" \});
			  \});
			
			  // pattern: "/:year(\\\\d+)/:month(\\\\d+)/:slug", // month & name
			  // handler: post
			  test("post (month & name)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/2016/10/the-beauties-of-gullfoss" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.postType);
			    expect(params).toMatchObject(\{ slug: "the-beauties-of-gullfoss" \});
			  \});
			
			  // pattern: "/archives/:id", // numeric
			  // handler: post
			  test("post (numeric)", () => \{
			    const \{ func, params \} = getMatch(\{ route: "/archives/60" \}, wpOrgHandlers);
			    expect(func).toBe(handlers.post);
			    expect(params).toMatchObject(\{ id: "60" \});
			  \});
			
			  // pattern: ":slug", // post name or page name
			  // handler: postType
			  test("post name / page / attachment (without parent)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/post-or-page-or-attachment" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.postType);
			    expect(params).toMatchObject(\{ slug: "post-or-page-or-attachment" \});
			  \});
			
			  // pattern: "/(.*)/:slug", // subpages
			  // handler: page
			  test("subpage / attachment", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/about-us/location" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.postType);
			    expect(params).toMatchObject(\{ slug: "location" \});
			  \});
			
			  // pattern: "/:year(\\\\d+)/:month(\\\\d+)/:day(\\\\d+)/:postSlug/:slug", // day & name
			  // handler: attachment
			  test("attachment (day & name)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/2016/10/25/the-beauties-of-gullfoss/attachment-1" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.attachment);
			    expect(params).toMatchObject(\{ slug: "attachment-1" \});
			  \});
			
			  // pattern: "/:year(\\\\d+)/:month(\\\\d+)/:postSlug/:slug", // month & name
			  // handler: attachment
			  test("attachment (month & name)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/2016/10/the-beauties-of-gullfoss/attachment-2" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.attachment);
			    expect(params).toMatchObject(\{ slug: "attachment-2" \});
			  \});
			
			  // pattern: "/archives/:postId/:slug", // numeric
			  // handler: attachment
			  test("attachment (numeric)", () => \{
			    const \{ func, params \} = getMatch(
			      \{ route: "/archives/60/attachment-3" \},
			      wpOrgHandlers
			    );
			    expect(func).toBe(handlers.attachment);
			    expect(params).toMatchObject(\{ slug: "attachment-3" \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\handlers.org.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(17)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\populate.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import \{ Response as NodeResponse \} from "node-fetch";
			import clone from "clone-deep";
			import wpSource from "../../";
			import \{ Packages \} from "../../../types";
			import populate from "../populate";
			import posts from "../handlers/__tests__/mocks/post-archive/posts.json";
			import postsSubdir from "../handlers/__tests__/mocks/post-archive/posts-subdir.json";
			import cpts from "../handlers/__tests__/mocks/cpt-archive/cpts.json";
			
			const initStore = (): InitializedStore<Packages> => \{
			  const config: Packages = clone(wpSource());
			  config.state.source.url = "https://test.frontity.org";
			  config.state.frontity = \{\};
			  return createStore(config);
			\};
			
			// Use Response from "node-fetch" to mock response objects,
			// but with "lib.dom.d.ts" Response type.
			const mockResponse = (body): Response =>
			  (new NodeResponse(JSON.stringify(body)) as unknown) as Response;
			
			describe("populate", () => \{
			  test("adds posts and embedded into state", async () => \{
			    const \{ state \} = initStore();
			    const response = mockResponse(posts);
			    const result = await populate(\{ state, response \});
			
			    expect(result).toMatchSnapshot();
			    expect(state.source).toMatchSnapshot();
			  \});
			
			  test("does not overwrite added entities", async () => \{
			    const \{ state \} = initStore();
			
			    // Add Category 1
			    await populate(\{
			      state,
			      response: mockResponse([
			        \{
			          id: 1,
			          count: 5,
			          link: "https://test.frontity.org/category/cat-1/",
			          slug: "cat-1",
			          taxonomy: "category",
			          description: "This is the Category 1",
			          parent: 0,
			        \},
			      ]),
			    \});
			
			    // Try to overwrite Category 1
			    await populate(\{
			      state,
			      response: mockResponse(\{
			        id: 1,
			        link: "https://test.frontity.org/category/cat-1/",
			        slug: "cat-1",
			        taxonomy: "category",
			      \}),
			    \});
			
			    expect(state.source.category[1].description).toBe("This is the Category 1");
			    expect(state.source.category[1].count).toBe(5);
			  \});
			
			  test("overwrite entities if \`force\` is true", async () => \{
			    const \{ state \} = initStore();
			
			    // Add Category 1 with missing properties
			    await populate(\{
			      state,
			      response: mockResponse([
			        \{
			          id: 1,
			          link: "https://test.frontity.org/category/cat-1/",
			          slug: "cat-1",
			          taxonomy: "category",
			          count: 1,
			        \},
			      ]),
			    \});
			
			    // Overwrite Category 1 using \`force\` = true
			    await populate(\{
			      state,
			      response: mockResponse(\{
			        id: 1,
			        count: 5,
			        link: "https://test.frontity.org/category/cat-1/",
			        slug: "cat-1",
			        taxonomy: "category",
			        description: "This is the Category 1",
			      \}),
			      force: true,
			    \});
			
			    expect(state.source.category[1].description).toBe("This is the Category 1");
			    expect(state.source.category[1].count).toBe(5);
			  \});
			
			  test("removes WP API path from links", async () => \{
			    const \{ state \} = initStore();
			    state.source.url = "https://test.frontity.org/subdirectory/";
			
			    const response = mockResponse(postsSubdir);
			    const result = await populate(\{ state, response \});
			
			    expect(result).toMatchSnapshot();
			    expect(state.source).toMatchSnapshot();
			  \});
			
			  test("transforms links if subdirectory is specified", async () => \{
			    const \{ state \} = initStore();
			    state.source.url = "https://test.frontity.org/subdirectory/";
			
			    const response = mockResponse(postsSubdir);
			    const subdirectory = "/blog/";
			    const result = await populate(\{ state, response, subdirectory \});
			
			    expect(result).toMatchSnapshot();
			    expect(state.source).toMatchSnapshot();
			  \});
			
			  test("transforms links if subdirectory is specified in \`state.frontity.url\`", async () => \{
			    const \{ state \} = initStore();
			    state.frontity.url = "https://final-domain.com/blog/";
			    state.source.url = "https://test.frontity.org/subdirectory/";
			
			    const response = mockResponse(postsSubdir);
			    const result = await populate(\{ state, response \});
			
			    expect(result).toMatchSnapshot();
			    expect(state.source).toMatchSnapshot();
			  \});
			
			  test("add new custom post types & taxonomies to the state", async () => \{
			    const \{ state \} = initStore();
			    const response = mockResponse(cpts);
			    const result = await populate(\{ state, response \});
			
			    expect(result).toMatchSnapshot();
			    expect(state.source).toMatchSnapshot();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\populate.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(7)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\redirections.tests.ts', () => {
        const sourceCode = `
			import \{ getMatch \} from "../get-match";
			
			// Some redirections
			const redirections: \{
			  name: string;
			  priority: number;
			  pattern: string;
			  func: (params: Record<string, string>) => string;
			\}[] = [
			  \{
			    name: "",
			    priority: 10,
			    pattern: "/",
			    func: () => "/about-us/",
			  \},
			  \{
			    name: "",
			    priority: 10,
			    pattern: "/posts/",
			    func: () => "/",
			  \},
			  \{
			    name: "",
			    priority: 10,
			    pattern: "/wp-cat/:subpath+",
			    func: (\{ subpath \}) => \`/category/\$\{subpath\}/\`,
			  \},
			  \{
			    name: "",
			    priority: 10,
			    pattern: "/category/(.*)",
			    func: () => "",
			  \},
			  \{
			    name: "",
			    priority: 10,
			    pattern: "/blog/:subpath*/",
			    func: (\{ subpath = "" \}) => \`/\$\{subpath\}\$\{subpath ? "/" : ""\}\`,
			  \},
			];
			
			const redirect = (route, redirections) => \{
			  const match = getMatch(\{ route \}, redirections);
			  if (!match) return route;
			  return match.func(match.params);
			\};
			
			// Add redirects
			describe("getMatch", () => \{
			  test("redirects different routes", async () => \{
			    expect(redirect("/", redirections)).toBe("/about-us/");
			    expect(redirect("/about-us/", redirections)).toBe("/about-us/");
			    expect(redirect("/posts/", redirections)).toBe("/");
			    expect(redirect("/wp-cat/nature/", redirections)).toBe("/category/nature/");
			    expect(redirect("/wp-cat/nature/forests", redirections)).toBe(
			      "/category/nature/forests/"
			    );
			    expect(redirect("/category/nature", redirections)).toBe("");
			    expect(redirect("/blog/", redirections)).toBe("/");
			    expect(redirect("/blog/some-post/", redirections)).toBe("/some-post/");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\redirections.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\response-utils.tests.ts', () => {
        const sourceCode = `
			import \{ Response as NodeResponse \} from "node-fetch";
			import \{ getTotal \} from "../response-utils";
			
			describe("response utils - getTotal", () => \{
			  test("retrives result from header", () => \{
			    const response = (new NodeResponse() as any) as Response;
			    response.headers.get = jest.fn(() => "1");
			    expect(getTotal(response, 0)).toBe(1);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\response-utils.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(1)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\route-utils.test.ts', () => {
        const sourceCode = `
			import \{ parse, stringify, normalize \} from "../route-utils";
			
			describe("route utils - parse", () => \{
			  test("from path", () => \{
			    expect(parse("/some/path/")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 1,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			
			  test("from path (contains 'page')", () => \{
			    expect(parse("/some-page/page/2")).toEqual(\{
			      path: "/some-page/",
			      route: "/some-page/",
			      page: 2,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			
			  test("from path (fixes path)", () => \{
			    expect(parse("/some/path")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 1,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			
			  test("from path and page", () => \{
			    expect(parse("/some/path/page/2/")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 2,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			
			  test("from path and query", () => \{
			    expect(parse("/some/path/?k1=v1&k2=v2")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 1,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			      queryString: "?k1=v1&k2=v2",
			    \});
			  \});
			
			  test("from path and reversed query", () => \{
			    expect(parse("/some/path/?k2=v2&k1=v1")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 1,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			      queryString: "?k1=v1&k2=v2",
			    \});
			  \});
			
			  test("from path, page and query", () => \{
			    expect(parse("/some/path/page/2?k1=v1&k2=v2")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			      queryString: "?k1=v1&k2=v2",
			    \});
			  \});
			
			  test("from path, page and reversed query", () => \{
			    expect(parse("/some/path/page/2?k2=v2&k1=v1")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			      queryString: "?k1=v1&k2=v2",
			    \});
			  \});
			
			  test("from root path", () => \{
			    expect(parse("/")).toEqual(\{
			      path: "/",
			      route: "/",
			      page: 1,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			
			  test("from root path and page", () => \{
			    expect(parse("/page/2/")).toEqual(\{
			      path: "/",
			      route: "/",
			      page: 2,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			
			  test("from root path, page and query", () => \{
			    expect(parse("/page/2?k1=v1&k2=v2")).toEqual(\{
			      path: "/",
			      route: "/",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			      queryString: "?k1=v1&k2=v2",
			    \});
			  \});
			
			  test("from root path, page and reversed query", () => \{
			    expect(parse("/page/2?k2=v2&k1=v1")).toEqual(\{
			      path: "/",
			      route: "/",
			      page: 2,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			      queryString: "?k1=v1&k2=v2",
			    \});
			  \});
			
			  test("from full URL", () => \{
			    expect(parse("https://test.frontity.org/some/path/?k1=v1&k2=v2")).toEqual(\{
			      path: "/some/path/",
			      route: "/some/path/",
			      page: 1,
			      query: \{
			        k1: "v1",
			        k2: "v2",
			      \},
			      queryString: "?k1=v1&k2=v2",
			    \});
			  \});
			
			  test("from name", () => \{
			    expect(parse("custom-list")).toEqual(\{
			      path: "custom-list/",
			      route: "custom-list/",
			      page: 1,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			
			  test("from name (page)", () => \{
			    expect(parse("custom-list/page/2")).toEqual(\{
			      path: "custom-list/",
			      route: "custom-list/",
			      page: 2,
			      query: \{\},
			      queryString: "",
			    \});
			  \});
			\});
			
			describe("route utils - stringify", () => \{
			  describe("using only the \`path\` parameter", () => \{
			    test("from params (fixes path)", () => \{
			      expect(stringify(\{ path: "/some/path" \})).toBe("/some/path/");
			    \});
			
			    test("from params (path is a name)", () => \{
			      expect(stringify(\{ path: "custom-list" \})).toBe("custom-list/");
			    \});
			
			    test("from params (path, page)", () => \{
			      expect(stringify(\{ path: "/some/path/", page: 2 \})).toBe(
			        "/some/path/page/2/"
			      );
			    \});
			
			    test("from params (path, page, query)", () => \{
			      expect(
			        stringify(\{
			          path: "/some/path",
			          page: 2,
			          query: \{
			            k1: "v1",
			            k2: "v2",
			          \},
			        \})
			      ).toBe("/some/path/page/2/?k1=v1&k2=v2");
			    \});
			
			    test("from params (root, page, query)", () => \{
			      expect(
			        stringify(\{
			          path: "/",
			          page: 2,
			          query: \{
			            k1: "v1",
			            k2: "v2",
			          \},
			        \})
			      ).toBe("/page/2/?k1=v1&k2=v2");
			    \});
			  \});
			
			  describe("Using only the \`route\` parameter", () => \{
			    test("from params (fixes path)", () => \{
			      expect(stringify(\{ route: "/some/path" \})).toBe("/some/path/");
			    \});
			
			    test("from params (path is a name)", () => \{
			      expect(stringify(\{ route: "custom-list" \})).toBe("custom-list/");
			    \});
			
			    test("from params (path, page)", () => \{
			      expect(stringify(\{ route: "/some/path/", page: 2 \})).toBe(
			        "/some/path/page/2/"
			      );
			    \});
			
			    test("from params (path, page, query)", () => \{
			      expect(
			        stringify(\{
			          route: "/some/path",
			          page: 2,
			          query: \{
			            k1: "v1",
			            k2: "v2",
			          \},
			        \})
			      ).toBe("/some/path/page/2/?k1=v1&k2=v2");
			    \});
			
			    test("from params (root, page, query)", () => \{
			      expect(
			        stringify(\{
			          route: "/",
			          page: 2,
			          query: \{
			            k1: "v1",
			            k2: "v2",
			          \},
			        \})
			      ).toBe("/page/2/?k1=v1&k2=v2");
			    \});
			  \});
			\});
			
			describe("route utils - normalize", () => \{
			  test("from path", () => \{
			    expect(normalize("/some/path/")).toBe("/some/path/");
			  \});
			
			  test("from path (contains 'page')", () => \{
			    expect(normalize("/some-page/")).toBe("/some-page/");
			  \});
			
			  test("from path (fixes path)", () => \{
			    expect(normalize("/some/path")).toBe("/some/path/");
			  \});
			
			  test("from path (upper case)", () => \{
			    expect(normalize("/SOME/PATH/")).toBe("/some/path/");
			  \});
			
			  test("from path and page", () => \{
			    expect(normalize("/some/path/page/2")).toBe("/some/path/page/2/");
			  \});
			
			  test("from path and query", () => \{
			    expect(normalize("/some/path?k1=v1&k2=v2")).toBe("/some/path/?k1=v1&k2=v2");
			  \});
			
			  test("from path and query (upper case)", () => \{
			    expect(normalize("/some/PATH?K1=V1&k2=v2")).toBe("/some/path/?K1=V1&k2=v2");
			  \});
			
			  test("from path, page and query", () => \{
			    expect(normalize("/some/path/page/2?k1=v1&k2=v2")).toBe(
			      "/some/path/page/2/?k1=v1&k2=v2"
			    );
			  \});
			
			  test("from path, query and hash", () => \{
			    expect(normalize("/some/path/?id=1&search=value#element")).toBe(
			      "/some/path/?id=1&search=value#element"
			    );
			  \});
			
			  test("from root path", () => \{
			    expect(normalize("/")).toEqual("/");
			  \});
			
			  test("from root path and page", () => \{
			    expect(normalize("/page/2")).toEqual("/page/2/");
			  \});
			
			  test("from root path, page and query", () => \{
			    expect(normalize("/page/2?k1=v1&k2=v2")).toEqual("/page/2/?k1=v1&k2=v2");
			  \});
			
			  test("from full URL", () => \{
			    expect(
			      normalize("https://test.frontity.org/some/path/page/2?k1=v1&k2=v2")
			    ).toBe("/some/path/page/2/?k1=v1&k2=v2");
			  \});
			
			  test("from root URL", () => \{
			    expect(normalize("https://test.frontity.org?k1=v1&k2=v2")).toBe(
			      "/?k1=v1&k2=v2"
			    );
			  \});
			
			  test("from name", () => \{
			    expect(normalize("custom-list")).toBe("custom-list/");
			  \});
			
			  test("from name (page)", () => \{
			    expect(normalize("custom-list/page/2/")).toBe("custom-list/page/2/");
			  \});
			
			  test("final \`/amp\` path is not removed by default", () => \{
			    expect(normalize("/amp")).toBe("/amp/");
			    expect(normalize("/category/amp/")).toBe("/category/amp/");
			    expect(normalize("/tag/amp/")).toBe("/tag/amp/");
			    expect(normalize("/taxonomy/amp/")).toBe("/taxonomy/amp/");
			    expect(normalize("/posts/amp/")).toBe("/posts/amp/");
			    expect(normalize("/parent/some-page/amp/")).toBe("/parent/some-page/amp/");
			    expect(normalize("/amp/?a=1&b=1#some-hash")).toBe(
			      "/amp/?a=1&b=1#some-hash"
			    );
			    expect(normalize("/amp/page/3/?a=1&b=1#some-hash")).toBe(
			      "/amp/page/3/?a=1&b=1#some-hash"
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\route-utils.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(42)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\transform-link.test.ts', () => {
        const sourceCode = `
			import \{ createStore \} from "frontity";
			import \{ Frontity, MergePackages \} from "frontity/types";
			import clone from "clone-deep";
			import merge from "deepmerge";
			import \{ transformLink \} from "../transform-link";
			import wpSource from "../../";
			import WpSource from "../../../types";
			
			type Packages = MergePackages<Frontity, WpSource>;
			
			describe("transformLink (w/o subdirectory)", () => \{
			  const initStore = () => \{
			    const config = clone(merge(wpSource(), \{ state: \{ frontity: \{\} \} \}));
			    return createStore<Packages>(config);
			  \};
			
			  it("should work for Free WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.url and state.wpSource.isWpCom", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://wp-domain.com";
			    state.wpSource.isWpCom = true;
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://wp-domain.com/subdir";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/subdir/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/subdir/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/");
			  \});
			
			  it("should not add a trailing slash for links with hash part", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/#element-id" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/some-link/#element-id");
			  \});
			\});
			
			describe("transformLink (w/ subdirectory)", () => \{
			  const initStore = () => \{
			    const config = clone(merge(wpSource(), \{ state: \{ frontity: \{\} \} \}));
			    return createStore<Packages>(config);
			  \};
			
			  const subdirectory = "subdir";
			
			  it("should work for Free WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.url and state.wpSource.isWpCom", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://wp-domain.com";
			    state.wpSource.isWpCom = true;
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.url = "https://wp-domain.com/subdir";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/subdir/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/wp-subdir/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/wp-subdir/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.api = "https://wp-domain.com/wp-subdir/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/wp-subdir/some-link/" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should not add a trailing slash for links with hash part", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/#element-id" \};
			    transformLink(\{ entity, state, subdirectory \});
			
			    expect(entity.link).toBe("/subdir/some-link/#element-id");
			  \});
			\});
			
			describe("transformLink (state.source.subdirectory)", () => \{
			  const initStore = () => \{
			    const config = clone(merge(wpSource(), \{ state: \{ frontity: \{\} \} \}));
			    return createStore<Packages>(config);
			  \};
			
			  it("should work for Free WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.source.url = "https://sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.url and state.wpSource.isWpCom", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.source.url = "https://wp-domain.com";
			    state.wpSource.isWpCom = true;
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.source.url = "https://wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.source.url = "https://wp-domain.com/subdir";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.wpSource.api = "https://wp-domain.com/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.subdirectory = "/subdir";
			    state.wpSource.api = "https://wp-domain.com/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.subdirectory = "/subdir";
			    state.wpSource.api = "https://wp-domain.com/wp-subdir/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/wp-subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.subdirectory = "/subdir";
			    state.wpSource.api = "https://wp-domain.com/wp-subdir/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/wp-subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should not add a trailing slash for links with hash part", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com";
			    state.source.subdirectory = "/subdir";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/#element-id" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/#element-id");
			  \});
			\});
			
			describe("transformLink (state.frontity.url w/ subdirectory)", () => \{
			  const initStore = () => \{
			    const config = clone(merge(wpSource(), \{ state: \{ frontity: \{\} \} \}));
			    return createStore<Packages>(config);
			  \};
			
			  it("should work for Free WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.url = "https://sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Free WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.url and state.wpSource.isWpCom", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.url = "https://wp-domain.com";
			    state.wpSource.isWpCom = true;
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for Personal and Premium WP com - configured by state.source.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.url = "https://wp-domain.com";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.source.url (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.url = "https://wp-domain.com/subdir";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.wpSource.api = "https://wp-domain.com/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.wpSource.api = "https://wp-domain.com/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.wpSource.api = "https://wp-domain.com/wp-subdir/wp-json/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/wp-subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should work for WP org and Business WP com - configured by state.wpSource.api and custom prefix (w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.wpSource.api = "https://wp-domain.com/wp-subdir/api/";
			    state.wpSource.prefix = "/api";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/wp-subdir/some-link/" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/");
			  \});
			
			  it("should not add a trailing slash for links with hash part", () => \{
			    const \{ state \} = initStore();
			
			    // Define the options set by the user.
			    state.frontity.url = "https://final-domain.com/subdir";
			    state.source.url = "https://wp-domain.com/";
			
			    // Transform the link of an entity mock.
			    const entity = \{ link: "/some-link/#element-id" \};
			    transformLink(\{ entity, state \});
			
			    expect(entity.link).toBe("/subdir/some-link/#element-id");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\libraries\\__tests__\\transform-link.test.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(52)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\__tests__\\3xx-redirections.tests.ts', () => {
        const sourceCode = `
			/* eslint-disable @typescript-eslint/no-namespace */
			import * as frontity from "frontity";
			import clone from "clone-deep";
			import \{ InitializedStore, createStore \} from "@frontity/connect";
			import \{ Pattern, Handler, Packages \} from "../../types";
			import wpSource from "..";
			import \{ ServerError \} from "@frontity/source";
			import \{ RedirectionData \} from "@frontity/source/types/data";
			import \{ Headers \} from "node-fetch";
			
			let handler: jest.Mocked<Pattern<Handler>>;
			let store: InitializedStore<Packages>;
			let mockedFetch: jest.MockedFunction<typeof fetch>;
			
			declare global \{
			  namespace jest \{
			    interface Matchers<R> \{
			      toHaveBeenCalledBefore(func: any): R;
			    \}
			  \}
			\}
			
			/**
			 * Add a \`.toHaveBeenCalledBefore()\` matcher to jest to make the tests more
			 * clear.
			 */
			expect.extend(\{
			  toHaveBeenCalledBefore(first, second) \{
			    if (
			      first.mock.invocationCallOrder[0] < second.mock.invocationCallOrder[0]
			    ) \{
			      return \{
			        message: () => \`expected \$\{first\} to have been called before \$\{second\}\`,
			        pass: true,
			      \};
			    \} else \{
			      return \{
			        message: () => \`expected \$\{first\} to have been called before \$\{second\}\`,
			        pass: false,
			      \};
			    \}
			  \},
			\});
			
			const setEmbeddedModeTrue = (store) => \{
			  // Ensure that all the namespaces are available first
			  store.state.frontity.options = store.state.frontity.options || \{\};
			  store.state.frontity.options.embedded = "true";
			\};
			
			const serverFetchParams = [
			  "https://wp.domain.com/some-post/",
			  \{
			    method: "HEAD",
			    redirect: "manual",
			  \},
			];
			const serverResponse = \{
			  status: 301,
			  headers: new Headers(\{
			    location: "https://wp.domain.com/redirected-url",
			  \}),
			\};
			const clientFetchParams = [
			  "https://wp.domain.com/some-post/",
			  \{
			    method: "HEAD",
			  \},
			];
			const clientResponse = \{
			  url: "https://wp.domain.com/redirected-url",
			  redirected: true,
			  status: 200,
			\};
			
			describe.each\`
			  platform    | fetchRedirectionParams | response
			  \$\{"server"\} | \$\{serverFetchParams\}   | \$\{serverResponse\}
			  \$\{"client"\} | \$\{clientFetchParams\}   | \$\{clientResponse\}
			\`("Redirection tests", (\{ platform, fetchRedirectionParams, response \}) => \{
			  beforeEach(() => \{
			    mockedFetch = jest.fn((_) =>
			      Promise.resolve((response as unknown) as Response)
			    );
			    (frontity.fetch as typeof fetch) = mockedFetch;
			
			    // Initialize the store.
			    store = createStore<Packages>(clone(wpSource()));
			    store.state.source.url = "https://wp.domain.com";
			    store.state.frontity = \{
			      platform,
			      url: "https://www.domain.com/",
			    \};
			
			    handler = \{
			      name: "always",
			      priority: 10,
			      pattern: "/(.*)",
			      func: jest.fn(async (\{ link, state \}) => \{
			        await Promise.resolve();
			        Object.assign(state.source.data[link], \{
			          type: "example",
			          id: 1,
			          isPostType: true,
			        \});
			      \}),
			    \};
			
			    store.libraries.source.handlers.push(handler);
			  \});
			
			  describe("redirections: all", () => \{
			    it(\`\$\{platform\}: Should handle a redirect with 'all'\`, async () => \{
			      store.state.source.redirections = "all";
			
			      // On embedded mode, on the client side, there should not be
			      // any difference in handling the redirections.
			      if (platform === "client") \{
			        setEmbeddedModeTrue(store);
			      \}
			
			      await store.actions.source.fetch("/some-post/");
			
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			
			      expect(handler.func).not.toHaveBeenCalled();
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    // On the server, the embedded mode should NOT handle the redirections
			    // to avoid the infinite loading loop.
			    // On embedded mode redirections are handled by the host which embeds frontity.
			    // More specifically Wordpress.
			    if (platform === "server") \{
			      it(\`\$\{platform\}: Should not handle a redirections with 'all' for embedded mode\`, async () => \{
			        store.state.source.redirections = "all";
			
			        setEmbeddedModeTrue(store);
			
			        await store.actions.source.fetch("/some-post/");
			
			        expect(mockedFetch).toHaveBeenCalledTimes(0);
			        expect(handler.func).toHaveBeenCalled();
			
			        expect(store.state.source.data).toMatchInlineSnapshot(\`
			                Object \{
			                  "/some-post/": Object \{
			                    "id": 1,
			                    "isFetching": false,
			                    "isPostType": true,
			                    "isReady": true,
			                    "link": "/some-post/",
			                    "page": 1,
			                    "query": Object \{\},
			                    "route": "/some-post/",
			                    "type": "example",
			                  \},
			                \}
			            \`);
			      \});
			    \}
			  \});
			
			  describe("redirections: 404", () => \{
			    beforeEach(() => \{
			      // The handler throws a ServerError to imitate getting a 404 from the WP
			      // REST API.
			      handler.func = jest.fn(() => \{
			        throw new ServerError("There was an error", 404);
			      \}) as any;
			    \});
			
			    it(\`\$\{platform\}: Should ignore the redirection if there is no error\`, async () => \{
			      store.state.source.redirections = "404";
			
			      // Restore the handler to the original implementation.
			      handler.func.mockRestore();
			
			      await store.actions.source.fetch("/some-post/");
			
			      expect(mockedFetch).not.toHaveBeenCalled();
			      expect(handler.func).toHaveBeenCalledTimes(1);
			    \});
			
			    it(\`\$\{platform\}: Should NOT redirect on an error that is not a 404\`, async () => \{
			      store.state.source.redirections = "404";
			
			      // Throw a 500 inside of the handler.
			      handler.func = jest.fn(() => \{
			        throw new ServerError("There was an error", 500);
			      \}) as any;
			
			      await store.actions.source.fetch("/some-post/");
			
			      expect(mockedFetch).not.toHaveBeenCalled();
			      expect(handler.func).toHaveBeenCalledTimes(1);
			    \});
			
			    it(\`\$\{platform\}: Should redirect on 404\`, async () => \{
			      store.state.source.redirections = "404";
			
			      // On embedded mode, on the client side, there should not be
			      // any difference in handling the redirections.
			      if (platform === "client") \{
			        setEmbeddedModeTrue(store);
			      \}
			
			      await store.actions.source.fetch("/some-post/");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			
			      expect(handler.func).toHaveBeenCalledTimes(1);
			      expect(handler.func).toHaveBeenCalledBefore(mockedFetch);
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    // On the server, the embedded mode should NOT handle the redirections
			    // to avoid the infinite loading loop.
			    // On embedded mode redirections are handled by the host which embeds frontity.
			    // More specifically Wordpress.
			    if (platform === "server") \{
			      it(\`\$\{platform\}: Should not redirect on 404 on embedded mode\`, async () => \{
			        store.state.source.redirections = "404";
			
			        // Set the embedded mode
			        setEmbeddedModeTrue(store);
			
			        await store.actions.source.fetch("/some-post/");
			
			        // The \`fetch()\` was called.
			        expect(mockedFetch).toHaveBeenCalledTimes(0);
			        expect(handler.func).toHaveBeenCalledTimes(1);
			
			        expect(store.state.source.data).toMatchInlineSnapshot(\`
			                Object \{
			                  "/some-post/": Object \{
			                    "errorStatus": 404,
			                    "errorStatusText": "There was an error",
			                    "is404": true,
			                    "isError": true,
			                    "isFetching": false,
			                    "isReady": true,
			                    "link": "/some-post/",
			                    "page": 1,
			                    "query": Object \{\},
			                    "route": "/some-post/",
			                  \},
			                \}
			            \`);
			      \});
			    \}
			
			    it(\`\$\{platform\}: Should redirect on 404 when the redirection is a 302 redirection\`, async () => \{
			      store.state.source.redirections = "404";
			
			      if (platform === "server") \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve((\{
			            ...serverResponse,
			            status: 302,
			          \} as unknown) as Response)
			        );
			      \}
			
			      (frontity.fetch as typeof fetch) = mockedFetch;
			
			      await store.actions.source.fetch("/some-post/");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			
			      expect(handler.func).toHaveBeenCalledTimes(1);
			      expect(handler.func).toHaveBeenCalledBefore(mockedFetch);
			
			      const snapshot = \`
			        Object \{
			          "/some-post/": Object \{
			            "is30\$\{platform === "server" ? "2" : "1"\}": true,
			            "isExternal": false,
			            "isFetching": false,
			            "isReady": true,
			            "isRedirection": true,
			            "link": "/some-post/",
			            "location": "https://wp.domain.com/redirected-url",
			            "page": 1,
			            "query": Object \{\},
			            "redirectionStatus": 30\$\{platform === "server" ? "2" : "1"\},
			            "route": "/some-post/",
			          \},
			        \}
			      \`;
			
			      const is302 = platform === "server";
			      const is301 = platform === "client";
			      const data = store.state.source.data["/some-post/"] as RedirectionData;
			
			      expect(!!data.is302).toBe(is302);
			      expect(!!data.is301).toBe(is301);
			      expect(store.state.source.data).toMatchInlineSnapshot(snapshot);
			    \});
			
			    it(\`\$\{platform\}: Should return a normal 404 error if fetching the redirection fails\`, async () => \{
			      store.state.source.redirections = "404";
			
			      // Fetching the redirection fails.
			      mockedFetch = jest.fn().mockRejectedValueOnce("Fetch Error");
			      (frontity.fetch as typeof fetch) = mockedFetch;
			
			      await store.actions.source.fetch("/some-post/");
			
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "errorStatus": 404,
			                  "errorStatusText": "There was an error",
			                  "is404": true,
			                  "isError": true,
			                  "isFetching": false,
			                  "isReady": true,
			                  "link": "/some-post/",
			                  "page": 1,
			                  "query": Object \{\},
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should handle redirections if the URL contains a query string\`, async () => \{
			      store.state.source.redirections = "404";
			
			      await store.actions.source.fetch("/some-post?key=value&key2=value2");
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/?key=value&key2=value2": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/?key=value&key2=value2",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{
			                    "key": "value",
			                    "key2": "value2",
			                  \},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			  \});
			
			  describe("redirections: RegExp and RegExp[]", () => \{
			    beforeEach(() => \{
			      // The handler throws a 404.
			      handler.func = jest.fn(() => \{
			        throw new ServerError("There was an error", 404);
			      \}) as any;
			    \});
			
			    it(\`\$\{platform\}: Should fetch the redirection when the redirection is a single regex\`, async () => \{
			      store.state.source.redirections = "RegExp:/some-(\\\\w*)";
			      await store.actions.source.fetch("/some-post");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			
			      expect(handler.func).not.toHaveBeenCalled();
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should match the redirection with pagination and queries\`, async () => \{
			      store.state.source.redirections = "RegExp:/some-(\\\\w*)";
			      await store.actions.source.fetch("/some-post");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(handler.func).not.toHaveBeenCalled();
			
			      store.state.source.redirections =
			        "RegExp:\\\\/category\\\\/some-cat\\\\/page\\\\/[2,3]";
			      await store.actions.source.fetch("/category/some-cat/page/2");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(2);
			      expect(handler.func).not.toHaveBeenCalled();
			
			      await store.actions.source.fetch("/category/some-cat/page/5");
			
			      // The \`fetch()\` was not called.
			      expect(mockedFetch).toHaveBeenCalledTimes(2);
			      expect(handler.func).toHaveBeenCalledTimes(1);
			
			      store.state.source.redirections = ["RegExp:(\\\\?|&)p=(\\\\d+)"];
			      await store.actions.source.fetch("/?p=123&preview=true");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(3);
			      expect(handler.func).toHaveBeenCalledTimes(1);
			
			      await store.actions.source.fetch("/?page_id=123&preview=true");
			
			      // The \`fetch()\` was not called.
			      expect(mockedFetch).toHaveBeenCalledTimes(3);
			      expect(handler.func).toHaveBeenCalledTimes(2);
			    \});
			
			    it(\`\$\{platform\}: Should just return a 404 if the redirection does not match the regex\`, async () => \{
			      store.state.source.redirections = "RegExp:/some-other-post";
			      await store.actions.source.fetch("/some-post");
			
			      // The \`fetch()\` was NOT called.
			      expect(mockedFetch).toHaveBeenCalledTimes(0);
			      expect(handler.func).toHaveBeenCalledTimes(1);
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "errorStatus": 404,
			                  "errorStatusText": "There was an error",
			                  "is404": true,
			                  "isError": true,
			                  "isFetching": false,
			                  "isReady": true,
			                  "link": "/some-post/",
			                  "page": 1,
			                  "query": Object \{\},
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should fetch the redirection when the redirection is an array of regexes\`, async () => \{
			      store.state.source.redirections = [
			        "RegExp:/some-(.*)",
			        "RegExp:/some-other-post",
			      ];
			      await store.actions.source.fetch("/some-post");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			
			      expect(handler.func).not.toHaveBeenCalled();
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should fetch the redirection when the redirection is an array of regexes that includes a 404 AND the regex does NOT match the route\`, async () => \{
			      store.state.source.redirections = [
			        "404",
			        "RegExp:/some-other-post", // This regex does not match
			      ];
			      await store.actions.source.fetch("/some-post");
			
			      // The \`fetch()\` was called.
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			
			      expect(handler.func).toHaveBeenCalledTimes(1);
			
			      // The handler was called before the fetch because there was no match for
			      // the redirection regex so we only fetch the redirection once the error is thrown.
			      expect(handler.func).toHaveBeenCalledBefore(mockedFetch);
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should fetch the redirection when the redirection is an array of regexes that includes a 404 AND the regex matches a route\`, async () => \{
			      store.state.source.redirections = [
			        "404",
			        "RegExp:/some-(\\\\w*)", // This regex DOES match
			      ];
			      await store.actions.source.fetch("/some-post");
			
			      // We only call the fetch once, even though we include the
			      expect(mockedFetch).toHaveBeenCalledTimes(1);
			      expect(mockedFetch).toHaveBeenCalledWith(...fetchRedirectionParams);
			
			      expect(handler.func).not.toHaveBeenCalled();
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			  \});
			
			  describe("redirections: external", () => \{
			    it(\`\$\{platform\}: Should not mark the Frontity URLs as external redirections\`, async () => \{
			      store.state.source.redirections = "all";
			
			      if (platform === "server") \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve((\{
			            status: 301,
			            headers: new Headers(\{
			              location: "https://www.domain.com/redirected-url",
			            \}),
			          \} as unknown) as Response)
			        );
			      \} else \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve(\{
			            url: "https://www.domain.com/redirected-url",
			            redirected: true,
			            status: 200,
			          \} as Response)
			        );
			      \}
			
			      (frontity.fetch as typeof fetch) = mockedFetch;
			
			      await store.actions.source.fetch("/some-post/");
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://www.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should not mark backend URLs as external redirections\`, async () => \{
			      store.state.source.redirections = "all";
			
			      if (platform === "server") \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve((\{
			            status: 301,
			            headers: new Headers(\{
			              location: "https://wp.domain.com/redirected-url",
			            \}),
			          \} as unknown) as Response)
			        );
			      \} else \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve(\{
			            url: "https://wp.domain.com/redirected-url",
			            redirected: true,
			            status: 200,
			          \} as Response)
			        );
			      \}
			
			      (frontity.fetch as typeof fetch) = mockedFetch;
			
			      await store.actions.source.fetch("/some-post/");
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": false,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://wp.domain.com/redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should mark external redirections\`, async () => \{
			      store.state.source.redirections = "all";
			
			      if (platform === "server") \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve((\{
			            status: 301,
			            headers: new Headers(\{
			              location: "https://external-domain.com/external-redirected-url",
			            \}),
			          \} as unknown) as Response)
			        );
			      \} else \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve(\{
			            url: "https://external-domain.com/external-redirected-url",
			            redirected: true,
			            status: 200,
			          \} as Response)
			        );
			      \}
			
			      (frontity.fetch as typeof fetch) = mockedFetch;
			
			      await store.actions.source.fetch("/some-post/");
			
			      expect(store.state.source.data).toMatchInlineSnapshot(\`
			              Object \{
			                "/some-post/": Object \{
			                  "is301": true,
			                  "isExternal": true,
			                  "isFetching": false,
			                  "isReady": true,
			                  "isRedirection": true,
			                  "link": "/some-post/",
			                  "location": "https://external-domain.com/external-redirected-url",
			                  "page": 1,
			                  "query": Object \{\},
			                  "redirectionStatus": 301,
			                  "route": "/some-post/",
			                \},
			              \}
			          \`);
			    \});
			
			    it(\`\$\{platform\}: Should mark redirections as external if they fail due to CORS\`, async () => \{
			      store.state.source.redirections = "all";
			
			      if (platform === "server") \{
			        mockedFetch = jest.fn((_) =>
			          Promise.resolve((\{
			            status: 301,
			            headers: new Headers(\{
			              location: "https://external-domain.com/external-redirected-url",
			            \}),
			          \} as unknown) as Response)
			        );
			      \} else \{
			        mockedFetch = jest
			          .fn()
			          // Fetching the redirection fails first due to CORS.
			          .mockRejectedValueOnce("Fetch Error")
			          // Then the next fetch done with \`redirect: manual\` returns the
			          // opaqueredirect value.
			          .mockResolvedValueOnce(\{
			            url: "https://wp.domain.com/some-post/",
			            type: "opaqueredirect",
			            status: 0,
			          \});
			      \}
			
			      (frontity.fetch as typeof fetch) = mockedFetch;
			
			      await store.actions.source.fetch("/some-post/");
			
			      const snapshot = \`
			      Object \{
			        "/some-post/": Object \{
			          "is301": true,
			          "isExternal": true,
			          "isFetching": false,
			          "isReady": true,
			          "isRedirection": true,
			          "link": "/some-post/",
			          "location": \$\{
			            platform === "server"
			              ? '"https://external-domain.com/external-redirected-url"'
			              : '"https://wp.domain.com/some-post/"'
			          \},
			          "page": 1,
			          "query": Object \{\},
			          "redirectionStatus": 301,
			          "route": "/some-post/",
			        \},
			      \}
			    \`;
			
			      expect(store.state.source.data).toMatchInlineSnapshot(snapshot);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\__tests__\\3xx-redirections.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(19)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\__tests__\\actions.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, observe, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../";
			import WpSource, \{ Pattern, Handler \} from "../../types";
			import * as handlers from "../libraries/handlers";
			import \{ getMatch \} from "../libraries/get-match";
			import \{ Data, CategoryData, ErrorData \} from "@frontity/source/types";
			import \{ isCategory, isError, isHome \} from "@frontity/source";
			
			// Create mock for handler generators
			jest.mock("../libraries/handlers");
			
			const handlerMocks = handlers as jest.Mocked<typeof handlers>;
			handlerMocks.taxonomyHandler.mockReturnValue(jest.fn());
			handlerMocks.postTypeHandler.mockReturnValue(jest.fn());
			handlerMocks.postTypeArchiveHandler.mockReturnValue(jest.fn());
			handlerMocks.postTypeWithQueryHandler.mockReturnValue(jest.fn());
			
			let handler: jest.Mocked<Pattern<Handler>>;
			let store: InitializedStore<WpSource>;
			
			beforeEach(() => \{
			  // Reset mocks
			  handlerMocks.taxonomyHandler.mockClear();
			  handlerMocks.postTypeHandler.mockClear();
			  handlerMocks.postTypeArchiveHandler.mockClear();
			  handlerMocks.postTypeWithQueryHandler.mockClear();
			  // Create a mock handler
			  handler = \{
			    name: "always",
			    priority: 0,
			    pattern: "/(.*)",
			    func: jest.fn(async (\{ link, state \}) => \{
			      await Promise.resolve();
			      Object.assign(state.source.data[link], \{
			        type: "example",
			        id: 1,
			        isPostType: true,
			        isFetching: true,
			        isReady: false,
			      \});
			    \}),
			  \};
			
			  // Initialize the store
			  store = createStore<WpSource>(clone(wpSource(), \{ clone: false \}));
			
			  store.state.source.url = "https://test.frontity.org/";
			
			  // Add mock handler to the store
			  store.libraries.source.handlers.push(handler);
			\});
			
			/**
			 * Helper that returns a link's data when the given prop has the given value.
			 *
			 * @param link - Link in the Frontity site.
			 * @param props - Props and their values to check.
			 * @returns Promise with the data object when is ready.
			 */
			const observeData = (link: string, props: Partial<Data>): Promise<Data> =>
			  new Promise((resolve) => \{
			    observe(() => \{
			      const data = store.state.source.get(link);
			
			      // Exit if some condition fails.
			      for (const prop in props) \{
			        if (!data[prop] === props[prop]) return;
			      \}
			
			      // Resolve only when all conditions are true.
			      resolve(data);
			    \});
			  \});
			
			describe("actions.source.fetch", () => \{
			  test("should work if data doesn't exist", async () => \{
			    await store.actions.source.fetch("/some/route/");
			    expect(handler.func).toHaveBeenCalledTimes(1);
			    expect(store.state.source.data).toMatchSnapshot();
			  \});
			
			  test("does nothing if data exists", async () => \{
			    store.state.source.data["/some/route/"] = \{
			      type: "example",
			      id: 1,
			      isPostType: true,
			      isFetching: false,
			      isReady: true,
			      link: "/some/route/",
			      route: "/some/route/",
			      page: 1,
			      query: \{\},
			    \} as Data;
			
			    await store.actions.source.fetch("/some/route/");
			    expect(handler.func).not.toHaveBeenCalled();
			    expect(store.state.source.data).toMatchSnapshot();
			  \});
			
			  test("should switch isFetching and isReady even if data exists", async () => \{
			    store.state.source.data["/some/route/"] = \{
			      isFetching: false,
			      isReady: false,
			      link: "/some/route/",
			      route: "/some/route/",
			      page: 1,
			      query: \{\},
			    \};
			    const fetching = store.actions.source.fetch("/some/route/");
			    expect(store.state.source.get("/some/route").isFetching).toBe(true);
			    expect(store.state.source.get("/some/route").isReady).toBe(false);
			    await fetching;
			    expect(store.state.source.get("/some/route").isFetching).toBe(false);
			    expect(store.state.source.get("/some/route").isReady).toBe(true);
			  \});
			
			  test('should set isHome in "/"', async () => \{
			    const promisedData = observeData("/", \{ isReady: true \});
			    store.actions.source.fetch("/");
			    expect(isHome(await promisedData)).toBe(true);
			  \});
			
			  test('should set isHome in "/page/x"', async () => \{
			    const promisedData = observeData("/page/123", \{ isReady: true \});
			    store.actions.source.fetch("/page/123");
			    expect(isHome(await promisedData)).toBe(true);
			  \});
			
			  test('should set isHome in "/blog" when using a subdirectory', async () => \{
			    store.state.source.subdirectory = "/blog";
			    const promisedData = observeData("/blog", \{ isReady: true \});
			    store.actions.source.fetch("/blog");
			    expect(isHome(await promisedData)).toBe(true);
			  \});
			
			  test('should set isHome in "/blog/page/x" when using a subdirectory', async () => \{
			    store.state.source.subdirectory = "/blog";
			    const promisedData = observeData("/blog/page/123", \{ isReady: true \});
			    store.actions.source.fetch("/blog/page/123");
			    expect(isHome(await promisedData)).toBe(true);
			  \});
			
			  test('should set isHome in "/" when a redirection has matched', async () => \{
			    store.libraries.source.redirections = [
			      \{
			        name: "homepage",
			        priority: 10,
			        pattern: "/",
			        func: () => "/front-page/",
			      \},
			    ];
			
			    const promisedData = observeData("/", \{ isReady: true \});
			    store.actions.source.fetch("/");
			    expect(isHome(await promisedData)).toBe(true);
			  \});
			
			  test('should set isHome in "/page/x/" when a redirection has matched', async () => \{
			    store.libraries.source.redirections = [
			      \{
			        name: "homepage",
			        priority: 10,
			        pattern: "/",
			        func: () => "/front-page/",
			      \},
			    ];
			
			    const promisedData = observeData("/page/123", \{ isReady: true \});
			    store.actions.source.fetch("/page/123");
			    expect(isHome(await promisedData)).toBe(true);
			  \});
			
			  test("should run again when \`force\` is used", async () => \{
			    store.state.source.data["/some/route/"] = \{
			      errorStatusText: "Request Timeout",
			      errorStatus: 408,
			      isError: true,
			      isFetching: false,
			      isReady: true,
			      link: "/some/route/",
			      query: \{\},
			    \} as ErrorData;
			
			    await store.actions.source.fetch("/some/route/", \{ force: true \});
			    expect(handler.func).toHaveBeenCalled();
			    expect(store.state.source.data).toMatchSnapshot();
			  \});
			
			  test("Throw an error if fetch fails", async () => \{
			    handler.func = jest.fn(async (_) => \{
			      throw new Error("Handler error");
			    \});
			
			    let error: Error;
			
			    try \{
			      await store.actions.source.fetch("/some/route/");
			      throw new Error("This should not be reached");
			    \} catch (e) \{
			      error = e;
			    \}
			
			    expect(error.message).toBe("Handler error");
			    expect(store.state.source.data).toMatchSnapshot();
			  \});
			
			  test("should allow to observe 'isReady' properly", async () => \{
			    expect(store.state.source.get("/").isReady).toBe(false);
			
			    // \`observeData\` uses \`observe\`.
			    const promisedData = observeData("/", \{ isReady: true \});
			    store.actions.source.fetch("/");
			    await promisedData;
			  \});
			
			  test("should allow to observe 'isFetching' properly", async () => \{
			    expect(store.state.source.get("/").isFetching).toBe(false);
			    store.actions.source.fetch("/");
			    expect(store.state.source.get("/").isFetching).toBe(true);
			
			    // \`observeData\` uses \`observe\`.
			    const promisedData = observeData("/", \{ isFetching: false \});
			    await promisedData;
			  \});
			
			  test("Should throw a 404 error if no handler matched the link", async () => \{
			    await store.actions.source.fetch("@unknown/link");
			    expect(store.state.source.data).toMatchInlineSnapshot(\`
			      Object \{
			        "@unknown/link/": Object \{
			          "errorStatus": 404,
			          "errorStatusText": "No handler has matched for the given link: \\\\"@unknown/link/\\\\"",
			          "is404": true,
			          "isError": true,
			          "isFetching": false,
			          "isReady": true,
			          "link": "@unknown/link/",
			          "page": 1,
			          "query": Object \{\},
			          "route": "@unknown/link/",
			        \},
			      \}
			    \`);
			  \});
			\});
			
			describe("actions.source.init", () => \{
			  test("should add redirect for the specified homepage", async () => \{
			    store.state.source.homepage = "/about-us/";
			    await store.actions.source.init();
			    expect(store.libraries.source.redirections).toMatchSnapshot();
			
			    // The redirection returns \`homepage\` as the new \`route\` if the link doesn't
			    // contain a search param (\`?s=search+term\`).
			    const linksWithoutSearch = [
			      "/",
			      "/?some=param",
			      "/#hashtag",
			      "/?some=param#hashtag",
			    ];
			
			    linksWithoutSearch.forEach((link) => \{
			      const redirect = getMatch(\{ link \}, store.libraries.source.redirections);
			      expect(redirect).toBeTruthy();
			      expect(redirect.func(redirect.params)).toBe("/about-us/");
			    \});
			
			    // The redirection should not match if the link contains a search param or
			    // it's not the homepage.
			    const linksWithSearch = [
			      "/?s=search+term",
			      "/?s=search+term&some=param",
			      "/?some=param&s=search+term",
			      "/?s=search+term#hashtag",
			      "/?s=search+term&some=param#hashtag",
			      "/?some=param&s=search+term#hashtag",
			      "/post-1/",
			      "/post-1/?some=param",
			      "/post-1/#hashtag",
			      "/post-1/?some=param#hashtag",
			    ];
			
			    linksWithSearch.forEach((link) => \{
			      const redirect = getMatch(\{ link \}, store.libraries.source.redirections);
			      expect(redirect && link).toBeFalsy();
			    \});
			  \});
			
			  test("should add redirect for the specified homepage and subdirectory", async () => \{
			    store.state.source.homepage = "/about-us/";
			    store.state.source.subdirectory = "/subdir/";
			    await store.actions.source.init();
			    expect(store.libraries.source.redirections).toMatchSnapshot();
			
			    // The redirection returns \`homepage\` as the new \`route\` if the link doesn't
			    // contain a search param (\`?s=search+term\`).
			    const linksWithoutSearch = [
			      "/subdir/",
			      "/subdir/?some=param",
			      "/subdir/#hashtag",
			      "/subdir/?some=param#hashtag",
			    ];
			
			    linksWithoutSearch.forEach((link) => \{
			      const redirect = getMatch(\{ link \}, store.libraries.source.redirections);
			      expect(redirect).toBeTruthy();
			      expect(redirect.func(redirect.params)).toBe("/about-us/");
			    \});
			
			    // The redirection should not match if the link contains a search param or
			    // it's not the homepage.
			    const linksWithSearch = [
			      "/subdir/?s=search+term",
			      "/subdir/?s=search+term&some=param",
			      "/subdir/?some=param&s=search+term",
			      "/subdir/?s=search+term#hashtag",
			      "/subdir/?s=search+term&some=param#hashtag",
			      "/subdir/?some=param&s=search+term#hashtag",
			      "/subdir/post-1/",
			      "/subdir/post-1/?some=param",
			      "/subdir/post-1/#hashtag",
			      "/subdir/post-1/?some=param#hashtag",
			      "/",
			      "/?some=param",
			      "/#hashtag",
			      "/?some=param#hashtag",
			    ];
			
			    linksWithSearch.forEach((link) => \{
			      const redirect = getMatch(\{ link \}, store.libraries.source.redirections);
			      expect(redirect && link).toBeFalsy();
			    \});
			  \});
			
			  test("should add redirect for the specified posts page", async () => \{
			    store.state.source.postsPage = "/all-posts/";
			    await store.actions.source.init();
			    expect(store.libraries.source.redirections).toMatchSnapshot();
			  \});
			
			  test("should add redirect for categories if 'categoryBase' is set", async () => \{
			    store.state.source.categoryBase = "wp-cat";
			    await store.actions.source.init();
			    expect(store.libraries.source.redirections).toMatchSnapshot();
			    // Test that the redirection works.
			    const route = "/wp-cat/travel/";
			    const redirect = getMatch(\{ route \}, store.libraries.source.redirections);
			    expect(redirect).toBeTruthy();
			    expect(redirect.func(redirect.params)).toBe("/category/travel/");
			  \});
			
			  test("should add redirect for tags if 'tagBase' is set", async () => \{
			    store.state.source.tagBase = "wp-tag";
			    await store.actions.source.init();
			    expect(store.libraries.source.redirections).toMatchSnapshot();
			    // Test that the redirection works.
			    const route = "/wp-tag/paris/";
			    const redirect = getMatch(\{ route \}, store.libraries.source.redirections);
			    expect(redirect).toBeTruthy();
			    expect(redirect.func(redirect.params)).toBe("/tag/paris/");
			  \});
			
			  test("should add redirect for tags if 'authorBase' is set", async () => \{
			    store.state.source.authorBase = "/blog/author";
			    await store.actions.source.init();
			    expect(store.libraries.source.redirections).toMatchSnapshot();
			    // Test that the redirection works.
			    const route = "/blog/author/admin/";
			    const redirect = getMatch(\{ route \}, store.libraries.source.redirections);
			    expect(redirect).toBeTruthy();
			    expect(redirect.func(redirect.params)).toBe("/author/admin/");
			  \});
			
			  test("should add redirect if 'subirectory' is present", async () => \{
			    store.state.source.homepage = "/about-us/";
			    store.state.source.postsPage = "/all-posts/";
			    store.state.source.categoryBase = "wp-cat";
			    store.state.source.tagBase = "wp-tag";
			    store.state.source.subdirectory = "blog";
			    await store.actions.source.init();
			    expect(store.libraries.source.redirections).toMatchSnapshot();
			  \});
			
			  test("should add new handlers from postTypes array", async () => \{
			    store.state.source.postTypes.push(
			      \{
			        type: "cpt1",
			        endpoint: "cpts1",
			      \},
			      \{
			        type: "cpt2",
			        endpoint: "cpts2",
			        archive: "cpt2-archive",
			      \}
			    );
			
			    await store.actions.source.init();
			
			    expect(store.libraries.source.handlers).toMatchSnapshot();
			    expect(handlerMocks.postTypeHandler.mock.calls).toMatchSnapshot();
			    expect(handlerMocks.postTypeArchiveHandler.mock.calls).toMatchSnapshot();
			    expect(handlerMocks.postTypeWithQueryHandler.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should add new handlers from taxonomies array", async () => \{
			    store.state.source.taxonomies.push(
			      \{
			        taxonomy: "taxonomy1",
			        endpoint: "taxonomies1",
			      \},
			      \{
			        taxonomy: "taxonomy2",
			        endpoint: "taxonomies2",
			        postTypeEndpoint: "cpt",
			      \},
			      \{
			        taxonomy: "taxonomy3",
			        endpoint: "taxonomies3",
			        postTypeEndpoint: "multiple-post-type",
			        params: \{
			          type: ["posts", "cpts"],
			        \},
			      \}
			    );
			
			    await store.actions.source.init();
			
			    expect(store.libraries.source.handlers).toMatchSnapshot();
			    expect(handlerMocks.taxonomyHandler.mock.calls).toMatchSnapshot();
			  \});
			
			  test("should populate link, route, page and query even if data exists", async () => \{
			    store.state.source.data["/some/route/page/2/?a=b"] = \{
			      isFetching: false,
			      isReady: false,
			      link: "/some/route/page/2/?a=b",
			      route: "/some/route/",
			      page: 2,
			      query: \{ a: "b" \},
			    \};
			
			    await store.actions.source.fetch("/some/route/page/2/?a=b");
			
			    const \{ link, route, page, query \} = store.state.source.get(
			      "/some/route/page/2/?a=b"
			    );
			
			    expect(link).toEqual("/some/route/page/2/?a=b");
			    expect(route).toEqual("/some/route/");
			    expect(page).toEqual(2);
			    expect(query).toEqual(\{ a: "b" \});
			  \});
			
			  test("state.data['/some/route/'].isReady should stay true when fetching with \{ force: true \}", async () => \{
			    // Get initial data into the store
			    store.state.source.data["/some/route/"] = \{
			      isFetching: false,
			      isReady: true,
			      link: "/some/route/",
			      route: "/some/route/",
			      page: 1,
			      query: \{\},
			    \};
			
			    const fetchLink = store.actions.source.fetch("/some/route/", \{
			      force: true,
			    \});
			
			    // Normally this would be \`false\` if we hadn't already fetched the data
			    expect(store.state.source.data["/some/route/"].isReady).toBe(true);
			
			    await fetchLink;
			
			    // It should stay \`true\` after having fetched, obviously
			    expect(store.state.source.data["/some/route/"].isReady).toBe(true);
			  \});
			
			  test("state.data['/some/route/'].isCategory should be removed when fetching with \{ force: true \}", async () => \{
			    // Get initial data into the store
			    const initialData: CategoryData = \{
			      isArchive: true,
			      isTerm: true,
			      isCategory: true,
			      taxonomy: "category",
			      id: 7,
			      items: [],
			      isReady: true,
			      isFetching: false,
			      link: "/some/route/",
			      query: \{\},
			      route: "/some/route/",
			      page: 1,
			    \};
			
			    store.state.source.data["/some/route/"] = initialData;
			
			    handler.func = jest.fn(async (\{ link, state \}) => \{
			      await Promise.resolve();
			      Object.assign(state.source.data[link], \{
			        isFetching: true,
			        isReady: true,
			      \});
			    \});
			
			    expect(isCategory(store.state.source.data["/some/route/"])).toBe(true);
			    expect((store.state.source.data["/some/route/"] as any).items).toEqual([]);
			
			    await store.actions.source.fetch("/some/route/", \{
			      force: true,
			    \});
			
			    const data = store.state.source.get("/some/route/");
			
			    // NOTE!!! This should fail in wp-source 2.0, because \`isCategory\` and \`items\` should be removed
			    expect(data).toMatchSnapshot();
			
			    // NOTE!!! This should fail in wp-source 2.0, because \`isCategory\` and \`items\` should be removed
			    expect(isCategory(data)).toBe(true);
			    expect((data as any).items).toEqual([]);
			  \});
			
			  test("Errors for state.data['/some/route/'] should be removed when fetching with \{ force: true \}", async () => \{
			    // Get initial data into the store
			    store.state.source["/some/route/"] = \{
			      isError: true,
			      errorStatusText: "Some error",
			      errorStatus: 404,
			      isReady: true,
			      isFetching: false,
			    \};
			
			    await store.actions.source.fetch("/some/route/", \{
			      force: true,
			    \});
			
			    const data = store.state.source.get("/some/route/");
			
			    expect(data).toMatchSnapshot();
			
			    expect(isError(data)).toBe(false);
			    expect((data as any).errorStatus).toBeUndefined();
			    expect((data as any).errorStatusText).toBeUndefined();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\__tests__\\actions.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(27)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\__tests__\\internal-redirections-handlers.tests.ts', () => {
        const sourceCode = `
			import \{ createStore, InitializedStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "..";
			import WpSource from "../../types";
			import * as getMatch from "../libraries/get-match";
			
			// Create mock for handler generators
			jest.mock("../libraries/get-match");
			
			const getMatchMock = getMatch as jest.Mocked<typeof getMatch>;
			
			let store: InitializedStore<WpSource>;
			
			beforeEach(() => \{
			  // Initialize the store
			  store = createStore<WpSource>(clone(wpSource()));
			  store.state.source.url = "https://test.frontity.org/";
			
			  getMatchMock.getMatch.mockClear();
			\});
			
			test("Correct handler should have been called after an internal redirection", async () => \{
			  const redirection = \{
			    name: "redirection",
			    params: \{\},
			    priority: 1,
			    pattern: "/test",
			    func: jest.fn(() => "/redirected"),
			  \};
			
			  // We have to mock the return value of getMatch for the FIRST invocation
			  // in actions.source.fetch()
			  getMatchMock.getMatch.mockReturnValueOnce(redirection);
			
			  await store.actions.source.fetch("/test");
			
			  // The redirection func should have been called just once to get the new route
			  expect(redirection.func).toHaveBeenCalledTimes(1);
			
			  // The first call is matching the redirections
			  // The second call is matching the handler
			  expect(getMatchMock.getMatch).toHaveBeenCalledTimes(2);
			  expect(getMatchMock.getMatch.mock.calls).toMatchInlineSnapshot(\`
			    Array [
			      Array [
			        Object \{
			          "link": "/test/",
			          "route": "/test/",
			        \},
			        Array [],
			      ],
			      Array [
			        Object \{
			          "link": "/redirected/",
			          "route": "/redirected",
			        \},
			        Array [],
			      ],
			    ]
			  \`);
			\});
			
			test("Match handler after redirection if link includes page or query", async () => \{
			  // We have to unmock the get-match, because it's being mocked on the module level
			  getMatchMock.getMatch.mockImplementation(
			    jest.requireActual("../libraries/get-match").getMatch
			  );
			
			  // A fake redirection that redirects from "/test" to "/redirected"
			  const redirection = \{
			    name: "redirection",
			    params: \{\},
			    priority: 1,
			    pattern: "/test",
			    func: jest.fn(() => "/redirected"),
			  \};
			
			  // Create a mock handler
			  const handler = \{
			    name: "test",
			    priority: 1,
			    pattern: "RegExp:\\\\/redirected\\\\/\\\\?option=test",
			    func: jest.fn(async (\{ link, state \}) => \{
			      await Promise.resolve();
			      Object.assign(state.source.data[link], \{
			        isFetching: true,
			        isReady: false,
			        id: 1,
			      \});
			    \}),
			  \};
			
			  // Add the handler and redirections
			  store.libraries.source.handlers = [handler];
			  store.libraries.source.redirections = [redirection];
			
			  await store.actions.source.fetch("/test?option=test");
			
			  // Make sure that the redirection and the handler were indeed called
			  expect(redirection.func).toHaveBeenCalledTimes(1);
			  expect(handler.func).toHaveBeenCalledTimes(1);
			
			  // Should show the data assigned by our mock handler
			  expect(store.state.source.data).toMatchInlineSnapshot(\`
			    Object \{
			      "/test/?option=test": Object \{
			        "id": 1,
			        "isFetching": false,
			        "isReady": true,
			        "link": "/test/?option=test",
			        "page": 1,
			        "query": Object \{
			          "option": "test",
			        \},
			        "route": "/test/",
			      \},
			    \}
			  \`);
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\__tests__\\internal-redirections-handlers.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(2)
    });
    it('frontity_frontity\\packages\\wp-source\\src\\__tests__\\state.tests.ts', () => {
        const sourceCode = `
			import \{ createStore \} from "@frontity/connect";
			import clone from "clone-deep";
			import wpSource from "../";
			import merge from "deepmerge";
			
			describe("state.source.get", () => \{
			  const initStore = (data = \{\}) => \{
			    const config = clone(wpSource());
			    // replace data by the one passed as argument
			    config.state.source.data = data;
			    return createStore(config);
			  \};
			
			  test("returns an object with isReady/isFetching = false if not found", () => \{
			    const store = initStore();
			    expect(store.state.source.get("/some-post/")).toEqual(\{
			      isFetching: false,
			      isReady: false,
			      link: "/some-post/",
			      page: 1,
			      query: \{\},
			      route: "/some-post/",
			    \});
			  \});
			
			  test("returns the correct object (path)", () => \{
			    const post = \{
			      type: "post",
			      id: 1,
			      isPostType: true,
			      isReady: true,
			      isFetching: false,
			    \};
			    const \{ source \} = initStore(\{ "/some-post/": post \}).state;
			    expect(source.get("/some-post")).toEqual(post);
			    expect(source.get("/some-post/")).toEqual(post);
			    expect(source.get("https://wp.site.test/some-post/")).toEqual(post);
			  \});
			
			  test("returns the correct object (path, page)", () => \{
			    const archive = \{
			      taxonomy: "tag",
			      id: 2,
			      items: [],
			      isArchive: true,
			      isTaxonomy: true,
			      isTag: true,
			      isReady: true,
			      isFetching: false,
			    \};
			    const \{ source \} = initStore(\{ "/tag/some-tag/page/2/": archive \}).state;
			    expect(source.get("/tag/some-tag/page/2")).toEqual(archive);
			    expect(source.get("/tag/some-tag/page/2/")).toEqual(archive);
			    expect(source.get("https://wp.site.test/tag/some-tag/page/2/")).toEqual(
			      archive
			    );
			  \});
			
			  test("returns the correct object (path, query)", () => \{
			    const archive = \{
			      taxonomy: "tag",
			      id: 2,
			      items: [],
			      isArchive: true,
			      isTaxonomy: true,
			      isTag: true,
			      isReady: true,
			      isFetching: false,
			    \};
			    const \{ source \} = initStore(\{ "/tag/some-tag/?s=search": archive \}).state;
			    expect(source.get("/tag/some-tag?s=search")).toEqual(archive);
			    expect(source.get("/tag/some-tag/?s=search")).toEqual(archive);
			    expect(source.get("https://wp.site.test/tag/some-tag/?s=search")).toEqual(
			      archive
			    );
			  \});
			
			  test("returns the correct object (path, unordered query)", () => \{
			    const archive = \{
			      taxonomy: "tag",
			      id: 2,
			      items: [],
			      isArchive: true,
			      isTaxonomy: true,
			      isTag: true,
			      isReady: true,
			      isFetching: false,
			    \};
			    const \{ source \} = initStore(\{
			      "/tag/some-tag/?k1=v1&k2=v2": archive,
			    \}).state;
			    expect(source.get("/tag/some-tag?k2=v2&k1=v1")).toEqual(archive);
			    expect(source.get("/tag/some-tag/?k2=v2&k1=v1")).toEqual(archive);
			    expect(
			      source.get("https://wp.site.test/tag/some-tag/?k2=v2&k1=v1")
			    ).toEqual(archive);
			  \});
			
			  test("returns the correct object (path, page, query)", () => \{
			    const archive = \{
			      taxonomy: "tag",
			      id: 2,
			      items: [],
			      isArchive: true,
			      isTaxonomy: true,
			      isTag: true,
			      isReady: true,
			      isFetching: false,
			    \};
			    const \{ source \} = initStore(\{
			      "/tag/some-tag/page/2/?s=search": archive,
			    \}).state;
			    expect(source.get("/tag/some-tag/page/2/?s=search")).toEqual(archive);
			    expect(source.get("/tag/some-tag/page/2?s=search")).toEqual(archive);
			    expect(
			      source.get("https://wp.site.test/tag/some-tag/page/2?s=search")
			    ).toEqual(archive);
			  \});
			\});
			
			describe("state.wpSource.isWpCom (state.source.isWpCom)", () => \{
			  const initStore = () => \{
			    const config = clone(merge(wpSource(), \{ state: \{ frontity: \{\} \} \}));
			    return createStore(config);
			  \};
			
			  it("should be false (state.frontity.url, state.source.url not WP com subdomain)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			    state.source.url = "https://wp-domain.com/";
			
			    expect(state.wpSource.isWpCom).toBe(false);
			    expect(state.source.isWpCom).toBe(false);
			  \});
			
			  it("should be false (state.frontity.url, state.wpSource.api not WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.wpSource.api = "https://wp-domain.com/wp-json/";
			    expect(state.wpSource.isWpCom).toBe(false);
			    expect(state.source.isWpCom).toBe(false);
			
			    // Without trailing slash.
			    state.wpSource.api = "https://wp-domain.com/wp-json";
			    expect(state.wpSource.isWpCom).toBe(false);
			    expect(state.source.isWpCom).toBe(false);
			  \});
			
			  it("should be false (state.frontity.url, state.source.api not WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.source.api = "https://wp-domain.com/wp-json/";
			    expect(state.wpSource.isWpCom).toBe(false);
			    expect(state.source.isWpCom).toBe(false);
			
			    // Without trailing slash.
			    state.source.api = "https://wp-domain.com/wp-json";
			    expect(state.wpSource.isWpCom).toBe(false);
			    expect(state.source.isWpCom).toBe(false);
			  \});
			
			  it("should be true (state.frontity.url, state.source.url is WP com subdomain)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			    state.source.url = "https://sub.wordpress.com/";
			
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			  \});
			
			  it("should be true (state.frontity.url, state.wpSource.api is WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com/";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			
			    // Without trailing slash.
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			  \});
			
			  it("should be true (state.frontity.url, state.source.api is WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com/";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			
			    // Without trailing slash.
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			  \});
			
			  it("should be true (state.frontity.url, state.wpSource.api is WP com, custom domain)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			
			    // Without trailing slash.
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			  \});
			
			  it("should be true (state.frontity.url, state.source.api is WP com, custom domain)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			
			    // Without trailing slash.
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			    expect(state.wpSource.isWpCom).toBe(true);
			    expect(state.source.isWpCom).toBe(true);
			  \});
			\});
			
			describe("state.wpSource.api (state.source.api)", () => \{
			  const initStore = () => \{
			    const config = clone(merge(wpSource(), \{ state: \{ frontity: \{\} \} \}));
			    return createStore(config);
			  \};
			
			  it("should return a WP org and Business WP com API (state.frontity.url)", () => \{
			    const \{ state \} = initStore();
			
			    // With trailing slash.
			    state.frontity.url = "https://final-domain.com/";
			    expect(state.wpSource.api).toBe("https://final-domain.com/wp-json/");
			    expect(state.source.api).toBe("https://final-domain.com/wp-json/");
			
			    // Without trailing slash.
			    state.frontity.url = "https://final-domain.com";
			    expect(state.wpSource.api).toBe("https://final-domain.com/wp-json/");
			    expect(state.source.api).toBe("https://final-domain.com/wp-json/");
			  \});
			
			  it("should return a WP org and Business WP com API (state.source.url)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.source.url = "https://wp-domain.com/";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/wp-json/");
			    expect(state.source.api).toBe("https://wp-domain.com/wp-json/");
			
			    // Without trailing slash.
			    state.source.url = "https://wp-domain.com";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/wp-json/");
			    expect(state.source.api).toBe("https://wp-domain.com/wp-json/");
			  \});
			
			  it("should return a WP org and Business WP com API (state.frontity.url, prefix)", () => \{
			    const \{ state \} = initStore();
			
			    // With a trailing slash and different combinations of \`prefix\`.
			    state.frontity.url = "https://final-domain.com/";
			    state.wpSource.prefix = "api";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			    state.wpSource.prefix = "api/";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			    state.wpSource.prefix = "/api";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			    state.wpSource.prefix = "/api/";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			
			    // Without a trailing slash.
			    state.frontity.url = "https://final-domain.com";
			    state.wpSource.prefix = "api";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			    state.wpSource.prefix = "api/";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			    state.wpSource.prefix = "/api";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			    state.wpSource.prefix = "/api/";
			    expect(state.wpSource.api).toBe("https://final-domain.com/api/");
			    expect(state.source.api).toBe("https://final-domain.com/api/");
			  \});
			
			  it("should return a WP org and Business WP com API (state.source.url, prefix)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash and different combinations of \`prefix\`.
			    state.source.url = "https://wp-domain.com/";
			    state.wpSource.prefix = "api";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			    state.wpSource.prefix = "api/";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			    state.wpSource.prefix = "/api";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			    state.wpSource.prefix = "/api/";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			
			    // Without a trailing slash.
			    state.source.url = "https://wp-domain.com";
			    state.wpSource.prefix = "api";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			    state.wpSource.prefix = "api/";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			    state.wpSource.prefix = "/api";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			    state.wpSource.prefix = "/api/";
			    expect(state.wpSource.api).toBe("https://wp-domain.com/api/");
			    expect(state.source.api).toBe("https://wp-domain.com/api/");
			  \});
			
			  it("should return a WP com API (state.frontity.url, state.wpSource.isWpCom)", () => \{
			    const \{ state \} = initStore();
			
			    state.wpSource.isWpCom = true;
			
			    // With final slash.
			    state.frontity.url = "https://final-domain.com/";
			    expect(state.wpSource.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/final-domain.com/"
			    );
			    expect(state.source.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/final-domain.com/"
			    );
			
			    // Without final slash.
			    state.frontity.url = "https://final-domain.com";
			    expect(state.wpSource.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/final-domain.com/"
			    );
			    expect(state.source.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/final-domain.com/"
			    );
			  \});
			
			  it("should return a WP com API (state.source.url - Free WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With trailing slash.
			    state.source.url = "https://sub.wordpress.com/";
			    expect(state.wpSource.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com/"
			    );
			    expect(state.source.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com/"
			    );
			
			    // Without trailing slash.
			    state.source.url = "https://sub.wordpress.com";
			    expect(state.wpSource.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com/"
			    );
			    expect(state.source.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/sub.wordpress.com/"
			    );
			  \});
			
			  it("should return a WP com API (state.source.url, state.wpSource.isWpCom)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			    state.wpSource.isWpCom = true;
			
			    // With final slash.
			    state.source.url = "https://wp-domain.com/";
			    expect(state.wpSource.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/"
			    );
			    expect(state.source.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/"
			    );
			
			    // Without final slash.
			    state.source.url = "https://wp-domain.com";
			    expect(state.wpSource.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/"
			    );
			    expect(state.source.api).toBe(
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/"
			    );
			  \});
			\});
			
			describe("state.source.url", () => \{
			  const initStore = () => \{
			    const config = clone(merge(wpSource(), \{ state: \{ frontity: \{\} \} \}));
			    return createStore(config);
			  \};
			
			  it("should return state.frontity.url if no other props are set (embedded)", () => \{
			    const \{ state \} = initStore();
			
			    // With a trailing slash.
			    state.frontity.url = "https://final-domain.com/";
			    expect(state.source.url).toBe("https://final-domain.com/");
			
			    // Without a trailing slash.
			    state.frontity.url = "https://final-domain.com";
			    expect(state.source.url).toBe("https://final-domain.com/");
			  \});
			
			  it("should derive from state.wpSource.api (WP org and Business WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash.
			    state.wpSource.api = "https://wp-domain.com/wp-json/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			
			    // Without a trailing slash.
			    state.wpSource.api = "https://wp-domain.com/wp-json";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			  \});
			
			  it("should derive from state.source.api (WP org and Business WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash.
			    state.source.api = "https://wp-domain.com/wp-json/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			
			    // Without a trailing slash.
			    state.source.api = "https://wp-domain.com/wp-json";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			  \});
			
			  it("should derive from state.wpSource.api (WP org and Business WP com, w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash.
			    state.wpSource.api = "https://wp-domain.com/subdir/wp-json/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			
			    // Without a trailing slash.
			    state.wpSource.api = "https://wp-domain.com/subdir/wp-json";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			  \});
			
			  it("should derive from state.source.api (WP org and Business WP com, w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash.
			    state.source.api = "https://wp-domain.com/subdir/wp-json/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			
			    // Without a trailing slash.
			    state.source.api = "https://wp-domain.com/subdir/wp-json";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			  \});
			
			  it("should derive from state.wpSource.api and prefix (WP org and Business WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash and different combinations of \`prefix\`.
			    state.wpSource.api = "https://wp-domain.com/api/";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			
			    // Without a trailing slash.
			    state.wpSource.api = "https://wp-domain.com/api";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			  \});
			
			  it("should derive from state.source.api and prefix (WP org and Business WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash and different combinations of \`prefix\`.
			    state.source.api = "https://wp-domain.com/api/";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			
			    // Without a trailing slash.
			    state.source.api = "https://wp-domain.com/api";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			  \});
			
			  it("should derive from state.wpSource.api and prefix (WP org and Business WP com, w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash and different combinations of \`prefix\`.
			    state.wpSource.api = "https://wp-domain.com/subdir/api/";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			
			    // Without a trailing slash.
			    state.wpSource.api = "https://wp-domain.com/subdir/api";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			  \});
			
			  it("should derive from state.source.api and prefix (WP org and Business WP com, w/ subdirectory)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash and different combinations of \`prefix\`.
			    state.source.api = "https://wp-domain.com/subdir/api/";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			
			    // Without a trailing slash.
			    state.source.api = "https://wp-domain.com/subdir/api";
			    state.wpSource.prefix = "api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			    state.wpSource.prefix = "/api/";
			    expect(state.source.url).toBe("https://wp-domain.com/subdir/");
			  \});
			
			  it("should derive from state.wpSource.api (Free, Personal and Premium WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash.
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			
			    // Without a trailing slash.
			    state.wpSource.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			  \});
			
			  it("should derive from state.source.api (Free, Personal and Premium WP com)", () => \{
			    const \{ state \} = initStore();
			
			    state.frontity.url = "https://final-domain.com/";
			
			    // With a trailing slash.
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com/";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			
			    // Without a trailing slash.
			    state.source.api =
			      "https://public-api.wordpress.com/wp/v2/sites/wp-domain.com";
			    expect(state.source.url).toBe("https://wp-domain.com/");
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\wp-source\\src\\__tests__\\state.tests.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(32)
    });
    it('frontity_frontity\\packages\\yoast\\src\\__tests__\\yoast.tests.tsx', () => {
        const sourceCode = `
			/**
			 * @jest-environment node
			 */
			
			import TestRenderer from "react-test-renderer";
			import \{ HelmetProvider \} from "frontity";
			import \{ Provider as ConnectProvider \} from "@frontity/connect";
			import \{ State \} from "frontity/types";
			import \{ FilledContext \} from "react-helmet-async";
			import Yoast from "../components";
			import \{ Packages \} from "../../types";
			import Html2React from "@frontity/html2react/src";
			
			/**
			 * Return a mocked state with the following props:
			 *
			 * - router pointing to a 404 page ("/not-found/").
			 * - source with a "not-found" data object.
			 * - Frontity site's URL is http://my.frontity.test.
			 * - Yoast package has default settings.
			 *
			 * @returns Frontity state.
			 */
			const getState404 = () =>
			  ((\{
			    router: \{
			      link: "/not-found",
			    \},
			    source: \{
			      get: () => (\{
			        link: "/not-found/",
			        route: "/not-found/",
			        page: 1,
			        query: \{\},
			        isFetching: false,
			        isReady: true,
			        isError: true,
			        is404: true,
			        errorStatus: 404,
			        errorStatusText: "Not Found",
			      \}),
			    \},
			    frontity: \{
			      url: "http://my.frontity.test",
			    \},
			    yoast: \{
			      renderTags: "both",
			      transformLinks: \{
			        ignore: "^(wp-(json|admin|content|includes))|feed|comments|xmlrpc",
			        base: "http://localhost:8080",
			      \},
			    \},
			  \} as unknown) as State<Packages>);
			
			/**
			 * Return a mocked state with the following props:
			 *
			 * - router pointing to Hello World post ("/hello-world/").
			 * - source with a "hello-world" data object.
			 * - Frontity site's URL is http://my.frontity.test.
			 * - Yoast package has default settings.
			 *
			 * @returns Frontity state.
			 */
			const getStateHelloWorld = () =>
			  ((\{
			    router: \{
			      link: "/hello-world/",
			    \},
			    source: \{
			      get: () => (\{
			        link: "/hello-word/",
			        route: "/hello-word/",
			        page: 1,
			        query: \{\},
			        isFetching: false,
			        isReady: true,
			        isPostType: true,
			        isPost: true,
			        type: "post",
			        id: 1,
			      \}),
			      post: \{
			        1: \{
			          type: "post",
			          id: 1,
			          slug: "hello-world",
			          link: "/hello-world/",
			          ["yoast_head"]: \`
			          <title>Hello World &ndash; WP Test Site</title>
			          <meta property="og:url" content="http://localhost:8080/hello-world/">
			          <link rel="canonical" href="http://localhost:8080/hello-world/">
			          <script type="application/ld+json">
			          \{
			            "@graph":[
			              \{
			                "@id":"http://localhost:8080/#website",
			                "url":"http://localhost:8080/"
			              \}
			            ]
			          \}
			          </script>
			          \`,
			        \},
			      \},
			    \},
			    frontity: \{
			      url: "http://my.frontity.test",
			    \},
			    yoast: \{
			      renderTags: "both",
			      transformLinks: \{
			        ignore: "^(wp-(json|admin|content|includes))|feed|comments|xmlrpc",
			        base: "http://localhost:8080",
			      \},
			    \},
			  \} as unknown) as State<Packages>);
			
			/**
			 * Return mocked libraries with just the Html2React component, which is needed
			 * by the Yoast package.
			 *
			 * @returns Frontity libraries.
			 *
			 */
			const getLibraries = () =>
			  ((\{
			    html2react: \{
			      Component: Html2React.libraries.html2react.Component,
			    \},
			  \} as unknown) as Packages["libraries"]);
			
			/**
			 * Render the Yoast component and return the \`helmet\` property of a
			 * \`helmetContext\` object, ready for tests.
			 *
			 * @param props - Object with \`state\` and \`libraries\` props from Frontity.
			 * @returns The \`helmet\` property of \`helmetContext\`.
			 */
			const renderYoastHead = (\{ state, libraries \}) => \{
			  const helmetContext = \{\};
			  TestRenderer.create(
			    <HelmetProvider context=\{helmetContext\}>
			      <ConnectProvider value=\{\{ state, libraries \}\}>
			        <Yoast />
			      </ConnectProvider>
			    </HelmetProvider>
			  ).toJSON();
			  return (helmetContext as FilledContext).helmet;
			\};
			
			/**
			 * Yoast package tests.
			 */
			describe("Yoast", () => \{
			  it("renders nothing if there isn't \`yoast_head\` field", () => \{
			    const state = getState404();
			    const libraries = getLibraries();
			    const head = renderYoastHead(\{ state, libraries \});
			
			    expect(head.title.toString()).toMatchInlineSnapshot(
			      \`"<title data-rh=\\\\"true\\\\"></title>"\`
			    );
			    expect(head.link.toString()).toMatchInlineSnapshot(\`""\`);
			    expect(head.meta.toString()).toMatchInlineSnapshot(\`""\`);
			    expect(head.script.toString()).toMatchInlineSnapshot(\`""\`);
			  \});
			
			  it("renders head tags (changing links by default)", () => \{
			    const state = getStateHelloWorld();
			    const libraries = getLibraries();
			    const head = renderYoastHead(\{ state, libraries \});
			
			    expect(head.title.toString()).toMatchInlineSnapshot(
			      \`"<title data-rh=\\\\"true\\\\">Hello World  WP Test Site</title>"\`
			    );
			    expect(head.link.toString()).toMatchInlineSnapshot(
			      \`"<link data-rh=\\\\"true\\\\" rel=\\\\"canonical\\\\" href=\\\\"http://my.frontity.test/hello-world/\\\\"/>"\`
			    );
			    expect(head.meta.toString()).toMatchInlineSnapshot(
			      \`"<meta data-rh=\\\\"true\\\\" property=\\\\"og:url\\\\" content=\\\\"http://my.frontity.test/hello-world/\\\\"/>"\`
			    );
			    expect(head.script.toString()).toMatchInlineSnapshot(\`
			      "<script data-rh=\\\\"true\\\\" type=\\\\"application/ld+json\\\\">
			                \{
			                  \\\\"@graph\\\\":[
			                    \{
			                      \\\\"@id\\\\":\\\\"http://my.frontity.test/#website\\\\",
			                      \\\\"url\\\\":\\\\"http://my.frontity.test/\\\\"
			                    \}
			                  ]
			                \}
			                </script>"
			    \`);
			  \});
			
			  it("renders head tags (without changing links)", () => \{
			    const state = getStateHelloWorld();
			    const libraries = getLibraries();
			
			    // Set Yoast settings.
			    state.yoast.transformLinks = false;
			
			    const head = renderYoastHead(\{ state, libraries \});
			
			    expect(head.title.toString()).toMatchInlineSnapshot(
			      \`"<title data-rh=\\\\"true\\\\">Hello World  WP Test Site</title>"\`
			    );
			    expect(head.link.toString()).toMatchInlineSnapshot(
			      \`"<link data-rh=\\\\"true\\\\" rel=\\\\"canonical\\\\" href=\\\\"http://localhost:8080/hello-world/\\\\"/>"\`
			    );
			    expect(head.meta.toString()).toMatchInlineSnapshot(
			      \`"<meta data-rh=\\\\"true\\\\" property=\\\\"og:url\\\\" content=\\\\"http://localhost:8080/hello-world/\\\\"/>"\`
			    );
			    expect(head.script.toString()).toMatchInlineSnapshot(\`
			      "<script data-rh=\\\\"true\\\\" type=\\\\"application/ld+json\\\\">
			                \{
			                  \\\\"@graph\\\\":[
			                    \{
			                      \\\\"@id\\\\":\\\\"http://localhost:8080/#website\\\\",
			                      \\\\"url\\\\":\\\\"http://localhost:8080/\\\\"
			                    \}
			                  ]
			                \}
			                </script>"
			    \`);
			  \});
			
			  it("renders all tags in SSR (renderTags: server)", () => \{
			    const state = getStateHelloWorld();
			    const libraries = getLibraries();
			
			    // Set Yoast settings.
			    state.yoast.renderTags = "server";
			
			    const head = renderYoastHead(\{ state, libraries \});
			
			    expect(head.title.toString()).toMatchInlineSnapshot(
			      \`"<title data-rh=\\\\"true\\\\">Hello World  WP Test Site</title>"\`
			    );
			    expect(head.link.toString()).toMatchInlineSnapshot(
			      \`"<link data-rh=\\\\"true\\\\" rel=\\\\"canonical\\\\" href=\\\\"http://my.frontity.test/hello-world/\\\\"/>"\`
			    );
			    expect(head.meta.toString()).toMatchInlineSnapshot(
			      \`"<meta data-rh=\\\\"true\\\\" property=\\\\"og:url\\\\" content=\\\\"http://my.frontity.test/hello-world/\\\\"/>"\`
			    );
			    expect(head.script.toString()).toMatchInlineSnapshot(\`
			      "<script data-rh=\\\\"true\\\\" type=\\\\"application/ld+json\\\\">
			                \{
			                  \\\\"@graph\\\\":[
			                    \{
			                      \\\\"@id\\\\":\\\\"http://my.frontity.test/#website\\\\",
			                      \\\\"url\\\\":\\\\"http://my.frontity.test/\\\\"
			                    \}
			                  ]
			                \}
			                </script>"
			    \`);
			  \});
			
			  it("renders only the title in CSR (renderTags: server)", () => \{
			    const state = getStateHelloWorld();
			    const libraries = getLibraries();
			
			    // Set Yoast settings.
			    state.yoast.renderTags = "server";
			
			    // Set rendering state to CSR.
			    state.frontity.rendering = "csr";
			
			    // Mock the Html2React component.
			    libraries.html2react.Component = jest.fn();
			
			    const head = renderYoastHead(\{ state, libraries \});
			
			    expect(head.title.toString()).toMatchInlineSnapshot(
			      \`"<title data-rh=\\\\"true\\\\">Hello World  WP Test Site</title>"\`
			    );
			    expect(head.link.toString()).toMatchInlineSnapshot(\`""\`);
			    expect(head.meta.toString()).toMatchInlineSnapshot(\`""\`);
			    expect(head.script.toString()).toMatchInlineSnapshot(\`""\`);
			    expect(libraries.html2react.Component).not.toHaveBeenCalled();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'frontity_frontity\\packages\\yoast\\src\\__tests__\\yoast.tests.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;

		expect(tests.length).toBe(5)
    });
});
