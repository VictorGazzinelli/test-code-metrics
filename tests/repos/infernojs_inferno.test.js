const { extractFromSource } = require('../../src/extractor');

describe('infernojs_inferno', () => {
    it('infernojs_inferno\\packages\\inferno\\__tests__\\animationHooks.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, InfernoNode, render \} from 'inferno';
			
			describe('animation hooks', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  /**
			   * This is how component animation hooks work:
			   *
			   * On node creation, if there is a callback, a reference to the DOM-node is passed to that callback which allows for CSS-
			   * animations to be applied.
			   *
			   * On node removal, if there is a callback, the node isn't actually removed until the callback has finished.
			   *
			   * On node move, if there is a callback, the original node is cloned and both a reference to the cloned node and the new
			   * node are passed to the callback allowing CSS-animations to be performed.
			   *
			   * ** Entrypoints **
			   * - mounting.ts
			   * - unmounnting.ts
			   *
			   * ** Scope **
			   * We will start by implementing this for class components. Animations are expensive so it is probably a reasonable
			   * tradeoff to force the use of class componnents.
			   *
			   * QUESTION: How do we handle nested animations?
			   * Normally we only want to animated the outermost animation, but there are situation when the dev might want to
			   * do this differenty. Should we:
			   * - always block animations in children?
			   * - allow the dev to specify?
			   *
			   * Ex. you have a page animation and also animations on items in that page.
			   * ANSWER: I will block all animations down stream for starters. Giving an option requires A LOT of thought on
			   * edge cases.
			   *
			   * QUESTION: What if we add a set of siblings in a list, then all of them should animate, no?
			   * DONE: Investigate how to solve this.
			   * ANSWER: Animations should be a tree and only the highest node animates, but all siblings will animate
			   *
			   * DONE: Fix code path when removing last item in a list using clearDOM(dom) optmisation
			   * DONE: The callback is lost when transition is completed by the timeout
			   * QUESTION: Should I require the component to have a key?
			   * ANSWER: No, they should only be required in lists.
			   * DONE: What happens if order of DOM is changed during animation?
			   * DONE: remove intermediate elements during animation in list
			   * DONE: randomly reassign keys in a list (before/during animation)
			   * DONE: randomly sort list during animation
			   * DONE: shuffle keys
			   * DONE: The keyed patching appears to add children despite existing nodes with same key
			   * DONE: When rerendering a list 1,3,4,5,6 to 1,2,3,4,5 there are issues in the patching algorithm where 6 is left in DOM
			   * STARTED: Compare with tests in patchKeyedChildren.spec.js
			   * TODO: Investigate adding animations in https://github.com/infernojs/inferno/tree/master/docs/uibench-reactlike
			   * TODO: Add an animation blocking parent component to example
			   *
			   */
			
			  it('should NOT call "componentWillMove" when component is inserted into DOM', () => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public componentWillMove() \{
			        spyer('willMove');
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(1);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			  \});
			  it('should NOT call "componentWillMove" when component is removed from DOM', () => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public componentWillMove() \{
			        spyer('willMove');
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(<App />, container);
			
			    render(null, container);
			
			    expect(spyer).toHaveBeenCalledTimes(1);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			  \});
			
			  it('should call "componentWillMove" when component is about to be moved in DOM', () => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public componentWillMove() \{
			        spyer('willMove');
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div>\{this.props.children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <App key="1">1</App>
			        <App key="2">2</App>
			      </div>,
			      container
			    );
			    expect(container.textContent).toEqual('12');
			
			    render(
			      <div>
			        <App key="2">2</App>
			        <App key="1">1</App>
			      </div>,
			      container
			    );
			
			    expect(container.textContent).toEqual('21');
			    // Only the first element needs to perform a DOM move
			    // The second element is animated by parent checking positions before and after move
			    expect(spyer).toHaveBeenCalledTimes(3);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(2)).toEqual(['willMove']);
			  \});
			
			  it('should call "componentWillMove" when component is about to be moved in DOM', () => \{
			    const spyer = jasmine.createSpy();
			
			    class App extends Component<unknown, unknown> \{
			      public componentWillMove(_parentVNode, _parent, dom) \{
			        spyer('willMove');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div>\{this.props.children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <App key="1">1</App>
			        <App key="2">2</App>
			        <App key="3">3</App>
			      </div>,
			      container
			    );
			    expect(container.textContent).toEqual('123');
			
			    render(
			      <div>
			        <App key="2">2</App>
			        <App key="3">3</App>
			        <App key="1">1</App>
			      </div>,
			      container
			    );
			
			    expect(container.textContent).toEqual('231');
			    // Only the first element needs to perform a DOM move
			    // The second element is animated by parent checking positions before and after move
			    expect(spyer).toHaveBeenCalledTimes(4);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(2)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(3)).toEqual(['willMove']);
			  \});
			
			  it('should call "componentWillMove" when component is about to be moved in DOM', () => \{
			    const spyer = jasmine.createSpy();
			    let parentDom;
			    class App extends Component \{
			      public componentWillMove(_parentVNode, parent, dom) \{
			        spyer('willMove');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			        parentDom = parentDom || parent;
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div>\{this.props.children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <App key="1">1</App>
			        <App key="2">2</App>
			        <App key="3">3</App>
			        <App key="4">4</App>
			      </div>,
			      container
			    );
			    expect(container.textContent).toEqual('1234');
			
			    render(
			      <div>
			        <App key="4">4</App>
			        <App key="3">3</App>
			        <App key="2">2</App>
			        <App key="1">1</App>
			      </div>,
			      container
			    );
			
			    expect(spyer).toHaveBeenCalledTimes(7);
			    // Three elements need to perform a DOM move
			    // The fourth element is animated by parent checking positions before and after move
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(2)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(3)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(4)).toEqual(['willMove']);
			    expect(spyer.calls.argsFor(5)).toEqual(['willMove']);
			    expect(spyer.calls.argsFor(6)).toEqual(['willMove']);
			    expect(container.textContent).toEqual('4321');
			  \});
			
			  it('should call "componentDidAppear" when component has been inserted into DOM', () => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public componentDidAppear(dom) \{
			        spyer('didAppear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(2);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['didAppear']);
			  \});
			
			  it('should only call parent "componentDidAppear" when component tree has been inserted into DOM', () => \{
			    const spyer = jasmine.createSpy();
			    class Child extends Component \{
			      public componentDidAppear() \{
			        spyer('no-op');
			      \}
			      public componentDidMount() \{
			        spyer('childDidMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    class App extends Component \{
			      public componentDidAppear(dom) \{
			        spyer('didAppear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return (
			          <div>
			            <Child />
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(3);
			    expect(spyer.calls.argsFor(0)).toEqual(['childDidMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(2)).toEqual(['didAppear']);
			  \});
			
			  it('should only call "componentDidAppear" when child component has been inserted into DOM', (done) => \{
			    const spyer = jasmine.createSpy();
			    class Child extends Component \{
			      public componentDidAppear() \{
			        spyer('childDidAppear');
			      \}
			      public componentDidMount() \{
			        spyer('childDidMount');
			      \}
			      public render() \{
			        return <div>\{this.props.children\}</div>;
			      \}
			    \}
			
			    interface AppState \{
			      items: number[];
			    \}
			
			    class App extends Component<unknown, AppState> \{
			      public state: AppState;
			
			      constructor() \{
			        super(...arguments);
			        this.state = \{
			          items: [1]
			        \};
			      \}
			
			      public componentDidMount() \{
			        spyer('didMount');
			        setTimeout(() => \{
			          this.setState(\{
			            items: [1, 2]
			          \});
			          // Make sure inferno is done and then check the results
			          setTimeout(finished, 5);
			        \}, 5);
			      \}
			
			      public render() \{
			        return (
			          <div>
			            \{this.state.items.map((i) => (
			              <Child key=\{i\}>\{i\}</Child>
			            ))\}
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    const finished = () => \{
			      expect(spyer).toHaveBeenCalledTimes(5);
			      expect(spyer.calls.argsFor(0)).toEqual(['childDidMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(2)).toEqual(['childDidAppear']);
			      expect(spyer.calls.argsFor(3)).toEqual(['childDidMount']);
			      expect(spyer.calls.argsFor(4)).toEqual(['childDidAppear']);
			      expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div></div>');
			      done();
			    \};
			  \});
			
			  it('should call all "componentDidAppear" when multiple siblings have been inserted into DOM', () => \{
			    const spyer = jasmine.createSpy();
			    class Child extends Component \{
			      public componentDidAppear(dom) \{
			        spyer('childDidAppear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    class App extends Component \{
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return (
			          <div>
			            <Child />
			            <Child />
			            <Child />
			            <Child />
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(5);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['childDidAppear']);
			    expect(spyer.calls.argsFor(2)).toEqual(['childDidAppear']);
			    expect(spyer.calls.argsFor(3)).toEqual(['childDidAppear']);
			    expect(spyer.calls.argsFor(4)).toEqual(['childDidAppear']);
			  \});
			
			  it('should call "componentWillDisappear" when component is about to be removed from DOM', () => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public componentWillDisappear(dom, done) \{
			        spyer('willDisappear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			        expect(done instanceof Function).toEqual(true);
			        done();
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(<App />, container);
			
			    render(null, container);
			
			    expect(spyer).toHaveBeenCalledTimes(2);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['willDisappear']);
			  \});
			
			  it('should handle async callbacks from "componentWillDisappear"', (done) => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public componentWillDisappear(dom, callback) \{
			        spyer('willDisappear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			        expect(callback instanceof Function).toEqual(true);
			        setTimeout(() => \{
			          callback();
			          setTimeout(() => didFinish(), 10);
			        \}, 10);
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(<App />, container);
			
			    render(null, container);
			
			    function didFinish() \{
			      expect(spyer).toHaveBeenCalledTimes(2);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['willDisappear']);
			      done();
			    \}
			  \});
			
			  it('should handle async callbacks "componentWillDisappear" when removing the two last elements in list', (done) => \{
			    /**
			     * This test is hard to get to consistently fail. It should trigger
			     * clearDOM from last animation callback prior to deferComponentClassRemoval
			     * of at least one item. But it does work as expected now
			     * Change
			     * clearVNodeDOM(vNode, parentDOM, true);
			     * to
			     * clearVNodeDOM(vNode, parentDOM, false);
			     * in
			     * function deferComponentClassRemoval
			     * to force failure
			     */
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public state = \{
			        items: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
			      \};
			
			      public render() \{
			        if (this.state.items.length > 0) \{
			          setTimeout(() => \{
			            const items = this.state.items;
			            items.pop();
			            this.setState(\{ items \});
			          \});
			        \}
			
			        if (this.state.items.length === 0) \{
			          return <div />;
			        \}
			
			        return (
			          <div>
			            \{this.state.items.map((i) => (
			              <Item key=\{i\} index=\{i\} />
			            ))\}
			          </div>
			        );
			      \}
			    \}
			
			    interface ItemProps \{
			      index: number;
			    \}
			
			    class Item extends Component<ItemProps> \{
			      public componentWillDisappear(_dom, callback) \{
			        spyer('willDisappear ' + this.props.index);
			
			        let timeout = 10;
			        if (this.props.index === 0) \{
			          timeout = 0;
			        \}
			        setTimeout(() => \{
			          callback();
			        \}, timeout);
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(<App />, container);
			
			    const checkRenderComplete_ONE = () => \{
			      if (container.innerHTML !== '<div></div>') \{
			        return setTimeout(checkRenderComplete_ONE, 10);
			      \}
			      expect(spyer).toHaveBeenCalledTimes(40);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(19)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(20)).toEqual(['willDisappear 19']);
			      expect(spyer.calls.argsFor(39)).toEqual(['willDisappear 0']);
			      done();
			    \};
			    checkRenderComplete_ONE();
			  \});
			
			  it('should handle async callbacks from "componentWillDisappear" and mounting components with "componentDidAppear"', (done) => \{
			    const spyer = jasmine.createSpy();
			    // Always call the componentWillDisappear callback after last render
			    let lastRenderDone = false;
			    let callMeAfterLastRender;
			
			    interface AppProps \{
			      forceDone?: boolean;
			    \}
			
			    class App extends Component<AppProps> \{
			      public componentDidAppear(dom) \{
			        spyer('didAppear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			      \}
			      public componentWillDisappear(dom, callback) \{
			        spyer('willDisappear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			        expect(callback instanceof Function).toEqual(true);
			
			        if (this.props.forceDone) \{
			          callback();
			        \} else \{
			          setTimeout(() => \{
			            callMeAfterLastRender = () => \{
			              callback();
			              setTimeout(() => didFinish(), 10);
			            \};
			            // tslint:disable-next-line:no-unused-expression
			            lastRenderDone && callMeAfterLastRender();
			          \}, 10);
			        \}
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(<App />, container);
			    render(null, container);
			    // forceDone completes the willDissapear hook immediately
			    render(<App forceDone />, container);
			
			    expect(container.innerHTML).toBe('<div></div><div></div>');
			
			    lastRenderDone = true;
			    // tslint:disable-next-line:no-unused-expression
			    callMeAfterLastRender && callMeAfterLastRender();
			
			    function didFinish() \{
			      expect(spyer).toHaveBeenCalledTimes(5);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['didAppear']);
			      expect(spyer.calls.argsFor(2)).toEqual(['willDisappear']);
			      expect(spyer.calls.argsFor(3)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(4)).toEqual(['didAppear']);
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			      done();
			    \}
			  \});
			
			  it('should handle async callbacks even when parent is removed during animation', (done) => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      public componentWillDisappear(dom, callback) \{
			        spyer('willDisappear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			        expect(callback instanceof Function).toEqual(true);
			        setTimeout(() => \{
			          callback();
			        \}, 10);
			      \}
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    render(
			      <div>
			        <App />
			        <App />
			      </div>,
			      container
			    );
			    render(
			      <div>
			        <App />
			      </div>,
			      container
			    );
			    render(null, container);
			
			    expect(container.innerHTML).not.toEqual('');
			    // Wait for all async operations to finish
			    const checkRenderComplete_ONE = () => \{
			      if (container.innerHTML !== '') \{
			        return setTimeout(checkRenderComplete_ONE, 10);
			      \}
			      expect(spyer).toHaveBeenCalledTimes(6);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(2)).toEqual(['willDisappear']);
			      expect(spyer.calls.argsFor(3)).toEqual(['willDisappear']);
			      expect(spyer.calls.argsFor(4)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(5)).toEqual(['willDisappear']);
			      done();
			    \};
			    checkRenderComplete_ONE();
			  \});
			
			  const template = function (child) \{
			    return <div>\{child\}</div>;
			  \};
			
			  it('should add all nodes', () => \{
			    const spyer = jasmine.createSpy();
			
			    render(template(generateKeyNodes([], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    // expect(spyer).toHaveBeenCalledTimes(4);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(8);
			  \});
			
			  it('should size up', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    // expect(spyer).toHaveBeenCalledTimes(4);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(8);
			  \});
			
			  it('should do smiple size down', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#2'], spyer)), container);
			    expect(container.textContent).toBe('#0#2');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    // expect(spyer).toHaveBeenCalledTimes(4);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(8);
			  \});
			
			  it('should size down', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1'], spyer)), container);
			    // expect(spyer).toHaveBeenCalledTimes(2);
			    expect(container.textContent).toBe('#0#1');
			    expect(container.firstChild.childNodes.length).toBe(2);
			
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1'], spyer)), container);
			
			    // expect(spyer).toHaveBeenCalledTimes(10);
			    expect(container.textContent).toBe('#0#1');
			    expect(container.firstChild.childNodes.length).toBe(2);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(12);
			  \});
			
			  it('should handle multiple removes of siblings combined with adds', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3', '#4', '#5'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#2', '#5', '#6'], spyer)), container);
			    // expect(spyer).toHaveBeenCalledTimes(2);
			    expect(container.textContent).toBe('#0#2#5#6');
			    expect(container.firstChild.childNodes.length).toBe(4);
			
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#10', '#11'], spyer)), container);
			
			    // expect(spyer).toHaveBeenCalledTimes(10);
			    expect(container.textContent).toBe('#10#11');
			    expect(container.firstChild.childNodes.length).toBe(2);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(12);
			  \});
			
			  it('should clear all nodes', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes([], spyer)), container);
			    expect(container.textContent).toBe('');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes([], spyer)), container);
			  \});
			
			  it('should work with mixed nodes', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['1', '#0', '#1', '#2'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key for start to end', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['a', '#0', '#1', '#2'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', 'a'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2a');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', 'a', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', 'a', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1a#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  /* Skipping spyer from here on */
			
			  it('should move a key', () => \{
			    render(template(generateKeyNodes(['#0', 'a', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1', 'a', '#3'])), container);
			    expect(container.textContent).toBe('#0#1a#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key with a size up', () => \{
			    render(template(generateKeyNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			  it('should move a key with a size down', () => \{
			    render(template(generateKeyNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should avoid unnecessary reordering', () => \{
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should work with keyed nodes', () => \{
			    render(template(generateKeyNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateKeyNodes([1, 2, 3, 4, 0])), container);
			    expect(container.textContent).toBe('12340');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should reorder keys', () => \{
			    render(template(generateKeyNodes(['1', '2', '3', '4', 'abc', '6', 'def', '7'])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			  \});
			  it('should remove one key at the start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['b', 'c'])), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should do a complex reverse', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateKeyNodes(['d', 'c', 'b', 'a'])), container);
			    expect(container.textContent).toBe('dcba');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should remove two keys at the start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['c'])), container);
			    expect(container.textContent).toBe('c');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key to start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should add two key to start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['c'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove one key at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should remove two keys at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['a'])), container);
			    expect(container.textContent).toBe('a');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add two key at the end', () => \{
			    render(template(generateKeyNodes(['a'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add to end, delete from center & reverse', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateKeyNodes(['e', 'd', 'c', 'a'])), container);
			    expect(container.textContent).toBe('edca');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should add to the beginning and remove', () => \{
			    render(template(generateKeyNodes(['c', 'd'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'e'])), container);
			    expect(container.textContent).toBe('abce');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should keep a central pivot', () => \{
			    render(template(generateKeyNodes(['1', '2', '3'])), container);
			    render(template(generateKeyNodes(['4', '2', '5'])), container);
			    expect(container.textContent).toBe('425');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should insert to the middle', () => \{
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'e'])), container);
			    expect(container.textContent).toBe('abe');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['a', 'p', 'e'])), container);
			    expect(container.textContent).toBe('ape');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should shuffle, insert and remove', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 'e', 'f', 'g'])), container);
			    render(template(generateKeyNodes(['b', 'c', 'a'])), container);
			    expect(container.textContent).toBe('bca');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove a element from the middle', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([1, 2, 4, 5])), container);
			    expect(container.textContent).toBe('1245');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a element forward', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([2, 3, 1, 4])), container);
			    expect(container.textContent).toBe('2314');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([3, 2, 1, 4])), container);
			    expect(container.textContent).toBe('3214');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([3, 2, 4, 1])), container);
			    expect(container.textContent).toBe('3241');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should move a element to the end', () => \{
			    render(template(generateKeyNodes([1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes([2, 3, 1])), container);
			    expect(container.textContent).toBe('231');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should move a element backwards', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([1, 4, 2, 3])), container);
			    expect(container.textContent).toBe('1423');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should swap first and last', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([4, 2, 3, 1])), container);
			    expect(container.textContent).toBe('4231');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should move to left and replace', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([4, 1, 2, 3, 6])), container);
			    expect(container.textContent).toBe('41236');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([4, 5, 2, 3, 0])), container);
			    expect(container.textContent).toBe('45230');
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			  \});
			
			  it('should move to left and leave a hole', () => \{
			    render(template(generateKeyNodes([1, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes([4, 6])), container);
			    expect(container.textContent).toBe('46');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should do something', () => \{
			    render(template(generateKeyNodes([0, 1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateKeyNodes([4, 3, 2, 1, 5, 0])), container);
			    expect(container.textContent).toBe('432150');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			
			  it('should cycle order correctly', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			    render(template(generateKeyNodes([2, 3, 4, 1])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('2341');
			    render(template(generateKeyNodes([3, 4, 1, 2])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('3412');
			    render(template(generateKeyNodes([4, 1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('4123');
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			  \});
			
			  it('should cycle order correctly in the other direction', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			    render(template(generateKeyNodes([4, 1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('4123');
			    render(template(generateKeyNodes([3, 4, 1, 2])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('3412');
			    render(template(generateKeyNodes([2, 3, 4, 1])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('2341');
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			  \});
			
			  it('should allow any character as a key', () => \{
			    render(template(generateKeyNodes(['<WEIRD/&\\\\key>'])), container);
			    render(template(generateKeyNodes(['INSANE/(/&\\\\key', '<CRAZY/&\\\\key>', '<WEIRD/&\\\\key>'])), container);
			    expect(container.textContent).toBe('INSANE/(/&\\\\key<CRAZY/&\\\\key><WEIRD/&\\\\key>');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should reorder nodes', () => \{
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['1', '2', '3', '4', 'abc', '6', 'def', '7'])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			  \});
			
			  it('should do a advanced shuffle - numbers and letters', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([1, 'e', 2, 'b', 'f', 'g', 'c', 'a', 3])), container);
			    expect(container.textContent).toBe('1e2bfgca3');
			    expect(container.firstChild.childNodes.length).toBe(9);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([0, 'e', 2, 'b', 'f', 'g', 'c', 'a', 4])), container);
			    expect(container.textContent).toBe('0e2bfgca4');
			    expect(container.firstChild.childNodes.length).toBe(9);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([1, 'e', 2, 'b', 'f', 'g', 'c', 'a', 3])), container);
			    expect(container.textContent).toBe('1e2bfgca3');
			    expect(container.firstChild.childNodes.length).toBe(9);
			  \});
			
			  it('should do a complex removal at the beginning', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['c', 'd'])), container);
			    expect(container.textContent).toBe('cd');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should do move and sync nodes from right to left', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['c', 'l', 1, 2, 3, 4, 5, 6, 7, 8, 9, 'd', 'g', 'b'])), container);
			    expect(container.textContent).toBe('cl123456789dgb');
			    expect(container.firstChild.childNodes.length).toBe(14);
			  \});
			
			  describe('Should handle massive large arrays', () => \{
			    let items;
			
			    beforeEach(function () \{
			      items = new Array(1000);
			      for (let i = 0; i < 1000; i++) \{
			        items[i] = i;
			      \}
			    \});
			
			    it('Should handle massive large arrays - initial', () => \{
			      render(template(generateKeyNodes(items)), container);
			
			      expect(container.textContent).toEqual(items.join(''));
			    \});
			
			    it('Should handle massive arrays shifting once by 2', () => \{
			      items = items.concat(items.splice(0, 2));
			      render(template(generateKeyNodes(items)), container);
			
			      expect(container.textContent).toEqual(items.join(''));
			    \});
			
			    for (let i = 0; i < 10; i++) \{
			      // eslint-disable-next-line
			      it('Should handle massive arrays shifting ' + i + ' times by ' + i, () => \{
			        for (let j = 0; j < i; j++) \{
			          items = items.concat(items.splice(i, j));
			        \}
			        render(template(generateKeyNodes(items)), container);
			        expect(container.textContent).toEqual(items.join(''));
			      \});
			    \}
			  \});
			
			  describe('Calendar like layout', () => \{
			    interface AnimatedProps \{
			      key: string;
			      children?: any;
			    \}
			
			    class Animated extends Component<AnimatedProps, unknown> \{
			      public componentDidAppear(_dom) \{
			        // Trigger animation code paths on add
			      \}
			      public componentWillDisappear(_dom, done) \{
			        // Trigger animation code paths on remove
			        done();
			      \}
			      public render(\{ children \}: AnimatedProps) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    function o(text) \{
			      return <Animated key=\{'o' + text\}>\{',o' + text\}</Animated>;
			    \}
			
			    function d(text) \{
			      return <Animated key=\{'d' + text\}>\{',d' + text\}</Animated>;
			    \}
			
			    function wk(text) \{
			      return <Animated key=\{'wk' + text\}>\{',wk' + text\}</Animated>;
			    \}
			
			    it('Should do complex suffle without duplications', () => \{
			      const layout1 = [
			        wk(31),
			        d(1),
			        d(2),
			        d(3),
			        d(4),
			        d(5),
			        d(6),
			        d(7),
			        wk(32),
			        d(8),
			        d(9),
			        d(10),
			        d(11),
			        d(12),
			        d(13),
			        d(14),
			        wk(33),
			        d(15),
			        d(16),
			        d(17),
			        d(18),
			        d(19),
			        d(20),
			        d(21),
			        wk(34),
			        d(22),
			        d(23),
			        d(24),
			        d(25),
			        d(26),
			        d(27),
			        d(28),
			        wk(35),
			        d(29),
			        d(30),
			        d(31),
			        o(1),
			        o(2),
			        o(3),
			        o(4),
			        wk(36),
			        o(5),
			        o(6),
			        o(7),
			        o(8),
			        o(9),
			        o(10),
			        o(11)
			      ];
			      render(template(layout1), container);
			
			      expect(container.textContent).toBe(
			        ',wk31,d1,d2,d3,d4,d5,d6,d7,wk32,d8,d9,d10,d11,d12,d13,d14,wk33,d15,d16,d17,d18,d19,d20,d21,wk34,d22,d23,d24,d25,d26,d27,d28,wk35,d29,d30,d31,o1,o2,o3,o4,wk36,o5,o6,o7,o8,o9,o10,o11'
			      );
			
			      const layout2 = [
			        wk(35),
			        o(29),
			        o(30),
			        o(31),
			        d(1),
			        d(2),
			        d(3),
			        d(4),
			        wk(36),
			        d(5),
			        d(6),
			        d(7),
			        d(8),
			        d(9),
			        d(10),
			        d(11),
			        wk(37),
			        d(12),
			        d(13),
			        d(14),
			        d(15),
			        d(16),
			        d(17),
			        d(18),
			        wk(38),
			        d(19),
			        d(20),
			        d(21),
			        d(22),
			        d(23),
			        d(24),
			        d(25),
			        wk(39),
			        d(26),
			        d(27),
			        d(28),
			        d(29),
			        d(30),
			        o(1),
			        o(2),
			        wk(40),
			        o(3),
			        o(4),
			        o(5),
			        o(6),
			        o(7),
			        o(8),
			        o(9)
			      ];
			      render(template(layout2), container);
			
			      expect(container.textContent).toBe(
			        ',wk35,o29,o30,o31,d1,d2,d3,d4,wk36,d5,d6,d7,d8,d9,d10,d11,wk37,d12,d13,d14,d15,d16,d17,d18,wk38,d19,d20,d21,d22,d23,d24,d25,wk39,d26,d27,d28,d29,d30,o1,o2,wk40,o3,o4,o5,o6,o7,o8,o9'
			      );
			    \});
			  \});
			\});
			
			function factory(spyer?: jasmine.Spy) \{
			  // TODO: Add componentWillMove
			  return class Animated extends Component<any, any> \{
			    public componentDidAppear(_dom) \{
			      if (spyer) \{
			        spyer('didAppear');
			      \}
			    \}
			    public componentWillDisappear(_dom, done) \{
			      if (spyer) \{
			        spyer('willDisappear');
			      \}
			
			      done();
			    \}
			    public render(\{ children \}) \{
			      return <div>\{children\}</div>;
			    \}
			  \};
			\}
			
			function generateKeyNodes(array: (string | number)[], spyer?) \{
			  let i: number = 0;
			  let id: string | number;
			  let key: string | number;
			  const children: InfernoNode[] = [];
			  let newKey: string | number | null;
			  const Tag = factory(spyer);
			
			  for (i = 0; i < array.length; i++) \{
			    id = key = array[i];
			    if (key !== null && (typeof key !== 'string' || key[0] !== '#')) \{
			      newKey = key;
			    \} else \{
			      newKey = null;
			    \}
			
			    children.push(
			      <Tag key=\{newKey\} id=\{String(id)\}>
			        \{id\}
			      </Tag>
			    );
			  \}
			  return children;
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\animationHooks.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(62)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\animationHooksFunc.spec.tsx', () => {
        const sourceCode = `
			/* tslint:disable:no-unused-expression */
			import \{ Component, InfernoNode, InfernoSingleNode, render \} from 'inferno';
			
			describe('animation hooks', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should call "onComponentDidAppear" when component has been inserted into DOM', () => \{
			    const spyer = jasmine.createSpy();
			
			    const Animated = () => \{
			      return <div />;
			    \};
			
			    const onComponentDidAppear = (dom, props) => \{
			      spyer('didAppear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			      expect(typeof props === 'object').toEqual(true);
			    \};
			
			    class App extends Component \{
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return <Animated onComponentDidAppear=\{onComponentDidAppear\} />;
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(2);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['didAppear']);
			  \});
			
			  it('should only call parent "onComponentDidAppear" when component tree has been inserted into DOM', () => \{
			    const spyer = jasmine.createSpy();
			
			    const Child = () => \{
			      return <div />;
			    \};
			
			    const childOnComponentDidAppear = (dom) => \{
			      spyer('no-op');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			    \};
			
			    const Parent = () => \{
			      return <Child onComponentDidAppear=\{childOnComponentDidAppear\} />;
			    \};
			
			    const parentOnComponentDidAppear = (dom) => \{
			      spyer('didAppear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			    \};
			
			    class App extends Component \{
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return (
			          <div>
			            <Parent onComponentDidAppear=\{parentOnComponentDidAppear\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(2);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['didAppear']);
			  \});
			
			  it('should only call "componentDidAppear" when child component has been inserted into DOM', (done) => \{
			    const spyer = jasmine.createSpy();
			
			    const Child = (props) => \{
			      return <div>\{props.children\}</div>;
			    \};
			
			    const childOnComponentDidMount = () => \{
			      spyer('childDidMount');
			    \};
			
			    const childOnComponentDidAppear = () => \{
			      spyer('childDidAppear');
			    \};
			
			    interface AppState \{
			      items: number[];
			    \}
			
			    class App extends Component<unknown, AppState> \{
			      public state: AppState;
			
			      constructor() \{
			        super(...arguments);
			        this.state = \{
			          items: [1]
			        \};
			      \}
			
			      public componentDidMount() \{
			        spyer('didMount');
			        setTimeout(() => \{
			          this.setState(\{
			            items: [1, 2]
			          \});
			          // Make sure inferno is done and then check the results
			          setTimeout(finished, 5);
			        \}, 5);
			      \}
			
			      public render() \{
			        return (
			          <div>
			            \{this.state.items.map((i) => (
			              <Child key=\{i\} onComponentDidAppear=\{childOnComponentDidAppear\} onComponentDidMount=\{childOnComponentDidMount\}>
			                \{i\}
			              </Child>
			            ))\}
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    const finished = () => \{
			      expect(spyer).toHaveBeenCalledTimes(5);
			      expect(spyer.calls.argsFor(0)).toEqual(['childDidMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(2)).toEqual(['childDidAppear']);
			      expect(spyer.calls.argsFor(3)).toEqual(['childDidMount']);
			      expect(spyer.calls.argsFor(4)).toEqual(['childDidAppear']);
			      expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div></div>');
			      done();
			    \};
			  \});
			
			  it('should call all "componentDidAppear" when multiple siblings have been inserted into DOM', () => \{
			    const spyer = jasmine.createSpy();
			
			    const Child = () => \{
			      return <div />;
			    \};
			
			    const onComponentDidAppear = (dom) => \{
			      spyer('childDidAppear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			    \};
			
			    class App extends Component \{
			      public componentDidMount() \{
			        spyer('didMount');
			      \}
			      public render() \{
			        return (
			          <div>
			            <Child onComponentDidAppear=\{onComponentDidAppear\} />
			            <Child onComponentDidAppear=\{onComponentDidAppear\} />
			            <Child onComponentDidAppear=\{onComponentDidAppear\} />
			            <Child onComponentDidAppear=\{onComponentDidAppear\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(5);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['childDidAppear']);
			    expect(spyer.calls.argsFor(2)).toEqual(['childDidAppear']);
			    expect(spyer.calls.argsFor(3)).toEqual(['childDidAppear']);
			    expect(spyer.calls.argsFor(4)).toEqual(['childDidAppear']);
			  \});
			
			  it('should call "componentWillDisappear" when component is about to be removed from DOM', () => \{
			    const spyer = jasmine.createSpy();
			    const App = () => \{
			      return <div />;
			    \};
			
			    const onComponentWillDisappear = (dom, props, callback) => \{
			      spyer('willDisappear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			      expect(callback instanceof Function).toEqual(true);
			      expect(typeof props === 'object').toEqual(true);
			      callback();
			    \};
			
			    const onComponentDidMount = () => \{
			      spyer('didMount');
			    \};
			
			    render(<App onComponentWillDisappear=\{onComponentWillDisappear\} onComponentDidMount=\{onComponentDidMount\} />, container);
			
			    render(null, container);
			
			    expect(spyer).toHaveBeenCalledTimes(2);
			    expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['willDisappear']);
			  \});
			
			  it('should handle async callbacks from "componentWillDisappear"', (done) => \{
			    const spyer = jasmine.createSpy();
			
			    const App = () => \{
			      return <div />;
			    \};
			
			    const onComponentWillDisappear = (dom, _props, callback) => \{
			      spyer('willDisappear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			      expect(callback instanceof Function).toEqual(true);
			      setTimeout(() => \{
			        callback();
			        setTimeout(() => didFinish(), 10);
			      \}, 10);
			    \};
			
			    const onComponentDidMount = () => \{
			      spyer('didMount');
			    \};
			
			    render(<App onComponentWillDisappear=\{onComponentWillDisappear\} onComponentDidMount=\{onComponentDidMount\} />, container);
			
			    render(null, container);
			
			    function didFinish() \{
			      expect(spyer).toHaveBeenCalledTimes(2);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['willDisappear']);
			      done();
			    \}
			  \});
			
			  it('should handle async callbacks "componentWillDisappear" when removing the two last elements in list', (done) => \{
			    /**
			     * This test is hard to get to consistently fail. It should trigger
			     * clearDOM from last animation callback prior to deferComponentClassRemoval
			     * of at least one item. But it does work as expected now
			     * Change
			     * clearVNodeDOM(vNode, parentDOM, true);
			     * to
			     * clearVNodeDOM(vNode, parentDOM, false);
			     * in
			     * function deferComponentClassRemoval
			     * to force failure
			     */
			    const spyer = jasmine.createSpy();
			
			    const Item = () => \{
			      return <div />;
			    \};
			
			    const getOnComponentWillDisappear = (index) => \{
			      return (_dom, _props, callback) => \{
			        spyer('willDisappear ' + index);
			
			        let timeout = 10;
			        if (index === 0) \{
			          timeout = 0;
			        \}
			        setTimeout(() => \{
			          callback();
			        \}, timeout);
			      \};
			    \};
			
			    const onComponentDidMount = () => \{
			      spyer('didMount');
			    \};
			
			    class App extends Component \{
			      public state = \{
			        items: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
			      \};
			
			      public render() \{
			        if (this.state.items.length > 0) \{
			          setTimeout(() => \{
			            const items = this.state.items;
			            items.pop();
			            this.setState(\{ items \});
			          \});
			        \}
			
			        if (this.state.items.length === 0) \{
			          return <div />;
			        \}
			
			        return (
			          <div>
			            \{this.state.items.map((i) => (
			              <Item key=\{i\} onComponentWillDisappear=\{getOnComponentWillDisappear(i)\} onComponentDidMount=\{onComponentDidMount\} />
			            ))\}
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    const checkRenderComplete_ONE = () => \{
			      if (container.innerHTML !== '<div></div>') \{
			        return setTimeout(checkRenderComplete_ONE, 100);
			      \}
			      expect(spyer).toHaveBeenCalledTimes(40);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(19)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(20)).toEqual(['willDisappear 19']);
			      expect(spyer.calls.argsFor(39)).toEqual(['willDisappear 0']);
			      done();
			    \};
			    checkRenderComplete_ONE();
			  \});
			
			  it('should handle async callbacks from "componentWillDisappear" and mounting components with "componentDidAppear"', (done) => \{
			    const spyer = jasmine.createSpy();
			    // Always call the componentWillDisappear callback after last render
			    let lastRenderDone = false;
			    let callMeAfterLastRender;
			
			    const App = () => \{
			      return <div />;
			    \};
			
			    const onComponentDidAppear = (dom) => \{
			      spyer('didAppear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			    \};
			
			    const getOnComponentWillDisappear = (forceDone) => (dom, _props, callback) => \{
			      spyer('willDisappear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			      expect(callback instanceof Function).toEqual(true);
			
			      if (forceDone) \{
			        callback();
			      \} else \{
			        setTimeout(() => \{
			          callMeAfterLastRender = () => \{
			            callback();
			            setTimeout(() => didFinish(), 10);
			          \};
			          lastRenderDone && callMeAfterLastRender();
			        \}, 10);
			      \}
			    \};
			
			    const onComponentDidMount = () => \{
			      spyer('didMount');
			    \};
			
			    render(
			      <App
			        onComponentDidAppear=\{onComponentDidAppear\}
			        onComponentDidMount=\{onComponentDidMount\}
			        onComponentWillDisappear=\{getOnComponentWillDisappear(false)\}
			      />,
			      container
			    );
			    render(null, container);
			    // forceDone completes the willDissapear hook immediately
			    render(
			      <App
			        onComponentDidAppear=\{onComponentDidAppear\}
			        onComponentDidMount=\{onComponentDidMount\}
			        onComponentWillDisappear=\{getOnComponentWillDisappear(true)\}
			      />,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div></div><div></div>');
			
			    lastRenderDone = true;
			    callMeAfterLastRender && callMeAfterLastRender();
			
			    function didFinish() \{
			      expect(spyer).toHaveBeenCalledTimes(5);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['didAppear']);
			      expect(spyer.calls.argsFor(2)).toEqual(['willDisappear']);
			      expect(spyer.calls.argsFor(3)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(4)).toEqual(['didAppear']);
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			      done();
			    \}
			  \});
			
			  it('should handle async callbacks even when parent is removed during animation', (done) => \{
			    const spyer = jasmine.createSpy();
			    const App = () => \{
			      return <div />;
			    \};
			
			    const onComponentWillDisappear = (dom, _props, callback) => \{
			      spyer('willDisappear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			      expect(callback instanceof Function).toEqual(true);
			      setTimeout(() => \{
			        callback();
			      \}, 10);
			    \};
			
			    const onComponentDidMount = () => \{
			      spyer('didMount');
			    \};
			
			    render(
			      <div>
			        <App onComponentDidMount=\{onComponentDidMount\} onComponentWillDisappear=\{onComponentWillDisappear\} />
			        <App onComponentDidMount=\{onComponentDidMount\} onComponentWillDisappear=\{onComponentWillDisappear\} />
			      </div>,
			      container
			    );
			    render(
			      <div>
			        <App onComponentDidMount=\{onComponentDidMount\} onComponentWillDisappear=\{onComponentWillDisappear\} />
			      </div>,
			      container
			    );
			    render(null, container);
			
			    expect(container.innerHTML).not.toEqual('');
			    // Wait for all async operations to finish
			    const checkRenderComplete_ONE = () => \{
			      if (container.innerHTML !== '') \{
			        return setTimeout(checkRenderComplete_ONE, 10);
			      \}
			      expect(spyer).toHaveBeenCalledTimes(6);
			      expect(spyer.calls.argsFor(0)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(1)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(2)).toEqual(['willDisappear']);
			      expect(spyer.calls.argsFor(3)).toEqual(['willDisappear']);
			      expect(spyer.calls.argsFor(4)).toEqual(['didMount']);
			      expect(spyer.calls.argsFor(5)).toEqual(['willDisappear']);
			      done();
			    \};
			    checkRenderComplete_ONE();
			  \});
			
			  it('should call "willMove" when component is about to be moved to another part of DOM', () => \{\});
			
			  const template = function (child) \{
			    return <div>\{child\}</div>;
			  \};
			
			  it('should add all nodes', () => \{
			    const spyer = jasmine.createSpy();
			
			    render(template(generateKeyNodes([], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    // expect(spyer).toHaveBeenCalledTimes(4);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(8);
			  \});
			
			  it('should size up', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    // expect(spyer).toHaveBeenCalledTimes(4);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(8);
			  \});
			
			  it('should do smiple size down', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#2'], spyer)), container);
			    expect(container.textContent).toBe('#0#2');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    // expect(spyer).toHaveBeenCalledTimes(4);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(8);
			  \});
			
			  it('should size down', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1'], spyer)), container);
			    // expect(spyer).toHaveBeenCalledTimes(2);
			    expect(container.textContent).toBe('#0#1');
			    expect(container.firstChild.childNodes.length).toBe(2);
			
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1'], spyer)), container);
			
			    // expect(spyer).toHaveBeenCalledTimes(10);
			    expect(container.textContent).toBe('#0#1');
			    expect(container.firstChild.childNodes.length).toBe(2);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(12);
			  \});
			
			  it('should handle multiple removes of siblings combined with adds', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3', '#4', '#5'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#2', '#5', '#6'], spyer)), container);
			    // expect(spyer).toHaveBeenCalledTimes(2);
			    expect(container.textContent).toBe('#0#2#5#6');
			    expect(container.firstChild.childNodes.length).toBe(4);
			
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#10', '#11'], spyer)), container);
			
			    // expect(spyer).toHaveBeenCalledTimes(10);
			    expect(container.textContent).toBe('#10#11');
			    expect(container.firstChild.childNodes.length).toBe(2);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    // expect(spyer).toHaveBeenCalledTimes(12);
			  \});
			
			  it('should clear all nodes', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes([], spyer)), container);
			    expect(container.textContent).toBe('');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes([], spyer)), container);
			  \});
			
			  it('should work with mixed nodes', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['1', '#0', '#1', '#2'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key for start to end', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['a', '#0', '#1', '#2'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', 'a'], spyer)), container);
			    expect(container.textContent).toBe('#0#1#2a');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key', () => \{
			    const spyer = jasmine.createSpy();
			    render(template(generateKeyNodes(['#0', 'a', '#2', '#3'], spyer)), container);
			    render(template(generateKeyNodes(['#0', '#1', 'a', '#3'], spyer)), container);
			    expect(container.textContent).toBe('#0#1a#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  /* Skipping spyer from here on */
			
			  it('should move a key', () => \{
			    render(template(generateKeyNodes(['#0', 'a', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1', 'a', '#3'])), container);
			    expect(container.textContent).toBe('#0#1a#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key with a size up', () => \{
			    render(template(generateKeyNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			  it('should move a key with a size down', () => \{
			    render(template(generateKeyNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should avoid unnecessary reordering', () => \{
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should work with keyed nodes', () => \{
			    render(template(generateKeyNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateKeyNodes([1, 2, 3, 4, 0])), container);
			    expect(container.textContent).toBe('12340');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should reorder keys', () => \{
			    render(template(generateKeyNodes(['1', '2', '3', '4', 'abc', '6', 'def', '7'])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			  \});
			  it('should remove one key at the start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['b', 'c'])), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should do a complex reverse', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateKeyNodes(['d', 'c', 'b', 'a'])), container);
			    expect(container.textContent).toBe('dcba');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should remove two keys at the start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['c'])), container);
			    expect(container.textContent).toBe('c');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key to start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should add two key to start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['c'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove one key at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should remove two keys at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['a'])), container);
			    expect(container.textContent).toBe('a');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add two key at the end', () => \{
			    render(template(generateKeyNodes(['a'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add to end, delete from center & reverse', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateKeyNodes(['e', 'd', 'c', 'a'])), container);
			    expect(container.textContent).toBe('edca');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should add to the beginning and remove', () => \{
			    render(template(generateKeyNodes(['c', 'd'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'e'])), container);
			    expect(container.textContent).toBe('abce');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should keep a central pivot', () => \{
			    render(template(generateKeyNodes(['1', '2', '3'])), container);
			    render(template(generateKeyNodes(['4', '2', '5'])), container);
			    expect(container.textContent).toBe('425');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should insert to the middle', () => \{
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'e'])), container);
			    expect(container.textContent).toBe('abe');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['a', 'p', 'e'])), container);
			    expect(container.textContent).toBe('ape');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should shuffle, insert and remove', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 'e', 'f', 'g'])), container);
			    render(template(generateKeyNodes(['b', 'c', 'a'])), container);
			    expect(container.textContent).toBe('bca');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove a element from the middle', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([1, 2, 4, 5])), container);
			    expect(container.textContent).toBe('1245');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a element forward', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([2, 3, 1, 4])), container);
			    expect(container.textContent).toBe('2314');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([3, 2, 1, 4])), container);
			    expect(container.textContent).toBe('3214');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([3, 2, 4, 1])), container);
			    expect(container.textContent).toBe('3241');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should move a element to the end', () => \{
			    render(template(generateKeyNodes([1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes([2, 3, 1])), container);
			    expect(container.textContent).toBe('231');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should move a element backwards', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([1, 4, 2, 3])), container);
			    expect(container.textContent).toBe('1423');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should swap first and last', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([4, 2, 3, 1])), container);
			    expect(container.textContent).toBe('4231');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should move to left and replace', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([4, 1, 2, 3, 6])), container);
			    expect(container.textContent).toBe('41236');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([4, 5, 2, 3, 0])), container);
			    expect(container.textContent).toBe('45230');
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			  \});
			
			  it('should move to left and leave a hole', () => \{
			    render(template(generateKeyNodes([1, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes([4, 6])), container);
			    expect(container.textContent).toBe('46');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should do something', () => \{
			    render(template(generateKeyNodes([0, 1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateKeyNodes([4, 3, 2, 1, 5, 0])), container);
			    expect(container.textContent).toBe('432150');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			
			  it('should cycle order correctly', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			    render(template(generateKeyNodes([2, 3, 4, 1])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('2341');
			    render(template(generateKeyNodes([3, 4, 1, 2])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('3412');
			    render(template(generateKeyNodes([4, 1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('4123');
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			  \});
			
			  it('should cycle order correctly in the other direction', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			    render(template(generateKeyNodes([4, 1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('4123');
			    render(template(generateKeyNodes([3, 4, 1, 2])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('3412');
			    render(template(generateKeyNodes([2, 3, 4, 1])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('2341');
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			  \});
			
			  it('should allow any character as a key', () => \{
			    render(template(generateKeyNodes(['<WEIRD/&\\\\key>'])), container);
			    render(template(generateKeyNodes(['INSANE/(/&\\\\key', '<CRAZY/&\\\\key>', '<WEIRD/&\\\\key>'])), container);
			    expect(container.textContent).toBe('INSANE/(/&\\\\key<CRAZY/&\\\\key><WEIRD/&\\\\key>');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should reorder nodes', () => \{
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['1', '2', '3', '4', 'abc', '6', 'def', '7'])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			  \});
			
			  it('should do a advanced shuffle - numbers and letters', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([1, 'e', 2, 'b', 'f', 'g', 'c', 'a', 3])), container);
			    expect(container.textContent).toBe('1e2bfgca3');
			    expect(container.firstChild.childNodes.length).toBe(9);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([0, 'e', 2, 'b', 'f', 'g', 'c', 'a', 4])), container);
			    expect(container.textContent).toBe('0e2bfgca4');
			    expect(container.firstChild.childNodes.length).toBe(9);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([1, 'e', 2, 'b', 'f', 'g', 'c', 'a', 3])), container);
			    expect(container.textContent).toBe('1e2bfgca3');
			    expect(container.firstChild.childNodes.length).toBe(9);
			  \});
			
			  it('should do a complex removal at the beginning', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['c', 'd'])), container);
			    expect(container.textContent).toBe('cd');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should do move and sync nodes from right to left', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['c', 'l', 1, 2, 3, 4, 5, 6, 7, 8, 9, 'd', 'g', 'b'])), container);
			    expect(container.textContent).toBe('cl123456789dgb');
			    expect(container.firstChild.childNodes.length).toBe(14);
			  \});
			
			  describe('Should handle massive large arrays', () => \{
			    let items;
			
			    beforeEach(function () \{
			      items = new Array(1000);
			      for (let i = 0; i < 1000; i++) \{
			        items[i] = i;
			      \}
			    \});
			
			    it('Should handle massive large arrays - initial', () => \{
			      render(template(generateKeyNodes(items)), container);
			
			      expect(container.textContent).toEqual(items.join(''));
			    \});
			
			    it('Should handle massive arrays shifting once by 2', () => \{
			      items = items.concat(items.splice(0, 2));
			      render(template(generateKeyNodes(items)), container);
			
			      expect(container.textContent).toEqual(items.join(''));
			    \});
			
			    for (let i = 0; i < 10; i++) \{
			      // eslint-disable-next-line
			      it('Should handle massive arrays shifting ' + i + ' times by ' + i, () => \{
			        for (let j = 0; j < i; j++) \{
			          items = items.concat(items.splice(i, j));
			        \}
			        render(template(generateKeyNodes(items)), container);
			        expect(container.textContent).toEqual(items.join(''));
			      \});
			    \}
			  \});
			
			  describe('Calendar like layout', () => \{
			    interface AnimatedProps \{
			      key: string;
			      children?: any;
			    \}
			
			    class Animated extends Component<AnimatedProps, unknown> \{
			      public componentDidAppear() \{
			        // Trigger animation code paths on add
			      \}
			      public componentWillDisappear(_dom, done) \{
			        // Trigger animation code paths on remove
			        done();
			      \}
			      public render(\{ children \}: AnimatedProps) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    function o(text) \{
			      return <Animated key=\{'o' + text\}>\{',o' + text\}</Animated>;
			    \}
			
			    function d(text) \{
			      return <Animated key=\{'d' + text\}>\{',d' + text\}</Animated>;
			    \}
			
			    function wk(text) \{
			      return <Animated key=\{'wk' + text\}>\{',wk' + text\}</Animated>;
			    \}
			
			    it('Should do complex suffle without duplications', () => \{
			      const layout1 = [
			        wk(31),
			        d(1),
			        d(2),
			        d(3),
			        d(4),
			        d(5),
			        d(6),
			        d(7),
			        wk(32),
			        d(8),
			        d(9),
			        d(10),
			        d(11),
			        d(12),
			        d(13),
			        d(14),
			        wk(33),
			        d(15),
			        d(16),
			        d(17),
			        d(18),
			        d(19),
			        d(20),
			        d(21),
			        wk(34),
			        d(22),
			        d(23),
			        d(24),
			        d(25),
			        d(26),
			        d(27),
			        d(28),
			        wk(35),
			        d(29),
			        d(30),
			        d(31),
			        o(1),
			        o(2),
			        o(3),
			        o(4),
			        wk(36),
			        o(5),
			        o(6),
			        o(7),
			        o(8),
			        o(9),
			        o(10),
			        o(11)
			      ];
			      render(template(layout1), container);
			
			      expect(container.textContent).toBe(
			        ',wk31,d1,d2,d3,d4,d5,d6,d7,wk32,d8,d9,d10,d11,d12,d13,d14,wk33,d15,d16,d17,d18,d19,d20,d21,wk34,d22,d23,d24,d25,d26,d27,d28,wk35,d29,d30,d31,o1,o2,o3,o4,wk36,o5,o6,o7,o8,o9,o10,o11'
			      );
			
			      const layout2 = [
			        wk(35),
			        o(29),
			        o(30),
			        o(31),
			        d(1),
			        d(2),
			        d(3),
			        d(4),
			        wk(36),
			        d(5),
			        d(6),
			        d(7),
			        d(8),
			        d(9),
			        d(10),
			        d(11),
			        wk(37),
			        d(12),
			        d(13),
			        d(14),
			        d(15),
			        d(16),
			        d(17),
			        d(18),
			        wk(38),
			        d(19),
			        d(20),
			        d(21),
			        d(22),
			        d(23),
			        d(24),
			        d(25),
			        wk(39),
			        d(26),
			        d(27),
			        d(28),
			        d(29),
			        d(30),
			        o(1),
			        o(2),
			        wk(40),
			        o(3),
			        o(4),
			        o(5),
			        o(6),
			        o(7),
			        o(8),
			        o(9)
			      ];
			      render(template(layout2), container);
			
			      expect(container.textContent).toBe(
			        ',wk35,o29,o30,o31,d1,d2,d3,d4,wk36,d5,d6,d7,d8,d9,d10,d11,wk37,d12,d13,d14,d15,d16,d17,d18,wk38,d19,d20,d21,d22,d23,d24,d25,wk39,d26,d27,d28,d29,d30,o1,o2,wk40,o3,o4,o5,o6,o7,o8,o9'
			      );
			    \});
			  \});
			\});
			
			interface TagProps \{
			  children: InfernoSingleNode;
			  id: string;
			\}
			
			function factory(spyer?: jasmine.Spy) \{
			  return \{
			    Tag: (\{ children \}: TagProps) => \{
			      return <div>\{children\}</div>;
			    \},
			    onComponentDidAppear(_dom) \{
			      spyer && spyer('didAppear');
			    \},
			    onComponentWillDisappear(_dom, _props, callback) \{
			      spyer && spyer('willDisappear');
			      callback();
			    \}
			  \};
			\}
			
			function generateKeyNodes(array: (string | number)[], spyer?) \{
			  let i: number;
			  let id: string | number;
			  let key: string | number;
			  const children: InfernoNode[] = [];
			  let newKey: string | number | null;
			  const \{ Tag, onComponentDidAppear, onComponentWillDisappear \} = factory(spyer);
			
			  for (i = 0; i < array.length; i++) \{
			    id = key = array[i];
			    if (key !== null && (typeof key !== 'string' || key[0] !== '#')) \{
			      newKey = key;
			    \} else \{
			      newKey = null;
			    \}
			
			    children.push(
			      <Tag key=\{newKey\} id=\{String(id)\} onComponentDidAppear=\{onComponentDidAppear\} onComponentWillDisappear=\{onComponentWillDisappear\}>
			        \{id\}
			      </Tag>
			    );
			  \}
			  return children;
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\animationHooksFunc.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(58)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\async-setstate.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render, rerender \} from 'inferno';
			
			describe('Async set state issue', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should always call all set change callbacks', () => \{
			    interface HoCProps \{
			      run: number;
			    \}
			
			    class HoC extends Component<HoCProps> \{
			      constructor(props) \{
			        super(props);
			
			        this.update = this.update.bind(this);
			      \}
			
			      public update() \{
			        this.setState(\{\});
			      \}
			
			      public render(props) \{
			        return (
			          <div>
			            <Test update=\{this.update\} run=\{props.run\} name="first" />
			            <Test update=\{this.update\} run=\{props.run\} name="second" />
			          </div>
			        );
			      \}
			    \}
			
			    let _fromCWRPCBRequested = 0;
			    let _failureCreatorCBRequested = 0;
			    let _callMePlsCBRequested = 0;
			    let _justBecauseCBRequested = 0;
			    let _fromCWRPCalled = 0;
			    let _failureCreatorCalled = 0;
			    let _callMePlsCalled = 0;
			    let _justBecauseCalled = 0;
			
			    interface TestProps \{
			      update: () => void;
			      run: number;
			      name: string;
			    \}
			
			    interface TestState \{
			      async: boolean;
			      counter: number;
			      failure: boolean;
			      success: number;
			    \}
			
			    class Test extends Component<TestProps, TestState> \{
			      public state: TestState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          async: false,
			          counter: 0,
			          failure: false,
			          success: 0
			        \};
			      \}
			
			      public _forceASYNC() \{
			        // hack just for testing, this forces parent is updating so we can test async setState flow
			        if (this.state.counter === 1) \{
			          this.props.update();
			        \}
			      \}
			
			      public _justBecause() \{
			        _justBecauseCalled++;
			        this._forceASYNC();
			
			        this.setState(\{
			          success: 2
			        \});
			      \}
			
			      public _callMePls() \{
			        _callMePlsCalled++;
			        this._forceASYNC();
			
			        _justBecauseCBRequested++;
			        this.setState(
			          \{
			            success: 1
			          \},
			          this._justBecause
			        );
			      \}
			
			      public _failureCreator() \{
			        _failureCreatorCalled++;
			        this._forceASYNC();
			
			        _callMePlsCBRequested++;
			        this.setState(
			          \{
			            failure: true
			          \},
			          this._callMePls
			        );
			      \}
			
			      public _fromCWRP() \{
			        _fromCWRPCalled++;
			        this._forceASYNC();
			
			        _failureCreatorCBRequested++;
			        // This setState triggers async flow
			        this.setState(
			          \{
			            async: true
			          \},
			          this._failureCreator
			        );
			      \}
			
			      public componentWillReceiveProps(_nextProps, _nextContext) \{
			        _fromCWRPCBRequested++;
			
			        this.setState(
			          \{
			            counter: this.state.counter + 1
			          \},
			          this._fromCWRP
			        );
			      \}
			
			      public render() \{
			        return <div>\{\`\$\{this.props.name\} \$\{this.state.success\} \$\{this.state.counter\} \$\{this.state.async\} \$\{this.state.failure\}\`\}</div>;
			      \}
			    \}
			
			    render(<HoC run=\{1\} />, container);
			    rerender();
			    render(<HoC run=\{2\} />, container);
			    rerender();
			
			    // Set state should be called as many times as it was requested
			    expect(_fromCWRPCBRequested).toBe(_fromCWRPCalled);
			    expect(_callMePlsCBRequested).toBe(_callMePlsCalled);
			    expect(_failureCreatorCBRequested).toBe(_failureCreatorCalled);
			    expect(_justBecauseCBRequested).toBe(_justBecauseCalled);
			
			    // This assertion is just to document it used to be 4 iterations
			    expect(_fromCWRPCBRequested).toBe(4);
			    expect(_callMePlsCBRequested).toBe(4);
			    expect(_failureCreatorCBRequested).toBe(4);
			    expect(_justBecauseCBRequested).toBe(4);
			
			    expect(container.innerHTML).toBe('<div><div>first 2 2 true true</div><div>second 2 2 true true</div></div>');
			  \});
			
			  it('Should always call all set change callbacks in order of setState requests', () => \{
			    interface HoCProps \{
			      run: number;
			    \}
			
			    class HoC extends Component<HoCProps> \{
			      constructor(props) \{
			        super(props);
			
			        this.update = this.update.bind(this);
			      \}
			
			      public update() \{
			        this.setState(\{\});
			      \}
			
			      public render(props) \{
			        return (
			          <div>
			            <TestBefore update=\{this.update\} run=\{props.run\} />
			            <TestAfter update=\{this.update\} run=\{props.run\} />
			          </div>
			        );
			      \}
			    \}
			
			    const orderOfCalls: string[] = [];
			    let testBeforeBeforeSpy: jasmine.Spy;
			    let testBeforeAfterSpy: jasmine.Spy;
			    let testAfterBeforeSpy: jasmine.Spy;
			    let testAfterAfterSpy: jasmine.Spy;
			
			    interface TestBeforeProps \{
			      update: () => void;
			      run: number;
			    \}
			    interface TestBeforeState \{
			      async: number;
			      counter: number;
			    \}
			
			    class TestBefore extends Component<TestBeforeProps, TestBeforeState> \{
			      public state: TestBeforeState;
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          async: 0,
			          counter: 0
			        \};
			
			        testBeforeBeforeSpy = spyOn(this, '_before').and.callFake(function () \{
			          orderOfCalls.push('testBeforeBefore');
			        \});
			        testBeforeAfterSpy = spyOn(this, '_after').and.callFake(function () \{
			          orderOfCalls.push('testBeforeAfter');
			        \});
			      \}
			
			      public _forceASYNC() \{
			        // hack just for testing, this forces parent is updating so we can test async setState flow
			        if (this.state.counter === 1) \{
			          this.props.update();
			        \}
			      \}
			
			      public _before() \{\}
			
			      public _after() \{\}
			
			      public _fromCWRP() \{
			        this._forceASYNC();
			
			        this.setState(
			          \{
			            async: 1
			          \},
			          this._before
			        );
			
			        this.setState(
			          \{
			            async: 2
			          \},
			          this._after
			        );
			      \}
			
			      public componentWillReceiveProps(_nextProps, _nextContext) \{
			        this.setState(
			          \{
			            counter: this.state.counter + 1
			          \},
			          this._fromCWRP
			        );
			      \}
			
			      public render() \{
			        return <div>\{\`\$\{this.state.async\}\`\}</div>;
			      \}
			    \}
			
			    interface TestAfterProps \{
			      update: () => void;
			      run: number;
			    \}
			
			    interface TestAfterState \{
			      async: number;
			      counter: number;
			    \}
			
			    class TestAfter extends Component<TestAfterProps, TestAfterState> \{
			      public state: TestAfterState;
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          async: 0,
			          counter: 0
			        \};
			
			        testAfterBeforeSpy = spyOn(this, '_before').and.callFake(function () \{
			          orderOfCalls.push('testAfterBefore');
			        \});
			        testAfterAfterSpy = spyOn(this, '_after').and.callFake(function () \{
			          orderOfCalls.push('testAfterAfter');
			        \});
			      \}
			
			      public _forceASYNC() \{
			        // hack just for testing, this forces parent is updating so we can test async setState flow
			        if (this.state.counter === 1) \{
			          this.props.update();
			        \}
			      \}
			
			      public _before() \{\}
			
			      public _after() \{\}
			
			      public _fromCWRP() \{
			        this._forceASYNC();
			
			        this.setState(
			          \{
			            async: 1
			          \},
			          this._before
			        );
			
			        this.setState(
			          \{
			            async: 2
			          \},
			          this._after
			        );
			      \}
			
			      public componentWillReceiveProps(_nextProps, _nextContext) \{
			        this.setState(
			          \{
			            counter: this.state.counter + 1
			          \},
			          this._fromCWRP
			        );
			      \}
			
			      public render() \{
			        return <div>\{\`\$\{this.state.async\}\`\}</div>;
			      \}
			    \}
			
			    render(<HoC run=\{1\} />, container);
			    rerender();
			
			    render(<HoC run=\{2\} />, container);
			    rerender();
			
			    // Set state should be called as many times as it was requested
			    expect(testBeforeBeforeSpy!).toHaveBeenCalledTimes(2);
			    expect(testBeforeAfterSpy!).toHaveBeenCalledTimes(2);
			    expect(testAfterBeforeSpy!).toHaveBeenCalledTimes(2);
			    expect(testAfterAfterSpy!).toHaveBeenCalledTimes(2);
			
			    expect(orderOfCalls).toEqual([
			      'testBeforeBefore',
			      'testBeforeAfter',
			      'testBeforeBefore',
			      'testBeforeAfter',
			      'testAfterBefore',
			      'testAfterAfter',
			      'testAfterBefore',
			      'testAfterAfter'
			    ]);
			
			    expect(container.innerHTML).toBe('<div><div>2</div><div>2</div></div>');
			  \});
			
			  it('Should not call applystate for components which were unmounted during the micro task startup', function () \{
			    interface HoCProps \{
			      run: number;
			    \}
			
			    class HoC extends Component<HoCProps> \{
			      constructor(props) \{
			        super(props);
			
			        this.update = this.update.bind(this);
			      \}
			
			      public update() \{
			        this.setState(\{\});
			      \}
			
			      public render(props) \{
			        return (
			          <div>
			            <TestBefore update=\{this.update\} run=\{props.run\} />
			            <TestAfter update=\{this.update\} run=\{props.run\} />
			          </div>
			        );
			      \}
			    \}
			
			    let testBeforeBeforeSpy: jasmine.Spy;
			    let testBeforeAfterSpy: jasmine.Spy;
			    let testAfterBeforeSpy: jasmine.Spy;
			    let testAfterAfterSpy: jasmine.Spy;
			
			    interface TestBeforeProps \{
			      update: () => void;
			      run: number;
			    \}
			    interface TestBeforeState \{
			      async: number;
			      counter: number;
			    \}
			
			    class TestBefore extends Component<TestBeforeProps, TestBeforeState> \{
			      public state: TestBeforeState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          async: 0,
			          counter: 0
			        \};
			
			        testBeforeBeforeSpy = spyOn(this, '_before');
			        testBeforeAfterSpy = spyOn(this, '_after');
			      \}
			
			      public _forceASYNC() \{
			        // hack just for testing, this forces parent is updating so we can test async setState flow
			        if (this.state.counter === 1) \{
			          this.props.update();
			        \}
			      \}
			
			      public _before() \{\}
			
			      public _after() \{\}
			
			      public _fromCWRP() \{
			        this._forceASYNC();
			
			        this.setState(
			          \{
			            async: 1
			          \},
			          this._before
			        );
			
			        this.setState(
			          \{
			            async: 2
			          \},
			          this._after
			        );
			      \}
			
			      public componentWillReceiveProps(_nextProps, _nextContext) \{
			        this.setState(
			          \{
			            counter: this.state.counter + 1
			          \},
			          this._fromCWRP
			        );
			      \}
			
			      public render() \{
			        return <div>\{\`\$\{this.state.async\}\`\}</div>;
			      \}
			    \}
			
			    interface TestAfterProps \{
			      update: () => void;
			      run: number;
			    \}
			
			    interface TestAfterState \{
			      async: number;
			      counter: number;
			    \}
			
			    class TestAfter extends Component<TestAfterProps, TestAfterState> \{
			      public state: TestAfterState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          async: 0,
			          counter: 0
			        \};
			
			        testAfterBeforeSpy = spyOn(this, '_before');
			        testAfterAfterSpy = spyOn(this, '_after');
			      \}
			
			      public _forceASYNC() \{
			        // hack just for testing, this forces parent is updating so we can test async setState flow
			        if (this.state.counter === 1) \{
			          this.props.update();
			        \}
			      \}
			
			      public _before() \{\}
			
			      public _after() \{\}
			
			      public _fromCWRP() \{
			        this._forceASYNC();
			
			        this.setState(
			          \{
			            async: 1
			          \},
			          this._before
			        );
			
			        this.setState(
			          \{
			            async: 2
			          \},
			          this._after
			        );
			      \}
			
			      public componentWillReceiveProps(_nextProps, _nextContext) \{
			        this.setState(
			          \{
			            counter: this.state.counter + 1
			          \},
			          this._fromCWRP
			        );
			      \}
			
			      public render() \{
			        return <div>\{\`\$\{this.state.async\}\`\}</div>;
			      \}
			    \}
			
			    render(<HoC run=\{1\} />, container);
			    rerender();
			    render(<HoC run=\{2\} />, container);
			    rerender();
			    render(null, container);
			    rerender();
			
			    // Set state should be called as many times as it was requested
			    expect(testBeforeBeforeSpy!.calls.count()).toBe(2);
			    expect(testBeforeAfterSpy!.calls.count()).toBe(2);
			    expect(testAfterBeforeSpy!.calls.count()).toBe(2);
			    expect(testAfterAfterSpy!.calls.count()).toBe(2);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\async-setstate.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\blueprints.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			
			describe('Blueprints (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			    container = null;
			  \});
			
			  describe('Should have parentDOM defined #1', () => \{
			    class A extends Component \{
			      public render() \{
			        return <div>A</div>;
			      \}
			    \}
			
			    class B extends Component \{
			      public render() \{
			        return <span>B</span>;
			      \}
			    \}
			
			    interface CounterProps \{
			      car: string;
			    \}
			
			    interface CounterState \{
			      bool: boolean;
			    \}
			
			    class Counter extends Component<CounterProps, CounterState> \{
			      public state: CounterState;
			
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          bool: false
			        \};
			        this.btnCount = this.btnCount.bind(this);
			      \}
			
			      public btnCount() \{
			        this.setState(\{
			          bool: !this.state.bool
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div className="my-component">
			            <h1>
			              \{this.props.car\} \{this.state.bool ? <A /> : <B />\}
			            </h1>
			            <button type="button" onClick=\{this.btnCount\}>
			              btn
			            </button>
			          </div>
			        );
			      \}
			    \}
			
			    class Wrapper extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      public render() \{
			        return (
			          <div>
			            \{['Saab', 'Volvo', 'BMW'].map(function (c) \{
			              return <Counter car=\{c\} />;
			            \})\}
			          </div>
			        );
			      \}
			    \}
			
			    it('Initial render (creation)', () => \{
			      render(<Wrapper />, container);
			
			      expect(container.innerHTML).toBe(
			        '<div><div class="my-component"><h1>Saab <span>B</span></h1><button type="button">btn</button></div><div class="my-component"><h1>Volvo <span>B</span></h1><button type="button">btn</button></div><div class="my-component"><h1>BMW <span>B</span></h1><button type="button">btn</button></div></div>'
			      );
			
			      render(null, container);
			    \});
			
			    it('Second render (update)', () => \{
			      render(<Wrapper />, container);
			      const buttons = container.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      expect(container.innerHTML).toBe(
			        '<div><div class="my-component"><h1>Saab <div>A</div></h1><button type="button">btn</button></div><div class="my-component"><h1>Volvo <div>A</div></h1><button type="button">btn</button></div><div class="my-component"><h1>BMW <div>A</div></h1><button type="button">btn</button></div></div>'
			      );
			      render(null, container);
			    \});
			  \});
			
			  describe('Infinite loop issue', () => \{
			    it('Should not get stuck when doing setState from ref callback', (done) => \{
			      interface AProps \{
			        open?: boolean;
			      \}
			
			      interface AState \{
			        text: string;
			      \}
			
			      class A extends Component<AProps, AState> \{
			        public state: Readonly<AState>;
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            text: 'foo'
			          \};
			
			          this.onWilAttach = this.onWilAttach.bind(this);
			        \}
			
			        public onWilAttach() \{
			          this.setState(\{
			            text: 'animate'
			          \});
			        \}
			
			        public render() \{
			          if (!this.props.open) \{
			            return null;
			          \}
			
			          return <div ref=\{this.onWilAttach\}>\{this.state.text\}</div>;
			        \}
			      \}
			
			      render(<A />, container);
			
			      render(<A open=\{true\} />, container);
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div>animate</div>');
			        done();
			      \}, 10);
			    \});
			  \});
			
			  describe('Refs inside components', () => \{
			    it('Should have refs defined when componentDidMount is called', () => \{
			      class Com extends Component \{
			        private _first: HTMLDivElement | null;
			        private _second: HTMLSpanElement | null;
			
			        constructor(props) \{
			          super(props);
			          this._first = null;
			          this._second = null;
			        \}
			
			        public componentDidMount() \{
			          expect(this._first).not.toBe(null);
			          expect(this._second).not.toBe(null);
			        \}
			
			        public render() \{
			          return (
			            <div ref=\{(node) => (this._first = node)\}>
			              <span>1</span>
			              <span ref=\{(node) => (this._second = node)\}>2</span>
			            </div>
			          );
			        \}
			      \}
			
			      render(<Com />, container);
			    \});
			  \});
			
			  describe('Spread operator and templates', () => \{
			    it('Should be able to update property', () => \{
			      interface AProps \{
			        disabled?: boolean;
			        args?: \{\};
			      \}
			      class A extends Component<AProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <input disabled=\{this.props.disabled\} \{...this.props.args\} />
			            </div>
			          );
			        \}
			      \}
			
			      render(<A disabled=\{true\} />, container);
			      let input = container.querySelector('input');
			      expect(input.disabled).toBe(true);
			
			      render(<A disabled=\{false\} />, container);
			      input = container.querySelector('input');
			      expect(input.disabled).toBe(false);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\blueprints.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\children.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, InfernoNode, Key, render \} from 'inferno';
			
			describe('Children - (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('keyed - children', function () \{
			    it('Should push to correct location when it keyed list has siblings', function () \{
			      const _tabs = [\{ title: 'Item A' \}, \{ title: 'Item B' \}];
			      interface TabProps \{
			        title?: string;
			        onSelect?: () => void;
			        key?: Key;
			        id?: string;
			      \}
			
			      function Tab(\{ title, onSelect, key, id \}: TabProps) \{
			        return (
			          <div id=\{id\} key=\{key\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div id="add">Add</div></div>');
			      let addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div id="add">Add</div></div>');
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div id="add">Add</div></div>'
			      );
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div>New 4</div><div id="add">Add</div></div>'
			      );
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div>New 4</div><div>New 5</div><div id="add">Add</div></div>'
			      );
			    \});
			
			    it('Should append child node to correct location when its empty at the beginning ', function () \{
			      const _tabs: \{ title: string \}[] = [];
			      interface TabProps \{
			        title?: string;
			        onSelect?: () => void;
			        key?: Key;
			        id?: string;
			      \}
			
			      function Tab(\{ title, onSelect, key, id \}: TabProps) \{
			        return (
			          <div id=\{id\} key=\{key\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div></div>');
			      let addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div id="add">Add</div></div>');
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div>New 1</div><div id="add">Add</div></div>');
			    \});
			
			    it('Should append child node to correct location when its empty at the beginning ', function () \{
			      const _tabs: \{ title: string \}[] = [];
			
			      interface TabProps \{
			        title?: string;
			        onSelect?: () => void;
			        key?: Key;
			        id?: string;
			      \}
			
			      function Tab(\{ title, onSelect, key, id \}: TabProps) \{
			        return (
			          <div id=\{id\} key=\{key\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            <Tab onSelect=\{create\} id="add" title="Add" />
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div></div>');
			      let addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div><div>New 0</div></div>');
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div><div>New 0</div><div>New 1</div></div>');
			    \});
			
			    it('Should append child node to correct location when its empty at the beginning ', function () \{
			      const _tabs: \{ title: string \}[] = [];
			      interface TabProps \{
			        title?: string;
			        onSelect?: () => void;
			        key?: Key;
			        id?: string;
			      \}
			
			      function Tab(\{ title, onSelect, key, id \}: TabProps) \{
			        return (
			          <div id=\{id\} key=\{key\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div></div>');
			      let addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div id="add">Add</div><div>New 0</div></div>');
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div>New 1</div><div id="add">Add</div><div>New 0</div><div>New 1</div></div>');
			    \});
			
			    it('Should appendx3 to correct location when it keyed list has siblings', function () \{
			      const _tabs = [\{ title: 'Item A' \}, \{ title: 'Item B' \}];
			      interface TabProps \{
			        title?: string;
			        onSelect?: () => void;
			        key?: Key;
			        id?: string;
			      \}
			
			      function Tab(\{ title, onSelect, key, id \}: TabProps) \{
			        return (
			          <div id=\{id\} key=\{key\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div id="add">Add</div></div>');
			      const addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div>New 4</div><div id="add">Add</div></div>'
			      );
			    \});
			
			    it('Should unshiftx3 to correct location when it keyed list has siblings', function () \{
			      const _tabs = [\{ title: 'Item A' \}, \{ title: 'Item B' \}];
			      interface TabProps \{
			        title?: string;
			        onSelect?: () => void;
			        key?: Key;
			        id?: string;
			      \}
			
			      function Tab(\{ title, onSelect, key, id \}: TabProps) \{
			        return (
			          <div id=\{id\} key=\{key\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.unshift(\{ title: 'New ' + tabs.length \});
			          tabs.unshift(\{ title: 'New ' + tabs.length \});
			          tabs.unshift(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div id="add">Add</div></div>');
			      const addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>New 4</div><div>New 3</div><div>New 2</div><div>Item A</div><div>Item B</div><div id="add">Add</div></div>'
			      );
			    \});
			
			    it('Inline text element before array list', function () \{
			      const _tabs: \{ title: string \}[] = [];
			
			      interface TabProps \{
			        title?: string;
			        key?: Key;
			      \}
			
			      function Tab(\{ title, key \}: TabProps) \{
			        return <div key=\{key\}>\{title\}</div>;
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        return (
			          <div className="tab-group">
			            inlineText
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group">inlineText</div>');
			
			      _tabs.push(\{ title: 'New ' + _tabs.length \});
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group">inlineText<div>New 0</div></div>');
			    \});
			
			    it('Inline text element after array list', function () \{
			      const _tabs: \{ title: string \}[] = [];
			      interface TabProps \{
			        title?: string;
			        key?: Key;
			      \}
			
			      function Tab(\{ title, key \}: TabProps) \{
			        return <div key=\{key\}>\{title\}</div>;
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab, i) => (
			              <Tab key=\{'Item ' + i\} title=\{tab.title\} />
			            ))\}
			            inlineText
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group">inlineText</div>');
			
			      _tabs.push(\{ title: 'New ' + _tabs.length \});
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div>inlineText</div>');
			    \});
			  \});
			
			  describe('nonKeyed - children', function () \{
			    it('Should push to correct location when it keyed list has siblings', function () \{
			      const _tabs = [\{ title: 'Item A' \}, \{ title: 'Item B' \}];
			
			      interface TabProps \{
			        title?: string;
			        id?: string;
			        onSelect?: () => void;
			      \}
			
			      function Tab(\{ title, id, onSelect \}: TabProps) \{
			        return (
			          <div id=\{id\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div id="add">Add</div></div>');
			      let addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div id="add">Add</div></div>');
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div id="add">Add</div></div>'
			      );
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div>New 4</div><div id="add">Add</div></div>'
			      );
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div>New 4</div><div>New 5</div><div id="add">Add</div></div>'
			      );
			    \});
			
			    it('Should append child node to correct location when its empty at the beginning ', function () \{
			      const _tabs: \{ title: string \}[] = [];
			
			      interface TabProps \{
			        title?: string;
			        id?: string;
			        onSelect?: () => void;
			      \}
			
			      function Tab(\{ title, id, onSelect \}: TabProps) \{
			        return (
			          <div id=\{id\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div></div>');
			      let addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div id="add">Add</div></div>');
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div>New 1</div><div id="add">Add</div></div>');
			    \});
			
			    it('Should append child node to correct location when its empty at the beginning ', function () \{
			      const _tabs: \{ title: string \}[] = [];
			
			      interface TabProps \{
			        title?: string;
			        id?: string;
			        onSelect?: () => void;
			      \}
			
			      function Tab(\{ title, id, onSelect \}: TabProps) \{
			        return (
			          <div id=\{id\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            <Tab onSelect=\{create\} id="add" title="Add" />
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div></div>');
			      const addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div><div>New 0</div></div>');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div><div>New 0</div><div>New 1</div></div>');
			    \});
			
			    it('Should append child node to correct location when its empty at the beginning ', function () \{
			      const _tabs: \{ title: string \}[] = [];
			
			      interface TabProps \{
			        title?: string;
			        id?: string;
			        onSelect?: () => void;
			      \}
			
			      function Tab(\{ title, id, onSelect \}: TabProps) \{
			        return (
			          <div id=\{id\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div id="add">Add</div></div>');
			      let addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div id="add">Add</div><div>New 0</div></div>');
			      addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div><div>New 1</div><div id="add">Add</div><div>New 0</div><div>New 1</div></div>');
			    \});
			
			    it('Should appendx3 to correct location when it list has siblings', function () \{
			      const _tabs = [\{ title: 'Item A' \}, \{ title: 'Item B' \}];
			
			      interface TabProps \{
			        title?: string;
			        id?: string;
			        onSelect?: () => void;
			      \}
			
			      function Tab(\{ title, id, onSelect \}: TabProps) \{
			        return (
			          <div id=\{id\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          tabs.push(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div id="add">Add</div></div>');
			      const addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>Item A</div><div>Item B</div><div>New 2</div><div>New 3</div><div>New 4</div><div id="add">Add</div></div>'
			      );
			    \});
			
			    it('Should unshiftx3 to correct location when it list has siblings', function () \{
			      const _tabs = [\{ title: 'Item A' \}, \{ title: 'Item B' \}];
			
			      interface TabProps \{
			        title?: string;
			        id?: string;
			        onSelect?: () => void;
			      \}
			
			      function Tab(\{ title, id, onSelect \}: TabProps) \{
			        return (
			          <div id=\{id\} onClick=\{onSelect\}>
			            \{title\}
			          </div>
			        );
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        function create() \{
			          tabs.unshift(\{ title: 'New ' + tabs.length \});
			          tabs.unshift(\{ title: 'New ' + tabs.length \});
			          tabs.unshift(\{ title: 'New ' + tabs.length \});
			          renderIt();
			        \}
			
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} onSelect=\{() => undefined\} />
			            ))\}
			            <Tab onSelect=\{create\} id="add" title="Add" />
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>Item A</div><div>Item B</div><div id="add">Add</div></div>');
			      const addTab = container.querySelector('#add');
			      addTab.click();
			      expect(container.innerHTML).toBe(
			        '<div class="tab-group"><div>New 4</div><div>New 3</div><div>New 2</div><div>Item A</div><div>Item B</div><div id="add">Add</div></div>'
			      );
			    \});
			
			    it('Inline text element before array list', function () \{
			      const _tabs: \{ title: string \}[] = [];
			
			      function Tab(\{ title \}) \{
			        return <div>\{title\}</div>;
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        return (
			          <div className="tab-group">
			            inlineText
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group">inlineText</div>');
			
			      _tabs.push(\{ title: 'New ' + _tabs.length \});
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group">inlineText<div>New 0</div></div>');
			    \});
			
			    it('Inline text element after array list', function () \{
			      const _tabs: \{ title: string \}[] = [];
			
			      function Tab(\{ title \}) \{
			        return <div>\{title\}</div>;
			      \}
			
			      function TabGroup(\{ tabs \}) \{
			        return (
			          <div className="tab-group">
			            \{tabs.map((tab) => (
			              <Tab title=\{tab.title\} />
			            ))\}
			            inlineText
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<TabGroup tabs=\{_tabs\} />, container);
			      \}
			
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group">inlineText</div>');
			
			      _tabs.push(\{ title: 'New ' + _tabs.length \});
			      renderIt();
			
			      expect(container.innerHTML).toBe('<div class="tab-group"><div>New 0</div>inlineText</div>');
			    \});
			  \});
			
			  describe('mixed children edge cases', function () \{
			    it('NONKEYED - should remove children from correct location when there is dynamic static item', function () \{
			      const items = ['a', 'b', 'c'];
			      const emptyArray = [];
			      const items3 = ['v', 'a'];
			      let visible = false;
			      let activeOne;
			
			      function Loop(\{ text \}) \{
			        return <p>\{text\}</p>;
			      \}
			
			      function Looper(\{ collectionOne, visibleStatic \}) \{
			        return (
			          <div className="c">
			            \{visibleStatic ? <Loop text="static" /> : null\}
			            \{collectionOne.map((text) => (
			              <Loop text=\{text\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<Looper collectionOne=\{activeOne\} visibleStatic=\{visible\} />, container);
			      \}
			
			      visible = true;
			      activeOne = items;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p><p>a</p><p>b</p><p>c</p></div>');
			
			      visible = false;
			      activeOne = items3;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>v</p><p>a</p></div>');
			
			      visible = true;
			      activeOne = items3;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p><p>v</p><p>a</p></div>');
			
			      visible = true;
			      activeOne = emptyArray;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p></div>');
			    \});
			
			    it('NONKEYED - should remove children from correct location when there is 2 dynamic static items and 2 lists', function () \{
			      const items = ['a', 'b', 'c'];
			      const emptyArray = [];
			      const items3 = ['v', 'a'];
			
			      let activeOne;
			      let activeTwo;
			      let visibleOne = false;
			      let visibleTwo = false;
			
			      function Loop(\{ text \}) \{
			        return <p>\{text\}</p>;
			      \}
			
			      function Looper(\{ collectionOne, visibleStaticOne, collectionTwo, visibleStaticTwo \}) \{
			        return (
			          <div className="c">
			            \{visibleStaticOne ? <Loop text="static" /> : null\}
			            \{collectionOne.map((text) => (
			              <Loop text=\{text\} />
			            ))\}
			            \{visibleStaticTwo ? <Loop text="static" /> : null\}
			            \{collectionTwo.map((text) => (
			              <Loop text=\{text\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<Looper collectionOne=\{activeOne\} visibleStaticOne=\{visibleOne\} collectionTwo=\{activeTwo\} visibleStaticTwo=\{visibleTwo\} />, container);
			      \}
			
			      visibleOne = true;
			      activeOne = items;
			      visibleTwo = false;
			      activeTwo = emptyArray;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p><p>a</p><p>b</p><p>c</p></div>');
			
			      visibleOne = true;
			      activeOne = emptyArray;
			      visibleTwo = true;
			      activeTwo = items;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p><p>static</p><p>a</p><p>b</p><p>c</p></div>');
			
			      visibleOne = false;
			      activeOne = items3;
			      visibleTwo = false;
			      activeTwo = emptyArray;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>v</p><p>a</p></div>');
			
			      visibleOne = true;
			      activeOne = items;
			      visibleTwo = true;
			      activeTwo = emptyArray;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p><p>a</p><p>b</p><p>c</p><p>static</p></div>');
			    \});
			
			    it('KEYED - should remove children from correct location when there is dynamic static item', function () \{
			      const items = ['a', 'b', 'c'];
			      const emptyArray = [];
			      const items3 = ['v', 'a'];
			      let visible = false;
			
			      let activeOne;
			
			      function Loop(\{ text \}) \{
			        return <p>\{text\}</p>;
			      \}
			
			      function Looper(\{ collectionOne, visibleStatic \}) \{
			        return (
			          <div className="c">
			            \{visibleStatic ? <Loop text="static" /> : null\}
			            \{collectionOne.map((text, i) => (
			              <Loop key=\{i\} text=\{text\} />
			            ))\}
			          </div>
			        );
			      \}
			
			      function renderIt() \{
			        render(<Looper collectionOne=\{activeOne\} visibleStatic=\{visible\} />, container);
			      \}
			
			      visible = true;
			      activeOne = items;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p><p>a</p><p>b</p><p>c</p></div>');
			
			      visible = false;
			      activeOne = items3;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>v</p><p>a</p></div>');
			
			      visible = true;
			      activeOne = items3;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p><p>v</p><p>a</p></div>');
			
			      visible = true;
			      activeOne = emptyArray;
			      renderIt();
			      expect(container.innerHTML).toBe('<div class="c"><p>static</p></div>');
			    \});
			  \});
			
			  describe('Functions non keyed', () => \{
			    it('Should render correctly functions and nodes mixed', () => \{
			      let updaterFirst: (() => void) | null = null;
			      let updaterSecond: (() => void) | null = null;
			
			      interface AState \{
			        first: boolean;
			        second: boolean;
			      \}
			
			      class A extends Component<unknown, AState> \{
			        public state: Readonly<AState>;
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            first: true,
			            second: true
			          \};
			
			          updaterFirst = () => this.setState(\{ first: !this.state.first \});
			          updaterSecond = () => this.setState(\{ second: !this.state.second \});
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <p>1</p>
			              \{function () \{
			                if (this.state.first) \{
			                  return <span>abc</span>;
			                \}
			                return null;
			              \}.call(this)\}
			              <p>2</p>
			              \{function () \{
			                if (this.state.second) \{
			                  return <span>def</span>;
			                \}
			                return null;
			              \}.call(this)\}
			              <p>3</p>
			            </div>
			          );
			        \}
			      \}
			
			      render(<A />, container);
			      expect(container.innerHTML).toBe('<div><p>1</p><span>abc</span><p>2</p><span>def</span><p>3</p></div>');
			      updaterFirst!();
			      expect(container.innerHTML).toBe('<div><p>1</p><p>2</p><span>def</span><p>3</p></div>');
			      updaterSecond!();
			      expect(container.innerHTML).toBe('<div><p>1</p><p>2</p><p>3</p></div>');
			      updaterSecond!();
			      expect(container.innerHTML).toBe('<div><p>1</p><p>2</p><span>def</span><p>3</p></div>');
			      updaterFirst!();
			      expect(container.innerHTML).toBe('<div><p>1</p><span>abc</span><p>2</p><span>def</span><p>3</p></div>');
			    \});
			  \});
			
			  describe('JSX plugin', () => \{
			    it('Should not have undefined properties', () => \{
			      class A extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public render() \{
			          return <div>\{this.props.children\}</div>;
			        \}
			      \}
			
			      class B extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public callback() \{\}
			
			        public render() \{
			          return (
			            <A>
			              <div onclick=\{this.callback\}>B</div>
			            </A>
			          );
			        \}
			      \}
			
			      render(<B />, container);
			    \});
			  \});
			
			  describe('Rendering null on child node', () => \{
			    it('Should trigger unmount', () => \{
			      interface AProps \{
			        test: InfernoNode;
			      \}
			      class A extends Component<AProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public render() \{
			          return <div>\{this.props.test\}</div>;
			        \}
			      \}
			
			      class B extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <p>B</p>;
			        \}
			      \}
			
			      const unmountSpy = spyOn(B.prototype, 'componentWillUnmount');
			      render(<A test=\{<B />\} />, container);
			      expect(container.innerHTML).toBe('<div><p>B</p></div>');
			      render(<A test=\{null\} />, container);
			      expect(container.innerHTML).toBe('<div></div>');
			      expect(unmountSpy.calls.count()).toBe(1);
			    \});
			  \});
			
			  describe('VFragment within other nodes', () => \{
			    it('Should not clear nodes when non keyed', () => \{
			      const Nodes = (\{ items \}) => (
			        <div>
			          <div>test</div>
			          \{items.map((item) => (
			            <span>\{item\}</span>
			          ))\}
			          <div>end</div>
			        </div>
			      );
			
			      render(<Nodes items=\{[1, 2, 3]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>1</span><span>2</span><span>3</span><div>end</div></div>');
			
			      render(<Nodes items=\{[3, 2, 1]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>3</span><span>2</span><span>1</span><div>end</div></div>');
			
			      render(<Nodes items=\{[9, 8, 7]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>9</span><span>8</span><span>7</span><div>end</div></div>');
			
			      render(<Nodes items=\{[]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><div>end</div></div>');
			    \});
			
			    it('Should not clear nodes when keyed inside vFragment', () => \{
			      const Nodes = (\{ items \}) => (
			        <div>
			          <div>test</div>
			          \{items.map((item) => (
			            <span key=\{item\}>\{item\}</span>
			          ))\}
			          <div>end</div>
			        </div>
			      );
			
			      render(<Nodes items=\{[1, 2, 3]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>1</span><span>2</span><span>3</span><div>end</div></div>');
			
			      render(<Nodes items=\{[3, 2, 1]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>3</span><span>2</span><span>1</span><div>end</div></div>');
			
			      render(<Nodes items=\{[9, 8, 7]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>9</span><span>8</span><span>7</span><div>end</div></div>');
			
			      render(<Nodes items=\{[]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><div>end</div></div>');
			    \});
			
			    it('Should not clear nodes when keyed inside vFragment #2', () => \{
			      const Nodes = (\{ items \}) => (
			        <div>
			          <div>test</div>
			          \{items.map((item) => (
			            <span key=\{item\}>\{item\}</span>
			          ))\}
			          <div>end</div>
			        </div>
			      );
			
			      render(<Nodes items=\{[1]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>1</span><div>end</div></div>');
			
			      render(<Nodes items=\{[]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><div>end</div></div>');
			
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			
			      render(<Nodes items=\{[1, 2, 3]\} />, container);
			      expect(container.innerHTML).toBe('<div><div>test</div><span>1</span><span>2</span><span>3</span><div>end</div></div>');
			    \});
			  \});
			
			  describe('Forced keyed children', () => \{
			    it('Should always go keyed algorithm when parent has \$HasKeyedChildren', () => \{
			      const Collection = (\{ children \}) => <div \$HasKeyedChildren>\{children\}</div>;
			
			      render(
			        <Collection>
			          <div key="1">1</div>
			          <div key="2">2</div>
			          <div key="3">3</div>
			        </Collection>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div><div>3</div></div>');
			
			      render(
			        <Collection>
			          <div key="3">3</div>
			          <div key="2">2</div>
			          <div key="1">1</div>
			        </Collection>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>3</div><div>2</div><div>1</div></div>');
			
			      render(
			        <Collection>
			          <div key="3">3</div>
			          <div key="2">2</div>
			          <div key="11">11</div>
			        </Collection>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>3</div><div>2</div><div>11</div></div>');
			    \});
			
			    it('Should be able to swap from keyed to nonkeyed when nextNode no longer is keyed', () => \{
			      const CollectionKeyed = (\{ children \}) => <div \$HasKeyedChildren>\{children\}</div>;
			
			      const CollectionNonKeyed = (\{ children \}) => <div \$HasNonKeyedChildren>\{children\}</div>;
			
			      render(
			        <CollectionKeyed>
			          <div key="1">1</div>
			          <div key="2">2</div>
			          <div key="3">3</div>
			        </CollectionKeyed>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div><div>3</div></div>');
			
			      render(
			        <CollectionNonKeyed>
			          <div>3</div>
			          <div>2</div>
			        </CollectionNonKeyed>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>3</div><div>2</div></div>');
			
			      render(
			        <CollectionKeyed>
			          <div key="3">3</div>
			          <div key="2">2</div>
			          <div key="11">11</div>
			        </CollectionKeyed>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>3</div><div>2</div><div>11</div></div>');
			    \});
			
			    it('Should handle previous being empty array', () => \{
			      const CollectionKeyed = (\{ children \}) => <div \$HasKeyedChildren>\{children\}</div>;
			
			      const child = [];
			      render(<CollectionKeyed>\{child\}</CollectionKeyed>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      render(
			        <CollectionKeyed>
			          <div key="1">1</div>
			          <div key="2">2</div>
			          <div key="3">3</div>
			        </CollectionKeyed>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div><div>3</div></div>');
			    \});
			
			    it('Should handle next being empty array', () => \{
			      const CollectionKeyed = (\{ children \}) => <div \$HasKeyedChildren>\{children\}</div>;
			
			      render(
			        <CollectionKeyed>
			          <div key="1">1</div>
			          <div key="2">2</div>
			          <div key="3">3</div>
			        </CollectionKeyed>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div><div>3</div></div>');
			
			      const child = [];
			      render(<CollectionKeyed>\{child\}</CollectionKeyed>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			
			    it('Should handle last/next being empty', () => \{
			      const CollectionKeyed = (\{ children \}) => <div \$HasKeyedChildren>\{children\}</div>;
			
			      const child = [];
			      render(<CollectionKeyed>\{child\}</CollectionKeyed>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      const childB = [];
			
			      render(<CollectionKeyed>\{childB\}</CollectionKeyed>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			  \});
			
			  describe('Unmount behavior in lists', () => \{
			    it('Should not call unmount when changing list length', () => \{
			      class UnMountTest extends Component \{
			        public componentWillUnmount() \{
			          // Should not be here
			        \}
			
			        public render() \{
			          return <span>1</span>;
			        \}
			      \}
			
			      interface ParentProps \{
			        firstClassCitizenIsBack?: boolean;
			      \}
			
			      class Parent extends Component<ParentProps> \{
			        public render() \{
			          let firstClassCitizen = null;
			          if (this.props.firstClassCitizenIsBack) \{
			            firstClassCitizen = <div>b</div>;
			          \}
			
			          // variable for debugging
			          const node = (
			            <div>
			              <div>a</div>
			              \{firstClassCitizen\}
			              <UnMountTest />
			              <div>C</div>
			            </div>
			          );
			
			          return node;
			        \}
			      \}
			
			      const spyUnmount = spyOn(UnMountTest.prototype, 'componentWillUnmount');
			
			      render(<Parent firstClassCitizenIsBack=\{false\} />, container); // initial render
			      expect(container.innerHTML).toEqual('<div><div>a</div><span>1</span><div>C</div></div>');
			      expect(spyUnmount).not.toHaveBeenCalled();
			
			      render(<Parent firstClassCitizenIsBack=\{true\} />, container);
			      expect(container.innerHTML).toEqual('<div><div>a</div><div>b</div><span>1</span><div>C</div></div>');
			      expect(spyUnmount).not.toHaveBeenCalled();
			    \});
			  \});
			
			  describe('Children lifecycle with fastUnmount', () => \{
			    it('Should call componentWillUnmount for children', (done) => \{
			      let toggle;
			
			      interface WrapperState \{
			        bool: boolean;
			      \}
			
			      class Wrapper extends Component<unknown, WrapperState> \{
			        public state: WrapperState;
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            bool: true
			          \};
			
			          toggle = () => \{
			            this.setState(\{
			              bool: !this.state.bool
			            \});
			          \};
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <span>foobar</span>
			              \{this.state.bool ? <FooBar /> : null\}
			            </div>
			          );
			        \}
			      \}
			
			      interface FoobarState \{
			        text: string;
			      \}
			
			      class FooBar extends Component<unknown, FoobarState> \{
			        public state: FoobarState;
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            text: 'initial'
			          \};
			        \}
			
			        public componentWillUnmount() \{\}
			
			        public componentWillMount() \{\}
			
			        public render() \{
			          return <span>\{this.state.text\}</span>;
			        \}
			      \}
			
			      render(<Wrapper />, container);
			
			      const unMountSpy = spyOn(FooBar.prototype, 'componentWillUnmount');
			      const mountSpy = spyOn(FooBar.prototype, 'componentWillMount');
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span>initial</span></div>');
			
			      mountSpy.calls.reset();
			      unMountSpy.calls.reset();
			
			      toggle(); // Unmount child component
			      setTimeout(() => \{
			        expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			
			        expect(unMountSpy).toHaveBeenCalledTimes(1);
			        expect(mountSpy).not.toHaveBeenCalled();
			        done();
			      \}, 10);
			    \});
			
			    it('Should call componentWillUnmount for nested children', (done) => \{
			      let toggle;
			
			      interface WrapperState \{
			        bool: boolean;
			      \}
			
			      class Wrapper extends Component<unknown, WrapperState> \{
			        public state: WrapperState;
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            bool: true
			          \};
			
			          toggle = () => \{
			            this.setState(\{
			              bool: !this.state.bool
			            \});
			          \};
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <span>foobar</span>
			              \{this.state.bool ? <FooBar /> : null\}
			            </div>
			          );
			        \}
			      \}
			
			      class FooBar extends Component \{
			        public render() \{
			          return (
			            <span>
			              <Test />
			            </span>
			          );
			        \}
			      \}
			
			      class Test extends Component \{
			        public componentWillUnmount() \{\}
			
			        public componentWillMount() \{\}
			
			        public render() \{
			          return <em>f</em>;
			        \}
			      \}
			
			      render(<Wrapper />, container);
			
			      const unMountSpy = spyOn(Test.prototype, 'componentWillUnmount');
			      const mountSpy = spyOn(Test.prototype, 'componentWillMount');
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span><em>f</em></span></div>');
			
			      mountSpy.calls.reset();
			      unMountSpy.calls.reset();
			
			      toggle(); // Unmount child component
			      setTimeout(() => \{
			        expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			
			        expect(unMountSpy).toHaveBeenCalledTimes(1);
			        expect(mountSpy).not.toHaveBeenCalled();
			        done();
			      \}, 10);
			    \});
			
			    it('Should call componentWillUnmount for nested children #2', (done) => \{
			      let toggle;
			
			      interface WrapperState \{
			        bool: boolean;
			      \}
			
			      class Wrapper extends Component<unknown, WrapperState> \{
			        public state: WrapperState;
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            bool: true
			          \};
			
			          toggle = () => \{
			            this.setState(\{
			              bool: !this.state.bool
			            \});
			          \};
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <span>foobar</span>
			              \{this.state.bool ? <FooBar /> : null\}
			            </div>
			          );
			        \}
			      \}
			
			      class FooBar extends Component \{
			        public render() \{
			          return (
			            <span>
			              <Test />
			              <Foo />
			            </span>
			          );
			        \}
			      \}
			
			      class Test extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <em>f</em>;
			        \}
			      \}
			
			      class Foo extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <em>f</em>;
			        \}
			      \}
			
			      render(<Wrapper />, container);
			
			      const unMountSpy = spyOn(Test.prototype, 'componentWillUnmount');
			      const unMountSpy2 = spyOn(Foo.prototype, 'componentWillUnmount');
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span><em>f</em><em>f</em></span></div>');
			
			      unMountSpy2.calls.reset();
			      unMountSpy.calls.reset();
			
			      toggle(); // Unmount child component
			      setTimeout(() => \{
			        expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			        expect(unMountSpy2).toHaveBeenCalledTimes(1);
			        expect(unMountSpy).toHaveBeenCalledTimes(1);
			        done();
			      \}, 10);
			    \});
			
			    it('Should call componentWillUnmount for deeply nested children', (done) => \{
			      let toggle;
			
			      interface WrapperState \{
			        bool: boolean;
			      \}
			
			      class Wrapper extends Component<unknown, WrapperState> \{
			        public state: WrapperState;
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            bool: true
			          \};
			
			          toggle = () => \{
			            this.setState(\{
			              bool: !this.state.bool
			            \});
			          \};
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <span>foobar</span>
			              \{this.state.bool ? <FooBar /> : null\}
			            </div>
			          );
			        \}
			      \}
			
			      class FooBar extends Component \{
			        public render() \{
			          return (
			            <span>
			              <span>
			                <span>
			                  <span>
			                    <Test />
			                  </span>
			                </span>
			              </span>
			            </span>
			          );
			        \}
			      \}
			
			      class Test extends Component \{
			        public render() \{
			          return <Test2 />;
			        \}
			      \}
			
			      class Test2 extends Component \{
			        public render() \{
			          return <Test4 />;
			        \}
			      \}
			
			      class Test4 extends Component \{
			        public render() \{
			          return (
			            <div>
			              <span />
			              <Test5 />
			              <span />
			            </div>
			          );
			        \}
			      \}
			
			      class Test5 extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <h1>ShouldUnMountMe</h1>;
			        \}
			      \}
			
			      render(<Wrapper />, container);
			
			      const unMountSpy = spyOn(Test5.prototype, 'componentWillUnmount');
			
			      expect(container.innerHTML).toEqual(
			        '<div><span>foobar</span><span><span><span><span><div><span></span><h1>ShouldUnMountMe</h1><span></span></div></span></span></span></span></div>'
			      );
			
			      unMountSpy.calls.reset();
			
			      toggle(); // Unmount child component
			      setTimeout(() => \{
			        expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			        expect(unMountSpy).toHaveBeenCalledTimes(1);
			        done();
			      \}, 10);
			    \});
			
			    it('Should call componentWillUnmount for parent when children dont have componentWIllUnmount', (done) => \{
			      class Wrapper extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return (
			            <div>
			              <span>foobar</span>
			              <FooBar />
			            </div>
			          );
			        \}
			      \}
			
			      class FooBar extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return (
			            <span>
			              <Test />
			            </span>
			          );
			        \}
			      \}
			
			      class Test extends Component \{
			        public render() \{
			          return <em>f</em>;
			        \}
			      \}
			
			      render(<Wrapper />, container);
			
			      const unMountSpy = spyOn(Wrapper.prototype, 'componentWillUnmount');
			      const unMountSpy2 = spyOn(FooBar.prototype, 'componentWillUnmount');
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span><em>f</em></span></div>');
			
			      unMountSpy.calls.reset();
			      unMountSpy2.calls.reset();
			
			      render(null, container);
			      setTimeout(() => \{
			        expect(container.innerHTML).toEqual('');
			
			        expect(unMountSpy).toHaveBeenCalledTimes(1);
			        expect(unMountSpy2).toHaveBeenCalledTimes(1);
			        done();
			      \}, 10);
			    \});
			
			    it('Should fastUnmount child component when only parent has unmount callback', (done) => \{
			      interface WrapperProps \{
			        kill: boolean;
			      \}
			
			      class Wrapper extends Component<WrapperProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return (
			            <div>
			              <span>foobar</span>
			              <FooBar kill=\{this.props.kill\} />
			            </div>
			          );
			        \}
			      \}
			
			      interface FoobarProps \{
			        kill: boolean;
			      \}
			
			      class FooBar extends Component<FoobarProps> \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <span>\{!this.props.kill ? <Test /> : null\}</span>;
			        \}
			      \}
			
			      class Test extends Component \{
			        public render() \{
			          return (
			            <em>
			              <FastUnMountThis />
			            </em>
			          );
			        \}
			      \}
			
			      let dirtyReference: FastUnMountThis | null = null;
			      let updateFastUnmountedComponent: (() => void) | null = null;
			
			      interface FastUnMountThisState \{
			        text: string;
			      \}
			
			      class FastUnMountThis extends Component<unknown, FastUnMountThisState> \{
			        public state: FastUnMountThisState;
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            text: 'aa'
			          \};
			
			          dirtyReference = this;
			          updateFastUnmountedComponent = () => \{
			            this.changeText();
			          \};
			        \}
			
			        public changeText() \{
			          this.setState(\{
			            text: 'foo'
			          \});
			        \}
			
			        public render() \{
			          return <pre onclick=\{function () \{\}\}>\{this.state.text\}</pre>;
			        \}
			      \}
			
			      render(<Wrapper kill=\{false\} />, container);
			
			      const unMountSpy = spyOn(Wrapper.prototype, 'componentWillUnmount');
			      const unMountSpy2 = spyOn(FooBar.prototype, 'componentWillUnmount');
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span><em><pre>aa</pre></em></span></div>');
			
			      render(<Wrapper kill=\{true\} />, container);
			
			      setTimeout(() => \{
			        expect(container.innerHTML).toEqual('<div><span>foobar</span><span></span></div>');
			
			        expect(unMountSpy).not.toHaveBeenCalled();
			        expect(unMountSpy2).not.toHaveBeenCalled();
			
			        // This component is actually unmounted but fastUnmount skips unmount loop so unmounted remains false
			        expect(dirtyReference!.\$UN).toEqual(true);
			        // Try to do setState and verify it doesn't fail
			        updateFastUnmountedComponent!();
			
			        setTimeout(() => \{
			          expect(dirtyReference!.\$UN).toEqual(true);
			          expect(container.innerHTML).toEqual('<div><span>foobar</span><span></span></div>');
			
			          done();
			        \}, 10);
			      \}, 10);
			    \});
			
			    it('Should render call componentWillUnmount for children when later sibling has no lifecycle', () => \{
			      class Parent extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return (
			            <div>
			              <HasLife />
			              <NoLife />
			            </div>
			          );
			        \}
			      \}
			
			      // This should be able to fastUnmount
			      class NoLife extends Component \{
			        public render() \{
			          return <span>nolife</span>;
			        \}
			      \}
			
			      // This should have fastUnmount false
			      class HasLife extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <span>haslife</span>;
			        \}
			      \}
			
			      const unMountSpy = spyOn(Parent.prototype, 'componentWillUnmount');
			      const unMountSpy2 = spyOn(HasLife.prototype, 'componentWillUnmount');
			
			      render(<Parent />, container);
			
			      expect(unMountSpy).not.toHaveBeenCalled();
			      expect(unMountSpy2).not.toHaveBeenCalled();
			
			      expect(container.innerHTML).toEqual('<div><span>haslife</span><span>nolife</span></div>');
			
			      render(null, container);
			
			      expect(unMountSpy).toHaveBeenCalledTimes(1);
			      expect(unMountSpy2).toHaveBeenCalledTimes(1);
			    \});
			  \});
			
			  describe('Children lifecycle with fastUnmount Functional Components', () => \{
			    it('Should call componentWillUnmount for children', () => \{
			      let mountCalls = 0;
			      let unMountCalls = 0;
			      const foobarLifecycle = \{
			        componentWillMount: () => \{
			          mountCalls++;
			        \},
			        componentWillUnmount: () => \{
			          unMountCalls++;
			        \}
			      \};
			
			      function Wrapper(\{ bool \}) \{
			        return (
			          <div>
			            <span>foobar</span>
			            \{bool ? <FooBar onComponentWillMount=\{foobarLifecycle.componentWillMount\} onComponentWillUnmount=\{foobarLifecycle.componentWillUnmount\} /> : null\}
			          </div>
			        );
			      \}
			
			      function FooBar() \{
			        return <span>initial</span>;
			      \}
			
			      render(<Wrapper bool=\{true\} />, container);
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span>initial</span></div>');
			
			      expect(mountCalls).toEqual(1);
			      expect(unMountCalls).toEqual(0);
			
			      render(<Wrapper bool=\{false\} />, container); // Unmount child component
			      expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			
			      expect(mountCalls).toEqual(1);
			      expect(unMountCalls).toEqual(1);
			    \});
			
			    it('Should call componentWillUnmount for nested children', () => \{
			      let unMountCalls = 0;
			      let mountCalls = 0;
			
			      const testLifeCycle = \{
			        componentWillMount: () => \{
			          mountCalls++;
			        \},
			        componentWillUnmount: () => \{
			          unMountCalls++;
			        \}
			      \};
			
			      function Wrapper(\{ bool \}) \{
			        return (
			          <div>
			            <span>foobar</span>
			            \{bool ? <FooBar /> : null\}
			          </div>
			        );
			      \}
			
			      function FooBar() \{
			        return (
			          <span>
			            <Test onComponentWillMount=\{testLifeCycle.componentWillMount\} onComponentWillUnmount=\{testLifeCycle.componentWillUnmount\} />
			          </span>
			        );
			      \}
			
			      function Test() \{
			        return <em>f</em>;
			      \}
			
			      render(<Wrapper bool=\{true\} />, container);
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span><em>f</em></span></div>');
			
			      expect(mountCalls).toEqual(1);
			      expect(unMountCalls).toEqual(0);
			
			      render(<Wrapper bool=\{false\} />, container); // Unmount child component
			      expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			
			      expect(mountCalls).toEqual(1);
			      expect(unMountCalls).toEqual(1);
			    \});
			
			    it('Should call componentWillUnmount for nested children #2', () => \{
			      let unMountTest = 0;
			      let unMountFoo = 0;
			
			      const testLifeCycle = \{
			        componentWillUnmount: () => \{
			          unMountTest++;
			        \}
			      \};
			
			      const fooLifecycle = \{
			        componentWillUnmount: () => \{
			          unMountFoo++;
			        \}
			      \};
			
			      function Wrapper(\{ bool \}) \{
			        return (
			          <div>
			            <span>foobar</span>
			            \{bool ? <FooBar /> : null\}
			          </div>
			        );
			      \}
			
			      function FooBar() \{
			        return (
			          <span>
			            <Test onComponentWillUnmount=\{testLifeCycle.componentWillUnmount\} />
			            <Foo onComponentWillUnmount=\{fooLifecycle.componentWillUnmount\} />
			          </span>
			        );
			      \}
			
			      function Test() \{
			        return <em>f</em>;
			      \}
			
			      function Foo() \{
			        return <em>f</em>;
			      \}
			
			      render(<Wrapper bool=\{true\} />, container);
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span><em>f</em><em>f</em></span></div>');
			
			      render(<Wrapper bool=\{false\} />, container);
			      expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			      expect(unMountTest).toEqual(1);
			      expect(unMountFoo).toEqual(1);
			    \});
			
			    it('Should call componentWillUnmount for deeply nested children', () => \{
			      let unMountTest = 0;
			
			      const testLifecycle = \{
			        componentWillUnmount: () => \{
			          unMountTest++;
			        \}
			      \};
			
			      function Wrapper(\{ bool \}) \{
			        return (
			          <div>
			            <span>foobar</span>
			            \{bool ? <FooBar /> : null\}
			          </div>
			        );
			      \}
			
			      function FooBar() \{
			        return (
			          <span>
			            <span>
			              <span>
			                <span>
			                  <Test />
			                </span>
			              </span>
			            </span>
			          </span>
			        );
			      \}
			
			      function Test() \{
			        return <Test2 />;
			      \}
			
			      function Test2() \{
			        return <Test4 />;
			      \}
			
			      function Test4() \{
			        return (
			          <div>
			            <span />
			            <Test5 onComponentWillUnmount=\{testLifecycle.componentWillUnmount\} />
			            <span />
			          </div>
			        );
			      \}
			
			      function Test5() \{
			        return <h1>ShouldUnMountMe</h1>;
			      \}
			
			      render(<Wrapper bool=\{true\} />, container);
			
			      expect(container.innerHTML).toEqual(
			        '<div><span>foobar</span><span><span><span><span><div><span></span><h1>ShouldUnMountMe</h1><span></span></div></span></span></span></span></div>'
			      );
			
			      render(<Wrapper bool=\{false\} />, container);
			      expect(container.innerHTML).toEqual('<div><span>foobar</span></div>');
			
			      expect(unMountTest).toEqual(1);
			    \});
			
			    it('Should call componentWillUnmount for parent when children dont have componentWIllUnmount', (done) => \{
			      let unMountTest = 0;
			      let unMountTwoTest = 0;
			
			      const testLifecycle = \{
			        componentWillUnmount: () => \{
			          unMountTest++;
			        \},
			        componentWillUnmountTwo: () => \{
			          unMountTwoTest++;
			        \}
			      \};
			
			      function Wrapper() \{
			        return (
			          <div>
			            <span>foobar</span>
			            <FooBar onComponentWillUnmount=\{testLifecycle.componentWillUnmountTwo\} />
			          </div>
			        );
			      \}
			
			      function FooBar() \{
			        return (
			          <span>
			            <Test />
			          </span>
			        );
			      \}
			
			      function Test() \{
			        return <em>f</em>;
			      \}
			
			      render(<Wrapper onComponentWillUnmount=\{testLifecycle.componentWillUnmount\} />, container);
			
			      expect(container.innerHTML).toEqual('<div><span>foobar</span><span><em>f</em></span></div>');
			
			      render(null, container);
			      setTimeout(() => \{
			        expect(container.innerHTML).toEqual('');
			
			        expect(unMountTest).toEqual(1);
			        expect(unMountTwoTest).toEqual(1);
			        done();
			      \}, 10);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\children.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(43)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\clonenode.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			
			describe('CloneVNode use cases', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should be able to render hoisted node', () => \{
			    const a = ['foo', 'bar'];
			
			    render(<div>\{[a, a, a, a]\}</div>, container);
			
			    expect(container.innerHTML).toEqual('<div>foobarfoobarfoobarfoobar</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\clonenode.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\columnrender.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ isNullOrUndef \} from 'inferno-shared';
			import Spy = jasmine.Spy;
			
			describe('Columns like tests - (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('Column-like tests', () => \{
			    function buildTestCases(row, item, suffix) \{
			      return [
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'add one column -' + suffix,
			          update: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4)), row(3, item(5, 5))]
			        \},
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'add one item -' + suffix,
			          update: [row(1, item(1, 1), item(2, 2), item(5, 5)), row(2, item(3, 3), item(4, 4))]
			        \},
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'add one column and item -' + suffix,
			          update: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4), item(6, 6)), row(3, item(5, 5))]
			        \},
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'swap all items -' + suffix,
			          update: [row(1, item(2, 2), item(1, 1)), row(2, item(4, 4), item(3, 3))]
			        \},
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'remove first item -' + suffix,
			          update: [row(1, item(2, 2)), row(2, item(4, 4))]
			        \},
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'remove last item -' + suffix,
			          update: [row(1, item(1, 1)), row(2, item(3, 3))]
			        \},
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'remove all items-' + suffix,
			          update: [row(1), row(2)]
			        \},
			        \{
			          initial: [row(1, item(1, 1), item(2, 2)), row(2, item(3, 3), item(4, 4))],
			          name: 'remove all columns-' + suffix,
			          update: []
			        \}
			      ];
			    \}
			
			    function filterPlaceholders(_nodes) \{
			      const nodes = [].slice.apply(_nodes);
			      let len = nodes.length;
			      let i = 0;
			
			      while (i < len) \{
			        const node = nodes[i];
			
			        if (node.nodeType === 3 && node.nodeValue === '') \{
			          nodes.splice(i, 1);
			          len--;
			        \}
			        i++;
			      \}
			      return nodes;
			    \}
			
			    function verifyRenderResult(columns, _container) \{
			      // Verify root
			      const root = _container.firstChild;
			      const rootChildNodes = filterPlaceholders(root.childNodes);
			
			      expect(rootChildNodes.length).toBe(columns.length);
			      // Verify columns
			      for (let i = 0; i < rootChildNodes.length; i++) \{
			        const columnRoot = rootChildNodes[i];
			        const columnChildNodes = filterPlaceholders(columnRoot.childNodes);
			
			        expect(columnChildNodes.length).toBe(columns[i].items.length + 1);
			        expect(columnRoot.firstChild.innerHTML).toBe('column');
			
			        // Verify items
			        // Skip first - its hardcoded
			        for (let j = 1; j < columnChildNodes.length; j++) \{
			          const itemRoot = columnChildNodes[j];
			          expect(itemRoot.innerHTML).toBe(columns[i].items[j - 1].text.toString());
			        \}
			      \}
			    \}
			
			    function getDifferentObjects(arr1, arr2) \{
			      return arr1.filter(function (obj) \{
			        return !arr2.some(function (obj2) \{
			          return obj._testKey === obj2._testKey;
			        \});
			      \});
			    \}
			
			    function getSameObjects(arr1, arr2) \{
			      return arr1.filter(function (obj) \{
			        return arr2.some(function (obj2) \{
			          return obj._testKey === obj2._testKey;
			        \});
			      \});
			    \}
			
			    describe('columns KEYED', () => \{
			      // Item Keyed
			      function BuildItemKeyed(key, text) \{
			        return \{ _testKey: key, id: key, text \};
			      \}
			
			      // Row Keyed
			      function BuildRowKeyed(key, ...items) \{
			        return \{ _testKey: key, id: key, items \};
			      \}
			
			      const keyedTests = buildTestCases(BuildRowKeyed, BuildItemKeyed, 'KEYED');
			
			      interface ItemKeyedProps \{
			        text?: string;
			      \}
			
			      class ItemKeyed extends Component<ItemKeyedProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUpdate() \{\}
			
			        public componentWillMount() \{\}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div>\{this.props.text\}</div>;
			        \}
			      \}
			
			      interface ColumnKeyedProps \{
			        items: \{ id: string; text: string \}[];
			      \}
			
			      class ColumnKeyed extends Component<ColumnKeyedProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUpdate() \{\}
			
			        public componentWillMount() \{\}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          const items = this.props.items;
			
			          return (
			            <div>
			              <span key="column">column</span>
			              \{items.map((item) => (
			                <ItemKeyed key=\{item.id\} text=\{item.text\} />
			              ))\}
			            </div>
			          );
			        \}
			      \}
			
			      const ViewKeyed = (\{ columns \}) => (
			        <div>
			          \{columns.map((column) => (
			            <ColumnKeyed key=\{column.id\} items=\{column.items\} />
			          ))\}
			        </div>
			      );
			
			      let mountedColumnSpy: Spy = null as unknown as Spy;
			      let unmountColumnSpy = null as unknown as Spy;
			      let updateColumnSpy = null as unknown as Spy;
			      let mountedItemSpy = null as unknown as Spy;
			      let unmountItemSpy = null as unknown as Spy;
			      let updateItemSpy = null as unknown as Spy;
			
			      beforeEach(function () \{
			        mountedColumnSpy = spyOn(ColumnKeyed.prototype, 'componentWillMount');
			        unmountColumnSpy = spyOn(ColumnKeyed.prototype, 'componentWillUnmount');
			        updateColumnSpy = spyOn(ColumnKeyed.prototype, 'componentWillUpdate');
			        mountedItemSpy = spyOn(ItemKeyed.prototype, 'componentWillMount');
			        unmountItemSpy = spyOn(ItemKeyed.prototype, 'componentWillUnmount');
			        updateItemSpy = spyOn(ItemKeyed.prototype, 'componentWillUpdate');
			      \});
			
			      afterEach(function () \{
			        mountedColumnSpy.calls.reset();
			        unmountColumnSpy.calls.reset();
			        updateColumnSpy.calls.reset();
			        mountedItemSpy.calls.reset();
			        unmountItemSpy.calls.reset();
			        updateItemSpy.calls.reset();
			      \});
			
			      keyedTests.forEach((testCase) => \{
			        it('Should ' + testCase.name, () => \{
			          const columnsToBeAdded = getDifferentObjects(testCase.update, testCase.initial);
			          const columnsToUpdate = getSameObjects(testCase.update, testCase.initial);
			          const columnsToRemove = getDifferentObjects(testCase.initial, testCase.update);
			
			          let itemsToBeAdded = [];
			          let itemsToUpdate = [];
			          let itemsToRemove = [];
			          let initialItemsCount = 0;
			
			          for (let i = 0; i < testCase.update.length || i < testCase.initial.length; i++) \{
			            const updateColumns = testCase.update[i];
			            const intialColumns = testCase.initial[i];
			
			            if (!isNullOrUndef(updateColumns)) \{
			              if (!isNullOrUndef(intialColumns)) \{
			                itemsToBeAdded = itemsToBeAdded.concat(getDifferentObjects(updateColumns.items, intialColumns.items));
			                itemsToRemove = itemsToRemove.concat(getDifferentObjects(intialColumns.items, updateColumns.items));
			                itemsToUpdate = itemsToUpdate.concat(getSameObjects(updateColumns.items, intialColumns.items));
			                initialItemsCount += intialColumns.items.length;
			              \} else \{
			                itemsToBeAdded = itemsToBeAdded.concat(updateColumns.items);
			              \}
			            \} else \{
			              if (!isNullOrUndef(intialColumns)) \{
			                initialItemsCount += intialColumns.items.length;
			                itemsToRemove = itemsToRemove.concat(intialColumns.items);
			              \} else \{
			                // Do nothing
			              \}
			            \}
			          \}
			
			          // Do initial render
			          render(<ViewKeyed columns=\{testCase.initial\} />, container);
			          verifyRenderResult(testCase.initial, container);
			          expect(mountedColumnSpy.calls.count()).toBe(testCase.initial.length); // Initial all mounted
			          expect(unmountColumnSpy.calls.count()).toBe(0); // Initial render none unmounted
			          expect(updateColumnSpy.calls.count()).toBe(0); // Initial render none to update
			
			          expect(mountedItemSpy.calls.count()).toBe(initialItemsCount); // Initial render - mount all items once
			          expect(updateItemSpy.calls.count()).toBe(0); // Initial render none to update
			          expect(unmountItemSpy.calls.count()).toBe(0); // Initial render none unmounted
			
			          // reset call counts
			          mountedColumnSpy.calls.reset();
			          unmountColumnSpy.calls.reset();
			          updateColumnSpy.calls.reset();
			          mountedItemSpy.calls.reset();
			          updateItemSpy.calls.reset();
			          unmountItemSpy.calls.reset();
			
			          // Do update
			          render(<ViewKeyed columns=\{testCase.update\} />, container);
			          verifyRenderResult(testCase.update, container);
			
			          expect(mountedColumnSpy.calls.count()).toBe(columnsToBeAdded.length); // mount count should equal to added count
			          expect(unmountColumnSpy.calls.count()).toBe(columnsToRemove.length); // Initial render none unmounted
			          expect(updateColumnSpy.calls.count()).toBe(columnsToUpdate.length); // Initial render none unmounted
			          expect(mountedItemSpy.calls.count()).toBe(itemsToBeAdded.length); // Initial render - mount all items once
			          expect(updateItemSpy.calls.count()).toBe(itemsToUpdate.length); // Initial render none to update
			          expect(unmountItemSpy.calls.count()).toBe(itemsToRemove.length); // Initial render none unmounted
			        \});
			      \});
			    \});
			
			    describe('columns NON-KEYED', () => \{
			      // Item Keyed
			      function BuildItem(key, text) \{
			        return \{ _testKey: key, text \};
			      \}
			
			      // Row Keyed
			      function BuildRow(key, ...items) \{
			        return \{ _testKey: key, items \};
			      \}
			
			      const nonKeyedTestCases = buildTestCases(BuildRow, BuildItem, 'NON-KEYED');
			
			      interface ItemProps \{
			        text: string;
			      \}
			
			      class Item extends Component<ItemProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUpdate() \{\}
			
			        public componentWillMount() \{\}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div>\{this.props.text\}</div>;
			        \}
			      \}
			
			      interface ColumnProps \{
			        items: \{ text: string \}[];
			      \}
			
			      class Column extends Component<ColumnProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentWillUpdate() \{\}
			
			        public componentWillMount() \{\}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          const items = this.props.items;
			
			          return (
			            <div>
			              <span>column</span>
			              \{items.map((item) => (
			                <Item text=\{item.text\} />
			              ))\}
			            </div>
			          );
			        \}
			      \}
			
			      const View = (\{ columns \}) => (
			        <div>
			          \{columns.map((column) => (
			            <Column items=\{column.items\} />
			          ))\}
			        </div>
			      );
			
			      let mountedColumnSpy = null as unknown as Spy;
			      let unmountColumnSpy = null as unknown as Spy;
			      let updateColumnSpy = null as unknown as Spy;
			      let mountedItemSpy = null as unknown as Spy;
			      let unmountItemSpy = null as unknown as Spy;
			      let updateItemSpy = null as unknown as Spy;
			
			      beforeEach(function () \{
			        mountedColumnSpy = spyOn(Column.prototype, 'componentWillMount');
			        unmountColumnSpy = spyOn(Column.prototype, 'componentWillUnmount');
			        updateColumnSpy = spyOn(Column.prototype, 'componentWillUpdate');
			        mountedItemSpy = spyOn(Item.prototype, 'componentWillMount');
			        unmountItemSpy = spyOn(Item.prototype, 'componentWillUnmount');
			        updateItemSpy = spyOn(Item.prototype, 'componentWillUpdate');
			      \});
			
			      afterEach(function () \{
			        mountedColumnSpy.calls.reset();
			        unmountColumnSpy.calls.reset();
			        updateColumnSpy.calls.reset();
			        mountedItemSpy.calls.reset();
			        unmountItemSpy.calls.reset();
			        updateItemSpy.calls.reset();
			      \});
			
			      nonKeyedTestCases.forEach((testCase) => \{
			        it('Should ' + testCase.name, () => \{
			          const columnsToBeAdded = getDifferentObjects(testCase.update, testCase.initial);
			          const columnsToUpdate = getSameObjects(testCase.update, testCase.initial);
			          const columnsToRemove = getDifferentObjects(testCase.initial, testCase.update);
			
			          let itemsToBeAdded = [];
			          let itemsToUpdate = [];
			          let itemsToRemove = [];
			          let initialItemsCount = 0;
			
			          for (let i = 0; i < testCase.update.length || i < testCase.initial.length; i++) \{
			            const updateColumns = testCase.update[i];
			            const intialColumns = testCase.initial[i];
			
			            if (!isNullOrUndef(updateColumns)) \{
			              if (!isNullOrUndef(intialColumns)) \{
			                itemsToBeAdded = itemsToBeAdded.concat(getDifferentObjects(updateColumns.items, intialColumns.items));
			                itemsToRemove = itemsToRemove.concat(getDifferentObjects(intialColumns.items, updateColumns.items));
			                itemsToUpdate = itemsToUpdate.concat(getSameObjects(updateColumns.items, intialColumns.items));
			                initialItemsCount += intialColumns.items.length;
			              \} else \{
			                itemsToBeAdded = itemsToBeAdded.concat(updateColumns.items);
			              \}
			            \} else \{
			              if (!isNullOrUndef(intialColumns)) \{
			                initialItemsCount += intialColumns.items.length;
			                itemsToRemove = itemsToRemove.concat(intialColumns.items);
			              \} else \{
			                // Do nothing
			              \}
			            \}
			          \}
			
			          // Do initial render
			          render(<View columns=\{testCase.initial\} />, container);
			          verifyRenderResult(testCase.initial, container);
			          expect(mountedColumnSpy.calls.count()).toBe(testCase.initial.length); // Initial all mounted
			          expect(unmountColumnSpy.calls.count()).toBe(0); // Initial render none unmounted
			          expect(updateColumnSpy.calls.count()).toBe(0); // Initial render none to update
			
			          expect(mountedItemSpy.calls.count()).toBe(initialItemsCount); // Initial render - mount all items once
			          expect(updateItemSpy.calls.count()).toBe(0); // Initial render none to update
			          expect(unmountItemSpy.calls.count()).toBe(0); // Initial render none unmounted
			
			          // reset call counts
			          mountedColumnSpy.calls.reset();
			          unmountColumnSpy.calls.reset();
			          updateColumnSpy.calls.reset();
			          mountedItemSpy.calls.reset();
			          updateItemSpy.calls.reset();
			          unmountItemSpy.calls.reset();
			
			          // Do update
			          render(<View columns=\{testCase.update\} />, container);
			          verifyRenderResult(testCase.update, container);
			
			          expect(mountedColumnSpy.calls.count()).toBe(columnsToBeAdded.length); // mount count should equal to added count
			          expect(unmountColumnSpy.calls.count()).toBe(columnsToRemove.length); // Initial render none unmounted
			          expect(updateColumnSpy.calls.count()).toBe(columnsToUpdate.length); // Initial render none unmounted
			          expect(mountedItemSpy.calls.count()).toBe(itemsToBeAdded.length); // Initial render - mount all items once
			          expect(updateItemSpy.calls.count()).toBe(itemsToUpdate.length); // Initial render none to update
			          expect(unmountItemSpy.calls.count()).toBe(itemsToRemove.length); // Initial render none unmounted
			        \});
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\columnrender.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\component.comparator.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, options, render \} from 'inferno';
			
			describe('top level context', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			
			    options.componentComparator = null;
			  \});
			
			  it('Should be possible to use custom component comparator to avoid replacing whole subtree', () => \{
			    class ComponentA extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 123
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\}</div>;
			      \}
			    \}
			
			    class ComponentB extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 333
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\} new</div>;
			      \}
			    \}
			
			    options.componentComparator = function () \{
			      // Simulate ComponentA being changed
			      ComponentA.prototype.render = ComponentB.prototype.render;
			      ComponentA.constructor = ComponentB.constructor;
			
			      return false;
			    \};
			
			    render(<ComponentA />, container);
			
			    expect(container.innerHTML).toBe('<div>123</div>');
			
			    const oldNode = container.firstChild;
			
			    render(<ComponentB />, container);
			
			    expect(container.innerHTML).toBe('<div>123 new</div>');
			
			    expect(container.firstChild).toBe(oldNode);
			  \});
			
			  it('Should be possible to use custom component comparator to avoid replacing whole subtree', () => \{
			    class ComponentA extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 123
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\}</div>;
			      \}
			    \}
			
			    class ComponentB extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 333
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\} new</div>;
			      \}
			    \}
			
			    options.componentComparator = function () \{
			      // Simulate ComponentA being changed
			      ComponentA.prototype.render = ComponentB.prototype.render;
			      ComponentA.constructor = ComponentB.constructor;
			
			      return false;
			    \};
			
			    render(<ComponentA />, container);
			
			    expect(container.innerHTML).toBe('<div>123</div>');
			
			    const oldNode = container.firstChild;
			
			    render(<ComponentB />, container);
			
			    expect(container.innerHTML).toBe('<div>123 new</div>');
			
			    expect(container.firstChild).toBe(oldNode);
			  \});
			
			  it('Should override keys, flags, reCreate', () => \{
			    class ComponentA extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 123
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\}</div>;
			      \}
			    \}
			
			    class ComponentB extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 333
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\} new</div>;
			      \}
			    \}
			
			    options.componentComparator = function () \{
			      // Simulate ComponentA being changed
			      ComponentA.prototype.render = ComponentB.prototype.render;
			      ComponentA.constructor = ComponentB.constructor;
			
			      return false;
			    \};
			
			    render(<ComponentA key=\{'a'\} \$ReCreate />, container);
			
			    expect(container.innerHTML).toBe('<div>123</div>');
			
			    const oldNode = container.firstChild;
			
			    render(<ComponentB key=\{'b'\} \$ReCreate />, container);
			
			    expect(container.innerHTML).toBe('<div>123 new</div>');
			
			    expect(container.firstChild).toBe(oldNode);
			  \});
			
			  it('Should do normal replace if comparator returns true', () => \{
			    class ComponentA extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 123
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\}</div>;
			      \}
			    \}
			
			    class ComponentB extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          abc: 333
			        \};
			      \}
			
			      public render() \{
			        return <div>\{this.state!.abc\} new</div>;
			      \}
			    \}
			
			    options.componentComparator = function () \{
			      // Simulate ComponentA being changed
			      ComponentA.prototype.render = ComponentB.prototype.render;
			      ComponentA.constructor = ComponentB.constructor;
			
			      return true;
			    \};
			
			    render(<ComponentA key=\{'a'\} \$ReCreate />, container);
			
			    expect(container.innerHTML).toBe('<div>123</div>');
			
			    const oldNode = container.firstChild;
			
			    render(<ComponentB key=\{'b'\} \$ReCreate />, container);
			
			    expect(container.innerHTML).toBe('<div>333 new</div>');
			
			    expect(container.firstChild).not.toBe(oldNode);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\component.comparator.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\componentlifecycle.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render, rerender \} from 'inferno';
			
			/* tslint:disable:no-console */
			
			describe('Component lifecycle', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('componentWillUpdate Should have nextProp in params and old variants in instance', () => \{
			    let callCount = 0;
			
			    class Com extends Component<\{ value: number \}> \{
			      public componentWillUpdate(nextProps) \{
			        callCount++;
			        expect(this.props.value).toBe(1);
			        expect(nextProps.value).toBe(2);
			      \}
			
			      public render() \{
			        return <div>\{this.props.value\}</div>;
			      \}
			    \}
			
			    render(<Com value=\{1\} />, container);
			
			    expect(container.innerHTML).toBe('<div>1</div>');
			
			    render(<Com value=\{2\} />, container);
			
			    expect(callCount).toBe(1);
			    expect(container.innerHTML).toBe('<div>2</div>');
			  \});
			
			  it('Current state in componentWillUpdate should not equal nextState if setState is called from componentWillReceiveProps', () => \{
			    let doSomething;
			
			    class Child extends Component<\{ active: boolean \}, \{ active: boolean \}> \{
			      public state = \{
			        active: false
			      \};
			
			      constructor() \{
			        super();
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        if (!this.props.active && nextProps.active) \{
			          this.setState(\{
			            active: true
			          \});
			        \}
			      \}
			
			      public componentWillUpdate(_nextProps, nextState) \{
			        expect(this.state.active).toBe(false);
			        expect(nextState.active).toBe(true);
			      \}
			
			      public render() \{
			        return <div>\{this.state.active ? 'true' : 'false'\}</div>;
			      \}
			    \}
			
			    class Parent extends Component<\{\}, \{ active: boolean \}> \{
			      public state = \{
			        active: false
			      \};
			
			      constructor() \{
			        super();
			        doSomething = this._setActive = this._setActive.bind(this);
			      \}
			
			      public _setActive() \{
			        this.setState(\{
			          active: true
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Child active=\{this.state.active\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    expect(container.innerHTML).toBe('<div><div>false</div></div>');
			
			    doSomething();
			
			    rerender();
			
			    expect(container.innerHTML).toBe('<div><div>true</div></div>');
			  \});
			
			  it('shouldComponentUpdate Should have nextProp in params and old variants in instance', () => \{
			    let callCount = 0;
			
			    class Com extends Component<\{ value: number \}> \{
			      public shouldComponentUpdate(nextProps) \{
			        callCount++;
			        expect(this.props.value).toBe(1);
			        expect(nextProps.value).toBe(2);
			
			        return true;
			      \}
			
			      public render() \{
			        return <div>\{this.props.value\}</div>;
			      \}
			    \}
			
			    render(<Com value=\{1\} />, container);
			
			    expect(container.innerHTML).toBe('<div>1</div>');
			
			    render(<Com value=\{2\} />, container);
			
			    expect(callCount).toBe(1);
			    expect(container.innerHTML).toBe('<div>2</div>');
			  \});
			
			  it('Should call componentWillUnmount before node is removed from DOM tree', () => \{
			    class Parent extends Component<\{ foo: boolean \}> \{
			      public render() \{
			        if (this.props.foo) \{
			          return (
			            <div>
			              <p>just to make it go removeAll</p>
			              <Child />
			            </div>
			          );
			        \}
			
			        return (
			          <div>
			            <p>just to make it go removeAll</p>
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component \{
			      private element: Element;
			
			      public componentWillUnmount() \{
			        // verify its not removed from DOM tree yet.
			        expect(this.element.parentElement != null ? this.element.parentElement.parentElement : null).toBe(container);
			      \}
			
			      public render() \{
			        // eslint-disable-next-line
			        return (
			          <div className="foobar" ref=\{(el) => (this.element = el!)\}>
			            1
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent foo=\{true\} />, container);
			    expect(container.querySelectorAll('.foobar').length).toBe(1);
			    render(<Parent foo=\{false\} />, container);
			    // Verify the specific div is removed now
			    expect(container.querySelectorAll('.foobar').length).toBe(0);
			  \});
			
			  it('Should not fail if componentDidUpdate is undefined #922', () => \{
			    let c;
			
			    class Com extends Component<\{ value: number \}> \{
			      public componentDidUpdate(nextProps) \{
			        expect(this.props.value).toBe(1);
			        expect(nextProps.value).toBe(2);
			
			        return true;
			      \}
			
			      public render() \{
			        return <div>\{this.props.value\}</div>;
			      \}
			    \}
			
			    // eslint-disable-next-line no-return-assign
			    render(
			      <Com
			        ref=\{(inst) => \{
			          c = inst;
			        \}\}
			        value=\{1\}
			      />,
			      container
			    );
			
			    c.componentDidUpdate = undefined;
			
			    // eslint-disable-next-line no-return-assign
			    render(<Com ref=\{(inst) => (c = inst)\} value=\{2\} />, container);
			  \});
			\});
			
			describe('legacy life cycle', () => \{
			  let consoleErrorStub;
			  let container;
			
			  beforeEach(() => \{
			    consoleErrorStub = spyOn(console, 'error');
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should warn when mix legacy life cycle with new ones', () => \{
			    /* tslint:disable:member-access no-empty */
			
			    // build the component and element to be rendered
			    class Foo extends Component \{
			      // just added to force the warnings
			      static getDerivedStateFromProps() \{\}
			
			      componentWillMount() \{\}
			
			      componentWillReceiveProps() \{\}
			
			      componentWillUpdate() \{\}
			
			      render() \{
			        return <div>Foo</div>;
			      \}
			    \}
			
			    const element = <Foo />;
			
			    // render the element
			    render(element, container);
			
			    // retrieve the arguments of all calls for console.error
			    // so multiple calls to console.error should not broke this test
			
			    expect(consoleErrorStub).toHaveBeenCalledTimes(1);
			
			    const message = consoleErrorStub.calls.argsFor(0)[0];
			    expect(message.indexOf('componentWillMount')).toBeGreaterThan(-1);
			    expect(message.indexOf('componentWillReceiveProps')).toBeGreaterThan(-1);
			    expect(message.indexOf('componentWillUpdate')).toBeGreaterThan(-1);
			  \});
			
			  it('should allow suppress legacy life cycles when mixed with new APIs', () => \{
			    /* tslint:disable:member-access no-empty */
			    // build the component and element to be rendered
			    class Foo extends Component \{
			      // just added to force the warnings
			      static getDerivedStateFromProps() \{\}
			
			      componentWillMount() \{\}
			
			      componentWillReceiveProps() \{\}
			
			      componentWillUpdate() \{\}
			
			      render() \{
			        return <div>Foo</div>;
			      \}
			    \}
			
			    // suppress the warnings
			    // @ts-ignore
			    Foo.prototype.componentWillMount.__suppressDeprecationWarning = true;
			    // @ts-ignore
			    Foo.prototype.componentWillReceiveProps.__suppressDeprecationWarning = true;
			    // @ts-ignore
			    Foo.prototype.componentWillUpdate.__suppressDeprecationWarning = true;
			
			    const element = <Foo />;
			    // render the element
			    render(element, container);
			
			    expect(console.error).toHaveBeenCalledTimes(0);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\componentlifecycle.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\components2.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			/* These must be in their own files for test to reproduce */
			import \{ ParentFirstCommon \} from './data/common-render/parentfirstcommon';
			import \{ ParentSecondCommon \} from './data/common-render/parentsecondcommon';
			
			describe('Components (JSX) #2', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    container.style.display = 'none';
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  describe('tracking DOM state', () => \{
			    class ComponentA extends Component \{
			      public render() \{
			        return (
			          <div>
			            <span>Something</span>
			          </div>
			        );
			      \}
			    \}
			
			    class ComponentB extends Component \{
			      public render() \{
			        return (
			          <div>
			            <span>Something</span>
			          </div>
			        );
			      \}
			    \}
			
			    interface ComponentBWithStateChangeState \{
			      text: string;
			    \}
			
			    class ComponentBWithStateChange extends Component<unknown, ComponentBWithStateChangeState> \{
			      public state: ComponentBWithStateChangeState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          text: ''
			        \};
			      \}
			
			      public componentWillMount() \{
			        this.setState(\{
			          text: 'newText'
			        \});
			
			        this.setState(\{
			          text: 'newText2'
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <span>\{this.state.text\}</span>
			          </div>
			        );
			      \}
			    \}
			
			    function ComA() \{
			      return (
			        <div>
			          <span>Something</span>
			        </div>
			      );
			    \}
			
			    function ComB() \{
			      return (
			        <div>
			          <span>Something</span>
			        </div>
			      );
			    \}
			
			    it('patching component A to component B, given they have the same children, should replace DOM tree ( for lifecycle ) with identical one', () => \{
			      render(<ComponentA />, container);
			      expect(container.innerHTML).toBe('<div><span>Something</span></div>');
			      const trackElemDiv = container.firstChild;
			      const trackElemSpan = container.firstChild.firstChild;
			
			      render(<ComponentB />, container);
			      // These are same but not equal
			      expect(container.innerHTML).toBe('<div><span>Something</span></div>');
			      expect(container.firstChild === trackElemDiv).toBe(false);
			      expect(container.firstChild.firstChild === trackElemSpan).toBe(false);
			    \});
			
			    it('patching component A to component B, given they have the same children, should not change the DOM tree when stateless components', () => \{
			      render(<ComA />, container);
			      expect(container.innerHTML).toBe('<div><span>Something</span></div>');
			      const trackElemDiv = container.firstChild;
			      const trackElemSpan = container.firstChild.firstChild;
			
			      render(<ComB />, container);
			      expect(container.innerHTML).toBe('<div><span>Something</span></div>');
			
			      expect(container.firstChild === trackElemDiv).toBe(false);
			      expect(container.firstChild.firstChild === trackElemSpan).toBe(false);
			    \});
			
			    it('Should not crash when ComB does setState while changing', () => \{
			      render(<ComponentA />, container);
			      expect(container.innerHTML).toBe('<div><span>Something</span></div>');
			      const trackElemDiv = container.firstChild;
			      const trackElemSpan = container.firstChild.firstChild;
			
			      render(<ComponentBWithStateChange />, container);
			      // These are same but not equal
			      expect(container.innerHTML).toBe('<div><span>newText2</span></div>');
			      expect(container.firstChild === trackElemDiv).toBe(false);
			      expect(container.firstChild.firstChild === trackElemSpan).toBe(false);
			    \});
			  \});
			
			  describe('Inheritance with common render', () => \{
			    interface ChildProps \{
			      name: string;
			    \}
			
			    interface ChildState \{
			      data: string;
			    \}
			
			    class Child extends Component<ChildProps, ChildState> \{
			      public state: ChildState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{ data: '' \};
			
			        this._update = this._update.bind(this);
			      \}
			
			      public _update() \{
			        this.setState(\{
			          data: 'bar'
			        \});
			      \}
			
			      public componentWillMount() \{
			        this.setState(\{
			          data: 'foo'
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div onclick=\{this._update\}>
			            \{this.props.name\}
			            \{this.state.data\}
			          </div>
			        );
			      \}
			    \}
			
			    class ParentBase extends Component \{
			      protected foo: string;
			
			      public render() \{
			        return (
			          <div>
			            <Child name=\{this.foo\} />
			          </div>
			        );
			      \}
			    \}
			
			    class ParentFirst extends ParentBase \{
			      constructor(props) \{
			        super(props);
			
			        this.foo = 'First';
			      \}
			    \}
			
			    class ParentSecond extends ParentBase \{
			      constructor(props) \{
			        super(props);
			
			        this.foo = 'Second';
			      \}
			    \}
			
			    // For some reason this one breaks but if components are imported separately, it works
			    it('Should not reuse children if parent changes #1', () => \{
			      render(<ParentFirst />, container);
			      expect(container.innerHTML).toBe('<div><div>Firstfoo</div></div>');
			      container.firstChild.firstChild.click();
			
			      expect(container.innerHTML).toBe('<div><div>Firstbar</div></div>');
			      render(<ParentSecond />, container);
			
			      expect(container.innerHTML).toBe('<div><div>Secondfoo</div></div>');
			    \});
			  \});
			
			  describe('Inheritance with duplicate render', () => \{
			    interface ChildProps \{
			      name: string;
			    \}
			
			    interface ChildState \{
			      data: string;
			    \}
			
			    class Child extends Component<ChildProps, ChildState> \{
			      public state: ChildState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          data: ''
			        \};
			
			        this._update = this._update.bind(this);
			      \}
			
			      public _update() \{
			        this.setState(\{
			          data: 'bar'
			        \});
			      \}
			
			      public componentWillMount() \{
			        this.setState(\{
			          data: 'foo'
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div onclick=\{this._update\}>
			            \{this.props.name\}
			            \{this.state.data\}
			          </div>
			        );
			      \}
			    \}
			
			    class ParentFirst extends Component \{
			      protected foo: string;
			
			      constructor(props) \{
			        super(props);
			
			        this.foo = 'First';
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Child name=\{this.foo\} />
			          </div>
			        );
			      \}
			    \}
			
			    class ParentSecond extends Component \{
			      protected foo: string;
			
			      constructor(props) \{
			        super(props);
			
			        this.foo = 'Second';
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Child name=\{this.foo\} />
			          </div>
			        );
			      \}
			    \}
			
			    // For some reason this one breaks but if components are imported separately, it works
			    it('Should not reuse children if parent changes #2', () => \{
			      render(<ParentFirst />, container);
			      expect(container.innerHTML).toBe('<div><div>Firstfoo</div></div>');
			      container.firstChild.firstChild.click();
			      expect(container.innerHTML).toBe('<div><div>Firstbar</div></div>');
			      render(<ParentSecond />, container);
			      expect(container.innerHTML).toBe('<div><div>Secondfoo</div></div>');
			    \});
			  \});
			
			  describe('Inheritance with 1 component per file Common BASE', () => \{
			    it('Should not reuse children if parent changes #3', () => \{
			      render(<ParentFirstCommon />, container);
			      expect(container.innerHTML).toBe('<div><div>Firstfoo</div></div>');
			      container.firstChild.firstChild.click();
			      expect(container.innerHTML).toBe('<div><div>Firstbar</div></div>');
			      render(<ParentSecondCommon />, container);
			      expect(container.innerHTML).toBe('<div><div>Secondfoo</div></div>');
			    \});
			  \});
			
			  describe('should handle defaultProps and keys being pass into components', () => \{
			    interface CompProps \{
			      foo: string;
			    \}
			    class Comp extends Component<CompProps> \{
			      public render() \{
			        return this.props.foo;
			      \}
			
			      public static defaultProps = \{
			        foo: 'bar'
			      \};
			    \}
			
			    it('should render the component with a key', () => \{
			      let val: string | number = '1';
			
			      render(<Comp key=\{val\} />, container);
			      expect(container.innerHTML).toBe('bar');
			      val = 2;
			      render(<Comp key=\{val\} />, container);
			      expect(container.innerHTML).toBe('bar');
			    \});
			  \});
			
			  describe('Force update', () => \{
			    it('Should not call shouldComponentUpdate', () => \{
			      let test = false;
			      let called = false;
			      let doForce;
			
			      class FooBar extends Component \{
			        constructor(props) \{
			          super(props);
			
			          doForce = this.doForceUpdate.bind(this);
			        \}
			
			        public shouldComponentUpdate() \{
			          test = true;
			
			          return false;
			        \}
			
			        public doForceUpdate() \{
			          called = true;
			          this.forceUpdate();
			        \}
			
			        public render() \{
			          return <div>1</div>;
			        \}
			      \}
			
			      render(<FooBar />, container);
			
			      expect(container.innerHTML).toEqual('<div>1</div>');
			      expect(test).toEqual(false);
			      expect(called).toEqual(false);
			
			      doForce();
			
			      expect(test).toEqual(false);
			      expect(called).toEqual(true);
			      expect(container.innerHTML).toEqual('<div>1</div>');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\components2.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\createref.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createRef, InfernoNode, RefObject, render, rerender \} from 'inferno';
			
			describe('createRef', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should add DOM reference to "current" of ref', () => \{
			    let instanceTesting: Testing | null = null;
			
			    class Testing extends Component \{
			      public render() \{
			        instanceTesting = this;
			        return 1;
			      \}
			    \}
			
			    function Functional() \{
			      return 'foobar';
			    \}
			
			    class Foobar extends Component \{
			      private readonly element: RefObject<HTMLSpanElement>;
			      private readonly es6: RefObject<Testing>;
			      private readonly functional: RefObject<unknown>;
			
			      constructor(props) \{
			        super(props);
			
			        this.element = createRef();
			        this.es6 = createRef();
			        this.functional = createRef();
			      \}
			
			      public componentWillMount() \{
			        expect(this.element.current).toBe(null);
			        expect(this.es6.current).toBe(null);
			        expect(this.functional.current).toBe(null);
			      \}
			
			      public componentDidMount() \{
			        expect(this.element.current).toBe(container.querySelector('#span'));
			        expect(this.es6.current).toBe(instanceTesting);
			        expect(this.functional.current).toBe(null);
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <span id="span" ref=\{this.element\}>
			              Ok
			            </span>
			            <Testing ref=\{this.es6\} />
			            \{/* @ts-expect-error ref is not valid for functional component */\}
			            <Functional ref=\{this.functional\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Foobar />, container);
			    rerender();
			  \});
			
			  it('Should update callback ref for Components too', () => \{
			    let instanceTesting: Testing | null = null;
			
			    class Testing extends Component \{
			      public render() \{
			        instanceTesting = this;
			        return 1;
			      \}
			    \}
			
			    let oldCounter = 0;
			    let oldValue = null;
			    let newCounter = 0;
			    let newValue = null;
			
			    interface FoobarProps \{
			      swap?: boolean;
			    \}
			
			    class Foobar extends Component<FoobarProps> \{
			      private readonly es6Old: (arg) => void;
			      private readonly es6new: (arg) => void;
			
			      constructor(props) \{
			        super(props);
			
			        this.es6Old = function (arg) \{
			          oldCounter++;
			          oldValue = arg;
			        \};
			        this.es6new = function (arg) \{
			          newCounter++;
			          newValue = arg;
			        \};
			      \}
			
			      public render(props) \{
			        return (
			          <div>
			            <Testing ref=\{props.swap ? this.es6Old : this.es6new\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Foobar swap=\{true\} />, container);
			
			    expect(oldCounter).toBe(1);
			    expect(oldValue).toBe(instanceTesting);
			    expect(newCounter).toBe(0);
			    expect(newValue).toBe(null);
			
			    render(<Foobar swap=\{false\} />, container);
			
			    expect(oldCounter).toBe(2);
			    expect(oldValue).toBe(null);
			    expect(newCounter).toBe(1);
			    expect(newValue).toBe(instanceTesting);
			  \});
			
			  it('Should update callback ref for element vNodes too', () => \{
			    let oldCounter = 0;
			    let oldValue = null;
			    let newCounter = 0;
			    let newValue = null;
			
			    interface FoobarProps \{
			      swap?: boolean;
			    \}
			
			    class Foobar extends Component<FoobarProps> \{
			      private readonly es6Old: (arg) => void;
			      private readonly es6new: (arg) => void;
			
			      constructor(props) \{
			        super(props);
			
			        this.es6Old = function (arg) \{
			          oldCounter++;
			          oldValue = arg;
			        \};
			        this.es6new = function (arg) \{
			          newCounter++;
			          newValue = arg;
			        \};
			      \}
			
			      public render(props) \{
			        return (
			          <div>
			            <div id=\{'divi'\} ref=\{props.swap ? this.es6Old : this.es6new\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Foobar swap=\{true\} />, container);
			
			    const instanceTesting = container.querySelector('#divi');
			
			    expect(oldCounter).toBe(1);
			    expect(oldValue).toBe(instanceTesting);
			    expect(newCounter).toBe(0);
			    expect(newValue).toBe(null);
			
			    render(<Foobar swap=\{false\} />, container);
			
			    expect(oldCounter).toBe(2);
			    expect(oldValue).toBe(null);
			    expect(newCounter).toBe(1);
			    expect(newValue).toBe(instanceTesting);
			  \});
			
			  it('Should update refs and unmount them', () => \{
			    let instance: Foobar | null = null;
			
			    let instanceTesting: Testing | null = null;
			
			    class Testing extends Component \{
			      public render() \{
			        instanceTesting = this;
			        return 1;
			      \}
			    \}
			
			    function Functional() \{
			      return 'foobar';
			    \}
			
			    class Foobar extends Component \{
			      public readonly elementOld: RefObject<HTMLSpanElement>;
			      public readonly elementNew: RefObject<HTMLSpanElement>;
			      public readonly es6Old: RefObject<Testing>;
			      public readonly es6new: RefObject<Testing>;
			      public readonly functionalOLD: RefObject<unknown>;
			      public readonly functionalNEW: RefObject<unknown>;
			
			      constructor(props) \{
			        super(props);
			
			        instance = this;
			
			        this.elementNew = createRef();
			        this.elementOld = createRef();
			        this.es6Old = createRef();
			        this.es6new = createRef();
			        this.functionalOLD = createRef();
			        this.functionalNEW = createRef();
			
			        this.state = \{
			          swap: true
			        \};
			      \}
			
			      public componentWillMount() \{
			        expect(this.elementNew.current).toBe(null);
			        expect(this.elementOld.current).toBe(null);
			        expect(this.es6Old.current).toBe(null);
			        expect(this.es6new.current).toBe(null);
			        expect(this.functionalOLD.current).toBe(null);
			        expect(this.functionalNEW.current).toBe(null);
			      \}
			
			      public componentDidMount() \{
			        expect(this.elementNew.current).toBe(null);
			        expect(this.elementOld.current).toBe(container.querySelector('#span'));
			        expect(this.es6Old.current).toBe(instanceTesting);
			        expect(this.es6new.current).toBe(null);
			        expect(this.functionalOLD.current).toBe(null);
			        expect(this.functionalNEW.current).toBe(null);
			
			        this.setState(\{
			          swap: false
			        \});
			      \}
			
			      public render(_props, \{ swap \}) \{
			        return (
			          <div>
			            <span id="span" ref=\{swap ? this.elementOld : this.elementNew\}>
			              Ok
			            </span>
			            <Testing ref=\{swap ? this.es6Old : this.es6new\} />
			            \{/* @ts-expect-error Functional component ref */\}
			            <Functional ref=\{swap ? this.functionalOLD : this.functionalNEW\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Foobar />, container);
			    rerender();
			
			    // Verify ref updated
			    expect(instance!.elementNew.current).toBe(container.querySelector('#span'));
			    expect(instance!.elementOld.current).toBe(null);
			    expect(instance!.es6Old.current).toBe(null);
			    expect(instance!.es6new.current).toBe(instanceTesting);
			    expect(instance!.functionalOLD.current).toBe(null);
			    expect(instance!.functionalNEW.current).toBe(null);
			
			    render(null, container);
			
			    expect(instance!.elementNew.current).toBe(null);
			    expect(instance!.elementOld.current).toBe(null);
			    expect(instance!.es6Old.current).toBe(null);
			    expect(instance!.es6new.current).toBe(null);
			    expect(instance!.functionalOLD.current).toBe(null);
			    expect(instance!.functionalNEW.current).toBe(null);
			  \});
			
			  it('Should change ref to the selected element in a list', () => \{
			    const TOTAL_CHILDREN = 5;
			    let setSelected;
			
			    interface ParentState \{
			      selected: number;
			    \}
			
			    class Parent extends Component<unknown, ParentState> \{
			      public state: ParentState;
			      private readonly selectedRef: RefObject<HTMLDivElement>;
			
			      constructor() \{
			        super();
			        setSelected = this._setSelected = this._setSelected.bind(this);
			
			        this.selectedRef = createRef();
			        this.state = \{
			          selected: 1
			        \};
			      \}
			
			      public componentDidMount() \{
			        expect(this.selectedRef.current).toBe(container.querySelector('#child' + this.state.selected));
			      \}
			
			      public componentDidUpdate() \{
			        expect(this.selectedRef.current).toBe(container.querySelector('#child' + this.state.selected));
			      \}
			
			      public render() \{
			        const children: InfernoNode[] = [];
			        for (let i = 0; i < TOTAL_CHILDREN; i++) \{
			          const selected = this.state.selected === i ? this.selectedRef : null;
			          children.push(<div key=\{i\} id=\{'child' + i\} ref=\{selected\} />);
			        \}
			
			        return <div id="parent">\{children\}</div>;
			      \}
			
			      public _setSelected(selected) \{
			        this.setState(\{
			          selected
			        \});
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    setSelected(2);
			
			    rerender();
			
			    setSelected(3);
			
			    rerender();
			
			    setSelected(2);
			
			    rerender();
			
			    setSelected(1);
			
			    rerender();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\createref.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\defaultprops-typings.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			
			describe('default prop typings', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  type MyComponentProps = \{
			    name: string;
			    value: number;
			  \};
			
			  class MyComponent extends Component<MyComponentProps, any> \{
			    constructor(props, context) \{
			      super(props, context);
			    \}
			
			    public static defaultProps = \{
			      name: 'custom-component',
			      value: 107
			    \};
			
			    public render() \{
			      return null;
			    \}
			  \}
			
			  it('TSX Should not require properties from default props', () => \{
			    render(<MyComponent name="new-name" />, container);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\defaultprops-typings.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\error.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, InfernoNode, render, rerender \} from 'inferno';
			
			describe('Error recovery', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should be possible to render again if user land code crashes in CWM', () => \{
			    interface CrasherProps \{
			      crash: boolean;
			    \}
			
			    interface CrasherState \{
			      value: number;
			    \}
			
			    class Crasher extends Component<CrasherProps, CrasherState> \{
			      public state: CrasherState;
			
			      constructor(props, context) \{
			        super(props, context);
			
			        this.state = \{
			          value: 1
			        \};
			      \}
			
			      public componentWillMount() \{
			        if (this.props.crash) \{
			          throw Error('test');
			        \}
			
			        this.setState(\{
			          value: 2
			        \});
			      \}
			
			      public render() \{
			        return <div>\{this.state.value\}</div>;
			      \}
			    \}
			
			    try \{
			      render(<Crasher crash=\{true\} />, container);
			    \} catch (ex) \{
			      expect(ex.message).toBe('test');
			    \}
			
			    render(<Crasher crash=\{false\} />, container);
			    expect(container.firstChild.innerHTML).toBe('2');
			  \});
			
			  it('Should be possible to render again if user land code crashes in ComponentWillUnmount', () => \{
			    interface CrasherProps \{
			      crash: boolean;
			    \}
			
			    interface CrasherState \{
			      value: number;
			    \}
			
			    class Crasher extends Component<CrasherProps, CrasherState> \{
			      public state: CrasherState;
			      constructor(props, context) \{
			        super(props, context);
			
			        this.state = \{
			          value: 1
			        \};
			      \}
			
			      public componentWillUnmount() \{
			        if (this.props.crash) \{
			          throw Error('test');
			        \}
			      \}
			
			      public render() \{
			        return <div>\{this.state.value\}</div>;
			      \}
			    \}
			
			    render(<Crasher crash=\{true\} />, container);
			
			    expect(container.firstChild.innerHTML).toBe('1');
			
			    try \{
			      render(null, container);
			    \} catch (ex) \{
			      expect(ex.message).toBe('test');
			    \}
			
			    // No change as it crashed
			    expect(container.firstChild.innerHTML).toBe('1');
			
			    // Try update
			    render(<Crasher crash=\{false\} />, container);
			
			    expect(container.firstChild.innerHTML).toBe('1');
			
			    // Should not crash now
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  /*
			   * THROW ERROR IN
			   *
			   * last  node - render - willMount, didMount, willUpdate, didUpdate, constructor, cwrp
			   * mid   node - render - willMount, didMount, willUpdate, didUpdate, constructor, cwrp
			   * first node - render - willMount, didMount, willUpdate, didUpdate, constructor, cwrp
			   *
			   * force keyed? force non keyed?
			   */
			
			  describe('Error recovery from user land errors', () => \{
			    ['last', 'mid', 'first'].forEach((location) => \{
			      ['render', 'constructor', 'DidMount', 'WillMount', 'WillReceiveProps', 'shouldUpdate', 'WillUpdate', 'DidUpdate', 'getChildContext'].forEach(
			        (crashLocation) => \{
			          it('Should recover from subtree crash in ' + location + ' of children when crash happens in components ' + crashLocation, () => \{
			            interface CrasherProps \{
			              crash: boolean;
			            \}
			
			            interface CrasherState \{
			              value: string;
			            \}
			
			            class Crasher extends Component<CrasherProps, CrasherState> \{
			              public state: CrasherState;
			              constructor(props, context) \{
			                super(props, context);
			
			                this.state = \{
			                  value: ''
			                \};
			
			                if (props.crash && crashLocation === 'constructor') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentWillMount() \{
			                this.setState(\{
			                  value: 'mounted'
			                \});
			
			                if (this.props.crash && crashLocation === 'WillMount') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentWillReceiveProps(props) \{
			                if (props.crash && crashLocation === 'WillReceiveProps') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentDidMount() \{
			                if (this.props.crash && crashLocation === 'DidMount') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public shouldComponentUpdate(props) \{
			                if (props.crash && crashLocation === 'shouldUpdate') \{
			                  throw Error('test');
			                \}
			
			                return false;
			              \}
			
			              public componentWillUpdate() \{
			                if (this.props.crash && crashLocation === 'WillUpdate') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentDidUpdate() \{
			                if (this.props.crash && crashLocation === 'DidUpdate') \{
			                  throw Error('test');
			                \}
			              \}
			
			              // Unmount hook is still an issue
			              // componentWillUnmount() \{
			              //     if (this.props.crash && crashLocation === 'WillUnmount') \{
			              //         throw Error('test');
			              //     \}
			              // \}
			
			              public getChildContext() \{
			                if (this.props.crash && crashLocation === 'getChildContext') \{
			                  throw Error('test');
			                \}
			
			                return \{\};
			              \}
			
			              public render() \{
			                if (this.props.crash && crashLocation === 'render') \{
			                  throw Error('test');
			                \}
			
			                return <div>\{this.state.value\}</div>;
			              \}
			            \}
			
			            function TreeOfCrashers(\{ suffle, crash \}: \{ suffle?: boolean; crash: boolean \}) \{
			              const arr: InfernoNode[] = [];
			
			              if (location === 'first') \{
			                arr.push(<Crasher crash=\{crash\} />);
			              \}
			
			              if (suffle) \{
			                arr.push(<span>1</span>);
			                if (location === 'mid') \{
			                  arr.push(<Crasher crash=\{crash\} />);
			                \}
			                arr.push(<Crasher crash=\{false\} />);
			              \} else \{
			                if (location === 'mid') \{
			                  arr.push(<Crasher crash=\{crash\} />);
			                \}
			                arr.push(<Crasher crash=\{false\} />);
			              \}
			
			              if (location === 'last') \{
			                arr.push(<Crasher crash=\{crash\} />);
			              \}
			
			              return <div>\{arr\}</div>;
			            \}
			
			            render(<TreeOfCrashers crash=\{false\} />, container);
			
			            try \{
			              render(<TreeOfCrashers suffle=\{true\} crash=\{true\} />, container);
			            \} catch (ex) \{
			              // do nothing
			            \}
			
			            render(<TreeOfCrashers crash=\{false\} />, container);
			
			            expect(container.firstChild.innerHTML).toBe('<div>mounted</div><div>mounted</div>');
			          \});
			        \}
			      );
			    \});
			
			    ['last', 'mid', 'first'].forEach((location) => \{
			      ['render', 'constructor', 'DidMount', 'WillMount', 'WillReceiveProps', 'shouldUpdate', 'WillUpdate', 'DidUpdate', 'getChildContext'].forEach(
			        (crashLocation) => \{
			          it('Should recover from subtree crash in NON-KEYED ' + location + ' of children when crash happens in components ' + crashLocation, () => \{
			            interface CrasherProps \{
			              crash: boolean;
			            \}
			
			            interface CrasherState \{
			              value: string;
			            \}
			
			            class Crasher extends Component<CrasherProps, CrasherState> \{
			              public state: CrasherState;
			              constructor(props, context) \{
			                super(props, context);
			
			                this.state = \{
			                  value: ''
			                \};
			
			                if (props.crash && crashLocation === 'constructor') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentWillMount() \{
			                this.setState(\{
			                  value: 'mounted'
			                \});
			
			                if (this.props.crash && crashLocation === 'WillMount') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentWillReceiveProps(props) \{
			                if (props.crash && crashLocation === 'WillReceiveProps') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentDidMount() \{
			                if (this.props.crash && crashLocation === 'DidMount') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public shouldComponentUpdate(props) \{
			                if (props.crash && crashLocation === 'shouldUpdate') \{
			                  throw Error('test');
			                \}
			
			                return false;
			              \}
			
			              public componentWillUpdate() \{
			                if (this.props.crash && crashLocation === 'WillUpdate') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentDidUpdate() \{
			                if (this.props.crash && crashLocation === 'DidUpdate') \{
			                  throw Error('test');
			                \}
			              \}
			
			              // Unmount hook is still an issue
			              // componentWillUnmount() \{
			              //     if (this.props.crash && crashLocation === 'WillUnmount') \{
			              //         throw Error('test');
			              //     \}
			              // \}
			
			              public getChildContext() \{
			                if (this.props.crash && crashLocation === 'getChildContext') \{
			                  throw Error('test');
			                \}
			
			                return \{\};
			              \}
			
			              public render() \{
			                if (this.props.crash && crashLocation === 'render') \{
			                  throw Error('test');
			                \}
			
			                return <div>\{this.state.value\}</div>;
			              \}
			            \}
			
			            function TreeOfCrashers(\{ suffle, crash \}: \{ suffle?: boolean; crash: boolean \}) \{
			              const arr: InfernoNode[] = [];
			
			              if (location === 'first') \{
			                arr.push(<Crasher crash=\{crash\} />);
			              \}
			
			              if (suffle) \{
			                arr.push(<span>1</span>);
			                if (location === 'mid') \{
			                  arr.push(<Crasher crash=\{crash\} />);
			                \}
			                arr.push(<Crasher crash=\{false\} />);
			              \} else \{
			                if (location === 'mid') \{
			                  arr.push(<Crasher crash=\{crash\} />);
			                \}
			                arr.push(<Crasher crash=\{false\} />);
			              \}
			
			              if (location === 'last') \{
			                arr.push(<Crasher crash=\{crash\} />);
			              \}
			
			              return <div \$HasNonKeyedChildren>\{arr\}</div>;
			            \}
			
			            render(<TreeOfCrashers crash=\{false\} />, container);
			
			            try \{
			              render(<TreeOfCrashers suffle=\{true\} crash=\{true\} />, container);
			            \} catch (ex) \{
			              // do nothing
			            \}
			
			            render(<TreeOfCrashers crash=\{false\} />, container);
			
			            expect(container.firstChild.innerHTML).toBe('<div>mounted</div><div>mounted</div>');
			          \});
			        \}
			      );
			    \});
			
			    ['last', 'mid', 'first'].forEach((location) => \{
			      ['render', 'constructor', 'DidMount', 'WillMount', 'WillReceiveProps', 'shouldUpdate', 'WillUpdate', 'DidUpdate', 'getChildContext'].forEach(
			        (crashLocation) => \{
			          it('Should recover from subtree crash in NON-KEYED ' + location + ' of children when crash happens in components ' + crashLocation, () => \{
			            interface CrasherProps \{
			              crash: boolean;
			            \}
			
			            interface CrasherState \{
			              value: string;
			            \}
			
			            class Crasher extends Component<CrasherProps, CrasherState> \{
			              public state: CrasherState;
			              constructor(props, context) \{
			                super(props, context);
			
			                this.state = \{
			                  value: ''
			                \};
			
			                if (props.crash && crashLocation === 'constructor') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentWillMount() \{
			                this.setState(\{
			                  value: 'mounted'
			                \});
			
			                if (this.props.crash && crashLocation === 'WillMount') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentWillReceiveProps(props) \{
			                if (props.crash && crashLocation === 'WillReceiveProps') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentDidMount() \{
			                if (this.props.crash && crashLocation === 'DidMount') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public shouldComponentUpdate(props) \{
			                if (props.crash && crashLocation === 'shouldUpdate') \{
			                  throw Error('test');
			                \}
			
			                return false;
			              \}
			
			              public componentWillUpdate() \{
			                if (this.props.crash && crashLocation === 'WillUpdate') \{
			                  throw Error('test');
			                \}
			              \}
			
			              public componentDidUpdate() \{
			                if (this.props.crash && crashLocation === 'DidUpdate') \{
			                  throw Error('test');
			                \}
			              \}
			
			              // Unmount hook is still an issue
			              // componentWillUnmount() \{
			              //     if (this.props.crash && crashLocation === 'WillUnmount') \{
			              //         throw Error('test');
			              //     \}
			              // \}
			
			              public getChildContext() \{
			                if (this.props.crash && crashLocation === 'getChildContext') \{
			                  throw Error('test');
			                \}
			
			                return \{\};
			              \}
			
			              public render() \{
			                if (this.props.crash && crashLocation === 'render') \{
			                  throw Error('test');
			                \}
			
			                return <div>\{this.state.value\}</div>;
			              \}
			            \}
			
			            function TreeOfCrashers(\{ suffle, crash \}: \{ suffle?: boolean; crash: boolean \}) \{
			              const arr: InfernoNode[] = [];
			
			              if (location === 'first') \{
			                arr.push(<Crasher key="first" crash=\{crash\} />);
			              \}
			
			              if (suffle) \{
			                arr.push(<span key="span">1</span>);
			                if (location === 'mid') \{
			                  arr.push(<Crasher key="mid" crash=\{crash\} />);
			                \}
			                arr.push(<Crasher key="false-suffle" crash=\{false\} />);
			              \} else \{
			                if (location === 'mid') \{
			                  arr.push(<Crasher key="mid" crash=\{crash\} />);
			                \}
			                arr.push(<Crasher key="true-suffle" crash=\{false\} />);
			              \}
			
			              if (location === 'last') \{
			                arr.push(<Crasher key="last" crash=\{crash\} />);
			              \}
			
			              return <div \$HasKeyedChildren>\{arr\}</div>;
			            \}
			
			            render(<TreeOfCrashers crash=\{false\} />, container);
			
			            try \{
			              render(<TreeOfCrashers suffle=\{true\} crash=\{true\} />, container);
			            \} catch (ex) \{
			              // do nothing
			            \}
			
			            render(<TreeOfCrashers crash=\{false\} />, container);
			
			            expect(container.firstChild.innerHTML).toBe('<div>mounted</div><div>mounted</div>');
			          \});
			        \}
			      );
			    \});
			
			    describe('Error in child component', () => \{
			      it('Should not block future updates', (done) => \{
			        let childCrasherInstance: ChildCrasher | null = null;
			
			        class BadComponent extends Component \{
			          constructor(props) \{
			            super(props);
			          \}
			
			          public componentWillMount() \{
			            throw new Error('Oops!');
			          \}
			
			          public render() \{
			            return 1;
			          \}
			        \}
			
			        interface ChildCrasherState \{
			          fail: boolean;
			        \}
			
			        class ChildCrasher extends Component<unknown, ChildCrasherState> \{
			          public state: ChildCrasherState;
			
			          constructor(props) \{
			            super(props);
			
			            this.state = \{
			              fail: false
			            \};
			
			            childCrasherInstance = this; // For the sake of test
			          \}
			
			          public render() \{
			            if (!this.state.fail) \{
			              return null;
			            \}
			
			            return <BadComponent />;
			          \}
			        \}
			
			        class Parent extends Component \{
			          public render() \{
			            return (
			              <div>
			                <ChildCrasher />
			              </div>
			            );
			          \}
			        \}
			
			        render(<Parent />, container);
			
			        expect(container.innerHTML).toBe('<div></div>');
			
			        expect(() => \{
			          childCrasherInstance!.setState(\{
			            fail: true
			          \});
			          rerender();
			        \}).toThrowError('Oops!');
			
			        // Recover from it
			        childCrasherInstance!.setState(\{
			          fail: false
			        \});
			
			        setTimeout(function () \{
			          expect(container.innerHTML).toBe('<div></div>');
			          done();
			        \}, 10);
			      \});
			
			      it('Should not block future updates - variation 2', () => \{
			        let parentInstance: Parent | null = null;
			
			        class BadComponent extends Component \{
			          constructor(props) \{
			            super(props);
			
			            throw new Error('Oops!');
			          \}
			
			          public render() \{
			            return <div>Ok</div>;
			          \}
			        \}
			
			        interface ChildCrasherProps \{
			          fail?: boolean;
			        \}
			
			        class ChildCrasher extends Component<ChildCrasherProps> \{
			          public render() \{
			            if (!this.props.fail) \{
			              return null;
			            \}
			
			            return (
			              <div>
			                <span>1</span>
			                <BadComponent />
			              </div>
			            );
			          \}
			        \}
			
			        interface ParentProps \{
			          fail: boolean;
			        \}
			
			        interface ParentState \{
			          nodes: boolean;
			        \}
			
			        class Parent extends Component<ParentProps, ParentState> \{
			          public state: ParentState;
			
			          constructor(props) \{
			            super(props);
			
			            this.state = \{
			              nodes: false
			            \};
			
			            parentInstance = this; // For the sake of test
			          \}
			
			          public render() \{
			            return (
			              <div>
			                <span>1</span>
			                \{null\}
			                <ChildCrasher fail=\{this.props.fail\} />
			              </div>
			            );
			          \}
			        \}
			
			        expect(() => render(<Parent fail=\{true\} />, container)).toThrowError('Oops!');
			
			        expect(() => render(<Parent fail=\{true\} />, container)).toThrowError('Oops!');
			
			        parentInstance!.setState(\{
			          nodes: true
			        \});
			        rerender();
			
			        expect(container.innerHTML).toEqual('');
			
			        render(<Parent fail=\{false\} />, container);
			
			        expect(() => render(<Parent fail=\{true\} />, container)).toThrowError('Oops!');
			
			        expect(() => \{
			          parentInstance!.setState(\{
			            nodes: false
			          \});
			          rerender();
			        \}).toThrowError('Oops!');
			
			        expect(() => \{
			          parentInstance!.setState(\{
			            nodes: true
			          \});
			          rerender();
			        \}).toThrowError('Oops!');
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\error.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\forceUpdate.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render, rerender \} from 'inferno';
			
			describe('forceUpdate', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    rerender(); // Flush pending stuff, if any
			    render(null, container);
			    document.body.removeChild(container);
			    container.innerHTML = '';
			  \});
			
			  // https://jsfiddle.net/pnwLh7au/
			  it('Should have new state in render when changed state during setState + forceUpdate inside lifecycle methods and render only once', () => \{
			    let updated = 0;
			
			    class Parent extends Component \{
			      public render() \{
			        return (
			          <div>
			            <Child />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component \{
			      public state = \{
			        foo: 'bar'
			      \};
			
			      public componentDidMount() \{
			        this.setState(\{
			          foo: 'bar2'
			        \});
			        this.forceUpdate();
			      \}
			
			      public componentDidUpdate() \{
			        updated++;
			      \}
			
			      public render() \{
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    render(<Parent />, container);
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar');
			
			    rerender();
			
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar2');
			    expect(updated).toBe(1);
			  \});
			
			  it('Should ignore shouldComponentUpdate when forceUpdate called like React does', () => \{
			    let updated = 0;
			
			    class Parent extends Component \{
			      public render() \{
			        return (
			          <div>
			            <Child />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component \{
			      public state = \{
			        foo: 'bar'
			      \};
			
			      public shouldComponentUpdate(_prevProps, prevState) \{
			        if (prevState.foo !== this.state.foo) \{
			          return true;
			        \}
			        return false;
			      \}
			
			      public componentDidMount() \{
			        this.forceUpdate();
			      \}
			
			      public render() \{
			        updated++;
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    render(<Parent />, container);
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar');
			    expect(updated).toBe(1);
			
			    rerender();
			
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar');
			    expect(updated).toBe(2);
			  \});
			
			  // As per React https://jsfiddle.net/pnwLh7au/
			  // React has a different flow when setState is called outside lifecycle methods or event handlers (https://jsfiddle.net/egd1kuz6/),
			  // but inferno has another flow for setState and Inferno.
			  // Inferno collapses several \`setState\` even if they are called outside event listeners or lifecycle methods. So forceUpdate follows it
			  it('Should use the updated state when forceUpdate called like React does even if shouldComponentUpdate ignores it', () => \{
			    let updated = 0;
			
			    class Parent extends Component \{
			      public render() \{
			        return (
			          <div>
			            <Child />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component \{
			      public state = \{
			        foo: 'bar'
			      \};
			
			      public shouldComponentUpdate() \{
			        return false;
			      \}
			
			      public componentDidMount() \{
			        this.setState(\{ foo: 'bar2' \});
			        this.forceUpdate();
			      \}
			
			      public render() \{
			        updated++;
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    render(<Parent />, container);
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar');
			    expect(updated).toBe(1);
			
			    rerender();
			
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar2');
			    expect(updated).toBe(2);
			  \});
			
			  // As per React https://jsfiddle.net/pnwLh7au/
			  it('Should use the updated state when forceUpdate called before setState like React does even if shouldComponentUpdate ignores it', () => \{
			    let updated = 0;
			
			    class Parent extends Component \{
			      public render() \{
			        return (
			          <div>
			            <Child />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component \{
			      public state = \{
			        foo: 'bar'
			      \};
			
			      public shouldComponentUpdate() \{
			        return false;
			      \}
			
			      public componentDidMount() \{
			        this.forceUpdate();
			        this.setState(\{ foo: 'bar2' \});
			      \}
			
			      public render() \{
			        updated++;
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    render(<Parent />, container);
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar');
			    expect(updated).toBe(1);
			
			    rerender();
			
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar2');
			    expect(updated).toBe(2);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\forceUpdate.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\formelements.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, linkEvent, render \} from 'inferno';
			
			describe('FormElements', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('text input', () => \{
			    interface TextBoxProps \{
			      value: string | number;
			    \}
			    class TextBox extends Component<TextBoxProps> \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <input type="text" value=\{this.props.value\} />
			          </div>
			        );
			      \}
			    \}
			
			    it('Should set value as text on render', () => \{
			      render(<TextBox value=\{1\} />, container);
			      expect(container.querySelector('input').value).toBe('1');
			    \});
			
			    it('Should override changed value on next render', () => \{
			      render(<TextBox value=\{1\} />, container);
			      let input = container.querySelector('input');
			      expect(input.value).toBe('1');
			      input.value = '2'; // Simulate user typing '2'
			      expect(input.value).toBe('2');
			      render(<TextBox value=\{3\} />, container);
			      input = container.querySelector('input');
			      expect(input.value).toBe('3');
			    \});
			
			    it('Should override changed value on next render even when value is same as on prev render', () => \{
			      render(<TextBox value=\{1\} />, container);
			      let input = container.querySelector('input');
			      expect(input.value).toBe('1');
			      input.value = '2'; // Simulate user typing '2'
			      expect(input.value).toBe('2');
			      render(<TextBox value=\{1\} />, container);
			      input = container.querySelector('input');
			      expect(input.value).toBe('1');
			    \});
			
			    it('Controlled - oninput - Should have updated props in onInput callbacks', () => \{
			      interface ExampleProps \{
			        value: number;
			        callback: (value: number) => void;
			      \}
			
			      class Example extends Component<ExampleProps> \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this._method = this._method.bind(this);
			        \}
			
			        public _method() \{
			          this.props.callback(this.props.value);
			        \}
			
			        public render() \{
			          return <input type="text" oninput=\{this._method\} value="test" />;
			        \}
			      \}
			      const spy = jasmine.createSpy('spy');
			
			      render(<Example callback=\{spy\} value=\{1\} />, container);
			
			      let event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(1);
			      expect(spy.calls.argsFor(0)[0]).toBe(1); // Verify initial props are correct
			
			      // Then update component
			      render(<Example callback=\{spy\} value=\{2\} />, container);
			
			      event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(2);
			      expect(spy.calls.argsFor(1)[0]).toBe(2); // Verify props have changed
			    \});
			
			    it('Controlled - onInput - Should have updated props in onInput callbacks', () => \{
			      interface ExampleProps \{
			        value: number;
			        callback: (value: number) => void;
			      \}
			
			      class Example extends Component<ExampleProps> \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this._method = this._method.bind(this);
			        \}
			
			        public _method() \{
			          this.props.callback(this.props.value);
			        \}
			
			        public render() \{
			          return <input type="text" onInput=\{this._method\} value="test" />;
			        \}
			      \}
			
			      let callCounter = 0;
			      const args: number[] = [];
			
			      const spy = function (arg) \{
			        callCounter++;
			        args.push(arg);
			      \};
			
			      render(<Example callback=\{spy\} value=\{1\} />, container);
			
			      let event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(callCounter).toBe(1);
			      expect(args[0]).toBe(1);
			
			      // Then update component
			      render(<Example callback=\{spy\} value=\{2\} />, container);
			
			      event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(callCounter).toBe(2);
			      expect(args[1]).toBe(2);
			    \});
			
			    it('Controlled - onInput - Should have updated props in onInput callbacks in setState callback', () => \{
			      interface ExampleProps \{
			        value: number;
			        callback: (value: number, a: number) => void;
			      \}
			
			      interface ExampleState \{
			        a: number;
			      \}
			
			      class Example extends Component<ExampleProps, ExampleState> \{
			        public state: ExampleState;
			
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            a: 0
			          \};
			
			          this._method = this._method.bind(this);
			        \}
			
			        public test() \{
			          this.props.callback(this.props.value, this.state.a);
			        \}
			
			        public _method() \{
			          this.setState(
			            \{
			              a: this.props.value
			            \},
			            this.test
			          );
			        \}
			
			        public render() \{
			          return <input type="text" onInput=\{this._method\} value="test" />;
			        \}
			      \}
			
			      const spy = jasmine.createSpy('spy');
			
			      render(<Example callback=\{spy\} value=\{1\} />, container);
			
			      let event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(1);
			      expect(spy.calls.argsFor(0)[0]).toBe(1); // Verify initial props are correct
			
			      // Then update component
			      render(<Example callback=\{spy\} value=\{2\} />, container);
			
			      event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(2);
			      expect(spy.calls.argsFor(1)[0]).toBe(2); // Verify props have changed
			    \});
			
			    it('Controlled - onInput (linkEvent) - Should have updated props in onInput callbacks', () => \{
			      interface ExampleProps \{
			        value: number;
			        callback: (value: number, a: number) => void;
			      \}
			
			      class Example extends Component<ExampleProps> \{
			        constructor(props, context) \{
			          super(props, context);
			        \}
			
			        public static _method(me) \{
			          me.props.callback(me.props.value);
			        \}
			
			        public render() \{
			          return <input type="text" onInput=\{linkEvent(this, Example._method)\} value="test" />;
			        \}
			      \}
			
			      const spy = jasmine.createSpy('spy');
			
			      render(<Example callback=\{spy\} value=\{1\} />, container);
			
			      let event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(1);
			      expect(spy.calls.argsFor(0)[0]).toBe(1); // Verify initial props are correct
			
			      // Then update component
			      render(<Example callback=\{spy\} value=\{2\} />, container);
			
			      event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(2);
			      expect(spy.calls.argsFor(1)[0]).toBe(2); // Verify props have changed
			    \});
			
			    it('NON Controlled - onInput (linkEvent) - Should have updated props in onInput callbacks', () => \{
			      interface ExampleProps \{
			        value: number;
			        callback: (value: number, a: number) => void;
			      \}
			
			      class Example extends Component<ExampleProps> \{
			        constructor(props, context) \{
			          super(props, context);
			        \}
			
			        public static _method(me) \{
			          me.props.callback(me.props.value);
			        \}
			
			        public render() \{
			          return <input type="text" onInput=\{linkEvent(this, Example._method)\} />;
			        \}
			      \}
			
			      const spy = jasmine.createSpy('spy');
			
			      render(<Example callback=\{spy\} value=\{1\} />, container);
			
			      let event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(1);
			      expect(spy.calls.argsFor(0)[0]).toBe(1); // Verify initial props are correct
			
			      // Then update component
			      render(<Example callback=\{spy\} value=\{2\} />, container);
			
			      event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(2);
			      expect(spy.calls.argsFor(1)[0]).toBe(2); // Verify props have changed
			    \});
			
			    it('NON Controlled - onInput - Should have updated props in onInput callbacks', () => \{
			      interface ExampleProps \{
			        value: number;
			        callback: (value: number) => void;
			      \}
			
			      class Example extends Component<ExampleProps> \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this._method = this._method.bind(this);
			        \}
			
			        public _method() \{
			          this.props.callback(this.props.value);
			        \}
			
			        public render() \{
			          return <input type="text" onInput=\{this._method\} />;
			        \}
			      \}
			
			      const spy = jasmine.createSpy('spy');
			
			      render(<Example callback=\{spy\} value=\{1\} />, container);
			
			      let event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(1);
			      expect(spy.calls.argsFor(0)[0]).toBe(1); // Verify initial props are correct
			
			      // Then update component
			      render(<Example callback=\{spy\} value=\{2\} />, container);
			
			      event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			      container.firstChild.dispatchEvent(event);
			
			      expect(spy).toHaveBeenCalledTimes(2);
			      expect(spy.calls.argsFor(1)[0]).toBe(2); // Verify props have changed
			    \});
			  \});
			
			  describe('input type checkbox', () => \{
			    interface CheckBoxProps \{
			      checked?: boolean;
			    \}
			
			    class CheckBox extends Component<CheckBoxProps> \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <input type="checkbox" checked=\{this.props.checked\} />
			          </div>
			        );
			      \}
			    \}
			
			    it('Should set checked on render', () => \{
			      render(<CheckBox checked=\{true\} />, container);
			      expect(container.querySelector('input').checked).toBe(true);
			    \});
			
			    it('Should set checked on render #2', () => \{
			      render(<CheckBox checked=\{false\} />, container);
			      expect(container.querySelector('input').checked).toBe(false);
			    \});
			
			    it('Should set checked on render #3', () => \{
			      render(<CheckBox />, container);
			      expect(container.querySelector('input').checked).toBe(false);
			    \});
			
			    it('Should override changed value on next render', () => \{
			      render(<CheckBox checked=\{false\} />, container);
			      let input = container.querySelector('input');
			      expect(input.checked).toBe(false);
			      input.checked = false; // Simulate user clicking checkbox twice
			      render(<CheckBox checked=\{true\} />, container);
			      input = container.querySelector('input');
			      expect(input.checked).toBe(true);
			    \});
			
			    it('Should override changed value on next render even when value is same as on prev render', () => \{
			      render(<CheckBox checked=\{false\} />, container);
			      let input = container.querySelector('input');
			      expect(input.checked).toBe(false);
			      input.checked = true; // Simulate user clicking checkbox
			      expect(input.checked).toBe(true);
			      render(<CheckBox checked=\{false\} />, container);
			      input = container.querySelector('input');
			      expect(input.checked).toBe(false);
			    \});
			
			    it('Should override changed value on next render even when value is same as on prev render #1', () => \{
			      render(<CheckBox checked=\{true\} />, container);
			      let input = container.querySelector('input');
			      expect(input.checked).toBe(true);
			      input.checked = false; // Simulate user clicking checkbox
			      expect(input.checked).toBe(false);
			      render(<CheckBox checked=\{true\} />, container);
			      input = container.querySelector('input');
			      expect(input.checked).toBe(true);
			    \});
			
			    it('Should support indeterminate state', () => \{
			      let input;
			
			      render(<input ref=\{(dom) => (input = dom)\} type="checkbox" checked=\{false\} indeterminate=\{true\} />, container);
			
			      expect(input.indeterminate).toBe(true);
			      expect(input.checked).toBe(false);
			
			      render(<input ref=\{(dom) => (input = dom)\} type="checkbox" checked=\{false\} indeterminate=\{false\} />, container);
			
			      expect(input.indeterminate).toBe(false);
			      expect(input.checked).toBe(false);
			
			      render(<input ref=\{(dom) => (input = dom)\} type="checkbox" checked=\{true\} indeterminate=\{false\} />, container);
			
			      expect(input.indeterminate).toBe(false);
			      expect(input.checked).toBe(true);
			    \});
			  \});
			
			  // https://facebook.github.io/react/docs/forms.html
			  describe('React form spec', () => \{
			    describe('Controlled select list', () => \{
			      interface SelectListProps \{
			        value: string;
			      \}
			
			      class SelectList extends Component<SelectListProps> \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <select value=\{this.props.value\}>
			                <option value="A">A</option>
			                <option value="B">B</option>
			                <option value="C">C</option>
			              </select>
			            </div>
			          );
			        \}
			      \}
			
			      it('Should pre select option by value', () => \{
			        render(<SelectList value="B" />, container);
			        const selectList = container.querySelector('select');
			        expect(selectList.childNodes[0].selected).toBe(false);
			        expect(selectList.childNodes[1].selected).toBe(true);
			        expect(selectList.childNodes[2].selected).toBe(false);
			      \});
			
			      it('Should change value based on value property', () => \{
			        render(<SelectList value="B" />, container);
			        let selectList = container.querySelector('select');
			        expect(selectList.childNodes[0].selected).toBe(false);
			        expect(selectList.childNodes[1].selected).toBe(true);
			        expect(selectList.childNodes[2].selected).toBe(false);
			
			        render(<SelectList value="C" />, container);
			        selectList = container.querySelector('select');
			        expect(selectList.childNodes[0].selected).toBe(false);
			        expect(selectList.childNodes[1].selected).toBe(false);
			        expect(selectList.childNodes[2].selected).toBe(true);
			      \});
			    \});
			
			    describe('Controlled select list updates', () => \{
			      let updater;
			
			      interface SelectListState \{
			        value: string;
			      \}
			
			      class SelectList extends Component<unknown, SelectListState> \{
			        public state: SelectListState;
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            value: 'A'
			          \};
			
			          updater = (e) => \{
			            this.setState(e);
			          \};
			        \}
			
			        public buildOptionsDynamically() \{
			          return [<option value="A">A</option>, <option value="B">B</option>, <option value="C">C</option>];
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <select value=\{this.state.value\}>\{this.buildOptionsDynamically()\}</select>
			            </div>
			          );
			        \}
			      \}
			
			      it('Should pre select option by value on update', (done) => \{
			        render(<SelectList />, container);
			        let selectList = container.querySelector('select');
			        expect(selectList.childNodes[0].selected).toBe(true);
			        expect(selectList.childNodes[1].selected).toBe(false);
			        expect(selectList.childNodes[2].selected).toBe(false);
			
			        updater(\{ value: 'B' \});
			        setTimeout(() => \{
			          selectList = container.querySelector('select');
			          expect(selectList.childNodes[0].selected).toBe(false);
			          expect(selectList.childNodes[1].selected).toBe(true);
			          expect(selectList.childNodes[2].selected).toBe(false);
			          done();
			        \}, 10);
			      \});
			    \});
			
			    describe('input range scu', () => \{
			      it('Should have correct value on initial render', () => \{
			        class TestInputRange extends Component \{
			          public shouldComponentUpdate() \{
			            return false;
			          \}
			
			          public render() \{
			            return <input name="test" type="range" min=\{50\} max=\{500\} step=\{5\} defaultValue=\{260\} />;
			          \}
			        \}
			        render(<TestInputRange />, container);
			
			        expect(container.firstChild.value).toBe('260');
			        expect(container.firstChild.defaultValue).toBe('260');
			      \});
			
			      it('Should have defaultValue even when defaultValue is omitted, if value exists', () => \{
			        class TestInputRange extends Component \{
			          public shouldComponentUpdate() \{
			            return false;
			          \}
			
			          public render() \{
			            return <input name="test" type="range" min=\{50\} max=\{500\} step=\{5\} value="110" />;
			          \}
			        \}
			        render(<TestInputRange />, container);
			
			        expect(container.firstChild.value).toBe('110');
			        expect(container.firstChild.defaultValue).toBe('110');
			      \});
			    \});
			
			    describe('Non-controlled select element', () => \{
			      it('Should have 2nd option selected', () => \{
			        render(
			          <select>
			            <option value="a">a</option>
			            <option selected=\{true\} value="b">
			              b
			            </option>
			          </select>,
			          container
			        );
			
			        expect(container.firstChild.children[0].selected).toBe(false);
			        expect(container.firstChild.children[1].selected).toBe(true);
			      \});
			
			      it('should render specified default selected option', () => \{
			        render(
			          <div>
			            <select>
			              <option value="a">a</option>
			              <option selected=\{true\} value="b">
			                b
			              </option>
			            </select>
			          </div>,
			          container
			        );
			
			        expect(container.querySelector('select').children[0].selected).toEqual(false);
			        expect(container.querySelector('select').children[1].selected).toEqual(true);
			      \});
			    \});
			
			    describe('callbacks with FormElements', () => \{
			      it('Should call latest calback from props', () => \{
			        interface CompAState \{
			          orderedConfigs: \{ value: boolean \}[];
			        \}
			        class CompA extends Component<unknown, CompAState> \{
			          public state: CompAState;
			          constructor(props) \{
			            super(props);
			            this.state = \{
			              orderedConfigs: [\{ value: false \}, \{ value: true \}, \{ value: false \}]
			            \};
			          \}
			
			          public handleClick(that, \{ targetConf, targetIndex \}) \{
			            const newConfigs = that.state.orderedConfigs.map((conf, index) => (index === targetIndex ? \{ value: !targetConf.value \} : conf));
			
			            this.setState(\{ orderedConfigs: newConfigs \});
			          \}
			
			          public render() \{
			            return <CompB orderedConfigs=\{this.state.orderedConfigs\} onClick=\{(...args) => this.handleClick(this, ...args)\} />;
			          \}
			        \}
			
			        interface CompBProps \{
			          orderedConfigs: \{ value: boolean \}[];
			          onClick: (arg: \{ targetConf: \{ value: boolean \}; targetIndex: number \}) => void;
			        \}
			
			        const CompB = function renderCompB(props: CompBProps) \{
			          return (
			            <div>
			              \{props.orderedConfigs.map((conf, index) => (
			                <input
			                  type="checkbox"
			                  checked=\{conf.value\}
			                  onClick=\{() => \{
			                    props.onClick(\{ targetConf: conf, targetIndex: index \});
			                  \}\}
			                />
			              ))\}
			            </div>
			          );
			        \};
			
			        render(<CompA />, container);
			
			        expect(container.firstChild.firstChild.checked).toBe(false);
			        // expect(container.querySelectorAll('input:checked').length).toEqual(1);
			
			        let input = container.querySelector('input');
			        input.click();
			
			        expect(container.firstChild.firstChild.checked).toBe(true);
			        // expect(container.querySelectorAll('input:checked').length).toEqual(2);
			
			        input = container.querySelector('input');
			        input.click();
			
			        expect(container.firstChild.firstChild.checked).toBe(false);
			        // expect(container.querySelectorAll('input:checked').length).toEqual(1);
			      \});
			    \});
			
			    describe('Controlled inputs, checkbox', () => \{
			      it('Should keep unChecked if checked is false', () => \{
			        render(
			          <label>
			            <input type="checkbox" checked=\{false\} name="test" value="test" /> test
			          </label>,
			          container
			        );
			
			        // Verify its not checked
			        const input = container.querySelector('input');
			
			        expect(input.checked).toBe(false);
			
			        input.click();
			
			        expect(input.checked).toBe(false);
			      \});
			
			      it('Should be possible to control checkbox by props', () => \{
			        interface ComponentTestState \{
			          checked: boolean;
			        \}
			        class ComponentTest extends Component<unknown, ComponentTestState> \{
			          public state: ComponentTestState;
			
			          constructor(props) \{
			            super(props);
			            this.state = \{ checked: false \};
			          \}
			          public handleClick() \{
			            this.setState((state) => (\{ checked: !state.checked \}));
			          \}
			          public render() \{
			            return (
			              <div>
			                <button onClick=\{() => this.handleClick()\} />
			                <input type="checkbox" checked=\{this.state.checked\} />
			              </div>
			            );
			          \}
			        \}
			
			        render(<ComponentTest />, container);
			
			        expect(container.querySelectorAll('input').length).toBe(1);
			
			        const input = container.querySelector('input');
			        const button = container.querySelector('button');
			
			        expect(input.checked).toBe(false);
			
			        button.click();
			
			        expect(input.checked).toBe(true);
			      \});
			
			      it('Clicking checkbox should have value changed in callback, and reverted after it (unless no change in state)', () => \{
			        let changeToValue = true;
			
			        interface ComponentTestState \{
			          checked: boolean;
			        \}
			        class ComponentTest extends Component<unknown, ComponentTestState> \{
			          public state: ComponentTestState;
			          constructor(props) \{
			            super(props);
			            this.state = \{ checked: true \};
			          \}
			          public handleClick(event) \{
			            expect(event.currentTarget.checked).toBe(false);
			
			            this.setState(() => (\{ checked: changeToValue \}));
			          \}
			          public render() \{
			            return (
			              <div>
			                <input onClick=\{(e) => this.handleClick(e)\} type="checkbox" checked=\{this.state.checked\} />
			              </div>
			            );
			          \}
			        \}
			
			        render(<ComponentTest />, container);
			
			        expect(container.querySelectorAll('input').length).toBe(1);
			
			        const input = container.querySelector('input');
			
			        expect(input.checked).toBe(true);
			
			        input.click();
			
			        expect(input.checked).toBe(true);
			
			        changeToValue = false;
			
			        input.click();
			
			        expect(input.checked).toBe(false);
			      \});
			
			      /* Same test as above, but in opposite order */
			      it('Clicking checkbox should have value changed in callback, and reverted after it (unless no change in state) #2', () => \{
			        let changeToValue = false;
			
			        interface ComponentTestState \{
			          checked: boolean;
			        \}
			        class ComponentTest extends Component<unknown, ComponentTestState> \{
			          public state: ComponentTestState;
			          constructor(props) \{
			            super(props);
			            this.state = \{ checked: false \};
			          \}
			          public handleClick(event) \{
			            expect(event.currentTarget.checked).toBe(true);
			
			            this.setState(() => (\{ checked: changeToValue \}));
			          \}
			          public render() \{
			            return (
			              <div>
			                <input onClick=\{(e) => this.handleClick(e)\} type="checkbox" checked=\{this.state.checked\} />
			              </div>
			            );
			          \}
			        \}
			
			        render(<ComponentTest />, container);
			
			        expect(container.querySelectorAll('input').length).toBe(1);
			
			        const input = container.querySelector('input');
			
			        expect(input.checked).toBe(false); // Initially false
			
			        input.click(); // Inside event handler should be true
			
			        expect(input.checked).toBe(false); // After render, it should be false again
			
			        changeToValue = true;
			
			        input.click(); // Inside event handler should be true
			
			        expect(input.checked).toBe(true); // Now it should be true because value was changed in state
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\formelements.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(28)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\forward-ref.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createRef, forwardRef, RefObject, render \} from 'inferno';
			
			describe('Forward Ref', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should be possible to forward createRef', () => \{
			    const FancyButton = forwardRef((props, ref) => (
			      <button ref=\{ref\} className="FancyButton">
			        \{props.children\}
			      </button>
			    ));
			
			    expect(FancyButton.render).toBeDefined();
			
			    class Hello extends Component \{
			      private readonly btn: RefObject<Element>;
			
			      constructor(props) \{
			        super(props);
			
			        // You can now get a ref directly to the DOM button:
			        this.btn = createRef();
			      \}
			
			      public componentDidMount() \{
			        expect(this.btn.current).toBe(container.querySelector('button'));
			      \}
			      public render() \{
			        return <FancyButton ref=\{this.btn\}>Click me!</FancyButton>;
			      \}
			    \}
			
			    render(<Hello />, container);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			  \});
			
			  it('Should be possible to forward callback ref', () => \{
			    const FancyButton = forwardRef((props, ref) => (
			      <button ref=\{ref\} className="FancyButton">
			        \{props.children\}
			      </button>
			    ));
			
			    expect(FancyButton.render).toBeDefined();
			
			    class Hello extends Component \{
			      public render() \{
			        return (
			          <FancyButton
			            ref=\{(btn) => \{
			              if (btn) \{
			                expect(btn).toBe(container.querySelector('button'));
			              \}
			            \}\}
			          >
			            Click me!
			          </FancyButton>
			        );
			      \}
			    \}
			
			    render(<Hello />, container);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to patch forwardRef component', () => \{
			    const FancyButton = forwardRef((props, ref) => \{
			      return (
			        <button ref=\{ref\} className="FancyButton">
			          \{props.children\}
			        </button>
			      );
			    \});
			
			    expect(FancyButton.render).toBeDefined();
			
			    let firstVal = null;
			
			    render(
			      <FancyButton
			        ref=\{(btn) => \{
			          firstVal = btn;
			        \}\}
			      >
			        Click me!
			      </FancyButton>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			    expect(firstVal).not.toBe(null);
			
			    let secondVal = null;
			
			    render(
			      <FancyButton
			        ref=\{(btn) => \{
			          secondVal = btn;
			        \}\}
			      >
			        Click me! 222
			      </FancyButton>,
			      container
			    );
			
			    expect(firstVal).toBe(null);
			    expect(secondVal).not.toBe(null);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me! 222</button>');
			  \});
			
			  describe('Validations', () => \{
			    it('Should log error if input is: Component, vNode or invalid value', () => \{
			      const consoleSpy = spyOn(console, 'error');
			
			      class Foobar extends Component \{\}
			
			      let i = 0;
			
			      // @ts-expect-error
			      forwardRef(false);
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      // @ts-expect-error
			      forwardRef(true);
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      // @ts-expect-error
			      forwardRef(\{\});
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      // @ts-expect-error
			      forwardRef('asd');
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      // @ts-expect-error
			      forwardRef(undefined);
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      // @ts-expect-error
			      forwardRef(8);
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      // TODO: improve forward ref typings
			      forwardRef(<div>1</div>);
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      forwardRef(<Foobar />);
			      expect(consoleSpy.calls.count()).toEqual(++i);
			
			      // This is ok
			      forwardRef(function () \{
			        return <div>1</div>;
			      \});
			      expect(consoleSpy.calls.count()).toEqual(i);
			    \});
			  \});
			
			  it('Should be possible to extent forwardRef object', () => \{
			    const objRef = createRef();
			    const RefComponent = forwardRef((props, ref) => (
			      <div ref=\{ref\} \{...props\}>
			        1
			      </div>
			    ));
			
			    RefComponent.staticMember = 'asd';
			
			    render(<RefComponent ref=\{objRef\} />, container);
			
			    expect(container.innerHTML).toBe('<div>1</div>');
			    expect(objRef.current!.outerHTML).toBe('<div>1</div>');
			
			    expect(RefComponent.staticMember).toBe('asd');
			  \});
			
			  describe('Inferno specifics', () => \{
			    it('Should support defaultProps and defaultHooks', () => \{
			      function CoolStuff(props, ref) \{
			        return (
			          <div className=\{props.className\}>
			            <span ref=\{ref\}>\{props.children\}</span>
			            \{props.foo\}
			          </div>
			        );
			      \}
			
			      CoolStuff.defaultProps = \{
			        foo: 'bar'
			      \};
			      CoolStuff.defaultHooks = \{
			        onComponentWillMount() \{\}
			      \};
			
			      const spy = spyOn(CoolStuff.defaultHooks, 'onComponentWillMount');
			
			      const ForwardCom = forwardRef(CoolStuff);
			
			      expect(ForwardCom.render).toBe(CoolStuff);
			
			      class Hello extends Component \{
			        public render() \{
			          return (
			            <ForwardCom
			              className="okay"
			              ref=\{(btn) => \{
			                if (btn) \{
			                  expect(btn).toBe(container.querySelector('span'));
			                \}
			              \}\}
			            >
			              <a>1</a>
			            </ForwardCom>
			          );
			        \}
			      \}
			
			      render(<Hello />, container);
			
			      expect(container.innerHTML).toBe('<div class="okay"><span><a>1</a></span>bar</div>');
			      expect(spy.calls.count()).toBe(1);
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\forward-ref.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\fragments.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createFragment, createPortal, Fragment, InfernoNode, render \} from 'inferno';
			import \{ ChildFlags \} from 'inferno-vnode-flags';
			
			describe('Fragments', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should render and unmount fragment', () => \{
			    class Example extends Component \{
			      public render() \{
			        return createFragment([<div>First</div>, <div>second</div>], ChildFlags.HasNonKeyedChildren);
			      \}
			    \}
			
			    render(<Example />, container);
			
			    expect(container.innerHTML).toBe('<div>First</div><div>second</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should render nested fragment', () => \{
			    class Example extends Component \{
			      public render() \{
			        return createFragment(
			          [<div>First</div>, createFragment([<div>Sub1</div>, <div>Sub2</div>], ChildFlags.HasNonKeyedChildren), <div>second</div>],
			          ChildFlags.HasNonKeyedChildren
			        );
			      \}
			    \}
			
			    render(<Example />, container);
			
			    expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be to replace component with fragment with another component', () => \{
			    class Example extends Component \{
			      public render() \{
			        return createFragment(
			          [<div>First</div>, createFragment([<div>Sub1</div>, <div>Sub2</div>], ChildFlags.HasNonKeyedChildren), <div>second</div>],
			          ChildFlags.HasNonKeyedChildren
			        );
			      \}
			    \}
			
			    function FunctionalComp() \{
			      return createFragment([<div>Functional</div>], ChildFlags.HasNonKeyedChildren);
			    \}
			
			    render(<Example />, container);
			
			    expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			    render(<FunctionalComp />, container);
			
			    expect(container.innerHTML).toBe('<div>Functional</div>');
			
			    render(<Example />, container);
			
			    expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			    render(<FunctionalComp />, container);
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to move fragments', () => \{
			    const fragmentA = () => createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			
			    const fragmentB = () => createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			
			    const fragmentC = () => createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			    render(
			      <div>
			        \{fragmentA()\}
			        \{fragmentB()\}
			        \{fragmentC()\}
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div id="a1">A1</div><div>A2</div><div id="b1">B1</div><div id="c1">C1</div><div>C2</div><div>C3</div></div>');
			
			    const A1 = container.querySelector('#a1');
			    const B1 = container.querySelector('#b1');
			    const C1 = container.querySelector('#c1');
			
			    // Switch order
			    render(
			      <div>
			        \{fragmentC()\}
			        \{fragmentA()\}
			        \{fragmentB()\}
			      </div>,
			      container
			    );
			
			    // Verify dom has changed and nodes are the same
			    expect(container.innerHTML).toBe('<div><div id="c1">C1</div><div>C2</div><div>C3</div><div id="a1">A1</div><div>A2</div><div id="b1">B1</div></div>');
			
			    expect(container.querySelector('#a1')).toBe(A1);
			    expect(container.querySelector('#b1')).toBe(B1);
			    expect(container.querySelector('#c1')).toBe(C1);
			
			    // Switch order again
			    render(
			      <div>
			        \{fragmentB()\}
			        \{fragmentC()\}
			      </div>,
			      container
			    );
			
			    // Verify dom has changed and nodes are the same
			    expect(container.innerHTML).toBe('<div><div id="b1">B1</div><div id="c1">C1</div><div>C2</div><div>C3</div></div>');
			
			    expect(container.querySelector('#a1')).toBe(null);
			    expect(container.querySelector('#b1')).toBe(B1);
			    expect(container.querySelector('#c1')).toBe(C1);
			  \});
			
			  it('Should clone fragment children if they are passed as reference', () => \{
			    const fragmentA = createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			    const fragmentB = createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			    const fragmentC = createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			    const content = [fragmentC];
			
			    function SFC() \{
			      return (
			        <Fragment>
			          <span>1</span>
			          <Fragment>\{content\}</Fragment>
			          <span>2</span>
			        </Fragment>
			      );
			    \}
			
			    render(
			      <Fragment>
			        \{fragmentA\}
			        <SFC key="sfc" />
			        \{fragmentB\}
			        \{fragmentC\}
			      </Fragment>,
			      container
			    );
			
			    const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			    const FragmentBHtml = '<div id="b1">B1</div>';
			    const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			    const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			    expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + FragmentCHtml);
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to move component with fragment root', () => \{
			    const fragmentA = createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			    const fragmentB = createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			    const fragmentC = createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			    const content = [fragmentC];
			
			    function SFC() \{
			      return (
			        <Fragment>
			          <span>1</span>
			          <Fragment>\{content\}</Fragment>
			          <span>2</span>
			        </Fragment>
			      );
			    \}
			
			    render(
			      <Fragment>
			        \{fragmentA\}
			        <SFC key="sfc" />
			        \{fragmentB\}
			        \{fragmentC\}
			      </Fragment>,
			      container
			    );
			
			    const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			    const FragmentBHtml = '<div id="b1">B1</div>';
			    const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			    const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			    expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + FragmentCHtml);
			
			    // Switch order
			    render(
			      <Fragment>
			        \{fragmentA\}
			        \{fragmentC\}
			        <SFC key="sfc" />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe(FragmentAHtml + FragmentCHtml + SFCHtml);
			
			    // Switch order again
			    render(
			      <Fragment>
			        <div key="1">1</div>
			        <SFC key="sfc" />
			        \{fragmentA\}
			        \{fragmentC\}
			        <div key="1">2</div>
			      </Fragment>,
			      container
			    );
			
			    // Verify dom has changed and nodes are the same
			    expect(container.innerHTML).toBe('<div>1</div>' + SFCHtml + FragmentAHtml + FragmentCHtml + '<div>2</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to move component with fragment root #2', () => \{
			    const fragmentA = createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			    const fragmentB = createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			    const fragmentC = createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			    const content = [fragmentC];
			
			    function SFC() \{
			      return (
			        <Fragment>
			          <span>1</span>
			          <Fragment>\{content\}</Fragment>
			          <span>2</span>
			        </Fragment>
			      );
			    \}
			
			    render(
			      <Fragment>
			        \{fragmentA\}
			        <SFC key="sfc1" />
			        \{fragmentB\}
			        <SFC key="sfc2" />
			        \{fragmentC\}
			        <SFC key="sfc3" />
			      </Fragment>,
			      container
			    );
			
			    const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			    const FragmentBHtml = '<div id="b1">B1</div>';
			    const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			    const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			    expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + SFCHtml + FragmentCHtml + SFCHtml);
			
			    // Switch order
			    render(
			      <Fragment>
			        <SFC key="sfc3" />
			        \{fragmentA\}
			        <SFC key="sfc1" />
			        \{fragmentC\}
			        <SFC key="sfc2" />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe(SFCHtml + FragmentAHtml + SFCHtml + FragmentCHtml + SFCHtml);
			
			    // Switch order again
			    render(
			      <Fragment>
			        <div key="1">1</div>
			        <SFC key="sfc1" />
			        <SFC key="sfc2" />
			        \{fragmentA\}
			        \{fragmentC\}
			        <div key="1">2</div>
			        <SFC key="sfc3" />
			      </Fragment>,
			      container
			    );
			
			    // Verify dom has changed and nodes are the same
			    expect(container.innerHTML).toBe('<div>1</div>' + SFCHtml + SFCHtml + FragmentAHtml + FragmentCHtml + '<div>2</div>' + SFCHtml);
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to render fragments JSX way', () => \{
			    interface FragmenterProps \{
			      first: InfernoNode;
			      mid: InfernoNode;
			      last: InfernoNode;
			      changeOrder?: boolean;
			    \}
			
			    function Fragmenter(\{ first, mid, last, changeOrder \}: FragmenterProps) \{
			      if (changeOrder) \{
			        return (
			          <>
			            <div>\{first\}</div>
			            <>
			              More
			              \{null\}
			              Hey!
			              <Fragment>
			                <>Large \{last\}</>
			                <Fragment>And Small</Fragment>
			              </Fragment>
			              <>Nesting</>
			              \{mid\}
			            </>
			            <span>bar</span>
			            \{null\}
			          </>
			        );
			      \}
			      return (
			        <>
			          <div>\{first\}</div>
			          Hey!
			          <>
			            More
			            <>Nesting</>
			            \{mid\}
			            <Fragment>
			              <>Large \{last\}</>
			              <Fragment>And Small</Fragment>
			            </Fragment>
			          </>
			          <span>bar</span>
			        </>
			      );
			    \}
			
			    let mountCounter = 0;
			    let unmountCounter = 0;
			
			    interface FoobarComProps \{
			      node: HTMLDivElement;
			    \}
			
			    class FoobarCom extends Component<FoobarComProps> \{
			      public componentWillMount() \{
			        mountCounter++;
			      \}
			
			      public componentWillUnmount() \{
			        unmountCounter++;
			      \}
			
			      public render(props) \{
			        return (
			          <>
			            \{props.children\}
			            \{createPortal(<div>InvisiblePortalCreator</div>, props.node)\}
			            \{null\}
			            Try out some crazy stuff
			          </>
			        );
			      \}
			    \}
			
			    const portalNode = document.createElement('div');
			
			    render(
			      <FoobarCom node=\{portalNode\}>
			        <Fragmenter first="first" mid="MID" last=\{<div>Why?</div>\} />
			      </FoobarCom>,
			      container
			    );
			
			    expect(mountCounter).toBe(1);
			    expect(unmountCounter).toBe(0);
			    expect(container.innerHTML).toBe('<div>first</div>Hey!MoreNestingMIDLarge <div>Why?</div>And Small<span>bar</span>Try out some crazy stuff');
			    expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			
			    render(
			      <FoobarCom node=\{portalNode\}>
			        <Fragmenter first=\{<span>GoGo</span>\} mid="MID" last=\{<div>Why?</div>\} changeOrder=\{true\} />
			      </FoobarCom>,
			      container
			    );
			
			    expect(mountCounter).toBe(1);
			    expect(unmountCounter).toBe(0);
			    expect(container.innerHTML).toBe('<div><span>GoGo</span></div>MoreHey!Large <div>Why?</div>And SmallNestingMID<span>bar</span>Try out some crazy stuff');
			    expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			
			    render(
			      <FoobarCom node=\{portalNode\}>
			        <Fragmenter first="first" mid="MID" last=\{<div>Why?</div>\} />
			      </FoobarCom>,
			      container
			    );
			    expect(mountCounter).toBe(1);
			    expect(unmountCounter).toBe(0);
			    expect(container.innerHTML).toBe('<div>first</div>Hey!MoreNestingMIDLarge <div>Why?</div>And Small<span>bar</span>Try out some crazy stuff');
			    expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			  \});
			
			  it('Should render deeply nested fragment', () => \{
			    function Fragmenter2() \{
			      return (
			        <>
			          <>
			            <>
			              <>
			                <>
			                  <>
			                    <>
			                      <>Okay!</>
			                    </>
			                  </>
			                </>
			              </>
			            </>
			          </>
			        </>
			      );
			    \}
			
			    render(<Fragmenter2 />, container);
			
			    expect(container.innerHTML).toBe('Okay!');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should append DOM nodes to correct position when component root Fragmnet change', () => \{
			    class TestRoot extends Component \{
			      public render() \{
			        return <>\{this.props.children\}</>;
			      \}
			    \}
			
			    render(
			      <div>
			        <TestRoot>
			          <div>1</div>
			          <div>2</div>
			        </TestRoot>
			        <TestRoot>
			          <span>Ok</span>
			          <span>Test</span>
			        </TestRoot>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><span>Ok</span><span>Test</span></div>');
			
			    render(
			      <div>
			        <TestRoot>
			          <div>1</div>
			          <div>2</div>
			          <div>3</div>
			          <div>4</div>
			        </TestRoot>
			        <TestRoot>
			          <div>Other</div>
			        </TestRoot>
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><div>3</div><div>4</div><div>Other</div></div>');
			  \});
			
			  it('Should not clear whole parent element when fragment children are cleared', () => \{
			    class TestRoot extends Component \{
			      public render() \{
			        return <>\{this.props.children\}</>;
			      \}
			    \}
			
			    render(
			      <div>
			        <TestRoot>
			          <div>1</div>
			          <div>2</div>
			        </TestRoot>
			        <TestRoot>
			          <span>Ok</span>
			          <span>Test</span>
			        </TestRoot>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><span>Ok</span><span>Test</span></div>');
			
			    render(
			      <div>
			        <TestRoot>
			          <div>1</div>
			          <div>2</div>
			          <div>3</div>
			          <div>4</div>
			        </TestRoot>
			        <TestRoot />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><div>3</div><div>4</div></div>');
			  \});
			
			  it('Should move fragment and all its contents when using Fragment long syntax with keys', () => \{
			    let unmountCounter = 0;
			    let mountCounter = 0;
			
			    class TestLifecycle extends Component \{
			      public componentWillUnmount() \{
			        unmountCounter++;
			      \}
			
			      public componentWillMount() \{
			        mountCounter++;
			      \}
			
			      public render() \{
			        return <>\{this.props.children\}</>;
			      \}
			    \}
			
			    render(
			      <div>
			        <Fragment key="1">
			          <TestLifecycle>1a</TestLifecycle>
			          <TestLifecycle>1b</TestLifecycle>
			        </Fragment>
			        <Fragment key="2">
			          <TestLifecycle>2a</TestLifecycle>
			          <TestLifecycle>2b</TestLifecycle>
			        </Fragment>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>1a1b2a2b</div>');
			    expect(unmountCounter).toBe(0);
			    expect(mountCounter).toBe(4);
			
			    render(
			      <div>
			        <Fragment key="2">
			          <TestLifecycle>2a</TestLifecycle>
			          <TestLifecycle>2b</TestLifecycle>
			          <TestLifecycle>2c</TestLifecycle>
			        </Fragment>
			        <Fragment key="1">
			          <TestLifecycle>1a</TestLifecycle>
			          <TestLifecycle>1b</TestLifecycle>
			        </Fragment>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>2a2b2c1a1b</div>');
			    expect(unmountCounter).toBe(0);
			    expect(mountCounter).toBe(5);
			
			    render(
			      <div>
			        <Fragment key="3">
			          <TestLifecycle>3a</TestLifecycle>
			          <TestLifecycle>3b</TestLifecycle>
			          <TestLifecycle>3c</TestLifecycle>
			        </Fragment>
			        <Fragment key="2">
			          <TestLifecycle>2a</TestLifecycle>
			          <TestLifecycle>2Patched</TestLifecycle>
			        </Fragment>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>3a3b3c2a2Patched</div>');
			    expect(unmountCounter).toBe(3);
			    expect(mountCounter).toBe(8);
			  \});
			
			  it('Should unmount empty fragments', () => \{
			    render(
			      <Fragment>
			        <Fragment />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    render(
			      <Fragment>
			        <div />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(
			      <Fragment>
			        <Fragment />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to replace last element in fragment', () => \{
			    render(
			      <Fragment>
			        <Fragment>
			          <span>1a</span>
			          <span>1b</span>
			          <div>1c</div>
			        </Fragment>
			        <Fragment>
			          <span>2a</span>
			          <span>2b</span>
			          <span>2c</span>
			        </Fragment>
			        <Fragment />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<span>1a</span><span>1b</span><div>1c</div><span>2a</span><span>2b</span><span>2c</span>');
			
			    render(
			      <Fragment>
			        <Fragment>
			          <span>1a</span>
			          <span>1c</span>
			        </Fragment>
			        <Fragment>
			          <span>2a</span>
			          <span>2b</span>
			          <span>2c</span>
			        </Fragment>
			        <Fragment />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<span>1a</span><span>1c</span><span>2a</span><span>2b</span><span>2c</span>');
			
			    render(
			      <Fragment>
			        <Fragment />
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should mount Fragment with invalid children', () => \{
			    render(
			      <Fragment>
			        \{null\}
			        \{undefined\}
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should mount Fragment with invalid children #2', () => \{
			    function Foobar() \{
			      return null;
			    \}
			
			    render(
			      <Fragment>
			        \{null\}
			        <Foobar />
			        \{undefined\}
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should mount Fragment with invalid children #2', () => \{
			    let add = false;
			
			    function Foobar() \{
			      if (add) \{
			        return <div>Ok</div>;
			      \}
			      return null;
			    \}
			
			    render(
			      <Fragment>
			        \{null\}
			        <Foobar />
			        \{undefined\}
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    add = true;
			
			    render(
			      <Fragment>
			        \{null\}
			        <Foobar />
			        \{undefined\}
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Ok</div>');
			  \});
			
			  it('Should be possible to update from 0 to 1', () => \{
			    function Foobar() \{
			      return <div>Ok</div>;
			    \}
			
			    let content = [null];
			
			    render(
			      <Fragment>
			        <span>1</span>
			        <Fragment>\{content\}</Fragment>
			        <span>2</span>
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			
			    content = [<Foobar />];
			
			    render(
			      <Fragment>
			        <span>1</span>
			        <Fragment>\{content\}</Fragment>
			        <span>2</span>
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<span>1</span><div>Ok</div><span>2</span>');
			  \});
			
			  it('Should be possible to update from 0 to 1 fragment -> fragment', () => \{
			    function Foobar() \{
			      return <div>Ok</div>;
			    \}
			
			    let content: InfernoNode[] = [];
			
			    render(
			      <Fragment>
			        <span>1</span>
			        <Fragment>\{content\}</Fragment>
			        <span>2</span>
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			
			    content = [
			      <Fragment>
			        <Foobar />
			      </Fragment>
			    ];
			
			    render(
			      <Fragment>
			        <span>1</span>
			        <Fragment>\{content\}</Fragment>
			        <span>2</span>
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<span>1</span><div>Ok</div><span>2</span>');
			  \});
			
			  it('Should be possible to mount and patch single component fragment children', () => \{
			    let counter = 0;
			
			    class Foobar extends Component \{
			      public componentWillMount() \{
			        counter++;
			      \}
			      public render() \{
			        return null;
			      \}
			    \}
			
			    render(<></>, container);
			
			    render(
			      <>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			    expect(counter).toBe(1);
			
			    render(
			      <>
			        <div>Ok</div>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Ok</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to mount and patch single component fragment children - variation 2', () => \{
			    let counter = 0;
			
			    class Foobar extends Component \{
			      public componentWillMount() \{
			        counter++;
			      \}
			      public render() \{
			        return null;
			      \}
			    \}
			
			    let nodes: InfernoNode[] = [];
			
			    render(<>\{nodes\}</>, container);
			
			    nodes = [<Foobar />];
			
			    render(<>\{nodes\}</>, container);
			
			    nodes = [<Foobar />, <Foobar />, <Foobar />];
			
			    render(<>\{nodes\}</>, container);
			
			    nodes = [];
			
			    render(<>\{nodes\}</>, container);
			
			    expect(container.innerHTML).toBe('');
			    expect(counter).toBe(3);
			
			    render(
			      <>
			        <div>Ok</div>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Ok</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to patch single fragment child component', () => \{
			    let counter = 0;
			
			    class Foobar extends Component \{
			      public componentWillMount() \{
			        counter++;
			      \}
			      public render() \{
			        return null;
			      \}
			    \}
			
			    render(
			      <>
			        <>
			          <Foobar />
			        </>
			        <>
			          <Foobar />
			        </>
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			    expect(counter).toBe(2);
			
			    render(
			      <>
			        <></>
			        <>
			          <Foobar />
			        </>
			        <>
			          <Foobar />
			        </>
			        <></>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			    expect(counter).toBe(4);
			
			    render(
			      <>
			        <div>Ok</div>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Ok</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to mount and patch single component fragment children', () => \{
			    class Foobar extends Component \{
			      public render() \{
			        return null;
			      \}
			    \}
			
			    render(
			      <>
			        <Foobar />
			      </>,
			      container
			    );
			
			    render(
			      <>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    render(
			      <>
			        <div>Ok</div>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Ok</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to mount and patch single component fragment children', () => \{
			    class Foobar extends Component \{
			      public render() \{
			        return null;
			      \}
			    \}
			
			    render(<>\{null\}</>, container);
			
			    render(
			      <>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('');
			
			    render(
			      <>
			        <div>Ok</div>
			        <Foobar />
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Ok</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should render fragment inside fragment Github #1399', () => \{
			    function Layout(props) \{
			      return <>\{props.children\}</>;
			    \}
			
			    class PageTemplate extends Component \{
			      public test(sim) \{
			        return (
			          <>
			            <div>\{sim\}</div>
			          </>
			        );
			      \}
			
			      public render() \{
			        return (
			          <Layout>
			            <div>test</div>
			            <>\{this.test('sim')\}</>
			          </Layout>
			        );
			      \}
			    \}
			
			    render(<PageTemplate />, container);
			
			    expect(container.innerHTML).toBe('<div>test</div><div>sim</div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should not crash if lastFragment is empty and optimized for keyed ( mount )', () => \{
			    let nodes: InfernoNode[] = [];
			
			    render(<Fragment \$HasKeyedChildren>\{nodes\}</Fragment>, container);
			
			    expect(container.innerHTML).toBe('');
			
			    nodes = [<h1>Hello</h1>, <h2>InfernoJS</h2>];
			
			    render(<Fragment \$HasKeyedChildren>\{nodes\}</Fragment>, container);
			
			    expect(container.innerHTML).toBe('<h1>Hello</h1><h2>InfernoJS</h2>');
			  \});
			
			  it('Should not crash if lastFragment is empty and optimized for keyed ( patch )', () => \{
			    let nodes: InfernoNode[] = [];
			
			    render(<Fragment \$HasKeyedChildren>\{nodes\}</Fragment>, container);
			
			    expect(container.innerHTML).toBe('');
			
			    nodes = nodes.slice();
			
			    render(<Fragment \$HasKeyedChildren>\{nodes\}</Fragment>, container);
			
			    expect(container.innerHTML).toBe('');
			
			    nodes = [<h1>Hello</h1>, <h2>InfernoJS</h2>];
			
			    render(<Fragment \$HasKeyedChildren>\{nodes\}</Fragment>, container);
			
			    expect(container.innerHTML).toBe('<h1>Hello</h1><h2>InfernoJS</h2>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\fragments.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(27)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\hooks.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import Spy = jasmine.Spy;
			
			describe('Component lifecycle (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('componentWillUnmount', () => \{
			    it('Should trigger UnMount for all children', () => \{
			      let updater: (() => void) | null = null;
			
			      interface AState \{
			        foo: boolean;
			      \}
			
			      class A extends Component<unknown, AState> \{
			        public state: AState;
			
			        public componentWillUnmount() \{\}
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            foo: true
			          \};
			
			          this.updateme = this.updateme.bind(this);
			          updater = this.updateme;
			        \}
			
			        public updateme() \{
			          this.setState(\{
			            foo: !this.state.foo
			          \});
			        \}
			
			        public render() \{
			          return (
			            <div>
			              \{(() => \{
			                if (this.state.foo) \{
			                  return null;
			                \}
			                return <B />;
			              \})()\}
			              <button onClick=\{this.updateme\}>btn</button>
			            </div>
			          );
			        \}
			      \}
			
			      class B extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return (
			            <div>
			              <C />
			            </div>
			          );
			        \}
			      \}
			
			      class C extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return (
			            <div>
			              <D />
			            </div>
			          );
			        \}
			      \}
			
			      class D extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div>Terve</div>;
			        \}
			      \}
			
			      const Aspy = spyOn(A.prototype, 'componentWillUnmount');
			      const Bspy = spyOn(B.prototype, 'componentWillUnmount');
			      const CSpy = spyOn(C.prototype, 'componentWillUnmount');
			      const DSpy = spyOn(D.prototype, 'componentWillUnmount');
			
			      render(<A />, container);
			      expect(container.innerHTML).toBe('<div><button>btn</button></div>');
			      expect(Aspy).not.toHaveBeenCalled();
			      expect(Bspy).not.toHaveBeenCalled();
			      expect(CSpy).not.toHaveBeenCalled();
			      expect(DSpy).not.toHaveBeenCalled();
			
			      updater!();
			      expect(container.innerHTML).toBe('<div><div><div><div>Terve</div></div></div><button>btn</button></div>');
			      expect(Aspy).not.toHaveBeenCalled();
			      expect(Bspy).not.toHaveBeenCalled();
			      expect(CSpy).not.toHaveBeenCalled();
			      expect(DSpy).not.toHaveBeenCalled();
			
			      updater!();
			      expect(container.innerHTML).toBe('<div><button>btn</button></div>');
			      expect(Aspy).not.toHaveBeenCalled();
			      expect(Bspy).toHaveBeenCalledTimes(1);
			      expect(CSpy).toHaveBeenCalledTimes(1);
			      expect(DSpy).toHaveBeenCalledTimes(1);
			    \});
			
			    it('Should not trigger unmount for new node', () => \{
			      let updater: (() => void) | null = null;
			
			      interface AState \{
			        foo: boolean;
			      \}
			
			      class A extends Component<unknown, AState> \{
			        public state: AState;
			        public componentWillUnmount() \{\}
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            foo: true
			          \};
			
			          this.updateme = this.updateme.bind(this);
			          updater = this.updateme;
			        \}
			
			        public updateme() \{
			          this.setState(\{
			            foo: !this.state.foo
			          \});
			        \}
			
			        public render() \{
			          return (
			            <div>
			              \{(() => \{
			                if (this.state.foo) \{
			                  return null;
			                \}
			                return <B />;
			              \})()\}
			              <button onClick=\{this.updateme\}>btn</button>
			            </div>
			          );
			        \}
			      \}
			
			      class B extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <C />;
			        \}
			      \}
			
			      class C extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <D />;
			        \}
			      \}
			
			      class D extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div>Terve</div>;
			        \}
			      \}
			
			      const Aspy = spyOn(A.prototype, 'componentWillUnmount');
			      const Bspy = spyOn(B.prototype, 'componentWillUnmount');
			      const CSpy = spyOn(C.prototype, 'componentWillUnmount');
			      const DSpy = spyOn(D.prototype, 'componentWillUnmount');
			
			      render(<A />, container);
			      expect(container.innerHTML).toBe('<div><button>btn</button></div>');
			      expect(Aspy).not.toHaveBeenCalled();
			      expect(Bspy).not.toHaveBeenCalled();
			      expect(CSpy).not.toHaveBeenCalled();
			      expect(DSpy).not.toHaveBeenCalled();
			
			      updater!();
			      expect(container.innerHTML).toBe('<div><div>Terve</div><button>btn</button></div>');
			      expect(Aspy).not.toHaveBeenCalled();
			      expect(Bspy).not.toHaveBeenCalled();
			      expect(CSpy).not.toHaveBeenCalled();
			      expect(DSpy).not.toHaveBeenCalled();
			
			      updater!();
			      expect(container.innerHTML).toBe('<div><button>btn</button></div>');
			      expect(Aspy).not.toHaveBeenCalled();
			      expect(Bspy).toHaveBeenCalledTimes(1);
			      expect(CSpy).toHaveBeenCalledTimes(1);
			      expect(DSpy).toHaveBeenCalledTimes(1);
			    \});
			
			    it('Should trigger unMount once for direct nested children', () => \{
			      class B extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div>B</div>;
			        \}
			      \}
			
			      class C extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div>C</div>;
			        \}
			      \}
			
			      class D extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div>D</div>;
			        \}
			      \}
			
			      const Bspy = spyOn(B.prototype, 'componentWillUnmount');
			      const CSpy = spyOn(C.prototype, 'componentWillUnmount');
			      const DSpy = spyOn(D.prototype, 'componentWillUnmount');
			
			      render(<B />, container);
			      expect(container.innerHTML).toBe('<div>B</div>');
			      expect(Bspy).not.toHaveBeenCalled();
			      expect(CSpy).not.toHaveBeenCalled();
			      expect(DSpy).not.toHaveBeenCalled();
			
			      render(<C />, container);
			      expect(container.innerHTML).toBe('<div>C</div>');
			      expect(Bspy).toHaveBeenCalledTimes(1);
			      expect(CSpy).not.toHaveBeenCalled();
			      expect(DSpy).not.toHaveBeenCalled();
			
			      render(<D />, container);
			      expect(container.innerHTML).toBe('<div>D</div>');
			      expect(Bspy).toHaveBeenCalledTimes(1);
			      expect(CSpy).toHaveBeenCalledTimes(1);
			      expect(DSpy).not.toHaveBeenCalled();
			
			      render(<B />, container);
			      expect(container.innerHTML).toBe('<div>B</div>');
			      expect(Bspy).toHaveBeenCalledTimes(1);
			      expect(CSpy).toHaveBeenCalledTimes(1);
			      expect(DSpy).toHaveBeenCalledTimes(1);
			    \});
			
			    it('Should trigger unmount once for children', () => \{
			      class B extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return (
			            <div>
			              <B1 />
			              <B2 />
			            </div>
			          );
			        \}
			      \}
			
			      class B1 extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <p>B1</p>;
			        \}
			      \}
			
			      class B2 extends Component \{
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <p>B2</p>;
			        \}
			      \}
			
			      class C extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            text: 'C0'
			          \};
			
			          this.updateMe = this.updateMe.bind(this);
			        \}
			
			        public componentWillUnmount() \{\}
			
			        public updateMe() \{
			          this.setState(\{
			            text: 'C1'
			          \});
			        \}
			
			        public render() \{
			          return (
			            <div className="c">
			              <C1 />
			              <C2 />
			            </div>
			          );
			        \}
			      \}
			
			      class C1 extends Component \{
			        public render() \{
			          return <p>C1</p>;
			        \}
			      \}
			
			      class C2 extends Component \{
			        public render() \{
			          return <p>C2</p>;
			        \}
			      \}
			
			      const Bspy = spyOn(B.prototype, 'componentWillUnmount');
			      const B1spy = spyOn(B1.prototype, 'componentWillUnmount');
			      const B2spy = spyOn(B2.prototype, 'componentWillUnmount');
			      const CSpy = spyOn(C.prototype, 'componentWillUnmount');
			
			      render(<B />, container);
			      expect(container.innerHTML).toBe('<div><p>B1</p><p>B2</p></div>');
			      expect(Bspy).not.toHaveBeenCalled();
			      expect(B1spy).not.toHaveBeenCalled();
			      expect(B2spy).not.toHaveBeenCalled();
			      expect(CSpy).not.toHaveBeenCalled();
			
			      Bspy.calls.reset();
			      B1spy.calls.reset();
			      B2spy.calls.reset();
			      CSpy.calls.reset();
			
			      render(<C />, container);
			      expect(container.innerHTML).toBe('<div class="c"><p>C1</p><p>C2</p></div>');
			      expect(Bspy).toHaveBeenCalledTimes(1);
			      expect(B1spy).toHaveBeenCalledTimes(1);
			      expect(B2spy).toHaveBeenCalledTimes(1);
			    \});
			  \});
			
			  describe('Stateless component hooks', () => \{
			    let _container;
			
			    function StatelessComponent(_props: \{ a?: unknown \}) \{
			      return <div>Hello world</div>;
			    \}
			
			    afterEach(function () \{
			      render(null, _container);
			    \});
			
			    beforeEach(function () \{
			      _container = document.createElement('div');
			    \});
			
			    it('"onComponentWillMount" hook should fire, args props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      render(<StatelessComponent a=\{1\} onComponentWillMount=\{spyObj.fn\} />, _container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(1);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1 \});
			    \});
			
			    it('"onComponentDidMount" hook should fire, args DOM props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      render(<StatelessComponent a=\{1\} onComponentDidMount=\{spyObj.fn\} />, _container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toBe(_container.firstChild);
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 1 \});
			    \});
			
			    it('"onComponentWillUnmount" hook should fire, args DOM props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      render(<StatelessComponent a=\{1\} onComponentWillUnmount=\{spyObj.fn\} />, _container);
			      expect(spy.calls.count()).toBe(0);
			      // do unmount
			      render(null, _container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0].outerHTML).toBe('<div>Hello world</div>');
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 1 \});
			    \});
			
			    it('"onComponentWillUpdate" hook should fire, args props nextProps', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      render(<StatelessComponent a=\{1\} onComponentWillUpdate=\{spyObj.fn\} />, _container);
			      expect(spy.calls.count()).toBe(0); // Update 1
			      render(<StatelessComponent a=\{2\} onComponentWillUpdate=\{spyObj.fn\} />, _container);
			      expect(spy.calls.count()).toBe(1); // Update 2
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1 \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2 \});
			    \});
			
			    it('"onComponentDidUpdate" hook should fire, args prevProps props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      render(<StatelessComponent a=\{1\} onComponentDidUpdate=\{spyObj.fn\} />, _container);
			      expect(spy.calls.count()).toBe(0); // Update 1
			      render(<StatelessComponent a=\{2\} onComponentDidUpdate=\{spyObj.fn\} />, _container);
			      expect(spy.calls.count()).toBe(1); // Update 2
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1 \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2 \});
			    \});
			
			    it('"onComponentShouldUpdate" hook should fire, should call render when return true, args props nextProps', () => \{
			      let onComponentShouldUpdateCount = 0;
			      let renderCount = 0;
			      const spyObj = \{
			        fn: () => \{
			          onComponentShouldUpdateCount++;
			          return true;
			        \}
			      \};
			      const spy = spyOn(spyObj, 'fn').and.callThrough();
			      const StatelessComponent3 = (_props: \{ a?: unknown \}) => \{
			        renderCount++;
			        return null;
			      \};
			
			      render(<StatelessComponent3 a=\{1\} onComponentShouldUpdate=\{spyObj.fn\} />, _container);
			      expect(onComponentShouldUpdateCount).toBe(0); // Update 1
			      expect(renderCount).toBe(1); // Rendered 1 time
			
			      render(<StatelessComponent3 a=\{2\} onComponentShouldUpdate=\{spyObj.fn\} />, _container);
			      expect(onComponentShouldUpdateCount).toBe(1); // Update 2
			      expect(renderCount).toBe(2); // Rendered 2 time
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1 \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2 \});
			    \});
			
			    it('"onComponentShouldUpdate" hook should fire, should not call render when return false, args props nextProps', () => \{
			      let onComponentShouldUpdateCount = 0;
			      let renderCount = 0;
			      const spyObj = \{
			        fn: () => \{
			          onComponentShouldUpdateCount++;
			          return false;
			        \}
			      \};
			      const spy = spyOn(spyObj, 'fn').and.callThrough();
			      const StatelessComponent2 = (_props: \{ a?: unknown \}) => \{
			        renderCount++;
			        return null;
			      \};
			
			      render(<StatelessComponent2 a=\{1\} onComponentShouldUpdate=\{spyObj.fn\} />, _container);
			      expect(onComponentShouldUpdateCount).toBe(0); // Update 1
			      expect(renderCount).toBe(1); // Rendered 1 time
			
			      render(<StatelessComponent2 a=\{2\} onComponentShouldUpdate=\{spyObj.fn\} />, _container);
			      expect(onComponentShouldUpdateCount).toBe(1); // Update 2
			      expect(renderCount).toBe(1); // Rendered 1 time
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1 \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2 \});
			    \});
			  \});
			
			  describe('ref hook', () => \{
			    const fakeObj = \{
			      previousSiblingCallback() \{\},
			      innerCallback() \{\},
			      innerSecondCallback() \{\}
			    \};
			
			    const RefTester = (\{ inner, innersecond \}) => \{
			      let content = null;
			      if (inner) \{
			        let contentTwo = null;
			        if (innersecond) \{
			          contentTwo = <span ref=\{fakeObj.innerSecondCallback\}>dfg</span>;
			        \}
			        content = <div ref=\{fakeObj.innerCallback\}>\{contentTwo\}</div>;
			      \}
			
			      return (
			        <div>
			          <span ref=\{fakeObj.previousSiblingCallback\}>abc</span>
			          \{content\}
			        </div>
			      );
			    \};
			
			    let orderOfCalls: string[] = [];
			    let spyPreviousSibling = null as unknown as Spy;
			    let spyInner = null as unknown as Spy;
			    let spyInnerSecond = null as unknown as Spy;
			
			    beforeEach(function () \{
			      orderOfCalls = [];
			      spyPreviousSibling = spyOn(fakeObj, 'previousSiblingCallback').and.callFake(function () \{
			        orderOfCalls.push('spyPreviousSibling');
			      \});
			      spyInner = spyOn(fakeObj, 'innerCallback').and.callFake(function () \{
			        orderOfCalls.push('inner');
			      \});
			      spyInnerSecond = spyOn(fakeObj, 'innerSecondCallback').and.callFake(function () \{
			        orderOfCalls.push('innerSecond');
			      \});
			    \});
			
			    it('Should call function when node is attached', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			      render(<RefTester inner=\{false\} innersecond=\{false\} />, container);
			
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{false\} />, container);
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div></div>');
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			    \});
			
			    it('Should call ref functions in order: child to parent', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner']);
			    \});
			
			    it('Should call ref when node is re-attached and re-unmounted', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner']);
			
			      // reset
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      render(<RefTester inner=\{false\} innersecond=\{true\} />, container);
			
			      // Verify divs are removed from DOM
			      expect(container.innerHTML).toEqual('<div><span>abc</span></div>');
			
			      // Verify ref callbacks
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyInner.calls.argsFor(0)[0]).toEqual(null);
			      expect(spyInnerSecond.calls.argsFor(0)[0]).toEqual(null);
			
			      // reset
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			
			      // Verify divs are attached
			      expect(container.innerHTML).toEqual('<div><span>abc</span><div><span>dfg</span></div></div>');
			
			      // Verify ref callbacks
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      // reset
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			    \});
			
			    it('Should have width defined when html node is attached', () => \{
			      if (global.usingJSDOM) \{
			        // JSDOM mocks the ref node width to 0. Skip test
			        return;
			      \}
			
			      let node: HTMLDivElement | null = null;
			
			      class Hello extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public componentDidMount() \{
			          expect(node!.offsetWidth).not.toEqual(0);
			        \}
			
			        public ref(n) \{
			          if (n) \{
			            expect(n.offsetWidth).not.toEqual(0);
			            node = n;
			          \}
			        \}
			
			        public render() \{
			          return <div ref=\{this.ref\}>Hello World</div>;
			        \}
			      \}
			
			      render(<Hello />, container);
			    \});
			  \});
			
			  describe('ref hook complex', () => \{
			    const fakeObj = \{
			      previousSiblingCallback() \{\},
			      innerCallback() \{\},
			      innerSecondCallback() \{\}
			    \};
			
			    const RefTester = (\{ inner, innersecond \}) => \{
			      let content = null;
			      if (inner) \{
			        let contentTwo = null;
			        if (innersecond) \{
			          contentTwo = <span ref=\{fakeObj.innerSecondCallback\}>dfg</span>;
			        \}
			        content = <div ref=\{fakeObj.innerCallback\}>\{contentTwo\}</div>;
			      \}
			
			      return (
			        <div>
			          <span ref=\{fakeObj.previousSiblingCallback\}>abc</span>
			          \{content\}
			        </div>
			      );
			    \};
			
			    const PlainDiv = () => <div>plaindiv</div>;
			
			    const RefParent = (\{ bool, inner, innersecond \}) => \{
			      return <div>\{bool ? <RefTester inner=\{inner\} innersecond=\{innersecond\} /> : <PlainDiv />\}</div>;
			    \};
			
			    let orderOfCalls: string[] = [];
			    let spyPreviousSibling = null as unknown as Spy;
			    let spyInner = null as unknown as Spy;
			    let spyInnerSecond = null as unknown as Spy;
			
			    beforeEach(function () \{
			      orderOfCalls = [];
			      spyPreviousSibling = spyOn(fakeObj, 'previousSiblingCallback').and.callFake(function () \{
			        orderOfCalls.push('spyPreviousSibling');
			      \});
			      spyInner = spyOn(fakeObj, 'innerCallback').and.callFake(function () \{
			        orderOfCalls.push('inner');
			      \});
			      spyInnerSecond = spyOn(fakeObj, 'innerSecondCallback').and.callFake(function () \{
			        orderOfCalls.push('innerSecond');
			      \});
			    \});
			
			    afterEach(function () \{
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			    \});
			
			    it('Should not call ref unmount when node is not mounted', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			      render(<RefParent bool=\{true\} inner=\{false\} innersecond=\{false\} />, container);
			
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      expect(container.innerHTML).toEqual('<div><div><span>abc</span></div></div>');
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      // RENDER INNER DIVS
			      render(<RefParent bool=\{true\} inner=\{true\} innersecond=\{true\} />, container);
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      // verify order
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner']);
			
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      expect(container.innerHTML).toEqual('<div><div><span>abc</span><div><span>dfg</span></div></div></div>');
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      // UNMOUNT INNER DIVS
			      render(<RefParent bool=\{true\} inner=\{false\} innersecond=\{false\} />, container);
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      // verify order
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner', 'inner', 'innerSecond']);
			
			      expect(spyInner.calls.argsFor(0)[0]).toEqual(null);
			      expect(spyInnerSecond.calls.argsFor(0)[0]).toEqual(null);
			
			      expect(container.innerHTML).toEqual('<div><div><span>abc</span></div></div>');
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      // Inner and InnerSecond divs are now unmounted
			      // and unmounting parent should not cause them to unmounted again
			
			      // REPLACE PARENT
			      render(<RefParent bool=\{false\} inner=\{false\} innersecond=\{false\} />, container);
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			      expect(container.innerHTML).toEqual('<div><div>plaindiv</div></div>');
			    \});
			  \});
			
			  describe('ref hook #2 with statefull components', () => \{
			    const fakeObj = \{
			      previousSiblingCallback() \{\},
			      innerCallback() \{\},
			      innerSecondCallback() \{\}
			    \};
			
			    interface RefTesterProps \{
			      inner?: boolean;
			      innersecond?: boolean;
			    \}
			
			    class RefTester extends Component<RefTesterProps> \{
			      public render() \{
			        const inner = this.props.inner;
			        const innersecond = this.props.innersecond;
			
			        let content = null;
			        if (inner) \{
			          let contentTwo = null;
			          if (innersecond) \{
			            contentTwo = <span ref=\{fakeObj.innerSecondCallback\}>dfg</span>;
			          \}
			          content = <div ref=\{fakeObj.innerCallback\}>\{contentTwo\}</div>;
			        \}
			
			        return (
			          <div>
			            <span ref=\{fakeObj.previousSiblingCallback\}>abc</span>
			            \{content\}
			          </div>
			        );
			      \}
			    \}
			
			    let orderOfCalls: string[] = [];
			    let spyPreviousSibling = null as unknown as Spy;
			    let spyInner = null as unknown as Spy;
			    let spyInnerSecond = null as unknown as Spy;
			
			    beforeEach(function () \{
			      orderOfCalls = [];
			      spyPreviousSibling = spyOn(fakeObj, 'previousSiblingCallback').and.callFake(function () \{
			        orderOfCalls.push('spyPreviousSibling');
			      \});
			      spyInner = spyOn(fakeObj, 'innerCallback').and.callFake(function () \{
			        orderOfCalls.push('inner');
			      \});
			      spyInnerSecond = spyOn(fakeObj, 'innerSecondCallback').and.callFake(function () \{
			        orderOfCalls.push('innerSecond');
			      \});
			    \});
			
			    it('Should call function when node is attached #2', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			      render(<RefTester inner=\{false\} innersecond=\{false\} />, container);
			
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{false\} />, container);
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div></div>');
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			    \});
			
			    it('Should call ref functions in order: child to parent #2', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			
			      expect(spyPreviousSibling);
			      expect(spyInner);
			      expect(spyInnerSecond);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner']);
			    \});
			
			    it('Should call ref when node is re-attached and re-unmounted', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner']);
			
			      // reset
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      render(<RefTester inner=\{false\} innersecond=\{true\} />, container);
			
			      // Verify divs are removed from DOM
			      expect(container.innerHTML).toEqual('<div><span>abc</span></div>');
			
			      // Verify ref callbacks
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyInner.calls.argsFor(0)[0]).toEqual(null);
			      expect(spyInnerSecond.calls.argsFor(0)[0]).toEqual(null);
			
			      // reset
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      render(<RefTester inner=\{true\} innersecond=\{true\} />, container);
			
			      // Verify divs are attached
			      expect(container.innerHTML).toEqual('<div><span>abc</span><div><span>dfg</span></div></div>');
			
			      // Verify ref callbacks
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      // reset
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			    \});
			  \});
			
			  describe('ref hook complex #2 statefull components', () => \{
			    const fakeObj = \{
			      previousSiblingCallback() \{\},
			      innerCallback() \{\},
			      innerSecondCallback() \{\}
			    \};
			
			    interface RefTesterProps \{
			      bool?: boolean;
			      inner?: boolean;
			      innersecond?: boolean;
			    \}
			
			    class RefTester extends Component<RefTesterProps> \{
			      public render() \{
			        const inner = this.props.inner;
			        const innersecond = this.props.innersecond;
			
			        let content = null;
			        if (inner) \{
			          let contentTwo = null;
			          if (innersecond) \{
			            contentTwo = <span ref=\{fakeObj.innerSecondCallback\}>dfg</span>;
			          \}
			          content = <div ref=\{fakeObj.innerCallback\}>\{contentTwo\}</div>;
			        \}
			
			        return (
			          <div>
			            <span ref=\{fakeObj.previousSiblingCallback\}>abc</span>
			            \{content\}
			          </div>
			        );
			      \}
			    \}
			
			    class PlainDiv extends Component \{
			      public render() \{
			        return <div>plaindiv</div>;
			      \}
			    \}
			
			    interface RefParentProps \{
			      bool?: boolean;
			      inner?: boolean;
			      innersecond?: boolean;
			    \}
			
			    class RefParent extends Component<RefParentProps> \{
			      public render() \{
			        const \{ bool, inner, innersecond \} = this.props;
			
			        return <div>\{bool ? <RefTester inner=\{inner\} innersecond=\{innersecond\} /> : <PlainDiv />\}</div>;
			      \}
			    \}
			
			    let orderOfCalls: string[] = [];
			    let spyPreviousSibling = null as unknown as Spy;
			    let spyInner = null as unknown as Spy;
			    let spyInnerSecond = null as unknown as Spy;
			
			    beforeEach(function () \{
			      orderOfCalls = [];
			      spyPreviousSibling = spyOn(fakeObj, 'previousSiblingCallback').and.callFake(function () \{
			        orderOfCalls.push('spyPreviousSibling');
			      \});
			      spyInner = spyOn(fakeObj, 'innerCallback').and.callFake(function () \{
			        orderOfCalls.push('inner');
			      \});
			      spyInnerSecond = spyOn(fakeObj, 'innerSecondCallback').and.callFake(function () \{
			        orderOfCalls.push('innerSecond');
			      \});
			    \});
			
			    afterEach(function () \{
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			    \});
			
			    it('Should not call ref unmount when node is not mounted #2', () => \{
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			      render(<RefParent bool=\{true\} inner=\{false\} innersecond=\{false\} />, container);
			
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyPreviousSibling.calls.argsFor(0)[0].outerHTML).toEqual('<span>abc</span>');
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			
			      expect(container.innerHTML).toEqual('<div><div><span>abc</span></div></div>');
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      // RENDER INNER DIVS
			      render(<RefParent bool=\{true\} inner=\{true\} innersecond=\{true\} />, container);
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      // verify order
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner']);
			
			      expect(spyInner.calls.argsFor(0)[0].outerHTML).toEqual('<div><span>dfg</span></div>');
			      expect(spyInnerSecond.calls.argsFor(0)[0].outerHTML).toEqual('<span>dfg</span>');
			
			      expect(container.innerHTML).toEqual('<div><div><span>abc</span><div><span>dfg</span></div></div></div>');
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      // UNMOUNT INNER DIVS
			      render(<RefParent bool=\{true\} inner=\{false\} innersecond=\{false\} />, container);
			      expect(spyPreviousSibling).not.toHaveBeenCalled();
			      expect(spyInner).toHaveBeenCalledTimes(1);
			      expect(spyInnerSecond).toHaveBeenCalledTimes(1);
			      // verify order
			      expect(orderOfCalls).toEqual(['spyPreviousSibling', 'innerSecond', 'inner', 'inner', 'innerSecond']);
			
			      expect(spyInner.calls.argsFor(0)[0]).toEqual(null);
			      expect(spyInnerSecond.calls.argsFor(0)[0]).toEqual(null);
			
			      expect(container.innerHTML).toEqual('<div><div><span>abc</span></div></div>');
			      spyPreviousSibling.calls.reset();
			      spyInner.calls.reset();
			      spyInnerSecond.calls.reset();
			
			      // Inner and InnerSecond divs are now unmounted
			      // and unmounting parent should not cause them to unmounted again
			
			      // REPLACE PARENT
			      render(<RefParent bool=\{false\} inner=\{false\} innersecond=\{false\} />, container);
			      expect(spyPreviousSibling).toHaveBeenCalledTimes(1);
			      expect(spyInner).not.toHaveBeenCalled();
			      expect(spyInnerSecond).not.toHaveBeenCalled();
			      expect(container.innerHTML).toEqual('<div><div>plaindiv</div></div>');
			    \});
			  \});
			
			  describe('ES6 Component within functional component', () => \{
			    it('Should trigger lifecycle events when functional component change', () => \{
			      let unmounted = false;
			
			      function A() \{
			        return (
			          <div>
			            <Com />
			          </div>
			        );
			      \}
			
			      function B() \{
			        return (
			          <div>
			            <Com />
			          </div>
			        );
			      \}
			
			      class Com extends Component \{
			        public componentWillUnmount() \{
			          unmounted = true;
			        \}
			
			        public render() \{
			          return <div>C</div>;
			        \}
			      \}
			
			      render(<A />, container);
			      expect(container.innerHTML).toEqual('<div><div>C</div></div>');
			      expect(unmounted).toEqual(false);
			      render(<B />, container);
			      expect(unmounted).toEqual(true);
			      expect(container.innerHTML).toEqual('<div><div>C</div></div>');
			    \});
			
			    it('Should trigger lifecycle events when functional component dont change', () => \{
			      let unmounted = false;
			
			      function A() \{
			        return (
			          <div>
			            <Com />
			          </div>
			        );
			      \}
			
			      class Com extends Component \{
			        public componentWillUnmount() \{
			          unmounted = true;
			        \}
			
			        public render() \{
			          return <div>C</div>;
			        \}
			      \}
			
			      render(<A />, container);
			      expect(container.innerHTML).toEqual('<div><div>C</div></div>');
			      expect(unmounted).toEqual(false);
			      render(<A />, container);
			      expect(unmounted).toEqual(false);
			      expect(container.innerHTML).toEqual('<div><div>C</div></div>');
			    \});
			  \});
			
			  describe('context with hooks', () => \{
			    it('Should trigger componentWillMount before getting child context', () => \{
			      interface AState \{
			        foobar: string | null;
			      \}
			
			      class A extends Component<unknown, AState> \{
			        public state: AState;
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            foobar: null
			          \};
			        \}
			
			        public getChildContext() \{
			          return \{
			            foobar: this.state.foobar
			          \};
			        \}
			
			        public componentWillMount() \{
			          this.setState(\{
			            foobar: 'hey'
			          \});
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <Child />
			            </div>
			          );
			        \}
			      \}
			
			      class Child extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        public render() \{
			          return <span>\{this.context.foobar\}</span>;
			        \}
			      \}
			
			      render(<A />, container);
			
			      expect(container.innerHTML).toEqual('<div><span>hey</span></div>');
			    \});
			  \});
			
			  describe('ref', () => \{
			    it('Should trigger lifecycle hooks when parent changes', () => \{
			      const spy1 = jasmine.createSpy('spy');
			      const spy2 = jasmine.createSpy('spy');
			      const spy3 = jasmine.createSpy('spy');
			      const spy4 = jasmine.createSpy('spy');
			      const spy5 = jasmine.createSpy('spy');
			
			      class A extends Component \{
			        public render() \{
			          return (
			            <div>
			              <div ref=\{spy5\}>
			                <span>1</span>
			                <span>1</span>
			              </div>
			            </div>
			          );
			        \}
			      \}
			
			      class B extends Component \{
			        public componentWillMount() \{
			          this.setState(\{
			            foo: 'bar'
			          \});
			        \}
			
			        public render() \{
			          return (
			            <div>
			              <div ref=\{spy1\} />
			              <Child />
			              <div />
			              <div ref=\{spy2\} />
			              <div />
			              <Child ref=\{spy3\} />
			            </div>
			          );
			        \}
			      \}
			
			      class Child extends Component \{
			        public componentWillMount() \{
			          this.setState(\{
			            foo: '1'
			          \});
			        \}
			
			        public render() \{
			          return <div ref=\{spy4\}>5</div>;
			        \}
			      \}
			
			      render(<A />, container);
			      expect(spy5.calls.count()).toBe(1);
			
			      render(<B />, container);
			
			      expect(spy5.calls.count()).toBe(2); // mount + unmount
			
			      expect(spy1.calls.count()).toBe(1);
			      expect(spy2.calls.count()).toBe(1);
			      expect(spy3.calls.count()).toBe(1);
			      expect(spy4.calls.count()).toBe(2); // 2 refs
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\hooks.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(24)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\input.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ triggerEvent \} from 'inferno-utils';
			
			describe('Input type checkbox', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Checked attribute should be false', function () \{
			    render(<input type="checkbox" checked=\{false\} />, container);
			    const input = container.firstChild;
			
			    expect(input.checked).toBe(false);
			  \});
			
			  it('Checked attribute after Click', function () \{
			    let clickChecked: boolean | null = null;
			    let changeChecked: boolean | null = null;
			
			    render(
			      <input
			        type="checkbox"
			        checked=\{false\}
			        onclick=\{(e) => \{
			          clickChecked = e.currentTarget.checked;
			        \}\}
			        onchange=\{(e) => \{
			          changeChecked = e.currentTarget.checked;
			        \}\}
			      />,
			      container
			    );
			    const input = container.firstChild;
			
			    triggerEvent('click', input);
			
			    expect(input.checked).toBe(false);
			    expect(clickChecked).toBe(true);
			    expect(changeChecked).toBe(true);
			  \});
			
			  it('Checkbox click should not propagate to parent', function () \{
			    let clickChecked: boolean | null = null;
			    let changeChecked: boolean | null = null;
			    let parentClick = false;
			
			    render(
			      <div onClick=\{() => (parentClick = true)\}>
			        <input
			          type="checkbox"
			          checked=\{false\}
			          onclick=\{(e) => \{
			            clickChecked = e.currentTarget.checked;
			          \}\}
			          onchange=\{(e) => \{
			            changeChecked = e.currentTarget.checked;
			          \}\}
			        />
			      </div>,
			      container
			    );
			    const input = container.querySelector('input');
			
			    expect(parentClick).toBe(false);
			
			    triggerEvent('click', input);
			
			    expect(input.checked).toBe(false);
			    expect(clickChecked).toBe(true);
			    expect(changeChecked).toBe(true);
			    expect(parentClick).toBe(false);
			  \});
			
			  it('Checked attribute after synthetic Click', function () \{
			    let nClicks = 0;
			    let clickChecked: boolean | null = null;
			    let nChanges = 0;
			    let changeChecked: boolean | null = null;
			
			    render(
			      <input
			        type="checkbox"
			        checked=\{false\}
			        onClick=\{(e) => \{
			          clickChecked = e.currentTarget.checked;
			          nClicks++;
			        \}\}
			        onChange=\{(e) => \{
			          changeChecked = e.currentTarget.checked;
			          nChanges++;
			        \}\}
			      />,
			      container
			    );
			    const input = container.firstChild;
			
			    triggerEvent('click', input);
			
			    expect(input.checked).toBe(false);
			    expect(nClicks).toBe(1);
			    expect(clickChecked).toBe(true);
			    expect(nChanges).toBe(1);
			    expect(changeChecked).toBe(true);
			  \});
			\});
			
			describe('Input type Radio', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Controlled radio, checked=false', function () \{
			    render(<input type="radio" checked=\{false\} value="magic" />, container);
			    const input = container.firstChild;
			
			    expect(input.checked).toBe(false);
			  \});
			
			  it('Checked attribute after Click #2', function () \{
			    let clickChecked: boolean | null = null;
			    let changeChecked: boolean | null = null;
			
			    render(
			      <input
			        type="radio"
			        checked=\{false\}
			        value="magic"
			        onclick=\{(e) => \{
			          clickChecked = e.currentTarget.checked;
			        \}\}
			        onchange=\{(e) => \{
			          changeChecked = e.currentTarget.checked;
			        \}\}
			      />,
			      container
			    );
			    const input = container.firstChild;
			
			    triggerEvent('click', input);
			
			    expect(clickChecked).toBe(true);
			    expect(input.checked).toBe(false);
			    expect(changeChecked).toBe(true);
			  \});
			
			  it('Checked attribute after synthetic Click #3', function () \{
			    let clickChecked: boolean | null = null;
			    let changeChecked: boolean | null = null;
			
			    render(
			      <input
			        type="radio"
			        checked=\{false\}
			        value="magic"
			        onClick=\{(e) => \{
			          clickChecked = e.currentTarget.checked;
			        \}\}
			        onChange=\{(e) => \{
			          changeChecked = e.currentTarget.checked;
			        \}\}
			      />,
			      container
			    );
			    const input = container.firstChild;
			
			    triggerEvent('click', input);
			
			    expect(clickChecked).toBe(true);
			    expect(input.checked).toBe(false);
			    expect(changeChecked).toBe(true);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\input.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\instancenull.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, InfernoNode, render, rerender \} from 'inferno';
			import \{ triggerEvent \} from 'inferno-utils';
			
			describe('BUG: instance - null', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  const Triangle = (\{ direction \}) => (
			    <svg className=\{\`popover-triangle \$\{direction\}\`\}>
			      <polygon points=\{'0,0'\} />
			    </svg>
			  );
			
			  function DropdownItem(\{ className, children, attached \}) \{
			    return (
			      <li ref=\{attached\} className=\{\`dd-item \$\{className\}\`\}>
			        \{children\}
			      </li>
			    );
			  \}
			
			  interface IconProps \{
			    icon?: string;
			  \}
			
			  class Icon extends Component<IconProps> \{
			    constructor(props, context) \{
			      super(props, context);
			    \}
			
			    public componentWillMount() \{\}
			
			    public render() \{
			      const props = this.props;
			
			      if (!props.icon) \{
			        return null;
			      \}
			
			      /*
			       * FireFox v51.0 fixes issue with href
			       * iOS still broken (21.1.2017)
			       */
			
			      return (
			        <svg focusable="false" className=\{'svgicon'\}>
			          <use xlink:href=\{props.icon\} />
			        </svg>
			      );
			    \}
			  \}
			
			  interface PopoverProps \{
			    popoverClassName?: string;
			    align?: string;
			    arrow?: boolean;
			    isOpen?: boolean;
			    target?: HTMLDivElement | null;
			    hasMobileClose?: boolean;
			    body?: InfernoNode;
			    onOuterAction?: (ev: any) => void;
			  \}
			
			  interface PopoverState \{
			    placement: string;
			  \}
			
			  class Popover extends Component<PopoverProps, PopoverState> \{
			    private _elements: \{
			      container: HTMLDivElement | null;
			      parentPopover: HTMLDivElement | null;
			      popover: HTMLDivElement | null;
			      target: HTMLDivElement | null;
			      popoverBody: HTMLDivElement | null;
			    \};
			
			    public state: PopoverState;
			
			    constructor(props) \{
			      super(props);
			
			      this.state = \{
			        placement: 'below'
			      \};
			
			      // Element references
			      this._elements = \{
			        container: null,
			        parentPopover: null,
			        popover: null,
			        popoverBody: null,
			        target: props.target || null
			      \};
			
			      // Lexical bindings
			      this._refContainer = this._refContainer.bind(this);
			      this._refTarget = this._refTarget.bind(this);
			      this._refPopoverBody = this._refPopoverBody.bind(this);
			      this._popoverRef = this._popoverRef.bind(this);
			    \}
			
			    //
			    // PRIVATE GETTER
			    //
			
			    //
			    // Private
			    //
			
			    public _popoverRef(node) \{
			      this._elements.popover = node;
			      if (node !== null) \{
			        this.setState(\{
			          placement: ''
			        \});
			      \}
			    \}
			
			    public _refContainer(node) \{
			      this._elements.container = node;
			    \}
			
			    public _refPopoverBody(node) \{
			      this._elements.popoverBody = node;
			    \}
			
			    public _refTarget(node) \{
			      if (!this.props.target) \{
			        this._elements.target = node;
			      \}
			    \}
			
			    //
			    // PRIVATE STATIC
			    //
			
			    //
			    // OVERRIDEN FROM COMPONENT
			    //
			    public render() \{
			      const props = this.props;
			      let popover = null;
			      let closeButton = null;
			
			      if (props.isOpen) \{
			        let triangle = null;
			
			        if (props.arrow !== false) \{
			          triangle = <Triangle direction=\{this.state.placement\} />;
			        \}
			
			        popover = (
			          <div ref=\{this._popoverRef\} className="popover">
			            <div className="popover-layer">
			              \{triangle\}
			              <div ref=\{this._refPopoverBody\} className="popover-body">
			                \{props.body\}
			              </div>
			            </div>
			          </div>
			        );
			      \}
			
			      if (props.hasMobileClose) \{
			        closeButton = <div className="inverse-action popover-close" onClick=\{props.onOuterAction\} />;
			      \}
			
			      return (
			        <div ref=\{this._refContainer\} className="popover-placeholder">
			          \{closeButton\}
			          <div className="popover-target" ref=\{this._refTarget\}>
			            \{props.children\}
			          </div>
			          \{popover\}
			        </div>
			      );
			    \}
			  \}
			
			  interface DropdownProps \{
			    items: \{
			      icon: string;
			      text: string;
			      value: string;
			    \}[];
			
			    changeCallback?: () => void;
			    changeParams?: unknown;
			    value?: string;
			  \}
			
			  interface DropdownState \{
			    activeValue?: string | null;
			    editableText: string;
			    isEditMode: boolean;
			    filteredItems:
			      | \{
			          icon: string;
			          text: string;
			          value: string;
			        \}[]
			      | null;
			  \}
			
			  class Dropdown extends Component<DropdownProps, DropdownState> \{
			    private _elements: \{ bottomLoader: null; activeNode: null; list: null \};
			    // @ts-expect-error
			    private _popover: HTMLDivElement | null;
			
			    public state: DropdownState;
			
			    constructor(props) \{
			      super(props);
			
			      // Element references
			      this._elements = \{
			        activeNode: null,
			        bottomLoader: null,
			        list: null
			      \};
			
			      this.state = \{
			        activeValue: props.value,
			        editableText: '',
			        filteredItems: null,
			        isEditMode: false
			      \};
			
			      // Lexical bindings
			      this._closePopover = this._closePopover.bind(this);
			      this._onActiveItemAttached = this._onActiveItemAttached.bind(this);
			      this._onDropDownCreating = this._onDropDownCreating.bind(this);
			      this._refPopover = this._refPopover.bind(this);
			      this._refBottomLoader = this._refBottomLoader.bind(this);
			      this._makeEditable = this._makeEditable.bind(this);
			    \}
			
			    //
			    // PRIVATE
			    //
			
			    // In some cases, we don't want to stop event propagation, f.e. listView editMode and movements with shift + TAB
			    public _closePopover(event) \{
			      event.stopPropagation();
			
			      this.setState(\{
			        activeValue: this.props.value,
			        editableText: '',
			        filteredItems: null,
			        isEditMode: false
			      \});
			    \}
			
			    public _onDropDownCreating(node) \{
			      this._elements.list = node;
			    \}
			
			    public _onActiveItemAttached(node) \{
			      this._elements.activeNode = node;
			    \}
			
			    public _refPopover(instance) \{
			      this._popover = instance;
			    \}
			
			    public _refBottomLoader(node) \{
			      this._elements.bottomLoader = node;
			    \}
			
			    public _renderItems() \{
			      const items = this.state.filteredItems || this.props.items || [];
			      const itemsToRender: InfernoNode[] = [];
			
			      for (let i = 0; i < items.length; i++) \{
			        const item = items[i];
			
			        itemsToRender.push(this._renderItem(item, i));
			      \}
			
			      return itemsToRender;
			    \}
			
			    public _renderDropdown() \{
			      const currentState = this.state;
			
			      // Shortcut dropdown rendering process when its not visible
			      if (!currentState.isEditMode) \{
			        return null;
			      \}
			
			      // Render items
			      const items = this._renderItems();
			
			      return (
			        <ul className="editable-dropdown" ref=\{this._onDropDownCreating\}>
			          \{items\}
			        </ul>
			      );
			    \}
			
			    public _renderItem(dropdownItem, isActive) \{
			      return (
			        <DropdownItem attached=\{isActive ? this._onActiveItemAttached : null\} key=\{dropdownItem.value\} className=\{'dd-item-icon'\}>
			          <Icon icon=\{dropdownItem.icon\} />
			          \{dropdownItem.text\}
			        </DropdownItem>
			      );
			    \}
			
			    public _makeEditable() \{
			      const state = this.state;
			      const props = this.props;
			
			      if (state.isEditMode) \{
			        return;
			      \}
			
			      // Updating editable and changing into editmode
			      this.setState(\{
			        activeValue: props.value,
			        isEditMode: true
			      \});
			    \}
			
			    //
			    // OVERRIDDEN FROM COMPONENT
			    //
			
			    public render() \{
			      return (
			        <Popover
			          ref=\{this._refPopover\}
			          arrow=\{true\}
			          align="begin"
			          hasMobileClose=\{true\}
			          isOpen=\{this.state.isEditMode\}
			          body=\{this._renderDropdown()\}
			          onOuterAction=\{this._closePopover\}
			        >
			          <div id="MAGICBUTTON" onclick=\{this.state.isEditMode ? this._closePopover : this._makeEditable\}>
			            TEST
			          </div>
			        </Popover>
			      );
			    \}
			  \}
			
			  it('Should not fail', () => \{
			    const items = [
			      \{
			        icon: '#user',
			        text: 'Implementation',
			        value: 'b73ea78d-350d-f764-e429-9bebd9d8b4b3'
			      \},
			      \{
			        icon: '#reminder',
			        text: 'Issue',
			        value: '4e0a069d-899a-418a-df27-8ff5ef18d459'
			      \},
			      \{
			        icon: '#favourite',
			        text: 'LomaTaski',
			        value: 'd9a54cc9-2a16-08e3-85da-c230b5d0b121'
			      \}
			    ];
			    const value = 'b73ea78d-350d-f764-e429-9bebd9d8b4b3';
			
			    render(
			      <div>
			        <Dropdown items=\{items\} changeCallback=\{function () \{\}\} changeParams=\{\{ guid: 'foo', field: 'activityType' \}\} value=\{value\} />
			      </div>,
			      container
			    );
			
			    triggerEvent('click', container.querySelector('#MAGICBUTTON'));
			
			    rerender();
			    expect(container.querySelectorAll('.dd-item').length).toBe(3);
			
			    triggerEvent('click', container.querySelector('#MAGICBUTTON'));
			
			    rerender();
			    expect(container.querySelectorAll('.dd-item').length).toBe(0);
			
			    rerender();
			    triggerEvent('click', container.querySelector('#MAGICBUTTON'));
			
			    expect(container.querySelectorAll('.dd-item').length).toBe(3);
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should not propagate mid/right mouse buttons clicks', (done) => \{
			    const obj = \{
			      spy() \{\}
			    \};
			    const spy = spyOn(obj, 'spy');
			
			    render(
			      <div>
			        <div onClick=\{spy\} id="MAGICBUTTON">
			          test
			        </div>
			      </div>,
			      container
			    );
			
			    const event = document.createEvent('MouseEvents');
			    // Simulate right click
			    Object.defineProperty(event, 'button', \{
			      value: 2
			    \});
			
			    // If changing button for click event is not supported, then we can skip this test.
			    if (event.button === 0) \{
			      done();
			      return;
			    \}
			
			    event.initEvent('click', true, true);
			
			    expect(spy.calls.count()).toBe(0);
			
			    const node = container.querySelector('#MAGICBUTTON');
			    node.dispatchEvent(event);
			
			    setTimeout(function () \{
			      expect(spy.calls.count()).toBe(0);
			      done();
			    \}, 10);
			  \});
			
			  it('Should not fail #2', () => \{
			    const items = [
			      \{
			        icon: '#user',
			        text: 'Implementation',
			        value: 'b73ea78d-350d-f764-e429-9bebd9d8b4b3'
			      \},
			      \{
			        icon: '#reminder',
			        text: 'Issue',
			        value: '4e0a069d-899a-418a-df27-8ff5ef18d459'
			      \},
			      \{
			        icon: '#favourite',
			        text: 'LomaTaski',
			        value: 'd9a54cc9-2a16-08e3-85da-c230b5d0b121'
			      \}
			    ];
			    const value = 'b73ea78d-350d-f764-e429-9bebd9d8b4b3';
			
			    render(
			      <div>
			        <Dropdown items=\{items\} changeCallback=\{function () \{\}\} changeParams=\{\{ guid: 'foo', field: 'activityType' \}\} value=\{value\} />
			      </div>,
			      container
			    );
			
			    container.querySelector('#MAGICBUTTON').click();
			
			    render(
			      <div>
			        <Icon />
			      </div>,
			      container
			    );
			  \});
			
			  it('Should not fail #3', () => \{
			    const items = [
			      \{
			        icon: '#user',
			        text: 'Implementation',
			        value: 'b73ea78d-350d-f764-e429-9bebd9d8b4b3'
			      \},
			      \{
			        icon: '#reminder',
			        text: 'Issue',
			        value: '4e0a069d-899a-418a-df27-8ff5ef18d459'
			      \},
			      \{
			        icon: '#favourite',
			        text: 'LomaTaski',
			        value: 'd9a54cc9-2a16-08e3-85da-c230b5d0b121'
			      \}
			    ];
			    const value = 'b73ea78d-350d-f764-e429-9bebd9d8b4b3';
			
			    render(
			      <div>
			        <Dropdown items=\{items\} changeCallback=\{function () \{\}\} changeParams=\{\{ guid: 'foo', field: 'activityType' \}\} value=\{value\} />
			      </div>,
			      container
			    );
			
			    container.querySelector('#MAGICBUTTON').click();
			
			    render(
			      <div>
			        <Dropdown items=\{items\} changeCallback=\{function () \{\}\} changeParams=\{\{ guid: 'dwqwdq', field: 'activityType' \}\} value=\{value\} />
			      </div>,
			      container
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\instancenull.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\issue-1369.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			
			describe('static tree as child nodes', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should patch whole tree even when static - Github #1369', () => \{
			    let renderCounter = 0;
			
			    class Form extends Component \{
			      public handleClick = () => \{
			        this.forceUpdate();
			      \};
			
			      public static childContextTypes = \{\};
			
			      public getChildContext() \{
			        return \{\};
			      \}
			
			      public render() \{
			        const \{ children, ...restProps \} = this.props;
			        return (
			          <div \{...restProps\}>
			            <button onClick=\{this.handleClick\}>test</button>
			            \{children\}
			          </div>
			        );
			      \}
			    \}
			
			    class Test extends Component \{
			      public render() \{
			        renderCounter++;
			
			        return <div>test</div>;
			      \}
			    \}
			
			    class App extends Component \{
			      public render() \{
			        return (
			          <Form>
			            <div>
			              <div>
			                <Test />
			              </div>
			            </div>
			          </Form>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(renderCounter).toBe(1);
			
			    const btn = container.querySelector('button');
			
			    btn.click();
			
			    expect(renderCounter).toBe(2);
			
			    btn.click();
			
			    expect(renderCounter).toBe(3);
			
			    btn.click();
			
			    expect(renderCounter).toBe(4);
			
			    btn.click();
			
			    expect(renderCounter).toBe(5);
			  \});
			
			  it('Should patch whole tree even when static - Github #1369 - 2', () => \{
			    let renderCounter = 0;
			
			    class Form extends Component \{
			      public handleClick = () => \{
			        this.forceUpdate();
			      \};
			
			      public static childContextTypes = \{\};
			
			      public getChildContext() \{
			        return \{\};
			      \}
			
			      public render() \{
			        const \{ children \} = this.props;
			        return (
			          <div>
			            <button onClick=\{this.handleClick\}>test</button>
			            \{children\}
			          </div>
			        );
			      \}
			    \}
			
			    let constuctCounter = 0;
			
			    interface TestState \{
			      text: string;
			    \}
			
			    class Test extends Component<unknown, TestState> \{
			      public state: TestState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          text: 'bar'
			        \};
			
			        constuctCounter++;
			      \}
			
			      public render() \{
			        renderCounter++;
			
			        return (
			          <div id=\{\`id-\$\{renderCounter\}\`\} onClick=\{() => this.setState(\{ text: 'foo' \})\} \$HasTextChildren>
			            \{this.state.text\}
			          </div>
			        );
			      \}
			    \}
			
			    class App extends Component \{
			      public render() \{
			        const hoistedDiv = (
			          <div>
			            <Test />
			          </div>
			        );
			
			        return (
			          <Form>
			            <div>
			              <div>\{hoistedDiv\}</div>
			              <div>\{hoistedDiv\}</div>
			              <div>\{hoistedDiv\}</div>
			            </div>
			          </Form>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(renderCounter).toBe(3);
			    expect(constuctCounter).toBe(3);
			
			    const expectedHTML = \`<div><button>test</button><div><div><div><div id="id-1">bar</div></div></div><div><div><div id="id-2">bar</div></div></div><div><div><div id="id-3">bar</div></div></div></div></div>\`;
			
			    expect(container.innerHTML).toBe(expectedHTML);
			
			    const btn = container.querySelector('button');
			
			    btn.click();
			
			    expect(renderCounter).toBe(6);
			    expect(constuctCounter).toBe(3);
			
			    expect(container.innerHTML).toBe(
			      \`<div><button>test</button><div><div><div><div id="id-4">bar</div></div></div><div><div><div id="id-5">bar</div></div></div><div><div><div id="id-6">bar</div></div></div></div></div>\`
			    );
			
			    container.querySelector('#id-4').click();
			
			    expect(renderCounter).toBe(7);
			    expect(constuctCounter).toBe(3);
			
			    expect(container.innerHTML).toBe(
			      \`<div><button>test</button><div><div><div><div id="id-7">foo</div></div></div><div><div><div id="id-5">bar</div></div></div><div><div><div id="id-6">bar</div></div></div></div></div>\`
			    );
			
			    container.querySelector('#id-5').click();
			
			    expect(renderCounter).toBe(8);
			    expect(constuctCounter).toBe(3);
			
			    expect(container.innerHTML).toBe(
			      \`<div><button>test</button><div><div><div><div id="id-7">foo</div></div></div><div><div><div id="id-8">foo</div></div></div><div><div><div id="id-6">bar</div></div></div></div></div>\`
			    );
			
			    container.querySelector('#id-6').click();
			
			    expect(renderCounter).toBe(9);
			    expect(constuctCounter).toBe(3);
			
			    expect(container.innerHTML).toBe(
			      \`<div><button>test</button><div><div><div><div id="id-7">foo</div></div></div><div><div><div id="id-8">foo</div></div></div><div><div><div id="id-9">foo</div></div></div></div></div>\`
			    );
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\issue-1369.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\lifecycle.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render, rerender \} from 'inferno';
			
			describe('ComponentDidUpdate', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should be called after ref updates, Github #1374 Github#1286', () => \{
			    class App extends Component \{
			      public state = \{
			        toggled: false
			      \};
			
			      private dynamicEl: HTMLDivElement | null;
			      private staticEl: HTMLDivElement | null;
			
			      public toggleDynamicComponent = () =>
			        this.setState(\{
			          toggled: !this.state.toggled
			        \});
			
			      public renderDynamicComponent = () => (
			        <div
			          id="dynamic"
			          ref=\{(el) => \{
			            this.dynamicEl = el;
			          \}\}
			        >
			          <p>Dynamic component!</p>
			        </div>
			      );
			
			      public componentDidUpdate() \{
			        const dynamic = container.querySelector('#dynamic');
			
			        expect(this.dynamicEl).toBe(dynamic);
			        if (this.state.toggled) \{
			          expect(dynamic).not.toBeNull();
			        \} else \{
			          expect(dynamic).toBeNull();
			        \}
			
			        expect(this.staticEl).toBe(container.querySelector('#static'));
			      \}
			
			      public render() \{
			        return (
			          <div
			            id="static"
			            ref=\{(el) => \{
			              this.staticEl = el;
			            \}\}
			          >
			            \{this.state.toggled && this.renderDynamicComponent()\}
			            <button onClick=\{this.toggleDynamicComponent\}>Toggle dynamic component</button>
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    const button = container.querySelector('button');
			
			    button.click();
			    button.click();
			    button.click();
			    button.click();
			  \});
			
			  it('Should unmount refs parent first', () => \{
			    const spyer = jasmine.createSpy();
			
			    class Mounter extends Component \{
			      public componentDidMount() \{
			        spyer('child-didmount');
			      \}
			
			      public componentWillUnmount() \{
			        spyer('child-willunmount');
			      \}
			    \}
			
			    interface AppProps \{
			      child?: boolean;
			    \}
			
			    class App extends Component<AppProps> \{
			      public componentDidMount() \{
			        spyer('parent-didmount');
			      \}
			
			      public componentWillUnmount() \{
			        spyer('parent-willunmount');
			      \}
			
			      public render() \{
			        return (
			          <div
			            id="outer"
			            ref=\{(el) => \{
			              // Create new function on purpose to trigger changes
			              spyer('outer-' + (el ? el.id : null));
			            \}\}
			          >
			            <div
			              id="inner"
			              ref=\{(el) => \{
			                // Create new function on purpose to trigger changes
			                spyer('inner-' + (el ? el.id : null));
			              \}\}
			            >
			              \{this.props.child ? <Mounter /> : null\}
			            </div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(3);
			    expect(spyer.calls.argsFor(0)).toEqual(['inner-inner']);
			    expect(spyer.calls.argsFor(1)).toEqual(['outer-outer']);
			    expect(spyer.calls.argsFor(2)).toEqual(['parent-didmount']);
			
			    render(<App child=\{true\} />, container);
			
			    expect(spyer.calls.argsFor(3)).toEqual(['inner-null']);
			    expect(spyer.calls.argsFor(4)).toEqual(['outer-null']);
			    expect(spyer.calls.argsFor(5)).toEqual(['child-didmount']);
			    expect(spyer.calls.argsFor(6)).toEqual(['inner-inner']);
			    expect(spyer.calls.argsFor(7)).toEqual(['outer-outer']);
			
			    expect(spyer).toHaveBeenCalledTimes(8);
			
			    render(<App child=\{false\} />, container);
			
			    expect(spyer.calls.argsFor(8)).toEqual(['child-willunmount']);
			    expect(spyer.calls.argsFor(9)).toEqual(['inner-null']);
			    expect(spyer.calls.argsFor(10)).toEqual(['outer-null']);
			    expect(spyer.calls.argsFor(11)).toEqual(['inner-inner']);
			    expect(spyer.calls.argsFor(12)).toEqual(['outer-outer']);
			
			    expect(spyer).toHaveBeenCalledTimes(13);
			
			    render(<App child=\{true\} />, container);
			
			    expect(spyer.calls.argsFor(13)).toEqual(['inner-null']);
			    expect(spyer.calls.argsFor(14)).toEqual(['outer-null']);
			    expect(spyer.calls.argsFor(15)).toEqual(['child-didmount']);
			    expect(spyer.calls.argsFor(16)).toEqual(['inner-inner']);
			    expect(spyer.calls.argsFor(17)).toEqual(['outer-outer']);
			
			    expect(spyer).toHaveBeenCalledTimes(18);
			
			    render(null, container);
			
			    expect(spyer.calls.argsFor(18)).toEqual(['parent-willunmount']);
			    expect(spyer.calls.argsFor(19)).toEqual(['outer-null']);
			    expect(spyer.calls.argsFor(20)).toEqual(['inner-null']);
			    expect(spyer.calls.argsFor(21)).toEqual(['child-willunmount']);
			
			    expect(spyer).toHaveBeenCalledTimes(22);
			  \});
			
			  // https://jsfiddle.net/3ja27qw5/
			  it('Should unmount refs parent first - variation 2', () => \{
			    const spyer = jasmine.createSpy();
			
			    class Mounter extends Component \{
			      public componentDidMount() \{
			        spyer('child-didmount');
			      \}
			
			      public componentWillUnmount() \{
			        spyer('child-willunmount');
			      \}
			    \}
			
			    interface AppProps \{
			      child?: boolean;
			    \}
			
			    class App extends Component<AppProps> \{
			      public componentDidMount() \{
			        spyer('parent-didmount');
			      \}
			
			      public componentWillUnmount() \{
			        spyer('parent-willunmount');
			      \}
			
			      public render() \{
			        return (
			          <div
			            id="outer"
			            ref=\{(el) => \{
			              // Create new function on purpose to trigger changes
			              spyer('outer-' + (el ? el.id : null));
			            \}\}
			          >
			            <Mounter />
			            <div
			              id="inner"
			              ref=\{(el) => \{
			                // Create new function on purpose to trigger changes
			                spyer('inner-' + (el ? el.id : null));
			              \}\}
			            >
			              \{this.props.child ? <Mounter /> : null\}
			            </div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(spyer).toHaveBeenCalledTimes(4);
			    expect(spyer.calls.argsFor(0)).toEqual(['child-didmount']);
			    expect(spyer.calls.argsFor(1)).toEqual(['inner-inner']);
			    expect(spyer.calls.argsFor(2)).toEqual(['outer-outer']);
			    expect(spyer.calls.argsFor(3)).toEqual(['parent-didmount']);
			
			    render(<App child=\{true\} />, container);
			
			    expect(spyer.calls.argsFor(4)).toEqual(['inner-null']);
			    expect(spyer.calls.argsFor(5)).toEqual(['outer-null']);
			    expect(spyer.calls.argsFor(6)).toEqual(['child-didmount']);
			    expect(spyer.calls.argsFor(7)).toEqual(['inner-inner']);
			    expect(spyer.calls.argsFor(8)).toEqual(['outer-outer']);
			
			    render(null, container);
			
			    expect(spyer.calls.argsFor(9)).toEqual(['parent-willunmount']);
			    expect(spyer.calls.argsFor(10)).toEqual(['outer-null']);
			    expect(spyer.calls.argsFor(11)).toEqual(['child-willunmount']);
			    expect(spyer.calls.argsFor(12)).toEqual(['inner-null']);
			    expect(spyer.calls.argsFor(13)).toEqual(['child-willunmount']);
			
			    expect(spyer).toHaveBeenCalledTimes(14);
			  \});
			
			  it('Should not call setState callback if another component triggers setState during other tree mount', () => \{
			    // This is only to simplify whats going on in real application
			    const testHack = \{
			      callback: () => \{\}
			    \};
			
			    let callbackCalled = 0;
			    let setState1Called = 0;
			    let setState2Called = 0;
			
			    class Another extends Component \{
			      constructor(props, context) \{
			        super(props, context);
			
			        testHack.callback = () => \{
			          callbackCalled++;
			          this.setState(\{ a: 112 \});
			        \};
			      \}
			
			      public render() \{
			        return <div>A</div>;
			      \}
			    \}
			
			    class TesterOne extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          foo: 'test'
			        \};
			      \}
			
			      public componentWillMount() \{
			        this.setState(
			          \{
			            foo: 'bar'
			          \},
			          function () \{
			            setState1Called++;
			            expect(this.state.foo).toBe('bar');
			          \}
			        );
			
			        testHack.callback();
			      \}
			
			      public render() \{
			        return <div>Tester One</div>;
			      \}
			    \}
			
			    interface OutsiderState \{
			      bool?: boolean;
			    \}
			
			    class Outsider extends Component<unknown, OutsiderState> \{
			      public state: OutsiderState;
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          bool: false
			        \};
			
			        this._handleClick = this._handleClick.bind(this);
			      \}
			
			      public _handleClick() \{
			        this.setState(
			          \{
			            bool: true
			          \},
			          function () \{
			            setState2Called++;
			            expect(this.state.bool).toBe(true);
			          \}
			        );
			      \}
			
			      public render() \{
			        return (
			          <div id="tester" onClick=\{this._handleClick\}>
			            \{this.state.bool ? <TesterOne /> : <span />\}
			          </div>
			        );
			      \}
			    \}
			
			    class App extends Component \{
			      public render() \{
			        return (
			          <div>
			            <Outsider />
			            <Another />
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(callbackCalled).toBe(0);
			    expect(setState1Called).toBe(0);
			    expect(setState2Called).toBe(0);
			
			    expect(container.innerHTML).toBe('<div><div id="tester"><span></span></div><div>A</div></div>');
			
			    container.querySelector('#tester').click();
			
			    expect(callbackCalled).toBe(1);
			    expect(setState1Called).toBe(1);
			    expect(setState2Called).toBe(1);
			
			    expect(container.innerHTML).toBe('<div><div id="tester"><div>Tester One</div></div><div>A</div></div>');
			  \});
			
			  it('Should not fail if mounting subtree propagates callback to parent which renders again', () => \{
			    // This is only to simplify whats going on in real application
			    const testHack = \{
			      callback: () => \{\}
			    \};
			
			    let callbackCalled = 0;
			    let setState1Called = 0;
			    let setState2Called = 0;
			    let mounterCounter = 0;
			
			    interface AnotherProps \{
			      a: number;
			    \}
			
			    class Another extends Component<AnotherProps> \{
			      public render() \{
			        return <div>A \{this.props.a\}</div>;
			      \}
			    \}
			
			    interface TesterOneProps \{
			      a: number;
			    \}
			
			    class TesterOne extends Component<TesterOneProps> \{
			      constructor(props) \{
			        super(props);
			
			        mounterCounter++;
			
			        this.state = \{
			          foo: 'test'
			        \};
			      \}
			
			      public componentWillMount() \{
			        this.setState(
			          \{
			            foo: 'bar'
			          \},
			          function () \{
			            setState1Called++;
			            expect(this.state.foo).toBe('bar');
			          \}
			        );
			
			        testHack.callback();
			      \}
			
			      public render() \{
			        return <div>Tester One \{this.props.a\}</div>;
			      \}
			    \}
			
			    interface OutsiderState \{
			      bool?: boolean;
			    \}
			
			    interface OutsiderProps \{
			      a: number;
			    \}
			
			    class Outsider extends Component<OutsiderProps, OutsiderState> \{
			      public state: OutsiderState;
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          bool: false
			        \};
			
			        this._handleClick = this._handleClick.bind(this);
			      \}
			
			      public _handleClick() \{
			        this.setState(
			          \{
			            bool: true
			          \},
			          function () \{
			            setState2Called++;
			            expect(this.state.bool).toBe(true);
			          \}
			        );
			      \}
			
			      public render() \{
			        return (
			          <div id="tester" onClick=\{this._handleClick\}>
			            \{this.state.bool ? <TesterOne a=\{this.props.a\} /> : <span>\{this.props.a\}</span>\}
			          </div>
			        );
			      \}
			    \}
			
			    interface AppState \{
			      a: number;
			    \}
			
			    class App extends Component<unknown, AppState> \{
			      public state: AppState;
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          a: 0
			        \};
			
			        testHack.callback = () => \{
			          callbackCalled++;
			          this.setState(\{ a: 112 \});
			        \};
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Outsider a=\{this.state.a\} />
			            <Another a=\{this.state.a\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(mounterCounter).toBe(0);
			    expect(callbackCalled).toBe(0);
			    expect(setState1Called).toBe(0);
			    expect(setState2Called).toBe(0);
			
			    expect(container.innerHTML).toBe('<div><div id="tester"><span>0</span></div><div>A 0</div></div>');
			
			    container.querySelector('#tester').click();
			
			    rerender();
			
			    expect(mounterCounter).toBe(1);
			    expect(callbackCalled).toBe(1);
			    expect(setState1Called).toBe(1);
			    expect(setState2Called).toBe(1);
			
			    expect(container.innerHTML).toBe('<div><div id="tester"><div>Tester One 112</div></div><div>A 112</div></div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\lifecycle.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\link.spec.tsx', () => {
        const sourceCode = `
			/* tslint:disable:no-console */
			import \{ render \} from 'inferno';
			
			describe('Links', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('javascript href', function () \{
			    it('Should log warning when rendering link starting with javascript::', function () \{
			      const consoleSpy = spyOn(console, 'error');
			
			      render(<a href="javascript:foobar">test</a>, container);
			
			      expect(consoleSpy).toHaveBeenCalledTimes(1);
			      expect(consoleSpy).toHaveBeenCalledWith(
			        'Rendering links with javascript: URLs is not recommended. Use event handlers instead if you can. Inferno was passed "javascript:foobar".'
			      );
			      expect(container.innerHTML).toEqual('<a href="javascript:foobar">test</a>');
			    \});
			
			    it('Should allow patching link to null', function () \{
			      const consoleSpy = spyOn(console, 'error');
			
			      render(<a href="javascript:foobar">test</a>, container);
			
			      expect(consoleSpy).toHaveBeenCalledTimes(1);
			
			      render(<a>test</a>, container);
			
			      expect(consoleSpy).toHaveBeenCalledTimes(1);
			
			      expect(container.innerHTML).toEqual('<a>test</a>');
			    \});
			
			    it('Should not log warning when rendering regular link', function () \{
			      const consoleSpy = spyOn(console, 'error');
			
			      render(<a href="https://github.com/infernojs/inferno">test</a>, container);
			
			      expect(consoleSpy).toHaveBeenCalledTimes(0);
			      expect(container.innerHTML).toEqual('<a href="https://github.com/infernojs/inferno">test</a>');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\link.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\linkEvent.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, linkEvent, render \} from 'inferno';
			
			describe('linkEvent', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('linkEvent on a button (onClick)', () => \{
			    let test;
			
			    function handleOnClick(props) \{
			      test = props.test;
			    \}
			
			    function FunctionalComponent(props) \{
			      return <button onClick=\{linkEvent(props, handleOnClick)\} />;
			    \}
			
			    interface StatefulComponentProps \{
			      test?: string;
			    \}
			
			    class StatefulComponent extends Component<StatefulComponentProps> \{
			      public render() \{
			        return <button onClick=\{linkEvent(this.props, handleOnClick)\} />;
			      \}
			    \}
			
			    it('should work correctly for functional components', () => \{
			      render(<FunctionalComponent test="123" />, container);
			      container.querySelector('button').click();
			      expect(test).toBe('123');
			    \});
			
			    it('should work correctly for stateful components', () => \{
			      render(<StatefulComponent test="456" />, container);
			      container.querySelector('button').click();
			      expect(test).toBe('456');
			    \});
			
			    it('Should not fail when given event is invalid', () => \{
			      // @ts-expect-error
			      render(<div onClick=\{linkEvent(\{ number: 1 \}, null)\} />, container);
			      container.firstChild.click();
			      // @ts-expect-error
			      render(<div onClick=\{linkEvent(\{ number: 1 \}, undefined)\} />, container);
			      container.firstChild.click();
			      // @ts-expect-error
			      render(<div onClick=\{linkEvent(\{ number: 1 \}, false)\} />, container);
			      container.firstChild.click();
			      // @ts-expect-error
			      render(<div onClick=\{linkEvent(\{ number: 1 \}, true)\} />, container);
			      container.firstChild.click();
			      // @ts-expect-error
			      render(<div onClick=\{linkEvent(\{ number: 1 \}, \{\})\} />, container);
			      container.firstChild.click();
			    \});
			  \});
			
			  describe('linkEvent on a button (onclick) - no delegation', () => \{
			    let test;
			
			    function handleOnClick(props) \{
			      test = props.test;
			    \}
			
			    function FunctionalComponent(props) \{
			      return <button onclick=\{linkEvent(props, handleOnClick)\} />;
			    \}
			
			    class StatefulComponent extends Component \{
			      public render() \{
			        return <button onclick=\{linkEvent(this.props, handleOnClick)\} />;
			      \}
			    \}
			
			    it('should work correctly for functional components', () => \{
			      render(<FunctionalComponent test="123" />, container);
			      container.querySelector('button').click();
			      expect(test).toBe('123');
			    \});
			
			    it('should work correctly for stateful components', () => \{
			      // @ts-expect-error
			      render(<StatefulComponent test="456" />, container);
			      container.querySelector('button').click();
			      expect(test).toBe('456');
			    \});
			  \});
			
			  describe('linkEvent on a input (onInput)', () => \{
			    let test;
			    let event;
			
			    function simulateInput(elm) \{
			      if (typeof Event !== 'undefined') \{
			        const newEvent = document.createEvent('Event');
			        newEvent.initEvent('input', true, true);
			
			        elm.dispatchEvent(newEvent);
			      \} else \{
			        elm.oninput(\{
			          target: elm
			        \});
			      \}
			    \}
			
			    function handleOnInput(props, e) \{
			      test = props.test;
			      event = e;
			    \}
			
			    function FunctionalComponent(props) \{
			      return <input type="text" onInput=\{linkEvent(props, handleOnInput)\} value="" />;
			    \}
			
			    interface StatelessComponentProps \{
			      test?: string;
			    \}
			
			    class StatefulComponent extends Component<StatelessComponentProps> \{
			      public render() \{
			        return <input type="text" onInput=\{linkEvent(this.props, handleOnInput)\} value="" />;
			      \}
			    \}
			
			    it('should work correctly for functional components', () => \{
			      render(<FunctionalComponent test="123" />, container);
			      simulateInput(container.querySelector('input'));
			      expect(test).toBe('123');
			      expect(event.target.nodeName).toBe('INPUT');
			    \});
			
			    it('should work correctly for stateful components', () => \{
			      render(<StatefulComponent test="456" />, container);
			      simulateInput(container.querySelector('input'));
			      expect(test).toBe('456');
			      expect(event.target.nodeName).toBe('INPUT');
			    \});
			  \});
			
			  describe('linkEvent on a input (onfocus and onblur) - no delegation', () => \{
			    let isFocus;
			    let isBlur;
			
			    function handleOnFocus(id) \{
			      isFocus = id;
			    \}
			
			    function handleOnBlur(id) \{
			      isBlur = id;
			    \}
			
			    function FunctionalComponent() \{
			      return (
			        <div>
			          <input onfocus=\{linkEvent('1234', handleOnFocus)\} onblur=\{linkEvent('4321', handleOnBlur)\} />
			        </div>
			      );
			    \}
			
			    class StatefulComponent extends Component \{
			      public render() \{
			        return (
			          <div>
			            <input onfocus=\{linkEvent('1234', handleOnFocus)\} onblur=\{linkEvent('4321', handleOnBlur)\} />
			          </div>
			        );
			      \}
			    \}
			
			    function simulateFocus(elm) \{
			      if (typeof Event !== 'undefined') \{
			        const newEvent = document.createEvent('UIEvent');
			        newEvent.initEvent('focus', true, true);
			
			        elm.dispatchEvent(newEvent);
			      \} else \{
			        elm.focus();
			      \}
			    \}
			
			    function simulateBlur(elm) \{
			      if (typeof Event !== 'undefined') \{
			        const newEvent = document.createEvent('UIEvent');
			        newEvent.initEvent('blur', true, true);
			
			        elm.dispatchEvent(newEvent);
			      \} else \{
			        elm.blur();
			      \}
			    \}
			
			    it('should work correctly for functional components', (done) => \{
			      render(<FunctionalComponent />, container);
			      const input = container.querySelector('input');
			      simulateFocus(input);
			      setTimeout(() => \{
			        simulateBlur(input);
			        setTimeout(() => \{
			          expect(isFocus).toBe('1234');
			          expect(isBlur).toBe('4321');
			          done();
			        \}, 25);
			      \}, 25);
			    \});
			
			    it('should work correctly for stateful components', (done) => \{
			      render(<StatefulComponent />, container);
			      const input = container.querySelector('input');
			      simulateFocus(input);
			      setTimeout(() => \{
			        simulateBlur(input);
			        setTimeout(() => \{
			          expect(isFocus).toBe('1234');
			          expect(isBlur).toBe('4321');
			          done();
			        \}, 25);
			      \}, 25);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\linkEvent.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\mixedFormElements.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			
			describe('HTML Form Elements', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('Textarea - defaultValue', () => \{
			    it('Should have value as defaultValue when actual value is null', () => \{
			      render(<textarea defaultValue="Hey Inferno" value=\{null\} />, container);
			      expect(container.firstChild.value).toBe('Hey Inferno');
			      expect(container.firstChild.defaultValue).toBe('Hey Inferno');
			    \});
			
			    it('Should have value as defaultValue when actual value is undefined', () => \{
			      render(<textarea defaultValue="Hey Inferno" />, container);
			      expect(container.firstChild.value).toBe('Hey Inferno');
			      expect(container.firstChild.defaultValue).toBe('Hey Inferno');
			    \});
			
			    it('Should not use defaultValue when actual value is empty string', () => \{
			      render(<textarea defaultValue="Hey Inferno" value="" />, container);
			      expect(container.firstChild.value).toBe('');
			      expect(container.firstChild.defaultValue).toBe('');
			    \});
			
			    it('Should not use defaultValue when actual value is number', () => \{
			      render(<textarea defaultValue="Hey Inferno" value=\{1\} />, container);
			      expect(container.firstChild.value).toBe('1');
			      expect(container.firstChild.defaultValue).toBe('1'); // As Per React, its 1 and not Hey Inferno
			    \});
			
			    it('Should not use defaultValue when actual value is object', () => \{
			      // @ts-expect-error
			      render(<textarea defaultValue="Hey Inferno" value=\{\{ a: 1 \}\} />, container);
			      expect(container.firstChild.value).toBe('[object Object]');
			      expect(container.firstChild.defaultValue).toBe('[object Object]');
			    \});
			
			    it('Should have false as string when given as defaultValue', () => \{
			      // @ts-expect-error
			      render(<textarea defaultValue=\{false\} />, container);
			      expect(container.firstChild.value).toBe('false');
			      expect(container.firstChild.defaultValue).toBe('false');
			    \});
			  \});
			
			  describe('Input - defaultValue', () => \{
			    it('Should have value as defaultValue when actual value is null', () => \{
			      render(<input defaultValue="Hey Inferno" value=\{null\} />, container);
			
			      expect(container.firstChild.value).toBe('Hey Inferno');
			      expect(container.firstChild.defaultValue).toBe('Hey Inferno');
			    \});
			
			    it('Should have value as defaultValue when actual value is undefined', () => \{
			      render(<input defaultValue="Hey Inferno" />, container);
			
			      expect(container.firstChild.value).toBe('Hey Inferno');
			      expect(container.firstChild.defaultValue).toBe('Hey Inferno');
			    \});
			
			    it('Should not use defaultValue when actual value is empty string', () => \{
			      render(<input defaultValue="Hey Inferno" value="" />, container);
			      expect(container.firstChild.value).toBe('');
			    \});
			
			    it('Should not use defaultValue when actual value is number', () => \{
			      render(<input defaultValue="Hey Inferno" value=\{1\} />, container);
			      expect(container.firstChild.value).toBe('1');
			      expect(container.firstChild.defaultValue).toBe('1');
			    \});
			
			    it('Should not use defaultValue when actual value is object', () => \{
			      // @ts-expect-error
			      render(<input defaultValue="Hey Inferno" value=\{\{ a: 1 \}\} />, container);
			      expect(container.firstChild.value).toBe('[object Object]');
			      expect(container.firstChild.defaultValue).toBe('[object Object]');
			    \});
			
			    it('Should be possible to create input with type color', () => \{
			      render(<input type="color" />, container);
			      expect(container.firstChild.getAttribute('type')).toBe('color');
			    \});
			
			    it('Should be possible to create input with type range', () => \{
			      function change() \{\}
			
			      render(<input min=\{0\} max=\{255\} value=\{75\} onChange=\{change\} type="range" />, container);
			      expect(container.firstChild.getAttribute('type')).toBe('range');
			      expect(container.firstChild.value).toBe('75');
			
			      render(<input min=\{0\} max=\{255\} value=\{11\} onChange=\{change\} type="range" />, container);
			
			      const event = document.createEvent('Event');
			      event.initEvent('input', true, true);
			
			      container.firstChild.dispatchEvent(event);
			
			      expect(container.firstChild.getAttribute('type')).toBe('range');
			      expect(container.firstChild.value).toBe('11');
			    \});
			  \});
			
			  describe('After external change', () => \{
			    it('Should update input check property', () => \{
			      render(<input type="checkbox" checked=\{true\} />, container);
			      expect(container.innerHTML).toBe('<input type="checkbox">');
			      expect(container.firstChild.checked).toBe(true);
			
			      //
			      // Exernal change verification
			      //
			
			      const input = container.querySelector('input');
			      input.checked = false;
			      expect(container.innerHTML).toBe('<input type="checkbox">');
			      expect(container.firstChild.checked).toBe(false);
			
			      //
			      // New Render
			      //
			
			      render(<input type="checkbox" checked=\{true\} />, container);
			      expect(container.innerHTML).toBe('<input type="checkbox">');
			      expect(container.firstChild.checked).toBe(true);
			    \});
			
			    it('Should update textarea value', () => \{
			      render(<textarea value="Hey People" />, container);
			      expect(container.firstChild.value).toBe('Hey People');
			      expect(container.firstChild.defaultValue).toBe('Hey People');
			
			      //
			      // Exernal change verification
			      //
			
			      const input = container.querySelector('textarea');
			      input.value = 'Inferno is cool';
			      expect(container.innerHTML).toBe(input.outerHTML);
			      expect(container.firstChild.value).toBe('Inferno is cool');
			
			      //
			      // New Render
			      //
			
			      render(<textarea value="Hey People" />, container);
			      expect(container.firstChild.value).toBe('Hey People');
			      expect(container.firstChild.defaultValue).toBe('Hey People');
			
			      //
			      // New Render, new value
			      //
			
			      render(<textarea value="Hey People again" />, container);
			      expect(container.firstChild.value).toBe('Hey People again');
			      expect(container.firstChild.defaultValue).toBe('Hey People again');
			    \});
			
			    it('Should update text input value', () => \{
			      render(<input type="text" value="Hey People" />, container);
			      expect(container.firstChild.value).toBe('Hey People');
			
			      //
			      // Exernal change verification
			      //
			
			      const input = container.querySelector('input');
			      input.value = 'Inferno is cool';
			      expect(container.firstChild.value).toBe('Inferno is cool');
			
			      //
			      // New Render
			      //
			
			      render(<input type="text" value="Hey People" />, container);
			      expect(container.firstChild.value).toBe('Hey People');
			
			      //
			      // New Render, new value
			      //
			
			      render(<input type="text" value="Hey People again" />, container);
			      expect(container.firstChild.value).toBe('Hey People again');
			    \});
			
			    it('Should update radio button', () => \{
			      render(
			        <div>
			          <input type="radio" name="gender" value="male" checked /> Male
			          <input type="radio" name="gender" value="female" /> Female
			          <input type="radio" name="gender" value="other" /> Other
			        </div>,
			        container
			      );
			
			      expect(container.firstChild.firstChild.value).toBe('male');
			      expect(container.firstChild.firstChild.checked).toBe(true);
			
			      //
			      // Exernal change verification
			      //
			
			      const radiobutton = container.querySelector('input');
			      radiobutton.checked = false;
			      expect(container.firstChild.firstChild.checked).toBe(false);
			
			      //
			      // New Render
			      //
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="male" checked /> Male
			          <input type="radio" name="gender" value="female" /> Female
			          <input type="radio" name="gender" value="other" /> Other
			        </div>,
			        container
			      );
			
			      expect(container.firstChild.firstChild.value).toBe('male');
			      expect(container.firstChild.firstChild.checked).toBe(true);
			
			      //
			      // New Render, new value
			      //
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="male" /> Male
			          <input type="radio" name="gender" checked value="female" /> Female
			          <input type="radio" name="gender" value="other" /> Other
			        </div>,
			        container
			      );
			
			      expect(container.firstChild.firstChild.value).toBe('male');
			      expect(container.firstChild.firstChild.checked).toBe(false);
			      expect(container.firstChild.children[1].value).toBe('female');
			      expect(container.firstChild.children[1].checked).toBe(true);
			    \});
			
			    it('Should not trigger onClick twice when using synthetic onClick on radio', () => \{
			      const spy1 = jasmine.createSpy('spy');
			      const spy2 = jasmine.createSpy('spy');
			      const spy3 = jasmine.createSpy('spy');
			
			      render(
			        <div>
			          <input onClick=\{spy1\} type="radio" name="gender" value="male" />
			          <input onClick=\{spy2\} type="radio" name="gender" value="female" />
			          <input onClick=\{spy3\} type="radio" id="test" name="gender" value="other" />
			        </div>,
			        container
			      );
			
			      //
			      // Exernal change verification
			      //
			
			      let radiobutton = container.querySelector('#test');
			      radiobutton.click();
			      expect(radiobutton.checked).toBe(true);
			
			      expect(spy1.calls.count()).toBe(0);
			      expect(spy2.calls.count()).toBe(0);
			      expect(spy3.calls.count()).toBe(1);
			
			      //
			      // New Render
			      //
			
			      render(
			        <div>
			          <input onClick=\{spy1\} type="radio" name="gender" value="male" />
			          <input onClick=\{spy2\} type="radio" name="gender" value="female" />
			          <input onClick=\{spy3\} type="radio" name="gender" value="other" />
			        </div>,
			        container
			      );
			
			      expect(spy1.calls.count()).toBe(0);
			      expect(spy2.calls.count()).toBe(0);
			      expect(spy3.calls.count()).toBe(1);
			
			      //
			      // New Render, new value
			      //
			
			      render(
			        <div>
			          <input onClick=\{spy1\} type="radio" name="gender" value="male" />
			          <input onClick=\{spy2\} type="radio" name="gender" value="female" />
			          <input onClick=\{spy3\} type="radio" name="gender" value="other" />
			        </div>,
			        container
			      );
			
			      expect(spy1.calls.count()).toBe(0);
			      expect(spy2.calls.count()).toBe(0);
			      expect(spy3.calls.count()).toBe(1);
			
			      render(
			        <div>
			          <input onClick=\{spy1\} type="radio" id="test" name="gender" value="male" />
			          <input onClick=\{spy2\} type="radio" name="gender" value="female" />
			          <input onClick=\{spy3\} type="radio" name="gender" value="other" />
			        </div>,
			        container
			      );
			
			      expect(spy1.calls.count()).toBe(0);
			      expect(spy2.calls.count()).toBe(0);
			      expect(spy3.calls.count()).toBe(1);
			
			      radiobutton = container.querySelector('#test');
			
			      radiobutton.click();
			
			      expect(spy1.calls.count()).toBe(1);
			      expect(spy2.calls.count()).toBe(0);
			      expect(spy3.calls.count()).toBe(1);
			
			      render(
			        <div>
			          <input onClick=\{spy1\} type="radio" id="test" name="gender" checked=\{true\} value="male" />
			          <input onClick=\{spy2\} type="radio" name="gender" checked=\{false\} value="female" />
			          <input onClick=\{spy3\} type="radio" name="gender" checked=\{false\} value="other" />
			        </div>,
			        container
			      );
			
			      const node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(true);
			      expect(node.childNodes[1].checked).toBe(false);
			      expect(node.childNodes[2].checked).toBe(false);
			    \});
			
			    it('Should change others radio inputs should have single one checked', () => \{
			      render(
			        <div>
			          <input type="radio" name="gender" value="male" checked=\{false\} />
			          <input type="radio" name="gender" value="female" checked=\{true\} />
			          <input type="radio" id="test" name="gender" value="other" checked=\{false\} />
			        </div>,
			        container
			      );
			
			      let node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(false);
			      expect(node.childNodes[1].checked).toBe(true);
			      expect(node.childNodes[2].checked).toBe(false);
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="male" checked=\{true\} />
			          <input type="radio" name="gender" value="female" checked=\{false\} />
			          <input type="radio" id="test" name="gender" value="other" checked=\{false\} />
			        </div>,
			        container
			      );
			
			      node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(true);
			      expect(node.childNodes[1].checked).toBe(false);
			      expect(node.childNodes[2].checked).toBe(false);
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="female" checked=\{false\} />
			          <input type="radio" id="test" name="gender" value="other" checked=\{false\} />
			        </div>,
			        container
			      );
			
			      node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(false);
			      expect(node.childNodes[1].checked).toBe(false);
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="female" checked=\{false\} />
			          <input type="radio" id="test" name="gender" value="other" checked=\{true\} />
			        </div>,
			        container
			      );
			
			      node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(false);
			      expect(node.childNodes[1].checked).toBe(true);
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="female" checked=\{false\} />
			          <input type="radio" id="test" name="gender" value="other" checked=\{true\} />
			          <input type="radio" name="gender" value="female" checked=\{false\} />
			          <input type="radio" name="gender" value="dqw" checked=\{false\} />
			        </div>,
			        container
			      );
			
			      node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(false);
			      expect(node.childNodes[1].checked).toBe(true);
			      expect(node.childNodes[2].checked).toBe(false);
			      expect(node.childNodes[3].checked).toBe(false);
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="female" checked=\{false\} />
			        </div>,
			        container
			      );
			
			      node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(false);
			
			      render(
			        <div>
			          <input type="radio" name="gender" value="female" checked=\{true\} />
			        </div>,
			        container
			      );
			
			      node = container.firstChild;
			
			      expect(node.childNodes[0].checked).toBe(true);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\mixedFormElements.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(19)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\newlifecycle.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render, rerender \} from 'inferno';
			
			describe('Lifecycle methods', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should call nested new lifecycle methods in the right order', () => \{
			    let updateOuterState;
			    let updateInnerState;
			    let forceUpdateOuter;
			    let forceUpdateInner;
			
			    let log: string[];
			    const logger = function (msg) \{
			      return function () \{
			        // return true for shouldComponentUpdate
			        log.push(msg);
			        return true;
			      \};
			    \};
			
			    interface OuterState \{
			      value: number;
			    \}
			
			    interface OuterProps \{
			      value?: number;
			      x: number;
			    \}
			
			    class Outer extends Component<OuterProps, OuterState> \{
			      public state: OuterState;
			
			      public static getDerivedStateFromProps() \{
			        log.push('outer getDerivedStateFromProps');
			        return null;
			      \}
			
			      constructor() \{
			        super();
			        log.push('outer constructor');
			
			        this.state = \{ value: 0 \};
			        forceUpdateOuter = () => this.forceUpdate();
			        updateOuterState = () =>
			          this.setState(\{
			            value: (this.state.value + 1) % 2
			          \});
			      \}
			
			      public render() \{
			        log.push('outer render');
			        return (
			          <div>
			            <Inner x=\{this.props.x\} outerValue=\{this.state.value\} />
			          </div>
			        );
			      \}
			    \}
			
			    Outer.prototype.componentDidMount = logger('outer componentDidMount');
			    Outer.prototype.shouldComponentUpdate = logger('outer shouldComponentUpdate');
			    Outer.prototype.getSnapshotBeforeUpdate = logger('outer getSnapshotBeforeUpdate');
			    Outer.prototype.componentDidUpdate = logger('outer componentDidUpdate');
			    Outer.prototype.componentWillUnmount = logger('outer componentWillUnmount');
			
			    interface InnerProps \{
			      x: number;
			      outerValue: number;
			    \}
			
			    interface InnerState \{
			      value: number;
			    \}
			
			    class Inner extends Component<InnerProps, InnerState> \{
			      public state: InnerState;
			
			      public static getDerivedStateFromProps() \{
			        log.push('inner getDerivedStateFromProps');
			        return null;
			      \}
			
			      constructor() \{
			        super();
			        log.push('inner constructor');
			
			        this.state = \{ value: 0 \};
			        forceUpdateInner = () => this.forceUpdate();
			        updateInnerState = () =>
			          this.setState(\{
			            value: (this.state.value + 1) % 2
			          \});
			      \}
			
			      public render() \{
			        log.push('inner render');
			        return (
			          <span>
			            \{this.props.x\} \{this.props.outerValue\} \{this.state.value\}
			          </span>
			        );
			      \}
			    \}
			
			    Inner.prototype.componentDidMount = logger('inner componentDidMount');
			    Inner.prototype.shouldComponentUpdate = logger('inner shouldComponentUpdate');
			    Inner.prototype.getSnapshotBeforeUpdate = logger('inner getSnapshotBeforeUpdate');
			    Inner.prototype.componentDidUpdate = logger('inner componentDidUpdate');
			    Inner.prototype.componentWillUnmount = logger('inner componentWillUnmount');
			
			    // Constructor & mounting
			    log = [];
			    render(<Outer x=\{1\} />, container);
			    expect(log).toEqual([
			      'outer constructor',
			      'outer getDerivedStateFromProps',
			      'outer render',
			      'inner constructor',
			      'inner getDerivedStateFromProps',
			      'inner render',
			      'inner componentDidMount',
			      'outer componentDidMount'
			    ]);
			
			    // Outer & Inner props update
			    log = [];
			    render(<Outer x=\{2\} />, container);
			    // Note: we differ from react here in that we apply changes to the dom
			    // as we find them while diffing. React on the other hand separates this
			    // into specific phases, meaning changes to the dom are only flushed
			    // once the whole diff-phase is complete. This is why
			    // "outer getSnapshotBeforeUpdate" is called just before the "inner" hooks.
			    // For react this call would be right before "outer componentDidUpdate"
			    expect(log).toEqual([
			      'outer getDerivedStateFromProps',
			      'outer shouldComponentUpdate',
			      'outer render',
			      'outer getSnapshotBeforeUpdate',
			      'inner getDerivedStateFromProps',
			      'inner shouldComponentUpdate',
			      'inner render',
			      'inner getSnapshotBeforeUpdate',
			      'inner componentDidUpdate',
			      'outer componentDidUpdate'
			    ]);
			
			    // Outer state update & Inner props update
			    log = [];
			    updateOuterState();
			    rerender();
			    expect(log).toEqual([
			      'outer getDerivedStateFromProps',
			      'outer shouldComponentUpdate',
			      'outer render',
			      'outer getSnapshotBeforeUpdate',
			      'inner getDerivedStateFromProps',
			      'inner shouldComponentUpdate',
			      'inner render',
			      'inner getSnapshotBeforeUpdate',
			      'inner componentDidUpdate',
			      'outer componentDidUpdate'
			    ]);
			
			    // Inner state update
			    log = [];
			    updateInnerState();
			    rerender();
			    expect(log).toEqual([
			      'inner getDerivedStateFromProps',
			      'inner shouldComponentUpdate',
			      'inner render',
			      'inner getSnapshotBeforeUpdate',
			      'inner componentDidUpdate'
			    ]);
			
			    // Force update Outer
			    log = [];
			    forceUpdateOuter();
			    rerender();
			    expect(log).toEqual([
			      'outer getDerivedStateFromProps',
			      'outer render',
			      'outer getSnapshotBeforeUpdate',
			      'inner getDerivedStateFromProps',
			      'inner shouldComponentUpdate',
			      'inner render',
			      'inner getSnapshotBeforeUpdate',
			      'inner componentDidUpdate',
			      'outer componentDidUpdate'
			    ]);
			
			    // Force update Inner
			    log = [];
			    forceUpdateInner();
			    rerender();
			    expect(log).toEqual(['inner getDerivedStateFromProps', 'inner render', 'inner getSnapshotBeforeUpdate', 'inner componentDidUpdate']);
			
			    // Unmounting Outer & Inner
			    log = [];
			    render(<table />, container);
			    expect(log).toEqual(['outer componentWillUnmount', 'inner componentWillUnmount']);
			  \});
			
			  describe('static getDerivedStateFromProps', () => \{
			    it('should set initial state with value returned from getDerivedStateFromProps', () => \{
			      interface FooState \{
			        bar: string;
			        foo: string;
			      \}
			
			      class Foo extends Component<\{ foo: string \}, FooState> \{
			        // @ts-ignore automatic init detection not working with getDerivedStateFromProps
			        public state: FooState;
			
			        public static getDerivedStateFromProps(nextProps) \{
			          return \{
			            bar: 'bar',
			            foo: nextProps.foo
			          \};
			        \}
			
			        public render() \{
			          return <div className=\{\`\$\{this.state.foo\} \$\{this.state.bar\}\`\} />;
			        \}
			      \}
			
			      render(<Foo foo="foo" />, container);
			      expect(container.firstChild.className).toEqual('foo bar');
			    \});
			
			    it('should update initial state with value returned from getDerivedStateFromProps', () => \{
			      interface FooState \{
			        bar: string;
			        foo: string;
			      \}
			      class Foo extends Component<unknown, FooState> \{
			        public state: FooState;
			
			        constructor(props, context) \{
			          super(props, context);
			          this.state = \{
			            bar: 'bar',
			            foo: 'foo'
			          \};
			        \}
			
			        public static getDerivedStateFromProps(_nextProps, prevState) \{
			          return \{
			            foo: \`not-\$\{prevState.foo\}\`
			          \};
			        \}
			
			        public render() \{
			          return <div className=\{\`\$\{this.state.foo\} \$\{this.state.bar\}\`\} />;
			        \}
			      \}
			
			      render(<Foo />, container);
			      expect(container.firstChild.className).toEqual('not-foo bar');
			    \});
			
			    it("should update the instance's state with the value returned from getDerivedStateFromProps when props change", () => \{
			      interface FooState \{
			        value: string;
			      \}
			
			      interface FooProps \{
			        update: boolean;
			      \}
			
			      class Foo extends Component<FooProps, FooState> \{
			        public state: FooState;
			        constructor(props, context) \{
			          super(props, context);
			          this.state = \{
			            value: 'initial'
			          \};
			        \}
			
			        public static getDerivedStateFromProps(nextProps) \{
			          if (nextProps.update) \{
			            return \{
			              value: 'updated'
			            \};
			          \}
			
			          return null;
			        \}
			
			        public componentDidMount() \{\}
			
			        public componentDidUpdate() \{\}
			
			        public render() \{
			          return <div className=\{this.state.value\} />;
			        \}
			      \}
			
			      const derivedSpy = spyOn(Foo, 'getDerivedStateFromProps').and.callThrough();
			      const didMountSpy = spyOn(Foo.prototype, 'componentDidMount');
			      const didUpdateSpy = spyOn(Foo.prototype, 'componentDidUpdate');
			
			      render(<Foo update=\{false\} />, container);
			      expect(container.firstChild.className).toEqual('initial');
			      expect(derivedSpy.calls.count()).toBe(1);
			      expect(didMountSpy.calls.count()).toBe(1); // verify mount occurred
			      expect(didUpdateSpy.calls.count()).toBe(0);
			
			      render(<Foo update=\{true\} />, container);
			      expect(container.firstChild.className).toEqual('updated');
			      expect(derivedSpy.calls.count()).toBe(2);
			      expect(didMountSpy.calls.count()).toBe(1);
			      expect(didUpdateSpy.calls.count()).toBe(1); // verify update occurred
			    \});
			
			    it("should update the instance's state with the value returned from getDerivedStateFromProps when state changes", () => \{
			      interface FooState \{
			        value: string;
			      \}
			
			      class Foo extends Component<unknown, FooState> \{
			        public state: FooState;
			
			        constructor(props, context) \{
			          super(props, context);
			          this.state = \{
			            value: 'initial'
			          \};
			        \}
			
			        public static getDerivedStateFromProps(_nextProps, prevState) \{
			          // Don't change state for call that happens after the constructor
			          if (prevState.value === 'initial') \{
			            return null;
			          \}
			
			          return \{
			            value: prevState.value + ' derived'
			          \};
			        \}
			
			        public componentDidMount() \{
			          this.setState(\{ value: 'updated' \});
			        \}
			
			        public render() \{
			          return <div className=\{this.state.value\} />;
			        \}
			      \}
			
			      const derivedSpy = spyOn(Foo, 'getDerivedStateFromProps').and.callThrough();
			
			      render(<Foo />, container);
			      expect(container.firstChild.className).toEqual('initial');
			      expect(derivedSpy.calls.count()).toBe(1);
			
			      rerender(); // call rerender to handle cDM setState call
			      expect(container.firstChild.className).toEqual('updated derived');
			      expect(derivedSpy.calls.count()).toBe(2);
			    \});
			
			    it('should NOT modify state if null is returned', () => \{
			      interface FooState \{
			        bar: string;
			        foo: string;
			      \}
			
			      class Foo extends Component<unknown, FooState> \{
			        public state: FooState;
			        constructor(props, context) \{
			          super(props, context);
			          this.state = \{
			            bar: 'bar',
			            foo: 'foo'
			          \};
			        \}
			
			        public static getDerivedStateFromProps() \{
			          return null;
			        \}
			
			        public render() \{
			          return <div className=\{\`\$\{this.state.foo\} \$\{this.state.bar\}\`\} />;
			        \}
			      \}
			
			      const derivedSpy = spyOn(Foo, 'getDerivedStateFromProps');
			
			      render(<Foo />, container);
			      expect(container.firstChild.className).toEqual('foo bar');
			      expect(derivedSpy.calls.count()).toBe(1);
			    \});
			
			    // NOTE: Difference from React
			    // React v16.3.2 warns if undefined if returned from getDerivedStateFromProps
			    it('should NOT modify state if undefined is returned', () => \{
			      interface FooState \{
			        bar: string;
			        foo: string;
			      \}
			
			      class Foo extends Component<unknown, FooState> \{
			        public state: FooState;
			        constructor(props, context) \{
			          super(props, context);
			          this.state = \{
			            bar: 'bar',
			            foo: 'foo'
			          \};
			        \}
			
			        public static getDerivedStateFromProps() \{\}
			
			        public render() \{
			          return <div className=\{\`\$\{this.state.foo\} \$\{this.state.bar\}\`\} />;
			        \}
			      \}
			
			      const derivedSpy = spyOn(Foo, 'getDerivedStateFromProps');
			
			      render(<Foo />, container);
			      expect(container.firstChild.className).toEqual('foo bar');
			      expect(derivedSpy.calls.count()).toBe(1);
			    \});
			
			    it('should NOT invoke deprecated lifecycles (cWM/cWRP) if new static gDSFP is present', () => \{
			      class Foo extends Component \{
			        public static getDerivedStateFromProps() \{\}
			
			        public componentWillMount() \{\}
			
			        public componentWillReceiveProps() \{\}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      const derivedSpy = spyOn(Foo, 'getDerivedStateFromProps');
			      const willMountSpy = spyOn(Foo.prototype, 'componentWillMount');
			      const propsSpy = spyOn(Foo.prototype, 'componentWillReceiveProps');
			
			      render(<Foo />, container);
			      expect(derivedSpy.calls.count()).toBe(1);
			      expect(willMountSpy.calls.count()).toBe(0);
			      expect(propsSpy.calls.count()).toBe(0);
			    \});
			
			    it('is not called if neither state nor props have changed', () => \{
			      let logs: string[] = [];
			      let childRef;
			
			      interface ParentState \{
			        parentRenders: number;
			      \}
			
			      class Parent extends Component<unknown, ParentState> \{
			        public state: ParentState;
			        constructor(props) \{
			          super(props);
			          this.state = \{ parentRenders: 0 \};
			        \}
			
			        public static getDerivedStateFromProps(_props, prevState) \{
			          logs.push('parent getDerivedStateFromProps');
			          return prevState.parentRenders + 1;
			        \}
			
			        public render() \{
			          logs.push('parent render');
			          return <Child parentRenders=\{this.state.parentRenders\} ref=\{(child) => (childRef = child)\} />;
			        \}
			      \}
			
			      interface ChildProps \{
			        parentRenders: number;
			      \}
			
			      class Child extends Component<ChildProps> \{
			        public render() \{
			          logs.push('child render');
			          return this.props.parentRenders;
			        \}
			      \}
			
			      render(<Parent />, container);
			      expect(logs).toEqual(['parent getDerivedStateFromProps', 'parent render', 'child render']);
			
			      logs = [];
			      childRef.setState(\{\});
			      rerender();
			      expect(logs).toEqual(['child render']);
			    \});
			
			    it('should be passed next props and state', () => \{
			      let updateState;
			
			      let propsArg;
			      let stateArg;
			
			      interface FooState \{
			        value: number;
			      \}
			
			      class Foo extends Component<\{ foo: string \}, FooState> \{
			        public state: FooState;
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            value: 0
			          \};
			          updateState = () =>
			            this.setState(\{
			              value: this.state.value + 1
			            \});
			        \}
			
			        public static getDerivedStateFromProps(props, state) \{
			          // These object references might be updated later so copy
			          // object so we can assert their values at this snapshot in time
			          propsArg = \{ ...props \};
			          stateArg = \{ ...state \};
			
			          // NOTE: Don't do this in real production code!
			          // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html
			          return \{
			            value: state.value + 1
			          \};
			        \}
			
			        public render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			
			      // Initial render
			      // state.value: initialized to 0 in constructor, 0 -> 1 in gDSFP
			
			      render(<Foo foo="foo" />, container);
			      expect(container.firstChild.textContent).toEqual('1');
			      expect(propsArg).toEqual(\{
			        foo: 'foo'
			      \});
			      expect(stateArg).toEqual(\{
			        value: 0
			      \});
			
			      // New Props
			      // state.value: 1 -> 2 in gDSFP
			      render(<Foo foo="bar" />, container);
			      expect(container.firstChild.textContent).toEqual('2');
			      expect(propsArg).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(stateArg).toEqual(\{
			        value: 1
			      \});
			
			      // New state
			      // state.value: 2 -> 3 in updateState, 3
			      updateState();
			      rerender();
			      expect(container.firstChild.textContent).toEqual('4');
			      expect(propsArg).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(stateArg).toEqual(\{
			        value: 3
			      \});
			    \});
			
			    it('should NOT mutate state, only create new versions', () => \{
			      const stateConstant = \{\};
			      let componentState;
			
			      class Stateful extends Component \{
			        public static getDerivedStateFromProps() \{
			          return \{ key: 'value' \};
			        \}
			
			        constructor() \{
			          super(...arguments);
			          this.state = stateConstant;
			        \}
			
			        public componentDidMount() \{
			          componentState = this.state;
			        \}
			      \}
			
			      render(<Stateful />, container);
			
			      expect(componentState).toEqual(\{ key: 'value' \});
			      expect(stateConstant).toEqual(\{\});
			    \});
			  \});
			
			  describe('#getSnapshotBeforeUpdate', () => \{
			    it('should pass the return value from getSnapshotBeforeUpdate to componentDidUpdate', () => \{
			      let log: string[] = [];
			
			      interface MyComponentProps \{
			        value: string;
			      \}
			      interface MyComponentState \{
			        value: number;
			      \}
			
			      class MyComponent extends Component<MyComponentProps, MyComponentState> \{
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            value: 0
			          \};
			        \}
			
			        public static getDerivedStateFromProps(_nextProps, prevState) \{
			          return \{
			            value: prevState.value + 1
			          \};
			        \}
			
			        public getSnapshotBeforeUpdate(prevProps, prevState) \{
			          log.push(\`getSnapshotBeforeUpdate() prevProps:\$\{prevProps.value\} prevState:\$\{prevState.value\}\`);
			          return 'abc';
			        \}
			
			        public componentDidUpdate(prevProps, prevState, snapshot) \{
			          log.push(\`componentDidUpdate() prevProps:\$\{prevProps.value\} prevState:\$\{prevState.value\} snapshot:\$\{snapshot\}\`);
			        \}
			
			        public render() \{
			          log.push('render');
			          return null;
			        \}
			      \}
			
			      render(<MyComponent value="foo" />, container);
			      expect(log).toEqual(['render']);
			      log = [];
			
			      render(<MyComponent value="bar" />, container);
			      expect(log).toEqual(['render', 'getSnapshotBeforeUpdate() prevProps:foo prevState:1', 'componentDidUpdate() prevProps:foo prevState:1 snapshot:abc']);
			      log = [];
			
			      render(<MyComponent value="baz" />, container);
			      expect(log).toEqual(['render', 'getSnapshotBeforeUpdate() prevProps:bar prevState:2', 'componentDidUpdate() prevProps:bar prevState:2 snapshot:abc']);
			      log = [];
			
			      render(<div />, container);
			      expect(log).toEqual([]);
			    \});
			
			    it('should call getSnapshotBeforeUpdate before mutations are committed', () => \{
			      let log: string[] = [];
			
			      interface MyComponentProps \{
			        value: string;
			      \}
			      interface MyComponentState \{
			        value: number;
			      \}
			
			      class MyComponent extends Component<MyComponentProps, MyComponentState> \{
			        protected divRef: HTMLDivElement | null;
			
			        public getSnapshotBeforeUpdate(prevProps) \{
			          log.push('getSnapshotBeforeUpdate');
			          expect(this.divRef!.textContent).toEqual(\`value:\$\{prevProps.value\}\`);
			          return 'foobar';
			        \}
			
			        public componentDidUpdate(_prevProps, _prevState, snapshot) \{
			          log.push('componentDidUpdate');
			          expect(this.divRef!.textContent).toEqual(\`value:\$\{this.props.value\}\`);
			          expect(snapshot).toEqual('foobar');
			        \}
			
			        public render() \{
			          log.push('render');
			          return <div ref=\{(ref) => (this.divRef = ref)\}>\{\`value:\$\{this.props.value\}\`\}</div>;
			        \}
			      \}
			
			      render(<MyComponent value="foo" />, container);
			      expect(log).toEqual(['render']);
			      log = [];
			
			      render(<MyComponent value="bar" />, container);
			      expect(log).toEqual(['render', 'getSnapshotBeforeUpdate', 'componentDidUpdate']);
			    \});
			
			    it('should be passed the previous props and state', () => \{
			      let updateState;
			      let prevPropsArg;
			      let prevStateArg;
			      let curProps;
			      let curState;
			
			      interface FooState \{
			        value: number;
			      \}
			
			      interface FooProps \{
			        foo: string;
			      \}
			
			      class Foo extends Component<FooProps, FooState> \{
			        public state: FooState;
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            value: 0
			          \};
			          updateState = () =>
			            this.setState(\{
			              value: this.state.value + 1
			            \});
			        \}
			
			        public static getDerivedStateFromProps(_props, state) \{
			          // NOTE: Don't do this in real production code!
			          // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html
			          return \{
			            value: state.value + 1
			          \};
			        \}
			
			        public getSnapshotBeforeUpdate(prevProps, prevState) \{
			          // These object references might be updated later so copy
			          // object so we can assert their values at this snapshot in time
			          prevPropsArg = \{ ...prevProps \};
			          prevStateArg = \{ ...prevState \};
			
			          curProps = \{ ...this.props \};
			          curState = \{ ...this.state \};
			        \}
			
			        public render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			
			      // Expectation:
			      // \`prevState\` in getSnapshotBeforeUpdate should be
			      // the state before setState or getDerivedStateFromProps was called.
			      // \`this.state\` in getSnapshotBeforeUpdate should be
			      // the updated state after getDerivedStateFromProps was called.
			
			      // Initial render
			      // state.value: initialized to 0 in constructor, 0 -> 1 in gDSFP
			      render(<Foo foo="foo" />, container);
			      expect(container.firstChild.textContent).toEqual('1');
			      expect(prevPropsArg).toBeUndefined();
			      expect(prevStateArg).toBeUndefined();
			      expect(curProps).toBeUndefined();
			      expect(curState).toBeUndefined();
			
			      // New props
			      // state.value: 1 -> 2 in gDSFP
			      render(<Foo foo="bar" />, container);
			      expect(container.firstChild.textContent).toEqual('2');
			      expect(prevPropsArg).toEqual(\{
			        foo: 'foo'
			      \});
			      expect(prevStateArg).toEqual(\{
			        value: 1
			      \});
			      expect(curProps).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(curState).toEqual(\{
			        value: 2
			      \});
			
			      // New state
			      // state.value: 2 -> 3 in updateState, 3
			      updateState();
			      rerender();
			      expect(container.firstChild.textContent).toEqual('4');
			      expect(prevPropsArg).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(prevStateArg).toEqual(\{
			        value: 2
			      \});
			      expect(curProps).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(curState).toEqual(\{
			        value: 4
			      \});
			    \});
			  \});
			
			  describe('#componentWillUpdate', () => \{
			    it('should NOT be called on initial render', () => \{
			      class ReceivePropsComponent extends Component \{
			        public componentWillUpdate() \{\}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      const willUpdateSpy = spyOn(ReceivePropsComponent.prototype, 'componentWillUpdate');
			      render(<ReceivePropsComponent />, container);
			      expect(willUpdateSpy.calls.count()).toBe(0);
			    \});
			
			    it('should be called when rerender with new props from parent', () => \{
			      let doRender;
			
			      interface OuterProps \{\}
			      interface OuterState \{
			        i: number;
			      \}
			
			      class Outer extends Component<OuterProps, OuterState> \{
			        public state: OuterState;
			
			        constructor(p, c) \{
			          super(p, c);
			          this.state = \{ i: 0 \};
			        \}
			
			        public componentDidMount() \{
			          doRender = () => this.setState(\{ i: this.state.i + 1 \});
			        \}
			
			        public render(props, \{ i \}) \{
			          return <Inner i=\{i\} \{...props\} />;
			        \}
			      \}
			
			      class Inner extends Component \{
			        public componentWillUpdate(nextProps, nextState) \{
			          expect(nextProps).toEqual(\{ i: 1 \});
			          expect(nextState).toBe(null);
			        \}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      const willUpdateSpy = spyOn(Inner.prototype, 'componentWillUpdate').and.callThrough();
			
			      // Initial render
			      render(<Outer />, container);
			      expect(willUpdateSpy.calls.count()).toBe(0);
			
			      // Rerender inner with new props
			      doRender();
			      rerender();
			      expect(willUpdateSpy.calls.count()).toBe(1);
			    \});
			
			    it('should be called on new state', () => \{
			      let doRender;
			
			      interface ReceivePropsComponentState \{
			        i: number;
			      \}
			
			      class ReceivePropsComponent extends Component<unknown, ReceivePropsComponentState> \{
			        public state: ReceivePropsComponentState;
			
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            i: 0
			          \};
			        \}
			
			        public componentWillUpdate() \{\}
			
			        public componentDidMount() \{
			          doRender = () => this.setState(\{ i: this.state.i + 1 \});
			        \}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      const willUpdateSpy = spyOn(ReceivePropsComponent.prototype, 'componentWillUpdate');
			      render(<ReceivePropsComponent />, container);
			      expect(willUpdateSpy.calls.count()).toBe(0);
			
			      doRender();
			      rerender();
			      expect(willUpdateSpy.calls.count()).toBe(1);
			    \});
			
			    it('should be called after children are mounted', () => \{
			      const log: string[] = [];
			
			      class Inner extends Component \{
			        public componentDidMount() \{
			          log.push('Inner mounted');
			
			          // Verify that the component is actually mounted when this
			          // callback is invoked.
			          expect(container.querySelector('#inner')).toEqual(this.\$LI.dom);
			        \}
			
			        public render() \{
			          return <div id="inner" />;
			        \}
			      \}
			
			      class Outer extends Component<\{ renderInner?: boolean \}> \{
			        public componentDidUpdate() \{
			          log.push('Outer updated');
			        \}
			
			        public render(props) \{
			          return props.renderInner ? <Inner /> : <div />;
			        \}
			      \}
			
			      render(<Outer renderInner=\{false\} />, container);
			      render(<Outer renderInner=\{true\} />, container);
			
			      expect(log).toEqual(['Inner mounted', 'Outer updated']);
			    \});
			  \});
			
			  describe('#componentWillReceiveProps', () => \{
			    it('should NOT be called on initial render', () => \{
			      class ReceivePropsComponent extends Component \{
			        public componentWillReceiveProps() \{\}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      const willRecSpy = spyOn(ReceivePropsComponent.prototype, 'componentWillReceiveProps');
			      render(<ReceivePropsComponent />, container);
			      expect(willRecSpy.calls.count()).toBe(0);
			    \});
			
			    it('should be called when rerender with new props from parent', () => \{
			      let doRender;
			
			      interface OuterState \{
			        i: number;
			      \}
			
			      class Outer extends Component<unknown, OuterState> \{
			        public state: OuterState;
			
			        constructor(p, c) \{
			          super(p, c);
			          this.state = \{ i: 0 \};
			        \}
			
			        public componentDidMount() \{
			          doRender = () => this.setState(\{ i: this.state.i + 1 \});
			        \}
			
			        public render(props, \{ i \}) \{
			          return <Inner i=\{i\} \{...props\} />;
			        \}
			      \}
			
			      interface InnerProps \{
			        i: number;
			      \}
			
			      class Inner extends Component<InnerProps> \{
			        public componentWillMount() \{
			          expect(this.props.i).toEqual(0);
			        \}
			
			        public componentWillReceiveProps(nextProps) \{
			          expect(nextProps.i).toEqual(1);
			        \}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      const cwrpSpy = spyOn(Inner.prototype, 'componentWillReceiveProps').and.callThrough();
			
			      // Initial render
			      render(<Outer />, container);
			      expect(cwrpSpy.calls.count()).toBe(0);
			
			      // Rerender inner with new props
			      doRender();
			      rerender();
			      expect(cwrpSpy.calls.count()).toBe(1);
			    \});
			
			    it('should be called in right execution order', () => \{
			      let doRender;
			
			      interface OuterState \{
			        i: number;
			      \}
			
			      class Outer extends Component<unknown, OuterState> \{
			        public state: OuterState;
			        constructor(p, c) \{
			          super(p, c);
			          this.state = \{ i: 0 \};
			        \}
			
			        public componentDidMount() \{
			          doRender = () => this.setState(\{ i: this.state.i + 1 \});
			        \}
			
			        public render(props, \{ i \}) \{
			          return <Inner i=\{i\} \{...props\} />;
			        \}
			      \}
			
			      class Inner extends Component \{
			        public componentDidUpdate() \{
			          expect(cwrpSpy.calls.count()).toBe(1);
			          expect(cwuSpy.calls.count()).toBe(1);
			        \}
			
			        public componentWillReceiveProps() \{
			          expect(cwuSpy.calls.count()).toBe(0);
			          expect(cduSpy.calls.count()).toBe(0);
			        \}
			
			        public componentWillUpdate() \{
			          expect(cwrpSpy.calls.count()).toBe(1);
			          expect(cduSpy.calls.count()).toBe(0);
			        \}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      const orderOfCalls: string[] = [];
			      const cwrpSpy = spyOn(Inner.prototype, 'componentWillReceiveProps').and.callFake(function () \{
			        orderOfCalls.push('componentWillReceiveProps');
			      \});
			      const cduSpy = spyOn(Inner.prototype, 'componentDidUpdate').and.callFake(function () \{
			        orderOfCalls.push('componentDidUpdate');
			      \});
			      const cwuSpy = spyOn(Inner.prototype, 'componentWillUpdate').and.callFake(function () \{
			        orderOfCalls.push('componentWillUpdate');
			      \});
			      const originalDidMount = Outer.prototype.componentDidMount;
			      const cdmSpy = spyOn(Outer.prototype, 'componentDidMount').and.callFake(function () \{
			        orderOfCalls.push('componentDidMount');
			        originalDidMount.call(this);
			      \});
			
			      render(<Outer />, container);
			      doRender();
			      rerender();
			
			      expect(orderOfCalls).toEqual(['componentDidMount', 'componentWillReceiveProps', 'componentWillUpdate', 'componentDidUpdate']);
			
			      expect(cdmSpy.calls.count()).toBe(1);
			    \});
			  \});
			
			  describe('#componentDidUpdate', () => \{
			    it('should be passed previous props and state', () => \{
			      let updateState;
			
			      let prevPropsArg;
			      let prevStateArg;
			      let curProps;
			      let curState;
			
			      interface FooProps \{
			        foo: string;
			      \}
			
			      interface FooState \{
			        value: number;
			      \}
			
			      class Foo extends Component<FooProps, FooState> \{
			        public state: FooState;
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            value: 0
			          \};
			          updateState = () =>
			            this.setState(\{
			              value: this.state.value + 1
			            \});
			        \}
			
			        public static getDerivedStateFromProps(_props, state) \{
			          // NOTE: Don't do this in real production code!
			          // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html
			          return \{
			            value: state.value + 1
			          \};
			        \}
			
			        public componentDidUpdate(prevProps, prevState) \{
			          // These object references might be updated later so copy
			          // object so we can assert their values at this snapshot in time
			          prevPropsArg = \{ ...prevProps \};
			          prevStateArg = \{ ...prevState \};
			
			          curProps = \{ ...this.props \};
			          curState = \{ ...this.state \};
			        \}
			
			        public render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			
			      // Expectation:
			      // \`prevState\` in componentDidUpdate should be
			      // the state before setState and getDerivedStateFromProps was called.
			      // \`this.state\` in componentDidUpdate should be
			      // the updated state after getDerivedStateFromProps was called.
			
			      // Initial render
			      // state.value: initialized to 0 in constructor, 0 -> 1 in gDSFP
			      render(<Foo foo="foo" />, container);
			      expect(container.firstChild.textContent).toEqual('1');
			      expect(prevPropsArg).toBeUndefined();
			      expect(prevStateArg).toBeUndefined();
			      expect(curProps).toBeUndefined();
			      expect(curState).toBeUndefined();
			
			      // New props
			      // state.value: 1 -> 2 in gDSFP
			      render(<Foo foo="bar" />, container);
			      expect(container.firstChild.textContent).toEqual('2');
			      expect(prevPropsArg).toEqual(\{
			        foo: 'foo'
			      \});
			      expect(prevStateArg).toEqual(\{
			        value: 1
			      \});
			      expect(curProps).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(curState).toEqual(\{
			        value: 2
			      \});
			
			      // New state
			      // state.value: 2 -> 3 in updateState, 3
			      updateState();
			      rerender();
			      expect(container.firstChild.textContent).toEqual('4');
			      expect(prevPropsArg).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(prevStateArg).toEqual(\{
			        value: 2
			      \});
			      expect(curProps).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(curState).toEqual(\{
			        value: 4
			      \});
			    \});
			
			    it("prevState argument should be the same object if state doesn't change", () => \{
			      let changeProps;
			      let cduPrevState;
			      let cduCurrentState;
			
			      interface PropsProviderState \{
			        value: number;
			      \}
			
			      class PropsProvider extends Component<unknown, PropsProviderState> \{
			        public state: PropsProviderState;
			
			        constructor() \{
			          super();
			          this.state = \{ value: 0 \};
			          changeProps = this.changeReceiverProps.bind(this);
			        \}
			
			        public changeReceiverProps() \{
			          const value = (this.state.value + 1) % 2;
			          this.setState(\{
			            value
			          \});
			        \}
			
			        public render() \{
			          return <PropsReceiver value=\{this.state.value\} />;
			        \}
			      \}
			
			      interface PropsReceiverProps \{
			        value: number;
			      \}
			
			      class PropsReceiver extends Component<PropsReceiverProps> \{
			        public componentDidUpdate(_prevProps, prevState) \{
			          cduPrevState = prevState;
			          cduCurrentState = this.state;
			        \}
			
			        public render(\{ value \}) \{
			          return <div>\{value\}</div>;
			        \}
			      \}
			
			      render(<PropsProvider />, container);
			
			      changeProps();
			      rerender();
			
			      expect(cduPrevState).toEqual(cduCurrentState);
			    \});
			
			    it('prevState argument should be a different object if state does change', () => \{
			      let updateState;
			      let cduPrevState;
			      let cduCurrentState;
			
			      interface FooState \{
			        value: number;
			      \}
			
			      class Foo extends Component<unknown, FooState> \{
			        public state: FooState;
			        constructor() \{
			          super();
			          this.state = \{ value: 0 \};
			          updateState = this.updateState.bind(this);
			        \}
			
			        public updateState() \{
			          const value = (this.state.value + 1) % 2;
			          this.setState(\{
			            value
			          \});
			        \}
			
			        public componentDidUpdate(_prevProps, prevState) \{
			          cduPrevState = prevState;
			          cduCurrentState = this.state;
			        \}
			
			        public render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			
			      render(<Foo />, container);
			
			      updateState();
			      rerender();
			
			      expect(cduPrevState).not.toEqual(cduCurrentState);
			    \});
			
			    it("prevProps argument should be the same object if props don't change", () => \{
			      let updateState;
			      let cduPrevProps;
			      let cduCurrentProps;
			
			      interface FooState \{
			        value: number;
			      \}
			
			      class Foo extends Component<unknown, FooState> \{
			        public state: FooState;
			        constructor() \{
			          super();
			          this.state = \{ value: 0 \};
			          updateState = this.updateState.bind(this);
			        \}
			
			        public updateState() \{
			          const value = (this.state.value + 1) % 2;
			          this.setState(\{
			            value
			          \});
			        \}
			
			        public componentDidUpdate(prevProps) \{
			          cduPrevProps = prevProps;
			          cduCurrentProps = this.props;
			        \}
			
			        public render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			
			      render(<Foo />, container);
			
			      updateState();
			      rerender();
			
			      expect(cduPrevProps).toEqual(cduCurrentProps);
			    \});
			
			    it('prevProps argument should be a different object if props do change', () => \{
			      let changeProps;
			      let cduPrevProps;
			      let cduCurrentProps;
			
			      interface PropsProviderState \{
			        value: number;
			      \}
			
			      class PropsProvider extends Component<unknown, PropsProviderState> \{
			        public state: PropsProviderState;
			
			        constructor() \{
			          super();
			          this.state = \{ value: 0 \};
			          changeProps = this.changeReceiverProps.bind(this);
			        \}
			
			        public changeReceiverProps() \{
			          const value = (this.state.value + 1) % 2;
			          this.setState(\{
			            value
			          \});
			        \}
			
			        public render() \{
			          return <PropsReceiver value=\{this.state.value\} />;
			        \}
			      \}
			
			      interface PropsReceiverProps \{
			        value: number;
			      \}
			
			      class PropsReceiver extends Component<PropsReceiverProps> \{
			        public componentDidUpdate(prevProps) \{
			          cduPrevProps = prevProps;
			          cduCurrentProps = this.props;
			        \}
			
			        public render(\{ value \}) \{
			          return <div>\{value\}</div>;
			        \}
			      \}
			
			      render(<PropsProvider />, container);
			
			      changeProps();
			      rerender();
			
			      expect(cduPrevProps).not.toEqual(cduCurrentProps);
			    \});
			  \});
			
			  describe('#constructor and component(Did|Will)(Mount|Unmount)', () => \{
			    let setState;
			
			    class Outer extends Component \{
			      constructor(p, c) \{
			        super(p, c);
			        this.state = \{ show: true \};
			        setState = (s) => this.setState(s);
			      \}
			
			      public render(props, \{ show \}) \{
			        return <div>\{show && <Inner \{...props\} />\}</div>;
			      \}
			    \}
			
			    class LifecycleTestComponent extends Component \{
			      constructor(p, c) \{
			        super(p, c);
			        this._constructor();
			      \}
			
			      public _constructor() \{\}
			
			      public componentWillMount() \{\}
			
			      public componentDidMount() \{\}
			
			      public componentWillUnmount() \{\}
			
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    class Inner extends LifecycleTestComponent \{
			      public render() \{
			        return (
			          <div>
			            <InnerMost />
			          </div>
			        );
			      \}
			    \}
			
			    class InnerMost extends LifecycleTestComponent \{
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    describe('inner components', () => \{
			      let constructorSpy: jasmine.Spy;
			      let willMountSpy: jasmine.Spy;
			      let didMountSpy: jasmine.Spy;
			      let willUnmountSpy: jasmine.Spy;
			
			      const reset = () => \{
			        constructorSpy.calls.reset();
			        willMountSpy.calls.reset();
			        didMountSpy.calls.reset();
			        willUnmountSpy.calls.reset();
			      \};
			
			      beforeEach(function () \{
			        constructorSpy = spyOn(Inner.prototype, '_constructor');
			        willMountSpy = spyOn(Inner.prototype, 'componentWillMount');
			        didMountSpy = spyOn(Inner.prototype, 'componentDidMount');
			        willUnmountSpy = spyOn(Inner.prototype, 'componentWillUnmount');
			      \});
			
			      it('should be invoked for components on initial render', () => \{
			        reset();
			        render(<Outer />, container);
			        expect(constructorSpy.calls.count()).toBe(1);
			        expect(didMountSpy.calls.count()).toBe(1);
			        expect(willMountSpy.calls.count()).toBe(1);
			      \});
			
			      it('should be invoked for components on unmount', () => \{
			        reset();
			        render(<Outer />, container);
			        setState(\{ show: false \});
			        rerender();
			
			        expect(willUnmountSpy.calls.count()).toBe(1);
			      \});
			
			      it('should be invoked for components on re-render', () => \{
			        reset();
			        render(<Outer />, container);
			        setState(\{ show: true \});
			        rerender();
			
			        expect(constructorSpy.calls.count()).toBe(1);
			        expect(didMountSpy.calls.count()).toBe(1);
			        expect(willMountSpy.calls.count()).toBe(1);
			      \});
			    \});
			
			    describe('innermost components', () => \{
			      let constructorSpy: jasmine.Spy;
			      let willMountSpy: jasmine.Spy;
			      let didMountSpy: jasmine.Spy;
			      let willUnmountSpy: jasmine.Spy;
			
			      const reset = () => \{
			        constructorSpy.calls.reset();
			        willMountSpy.calls.reset();
			        didMountSpy.calls.reset();
			        willUnmountSpy.calls.reset();
			      \};
			
			      beforeEach(function () \{
			        constructorSpy = spyOn(InnerMost.prototype, '_constructor');
			        willMountSpy = spyOn(InnerMost.prototype, 'componentWillMount');
			        didMountSpy = spyOn(InnerMost.prototype, 'componentDidMount');
			        willUnmountSpy = spyOn(InnerMost.prototype, 'componentWillUnmount');
			      \});
			
			      it('should be invoked for components on initial render', () => \{
			        reset();
			        render(<Outer />, container);
			        expect(constructorSpy.calls.count()).toBe(1);
			        expect(willMountSpy.calls.count()).toBe(1);
			        expect(didMountSpy.calls.count()).toBe(1);
			      \});
			
			      it('should be invoked for components on unmount', () => \{
			        reset();
			        render(<Outer />, container);
			        setState(\{ show: false \});
			        rerender();
			
			        expect(willUnmountSpy.calls.count()).toBe(1);
			      \});
			
			      it('should be invoked for components on re-render', () => \{
			        reset();
			        render(<Outer />, container);
			        setState(\{ show: true \});
			        rerender();
			
			        expect(constructorSpy.calls.count()).toBe(1);
			        expect(willMountSpy.calls.count()).toBe(1);
			        expect(didMountSpy.calls.count()).toBe(1);
			      \});
			    \});
			
			    describe('when shouldComponentUpdate() returns false', () => \{
			      let outerSetState;
			
			      class Outer1 extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ show: true \};
			          outerSetState = (s) => this.setState(s);
			        \}
			
			        public render(props, \{ show \}) \{
			          return (
			            <div>
			              \{show && (
			                <div>
			                  <Inner1 \{...props\} />
			                </div>
			              )\}
			            </div>
			          );
			        \}
			      \}
			
			      class Inner1 extends Component \{
			        public shouldComponentUpdate() \{
			          return false;
			        \}
			
			        public componentWillMount() \{\}
			
			        public componentDidMount() \{\}
			
			        public componentWillUnmount() \{\}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      let willMountSpy: jasmine.Spy;
			      let didMountSpy: jasmine.Spy;
			      let willUnmountSpy: jasmine.Spy;
			
			      beforeEach(function () \{
			        willMountSpy = spyOn(Inner1.prototype, 'componentWillMount');
			        didMountSpy = spyOn(Inner1.prototype, 'componentDidMount');
			        willUnmountSpy = spyOn(Inner1.prototype, 'componentWillUnmount');
			      \});
			
			      it('should be invoke normally on initial mount', () => \{
			        render(<Outer1 />, container);
			        expect(willMountSpy.calls.count()).toBe(1);
			        expect(didMountSpy.calls.count()).toBe(1);
			      \});
			
			      it('should be invoked normally on unmount', () => \{
			        render(<Outer1 />, container);
			        outerSetState(\{ show: false \});
			        rerender();
			
			        expect(willUnmountSpy.calls.count()).toBe(1);
			      \});
			
			      it('should still invoke mount for shouldComponentUpdate():false', () => \{
			        render(<Outer1 />, container);
			        outerSetState(\{ show: true \});
			        rerender();
			
			        expect(willMountSpy.calls.count()).toBe(1);
			        expect(didMountSpy.calls.count()).toBe(1);
			      \});
			
			      it('should still invoke unmount for shouldComponentUpdate():false', () => \{
			        render(<Outer1 />, container);
			        outerSetState(\{ show: false \});
			        rerender();
			
			        expect(willUnmountSpy.calls.count()).toBe(1);
			      \});
			    \});
			  \});
			
			  describe('#shouldComponentUpdate', () => \{
			    let setState;
			    let renderSpy: jasmine.Spy;
			    let shouldUpdateSpy: jasmine.Spy;
			
			    class Should extends Component \{
			      constructor() \{
			        super();
			        this.state = \{ show: true \};
			        setState = (s) => this.setState(s);
			      \}
			
			      public render(_props, \{ show \}) \{
			        return show ? <div /> : null;
			      \}
			    \}
			
			    class ShouldNot extends Should \{
			      public shouldComponentUpdate() \{
			        return false;
			      \}
			    \}
			
			    beforeEach(function () \{
			      renderSpy = spyOn(Should.prototype, 'render');
			      shouldUpdateSpy = spyOn(ShouldNot.prototype, 'shouldComponentUpdate');
			    \});
			
			    it('should rerender component on change by default', () => \{
			      render(<Should />, container);
			      setState(\{ show: false \});
			      rerender();
			
			      expect(renderSpy.calls.count()).toBe(2);
			    \});
			
			    it('should not rerender component if shouldComponentUpdate returns false', () => \{
			      render(<ShouldNot />, container);
			      setState(\{ show: false \});
			      rerender();
			
			      expect(shouldUpdateSpy.calls.count()).toBe(1);
			      expect(renderSpy.calls.count()).toBe(1);
			    \});
			
			    it('should be passed next props and state', () => \{
			      let updateState;
			      let curProps;
			      let curState;
			      let nextPropsArg;
			      let nextStateArg;
			
			      interface FooState \{
			        value: number;
			      \}
			
			      class Foo extends Component<\{ foo: string \}, FooState> \{
			        public state: FooState;
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            value: 0
			          \};
			          updateState = () =>
			            this.setState(\{
			              value: this.state.value + 1
			            \});
			        \}
			
			        public static getDerivedStateFromProps(_props, state) \{
			          // NOTE: Don't do this in real production code!
			          // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html
			          return \{
			            value: state.value + 1
			          \};
			        \}
			
			        public shouldComponentUpdate(nextProps, nextState) \{
			          nextPropsArg = \{ ...nextProps \};
			          nextStateArg = \{ ...nextState \};
			
			          curProps = \{ ...this.props \};
			          curState = \{ ...this.state \};
			
			          return true;
			        \}
			
			        public render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			
			      // Expectation:
			      // \`this.state\` in shouldComponentUpdate should be
			      // the state before setState or getDerivedStateFromProps was called
			      // \`nextState\` in shouldComponentUpdate should be
			      // the updated state after getDerivedStateFromProps was called
			
			      // Initial render
			      // state.value: initialized to 0 in constructor, 0 -> 1 in gDSFP
			      render(<Foo foo="foo" />, container);
			      expect(container.firstChild.textContent).toEqual('1');
			      expect(curProps).toBeUndefined();
			      expect(curState).toBeUndefined();
			      expect(nextPropsArg).toBeUndefined();
			      expect(nextStateArg).toBeUndefined();
			
			      // New props
			      // state.value: 1 -> 2 in gDSFP
			      render(<Foo foo="bar" />, container);
			      expect(container.firstChild.textContent).toEqual('2');
			      expect(curProps).toEqual(\{
			        foo: 'foo'
			      \});
			      expect(curState).toEqual(\{
			        value: 1
			      \});
			      expect(nextPropsArg).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(nextStateArg).toEqual(\{
			        value: 2
			      \});
			
			      // New state
			      // state.value: 2 -> 3 in updateState, 3
			      updateState();
			      expect(container.firstChild.textContent).toEqual('4');
			      expect(curProps).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(curState).toEqual(\{
			        value: 2
			      \});
			      expect(nextPropsArg).toEqual(\{
			        foo: 'bar'
			      \});
			      expect(nextStateArg).toEqual(\{
			        value: 4
			      \});
			    \});
			  \});
			
			  describe('#setState', () => \{
			    it('should NOT mutate state, only create new versions', (done) => \{
			      const stateConstant = \{\};
			      let didMount = false;
			      let componentState;
			
			      class Stateful extends Component \{
			        constructor() \{
			          super(...arguments);
			          this.state = stateConstant;
			        \}
			
			        public componentDidMount() \{
			          didMount = true;
			          this.setState(\{ key: 'value' \}, () => \{
			            componentState = this.state;
			          \});
			        \}
			      \}
			
			      render(<Stateful />, container);
			      rerender();
			
			      expect(didMount).toEqual(true);
			
			      setTimeout(() => \{
			        expect(componentState).toEqual(\{ key: 'value' \});
			        expect(stateConstant).toEqual(\{\});
			        done();
			      \}, 10);
			    \});
			  \});
			
			  describe('Lifecycle DOM Timing', () => \{
			    it('should render in a single microtask', () => \{
			      class Counter extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ count: 0 \};
			        \}
			
			        public render(_props, \{ count \}) \{
			          if (count < 5) \{
			            this.setState(\{ count: count + 1 \});
			          \}
			          return count;
			        \}
			      \}
			
			      render(<Counter />, container);
			
			      rerender();
			      expect(container.textContent).toEqual('5');
			    \});
			
			    it('should be invoked when dom does (DidMount, WillUnmount) or does not (WillMount, DidUnmount) exist', () => \{
			      let setState;
			
			      class Outer extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ show: true \};
			          setState = (s) => \{
			            this.setState(s);
			          \};
			        \}
			
			        public componentWillMount() \{
			          expect(document.getElementById('OuterDiv')).toBeNull();
			        \}
			
			        public componentDidMount() \{
			          expect(document.getElementById('OuterDiv')).not.toBeNull();
			        \}
			
			        public componentWillUnmount() \{
			          expect(document.getElementById('OuterDiv')).not.toBeNull();
			        \}
			
			        public render(props, \{ show \}) \{
			          return (
			            <div id="OuterDiv">
			              \{show && (
			                <div>
			                  <Inner \{...props\} />
			                </div>
			              )\}
			            </div>
			          );
			        \}
			      \}
			
			      class Inner extends Component \{
			        public componentWillMount() \{
			          expect(document.getElementById('InnerDiv')).toBeNull();
			        \}
			
			        public componentDidMount() \{
			          expect(document.getElementById('InnerDiv')).not.toBeNull();
			        \}
			
			        public componentWillUnmount() \{
			          expect(document.getElementById('InnerDiv')).not.toBeNull();
			        \}
			
			        public render() \{
			          return <div id="InnerDiv" />;
			        \}
			      \}
			
			      const proto = Inner.prototype;
			      const orderOfCalls: string[] = [];
			
			      const willMountSpy = spyOn(proto, 'componentWillMount').and.callFake(function () \{
			        orderOfCalls.push('willMount');
			      \});
			      const didMountSpy = spyOn(proto, 'componentDidMount').and.callFake(function () \{
			        orderOfCalls.push('didMount');
			      \});
			      const unmountSpy = spyOn(proto, 'componentWillUnmount').and.callFake(function () \{
			        orderOfCalls.push('willUnmount');
			      \});
			
			      const reset = () => \{
			        willMountSpy.calls.reset();
			        didMountSpy.calls.reset();
			        unmountSpy.calls.reset();
			      \};
			
			      render(<Outer />, container);
			      expect(willMountSpy.calls.count()).toBe(1);
			      expect(didMountSpy.calls.count()).toBe(1);
			
			      expect(orderOfCalls).toEqual(['willMount', 'didMount']);
			
			      reset();
			      setState(\{ show: false \});
			
			      expect(document.getElementById('InnerDiv')).toBeNull();
			
			      expect(unmountSpy.calls.count()).toBe(1);
			
			      reset();
			      setState(\{ show: true \});
			
			      expect(document.getElementById('InnerDiv')).not.toBeNull();
			
			      expect(willMountSpy.calls.count()).toBe(1);
			      expect(didMountSpy.calls.count()).toBe(1);
			
			      expect(orderOfCalls).toEqual(['willMount', 'didMount', 'willUnmount', 'willMount', 'didMount']);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\newlifecycle.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(42)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\patching-jsx.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, InfernoNode, render, rerender \} from 'inferno';
			
			describe('patching routine (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should always unmount/mount if ReCreate flag is set', () => \{
			    const spyObj = \{ fn: () => \{\} \};
			    const spyObj2 = \{ fn: () => \{\} \};
			    const spy1 = spyOn(spyObj, 'fn');
			    const spy2 = spyOn(spyObj2, 'fn');
			
			    const div = (
			      <div \$ReCreate ref=\{spy1\}>
			        1
			      </div>
			    );
			
			    render(div, container);
			
			    const firstDiv = container.firstChild;
			
			    expect(container.innerHTML).toEqual('<div>1</div>');
			    expect(spy1.calls.count()).toBe(1);
			    expect(spy1.calls.argsFor(0).length).toBe(1);
			    expect(spy1.calls.argsFor(0)[0]).toEqual(firstDiv);
			
			    const div2 = (
			      <div \$ReCreate ref=\{spy2\}>
			        1
			      </div>
			    );
			
			    render(div2, container);
			
			    expect(firstDiv).not.toBe(container.firstChild); // Div is different
			
			    // Html is the same
			    expect(container.innerHTML).toEqual('<div>1</div>');
			
			    // Verify all callbacks were called
			    expect(spy1.calls.count()).toBe(2);
			    expect(spy1.calls.argsFor(1).length).toBe(1);
			    expect(spy1.calls.argsFor(1)[0]).toEqual(null);
			
			    expect(spy2.calls.count()).toBe(1);
			    expect(spy2.calls.argsFor(0).length).toBe(1);
			    expect(spy2.calls.argsFor(0)[0]).toEqual(container.firstChild);
			  \});
			
			  it('Should be able to patch references', () => \{
			    interface Component1State \{
			      value: number;
			    \}
			
			    class Component1 extends Component<unknown, Component1State> \{
			      public state: Component1State;
			
			      constructor(p, c) \{
			        super(p, c);
			
			        this.state = \{
			          value: 1
			        \};
			
			        this.add = this.add.bind(this);
			      \}
			
			      public add(e) \{
			        e.stopPropagation();
			
			        this.setState(\{
			          value: ++this.state.value
			        \});
			      \}
			
			      public render(props) \{
			        return (
			          <div id="child" onclick=\{this.add\}>
			            <span>\{this.state.value\}</span>
			            \{props.children\}
			          </div>
			        );
			      \}
			    \}
			
			    interface ParentState \{
			      value: number;
			    \}
			
			    class Parent extends Component<unknown, ParentState> \{
			      public state: ParentState;
			      constructor(p, c) \{
			        super(p, c);
			
			        this.state = \{
			          value: 1
			        \};
			
			        this.add = this.add.bind(this);
			      \}
			
			      public add(e) \{
			        e.stopPropagation();
			
			        this.setState(\{
			          value: 3
			        \});
			      \}
			
			      public render() \{
			        const arr: InfernoNode[] = [];
			
			        arr.push(<div>\{this.state.value\}</div>);
			
			        if (this.state.value > 1) \{
			          arr.unshift(<div>\{this.state.value\}</div>);
			        \}
			
			        return (
			          <div id="parent" onclick=\{this.add\}>
			            <Component1>
			              <div \$HasNonKeyedChildren>\{arr\}</div>
			            </Component1>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    expect(container.innerHTML).toBe('<div id="parent"><div id="child"><span>1</span><div><div>1</div></div></div></div>');
			
			    container.querySelector('#child').click();
			    rerender();
			
			    expect(container.innerHTML).toBe('<div id="parent"><div id="child"><span>2</span><div><div>1</div></div></div></div>');
			
			    container.querySelector('#parent').click();
			    rerender();
			
			    expect(container.innerHTML).toBe('<div id="parent"><div id="child"><span>2</span><div><div>3</div><div>3</div></div></div></div>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\patching-jsx.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\patching.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createTextVNode, createVNode, linkEvent, render \} from 'inferno';
			import \{ ChildFlags, VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('patching routine', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should do nothing if lastVNode strictly equals nextVnode', () => \{
			    const yar = createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('123'), ChildFlags.HasVNodeChildren, null, null, null);
			    const bar = createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('123'), ChildFlags.HasVNodeChildren, null, null, null);
			    let foo = createVNode(VNodeFlags.HtmlElement, 'div', null, [bar, yar], ChildFlags.HasNonKeyedChildren, null, null, null);
			
			    render(foo, container);
			    expect(container.innerHTML).toEqual('<div><div>123</div><div>123</div></div>');
			
			    foo = createVNode(VNodeFlags.HtmlElement, 'div', null, [bar, yar], ChildFlags.HasNonKeyedChildren, null, null, null);
			
			    render(foo, container);
			    expect(container.innerHTML).toEqual('<div><div>123</div><div>123</div></div>');
			  \});
			
			  it('Should mount nextNode if lastNode crashed', () => \{
			    const validNode = createVNode(VNodeFlags.HtmlElement, 'span', null, createTextVNode('a'), ChildFlags.HasVNodeChildren, null, null, null);
			    const invalidNode = createVNode(0, 'span');
			
			    render(validNode, container);
			    try \{
			      render(invalidNode, container);
			    \} catch (e) \{
			      expect(e.message.indexOf('Inferno Error: mount() received an object')).not.toEqual(-1);
			    \}
			    expect(container.innerHTML).toEqual('<span>a</span>');
			
			    render(validNode, container);
			    expect(container.innerHTML).toEqual('<span>a</span>');
			  \});
			
			  it('Should not access real DOM property when text does not change', () => \{
			    render(createTextVNode('a'), container);
			    expect(container.innerHTML).toEqual('a');
			    render(createTextVNode('a'), container);
			    expect(container.innerHTML).toEqual('a');
			  \});
			
			  it('Should not patch same innerHTML', () => \{
			    container.innerHTML = '<span><span><span>child</span></span></span>';
			
			    const childelem = container.firstElementChild.firstElementChild;
			    const props = \{ dangerouslySetInnerHTML: \{ __html: '<span>child</span>' \} \};
			
			    const bar = createVNode(VNodeFlags.HtmlElement, 'span', null, null, ChildFlags.HasInvalidChildren, props, null, null);
			    const foo = createVNode(VNodeFlags.HtmlElement, 'span', null, [bar], ChildFlags.HasNonKeyedChildren, null, null, null);
			
			    render(foo, container);
			
			    expect(childelem).toBe(container.firstElementChild.firstElementChild);
			  \});
			
			  it('Should always unmount/mount if ReCreate flag is set', () => \{
			    const spyObj = \{ fn: () => \{\} \};
			    const spyObj2 = \{ fn: () => \{\} \};
			    const spy1 = spyOn(spyObj, 'fn');
			    const spy2 = spyOn(spyObj2, 'fn');
			
			    const div = createVNode(VNodeFlags.HtmlElement | VNodeFlags.ReCreate, 'div', null, createTextVNode('1'), ChildFlags.HasVNodeChildren, null, null, spy1);
			
			    render(div, container);
			
			    const firstDiv = container.firstChild;
			
			    expect(container.innerHTML).toEqual('<div>1</div>');
			    expect(spy1.calls.count()).toBe(1);
			    expect(spy1.calls.argsFor(0).length).toBe(1);
			    expect(spy1.calls.argsFor(0)[0]).toEqual(firstDiv);
			
			    const div2 = createVNode(VNodeFlags.HtmlElement | VNodeFlags.ReCreate, 'div', null, createTextVNode('1'), ChildFlags.HasVNodeChildren, null, null, spy2);
			
			    render(div2, container);
			
			    expect(firstDiv).not.toBe(container.firstChild); // Div is different
			
			    // Html is the same
			    expect(container.innerHTML).toEqual('<div>1</div>');
			
			    // Verify all callbacks were called
			    expect(spy1.calls.count()).toBe(2);
			    expect(spy1.calls.argsFor(1).length).toBe(1);
			    expect(spy1.calls.argsFor(1)[0]).toEqual(null);
			
			    expect(spy2.calls.count()).toBe(1);
			    expect(spy2.calls.argsFor(0).length).toBe(1);
			    expect(spy2.calls.argsFor(0)[0]).toEqual(container.firstChild);
			  \});
			
			  it('Should not mutate previous children', () => \{
			    let callCount = 0;
			
			    class Collapsible extends Component \{
			      public render() \{
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                callCount++;
			                this.setState(\{\});
			              \}\}
			            >
			              Click twice !
			            </button>
			            \{this.props.children\}
			          </div>
			        );
			      \}
			    \}
			
			    class Clock extends Component \{
			      public render() \{
			        return (
			          <Collapsible>
			            <div>
			              \{[<p>Hello 0</p>, <p>Hello 1</p>]\}
			              <strong>Hello 2</strong>
			            </div>
			            <p>Hello 3</p>
			          </Collapsible>
			        );
			      \}
			    \}
			
			    const expectedDOM = '<div><button>Click twice !</button><div><p>Hello 0</p><p>Hello 1</p><strong>Hello 2</strong></div><p>Hello 3</p></div>';
			
			    render(<Clock />, container);
			
			    expect(container.innerHTML).toBe(expectedDOM);
			
			    const btn = container.querySelector('button');
			
			    btn.click();
			
			    expect(callCount).toBe(1);
			
			    expect(container.innerHTML).toBe(expectedDOM);
			
			    btn.click();
			
			    expect(callCount).toBe(2);
			
			    expect(container.innerHTML).toBe(expectedDOM);
			
			    btn.click();
			
			    expect(callCount).toBe(3);
			
			    expect(container.innerHTML).toBe(expectedDOM);
			
			    btn.click();
			
			    expect(callCount).toBe(4);
			
			    expect(container.innerHTML).toBe(expectedDOM);
			  \});
			
			  it('Should not re-mount hoisted vNode', () => \{
			    const Com1 = () => <div>1</div>;
			    const Com2 = () => <div>2</div>;
			
			    const div = (
			      <div>
			        <Com1 />
			        <Com2 />
			      </div>
			    );
			
			    function Comp() \{
			      return div;
			    \}
			
			    render(<Comp />, container);
			
			    expect(container.innerHTML).toBe('<div><div>1</div><div>2</div></div>');
			
			    const first = container.firstChild.childNodes[0];
			    const second = container.firstChild.childNodes[1];
			
			    render(<Comp />, container);
			
			    expect(container.innerHTML).toBe('<div><div>1</div><div>2</div></div>');
			
			    const first2 = container.firstChild.childNodes[0];
			    const second2 = container.firstChild.childNodes[1];
			
			    // Verify dom nodes did not change
			    expect(first).toBe(first2);
			    expect(second).toBe(second2);
			
			    render(<Comp />, container);
			
			    expect(container.innerHTML).toBe('<div><div>1</div><div>2</div></div>');
			
			    const first3 = container.firstChild.childNodes[0];
			    const second3 = container.firstChild.childNodes[1];
			
			    // Verify dom nodes did not change
			    expect(first).toBe(first3);
			    expect(second).toBe(second3);
			  \});
			
			  describe('Event changes', () => \{
			    describe('Synthetic', () => \{
			      it('Should remove function if next is boolean (false)', () => \{
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkObj.methodFn\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onClick=\{false as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onclick=\{linkObj.methodFn\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should remove function if next is boolean (true)', () => \{
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkObj.methodFn\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onClick=\{true as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onclick=\{linkObj.methodFn\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should remove linkEvent if next is boolean (false)', () => \{
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onClick=\{false as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onClick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should remove linkEvent if next is boolean (true)', () => \{
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onClick=\{true as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onClick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should change from LinkEvent to Function', () => \{
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onClick=\{anotherObj.anotherFn\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from Function to LinkEvent', () => \{
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onClick=\{anotherObj.anotherFn\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from Function to different Function', () => \{
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkObj.methodFn\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onClick=\{anotherObj.anotherFn\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from LinkEvent fn to different LinkEvent fn', () => \{
			        const data = \{ foo: 1 \};
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onClick=\{linkEvent(data, anotherObj.anotherFn)\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onClick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from LinkEvent data to different LinkEvent data', () => \{
			        const obj1 = \{ foo: 1 \};
			        const obj2 = \{ foo: 2 \};
			        let secondArg = null;
			
			        const anotherObj = \{
			          anotherFn(_, ev) \{
			            secondArg = ev;
			          \}
			        \};
			
			        const anotherFnSpy = spyOn(anotherObj, 'anotherFn').and.callThrough();
			
			        render(<div onClick=\{linkEvent(obj1, anotherFnSpy)\} />, container);
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(1);
			        expect(anotherFnSpy).toHaveBeenCalledWith(obj1, secondArg);
			
			        anotherFnSpy.calls.reset();
			
			        render(<div onClick=\{linkEvent(obj2, anotherFnSpy)\} />, container);
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(1);
			        expect(anotherFnSpy).toHaveBeenCalledWith(obj2, secondArg);
			      \});
			    \});
			
			    describe('Regular', () => \{
			      it('Should remove function if next is boolean (false)', () => \{
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkObj.methodFn\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onclick=\{false as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onclick=\{linkObj.methodFn\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should remove function if next is boolean (true)', () => \{
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkObj.methodFn\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onclick=\{true as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onclick=\{linkObj.methodFn\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should remove linkEvent if next is boolean (false)', () => \{
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onclick=\{false as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onclick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should remove linkEvent if next is boolean (true)', () => \{
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        render(<div onclick=\{true as any\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        // ADD BACK
			
			        render(<div onclick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(2);
			      \});
			
			      it('Should change from LinkEvent to Function', () => \{
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onclick=\{anotherObj.anotherFn\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from Function to LinkEvent', () => \{
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onclick=\{anotherObj.anotherFn\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			
			        const data = \{ foo: 1 \};
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from Function to different Function', () => \{
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkObj.methodFn\} />, container);
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onclick=\{anotherObj.anotherFn\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from LinkEvent fn to different LinkEvent fn', () => \{
			        const data = \{ foo: 1 \};
			        const anotherObj = \{
			          anotherFn() \{\}
			        \};
			        spyOn(anotherObj, 'anotherFn');
			
			        render(<div onclick=\{linkEvent(data, anotherObj.anotherFn)\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			
			        const linkObj = \{
			          methodFn() \{\}
			        \};
			        spyOn(linkObj, 'methodFn');
			
			        render(<div onclick=\{linkEvent(data, linkObj.methodFn)\} />, container);
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherObj.anotherFn).toHaveBeenCalledTimes(1);
			        expect(linkObj.methodFn).toHaveBeenCalledTimes(1);
			      \});
			
			      it('Should change from LinkEvent data to different LinkEvent data', () => \{
			        const obj1 = \{ foo: 1 \};
			        const obj2 = \{ foo: 2 \};
			        let secondArg = null;
			
			        const anotherObj = \{
			          anotherFn(_, ev) \{
			            secondArg = ev;
			          \}
			        \};
			
			        const anotherFnSpy = spyOn(anotherObj, 'anotherFn').and.callThrough();
			
			        render(<div onclick=\{linkEvent(obj1, anotherFnSpy)\} />, container);
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(1);
			        expect(anotherFnSpy).toHaveBeenCalledWith(obj1, secondArg);
			
			        anotherFnSpy.calls.reset();
			
			        render(<div onclick=\{linkEvent(obj2, anotherFnSpy)\} />, container);
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(0);
			
			        container.firstChild.click();
			
			        expect(anotherFnSpy).toHaveBeenCalledTimes(1);
			        expect(anotherFnSpy).toHaveBeenCalledWith(obj2, secondArg);
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\patching.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(25)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\portal.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createPortal, render as _render \} from 'inferno';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('Portal spec', () => \{
			  let container;
			
			  function render(input, \$container, cb?) \{
			    _render(input, \$container, cb);
			
			    const rootInput = \$container.\$V;
			
			    if (rootInput && rootInput.flags & VNodeFlags.Component) \{
			      return rootInput.children;
			    \}
			
			    return rootInput;
			  \}
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container, null);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  let svgEls;
			  let htmlEls;
			  let mathEls;
			  const expectSVG = \{ ref: (el) => svgEls.push(el) \};
			  const expectHTML = \{ ref: (el) => htmlEls.push(el) \};
			  const expectMath = \{ ref: (el) => mathEls.push(el) \};
			
			  const usePortal = function (tree) \{
			    return createPortal(tree, document.createElement('div'));
			  \};
			
			  const assertNamespacesMatch = function (tree) \{
			    svgEls = [];
			    htmlEls = [];
			    mathEls = [];
			
			    render(tree, container);
			    svgEls.forEach((el) => \{
			      expect(el.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    \});
			    htmlEls.forEach((el) => \{
			      expect(el.namespaceURI).toBe('http://www.w3.org/1999/xhtml');
			    \});
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			  \};
			
			  it('should mount/unmount one portal', () => \{
			    const portalContainer = document.createElement('div');
			
			    render(<div>\{createPortal(<div>portal</div>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<div>portal</div>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should allow Arrays as portal content', () => \{
			    const portalContainer = document.createElement('div');
			    let mountCount = 0;
			    let unmountCount = 0;
			
			    class Tester extends Component \{
			      public componentWillUnmount() \{
			        unmountCount++;
			      \}
			
			      public componentWillMount() \{
			        mountCount++;
			      \}
			
			      public render(\{ children \}) \{
			        return children;
			      \}
			    \}
			
			    render(createPortal([<Tester key=\{1\}>1</Tester>, <Tester key=\{2\}>2</Tester>, <Tester key=\{3\}>3</Tester>], portalContainer), container);
			    expect(portalContainer.innerHTML).toBe('123');
			    expect(container.innerHTML).toBe('');
			
			    expect(mountCount).toBe(3);
			    expect(unmountCount).toBe(0);
			
			    render(createPortal([<Tester key=\{3\}>3</Tester>, <Tester key=\{4\}>4</Tester>, <Tester key=\{1\}>1</Tester>], portalContainer), container);
			    expect(portalContainer.innerHTML).toBe('341');
			    expect(container.innerHTML).toBe('');
			
			    expect(mountCount).toBe(4);
			    expect(unmountCount).toBe(1);
			
			    render(createPortal(<Tester key=\{1\}>1</Tester>, portalContainer), container);
			    expect(portalContainer.innerHTML).toBe('1');
			    expect(container.innerHTML).toBe('');
			
			    expect(mountCount).toBe(5);
			    expect(unmountCount).toBe(4);
			
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			
			    expect(unmountCount).toBe(5);
			  \});
			
			  it('Should allow Fragments as portal content', () => \{
			    const portalContainer = document.createElement('div');
			    let mountCount = 0;
			    let unmountCount = 0;
			
			    class Tester extends Component \{
			      public componentWillUnmount() \{
			        unmountCount++;
			      \}
			
			      public componentWillMount() \{
			        mountCount++;
			      \}
			
			      public render(\{ children \}) \{
			        return children;
			      \}
			    \}
			
			    render(
			      createPortal(
			        <>
			          <Tester key=\{1\}>1</Tester>
			          <Tester key=\{2\}>2</Tester>
			          <Tester key=\{3\}>3</Tester>
			        </>,
			        portalContainer
			      ),
			      container
			    );
			    expect(portalContainer.innerHTML).toBe('123');
			    expect(container.innerHTML).toBe('');
			
			    expect(mountCount).toBe(3);
			    expect(unmountCount).toBe(0);
			
			    render(
			      createPortal(
			        <>
			          <Tester key=\{3\}>3</Tester>
			          <Tester key=\{4\}>4</Tester>
			          <Tester key=\{1\}>1</Tester>
			        </>,
			        portalContainer
			      ),
			      container
			    );
			    expect(portalContainer.innerHTML).toBe('341');
			    expect(container.innerHTML).toBe('');
			
			    expect(mountCount).toBe(4);
			    expect(unmountCount).toBe(1);
			
			    render(createPortal(<Tester key=\{1\}>1</Tester>, portalContainer), container);
			    expect(portalContainer.innerHTML).toBe('1');
			    expect(container.innerHTML).toBe('');
			
			    expect(mountCount).toBe(5);
			    expect(unmountCount).toBe(4);
			
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			
			    expect(unmountCount).toBe(5);
			  \});
			
			  it('Should mount/render/patch one portal', () => \{
			    const portalContainer = document.createElement('div');
			
			    render(<div>\{createPortal(<div>portal</div>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<div>portal</div>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Patch
			    render(<div>\{createPortal(<div>portal2</div>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<div>portal2</div>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Patch Remove contents
			    render(<div>\{createPortal(null, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Patch Add contents
			    render(<div>\{createPortal(<span>Fobba</span>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<span>Fobba</span>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Remove parent
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should move portal based on container', () => \{
			    const portalContainer = document.createElement('div');
			    const portalContainer2 = document.createElement('div');
			
			    render(<div>\{createPortal(<div>portal</div>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<div>portal</div>');
			    expect(portalContainer2.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Patch - change container
			    render(<div>\{createPortal(<div>portal2</div>, portalContainer2)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(portalContainer2.innerHTML).toBe('<div>portal2</div>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Patch Remove contents of old portal - both should be removed
			    render(<div>\{createPortal(null, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(portalContainer2.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Patch Add contents
			    render(<div>\{createPortal(<span>Fobba</span>, portalContainer2)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(portalContainer2.innerHTML).toBe('<span>Fobba</span>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    // Remove parent
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should render many portals', () => \{
			    const portalContainer1 = document.createElement('div');
			    const portalContainer2 = document.createElement('div');
			
			    const ops: string[] = [];
			
			    interface ChildProps \{
			      name: string;
			    \}
			
			    class Child extends Component<ChildProps> \{
			      public componentDidMount() \{
			        ops.push(\`\$\{this.props.name\} componentDidMount\`);
			      \}
			
			      public componentDidUpdate() \{
			        ops.push(\`\$\{this.props.name\} componentDidUpdate\`);
			      \}
			
			      public componentWillUnmount() \{
			        ops.push(\`\$\{this.props.name\} componentWillUnmount\`);
			      \}
			
			      public render() \{
			        return <div>\{this.props.name\}</div>;
			      \}
			    \}
			
			    interface ParentProps \{
			      step: string;
			    \}
			
			    class Parent extends Component<ParentProps> \{
			      public componentDidMount() \{
			        ops.push(\`Parent:\$\{this.props.step\} componentDidMount\`);
			      \}
			
			      public componentDidUpdate() \{
			        ops.push(\`Parent:\$\{this.props.step\} componentDidUpdate\`);
			      \}
			
			      public componentWillUnmount() \{
			        ops.push(\`Parent:\$\{this.props.step\} componentWillUnmount\`);
			      \}
			
			      public render() \{
			        const \{ step \} = this.props;
			
			        const portalOne = createPortal(<Child key="b" name=\{\`portal1[0]:\$\{step\}\`\} />, portalContainer1);
			
			        const portalTwo = createPortal(
			          <div>
			            <Child key="d" name=\{\`portal2[0]:\$\{step\}\`\} />
			            <Child key="e" name=\{\`portal2[1]:\$\{step\}\`\} />
			          </div>,
			          portalContainer2
			        );
			
			        return (
			          <div>
			            <Child key="a" name=\{\`normal[0]:\$\{step\}\`\} />
			            \{portalOne\}
			            <Child key="c" name=\{\`normal[1]:\$\{step\}\`\} />
			            \{portalTwo\}
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent step="a" />, container);
			
			    expect(portalContainer1.innerHTML).toBe('<div>portal1[0]:a</div>');
			    expect(portalContainer2.innerHTML).toBe('<div><div>portal2[0]:a</div><div>portal2[1]:a</div></div>');
			    expect(container.innerHTML).toBe('<div><div>normal[0]:a</div><div>normal[1]:a</div></div>');
			    expect(ops).toEqual([
			      'normal[0]:a componentDidMount',
			      'portal1[0]:a componentDidMount',
			      'normal[1]:a componentDidMount',
			      'portal2[0]:a componentDidMount',
			      'portal2[1]:a componentDidMount',
			      'Parent:a componentDidMount'
			    ]);
			
			    ops.length = 0;
			
			    render(<Parent step="b" />, container);
			    expect(portalContainer1.innerHTML).toBe('<div>portal1[0]:b</div>');
			    expect(portalContainer2.innerHTML).toBe('<div><div>portal2[0]:b</div><div>portal2[1]:b</div></div>');
			    expect(container.innerHTML).toBe('<div><div>normal[0]:b</div><div>normal[1]:b</div></div>');
			    expect(ops).toEqual([
			      'normal[0]:b componentDidUpdate',
			      'portal1[0]:b componentDidUpdate',
			      'normal[1]:b componentDidUpdate',
			      'portal2[0]:b componentDidUpdate',
			      'portal2[1]:b componentDidUpdate',
			      'Parent:b componentDidUpdate'
			    ]);
			
			    ops.length = 0;
			    render(null, container);
			    expect(portalContainer1.innerHTML).toBe('');
			    expect(portalContainer2.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			    expect(ops).toEqual([
			      'Parent:b componentWillUnmount',
			      'normal[0]:b componentWillUnmount',
			      'portal1[0]:b componentWillUnmount',
			      'normal[1]:b componentWillUnmount',
			      'portal2[0]:b componentWillUnmount',
			      'portal2[1]:b componentWillUnmount'
			    ]);
			  \});
			
			  it('should render nested portals', () => \{
			    const portalContainer1 = document.createElement('div');
			    const portalContainer2 = document.createElement('div');
			    const portalContainer3 = document.createElement('div');
			
			    render(
			      <div>
			        <div key="a">normal[0]</div>
			        \{createPortal(
			          <div>
			            <div key="b">portal1[0]</div>
			            \{createPortal(<div key="c">portal2[0]</div>, portalContainer2)\}
			            \{createPortal(<div key="d">portal3[0]</div>, portalContainer3)\}
			            <div key="e">portal1[1]</div>
			          </div>,
			          portalContainer1
			        )\}
			        <div key="f">normal[1]</div>
			      </div>,
			      container
			    );
			    expect(portalContainer1.innerHTML).toBe('<div><div>portal1[0]</div><div>portal1[1]</div></div>');
			    expect(portalContainer2.innerHTML).toBe('<div>portal2[0]</div>');
			    expect(portalContainer3.innerHTML).toBe('<div>portal3[0]</div>');
			    expect(container.innerHTML).toBe('<div><div>normal[0]</div><div>normal[1]</div></div>');
			
			    render(null, container);
			    expect(portalContainer1.innerHTML).toBe('');
			    expect(portalContainer2.innerHTML).toBe('');
			    expect(portalContainer3.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should reconcile portal children', () => \{
			    const portalContainer = document.createElement('div');
			
			    render(<div>\{createPortal(<div>portal:1</div>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<div>portal:1</div>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(<div>\{createPortal(<div>portal:2</div>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<div>portal:2</div>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(<div>\{createPortal(<p>portal:3</p>, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('<p>portal:3</p>');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(<div>\{createPortal(<span>\{['Hi', 'Bye']\}</span>, portalContainer)\}</div>, container);
			    expect(portalContainer.textContent).toBe('HiBye');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(<div>\{createPortal(<span>\{['Bye', 'Hi']\}</span>, portalContainer)\}</div>, container);
			    expect(portalContainer.textContent).toBe('ByeHi');
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(<div>\{createPortal(null, portalContainer)\}</div>, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('<div></div>');
			  \});
			
			  it('should keep track of namespace across portals (simple)', () => \{
			    assertNamespacesMatch(
			      <svg \{...expectSVG\}>
			        <image \{...expectSVG\} />
			        \{usePortal(<div \{...expectHTML\} />)\}
			        <image \{...expectSVG\} />
			      </svg>
			    );
			    assertNamespacesMatch(
			      <math \{...expectMath\}>
			        <mi \{...expectMath\} />
			        \{usePortal(<div \{...expectHTML\} />)\}
			        <mi \{...expectMath\} />
			      </math>
			    );
			    assertNamespacesMatch(
			      <div \{...expectHTML\}>
			        <p \{...expectHTML\} />
			        \{usePortal(
			          <svg \{...expectSVG\}>
			            <image \{...expectSVG\} />
			          </svg>
			        )\}
			        <p \{...expectHTML\} />
			      </div>
			    );
			  \});
			
			  it('should keep track of namespace across portals (medium)', () => \{
			    assertNamespacesMatch(
			      <svg \{...expectSVG\}>
			        <image \{...expectSVG\} />
			        \{usePortal(<div \{...expectHTML\} />)\}
			        <image \{...expectSVG\} />
			        \{usePortal(<div \{...expectHTML\} />)\}
			        <image \{...expectSVG\} />
			      </svg>
			    );
			    assertNamespacesMatch(
			      <div \{...expectHTML\}>
			        <math \{...expectMath\}>
			          <mi \{...expectMath\} />
			          \{usePortal(
			            <svg \{...expectSVG\}>
			              <image \{...expectSVG\} />
			            </svg>
			          )\}
			        </math>
			        <p \{...expectHTML\} />
			      </div>
			    );
			    assertNamespacesMatch(
			      <math \{...expectMath\}>
			        <mi \{...expectMath\} />
			        \{usePortal(
			          <svg \{...expectSVG\}>
			            <image \{...expectSVG\} />
			            <foreignObject \{...expectSVG\}>
			              <p \{...expectHTML\} />
			              <math \{...expectMath\}>
			                <mi \{...expectMath\} />
			              </math>
			              <p \{...expectHTML\} />
			            </foreignObject>
			            <image \{...expectSVG\} />
			          </svg>
			        )\}
			        <mi \{...expectMath\} />
			      </math>
			    );
			    assertNamespacesMatch(
			      <div \{...expectHTML\}>
			        \{usePortal(
			          <svg \{...expectSVG\}>
			            \{usePortal(<div \{...expectHTML\} />)\}
			            <image \{...expectSVG\} />
			          </svg>
			        )\}
			        <p \{...expectHTML\} />
			      </div>
			    );
			    assertNamespacesMatch(
			      <svg \{...expectSVG\}>
			        <svg \{...expectSVG\}>
			          \{usePortal(<div \{...expectHTML\} />)\}
			          <image \{...expectSVG\} />
			        </svg>
			        <image \{...expectSVG\} />
			      </svg>
			    );
			  \});
			
			  it('should keep track of namespace across portals (complex)', () => \{
			    assertNamespacesMatch(
			      <div \{...expectHTML\}>
			        \{usePortal(
			          <svg \{...expectSVG\}>
			            <image \{...expectSVG\} />
			          </svg>
			        )\}
			        <p \{...expectHTML\} />
			        <svg \{...expectSVG\}>
			          <image \{...expectSVG\} />
			        </svg>
			        <svg \{...expectSVG\}>
			          <svg \{...expectSVG\}>
			            <image \{...expectSVG\} />
			          </svg>
			          <image \{...expectSVG\} />
			        </svg>
			        <p \{...expectHTML\} />
			      </div>
			    );
			    assertNamespacesMatch(
			      <div \{...expectHTML\}>
			        <svg \{...expectSVG\}>
			          <svg \{...expectSVG\}>
			            <image \{...expectSVG\} />
			            \{usePortal(
			              <svg \{...expectSVG\}>
			                <image \{...expectSVG\} />
			                <svg \{...expectSVG\}>
			                  <image \{...expectSVG\} />
			                </svg>
			                <image \{...expectSVG\} />
			              </svg>
			            )\}
			            <image \{...expectSVG\} />
			            <foreignObject \{...expectSVG\}>
			              <p \{...expectHTML\} />
			              \{usePortal(<p \{...expectHTML\} />)\}
			              <p \{...expectHTML\} />
			            </foreignObject>
			          </svg>
			          <image \{...expectSVG\} />
			        </svg>
			        <p \{...expectHTML\} />
			      </div>
			    );
			    assertNamespacesMatch(
			      <div \{...expectHTML\}>
			        <svg \{...expectSVG\}>
			          <foreignObject \{...expectSVG\}>
			            <p \{...expectHTML\} />
			            \{usePortal(
			              <svg \{...expectSVG\}>
			                <image \{...expectSVG\} />
			                <svg \{...expectSVG\}>
			                  <image \{...expectSVG\} />
			                  <foreignObject \{...expectSVG\}>
			                    <p \{...expectHTML\} />
			                  </foreignObject>
			                  \{usePortal(<p \{...expectHTML\} />)\}
			                </svg>
			                <image \{...expectSVG\} />
			              </svg>
			            )\}
			            <p \{...expectHTML\} />
			          </foreignObject>
			          <image \{...expectSVG\} />
			        </svg>
			        <p \{...expectHTML\} />
			      </div>
			    );
			  \});
			
			  it('should unwind namespaces on uncaught errors', () => \{
			    function BrokenRender() \{
			      throw new Error('Hello');
			    \}
			
			    expect(() => \{
			      assertNamespacesMatch(
			        <svg \{...expectSVG\}>
			          <BrokenRender />
			        </svg>
			      );
			    \}).toThrow(); // Hello
			
			    assertNamespacesMatch(<div \{...expectHTML\} />);
			  \});
			
			  it('should pass portal context when rendering subtree elsewhere', () => \{
			    const portalContainer = document.createElement('div');
			
			    class Comp extends Component \{
			      public render() \{
			        return <div>\{this.context.foo\}</div>;
			      \}
			    \}
			
			    class Parent extends Component \{
			      public getChildContext() \{
			        return \{
			          foo: 'bar'
			        \};
			      \}
			
			      public render() \{
			        return createPortal(<Comp />, portalContainer);
			      \}
			    \}
			
			    render(<Parent />, container);
			    expect(container.innerHTML).toBe('');
			    expect(portalContainer.innerHTML).toBe('<div>bar</div>');
			  \});
			
			  it('should update portal context if it changes due to setState', () => \{
			    const portalContainer = document.createElement('div');
			
			    class Comp extends Component \{
			      public render() \{
			        return <div>\{this.context.foo + '-' + this.context.getFoo()\}</div>;
			      \}
			    \}
			
			    class Parent extends Component \{
			      public state = \{
			        bar: 'initial'
			      \};
			
			      public getChildContext() \{
			        return \{
			          foo: this.state.bar,
			          getFoo: () => this.state.bar
			        \};
			      \}
			
			      public render() \{
			        return createPortal(<Comp />, portalContainer);
			      \}
			    \}
			    const instance = render(<Parent />, container);
			    expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
			    expect(container.innerHTML).toBe('');
			
			    instance.setState(\{ bar: 'changed' \});
			
			    expect(portalContainer.innerHTML).toBe('<div>changed-changed</div>');
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should update portal context if it changes due to re-render', () => \{
			    const portalContainer = document.createElement('div');
			
			    class Comp extends Component \{
			      public render() \{
			        return <div>\{this.context.foo + '-' + this.context.getFoo()\}</div>;
			      \}
			    \}
			
			    interface ParentProps \{
			      bar: string;
			    \}
			
			    class Parent extends Component<ParentProps> \{
			      public getChildContext() \{
			        return \{
			          foo: this.props.bar,
			          getFoo: () => this.props.bar
			        \};
			      \}
			
			      public render() \{
			        return createPortal(<Comp />, portalContainer);
			      \}
			    \}
			
			    render(<Parent bar="initial" />, container);
			    expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
			    expect(container.innerHTML).toBe('');
			
			    render(<Parent bar="changed" />, container);
			    expect(portalContainer.innerHTML).toBe('<div>changed-changed</div>');
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should update portal context if it changes due to re-render - functional comps', () => \{
			    const portalContainer = document.createElement('div');
			
			    function Comp(_, \{ foo, getFoo \}) \{
			      return <div>\{foo + '-' + getFoo()\}</div>;
			    \}
			
			    interface ParentProps \{
			      bar: string;
			    \}
			
			    class Parent extends Component<ParentProps> \{
			      public getChildContext() \{
			        return \{
			          foo: this.props.bar,
			          getFoo: () => this.props.bar
			        \};
			      \}
			
			      public render() \{
			        return createPortal(<Comp />, portalContainer);
			      \}
			    \}
			
			    render(<Parent bar="initial" />, container);
			    expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
			    expect(container.innerHTML).toBe('');
			
			    render(<Parent bar="changed" />, container);
			    expect(portalContainer.innerHTML).toBe('<div>changed-changed</div>');
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should update portal context if it changes due to re-render - functional comps #2', () => \{
			    const portalContainer = document.createElement('div');
			
			    function Comp(\{ foo \}) \{
			      return <div>\{foo\}</div>;
			    \}
			
			    function Parent(\{ bar \}) \{
			      return createPortal(<Comp foo=\{bar\} />, portalContainer);
			    \}
			
			    render(<Parent bar="initial" />, container);
			    expect(portalContainer.innerHTML).toBe('<div>initial</div>');
			    expect(container.innerHTML).toBe('');
			
			    render(<Parent bar="changed" />, container);
			    expect(portalContainer.innerHTML).toBe('<div>changed</div>');
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			    expect(portalContainer.innerHTML).toBe('');
			    expect(container.innerHTML).toBe('');
			  \});
			
			  describe('Changing portal to other type of vNode', () => \{
			    it('Should remove portal from its container when its replaced by div', () => \{
			      const portalContainer = document.createElement('div');
			
			      function Comp(\{ foo \}) \{
			        return <div>\{foo\}</div>;
			      \}
			
			      function Parent(\{ bar, port \}) \{
			        let innerContent;
			
			        if (port) \{
			          innerContent = createPortal(<Comp foo=\{bar\} />, portalContainer);
			        \} else \{
			          innerContent = <div>\{bar\}</div>;
			        \}
			
			        return <div>\{innerContent\}</div>;
			      \}
			
			      render(<Parent port=\{false\} bar="initial" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div><div>initial</div></div>');
			
			      render(<Parent port=\{true\} bar="changed" />, container);
			      expect(portalContainer.innerHTML).toBe('<div>changed</div>');
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<Parent port=\{false\} bar="triple" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div><div>triple</div></div>');
			
			      render(null, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should remove portal from its container when its replaced by class component', () => \{
			      const portalContainer = document.createElement('div');
			
			      class Comp extends Component \{
			        public render(\{ children \}) \{
			          return <div>\{children\}</div>;
			        \}
			      \}
			
			      function Parent(\{ bar, port \}) \{
			        let innerContent;
			
			        if (port) \{
			          innerContent = createPortal(<Comp children=\{bar\} />, portalContainer);
			        \} else \{
			          innerContent = (
			            <Comp>
			              <span>\{bar\}</span>
			            </Comp>
			          );
			        \}
			
			        return <div>\{innerContent\}</div>;
			      \}
			
			      render(<Parent port=\{false\} bar="initial" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div><div><span>initial</span></div></div>');
			
			      render(<Parent port=\{true\} bar="changed" />, container);
			      expect(portalContainer.innerHTML).toBe('<div>changed</div>');
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<Parent port=\{false\} bar="triple" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div><div><span>triple</span></div></div>');
			
			      render(null, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should remove portal from its container when its replaced by functional component', () => \{
			      const portalContainer = document.createElement('div');
			
			      function Comp(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			
			      function Parent(\{ bar, port \}) \{
			        let innerContent;
			
			        if (port) \{
			          innerContent = createPortal(<Comp children=\{bar\} />, portalContainer);
			        \} else \{
			          innerContent = (
			            <Comp>
			              <span>\{bar\}</span>
			            </Comp>
			          );
			        \}
			
			        return <div>\{innerContent\}</div>;
			      \}
			
			      render(<Parent port=\{false\} bar="initial" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div><div><span>initial</span></div></div>');
			
			      render(<Parent port=\{true\} bar="changed" />, container);
			      expect(portalContainer.innerHTML).toBe('<div>changed</div>');
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<Parent port=\{false\} bar="triple" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div><div><span>triple</span></div></div>');
			
			      render(null, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should remove portal from its container when its replaced by invalid node', () => \{
			      const portalContainer = document.createElement('div');
			
			      function Comp(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			
			      function Parent(\{ bar, port \}) \{
			        let innerContent;
			
			        if (port) \{
			          innerContent = createPortal(<Comp children=\{bar\} />, portalContainer);
			        \} else \{
			          innerContent = false;
			        \}
			
			        return <div>\{innerContent\}</div>;
			      \}
			
			      render(<Parent port=\{false\} bar="initial" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<Parent port=\{true\} bar="changed" />, container);
			      expect(portalContainer.innerHTML).toBe('<div>changed</div>');
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<Parent port=\{false\} bar="triple" />, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(null, container);
			      expect(portalContainer.innerHTML).toBe('');
			      expect(container.innerHTML).toBe('');
			    \});
			
			    describe('Multiple portals', () => \{
			      it('#1', () => \{
			        const portalContainer = document.createElement('div');
			
			        let mountCount = 0;
			        let unMountCount = 0;
			
			        class Comp extends Component \{
			          public componentWillMount() \{
			            mountCount++;
			          \}
			
			          public componentWillUnmount() \{
			            unMountCount++;
			          \}
			
			          public render(\{ children \}) \{
			            return <div>\{children\}</div>;
			          \}
			        \}
			
			        function Parent(\{ port \}) \{
			          let innerContent;
			
			          if (port) \{
			            innerContent = [
			              createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			              createPortal(<Comp key=\{2\} children=\{2\} />, portalContainer),
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer)
			            ];
			          \} else \{
			            innerContent = false;
			          \}
			
			          return <div>\{innerContent\}</div>;
			        \}
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('<div></div>');
			        expect(mountCount).toBe(0);
			        expect(unMountCount).toBe(0);
			
			        render(<Parent port=\{true\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>2</div><div>3</div>');
			        expect(container.innerHTML).toBe('<div></div>');
			        expect(mountCount).toBe(3);
			        expect(unMountCount).toBe(0);
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('<div></div>');
			        expect(mountCount).toBe(3);
			        expect(unMountCount).toBe(3);
			
			        render(null, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('');
			        expect(mountCount).toBe(3);
			        expect(unMountCount).toBe(3);
			      \});
			
			      it('#2', () => \{
			        const portalContainer = document.createElement('div');
			
			        let mountCount = 0;
			        let unMountCount = 0;
			
			        class Comp extends Component \{
			          public componentWillMount() \{
			            mountCount++;
			          \}
			
			          public componentWillUnmount() \{
			            unMountCount++;
			          \}
			
			          public render(\{ children \}) \{
			            return <div>\{children\}</div>;
			          \}
			        \}
			
			        function Parent(\{ port, nothing \}: \{ port?: boolean; nothing?: boolean \}) \{
			          let innerContent;
			
			          if (!nothing) \{
			            if (port) \{
			              innerContent = [
			                createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			                createPortal(<Comp key=\{2\} children=\{2\} />, portalContainer),
			                createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer)
			              ];
			            \} else \{
			              innerContent = [
			                createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			                createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer),
			                createPortal(<Comp key=\{5\} children=\{5\} />, portalContainer)
			              ];
			            \}
			          \}
			
			          return <div>\{innerContent\}</div>;
			        \}
			
			        render(<Parent nothing=\{true\} port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('<div></div>');
			        expect(mountCount).toBe(0);
			        expect(unMountCount).toBe(0);
			
			        render(<Parent port=\{true\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>2</div><div>3</div>');
			        expect(container.innerHTML).toBe('<div></div>');
			        expect(mountCount).toBe(3);
			        expect(unMountCount).toBe(0);
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>3</div><div>5</div>');
			        expect(container.innerHTML).toBe('<div></div>');
			        expect(mountCount).toBe(4); // 5 is new
			        expect(unMountCount).toBe(1); // 2 is dead
			
			        render(null, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('');
			        expect(mountCount).toBe(4);
			        expect(unMountCount).toBe(4);
			      \});
			
			      it('Should be possible to move nodes around portals #1', () => \{
			        const portalContainer = document.createElement('div');
			
			        let mountCount = 0;
			        let unMountCount = 0;
			
			        class Comp extends Component \{
			          public componentWillMount() \{
			            mountCount++;
			          \}
			
			          public componentWillUnmount() \{
			            unMountCount++;
			          \}
			
			          public render(\{ children \}) \{
			            return <div>\{children\}</div>;
			          \}
			        \}
			
			        function Parent(\{ port \}: \{ port?: boolean \}) \{
			          let innerContent;
			
			          if (port) \{
			            innerContent = [
			              <span key="a">a</span>,
			              createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			              <span key="b">b</span>,
			              createPortal(<Comp key=\{2\} children=\{2\} />, portalContainer),
			              <span key="c">c</span>,
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer)
			            ];
			          \} else \{
			            innerContent = [
			              createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			              <span key="c">c</span>,
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer),
			              createPortal(<Comp key=\{5\} children=\{5\} />, portalContainer),
			              <span key="a">a</span>,
			              <span key="b">b</span>
			            ];
			          \}
			
			          return <div>\{innerContent\}</div>;
			        \}
			
			        render(<Parent port=\{true\} />, container);
			        expect(container.innerHTML).toBe('<div><span>a</span><span>b</span><span>c</span></div>');
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>2</div><div>3</div>');
			        expect(mountCount).toBe(3);
			        expect(unMountCount).toBe(0);
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>3</div><div>5</div>');
			        expect(container.innerHTML).toBe('<div><span>c</span><span>a</span><span>b</span></div>');
			        expect(mountCount).toBe(4);
			        expect(unMountCount).toBe(1);
			
			        render(null, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('');
			        expect(mountCount).toBe(4);
			        expect(unMountCount).toBe(4);
			      \});
			
			      it('Should be possible to move nodes around portals #2', () => \{
			        const portalContainer = document.createElement('div');
			
			        let mountCount = 0;
			        let unMountCount = 0;
			
			        class Comp extends Component \{
			          public componentWillMount() \{
			            mountCount++;
			          \}
			
			          public componentWillUnmount() \{
			            unMountCount++;
			          \}
			
			          public render(\{ children \}) \{
			            return <div>\{children\}</div>;
			          \}
			        \}
			
			        function Parent(\{ port \}: \{ port?: boolean \}) \{
			          let innerContent;
			
			          if (port) \{
			            innerContent = [
			              <span key="a">a</span>,
			              createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			              <span key="b">b</span>,
			              createPortal(<Comp key=\{2\} children=\{2\} />, portalContainer),
			              <span key="c">c</span>,
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer)
			            ];
			          \} else \{
			            innerContent = [
			              createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			              <span key="c">c</span>,
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer),
			              createPortal(<Comp key=\{5\} children=\{5\} />, portalContainer),
			              <span key="a">a</span>,
			              <span key="b">b</span>
			            ];
			          \}
			
			          return <div>\{innerContent\}</div>;
			        \}
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>3</div><div>5</div>');
			        expect(container.innerHTML).toBe('<div><span>c</span><span>a</span><span>b</span></div>');
			
			        render(<Parent port=\{true\} />, container);
			        expect(container.innerHTML).toBe('<div><span>a</span><span>b</span><span>c</span></div>');
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>3</div><div>2</div>'); // <= Portal order is based on creation
			
			        render(null, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('');
			        expect(mountCount).toBe(4);
			        expect(unMountCount).toBe(4);
			      \});
			
			      it('Should be possible to move nodes around portals when portal is root node of component #1', () => \{
			        const portalContainer = document.createElement('div');
			
			        let mountCount = 0;
			        let unMountCount = 0;
			
			        class WrapPortal extends Component \{
			          public render(\{ children \}) \{
			            return createPortal(<Comp>\{children\}</Comp>, portalContainer);
			          \}
			        \}
			
			        class Comp extends Component \{
			          public componentWillMount() \{
			            mountCount++;
			          \}
			
			          public componentWillUnmount() \{
			            unMountCount++;
			          \}
			
			          public render(\{ children \}) \{
			            return <div>\{children\}</div>;
			          \}
			        \}
			
			        function Parent(\{ port \}) \{
			          let innerContent;
			
			          if (port) \{
			            innerContent = [
			              <span key="a">a</span>,
			              <WrapPortal key=\{1\}>1</WrapPortal>,
			              <span key="b">b</span>,
			              createPortal(<Comp key=\{2\} children=\{2\} />, portalContainer),
			              <span key="c">c</span>,
			              <WrapPortal key=\{3\}>3</WrapPortal>
			            ];
			          \} else \{
			            innerContent = [
			              createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			              <span key="c">c</span>,
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer),
			              createPortal(<Comp key=\{5\} children=\{5\} />, portalContainer),
			              <span key="a">a</span>,
			              <span key="b">b</span>
			            ];
			          \}
			
			          return <div>\{innerContent\}</div>;
			        \}
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>3</div><div>5</div>');
			        expect(container.innerHTML).toBe('<div><span>c</span><span>a</span><span>b</span></div>');
			
			        render(<Parent port=\{true\} />, container);
			        expect(container.innerHTML).toBe('<div><span>a</span><span>b</span><span>c</span></div>');
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>3</div><div>2</div>'); // <= Portal order is based on creation
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>3</div><div>5</div>');
			        expect(container.innerHTML).toBe('<div><span>c</span><span>a</span><span>b</span></div>');
			
			        render(null, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('');
			        expect(mountCount).toBe(9);
			        expect(unMountCount).toBe(9);
			      \});
			
			      it('Should be possible to move nodes around portals when portal is root node of component #2', () => \{
			        const portalContainer = document.createElement('div');
			
			        let mountCount = 0;
			        let unMountCount = 0;
			
			        class WrapPortal extends Component \{
			          public render(\{ children \}) \{
			            return createPortal(<Comp>\{children\}</Comp>, portalContainer);
			          \}
			        \}
			
			        class Comp extends Component \{
			          public componentWillMount() \{
			            mountCount++;
			          \}
			
			          public componentWillUnmount() \{
			            unMountCount++;
			          \}
			
			          public render(\{ children \}) \{
			            return <div>\{children\}</div>;
			          \}
			        \}
			
			        function Parent(\{ port \}) \{
			          let innerContent;
			
			          if (port) \{
			            innerContent = [
			              <span key="A">A</span>,
			              <WrapPortal key=\{1\}>1</WrapPortal>,
			              <WrapPortal key=\{2\}>2</WrapPortal>,
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer),
			              <WrapPortal key=\{4\}>
			                <WrapPortal>
			                  <WrapPortal>inner</WrapPortal>
			                </WrapPortal>
			              </WrapPortal>,
			              <span key="B">B</span>,
			              <WrapPortal key=\{5\}>5</WrapPortal>
			            ];
			          \} else \{
			            innerContent = [
			              createPortal(<Comp key=\{1\} children=\{1\} />, portalContainer),
			              <span key="C">C</span>,
			              <WrapPortal key=\{4\}>
			                <span>XX</span>
			              </WrapPortal>, // <== Change nested portal into component span and move it
			              createPortal(<Comp key=\{3\} children=\{3\} />, portalContainer),
			              <WrapPortal key=\{5\}>5</WrapPortal>,
			              <span key="A">A</span>,
			              <span key="B">B</span>
			            ];
			          \}
			
			          return <div>\{innerContent\}</div>;
			        \}
			
			        render(<Parent port=\{true\} />, container);
			        // 3 5 1 inner 2
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>2</div><div>3</div><div>inner</div><div></div><div></div><div>5</div>');
			        expect(container.innerHTML).toBe('<div><span>A</span><span>B</span></div>');
			        expect(mountCount).toBe(7);
			        expect(unMountCount).toBe(0);
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>3</div><div><span>XX</span></div><div>5</div><div>1</div>');
			        expect(container.innerHTML).toBe('<div><span>C</span><span>A</span><span>B</span></div>');
			
			        render(<Parent port=\{true\} />, container);
			        // 3 5 1 inner 2
			        expect(portalContainer.innerHTML).toBe('<div>3</div><div></div><div>5</div><div>1</div><div>inner</div><div></div><div>2</div>');
			        expect(container.innerHTML).toBe('<div><span>A</span><span>B</span></div>');
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div>3</div><div><span>XX</span></div><div>5</div><div>1</div>');
			        expect(container.innerHTML).toBe('<div><span>C</span><span>A</span><span>B</span></div>');
			
			        render(null, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to patch portal non keyed', () => \{
			        const portalContainer = document.createElement('div');
			
			        let mountCount = 0;
			        let unMountCount = 0;
			
			        class WrapPortal extends Component \{
			          public render(\{ children \}) \{
			            return createPortal(<Comp>\{children\}</Comp>, portalContainer);
			          \}
			        \}
			
			        class Comp extends Component \{
			          public componentWillMount() \{
			            mountCount++;
			          \}
			
			          public componentWillUnmount() \{
			            unMountCount++;
			          \}
			
			          public render(\{ children \}) \{
			            return <div>\{children\}</div>;
			          \}
			        \}
			
			        function Parent(\{ port \}) \{
			          let innerContent;
			
			          if (port) \{
			            innerContent = [
			              <span>A</span>,
			              <WrapPortal>1</WrapPortal>,
			              <WrapPortal>2</WrapPortal>,
			              createPortal(<Comp children=\{3\} />, portalContainer),
			              <WrapPortal>
			                <WrapPortal>
			                  <WrapPortal>inner</WrapPortal>
			                </WrapPortal>
			              </WrapPortal>,
			              <span>B</span>,
			              <WrapPortal>5</WrapPortal>
			            ];
			          \} else \{
			            innerContent = [
			              createPortal(<Comp children=\{1\} />, portalContainer),
			              <span>C</span>,
			              <WrapPortal>
			                <span>XX</span>
			              </WrapPortal>, // <== Change nested portal into component span and move it
			              createPortal(<Comp children=\{3\} />, portalContainer),
			              <WrapPortal>5</WrapPortal>,
			              <span>A</span>,
			              <span>B</span>
			            ];
			          \}
			
			          return <div>\{innerContent\}</div>;
			        \}
			
			        render(<Parent port=\{true\} />, container);
			        // 3 5 1 inner 2
			        expect(portalContainer.innerHTML).toBe('<div>1</div><div>2</div><div>3</div><div>inner</div><div></div><div></div><div>5</div>');
			        expect(container.innerHTML).toBe('<div><span>A</span><span>B</span></div>');
			
			        render(<Parent port=\{false\} />, container);
			        expect(portalContainer.innerHTML).toBe('<div><span>XX</span></div><div>3</div><div>5</div><div>1</div>');
			        expect(container.innerHTML).toBe('<div><span>C</span><span>A</span><span>B</span></div>');
			
			        render(<Parent port=\{true\} />, container);
			        // 3 5 1 inner 2
			        expect(portalContainer.innerHTML).toBe('<div>2</div><div>3</div><div></div><div>1</div><div>inner</div><div></div><div>5</div>');
			        expect(container.innerHTML).toBe('<div><span>A</span><span>B</span></div>');
			
			        render(null, container);
			        expect(portalContainer.innerHTML).toBe('');
			        expect(container.innerHTML).toBe('');
			
			        expect(mountCount).toBe(12);
			        expect(unMountCount).toBe(12);
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\portal.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(28)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\rendering.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createTextVNode, createVNode, render, rerender \} from 'inferno';
			import \{ ChildFlags, VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('rendering routine', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should throw error when trying to render to document.body', () => \{
			    const div = createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('1'), ChildFlags.HasVNodeChildren);
			    try \{
			      render(div, document.body);
			    \} catch (e) \{
			      expect(e.message).toEqual('Inferno Error: you cannot render() to the "document.body". Use an empty element as a container instead.');
			    \}
			  \});
			
			  it('Should throw error if second parameter is not given', () => \{
			    expect(() => render(<div>1</div>, null)).toThrow();
			  \});
			
			  it('Should create new object when dom exists', () => \{
			    const bar = createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('123'), ChildFlags.HasVNodeChildren);
			    const foo = createVNode(VNodeFlags.HtmlElement, 'div', null, bar, ChildFlags.HasVNodeChildren);
			
			    render(foo, container);
			    expect(container.innerHTML).toEqual('<div><div>123</div></div>');
			
			    render(null, container);
			
			    render(foo, container);
			    expect(container.innerHTML).toEqual('<div><div>123</div></div>');
			  \});
			
			  it('should be called a callback argument', () => \{
			    // mounting phase
			    let called = false;
			    render(<div>Foo</div>, container, () => (called = true));
			    expect(called).toEqual(true);
			
			    // updating phase
			    called = false;
			    render(<div>Foo</div>, container, () => (called = true));
			    expect(called).toEqual(true);
			  \});
			
			  it('should call a callback argument when the same element is re-rendered', () => \{
			    class Foo extends Component \{
			      public render() \{
			        return <div>Foo</div>;
			      \}
			    \}
			    const element = <Foo />;
			
			    // mounting phase
			    let called = false;
			    render(element, container, () => (called = true));
			    expect(called).toEqual(true);
			
			    // updating phase
			    called = false;
			
			    render(element, container, () => (called = true));
			
			    expect(called).toEqual(true);
			  \});
			
			  it('should render a component returning strings directly from render', () => \{
			    const Text = (\{ value \}) => value;
			
			    render(<Text value="foo" />, container);
			    expect(container.textContent).toEqual('foo');
			  \});
			
			  it('should render a component returning numbers directly from render', () => \{
			    const Text = (\{ value \}) => value;
			
			    render(<Text value=\{10\} />, container);
			
			    expect(container.textContent).toEqual('10');
			  \});
			
			  it('should not crash encountering low-priority tree', () => \{
			    render(
			      <div hidden=\{true\}>
			        <div />
			      </div>,
			      container
			    );
			  \});
			
			  it('should not warn when rendering into an empty container', () => \{
			    const consoleSpy = spyOn(console, 'error');
			
			    render(<div>foo</div>, container);
			    expect(container.innerHTML).toBe('<div>foo</div>');
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			    expect(consoleSpy.calls.count()).toBe(0);
			
			    render(<div>bar</div>, container);
			    expect(container.innerHTML).toBe('<div>bar</div>');
			
			    expect(consoleSpy.calls.count()).toBe(0);
			  \});
			
			  it('Should be possible to render Immutable datastructures', () => \{
			    function Clock(props) \{
			      const time = props.time + 1;
			      const array = Object.freeze([<span>\{'Inferno version:'\}</span>, <br />, <span>\{time\}</span>]);
			      return <div>\{array\}</div>;
			    \}
			
			    const consoleSpy = spyOn(console, 'error');
			
			    render(<Clock time=\{1\} />, container);
			    expect(container.innerHTML).toBe('<div><span>Inferno version:</span><br><span>2</span></div>');
			
			    render(<Clock time=\{2\} />, container);
			    expect(container.innerHTML).toBe('<div><span>Inferno version:</span><br><span>3</span></div>');
			
			    render(<Clock time=\{3\} />, container);
			    expect(container.innerHTML).toBe('<div><span>Inferno version:</span><br><span>4</span></div>');
			    expect(consoleSpy.calls.count()).toBe(0);
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			
			    expect(consoleSpy.calls.count()).toBe(0);
			  \});
			
			  describe('createTextVNode', () => \{
			    it('null/undefined textNodes should render empty text', () => \{
			      render(<div>\{createTextVNode(null)\}</div>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      render(<div>\{createTextVNode(undefined)\}</div>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      render(<div>\{createTextVNode('')\}</div>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			
			    it('Should render 0 as "0"', () => \{
			      render(<div>\{createTextVNode(0)\}</div>, container);
			
			      expect(container.innerHTML).toEqual('<div>0</div>');
			
			      render(<div>\{createTextVNode('0')\}</div>, container);
			
			      expect(container.innerHTML).toEqual('<div>0</div>');
			
			      render(<div>\{createTextVNode('')\}</div>, container);
			
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			  \});
			
			  describe('className', () => \{
			    it('Should override destructured property when defined', function () \{
			      const testObj = \{
			        className: 'test'
			      \};
			
			      render(<div \{...testObj\} className="bar" />, container);
			
			      expect(container.innerHTML).toEqual('<div class="bar"></div>');
			    \});
			  \});
			
			  describe('Swapping children', () => \{
			    it('Swapping children in component should affect hoisted children', () => \{
			      interface HelloProps \{
			        name: string;
			      \}
			
			      class Hello extends Component<HelloProps> \{
			        public render(props) \{
			          const child = props.children;
			
			          child.reverse();
			
			          return <div>Hello \{child\}</div>;
			        \}
			      \}
			
			      const data = [1, 2];
			
			      render(
			        <div>
			          <Hello name="World">\{data\}</Hello>
			          <Hello name="World">\{data\}</Hello>
			          <Hello name="World">\{data\}</Hello>
			        </div>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>Hello 21</div><div>Hello 12</div><div>Hello 21</div></div>');
			
			      render(
			        <div>
			          <Hello name="World">\{data\}</Hello>
			          <Hello name="World">\{data\}</Hello>
			          <Hello name="World">\{data\}</Hello>
			        </div>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>Hello 12</div><div>Hello 21</div><div>Hello 12</div></div>');
			    \});
			  \});
			
			  // https://jsfiddle.net/Ldqyu475/
			  describe('render during component construction', () => \{
			    it('Should queue updates and not fail if HOC updates during child component construction', () => \{
			      interface HelloProps \{
			        name?: string;
			        tag: number;
			        callback: () => void;
			      \}
			      interface HelloState \{
			        foo: string;
			      \}
			
			      class Hello extends Component<HelloProps, HelloState> \{
			        public state: HelloState;
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{ foo: 'foobar' \};
			
			          // expect(container.innerHTML).toBe('');
			          expect(this.props.tag).toBe(0);
			          props.callback();
			          // expect(container.innerHTML).toBe('');
			          expect(this.props.tag).toBe(0);
			          props.callback();
			          // expect(container.innerHTML).toBe('');
			          expect(this.props.tag).toBe(0);
			          props.callback();
			          // expect(container.innerHTML).toBe('');
			          expect(this.props.tag).toBe(0);
			        \}
			
			        public render() \{
			          return (
			            <div>
			              Hello \{this.props.name\} \{this.props.tag\} \{this.state.foo\}
			            </div>
			          );
			        \}
			      \}
			
			      interface HOCProps \{
			        name?: string;
			        renderAgain: () => void;
			      \}
			
			      interface HOCState \{
			        tag: number;
			      \}
			
			      class HOC extends Component<HOCProps, HOCState> \{
			        public state: HOCState;
			
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{ tag: 0 \};
			
			          this.renderAgain = this.renderAgain.bind(this);
			        \}
			
			        public renderAgain() \{
			          this.props.renderAgain();
			        \}
			
			        public render() \{
			          return (
			            <div>
			              \{this.state.tag > 0 ? <div>1</div> : null\}
			              \{this.state.tag > 1 ? <div>1</div> : null\}
			              <Hello name=\{this.props.name\} tag=\{this.state.tag\} callback=\{this.renderAgain\} />
			              <span>2</span>
			            </div>
			          );
			        \}
			      \}
			
			      interface ParentState \{
			        foo: boolean;
			      \}
			
			      class Parent extends Component<unknown, ParentState> \{
			        public state: ParentState;
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: false
			          \};
			        \}
			        public render() \{
			          return (
			            <span id="click" onClick=\{() => this.setState(\{ foo: !this.state.foo \})\}>
			              \{this.state.foo ? <HOC renderAgain=\{() => this.setState(\{\})\} /> : null\}
			            </span>
			          );
			        \}
			      \}
			
			      render(<Parent />, container);
			
			      expect(container.innerHTML).toBe('<span id="click"></span>');
			
			      container.querySelector('#click').click();
			      rerender();
			
			      expect(container.innerHTML).toBe('<span id="click"><div><div>Hello  0 foobar</div><span>2</span></div></span>');
			
			      container.querySelector('#click').click();
			      rerender();
			
			      expect(container.innerHTML).toBe('<span id="click"></span>');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\rendering.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(15)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\select.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ triggerEvent \} from 'inferno-utils';
			
			describe('Select selectedIndex', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should render select with selectedIndex -1', () => \{
			    render(
			      <select selectedIndex=\{-1\}>
			        <option value="0">Leonardo</option>
			        <option value="1">Donatello</option>
			        <option value="2">Rafael</option>
			        <option value="3">Michelangelo</option>
			        <option value="4">Splinter</option>
			      </select>,
			      container
			    );
			
			    const select = container.firstElementChild;
			    if (window.name === 'nodejs') \{
			      // bug in JSdom =(
			      expect(select.selectedIndex).toBe(0);
			    \} else \{
			      expect(select.selectedIndex).toBe(-1);
			    \}
			  \});
			
			  it('Should render select with selected option "3"', () => \{
			    render(
			      <select selectedIndex=\{3\}>
			        <option value="0">Leonardo</option>
			        <option value="1">Donatello</option>
			        <option value="2">Rafael</option>
			        <option value="3">Michelangelo</option>
			        <option value="4">Splinter</option>
			      </select>,
			      container
			    );
			
			    const select = container.firstElementChild;
			    expect(select.selectedIndex).toBe(3);
			    expect(select.value).toBe('3');
			  \});
			
			  it('Should render select without changes if value is not set', () => \{
			    render(
			      <select selectedIndex=\{3\}>
			        <option value="0">Leonardo</option>
			        <option value="1">Donatello</option>
			        <option value="2">Rafael</option>
			        <option value="3">Michelangelo</option>
			        <option value="4">Splinter</option>
			      </select>,
			      container
			    );
			
			    const select = container.firstElementChild;
			    select.value = '0';
			    triggerEvent('change', select);
			    expect(select.selectedIndex).toBe(0);
			    expect(select.value).toBe('0');
			  \});
			
			  it('Should strict render select if value set', () => \{
			    render(
			      <select selectedIndex=\{3\} value=\{'3'\}>
			        <option value="0">Leonardo</option>
			        <option value="1">Donatello</option>
			        <option value="2">Rafael</option>
			        <option value="3">Michelangelo</option>
			        <option value="4">Splinter</option>
			      </select>,
			      container
			    );
			
			    const select = container.firstElementChild;
			    select.value = '0';
			    triggerEvent('change', select);
			    expect(select.selectedIndex).toBe(3);
			    expect(select.value).toBe('3');
			  \});
			
			  it('Should not render attribute selectedIndex', () => \{
			    render(
			      <select selectedIndex=\{-1\}>
			        <option value="0">Leonardo</option>
			        <option value="1">Donatello</option>
			        <option value="2">Rafael</option>
			        <option value="3">Michelangelo</option>
			        <option value="4">Splinter</option>
			      </select>,
			      container
			    );
			
			    const select = container.firstElementChild;
			    expect(select.getAttribute('selectedIndex')).toBe(null);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\select.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\select2.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, InfernoNode, render \} from 'inferno';
			
			describe('Select / select multiple (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should render "select" boolean on select options with numbers', () => \{
			    render(
			      <select multiple=\{true\} value=\{null\}>
			        <option value=\{1\}>1</option>
			        <option value=\{2\}>2</option>
			      </select>,
			      container
			    );
			    render(
			      <select multiple=\{true\} value=\{undefined\}>
			        <option value=\{1\}>1</option>
			        <option value=\{2\}>1</option>
			      </select>,
			      container
			    );
			    render(
			      <select multiple=\{true\} value=\{2\}>
			        <option value=\{1\}>1</option>
			        <option value=\{2\}>2</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="1">1</option><option value="2">2</option></select>');
			
			    render(
			      <select multiple=\{true\} value=\{1\}>
			        <option value=\{1\}>1</option>
			        <option value=\{2\}>2</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="1">1</option><option value="2">2</option></select>');
			
			    render(
			      <select multiple=\{true\} value=\{'foo'\}>
			        <option value=\{1\}>1</option>
			        <option value=\{2\}>2</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="1">1</option><option value="2">2</option></select>');
			  \});
			
			  it('should render "select" boolean on select options #2', () => \{
			    render(
			      // @ts-expect-error
			      <select multiple=\{true\} value=\{false\}>
			        <option value="foo">foo</option>
			        <option value="bar">bar</option>
			      </select>,
			      container
			    );
			    render(
			      <select multiple=\{true\} value=\{'foo'\}>
			        <option value="foo">foo</option>
			        <option value="bar">bar</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>');
			    render(
			      // @ts-expect-error
			      <select multiple=\{true\} value=\{false\}>
			        <option value="foo">foo</option>
			        <option value="bar">bar</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>');
			
			    render(
			      <select multiple=\{true\} value=\{'bar'\}>
			        <option value="foo">foo</option>
			        <option value="bar">bar</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>');
			  \});
			
			  it('should populate the value attribute on select multiple using groups', () => \{
			    const template = (val) => (
			      <select multiple=\{true\} value=\{val\}>
			        <optgroup label="foo-group">
			          <option value="foo" />
			        </optgroup>
			        <optgroup label="bar-group" disabled>
			          <option value="bar" />
			        </optgroup>
			      </select>
			    );
			
			    // render(template(undefined), container);
			    render(template(['foo', 'bar']), container);
			
			    expect(container.firstChild.children[0].disabled).toEqual(false);
			    expect(container.firstChild.children[1].disabled).toEqual(true);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(true);
			
			    render(template([]), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			
			    render(template('foo'), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			
			    render(template('bar'), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(true);
			
			    render(template(false), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			  \});
			
			  it('should not fail if optgroup is empty', () => \{
			    const template = (val) => (
			      <select multiple=\{true\} value=\{val\}>
			        <optgroup label="foo-group">
			          <option value="foo" />
			        </optgroup>
			        <optgroup />
			        <optgroup label="bar-group" disabled>
			          <option value="bar" />
			        </optgroup>
			      </select>
			    );
			
			    // render(template(undefined), container);
			    render(template(['foo', 'bar']), container);
			  \});
			
			  it('Should be possible to render empty select', () => \{
			    render(<select value="test" />, container);
			
			    expect(container.innerHTML).toEqual('<select></select>');
			  \});
			
			  it('should populate the value attribute on select multiple using groups, multiple optgroups and options', () => \{
			    const template = (val) => (
			      <select multiple=\{true\} value=\{val\}>
			        <optgroup label="foo-group">
			          <option value="foo" />
			          <option value="foo2" />
			          <option value="foo3" />
			        </optgroup>
			        <optgroup label="bar-group" disabled>
			          <option value="bar" />
			          <option value="bar2" />
			          <option value="bar3" />
			        </optgroup>
			      </select>
			    );
			
			    // render(template(undefined), container);
			    render(template(['foo', 'bar2']), container);
			
			    expect(container.firstChild.children[0].disabled).toEqual(false);
			    expect(container.firstChild.children[1].disabled).toEqual(true);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option><option value="foo2"></option><option value="foo3"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option><option value="bar2"></option><option value="bar3"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].children[1].selected).toEqual(true);
			
			    render(template([]), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option><option value="foo2"></option><option value="foo3"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option><option value="bar2"></option><option value="bar3"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			
			    render(template('foo'), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option><option value="foo2"></option><option value="foo3"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option><option value="bar2"></option><option value="bar3"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			
			    render(template('bar'), container);
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(true);
			
			    render(template(false), container);
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			  \});
			
			  it('should render "select" boolean on select options #3', () => \{
			    render(
			      <select multiple=\{true\} value=\{'foo'\}>
			        <option value="foo">foo</option>
			        <option value="bar">bar</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      // Missing selected markup
			      '<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>'
			    );
			  \});
			
			  it('should render "select" boolean on select options #1', () => \{
			    render(
			      <select multiple=\{true\} value=\{'foo'\}>
			        <option value="foo">foo</option>
			        <option value="bar">bar</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>');
			
			    render(
			      // @ts-expect-error
			      <select multiple=\{true\} value=\{false\}>
			        <option value="foo">foo</option>
			        <option value="bar">bar</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>');
			  \});
			
			  it('should assure the value attribute also set the value property for \`textarea\`', () => \{
			    render(<textarea value=\{'foo'\} />, container);
			    expect(container.firstChild.value).toEqual('foo');
			    render(<textarea value=\{'bar'\} />, container);
			    expect(container.firstChild.value).toEqual('bar');
			    render(<textarea value=\{'bar'\} />, container);
			    expect(container.firstChild.value).toEqual('bar');
			    render(<textarea value=\{'foo'\} />, container);
			    expect(container.firstChild.value).toEqual('foo');
			    render(<textarea value=\{null\} />, container);
			    expect(container.firstChild.value).toEqual('');
			    render(<textarea value=\{undefined\} />, container);
			    expect(container.firstChild.value).toEqual('');
			    render(<textarea value=\{'bar'\} />, container);
			    expect(container.firstChild.value).toEqual('bar');
			    render(<textarea value=\{[]\} />, container);
			    expect(container.firstChild.value).toEqual('');
			
			    // @ts-expect-error
			    render(<textarea value=\{\{\}\} />, container);
			    expect(container.firstChild.value).toEqual('[object Object]');
			  \});
			
			  it('should handle when multiple values passed in as an array', () => \{
			    render(
			      <select multiple=\{true\} value=\{['a', 'b', 'c']\}>
			        <option value=\{'a'\}>a</option>
			        <option value=\{'b'\}>b</option>
			        <option value=\{'c'\}>c</option>
			        <option value=\{'d'\}>d</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(true);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select multiple=""><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('should handle when multiple options with selected set', () => \{
			    render(
			      <select multiple=\{true\}>
			        <option value="a" selected=\{true\}>
			          a
			        </option>
			        <option value="b" selected=\{true\}>
			          b
			        </option>
			        <option value="c" selected=\{true\}>
			          c
			        </option>
			        <option value="d">d</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(true);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select multiple=""><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('Should render empty select', () => \{
			    render(<select />, container);
			    expect(container.innerHTML).toEqual('<select></select>');
			  \});
			
			  it('should render defaultValue', () => \{
			    render(
			      <select defaultValue="b">
			        <option value="a">a</option>
			        <option value="b">b</option>
			        <option value="c">c</option>
			        <option value="d">d</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(false);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('should render multiple defaultValue', () => \{
			    render(
			      <select multiple=\{true\} defaultValue=\{['a', 'b', 'c']\}>
			        <option value=\{'a'\}>a</option>
			        <option value=\{'b'\}>b</option>
			        <option value=\{'c'\}>c</option>
			        <option value=\{'d'\}>d</option>
			      </select>,
			      container
			    );
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(true);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select multiple=""><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('should not touch selections, if value or selected, is null or undefined', () => \{
			    render(
			      <select>
			        <option value="a">a</option>
			        <option value="b">b</option>
			      </select>,
			      container
			    );
			    container.firstChild.children[1].selected = true;
			    render(
			      <select>
			        <option value="a">a</option>
			        <option value="b">b</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			  \});
			
			  it('should render specified default selected option', () => \{
			    render(
			      <select>
			        <option value="a">a</option>
			        <option selected=\{true\} value="b">
			          b
			        </option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true); // Currently failing due to issue #1031
			  \});
			
			  it('Should have selectedIndex -1 and value as null when value is removed - Github #1105', () => \{
			    render(
			      <select id="sel" value="">
			        <option value="">a</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.selectedIndex).toBe(0);
			    expect(container.firstChild.value).toBe('');
			
			    render(
			      <select id="sel">
			        <option value="">a</option>
			      </select>,
			      container
			    );
			    expect(container.firstChild.value).toBe('');
			    expect([0, -1]).toContain(container.firstChild.selectedIndex);
			  \});
			
			  it('Should be possible to render select element with options wrapped in functional Component', () => \{
			    interface CustomOptionProps \{
			      selected?: boolean;
			      value: number;
			      children: InfernoNode;
			    \}
			    const CustomOption = (\{ selected, value, children \}: CustomOptionProps) => (
			      <option selected=\{selected\} value=\{value\}>
			        \{children\}
			      </option>
			    );
			
			    render(
			      <select value=\{1\}>
			        <CustomOption value=\{1\}>1st</CustomOption>
			        <CustomOption value=\{2\}>2nd</CustomOption>
			        <CustomOption value=\{3\}>3rd</CustomOption>
			      </select>,
			      container
			    );
			
			    const selectElement = container.firstChild;
			
			    expect(container.innerHTML).toEqual('<select><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option></select>');
			    expect(selectElement.children[0].selected).toBe(true);
			    expect(selectElement.children[1].selected).toBe(false);
			    expect(selectElement.children[2].selected).toBe(false);
			
			    render(
			      <select value=\{2\}>
			        <CustomOption key=\{1\} value=\{1\}>
			          1st
			        </CustomOption>
			        <CustomOption key=\{2\} value=\{2\}>
			          2nd
			        </CustomOption>
			        <CustomOption key=\{3\} value=\{3\}>
			          3rd
			        </CustomOption>
			      </select>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<select><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option></select>');
			    expect(selectElement.children[0].selected).toBe(false);
			    expect(selectElement.children[1].selected).toBe(true);
			    expect(selectElement.children[2].selected).toBe(false);
			  \});
			
			  it('Should be possible to render select element with options wrapped in Class Component', () => \{
			    interface CustomOptionProps \{
			      selected?: boolean;
			      value: number;
			      children: InfernoNode;
			    \}
			
			    class CustomOption extends Component<CustomOptionProps> \{
			      public render() \{
			        return <option value=\{this.props.value\}>\{this.props.children\}</option>;
			      \}
			    \}
			
			    render(
			      <select value=\{1\}>
			        <CustomOption value=\{1\}>1st</CustomOption>
			        <CustomOption value=\{2\}>2nd</CustomOption>
			        <CustomOption value=\{3\}>3rd</CustomOption>
			      </select>,
			      container
			    );
			
			    const selectElement = container.firstChild;
			
			    expect(container.innerHTML).toEqual('<select><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option></select>');
			    expect(selectElement.children[0].selected).toBe(true);
			    expect(selectElement.children[1].selected).toBe(false);
			    expect(selectElement.children[2].selected).toBe(false);
			
			    render(
			      <select value=\{2\}>
			        <CustomOption key=\{1\} value=\{1\}>
			          1st
			        </CustomOption>
			        <CustomOption key=\{2\} value=\{2\}>
			          2nd
			        </CustomOption>
			        <CustomOption key=\{3\} value=\{3\}>
			          3rd
			        </CustomOption>
			      </select>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<select><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option></select>');
			    expect(selectElement.children[0].selected).toBe(false);
			    expect(selectElement.children[1].selected).toBe(true);
			    expect(selectElement.children[2].selected).toBe(false);
			  \});
			
			  it('Should be possible to render select element with options wrapped in Fragment', () => \{
			    render(
			      <select value=\{1\}>
			        <>
			          <>
			            <option value=\{1\}>1st</option>
			          </>
			          <option value=\{2\}>2nd</option>
			          <>
			            <option value=\{3\}>3rd</option>
			          </>
			        </>
			      </select>,
			      container
			    );
			
			    const selectElement = container.firstChild;
			
			    expect(container.innerHTML).toEqual('<select><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option></select>');
			    expect(selectElement.children[0].selected).toBe(true);
			    expect(selectElement.children[1].selected).toBe(false);
			    expect(selectElement.children[2].selected).toBe(false);
			
			    render(
			      <select value=\{2\}>
			        <>
			          <>
			            <option value=\{1\}>1st</option>
			          </>
			          <>
			            <option value=\{2\}>2nd</option>
			          </>
			        </>
			        <>
			          <option value=\{3\}>3rd</option>
			        </>
			      </select>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<select><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option></select>');
			    expect(selectElement.children[0].selected).toBe(false);
			    expect(selectElement.children[1].selected).toBe(true);
			    expect(selectElement.children[2].selected).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\select2.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(20)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\setState.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, DragEvent, render, rerender \} from 'inferno';
			
			describe('setState', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    rerender(); // Flush pending stuff, if any
			    render(null, container);
			    document.body.removeChild(container);
			    container.innerHTML = '';
			  \});
			
			  it('should throw an error when setState is called in constructor', () => \{
			    class TestComponent extends Component<any, any> \{
			      constructor(props, context) \{
			        super(props, context);
			        this.setState(\{
			          state: 'Something'
			        \});
			      \}
			      public render() \{
			        return null;
			      \}
			    \}
			
			    expect(() => render(<TestComponent />, container)).toThrowError(Error);
			  \});
			
			  it('callback should be fired after state has changed', () => \{
			    let counter = 0;
			    class TestComponent extends Component<any, \{ value: string \}> \{
			      public state = \{
			        value: this.props.value
			      \};
			
			      constructor(props) \{
			        super(props);
			        this.checkSetState = this.checkSetState.bind(this);
			      \}
			
			      public checkSetState() \{
			        counter++;
			        const value = this.state.value;
			        expect(value).toBe('__NEWVALUE__');
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        this.setState(
			          \{
			            value: nextProps.value
			          \},
			          this.checkSetState
			        );
			      \}
			
			      public render() \{
			        return null;
			      \}
			    \}
			
			    class BaseComp extends Component<any, any> \{
			      public state = \{
			        value: '__OLDVALUE__'
			      \};
			
			      public componentDidMount() \{
			        this.setState(\{
			          value: '__NEWVALUE__'
			        \});
			      \}
			
			      public render() \{
			        const value = this.state.value;
			        return <TestComponent value=\{value\} />;
			      \}
			    \}
			
			    render(<BaseComp />, container);
			    expect(container.innerHTML).toBe('');
			    rerender();
			    expect(container.innerHTML).toBe('');
			    expect(counter).toBe(1);
			  \});
			
			  it('Should not fail if callback is object and not function ( invalid used scenario )', () => \{
			    class TestComponent extends Component<\{ value: string \}, any> \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          value: props.value
			        \};
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        this.setState(
			          \{
			            value: nextProps.value
			          \},
			          \{ foo: 'bar' \} as any // This should not break inferno
			        );
			      \}
			
			      public render() \{
			        return null;
			      \}
			    \}
			
			    class BaseComp extends Component<any, any> \{
			      public state = \{
			        value: '__OLDVALUE__'
			      \};
			
			      public componentDidMount() \{
			        this.setState(\{
			          value: '__NEWVALUE__'
			        \});
			      \}
			
			      public render() \{
			        const value = this.state.value;
			        return <TestComponent value=\{value\} />;
			      \}
			    \}
			
			    render(<BaseComp />, container);
			  \});
			
			  it('Should have dataTransfer in dragEvent type Github #1411', () => \{
			    function handleDrop(evt: DragEvent<HTMLDivElement>) \{
			      return evt.dataTransfer;
			    \}
			
			    render(<div onDrop=\{handleDrop\}>1</div>, container);
			    expect(container.innerHTML).toBe('<div>1</div>');
			  \});
			
			  it('Should not fail if componentDidUpdate is not defined', () => \{
			    let counter = 0;
			
			    class TestComponent extends Component<\{ value: string \}, any> \{
			      public state = \{
			        value: this.props.value
			      \};
			
			      constructor(props) \{
			        super(props);
			      \}
			
			      public checkSetState() \{
			        const value = this.state.value;
			        counter++;
			        expect(value).toBe('__NEWVALUE__');
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        this.setState(
			          \{
			            value: nextProps.value
			          \},
			          this.checkSetState
			        );
			      \}
			
			      public render() \{
			        return null;
			      \}
			    \}
			
			    class BaseComp extends Component<any, any> \{
			      public state = \{
			        value: '__OLDVALUE__'
			      \};
			
			      public componentDidMount() \{
			        this.setState(\{
			          value: '__NEWVALUE__'
			        \});
			      \}
			
			      public render() \{
			        const value = this.state.value;
			        return <TestComponent value=\{value\} />;
			      \}
			    \}
			
			    render(<BaseComp />, container);
			    rerender();
			    expect(counter).toBe(1);
			  \});
			
			  // Should work as Per react: https://jsfiddle.net/f12u8xzb/
			  // React does not get stuck
			  it('Should not get stuck in infinite loop #1', () => \{
			    let doSomething;
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        active: false,
			        foo: 'b'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        this._setBar = this._setBar.bind(this);
			        doSomething = this._setActive = this._setActive.bind(this);
			      \}
			
			      private _setBar() \{
			        this.setState(\{
			          foo: 'bar'
			        \});
			      \}
			
			      private _setActive() \{
			        this.setState(\{
			          active: true
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.state.foo\}</div>
			            \{this.state.active ? <Child foo=\{this.state.foo\} callback=\{this._setBar\} /> : <Child foo=\{this.state.foo\} callback=\{this._setActive\} />\}
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component<\{ foo: string; callback: () => void \}> \{
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public componentWillUpdate(nextProps) \{
			        if (nextProps.foo !== 'bar') \{
			          this.props.callback();
			        \}
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.props.foo\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			    doSomething();
			    expect(container.innerHTML).toBe('<div><div>b</div><div><div>b</div></div></div>');
			    rerender();
			    expect(container.innerHTML).toBe('<div><div>bar</div><div><div>bar</div></div></div>');
			  \});
			
			  // Render should work as per React
			  // https://jsfiddle.net/qb4ootgm/
			  it('Should not fail during rendering', () => \{
			    let doSomething;
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        active: false,
			        foo: 'b'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        this._setBar = this._setBar.bind(this);
			        doSomething = this._setActive = this._setActive.bind(this);
			      \}
			
			      public _setBar() \{
			        this.setState(\{
			          foo: 'bar'
			        \});
			      \}
			
			      public _setActive() \{
			        this.setState(\{
			          active: true
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.state.foo\}</div>
			            <Child foo=\{this.state.foo\} callback=\{this._setBar\} />
			            <Child foo=\{this.state.foo\} callback=\{this._setBar\} />
			            <Child foo=\{this.state.foo\} callback=\{this._setBar\} />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component<\{ foo: string; callback: () => void \}> \{
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        if (nextProps.foo !== 'bar') \{
			          this.setState(\{
			            foo: 'bbaarr'
			          \});
			
			          this.props.callback();
			        \}
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.props.foo\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			    doSomething();
			
			    expect(container.innerHTML).toBe('<div><div>b</div><div><div>b</div></div><div><div>b</div></div><div><div>b</div></div></div>');
			    rerender();
			    expect(container.innerHTML).toBe('<div><div>bar</div><div><div>bar</div></div><div><div>bar</div></div><div><div>bar</div></div></div>');
			  \});
			
			  // https://jsfiddle.net/c6q9bvez/
			  it('Should not fail during rendering #2', () => \{
			    let doSomething;
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        active: false,
			        foo: 'b'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        this._setBar = this._setBar.bind(this);
			        doSomething = this._setActive = this._setActive.bind(this);
			      \}
			
			      private _setBar() \{
			        this.setState(\{
			          foo: 'bar'
			        \});
			      \}
			
			      private _setActive() \{
			        this.setState(\{
			          active: true
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Child foo=\{this.state.foo\} callback=\{this._setActive\} />
			            <ChildBar foo=\{this.state.foo\} onComponentWillMount=\{this._setBar\} />
			            <ChildBar foo=\{this.state.foo\} />
			          </div>
			        );
			      \}
			    \}
			
			    function ChildBar(\{ foo \}) \{
			      return <div>\{foo\}</div>;
			    \}
			
			    class Child extends Component<\{ foo: string; callback: () => void \}> \{
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        if (nextProps.foo !== 'bar') \{
			          this.setState(\{
			            foo: 'bbaarr'
			          \});
			
			          this.props.callback();
			        \}
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.props.foo\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    expect(container.innerHTML).toBe('<div><div><div>b</div></div><div>b</div><div>b</div></div>');
			
			    doSomething();
			
			    rerender();
			
			    expect(container.innerHTML).toBe('<div><div><div>bar</div></div><div>bar</div><div>bar</div></div>');
			  \});
			
			  it('Should have new state in render when changing state during componentWillReceiveProps', () => \{
			    let changeFoo;
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        foo: 'bar'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        changeFoo = this.changeFoo.bind(this);
			      \}
			
			      public changeFoo() \{
			        this.setState(\{
			          foo: 'bar2'
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Child foo=\{this.state.foo\} />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component<\{ foo: string \}, \{ foo: string \}> \{
			      public state = \{
			        foo: this.props.foo
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public callback() \{
			        expect(container.firstChild.firstChild.innerHTML).toBe('bar2');
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        if (nextProps.foo !== this.state.foo) \{
			          this.setState(
			            \{
			              foo: nextProps.foo
			            \},
			            this.callback
			          );
			        \}
			      \}
			
			      public render() \{
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    expect(container.firstChild.firstChild.innerHTML).toBe('bar');
			
			    changeFoo();
			
			    rerender();
			
			    expect(container.innerHTML).toBe('<div><div>bar2</div></div>');
			  \});
			
			  it('Should have new state in render when changing state during componentWillMount and render only once', () => \{
			    const spy = jasmine.createSpy('spy');
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        foo: 'bar'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Child foo=\{this.state.foo\} />
			          </div>
			        );
			      \}
			    \}
			
			    let renderCount = 0;
			    class Child extends Component<\{ foo: string \}, \{ foo: string \}> \{
			      public state = \{
			        foo: this.props.foo
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public componentWillMount() \{
			        this.setState(
			          \{
			            foo: '1'
			          \},
			          spy
			        );
			        this.setState(
			          \{
			            foo: '2'
			          \},
			          spy
			        );
			
			        this.setState(
			          \{
			            foo: '3'
			          \},
			          spy
			        );
			
			        this.setState(
			          \{
			            foo: '3'
			          \},
			          spy
			        );
			
			        this.setState(
			          \{
			            foo: '4'
			          \},
			          spy
			        );
			      \}
			
			      public render() \{
			        renderCount++;
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    expect(container.firstChild.firstChild.innerHTML).toBe('4');
			    expect(spy.calls.count()).toBe(5);
			    expect(renderCount).toBe(1);
			  \});
			
			  // Should work as Per react: https://jsfiddle.net/f12u8xzb/
			  // React does not get stuck
			  it('Should not get stuck in infinite loop #1 sync', () => \{
			    let doSomething;
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        active: false,
			        foo: 'b'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        this._setBar = this._setBar.bind(this);
			        doSomething = this._setActive = this._setActive.bind(this);
			      \}
			
			      private _setBar() \{
			        this.setState(\{
			          foo: 'bar'
			        \});
			      \}
			
			      private _setActive() \{
			        this.setState(\{
			          active: true
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.state.foo\}</div>
			            \{this.state.active ? <Child foo=\{this.state.foo\} callback=\{this._setBar\} /> : <Child foo=\{this.state.foo\} callback=\{this._setActive\} />\}
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component<\{ foo: string; callback: () => void \}> \{
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public componentWillUpdate(nextProps) \{
			        if (nextProps.foo !== 'bar') \{
			          this.props.callback();
			        \}
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.props.foo\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			    doSomething();
			    expect(container.innerHTML).toBe('<div><div>b</div><div><div>b</div></div></div>');
			    rerender();
			    expect(container.innerHTML).toBe('<div><div>bar</div><div><div>bar</div></div></div>');
			  \});
			
			  // Render should work as per React
			  // https://jsfiddle.net/qb4ootgm/
			  it('Should not fail during rendering sync', () => \{
			    let doSomething;
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        active: false,
			        foo: 'b'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        this._setBar = this._setBar.bind(this);
			        doSomething = this._setActive = this._setActive.bind(this);
			      \}
			
			      private _setBar() \{
			        this.setState(\{
			          foo: 'bar'
			        \});
			      \}
			
			      private _setActive() \{
			        this.setState(\{
			          active: true
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.state.foo\}</div>
			            <Child foo=\{this.state.foo\} callback=\{this._setBar\} />
			            <Child foo=\{this.state.foo\} callback=\{this._setBar\} />
			            <Child foo=\{this.state.foo\} callback=\{this._setBar\} />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component<\{ foo: string; callback: () => void \}> \{
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        if (nextProps.foo !== 'bar') \{
			          this.setState(\{
			            foo: 'bbaarr'
			          \});
			
			          this.props.callback();
			        \}
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <div>\{this.props.foo\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			    doSomething();
			    expect(container.innerHTML).toBe('<div><div>b</div><div><div>b</div></div><div><div>b</div></div><div><div>b</div></div></div>');
			    rerender();
			    expect(container.innerHTML).toBe('<div><div>bar</div><div><div>bar</div></div><div><div>bar</div></div><div><div>bar</div></div></div>');
			  \});
			
			  it('Should be possible to update state in componentWillUpdate', () => \{
			    interface MyState \{
			      foo: string;
			    \}
			
			    class Hello extends Component<any, MyState> \{
			      constructor(p, c) \{
			        super(p, c);
			
			        this.state = \{
			          foo: 'je'
			        \};
			      \}
			      public componentWillUpdate() \{
			        if (this.state!.foo === 'je') \{
			          this.setState(\{
			            foo: 'bar'
			          \});
			        \}
			      \}
			      public render() \{
			        return <div>Hello \{this.state!.foo\}</div>;
			      \}
			    \}
			
			    expect(container.innerHTML).toBe('');
			
			    render(<Hello name="World" />, container);
			
			    expect(container.innerHTML).toBe('<div>Hello je</div>');
			
			    render(<Hello name="World" />, container);
			
			    rerender();
			
			    expect(container.innerHTML).toBe('<div>Hello bar</div>');
			  \});
			
			  it('setState must be sync like React if no state changes are pending', () => \{
			    let doSomething;
			
			    class Parent extends Component<any, any> \{
			      public state = \{
			        foo: 'b'
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        doSomething = this._setBar = this._setBar.bind(this);
			      \}
			
			      private _setBar(p) \{
			        this.setState(\{
			          foo: p
			        \});
			      \}
			
			      public render() \{
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    render(<Parent />, container);
			    // Set state must go sync when nothing pending
			    expect(container.firstChild.innerHTML).toBe('b');
			    doSomething('1');
			    expect(container.firstChild.innerHTML).toBe('1');
			    doSomething('2');
			    expect(container.firstChild.innerHTML).toBe('2');
			    doSomething('3');
			    expect(container.firstChild.innerHTML).toBe('3');
			    doSomething('4');
			    expect(container.firstChild.innerHTML).toBe('4');
			  \});
			
			  it('Set state callback should have context of caller component (forced) - as per React', () => \{
			    let cnt = 0;
			
			    class Com extends Component<any, any> \{
			      public doTest() \{
			        expect(this.state!.a).toBe(cnt);
			      \}
			
			      public componentWillMount() \{
			        this.setState(
			          \{
			            a: ++cnt
			          \},
			          this.doTest
			        );
			      \}
			
			      public componentDidMount() \{
			        this.setState(
			          \{
			            a: ++cnt
			          \},
			          this.doTest
			        );
			      \}
			
			      public render() \{
			        return <div>1</div>;
			      \}
			    \}
			
			    render(<Com />, container);
			  \});
			
			  it('Should not re-create state if no setState is called', () => \{
			    const FooBarState = [1];
			
			    class FooBar extends Component<any, any> \{
			      constructor(props, context) \{
			        super(props, context);
			
			        this.state = FooBarState;
			      \}
			
			      public render(_props, state) \{
			        expect(state).toBe(FooBarState);
			        expect(this.state).toBe(FooBarState);
			        expect(state === FooBarState).toBe(true);
			
			        return <div>\{state[0]\}</div>;
			      \}
			    \}
			
			    render(<FooBar />, container);
			
			    expect(container.innerHTML).toEqual('<div>1</div>');
			
			    render(<FooBar />, container);
			
			    expect(container.innerHTML).toEqual('<div>1</div>');
			  \});
			
			  it('Should keep context in sync with state #1182', () => \{
			    function Child(_props, context) \{
			      return <div>\{(context.active ? 'ACTIVE' : 'INACTIVE') + '   :   ' + (context.state.active ? 'ACTIVE' : 'INACTIVE')\}</div>;
			    \}
			
			    class Container extends Component<\{ active: boolean \}, \{ active: boolean \}> \{
			      public state = \{
			        active: false
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public getChildContext() \{
			        return \{
			          active: this.state.active,
			          state: this.state
			        \};
			      \}
			
			      public componentWillReceiveProps(nextProps) \{
			        if (this.state.active !== nextProps.active) \{
			          this.setState(\{
			            active: nextProps.active
			          \});
			        \}
			      \}
			
			      public render() \{
			        return <Child />;
			      \}
			    \}
			
			    let updater;
			    class App extends Component<any, any> \{
			      public state = \{
			        active: false
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			
			        updater = this.didClick.bind(this);
			      \}
			
			      public didClick() \{
			        this.setState(\{
			          active: !this.state.active
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Container active=\{this.state.active\} />
			          </div>
			        );
			      \}
			    \}
			
			    render(<App />, container);
			
			    expect(container.textContent).toBe('INACTIVE   :   INACTIVE');
			
			    updater();
			    rerender();
			
			    expect(container.textContent).toBe('ACTIVE   :   ACTIVE');
			
			    updater();
			    rerender();
			
			    expect(container.textContent).toBe('INACTIVE   :   INACTIVE');
			
			    updater();
			    rerender();
			
			    expect(container.textContent).toBe('ACTIVE   :   ACTIVE');
			  \});
			
			  it('Should call all setState callbacks', () => \{
			    let counter = 0;
			    let setStateCounter = 0;
			
			    class Child extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ test: false \};
			        this.callCallback = this.callCallback.bind(this);
			      \}
			
			      public callCallback() \{
			        setStateCounter++;
			        this.setState(\{ test: true \}, () => \{
			          counter++;
			        \});
			      \}
			
			      public render() \{
			        if (setStateCounter === 1) \{
			          this.callCallback();
			          this.props.callback(true);
			        \}
			
			        return <div>Child</div>;
			      \}
			    \}
			
			    class MidChild extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ test: false \};
			        this.callCallback = this.callCallback.bind(this);
			      \}
			
			      public callCallback() \{
			        setStateCounter++;
			        this.setState(\{ test: true \}, () => \{
			          counter++;
			          this.props.callback(true);
			        \});
			      \}
			
			      public render() \{
			        return [<button onClick=\{this.callCallback\}>Click</button>, <Child callback=\{this.props.callback\} />];
			      \}
			    \}
			
			    class Parent extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ test: false, foobar: false \};
			        this.doSomething = this.doSomething.bind(this);
			        this.callCallback = this.callCallback.bind(this);
			      \}
			
			      public callCallback(testValue) \{
			        setStateCounter++;
			        this.setState(\{ test: testValue \}, () => \{
			          counter++;
			          this.props.callback(true);
			        \});
			      \}
			
			      public doSomething() \{
			        setStateCounter++;
			        this.setState(\{ foobar: true \}, () => \{
			          counter++;
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <MidChild callback=\{this.callCallback\} foobar=\{this.state!.foobar\} />
			          </div>
			        );
			      \}
			    \}
			
			    class Wrapper extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ didCounter: 0 \};
			        this.doSomething = this.doSomething.bind(this);
			      \}
			
			      public doSomething() \{
			        setStateCounter++;
			
			        this.setState(\{ didCounter: this.state!.didCounter + 1 \}, () => \{
			          counter++;
			        \});
			      \}
			
			      public render() \{
			        return (
			          <div>
			            <Parent callback=\{this.doSomething\} />
			            <span>\{this.state!.didCounter\}</span>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Wrapper />, container);
			
			    expect(counter).toBe(0);
			    expect(setStateCounter).toBe(0);
			
			    const btn = container.querySelector('button');
			
			    btn.click();
			
			    rerender();
			    expect(setStateCounter).toBe(6);
			    expect(counter).toBe(6);
			
			    expect(container.innerHTML).toEqual('<div><div><button>Click</button><div>Child</div></div><span>2</span></div>');
			  \});
			
			  it('Should update setState callback argument - Github #1420', () => \{
			    let renderCounter = 0;
			
			    interface TextState \{
			      texts: \{
			        text1: string;
			        text2: string;
			        text3: string;
			      \};
			    \}
			
			    class BrokenComponent extends Component<any, TextState> \{
			      constructor(props, context) \{
			        super(props, context);
			        this.state = \{
			          texts: \{
			            text1: 'Initial text 1',
			            text2: 'Initial text 2',
			            text3: 'Initial text 3'
			          \}
			        \};
			      \}
			
			      public componentDidMount() \{
			        // This change is ignored
			        this.setState((prevState) => \{
			          // init all
			          return \{
			            texts: \{
			              ...prevState.texts,
			              text1: 'Updated text 1'
			            \}
			          \};
			        \});
			        // This change is also ignored
			        this.setState((prevState) => \{
			          return \{
			            texts: \{
			              ...prevState.texts,
			              text2: 'Updated text 2'
			            \}
			          \};
			        \});
			        // Only this change is applied
			        this.setState((prevState) => \{
			          return \{
			            texts: \{
			              ...prevState.texts,
			              text3: 'Updated text 3'
			            \}
			          \};
			        \});
			      \}
			
			      public render() \{
			        const \{ text1, text2, text3 \} = this.state!.texts;
			
			        renderCounter++;
			
			        return (
			          <ul>
			            <li>\{text1\}</li>
			            <li>\{text2\}</li>
			            <li>\{text3\}</li>
			          </ul>
			        );
			      \}
			    \}
			
			    expect(renderCounter).toBe(0);
			
			    render(<BrokenComponent />, container);
			
			    expect(renderCounter).toBe(1);
			
			    expect(container.innerHTML).toBe('<ul><li>Initial text 1</li><li>Initial text 2</li><li>Initial text 3</li></ul>');
			
			    rerender();
			
			    expect(renderCounter).toBe(2);
			
			    expect(container.innerHTML).toBe('<ul><li>Updated text 1</li><li>Updated text 2</li><li>Updated text 3</li></ul>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\setState.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(19)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\singlepatches.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, Fragment, render \} from 'inferno';
			
			describe('All single patch variations', () => \{
			  let templateRefSpy;
			  let container;
			  let mountSpy;
			  let updateSpy;
			  let unmountSpy;
			
			  beforeEach(function () \{
			    mountSpy = spyOn(ComA.prototype, 'componentWillMount');
			    updateSpy = spyOn(ComA.prototype, 'componentWillUpdate');
			    unmountSpy = spyOn(ComA.prototype, 'componentWillUnmount');
			    templateRefSpy = jasmine.createSpy('spy');
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  function rTemplate(content) \{
			    return render(<div>\{[content]\}</div>, container);
			  \}
			
			  function tearDown() \{
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			  \}
			
			  /* tslint:disable:no-empty */
			  class ComA extends Component<any, any> \{
			    public componentDidMount() \{\}
			
			    public componentWillMount() \{\}
			
			    public componentWillReceiveProps(_nextProps, _nextContext) \{\}
			
			    public shouldComponentUpdate(_nextProps, _nextState, _nextContext) \{
			      return true;
			    \}
			
			    public componentWillUpdate(_nextProps, _nextState, _nextContext) \{\}
			
			    public componentDidUpdate(_prevProps, _prevState, _prevContext) \{\}
			
			    public componentWillUnmount() \{\}
			
			    public render(\{ children \}) \{
			      return children;
			    \}
			  \}
			  /* tslint:enable */
			
			  describe('Text to', () => \{
			    let node;
			
			    beforeEach(() => \{
			      rTemplate('text');
			      expect(container.innerHTML).toEqual('<div>text</div>');
			      node = container.firstChild.firstChild;
			    \});
			
			    it('text', () => \{
			      rTemplate('more text');
			      expect(container.innerHTML).toEqual('<div>more text</div>');
			
			      expect(container.firstChild.firstChild).toBe(node);
			
			      rTemplate('more text2');
			      expect(container.innerHTML).toEqual('<div>more text2</div>');
			
			      expect(container.firstChild.firstChild).toBe(node);
			      tearDown();
			    \});
			
			    it('invalid', () => \{
			      rTemplate(false);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      expect(container.firstChild.firstChild).toBe(null);
			
			      rTemplate(null);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      expect(container.firstChild.firstChild).toBe(null);
			      tearDown();
			    \});
			
			    it('vNode (elem)', () => \{
			      const spy = jasmine.createSpy('spy');
			
			      rTemplate(<span ref=\{spy\}>1</span>);
			      expect(container.innerHTML).toEqual('<div><span>1</span></div>');
			
			      expect(spy.calls.count()).toBe(1);
			
			      rTemplate(<span ref=\{spy\}>2</span>);
			      expect(container.innerHTML).toEqual('<div><span>2</span></div>');
			
			      expect(spy.calls.count()).toBe(1);
			      tearDown();
			    \});
			
			    it('vNode (com)', () => \{
			      const spy = jasmine.createSpy('spy');
			
			      rTemplate(<ComA ref=\{spy\}>1</ComA>);
			      expect(container.innerHTML).toEqual('<div>1</div>');
			      expect(mountSpy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(0);
			      expect(unmountSpy.calls.count()).toBe(0);
			      expect(spy.calls.count()).toBe(1);
			
			      rTemplate(<ComA ref=\{spy\}>2</ComA>);
			      expect(container.innerHTML).toEqual('<div>2</div>');
			      expect(mountSpy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(1);
			      expect(unmountSpy.calls.count()).toBe(0);
			      expect(spy.calls.count()).toBe(1);
			
			      tearDown();
			    \});
			
			    it('Array', () => \{
			      const spy = jasmine.createSpy('spy');
			
			      rTemplate([<ComA ref=\{spy\}>1</ComA>, 'foo']);
			      expect(container.innerHTML).toEqual('<div>1foo</div>');
			      expect(mountSpy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(0);
			      expect(unmountSpy.calls.count()).toBe(0);
			      expect(spy.calls.count()).toBe(1);
			
			      rTemplate([<ComA ref=\{spy\}>2</ComA>, null]);
			      expect(container.innerHTML).toEqual('<div>2</div>');
			      expect(mountSpy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(1);
			      expect(unmountSpy.calls.count()).toBe(0);
			      expect(spy.calls.count()).toBe(1);
			
			      tearDown();
			    \});
			  \});
			
			  describe('Component to', () => \{
			    beforeEach(() => \{
			      rTemplate(<ComA ref=\{templateRefSpy\}>first</ComA>);
			      expect(templateRefSpy.calls.count()).toBe(1);
			      templateRefSpy.calls.reset();
			      expect(container.innerHTML).toEqual('<div>first</div>');
			      expect(unmountSpy.calls.count()).toBe(0);
			      expect(mountSpy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(0);
			    \});
			
			    it('text', () => \{
			      rTemplate('more text');
			      expect(container.innerHTML).toEqual('<div>more text</div>');
			      expect(unmountSpy.calls.count()).toBe(1);
			      expect(mountSpy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(0);
			
			      rTemplate('more text2');
			      expect(container.innerHTML).toEqual('<div>more text2</div>');
			      tearDown();
			    \});
			
			    it('invalid', () => \{
			      rTemplate(false);
			      expect(container.innerHTML).toEqual('<div></div>');
			      expect(unmountSpy.calls.count()).toBe(1);
			      expect(mountSpy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(0);
			
			      expect(container.firstChild.firstChild).toBe(null);
			
			      rTemplate(null);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      expect(container.firstChild.firstChild).toBe(null);
			      tearDown();
			    \});
			
			    it('vNode (elem)', () => \{
			      const spy = jasmine.createSpy('spy');
			      expect(templateRefSpy.calls.count()).toBe(0);
			
			      rTemplate(
			        <div ref=\{spy\} className="component2">
			          Component 2 <br />
			          <span id="clear">clear app</span>
			        </div>
			      );
			      expect(templateRefSpy.calls.count()).toBe(1); // unmount
			      expect(unmountSpy.calls.count()).toBe(1);
			      expect(spy.calls.count()).toBe(1);
			      expect(updateSpy.calls.count()).toBe(0);
			      expect(container.innerHTML).toEqual('<div><div class="component2">Component 2 <br><span id="clear">clear app</span></div></div>');
			
			      rTemplate(<span ref=\{spy\}>2</span>);
			      expect(container.innerHTML).toEqual('<div><span>2</span></div>');
			
			      expect(spy.calls.count()).toBe(3); // mount, unmount, mount
			      tearDown();
			    \});
			
			    it('vNode (Com different)', () => \{
			      const componentWillMountSpy = jasmine.createSpy();
			
			      class ComC extends Component<any, any> \{
			        // tslint:disable-next-line
			        componentWillMount() \{
			          componentWillMountSpy();
			        \}
			
			        public render(\{ children \}) \{
			          return children;
			        \}
			      \}
			
			      rTemplate(<ComC>second</ComC>);
			
			      expect(componentWillMountSpy).toHaveBeenCalledTimes(1);
			
			      tearDown();
			    \});
			  \});
			
			  describe('children', () => \{
			    describe('HasKeyedChildren', () => \{
			      it('Should update from Array to single vNode', () => \{
			        render(<div \$HasKeyedChildren>\{[<div key="1">1</div>, <div key="2">2</div>]\}</div>, container);
			
			        expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div></div>');
			
			        render(
			          <div>
			            <div>single</div>
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toEqual('<div><div>single</div></div>');
			
			        // Revert
			        render(<div \$HasKeyedChildren>\{[<div key="1">1</div>, <div key="2">2</div>]\}</div>, container);
			
			        expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div></div>');
			      \});
			    \});
			
			    describe('hasNonKeyedChildren', () => \{
			      it('Should update from Array to single vNode', () => \{
			        render(<div \$HasNonKeyedChildren>\{[<div>1</div>, <div>2</div>]\}</div>, container);
			
			        expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div></div>');
			
			        render(
			          <div>
			            <div>single</div>
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toEqual('<div><div>single</div></div>');
			
			        // Revert
			        render(<div \$HasNonKeyedChildren>\{[<div>1</div>, <div>2</div>]\}</div>, container);
			
			        expect(container.innerHTML).toEqual('<div><div>1</div><div>2</div></div>');
			      \});
			    \});
			  \});
			
			  describe('defaultHooks', () => \{
			    it('Should never update if defaultProps refs SCU returns false', () => \{
			      let counter = 0;
			
			      const Static = function () \{
			        return <div>\{counter\}</div>;
			      \};
			
			      Static.defaultHooks = \{
			        onComponentShouldUpdate() \{
			          return false;
			        \}
			      \};
			
			      function doRender() \{
			        render(
			          <div>
			            \{counter\}
			            <Static />
			          </div>,
			          container
			        );
			      \}
			
			      doRender();
			      expect(container.innerHTML).toEqual('<div>0<div>0</div></div>');
			      counter++;
			      doRender();
			      expect(container.innerHTML).toEqual('<div>1<div>0</div></div>');
			      counter++;
			      doRender();
			      expect(container.innerHTML).toEqual('<div>2<div>0</div></div>');
			    \});
			
			    it('Should prefer external hook if given', () => \{
			      let counter = 0;
			      let mountCounter = 0;
			
			      type scuTestType = \{
			        onComponentShouldUpdate: () => boolean;
			      \};
			
			      const Static = function (_: scuTestType) \{
			        return <div>\{counter\}</div>;
			      \};
			
			      Static.defaultHooks = \{
			        onComponentShouldUpdate() \{
			          return false;
			        \},
			        onComponentWillMount() \{
			          mountCounter++;
			        \}
			      \};
			
			      function doRender() \{
			        render(
			          <div>
			            \{counter\}
			            <Static onComponentShouldUpdate=\{() => true\} />
			          </div>,
			          container
			        );
			      \}
			
			      doRender();
			      expect(container.innerHTML).toEqual('<div>0<div>0</div></div>');
			      counter++;
			      expect(mountCounter).toBe(1);
			      doRender();
			      expect(container.innerHTML).toEqual('<div>1<div>1</div></div>');
			      counter++;
			      expect(mountCounter).toBe(1);
			      doRender();
			      expect(container.innerHTML).toEqual('<div>2<div>2</div></div>');
			      expect(mountCounter).toBe(1);
			    \});
			
			    it('Should be possible to define default hooks and use spread operator', () => \{
			      let counter = 0;
			      let mountCounter = 0;
			
			      const Static = function () \{
			        return <div>\{counter\}</div>;
			      \};
			
			      Static.defaultHooks = \{
			        onComponentShouldUpdate() \{
			          return false;
			        \},
			        onComponentWillMount() \{
			          mountCounter++;
			        \}
			      \};
			
			      const props = \{
			        ref: \{
			          onComponentShouldUpdate: () => true
			        \}
			      \};
			
			      // TODO: Supporting types for "ref: \{\}" function component hooks probably needs changes to "JSX root types" where are those?
			
			      function doRender() \{
			        render(
			          <div>
			            \{counter\}
			            \{/*
			 // @ts-ignore */\}
			            <Static \{...props\} />
			          </div>,
			          container
			        );
			      \}
			
			      doRender();
			      expect(container.innerHTML).toEqual('<div>0<div>0</div></div>');
			      counter++;
			      expect(mountCounter).toBe(1);
			      doRender();
			      expect(container.innerHTML).toEqual('<div>1<div>1</div></div>');
			      counter++;
			      expect(mountCounter).toBe(1);
			      doRender();
			      expect(container.innerHTML).toEqual('<div>2<div>2</div></div>');
			      expect(mountCounter).toBe(1);
			    \});
			  \});
			
			  describe('immutable children', () => \{
			    it('Should be possible to render frozen objects', () => \{
			      const EMPTY_ARRAY = [];
			      Object.freeze(EMPTY_ARRAY);
			
			      render(<div>\{EMPTY_ARRAY\}</div>, container);
			
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<div>\{EMPTY_ARRAY\}</div>, container);
			
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<div>\{EMPTY_ARRAY\}</div>, container);
			
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<div>\{null\}</div>, container);
			      expect(container.innerHTML).toBe('<div></div>');
			    \});
			
			    it('Should be possible to render frozen objects #2', () => \{
			      const EMPTY_ARRAY = [];
			      const TWO_NODES = [<div>1</div>, <div>2</div>];
			      Object.freeze(EMPTY_ARRAY);
			      Object.freeze(TWO_NODES);
			
			      render(<div>\{EMPTY_ARRAY\}</div>, container);
			
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<div>\{TWO_NODES\}</div>, container);
			
			      expect(container.innerHTML).toBe('<div><div>1</div><div>2</div></div>');
			
			      render(<div>\{EMPTY_ARRAY\}</div>, container);
			
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(<div>\{null\}</div>, container);
			      expect(container.innerHTML).toBe('<div></div>');
			    \});
			  \});
			
			  describe('it should use non keyed algorithm if its forced Github #1275', () => \{
			    it('last & prev are flagged \$HasNonKeyedChildren', () => \{
			      render(<div \$HasNonKeyedChildren>\{[<div key="1">1</div>, <div key="2">2</div>]\}</div>, container);
			
			      const oldFirstNode = container.firstChild.firstChild;
			      expect(container.innerHTML).toBe('<div><div>1</div><div>2</div></div>');
			
			      render(<div \$HasNonKeyedChildren>\{[<div key="2">2</div>, <div key="1">1</div>]\}</div>, container);
			
			      expect(container.innerHTML).toBe('<div><div>2</div><div>1</div></div>');
			
			      // It is forced to do non keyed, so elements are remounted
			      expect(container.firstChild.firstChild).not.toBe(oldFirstNode);
			    \});
			  \});
			
			  it('Should remount whole vNode tree when parent element vNode key changes', () => \{
			    let mountCallCount = 0;
			    let unmountCallCount = 0;
			
			    class ComponentFooBar extends Component<any, any> \{
			      public componentWillMount() \{
			        mountCallCount++;
			      \}
			
			      public componentWillUnmount() \{
			        unmountCallCount++;
			      \}
			
			      public render() \{
			        return <div>Component</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <div key="First">
			          <ComponentFooBar />
			        </div>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<div><div><div>Component</div></div></div>');
			
			    expect(mountCallCount).toBe(1);
			    expect(unmountCallCount).toBe(0);
			
			    render(
			      <div>
			        <div key="Another">
			          <ComponentFooBar />
			        </div>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<div><div><div>Component</div></div></div>');
			
			    expect(mountCallCount).toBe(2);
			    expect(unmountCallCount).toBe(1);
			  \});
			
			  it('Should handle situation where same element ref is used multiple times', () => \{
			    const div = <div>Fun</div>;
			
			    render(
			      <Fragment \$HasNonKeyedChildren>
			        \{[
			          div,
			          div,
			          <div \$HasNonKeyedChildren>
			            \{div\}
			            <div \$HasVNodeChildren>\{div\}</div>
			          </div>,
			          div
			        ]\}
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Fun</div><div>Fun</div><div><div>Fun</div><div><div>Fun</div></div></div><div>Fun</div>');
			
			    expect(container.\$V.children[1].children[0]).not.toBe(container.\$V.children[0]);
			    expect(container.\$V.children[0]).not.toBe(container.\$V.children[3]);
			
			    render(
			      <Fragment \$HasNonKeyedChildren>
			        \{[
			          div,
			          div,
			          <div \$HasNonKeyedChildren>
			            \{div\}
			            <div \$HasVNodeChildren>\{div\}</div>
			            \{div\}
			          </div>,
			          div
			        ]\}
			      </Fragment>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Fun</div><div>Fun</div><div><div>Fun</div><div><div>Fun</div></div><div>Fun</div></div><div>Fun</div>');
			    expect(container.\$V.children[0]).not.toBe(container.\$V.children[3]);
			  \});
			
			  it('Should unmount root fragment with hoisted children', () => \{
			    const div = <div>Fun</div>;
			
			    render(
			      <Fragment \$HasNonKeyedChildren>
			        \{[
			          div,
			          div,
			          div,
			          <div \$HasNonKeyedChildren>
			            \{div\}
			            <div \$HasVNodeChildren>\{div\}</div>
			            \{div\}
			          </div>,
			          div,
			          div,
			          div
			        ]\}
			      </Fragment>,
			      container
			    );
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			    render(null, container);
			  \});
			
			  it('Should handle hoisted nodes correctly', () => \{
			    const div = <div>Fun</div>;
			
			    function Okay() \{
			      return div;
			    \}
			
			    const OkayHoisted = <Okay />;
			
			    function Nested() \{
			      return OkayHoisted;
			    \}
			
			    class Foobar extends Component \{
			      public render() \{
			        return (
			          <>
			            \{div\}
			            <span>Ok</span>
			            <Okay />
			          </>
			        );
			      \}
			    \}
			
			    const NestedHoisted = <Nested />;
			    const FooBarHoisted = <Foobar />;
			
			    render(
			      <Fragment>
			        \{[
			          FooBarHoisted,
			          <Foobar />,
			          div,
			          <div>
			            \{NestedHoisted\}
			            <div>\{div\}</div>
			            \{NestedHoisted\}
			          </div>,
			          FooBarHoisted,
			          div,
			          div
			        ]\}
			      </Fragment>,
			      container
			    );
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			
			    render(null, container);
			    render(null, container);
			  \});
			
			  it('Should not re-mount fragment contents', () => \{
			    class Foobar extends Component<
			      any,
			      \{
			        val: number;
			      \}
			    > \{
			      public state = \{
			        val: 1
			      \};
			
			      constructor(props, context) \{
			        super(props, context);
			      \}
			
			      public render() \{
			        return (
			          <div onClick=\{() => this.setState(\{ val: ++this.state.val \})\}>
			            <span>\{this.state.val\}</span>
			            \{this.props.children\}
			          </div>
			        );
			      \}
			    \}
			
			    function Foobar2(props) \{
			      return <span className=\{props.data\}>Foo</span>;
			    \}
			
			    render(
			      <>
			        <Foobar>
			          <div>
			            <Foobar2 data="first" />
			          </div>
			          <>
			            <>
			              <Foobar2 data="second" />
			              <Foobar2 data="third" />
			            </>
			          </>
			        </Foobar>
			      </>,
			      container
			    );
			
			    expect(container.innerHTML).toBe(
			      '<div><span>1</span><div><span class="first">Foo</span></div><span class="second">Foo</span><span class="third">Foo</span></div>'
			    );
			
			    const firstNode = container.querySelector('.first');
			    const secondNode = container.querySelector('.second');
			
			    container.firstChild.click();
			
			    expect(container.innerHTML).toBe(
			      '<div><span>2</span><div><span class="first">Foo</span></div><span class="second">Foo</span><span class="third">Foo</span></div>'
			    );
			
			    expect(container.querySelector('.first')).toBe(firstNode);
			    expect(container.querySelector('.second')).toBe(secondNode);
			
			    container.firstChild.click();
			
			    expect(container.innerHTML).toBe(
			      '<div><span>3</span><div><span class="first">Foo</span></div><span class="second">Foo</span><span class="third">Foo</span></div>'
			    );
			
			    expect(container.querySelector('.first')).toBe(firstNode);
			    expect(container.querySelector('.second')).toBe(secondNode);
			  \});
			
			  it('Should keep given key even for deeply nested content', () => \{
			    render(<div>\{[null, <div key="first">First</div>, <div key="second">Second</div>]\}</div>, container);
			
			    const firstDiv = container.firstChild.firstChild;
			    const secondDiv = container.firstChild.childNodes[1];
			
			    expect(container.innerHTML).toBe('<div><div>First</div><div>Second</div></div>');
			
			    render(<div>\{[null, undefined, <div key="first">First</div>, <div key="second">Second</div>]\}</div>, container);
			    const firstDiv2 = container.firstChild.firstChild;
			    const secondDiv2 = container.firstChild.childNodes[1];
			
			    expect(container.innerHTML).toBe('<div><div>First</div><div>Second</div></div>');
			
			    expect(firstDiv).toBe(firstDiv2);
			    expect(secondDiv).toBe(secondDiv2);
			  \});
			
			  it('Should keep given key even for deeply nested content #2', () => \{
			    const vNode1 = <div key="first">First</div>;
			
			    render(<div>\{[null, <div key="first1">First</div>, vNode1, <div key="second">Second</div>]\}</div>, container);
			
			    const domNode = container.firstChild.childNodes[1];
			
			    expect(container.innerHTML).toBe('<div><div>First</div><div>First</div><div>Second</div></div>');
			
			    render(<div>\{[null, undefined, <div key="first1">First</div>, [vNode1], <div key="second">Second</div>]\}</div>, container);
			    const domNode2 = container.firstChild.childNodes[1];
			
			    expect(container.innerHTML).toBe('<div><div>First</div><div>First</div><div>Second</div></div>');
			
			    expect(domNode).not.toBe(domNode2);
			  \});
			
			  it('Should differenciate between location even if key is same', () => \{
			    let changeState: any = null;
			    const okDiv = <div key="ok">ok</div>;
			
			    class Example extends Component<\{
			      test: boolean;
			    \}> \{
			      constructor(props, context) \{
			        super(props, context);
			
			        changeState = () => this.setState(\{\});
			      \}
			
			      public render() \{
			        if (this.props.test) \{
			          return <div>\{[[[[[[okDiv]]]]]]\}</div>;
			        \}
			
			        return <div>\{[[okDiv]]\}</div>;
			      \}
			    \}
			    render(<Example test=\{false\} />, container);
			
			    const domNode = container.firstChild.childNodes[0];
			
			    changeState();
			
			    // set state should keep it the same
			    expect(domNode).toBe(container.firstChild.childNodes[0]);
			
			    render(<Example test=\{true\} />, container);
			
			    // Rendered to different array, create new dom
			    const newDomNode = container.firstChild.childNodes[0];
			
			    expect(newDomNode).not.toBe(domNode);
			
			    changeState();
			
			    expect(newDomNode).toBe(container.firstChild.childNodes[0]);
			  \});
			
			  it('Should differenciate between location even if key is same (props.children)', () => \{
			    let changeState: any = null;
			
			    class Example extends Component<\{
			      test: boolean;
			    \}> \{
			      constructor(props, context) \{
			        super(props, context);
			
			        changeState = () => this.setState(\{\});
			      \}
			
			      public render() \{
			        if (this.props.test) \{
			          return <div>\{[[[[[[this.props.children]]]]]]\}</div>;
			        \}
			
			        return <div>\{[[this.props.children]]\}</div>;
			      \}
			    \}
			
			    function start(bool: boolean) \{
			      render(
			        <Example test=\{bool\}>
			          <div key="ok">ok</div>
			        </Example>,
			        container
			      );
			    \}
			
			    start(false);
			
			    const domNode = container.firstChild.childNodes[0];
			
			    changeState();
			
			    // set state should keep it the same
			    expect(domNode).toBe(container.firstChild.childNodes[0]);
			
			    start(true);
			
			    // Rendered to different array, create new dom
			    const newDomNode = container.firstChild.childNodes[0];
			
			    expect(newDomNode).not.toBe(domNode);
			
			    changeState();
			
			    expect(newDomNode).toBe(container.firstChild.childNodes[0]);
			  \});
			
			  it('Should not recreate DOM nodes if key is given and does not change', () => \{
			    let changeState: any = null;
			
			    class Example extends Component \{
			      constructor(props, context) \{
			        super(props, context);
			
			        changeState = () => this.setState(\{\});
			      \}
			
			      public render() \{
			        return (
			          <div key="exampleDiv">
			            <input key="button" type="button" value="rerender" />
			            \{this.props.children\}
			          </div>
			        );
			      \}
			    \}
			
			    const rerender = function () \{
			      // children must be defiend outside the Exampe Component
			      // if defined insite render of Exampe and/or its a single child, there is no issue
			      render(
			        <Example key="exmapleApp">
			          <div class="anim1" key="div1" />
			          <div class="anim2" key="div22" />
			        </Example>,
			        container
			      );
			    \};
			
			    rerender();
			
			    const originalInput = container.firstChild.children[0];
			    const originalDiv1 = container.firstChild.children[1];
			    const originalDiv2 = container.firstChild.children[2];
			
			    changeState();
			
			    expect(originalInput).toBe(container.firstChild.children[0]);
			    expect(originalDiv1).toBe(container.firstChild.children[1]);
			    expect(originalDiv2).toBe(container.firstChild.children[2]);
			
			    changeState();
			
			    expect(originalInput).toBe(container.firstChild.children[0]);
			    expect(originalDiv1).toBe(container.firstChild.children[1]);
			    expect(originalDiv2).toBe(container.firstChild.children[2]);
			
			    rerender();
			
			    expect(originalInput).toBe(container.firstChild.children[0]);
			    expect(originalDiv1).toBe(container.firstChild.children[1]);
			    expect(originalDiv2).toBe(container.firstChild.children[2]);
			
			    changeState();
			
			    expect(originalInput).toBe(container.firstChild.children[0]);
			    expect(originalDiv1).toBe(container.firstChild.children[1]);
			    expect(originalDiv2).toBe(container.firstChild.children[2]);
			
			    rerender();
			
			    expect(originalInput).toBe(container.firstChild.children[0]);
			    expect(originalDiv1).toBe(container.firstChild.children[1]);
			    expect(originalDiv2).toBe(container.firstChild.children[2]);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\singlepatches.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(27)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\state.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createComponentVNode, render, rerender \} from 'inferno';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			let renderCount = 0;
			
			class TestCWRP extends Component<any, any> \{
			  public state = \{
			    a: 0,
			    b: 0
			  \};
			
			  constructor(props) \{
			    super(props);
			  \}
			
			  public componentWillReceiveProps() \{
			    this.setState(\{ a: 1 \});
			
			    expect(this.state.a).toBe(0); // It should be 0 because state is not synchronously updated
			  \}
			
			  public render() \{
			    if (renderCount === 0) \{
			      expect(this.state.a).toBe(0);
			    \} else if (renderCount === 1) \{
			      expect(this.state.a).toBe(1); // Changed in CWRP
			    \}
			
			    renderCount++;
			
			    return <div>\{JSON.stringify(this.state)\}</div>;
			  \}
			\}
			
			describe('state', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  // As per React
			  it('Should not have state defined in base constructor', () => \{
			    class Foo extends Component<any, any> \{
			      constructor(p, c) \{
			        super(p, c);
			
			        expect(this.state).toBeNull();
			      \}
			
			      public render() \{
			        return null;
			      \}
			    \}
			
			    const f = new Foo(\{\}, \{\});
			
			    expect(f).not.toBeNull();
			  \});
			
			  describe('setting state', () => \{
			    it('setState should apply state during componentWillReceiveProps', (done) => \{
			      render(createComponentVNode(VNodeFlags.ComponentClass, TestCWRP, \{\}), container);
			      expect(renderCount).toBe(1);
			
			      render(
			        createComponentVNode(VNodeFlags.ComponentClass, TestCWRP, \{
			          foo: 1
			        \}),
			        container
			      );
			      expect(renderCount).toBe(2);
			      done();
			    \});
			  \});
			
			  describe('didUpdate and setState', () => \{
			    it('order', (done) => \{
			      class Test extends Component<\{ scrollTop: number \}, any> \{
			        public state = \{
			          testScrollTop: 0
			        \};
			
			        constructor(props, context) \{
			          super(props, context);
			        \}
			
			        public componentWillReceiveProps(nextProps) \{
			          if (nextProps.scrollTop !== 0) \{
			            this.setState(\{ testScrollTop: nextProps.scrollTop \});
			          \}
			        \}
			
			        public componentDidUpdate(_prevProps, prevState) \{
			          expect(prevState.testScrollTop).toBe(0);
			          expect(this.state.testScrollTop).toBe(200);
			        \}
			
			        public render() \{
			          return <div style=\{\{ 'background-attachment': 'scroll' \}\}>aa</div>;
			        \}
			      \}
			
			      class Example extends Component<\{ name: string \}, \{ exampleScrollTop: number \}> \{
			        public state = \{
			          exampleScrollTop: 0
			        \};
			
			        constructor(props, context) \{
			          super(props, context);
			        \}
			
			        public render() \{
			          return <Test scrollTop=\{this.state.exampleScrollTop\} />;
			        \}
			
			        public componentDidMount() \{
			          setTimeout(() => \{
			            this.setState(\{ exampleScrollTop: 200 \});
			            rerender();
			
			            done();
			          \}, 50);
			        \}
			      \}
			
			      render(<Example name="World" />, container);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\state.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\styles.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ PropertiesHyphen \} from 'csstype';
			
			function styleNode(style) \{
			  return <div style=\{style\} />;
			\}
			
			function isCSSvariablesSupported() \{
			  const div = document.createElement('div');
			  document.body.appendChild(div);
			  div.style.cssText = '--my-color:red;background-color:var(--my-color);';
			  const backgroundIsRed = getComputedStyle(div).backgroundColor === 'rgb(255, 0, 0)';
			  document.body.removeChild(div);
			
			  return backgroundIsRed;
			\}
			
			describe('CSS style properties (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should set and remove dynamic styles', () => \{
			    const styles = \{ display: 'none', 'font-family': 'Arial', 'line-height': 2 \};
			
			    render(<div style=\{styles\} />, container);
			    expect(container.firstChild.style.fontFamily).toBe('Arial');
			    expect(container.firstChild.style.lineHeight).toBe('2');
			
			    render(<div />, container);
			    expect(container.firstChild.style.fontFamily).toBe('');
			    expect(container.firstChild.style.lineHeight).toBe('');
			  \});
			
			  it('should update styles if initially null', () => \{
			    let styles: PropertiesHyphen | null = null;
			    render(<div style=\{styles\} />, container);
			
			    styles = \{ display: 'block' \};
			
			    render(<div style=\{styles\} />, container);
			    expect(container.firstChild.style.display).toBe('block');
			  \});
			
			  it('should update styles if updated to null multiple times', () => \{
			    let styles: PropertiesHyphen | null = null;
			
			    render(<div style=\{undefined\} />, container);
			
			    render(<div style=\{styles\} />, container);
			    expect(container.firstChild.style.display).toBe('');
			
			    styles = \{ display: 'block' \};
			
			    render(<div style=\{styles\} />, container);
			    expect(container.firstChild.style.display).toBe('block');
			
			    render(<div style=\{null\} />, container);
			    expect(container.firstChild.style.display).toBe('');
			
			    render(<div style=\{styles\} />, container);
			    expect(container.firstChild.style.display).toBe('block');
			
			    render(<div style=\{null\} />, container);
			    expect(container.firstChild.style.display).toBe('');
			  \});
			
			  it('should update styles when \`style\` changes from null to object', () => \{
			    const styles = \{ color: 'red' \};
			    // @ts-expect-error
			    render(<div style=\{123\} />, container);
			    render(<div style=\{styles\} />, container);
			    render(<div />, container);
			    render(<div style=\{styles\} />, container);
			
			    const stubStyle = container.firstChild.style;
			    expect(stubStyle.color).toBe('red');
			  \});
			
			  it('should support different unit types - em and mm', () => \{
			    const styles = \{ height: '200em', width: '20mm' \};
			    render(<div style=\{styles\} />, container);
			    render(<div />, container);
			    render(<div style=\{styles\} />, container);
			
			    const stubStyle = container.firstChild.style;
			    expect(stubStyle.height).toBe('200em');
			    expect(stubStyle.width).toBe('20mm');
			  \});
			
			  it('should clear all the styles when removing \`style\`', () => \{
			    const styles = \{ display: 'none', color: 'red' \};
			    render(<div style=\{styles\} />, container);
			
			    const stubStyle = container.firstChild.style;
			    expect(stubStyle.display).toBe('none');
			    expect(stubStyle.color).toBe('red');
			  \});
			
			  it('Should change styles', () => \{
			    const stylesOne = \{ color: 'red' \};
			    render(styleNode(stylesOne), container);
			    expect(container.firstChild.style.color).toBe('red');
			
			    const styles = \{ color: 'blue' \};
			    render(styleNode(styles), container);
			    expect(container.firstChild.style.color).toBe('blue');
			
			    const stylesTwo = \{ color: 'orange' \};
			    render(styleNode(stylesTwo), container);
			    expect(container.firstChild.style.color).toBe('orange');
			
			    const stylesThree = \{ color: 'orange' \};
			    render(styleNode(stylesThree), container);
			    expect(container.firstChild.style.color).toBe('orange');
			  \});
			
			  it('Should remove style attribute when next value is null', () => \{
			    const stylesOne = \{ color: 'green' \};
			    render(styleNode(stylesOne), container);
			    expect(container.firstChild.style.color).toBe('green');
			
			    render(styleNode(null), container);
			    expect(container.firstChild.style.cssText).toBe('');
			    // expect(container.innerHTML).to.eql('<div></div>');
			  \});
			
			  it('Should remove style attribute when single prop value is undefined', () => \{
			    const stylesOne = \{ 'text-align': 'center', color: 'red', display: 'block' \};
			    render(styleNode(stylesOne), container);
			    expect(container.firstChild.style.textAlign).toBe('center');
			
			    const stylesTwo = \{ 'text-align': 'left', display: 'none' \};
			    render(styleNode(stylesTwo), container);
			    expect(container.firstChild.style.textAlign).toBe('left');
			    expect(container.firstChild.style.display).toBe('none');
			    expect(container.firstChild.style.color).toBe('');
			  \});
			
			  // Test for CSS variable support, depends on browser
			  if (isCSSvariablesSupported()) \{
			    it('Should support inline CSS variables string way', () => \{
			      render(<div style="--my-color:red;background-color:var(--my-color);" />, container);
			
			      expect(getComputedStyle(container.firstChild).backgroundColor).toBe('rgb(255, 0, 0)'); // verify its red
			    \});
			
			    it('Should support inline CSS variables object way', () => \{
			      render(<div style=\{\{ '--my-color': 'red', 'background-color': 'var(--my-color)' \}\} />, container);
			
			      expect(getComputedStyle(container.firstChild).backgroundColor).toBe('rgb(255, 0, 0)'); // verify its red
			    \});
			  \}
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\styles.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(11)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\svgXlink.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			
			describe('createTree - SVG (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			  \});
			
			  it('should remove namespaced SVG attributes', () => \{
			    render(
			      <svg>
			        <image xlink:href="http://i.imgur.com/w7GCRPb.png" />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(true);
			
			    render(
			      <svg>
			        <image />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			  \});
			
			  it('should update namespaced SVG attributes', () => \{
			    render(
			      <svg>
			        <image xlink:href="http://i.imgur.com/w7GCRPb.png" />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(true);
			
			    render(
			      <svg>
			        <image xlink:href="http://i.imgur.com/JvqCM2p.png" />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.firstChild.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe('http://i.imgur.com/JvqCM2p.png');
			  \});
			
			  it('should add / change / remove xlink:href attribute', () => \{
			    render(
			      <svg>
			        <use xlink:href="#test" />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe('#test');
			
			    render(
			      <svg>
			        <use class="test" xlink:href="#changed" />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe('#changed');
			
			    render(
			      <svg>
			        <use />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			  \});
			
			  it('should add / change / remove xlinkHref attribute (babel plugin should transpile it)', () => \{
			    render(
			      <svg>
			        <use xlinkHref="#test" />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe('#test');
			
			    render(
			      <svg>
			        <use xlinkHref="#changed" />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe('#changed');
			
			    render(
			      <svg>
			        <use />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\svgXlink.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\topcontext.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createFragment, Fragment, render \} from 'inferno';
			import \{ ChildFlags \} from 'inferno-vnode-flags';
			
			describe('top level context', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should be possible to seed context object in render', () => \{
			    function Child(_props, context) \{
			      return (
			        <span>
			          \{context.foo\} \{context.bar\}
			        </span>
			      );
			    \}
			
			    render(<Child />, container, null, \{
			      bar: 'second',
			      foo: 'first'
			    \});
			
			    expect(container.innerHTML).toBe('<span>first second</span>');
			  \});
			
			  it('Should merge top level context with child context', () => \{
			    function Child(_props, context) \{
			      return (
			        <span>
			          \{context.foo\} \{context.bar\}
			        </span>
			      );
			    \}
			
			    class Parent extends Component<any, any> \{
			      public getChildContext() \{
			        return \{
			          foo: 'bar'
			        \};
			      \}
			
			      public render(_props, _state, context) \{
			        return [<div>\{context.foo\}</div>, <Child />];
			      \}
			    \}
			
			    render(<Parent />, container, null, \{
			      bar: 'second',
			      foo: 'first'
			    \});
			
			    expect(container.innerHTML).toBe('<div>first</div><span>bar second</span>');
			  \});
			
			  it('Should pass context correctly through Fragment when it has single child', () => \{
			    function Child(_props, context) \{
			      return (
			        <span>
			          \{context.foo\} \{context.bar\}
			        </span>
			      );
			    \}
			
			    class Parent extends Component<any, any> \{
			      public render() \{
			        return createFragment(<Child />, ChildFlags.HasVNodeChildren);
			      \}
			    \}
			
			    render(<Parent />, container, null, \{
			      bar: 'second',
			      foo: 'first'
			    \});
			
			    expect(container.innerHTML).toBe('<span>first second</span>');
			  \});
			
			  it('Should pass context correctly through Fragment when it has multiple children', () => \{
			    function Child(_props, context) \{
			      return (
			        <span>
			          \{context.foo\} \{context.bar\}
			        </span>
			      );
			    \}
			
			    class Parent extends Component<any, any> \{
			      public getChildContext() \{
			        return \{
			          foo: 'bar'
			        \};
			      \}
			
			      public render(_props, _state, context) \{
			        return [
			          <div>\{context.foo\}</div>,
			          <Fragment>
			            <Child />
			          </Fragment>
			        ];
			      \}
			    \}
			
			    render(
			      <Fragment>
			        <Parent />
			      </Fragment>,
			      container,
			      null,
			      \{
			        bar: 'second',
			        foo: 'first'
			      \}
			    );
			
			    expect(container.innerHTML).toBe('<div>first</div><span>bar second</span>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\topcontext.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\transition.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			
			describe('transition events', () => \{
			  let container;
			
			  function forceReflow() \{
			    return document.body.clientHeight;
			  \}
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  const transitionStyles = \{
			    background: 'red',
			    height: '16px',
			    left: '16px',
			    position: 'absolute' as any,
			    top: '16px',
			    transition: 'left 1ms',
			    width: '16px'
			  \};
			
			  it('should call "ontransitionend" at the end of a transition', (done) => \{
			    render(
			      <div
			        style=\{transitionStyles\}
			        onclick=\{(e) => \{
			          (e.target as HTMLDivElement).style.left = '50px';
			        \}\}
			        ontransitionend=\{(e) => \{
			          expect(e.type).toEqual('transitionend');
			          done();
			        \}\}
			      />,
			      container
			    );
			    // Be absolutely sure the transition has been applied through style
			    forceReflow();
			    const div = container.firstChild;
			    div.click();
			    // Be absolutely sure the transition has been applied through style
			    forceReflow();
			  \});
			
			  it('should call "onTransitionEnd" at the end of a transition', (done) => \{
			    render(
			      <div
			        style=\{transitionStyles\}
			        onclick=\{(e) => \{
			          (e.target as HTMLDivElement).style.left = '100px';
			        \}\}
			        onTransitionEnd=\{(e) => \{
			          expect(e.type).toEqual('transitionend');
			          done();
			        \}\}
			      />,
			      container
			    );
			    // Be absolutely sure the transition has been applied through style
			    forceReflow();
			    const div = container.firstChild;
			    div.click();
			    // Be absolutely sure the transition has been applied through style
			    forceReflow();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\transition.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\types.children.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, InfernoNode, InfernoSingleNode \} from 'inferno';
			
			describe('children types', () => \{
			  it('Should be possible to type child as component', () => \{
			    interface ParentComponentProps \{
			      children: FooBarCom;
			    \}
			
			    class FooBarCom extends Component<any, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			
			      public myMethod() \{
			        return 'foobar';
			      \}
			
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    class ParentComponent extends Component<ParentComponentProps, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			      public render(\{ children \}: ParentComponentProps) \{
			        children.myMethod();
			        this.props.children.myMethod();
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    // @ts-expect-error
			    const a = <ParentComponent></ParentComponent>;
			
			    const valid = (
			      <ParentComponent>
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    expect(valid).toBeDefined();
			  \});
			
			  it('Should be possible to type child as array', () => \{
			    interface ParentComponentProps \{
			      children: FooBarCom[];
			    \}
			
			    class FooBarCom extends Component<any, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			
			      public myMethod() \{
			        return 'foobar';
			      \}
			
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    class ParentComponent extends Component<ParentComponentProps, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			      public render(\{ children \}: ParentComponentProps) \{
			        children[0].myMethod();
			        this.props.children[0].myMethod();
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    // @ts-expect-error
			    const a = <ParentComponent></ParentComponent>;
			
			    const valid = <ParentComponent>\{[<FooBarCom />]\}</ParentComponent>;
			    const valid1 = (
			      <ParentComponent>
			        <FooBarCom />
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    const alsoValidForNow = (
			      <ParentComponent>
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    expect(valid).toBeDefined();
			    expect(valid1).toBeDefined();
			    expect(alsoValidForNow).toBeDefined();
			  \});
			
			  it('Should be possible to type child as InfernoNode', () => \{
			    interface ParentComponentProps \{
			      children?: InfernoNode;
			    \}
			
			    class FooBarCom extends Component<any, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			
			      public myMethod() \{
			        return 'foobar';
			      \}
			
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    class ParentComponent extends Component<ParentComponentProps, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			      public render(\{ children \}: ParentComponentProps) \{
			        // children.myMethod();
			        // this.props.children.myMethod();
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    // InfernoNode accepts any valid JSX as children
			    const valid = (
			      <ParentComponent>
			        <FooBarCom />
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    // Children defined optional so leaving it empty is also ok
			    const valid2 = <ParentComponent></ParentComponent>;
			
			    // Single child also ok
			    const valid3 = (
			      <ParentComponent>
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    expect(valid).toBeDefined();
			    expect(valid2).toBeDefined();
			    expect(valid3).toBeDefined();
			  \});
			
			  it('Should be possible to type child as InfernoNode', () => \{
			    interface ParentComponentProps \{
			      children: InfernoSingleNode;
			    \}
			
			    class FooBarCom extends Component<any, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			
			      public myMethod() \{
			        return 'foobar';
			      \}
			
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    class ParentComponent extends Component<ParentComponentProps, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			      public render(\{ children \}: ParentComponentProps) \{
			        // children.myMethod();
			        // this.props.children.myMethod();
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    // Children defined InfernoSingleNode so array is not acceptable
			    const invalid1 = (
			      // @ts-expect-error
			      <ParentComponent>
			        <FooBarCom />
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    // Children not defined optional so leaving it empty is error
			    // @ts-expect-error
			    const invalid2 = <ParentComponent></ParentComponent>;
			
			    // Single child component is ok
			    const valid1 = (
			      <ParentComponent>
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    // Single child div is ok
			    const valid2 = (
			      <ParentComponent>
			        <div>1</div>
			      </ParentComponent>
			    );
			
			    expect(invalid1).toBeDefined();
			    expect(invalid2).toBeDefined();
			    expect(valid1).toBeDefined();
			    expect(valid2).toBeDefined();
			  \});
			
			  it('Should be possible to type child as another component type', () => \{
			    class FooBarCom extends Component<any, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			
			      public myMethod() \{
			        return 'foobar';
			      \}
			
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    interface ParentComponentProps \{
			      children: FooBarCom[];
			    \}
			
			    class ParentComponent extends Component<ParentComponentProps, any> \{
			      public render(\{ children \}: ParentComponentProps) \{
			        // children.myMethod();
			        // this.props.children.myMethod();
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    // Children defined InfernoSingleNode so array is not acceptable
			    const invalid1 = (
			      <ParentComponent>
			        <FooBarCom />
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    // Children not defined optional so leaving it empty is error
			    // @ts-expect-error
			    const invalid2 = <ParentComponent></ParentComponent>;
			
			    // Single child component is ok
			    const valid1 = (
			      <ParentComponent>
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    // Single child div is ok
			    const valid2 = (
			      <ParentComponent>
			        <div>1</div>
			      </ParentComponent>
			    );
			
			    expect(invalid1).toBeDefined();
			    expect(invalid2).toBeDefined();
			    expect(valid1).toBeDefined();
			    expect(valid2).toBeDefined();
			  \});
			
			  it('Should be possible to type child as another component type', () => \{
			    class FooBarCom extends Component<any, any> \{
			      constructor(p, c) \{
			        super(p, c);
			      \}
			
			      public myMethod() \{
			        return 'foobar';
			      \}
			
			      public render(\{ children \}: any) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    interface ParentComponentProps \{
			      children: FooBarCom;
			    \}
			
			    class ParentComponent extends Component<ParentComponentProps, any> \{
			      public render(\{ children \}: Readonly<ParentComponentProps>) \{
			        children.myMethod();
			        this.props.children.myMethod();
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    // Children defined InfernoSingleNode so array is not acceptable
			    const invalid1 = (
			      // @ts-expect-error
			      <ParentComponent>
			        <FooBarCom />
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    // Children not defined optional so leaving it empty is error
			    // @ts-expect-error
			    const invalid2 = <ParentComponent></ParentComponent>;
			
			    // Single child component is ok
			    const valid1 = (
			      <ParentComponent>
			        <FooBarCom />
			      </ParentComponent>
			    );
			
			    // Single child div is ok
			    const valid2 = (
			      <ParentComponent>
			        <div>1</div>
			      </ParentComponent>
			    );
			
			    expect(invalid1).toBeDefined();
			    expect(invalid2).toBeDefined();
			    expect(valid1).toBeDefined();
			    expect(valid2).toBeDefined();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\types.children.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\types.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, ComponentType, createComponentVNode, createRef, createVNode, InfernoNode, linkEvent, Ref, render \} from 'inferno';
			import \{ emptyFn \} from 'inferno-shared';
			import \{ ChildFlags, VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('top level context', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('Rendering types', () => \{
			    it('Should render SFC jsx node', () => \{
			      const MyComponent = (props) => \{
			        return <div>\{props.children\}</div>;
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    it('Should be possible to return string from render SFC', () => \{
			      const MyComponent = () => \{
			        return 'd';
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    it('Should be possible to return number from render SFC', () => \{
			      const MyComponent = () => \{
			        return 1;
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    it('Should be possible to return null from render SFC', () => \{
			      const MyComponent = () => \{
			        return null;
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    describe('class component', function () \{
			      it('Should render jsx node - children', () => \{
			        class MyComponent extends Component<any, any> \{
			          public render(props) \{
			            return <div>\{props.children\}</div>;
			          \}
			        \}
			
			        render(<MyComponent />, container);
			      \});
			
			      it('Should ComponentType to be used as parameter for createComponentVNode', () => \{
			        interface TestCompProps \{
			          foo: number;
			          children?: InfernoNode;
			        \}
			
			        class TestComp extends Component<TestCompProps, any> \{
			          public render(props) \{
			            return createVNode(VNodeFlags.HtmlElement, 'div', null, props.foo, ChildFlags.HasTextChildren);
			          \}
			        \}
			
			        function TestFuncComp(props: TestCompProps) \{
			          return <span>\{props.foo\}</span>;
			        \}
			
			        function createComponent(val: number): ComponentType<\{
			          foo: number;
			        \}> \{
			          switch (val) \{
			            case 0:
			              return TestComp;
			            default:
			              return TestFuncComp;
			          \}
			        \}
			
			        class MyComponent extends Component<\{ val: number \}, any> \{
			          public render() \{
			            return createComponentVNode(VNodeFlags.ComponentUnknown, createComponent(this.props.val), \{ foo: 765 \});
			          \}
			        \}
			
			        render(<MyComponent val=\{1\} />, container);
			
			        expect(container.innerHTML).toBe('<span>765</span>');
			
			        render(<MyComponent val=\{0\} />, container);
			
			        expect(container.innerHTML).toBe('<div>765</div>');
			      \});
			
			      it('Should render children directly (props)', () => \{
			        class MyComponent extends Component<any, any> \{
			          public render(props) \{
			            return props.children;
			          \}
			        \}
			
			        render(<MyComponent />, container);
			      \});
			
			      it('Should render children directly (this)', () => \{
			        class MyComponent extends Component<any, any> \{
			          public render() \{
			            return this.props.children;
			          \}
			        \}
			
			        render(<MyComponent />, container);
			      \});
			
			      it('Should be possible to return string from class component render', () => \{
			        class MyComponent extends Component<any, any> \{
			          public render() \{
			            return 'd';
			          \}
			        \}
			
			        render(<MyComponent />, container);
			      \});
			
			      it('Should be possible to return number from class component render', () => \{
			        class MyComponent extends Component<any, any> \{
			          public render() \{
			            return 1;
			          \}
			        \}
			
			        render(<MyComponent />, container);
			      \});
			
			      it('Should be possible to return null from class component render', () => \{
			        class MyComponent extends Component<any, any> \{
			          public render() \{
			            return null;
			          \}
			        \}
			
			        render(<MyComponent />, container);
			      \});
			
			      it('Should be possible to return InfernoNode from class component render', () => \{
			        class FooBar extends Component<any, any> \{
			          public render() \{
			            return 'foobar';
			          \}
			        \}
			
			        class MyComponent extends Component<any, any> \{
			          public render() \{
			            let Val: InfernoNode = <FooBar />;
			
			            if (this.props.check) \{
			              Val = <div>1</div>;
			            \} else \{
			              Val = <div>\{Val\}</div>;
			            \}
			
			            return Val;
			          \}
			        \}
			
			        render(<MyComponent />, container);
			      \});
			    \});
			  \});
			
			  describe('JSX', function () \{
			    it('Should allow setting events null', function () \{
			      render(<div onClick=\{null\} />, container);
			    \});
			
			    it('Should allow setting linkEvent as event', function () \{
			      const myObj: \{ a: number \} = \{
			        a: 1
			      \};
			
			      function myFunction(data, ev) \{
			        expect(data.a).toBe(1);
			        expect(ev).toBeDefined();
			      \}
			
			      render(<div onClick=\{linkEvent(myObj, myFunction)\} />, container);
			    \});
			
			    it('styles object', function () \{
			      const getColor = () => 'red';
			
			      render(<div style=\{\{ 'background-color': getColor() \}\} />, container);
			    \});
			
			    it('styles as string', function () \{
			      render(<div style="background-color: red" />, container);
			    \});
			  \});
			
			  describe('ChildFlags', function () \{
			    it('Should allow special flags on all elements', function () \{
			      const refObj = createRef<HTMLDivElement>();
			      const text = 'foobar';
			      const row = (
			        <div className="floating-row-number" \$HasTextChildren onClick=\{emptyFn\}>
			          \{text\}
			        </div>
			      );
			
			      render(
			        <div className="floating-row-numbers" ref=\{refObj\} \$HasVNodeChildren>
			          \{row\}
			        </div>,
			        container
			      );
			    \});
			
			    it('Should allow special flags on SVG', function () \{
			      const refObj = createRef<SVGSVGElement>();
			      const text = 'foobar';
			      const row = (
			        <div className="floating-row-number" \$HasTextChildren onClick=\{emptyFn\}>
			          \{text\}
			        </div>
			      );
			
			      render(
			        <svg className="floating-row-numbers" ref=\{refObj\} \$HasVNodeChildren>
			          \{row\}
			        </svg>,
			        container
			      );
			    \});
			
			    it('Should allow null for attributes', function () \{
			      const row = <div tabIndex=\{null\}></div>;
			      const aria = <div aria-activedescendant=\{null\}></div>;
			
			      expect(row).not.toBeNull();
			      expect(aria).not.toBeNull();
			    \});
			
			    it('Should allow null for ref attribute', function () \{
			      const obj: \{
			        refWrap: Ref<HTMLDivElement> | null;
			      \} = \{
			        refWrap: null
			      \};
			
			      render(<div ref=\{obj.refWrap\}></div>, container);
			    \});
			  \});
			
			  it('Should allow setting native events null', function () \{
			    render(<div onclick=\{null\} />, container);
			  \});
			
			  it('Should allow setting linkEvent as native event handler', function () \{
			    const myObj: \{ a: number \} = \{
			      a: 1
			    \};
			
			    function myFunction(data, ev) \{
			      expect(data.a).toBe(1);
			      expect(ev).toBeDefined();
			    \}
			
			    render(<div onclick=\{linkEvent(myObj, myFunction)\} />, container);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\types.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(22)
    });
    it('infernojs_inferno\\packages\\inferno\\__tests__\\validations.spec.tsx', () => {
        const sourceCode = `
			import \{ createTextVNode, render \} from 'inferno';
			import \{ ChildFlags \} from 'inferno-vnode-flags';
			
			describe('Development warnings', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  // Browsers format error messages little bit differently so just skip those in tests. As long as messages are ok its fine.
			  if (typeof global !== 'undefined' && global.usingJSDOM) \{
			    describe('Warning two duplicate keys', () => \{
			      it('Should throw error if two duplicates is found', () => \{
			        const errorNode = (
			          <div>
			            <div key="1">2</div>
			            <div key="1">1</div>
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError('Inferno Error: Encountered two children with same key: \{1\}. Location: \\n>> <div>\\n>> <div>');
			      \});
			
			      it('Should throw error if two duplicate TEXTs is found with same key', () => \{
			        const errorNode = (
			          <div>
			            \{createTextVNode('foo', 'foo')\}
			            \{createTextVNode('foo2', 'foo')\}
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered two children with same key: \{foo\}. Location: \\n>> Text(foo2)\\n>> <div>'
			        );
			      \});
			
			      it('Should throw error if two duplicates is found (Component)', () => \{
			        const FooBar = (\{ children \}) => children;
			        const Tester = (\{ children \}) => children;
			        const errorNode = (
			          <div>
			            <FooBar key="1">2</FooBar>
			            <Tester key="1">1</Tester>
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered two children with same key: \{1\}. Location: \\n>> <Tester />\\n>> <div>'
			        );
			      \});
			
			      it('Should print nice stack of invalid key location', () => \{
			        // @ts-expect-error unused children
			        const FooBar = (\{ children \}) => (
			          <span className="parentNode">
			            <div key=\{'dup'\} />
			            <em key=\{'dup'\} />
			          </span>
			        );
			        const errorNode = (
			          <div>
			            <span>
			              <FooBar>
			                <span>1</span>
			              </FooBar>
			            </span>
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered two children with same key: \{dup\}. Location: \\n>> <em>\\n>> <span class="parentNode">'
			        );
			      \});
			    \});
			
			    describe('Warning key missing', () => \{
			      it('Should throw error if key is missing', () => \{
			        const errorNode = (
			          <div \$HasKeyedChildren>
			            <div key="1">2</div>
			            <div>1</div>
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered child without key during keyed algorithm. If this error points to Array make sure children is flat list. Location: \\n>> <div>\\n>> <div>'
			        );
			      \});
			
			      it('Should if there is one that cannot be keyed for example array', () => \{
			        const errorNode = (
			          <div \$ChildFlag=\{ChildFlags.HasKeyedChildren\}>
			            \{createTextVNode('foo', 'foo')\}
			            \{['1', '2']\}
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered ARRAY in mount, array must be flattened, or normalize used. Location: \\n>> Array(1,2)\\n>> <div>'
			        );
			      \});
			
			      it('Should show only first 3 items if array is really long one', () => \{
			        const errorNode = (
			          <div \$ChildFlag=\{ChildFlags.HasKeyedChildren\}>
			            \{createTextVNode('foo', 'foo')\}
			            \{[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\}
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered ARRAY in mount, array must be flattened, or normalize used. Location: \\n>> Array(1,2,3,...)\\n>> <div>'
			        );
			      \});
			
			      it('Should throw error if two duplicates is found (Component)', () => \{
			        const FooBar = (\{ children \}) => children;
			        const Tester = (\{ children \}) => children;
			        const errorNode = (
			          <div>
			            <FooBar key="1">2</FooBar>
			            <Tester key="1">1</Tester>
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered two children with same key: \{1\}. Location: \\n>> <Tester />\\n>> <div>'
			        );
			      \});
			
			      it('Should print nice stack of key missing', () => \{
			        const FooBar = () => (
			          <span className="parentNode" \$HasKeyedChildren>
			            <div key=\{'dup'\} />
			            \{2\}
			            <em key=\{'dup'\} />
			          </span>
			        );
			
			        const foobar = (
			          // @ts-expect-error Foobar has no children defined
			          <FooBar>
			            <span>1</span>
			          </FooBar>
			        );
			
			        const errorNode = (
			          <div>
			            <span \$HasVNodeChildren>\{foobar\}</span>
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Encountered child without key during keyed algorithm. If this error points to Array make sure children is flat list.'
			        );
			      \});
			    \});
			
			    describe('Invalid nodes', () => \{
			      it('Should throw error if key is missing', () => \{
			        const errorNode = (
			          <div \$HasKeyedChildren>
			            <div key="1">2</div>
			            \{null\}
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered invalid node when preparing to keyed algorithm. Location: \\n>> InvalidVNode(null)\\n>> <div>'
			        );
			      \});
			
			      it('Should if there is one that cannot be keyed for example array', () => \{
			        const errorNode = (
			          <div \$ChildFlag=\{ChildFlags.HasNonKeyedChildren\}>
			            \{createTextVNode('foo', 'foo')\}
			            \{null\}
			          </div>
			        );
			
			        expect(() => render(errorNode, container)).toThrowError(
			          'Inferno Error: Encountered invalid node with mixed keys. Location: \\n>> InvalidVNode(null)\\n>> <div>'
			        );
			      \});
			
			      it('Should support long chain of rendered nodes', () => \{
			        const errorNode = (
			          <div className="p1">
			            <div id="another">
			              <div data-attr="foobar">
			                <div \$ChildFlag=\{ChildFlags.HasNonKeyedChildren\}>
			                  \{createTextVNode('foo', 'foo')\}
			                  \{null\}
			                </div>
			              </div>
			            </div>
			          </div>
			        );
			
			        expect(() => \{
			          return render(errorNode, container);
			        \}).toThrowError('Inferno Error: Encountered invalid node with mixed keys. Location: \\n');
			      \});
			    \});
			  \}
			
			  describe('Invalid Element children', () => \{
			    it('Input cannot have children', () => \{
			      expect(() => render(<input>foobar</input>, container)).toThrowError("Inferno Error: input elements can't have children.");
			    \});
			
			    it('TextArea elements cannot have children', () => \{
			      expect(() => render(<textarea>foobar</textarea>, container)).toThrowError("Inferno Error: textarea elements can't have children.");
			    \});
			
			    it('Media elements cannot have children', () => \{
			      expect(() => render(<media>foobar</media>, container)).toThrowError("Inferno Error: media elements can't have children.");
			    \});
			
			    it('< BR > elements cannot have children', () => \{
			      expect(() => render(<br>foobar</br>, container)).toThrowError("Inferno Error: br elements can't have children.");
			    \});
			
			    it('< img > elements cannot have children', () => \{
			      expect(() => render(<img>foobar</img>, container)).toThrowError("Inferno Error: img elements can't have children.");
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno\\__tests__\\validations.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(17)
    });
    it('infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedAllComponent.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ renderToString \} from 'inferno-server';
			import \{ AnimatedAllComponent, componentDidAppear, componentWillDisappear, componentWillMove \} from 'inferno-animation';
			
			describe('inferno-animation AnimatedAllComponent', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  function waitForAnimationAndContinue(condition, callback, arg1?: any) \{
			    if (container.textContent !== condition) \{
			      setTimeout(waitForAnimationAndContinue.bind(null, condition, callback, arg1), 10);
			      return;
			    \}
			
			    callback(arg1);
			  \}
			
			  function afterEachClear(done) \{
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    done();
			  \}
			
			  afterEach(function (done) \{
			    render(null, container);
			    waitForAnimationAndContinue('', afterEachClear, done);
			  \});
			
			  it('should render class component extending AnimatedAllComponent into DOM', () => \{
			    class MyComponent extends AnimatedAllComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(<MyComponent>1</MyComponent>, container);
			    expect(container.textContent).toBe('1');
			  \});
			
			  it('should remove class component extending AnimatedAllComponent from DOM', (done) => \{
			    class My extends AnimatedAllComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#2">2</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedAllComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			
			    waitForAnimationAndContinue('13', function () \{
			      render(
			        <div>
			          <My key="#1">1</My>
			          <My key="#4">4</My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('14', function () \{
			        done();
			      \});
			    \});
			  \});
			
			  it('should move class component extending AnimatedAllComponent from DOM', (done) => \{
			    class My extends AnimatedAllComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#2">2</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#3">3</My>
			        <My key="#2">2</My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedAllComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			    // Disappear animations complete async
			
			    waitForAnimationAndContinue('132', function () \{
			      render(
			        <div>
			          <My key="#4">4</My>
			          <My key="#1">1</My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('41', function () \{
			        render(null, container);
			        done();
			      \});
			    \});
			  \});
			
			  it('should render class component extending AnimatedAllComponent to a string', () => \{
			    class MyComponent extends AnimatedAllComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    const outputStr = renderToString(<MyComponent>1</MyComponent>);
			    expect(outputStr).toBe('<div>1</div>');
			  \});
			\});
			
			describe('inferno-animation animated functional component', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  function waitForAnimationAndContinue(condition, callback, arg1?) \{
			    if (container.textContent !== condition) \{
			      setTimeout(waitForAnimationAndContinue.bind(null, condition, callback, arg1), 10);
			      return;
			    \}
			
			    callback(arg1);
			  \}
			
			  function afterEachClear(done) \{
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    done();
			  \}
			
			  afterEach(function (done) \{
			    render(null, container);
			    waitForAnimationAndContinue('', afterEachClear, done);
			  \});
			
			  it('should render class component extending AnimatedAllComponent into DOM', () => \{
			    const MyComponent = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    render(
			      <MyComponent onComponentDidAppear=\{componentDidAppear\} onComponentWillDisappear=\{componentWillDisappear\} onComponentWillMove=\{componentWillMove\}>
			        1
			      </MyComponent>,
			      container
			    );
			    expect(container.textContent).toBe('1');
			  \});
			
			  it('should remove class component extending AnimatedAllComponent from DOM', (done) => \{
			    const My = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentDidAppear: componentDidAppear,
			      onComponentWillDisappear: componentWillDisappear,
			      onComponentWillMove: componentWillMove
			    \};
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedAllComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			
			    waitForAnimationAndContinue('13', function () \{
			      render(
			        <div>
			          <My key="#1" \{...anim\}>
			            1
			          </My>
			          <My key="#4" \{...anim\}>
			            4
			          </My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('14', function () \{
			        done();
			      \});
			    \});
			  \});
			
			  it('should move class component extending AnimatedAllComponent from DOM', (done) => \{
			    const My = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentDidAppear: componentDidAppear,
			      onComponentWillDisappear: componentWillDisappear,
			      onComponentWillMove: componentWillMove
			    \};
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedAllComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			    // Disappear animations complete async
			
			    waitForAnimationAndContinue('132', function () \{
			      render(
			        <div>
			          <My key="#4" \{...anim\}>
			            4
			          </My>
			          <My key="#1" \{...anim\}>
			            1
			          </My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('41', function () \{
			        render(null, container);
			        done();
			      \});
			    \});
			  \});
			
			  it('should render class component extending AnimatedAllComponent to a string', () => \{
			    const MyComponent = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentDidAppear: componentDidAppear,
			      onComponentWillDisappear: componentWillDisappear,
			      onComponentWillMove: componentWillMove
			    \};
			
			    const outputStr = renderToString(<MyComponent \{...anim\}>1</MyComponent>);
			    expect(outputStr).toBe('<div>1</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedAllComponent.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedComponent.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ renderToString \} from 'inferno-server';
			import \{ AnimatedComponent, componentDidAppear, componentWillDisappear \} from 'inferno-animation';
			
			describe('inferno-animation AnimatedComponent', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  function waitForAnimationAndContinue(condition, callback, arg1?) \{
			    if (container.textContent !== condition) \{
			      setTimeout(waitForAnimationAndContinue.bind(null, condition, callback, arg1), 10);
			      return;
			    \}
			
			    callback(arg1);
			  \}
			
			  function afterEachClear(done) \{
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    done();
			  \}
			
			  afterEach(function (done) \{
			    render(null, container);
			    waitForAnimationAndContinue('', afterEachClear, done);
			  \});
			
			  it('should render class component extending AnimatedComponent into DOM', () => \{
			    class MyComponent extends AnimatedComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(<MyComponent>1</MyComponent>, container);
			    expect(container.textContent).toBe('1');
			  \});
			
			  it('should remove class component extending AnimatedComponent from DOM', (done) => \{
			    class My extends AnimatedComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#2">2</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			
			    waitForAnimationAndContinue('13', function () \{
			      render(
			        <div>
			          <My key="#1">1</My>
			          <My key="#4">4</My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('14', function () \{
			        done();
			      \});
			    \});
			  \});
			
			  it('should move class component extending AnimatedComponent from DOM', (done) => \{
			    class My extends AnimatedComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#2">2</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#3">3</My>
			        <My key="#2">2</My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			    // Disappear animations complete async
			
			    waitForAnimationAndContinue('132', function () \{
			      render(
			        <div>
			          <My key="#4">4</My>
			          <My key="#1">1</My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('41', function () \{
			        render(null, container);
			        done();
			      \});
			    \});
			  \});
			
			  it('should render class component extending AnimatedComponent to a string', () => \{
			    class MyComponent extends AnimatedComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    const outputStr = renderToString(<MyComponent>1</MyComponent>);
			    expect(outputStr).toBe('<div>1</div>');
			  \});
			\});
			
			describe('inferno-animation animated functional component', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  function waitForAnimationAndContinue(condition, callback, arg1?) \{
			    if (container.textContent !== condition) \{
			      setTimeout(waitForAnimationAndContinue.bind(null, condition, callback, arg1), 10);
			      return;
			    \}
			
			    callback(arg1);
			  \}
			
			  function afterEachClear(done) \{
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    done();
			  \}
			
			  afterEach(function (done) \{
			    render(null, container);
			    waitForAnimationAndContinue('', afterEachClear, done);
			  \});
			
			  it('should render class component extending AnimatedComponent into DOM', () => \{
			    const MyComponent = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    render(
			      <MyComponent onComponentDidAppear=\{componentDidAppear\} onComponentWillDisappear=\{componentWillDisappear\}>
			        1
			      </MyComponent>,
			      container
			    );
			    expect(container.textContent).toBe('1');
			  \});
			
			  it('should remove class component extending AnimatedComponent from DOM', (done) => \{
			    const My = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentDidAppear: componentDidAppear,
			      onComponentWillDisappear: componentWillDisappear
			    \};
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			
			    waitForAnimationAndContinue('13', function () \{
			      render(
			        <div>
			          <My key="#1" \{...anim\}>
			            1
			          </My>
			          <My key="#4" \{...anim\}>
			            4
			          </My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('14', function () \{
			        done();
			      \});
			    \});
			  \});
			
			  it('should move class component extending AnimatedComponent from DOM', (done) => \{
			    const My = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentDidAppear: componentDidAppear,
			      onComponentWillDisappear: componentWillDisappear
			    \};
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			    // Disappear animations complete async
			
			    waitForAnimationAndContinue('132', function () \{
			      render(
			        <div>
			          <My key="#4" \{...anim\}>
			            4
			          </My>
			          <My key="#1" \{...anim\}>
			            1
			          </My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('41', function () \{
			        render(null, container);
			        done();
			      \});
			    \});
			  \});
			
			  it('should render class component extending AnimatedComponent to a string', () => \{
			    const MyComponent = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentDidAppear: componentDidAppear,
			      onComponentWillDisappear: componentWillDisappear
			    \};
			
			    const outputStr = renderToString(<MyComponent \{...anim\}>1</MyComponent>);
			    expect(outputStr).toBe('<div>1</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedComponent.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedComponentTypings.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ AnimatedComponent \} from 'inferno-animation';
			
			describe('inferno-animation AnimatedComponent', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			  \});
			
			  it('Should be possible to define typed props for AnimatedComponent', () => \{
			    type MyProps = \{
			      number: number;
			    \};
			
			    class MyComponent extends AnimatedComponent<MyProps> \{
			      public render(props) \{
			        return <div>\{props.number\}</div>;
			      \}
			    \}
			
			    render(<MyComponent number=\{1\} />, container);
			
			    expect(container.innerHTML).toBe('<div>1</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedComponentTypings.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedMoveComponent.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ renderToString \} from 'inferno-server';
			import \{ AnimatedMoveComponent, componentWillMove \} from 'inferno-animation';
			
			describe('inferno-animation AnimatedMoveComponent', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  function waitForAnimationAndContinue(condition, callback, arg1?) \{
			    if (container.textContent !== condition) \{
			      setTimeout(waitForAnimationAndContinue.bind(null, condition, callback, arg1), 10);
			      return;
			    \}
			
			    callback(arg1);
			  \}
			
			  function afterEachClear(done) \{
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    done();
			  \}
			
			  afterEach(function (done) \{
			    render(null, container);
			    waitForAnimationAndContinue('', afterEachClear, done);
			  \});
			
			  it('should render class component extending AnimatedMoveComponent into DOM', () => \{
			    class MyComponent extends AnimatedMoveComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(<MyComponent>1</MyComponent>, container);
			    expect(container.textContent).toBe('1');
			  \});
			
			  it('should remove class component extending AnimatedMoveComponent from DOM', (done) => \{
			    class My extends AnimatedMoveComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#2">2</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedMoveComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			
			    waitForAnimationAndContinue('13', function () \{
			      render(
			        <div>
			          <My key="#1">1</My>
			          <My key="#4">4</My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('14', function () \{
			        done();
			      \});
			    \});
			  \});
			
			  it('should move class component extending AnimatedMoveComponent from DOM', (done) => \{
			    class My extends AnimatedMoveComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#2">2</My>
			        <My key="#3">3</My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1">1</My>
			        <My key="#3">3</My>
			        <My key="#2">2</My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedMoveComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			    // Disappear animations complete async
			
			    waitForAnimationAndContinue('132', function () \{
			      render(
			        <div>
			          <My key="#4">4</My>
			          <My key="#1">1</My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('41', function () \{
			        render(null, container);
			        done();
			      \});
			    \});
			  \});
			
			  it('should render class component extending AnimatedMoveComponent to a string', () => \{
			    class MyComponent extends AnimatedMoveComponent \{
			      public render(\{ children \}) \{
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    const outputStr = renderToString(<MyComponent>1</MyComponent>);
			    expect(outputStr).toBe('<div>1</div>');
			  \});
			\});
			
			describe('inferno-animation animated functional component', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  function waitForAnimationAndContinue(condition, callback, arg1?) \{
			    if (container.textContent !== condition) \{
			      setTimeout(waitForAnimationAndContinue.bind(null, condition, callback, arg1), 10);
			      return;
			    \}
			
			    callback(arg1);
			  \}
			
			  function afterEachClear(done) \{
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    done();
			  \}
			
			  afterEach(function (done) \{
			    render(null, container);
			    waitForAnimationAndContinue('', afterEachClear, done);
			  \});
			
			  it('should render class component extending AnimatedMoveComponent into DOM', () => \{
			    const MyComponent = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    render(<MyComponent onComponentWillMove=\{componentWillMove\}>1</MyComponent>, container);
			    expect(container.textContent).toBe('1');
			  \});
			
			  it('should remove class component extending AnimatedMoveComponent from DOM', (done) => \{
			    const My = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentWillMove: componentWillMove
			    \};
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedMoveComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			
			    waitForAnimationAndContinue('13', function () \{
			      render(
			        <div>
			          <My key="#1" \{...anim\}>
			            1
			          </My>
			          <My key="#4" \{...anim\}>
			            4
			          </My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('14', function () \{
			        done();
			      \});
			    \});
			  \});
			
			  it('should move class component extending AnimatedMoveComponent from DOM', (done) => \{
			    const My = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentWillMove: componentWillMove
			    \};
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			      </div>,
			      container
			    );
			    expect(container.textContent).toBe('123');
			
			    render(
			      <div>
			        <My key="#1" \{...anim\}>
			          1
			        </My>
			        <My key="#3" \{...anim\}>
			          3
			        </My>
			        <My key="#2" \{...anim\}>
			          2
			        </My>
			      </div>,
			      container
			    );
			
			    /**
			     * The reason for recursively calling checkRenderComplete_XXX instead of
			     * using a simpler setTimeout is due to a couple of async calls during the animations
			     * hooks of AnimatedMoveComponent. These can cause a setTimeout in the test to
			     * trigger prior to the animation callbacks and thus remove operations haven't yet
			     * been completed. As long as the render operation eventually completes correctly,
			     * the test should be considered successful.
			     */
			    // Disappear animations complete async
			
			    waitForAnimationAndContinue('132', function () \{
			      render(
			        <div>
			          <My key="#4" \{...anim\}>
			            4
			          </My>
			          <My key="#1" \{...anim\}>
			            1
			          </My>
			        </div>,
			        container
			      );
			
			      waitForAnimationAndContinue('41', function () \{
			        render(null, container);
			        done();
			      \});
			    \});
			  \});
			
			  it('should render class component extending AnimatedMoveComponent to a string', () => \{
			    const MyComponent = (\{ children \}) => \{
			      return <div>\{children\}</div>;
			    \};
			
			    const anim = \{
			      onComponentWillMove: componentWillMove
			    \};
			
			    const outputStr = renderToString(<MyComponent \{...anim\}>1</MyComponent>);
			    expect(outputStr).toBe('<div>1</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-animation\\__tests__\\animatedMoveComponent.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-animation\\__tests__\\index.spec.tsx', () => {
        const sourceCode = `
			import \{ AnimatedComponent, utils \} from 'inferno-animation';
			
			describe('inferno-animation public API', () => \{
			  it('should expose AnimatedComponent', () => \{
			    expect(AnimatedComponent).not.toBeUndefined();
			  \});
			  it('should expose utils', () => \{
			    const \{ addClassName, removeClassName, registerTransitionListener, forceReflow, clearDimensions, getDimensions, setDimensions, setDisplay \} = utils;
			    expect(addClassName).not.toBeUndefined();
			    expect(removeClassName).not.toBeUndefined();
			    expect(registerTransitionListener).not.toBeUndefined();
			    expect(forceReflow).not.toBeUndefined();
			    expect(clearDimensions).not.toBeUndefined();
			    expect(getDimensions).not.toBeUndefined();
			    expect(setDimensions).not.toBeUndefined();
			    expect(setDisplay).not.toBeUndefined();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-animation\\__tests__\\index.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-animation\\__tests__\\utils.spec.server-nodom.tsx', () => {
        const sourceCode = `
			import \{ transitionEndName \} from '../src/utils';
			
			describe('inferno-animation utils SSR', () => \{
			  it('transitionEnd is empty string', () => \{
			    expect(transitionEndName).toEqual('');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-animation\\__tests__\\utils.spec.server-nodom.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-animation\\__tests__\\utils.spec.tsx', () => {
        const sourceCode = `
			import \{
			  addClassName,
			  clearDimensions,
			  forceReflow,
			  getDimensions,
			  registerTransitionListener,
			  removeClassName,
			  setDimensions,
			  setDisplay,
			  transitionEndName
			\} from '../src/utils';
			
			describe('inferno-animation utils', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  function renderTemplate(dom) \{
			    dom.innerHTML = '<div><div class="target">content</div></div>';
			  \}
			
			  it('addClassName', () => \{
			    renderTemplate(container);
			    const el = document.querySelector('.target') as HTMLElement;
			    addClassName(el, 'test');
			    addClassName(el, '');
			    expect(el.className).toEqual('target test');
			  \});
			
			  it('removeClassName', () => \{
			    renderTemplate(container);
			    const el = document.querySelector('.target') as HTMLElement;
			    removeClassName(el, 'target');
			    removeClassName(el, '');
			    expect(el.className).toEqual('');
			  \});
			
			  it('forceReflow', () => \{
			    renderTemplate(container);
			    const res = forceReflow();
			    expect(res).not.toBeUndefined();
			  \});
			
			  it('setDisplay', () => \{
			    renderTemplate(container);
			    const el = document.querySelector('.target') as HTMLElement;
			    setDisplay(el, 'block');
			    setDisplay(el, 'block');
			    expect(el.style.getPropertyValue('display')).toEqual('block');
			
			    // Removes style prop
			    setDisplay(el, undefined);
			    // NOTE: For some reason we get a lingering 'style' attribute in on the DOM
			    // element. This is the recomended though
			    // https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
			    expect(el.outerHTML).toEqual('<div class="target" style="">content</div>');
			
			    // Just clear display prop
			
			    setDisplay(el, 'block');
			    setDimensions(el, 10, 10);
			    setDisplay(el, undefined);
			    expect(el.style.getPropertyValue('display')).toEqual('');
			  \});
			
			  it('getDimensions', () => \{
			    renderTemplate(container);
			    const el = document.querySelector('.target') as HTMLElement;
			    const res = getDimensions(el);
			    expect(res).not.toEqual(undefined);
			
			    el.style.display = 'none';
			    const res2 = getDimensions(el);
			    expect(res2).not.toEqual(undefined);
			  \});
			
			  it('setDimensions', () => \{
			    renderTemplate(container);
			    const el = document.querySelector('.target') as HTMLElement;
			    setDimensions(el, 10, 10);
			    const width = el.style.getPropertyValue('width');
			    const height = el.style.getPropertyValue('height');
			    expect(width).toEqual('10px');
			    expect(height).toEqual('10px');
			  \});
			
			  it('clearDimensions', () => \{
			    renderTemplate(container);
			    const el = document.querySelector('.target') as HTMLElement;
			    setDimensions(el, 10, 10);
			    clearDimensions(el);
			    const width = el.style.getPropertyValue('width');
			    const height = el.style.getPropertyValue('height');
			    expect(width).toEqual('');
			    expect(height).toEqual('');
			  \});
			
			  it('registerTransitionListener', (done) => \{
			    renderTemplate(container);
			    const el = document.querySelector('.target') as HTMLElement;
			
			    registerTransitionListener([el], () => \{
			      // We should always get a callback
			      done();
			    \});
			  \});
			
			  it('registerTransitionListener for IMG', (done) => \{
			    container.innerHTML = '<div><img class="target" /></div>';
			    const el = document.querySelector('.target') as HTMLElement;
			
			    registerTransitionListener([el], () => \{
			      // We should always get a callback
			      done();
			    \});
			    el.dispatchEvent(new Event('load'));
			  \});
			
			  it('transitionEnd is valid', () => \{
			    expect(transitionEndName).toEqual('transitionend');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-animation\\__tests__\\utils.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(10)
    });
    it('infernojs_inferno\\packages\\inferno-clone-vnode\\__tests__\\cloneVNode.spec.tsx', () => {
        const sourceCode = `
			import \{ cloneVNode \} from 'inferno-clone-vnode';
			import \{ Component, createTextVNode, Fragment, InfernoSingleNode, render, VNode \} from 'inferno';
			
			describe('cloneVNode (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			  \});
			
			  it('should clone a tag', () => \{
			    const node = cloneVNode(<a />, null);
			    render(node, container);
			    expect(container.innerHTML).toBe('<a></a>');
			  \});
			
			  it('should clone with third argument array', () => \{
			    const node = cloneVNode(<div />, null, [<span />]);
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><span></span></div>');
			  \});
			
			  it('should clone with third argument overriding props and cloned node children', () => \{
			    const node = cloneVNode(<div>f</div>, \{ children: 'x' \}, [<a>1</a>]);
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><a>1</a></div>');
			  \});
			
			  it('should clone with third argument overriding props and cloned node children', () => \{
			    const node = cloneVNode(<div>f</div>, \{ children: 'x' \}, [undefined]);
			    render(node, container);
			    expect(container.innerHTML).toBe('<div></div>');
			  \});
			
			  it('should clone OPT_ELEMENT', () => \{
			    const noop = () => \{\};
			    const node = cloneVNode(
			      // @ts-expect-error
			      <div onComponentWillMount=\{noop\} onComponentDidMount=\{noop\} onComponentWillUnmount=\{noop\} onComponentShouldUpdate=\{noop\} onComponentWillUpdate=\{noop\} />,
			      \{ children: [<span />] \}
			    );
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><span></span></div>');
			  \});
			
			  it('should clone a basic element with array children', () => \{
			    const node = cloneVNode(<div />, \{ children: [<span />] \});
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><span></span></div>');
			  \});
			
			  it('should clone a basic element with children in props and as third argument', () => \{
			    const node1 = cloneVNode(<div />, \{ children: <span>arr1a</span> \}, <span>arr2b</span>);
			    render(node1, container);
			    expect(container.innerHTML).toBe('<div><span>arr2b</span></div>');
			
			    const node2 = cloneVNode(<div />, \{ children: [<span>arr2a</span>] \}, <span>arr2b</span>);
			    render(node2, container);
			    expect(container.innerHTML).toBe('<div><span>arr2b</span></div>');
			
			    const node3 = cloneVNode(<div />, \{ children: [<span>arr3a</span>] \}, [<span>arr3b</span>]);
			    render(node3, container);
			    expect(container.innerHTML).toBe('<div><span>arr3b</span></div>');
			  \});
			
			  it('Should support multiple parameters as children', () => \{
			    // @ts-ignore
			    const node = cloneVNode(<div />, null, <span>arr3a</span>, <span>arr3b</span>, <span>arr3c</span>);
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><span>arr3a</span><span>arr3b</span><span>arr3c</span></div>');
			  \});
			
			  it('Should support multiple nodes as children inside array', () => \{
			    const node = cloneVNode(<div />, null, [<span>arr3a</span>, <span>arr3b</span>, <span>arr3c</span>]);
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><span>arr3a</span><span>arr3b</span><span>arr3c</span></div>');
			  \});
			
			  it('Should support single node as children', () => \{
			    const node = cloneVNode(<div />, null, <span>arr3a</span>);
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><span>arr3a</span></div>');
			  \});
			
			  it('Should support single node as children inside array', () => \{
			    const node = cloneVNode(<div />, null, [<span>arr3a</span>]);
			    render(node, container);
			    expect(container.innerHTML).toBe('<div><span>arr3a</span></div>');
			  \});
			
			  it('should clone a basic element with null children', () => \{
			    const node = cloneVNode(<div />, \{ children: null \});
			    render(node, container);
			    expect(container.innerHTML).toBe('<div></div>');
			  \});
			
			  it('should clone a basic element with key and ref', () => \{
			    const ref = () => \{\};
			    const node = cloneVNode(<div />, \{ key: 'foo', ref \});
			
			    expect(node.key).toBe('foo');
			    expect(node.ref).toBe(ref);
			  \});
			
			  it('should clone a basic element with different children and props', () => \{
			    const node1 = <div>Hello world</div>;
			    render(node1, container);
			    expect(container.innerHTML).toBe('<div>Hello world</div>');
			
			    const node2 = cloneVNode(node1, null, 'Hello world 2!');
			    render(node2, container);
			    expect(container.innerHTML).toBe('<div>Hello world 2!</div>');
			
			    const node3 = cloneVNode(node2, \{ className: 'foo' \}, 'Hello world 2!');
			    render(node3, container);
			    expect(container.innerHTML).toBe('<div class="foo">Hello world 2!</div>');
			
			    const node4 = cloneVNode(node1, \{ className: 'foo' \}, 'Hello world 3!');
			    render(node4, container);
			    expect(container.innerHTML).toBe('<div class="foo">Hello world 3!</div>');
			  \});
			
			  function StatelessComponent(props) \{
			    return <div \{...props\} />;
			  \}
			
			  it('should clone a basic stateless component with different children and props', () => \{
			    const node1 = <StatelessComponent children="Hello world" />;
			
			    render(node1, container);
			    expect(container.innerHTML).toBe('<div>Hello world</div>');
			    const node2 = cloneVNode(node1, \{ children: 'Hello world 2!' \});
			
			    render(node2, container);
			    expect(container.innerHTML).toBe('<div>Hello world 2!</div>');
			    const node3 = cloneVNode(node1, \{
			      children: 'Hello world 3!',
			      className: 'yo'
			    \});
			
			    render(node3, container);
			    expect(container.innerHTML).toBe('<div class="yo">Hello world 3!</div>');
			  \});
			
			  it('Should prefer falsy children (undefined) if its provided over existing children', () => \{
			    const node1 = <div>1</div>;
			    const clone = cloneVNode(node1, null, [undefined]);
			
			    render(clone, container);
			
			    expect(container.innerHTML).toEqual('<div></div>');
			  \});
			
			  it('Should clone Component with vNode div children', () => \{
			    class Com extends Component \{
			      public render(\{ children \}) \{
			        return children;
			      \}
			    \}
			    const com1 = (
			      <Com>
			        <div>abc</div>
			      </Com>
			    );
			    const clone = cloneVNode(com1);
			
			    render(clone, container);
			
			    expect(container.innerHTML).toEqual('<div>abc</div>');
			  \});
			
			  it('Should clone Component with no props at all', () => \{
			    class Com extends Component \{
			      public render(\{ children \}) \{
			        return children;
			      \}
			    \}
			    const com1 = <Com />;
			    const clone = cloneVNode(com1);
			
			    render(clone, container);
			
			    expect(container.innerHTML).toEqual('');
			  \});
			
			  it('Should clone vNode with no props at all', () => \{
			    const span = <span />;
			    const clone = cloneVNode(span);
			
			    render(clone, container);
			
			    expect(container.innerHTML).toEqual('<span></span>');
			  \});
			
			  it('Should clone Component with vNode text children', () => \{
			    class Com extends Component \{
			      public render() \{
			        return 'Text';
			      \}
			    \}
			    const com1 = (
			      <Com>
			        <div>1</div>
			      </Com>
			    );
			    const clone = cloneVNode(com1);
			
			    render(clone, container);
			
			    expect(container.innerHTML).toEqual('Text');
			  \});
			
			  it('Should clone textVNode', () => \{
			    const textNode = createTextVNode('foobar');
			    const clone = cloneVNode(textNode);
			
			    render(clone, container);
			
			    expect(container.innerHTML).toEqual('foobar');
			  \});
			
			  it('Should clone textVnode with new content', () => \{
			    const textNode = createTextVNode('foobar');
			    const clone = cloneVNode(textNode, null, 'foo');
			
			    render(clone, container);
			
			    expect(container.innerHTML).toEqual('foo');
			  \});
			
			  it('Should prefer children in order', () => \{
			    function Bar(\{ children \}) \{
			      return <div>\{children\}</div>;
			    \}
			
			    const nodeToClone = <Bar>First</Bar>;
			
			    render(nodeToClone, container);
			
			    expect(container.innerHTML).toBe('<div>First</div>');
			
			    render(cloneVNode(nodeToClone, \{ children: 'Second' \}), container);
			
			    expect(container.innerHTML).toBe('<div>Second</div>');
			
			    render(cloneVNode(nodeToClone, \{ children: 'Second' \}, 'Third'), container);
			
			    expect(container.innerHTML).toBe('<div>Third</div>');
			
			    // @ts-ignore
			    render(cloneVNode(nodeToClone, \{ children: 'Second' \}, 'Third', 'Fourth'), container);
			
			    expect(container.innerHTML).toBe('<div>ThirdFourth</div>');
			  \});
			
			  it('Should prefer children in order #2', () => \{
			    function Bar(\{ children \}) \{
			      return <div>\{children\}</div>;
			    \}
			
			    const nodeToClone = <Bar>First</Bar>;
			
			    render(nodeToClone, container);
			
			    expect(container.innerHTML).toBe('<div>First</div>');
			
			    render(cloneVNode(nodeToClone, null), container);
			
			    expect(container.innerHTML).toBe('<div>First</div>');
			
			    render(cloneVNode(nodeToClone, null, null), container);
			
			    expect(container.innerHTML).toBe('<div></div>');
			  \});
			
			  describe('Cloning className', () => \{
			    it('Should prefer new props over cloned object', () => \{
			      const node = <div className="test" />;
			
			      render(node, container);
			
			      expect(container.firstChild.className).toEqual('test');
			
			      const newNode = cloneVNode(node, \{
			        className: 'foo'
			      \});
			
			      render(newNode, container);
			      // expect(newNode.props.className).toBe(undefined); , This depends on if we are running inferno-compat or not
			      // expect(newNode.props.hasOwnProperty('className')).toBe(false);
			
			      expect(container.firstChild.className).toBe('foo');
			      expect(container.innerHTML).toEqual('<div class="foo"></div>');
			    \});
			
			    it('Should remove className if new one is empty', () => \{
			      const node = <div className="test" />;
			
			      render(node, container);
			
			      expect(container.firstChild.className).toEqual('test');
			
			      const newNode = cloneVNode(node, \{
			        className: null
			      \});
			
			      render(newNode, container);
			
			      expect(container.firstChild.className).toBe('');
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			
			    it('Should keep previous className when new props dont have that property at all', () => \{
			      const node = <div className="test" />;
			
			      render(node, container);
			
			      expect(container.firstChild.className).toEqual('test');
			
			      const newNode = cloneVNode(node, \{
			        id: 'wow'
			      \});
			
			      render(newNode, container);
			
			      expect(newNode.props.hasOwnProperty('id')).toBe(true);
			      // expect(newNode.props.className).toBe(undefined);
			      // expect(newNode.props.hasOwnProperty('className')).toBe(false);
			
			      expect(container.firstChild.className).toBe('test');
			      expect(container.firstChild.getAttribute('id')).toBe('wow');
			      expect(container.innerHTML).toEqual('<div class="test" id="wow"></div>');
			    \});
			
			    it('Should be possible to add props to children', () => \{
			      function Foobar(props) \{
			        return <div>\{cloneVNode(props.children, \{ foo: 'bar' \})\}</div>;
			      \}
			
			      function ChildCom(props) \{
			        return <div>\{props.foo\}</div>;
			      \}
			
			      render(
			        <Foobar>
			          <ChildCom foo="init" />
			        </Foobar>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>bar</div></div>');
			    \});
			  \});
			
			  describe('Cloning key', () => \{
			    it('Should prefer new props over cloned object', () => \{
			      const node = <div key="test" />;
			
			      expect(node.key).toEqual('test');
			
			      render(node, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      const newNode = cloneVNode(node, \{
			        key: 'foo'
			      \});
			
			      expect(newNode.key).toEqual('foo');
			      expect(newNode.props.ref).toBe(undefined);
			      // expect(newNode.props.hasOwnProperty('key')).toBe(false);
			      render(newNode, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			
			    it('Should remove key if new one is empty', () => \{
			      const node = <div key="test" />;
			
			      expect(node.key).toEqual('test');
			
			      render(node, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      const newNode = cloneVNode(node, \{
			        key: null
			      \});
			
			      expect(newNode.key).toEqual(null);
			
			      render(newNode, container);
			      expect(newNode.props.key).toBe(undefined);
			      // expect(newNode.props.hasOwnProperty('key')).toBe(false);
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			
			    it('Should keep previous key when new props dont have that property at all', () => \{
			      const node = <div key="test" />;
			
			      expect(node.key).toEqual('test');
			
			      render(node, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      const newNode = cloneVNode(node, \{
			        className: null
			      \});
			
			      expect(newNode.key).toEqual('test');
			      expect(newNode.props.key).toBe(undefined);
			      expect(newNode.props.className).toBe(undefined);
			      // expect(newNode.props.hasOwnProperty('key')).toBe(false);
			      // expect(newNode.props.hasOwnProperty('className')).toBe(false);
			      render(newNode, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			  \});
			
			  describe('Cloning Ref', () => \{
			    function initialFunc() \{\}
			
			    it('Should prefer new props over cloned object', () => \{
			      const node = <div ref=\{initialFunc\} />;
			
			      expect(node.ref).toEqual(initialFunc);
			
			      render(node, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      function newFunction() \{\}
			
			      const newNode = cloneVNode(node, \{
			        ref: newFunction
			      \});
			
			      expect(newNode.ref).toEqual(newFunction);
			      // expect(newNode.props.hasOwnProperty('ref')).toBe(false);
			      expect(newNode.props.ref).toBe(undefined);
			      render(newNode, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			
			    it('Should remove ref if new one is empty', () => \{
			      const node = <div ref=\{initialFunc\} />;
			
			      expect(node.ref).toEqual(initialFunc);
			
			      render(node, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      const newNode = cloneVNode(node, \{
			        ref: null
			      \});
			
			      expect(newNode.ref).toEqual(null);
			      // expect(newNode.props.hasOwnProperty('ref')).toBe(false);
			      expect(newNode.props.ref).toBe(undefined);
			      render(newNode, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			
			    it('Should keep previous ref when new props dont have that property at all', () => \{
			      const node = <div ref=\{initialFunc\} />;
			
			      expect(node.ref).toEqual(initialFunc);
			
			      render(node, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			
			      const newNode = cloneVNode(node, \{
			        className: null
			      \});
			
			      expect(newNode.ref).toEqual(initialFunc);
			      // expect(newNode.props.hasOwnProperty('className')).toBe(false);
			      expect(newNode.props.className).toBe(undefined);
			      expect(newNode.className).toBe(null);
			      render(newNode, container);
			      expect(container.innerHTML).toEqual('<div></div>');
			    \});
			  \});
			
			  describe('without children specified', () => \{
			    it('should render children one level deep', () => \{
			      interface NameContainerProps \{
			        children: InfernoSingleNode[];
			      \}
			      class NameContainer extends Component<NameContainerProps> \{
			        public render() \{
			          const children = this.props.children.map((c) =>
			            cloneVNode(c as VNode, \{
			              name: 'Henry'
			            \})
			          );
			
			          return <span>\{children\}</span>;
			        \}
			      \}
			
			      const NameViewer = () => \{
			        return (
			          <NameContainer>
			            <div className="test">
			              <span>A child that should render after the clone</span>
			            </div>
			            <div>
			              <span>A child that should render after the clone</span>
			            </div>
			          </NameContainer>
			        );
			      \};
			
			      render(<NameViewer />, container);
			
			      expect(container.innerHTML).toBe(\`<span><div class="test" name="Henry"><span>A child that should render after \\
			the clone</span></div><div name="Henry"><span>A child that should render after the clone</span></div></span>\`);
			    \});
			
			    it('should render children two levels deep', () => \{
			      const items = [\{ name: 'Mike Brady' \}, \{ name: 'Carol Brady' \}, \{ name: 'Greg Brady' \}, \{ name: 'Marcia Brady' \}];
			      const items2 = [\{ age: 28 \}, \{ age: 26 \}, \{ age: 16 \}, \{ age: 15 \}];
			
			      interface Wrapper1Props \{
			        children: InfernoSingleNode;
			      \}
			
			      class Wrapper1 extends Component<Wrapper1Props> \{
			        public render() \{
			          const children = cloneVNode(this.props.children as VNode, \{ items \});
			          return <div className="wrapper1">\{children\}</div>;
			        \}
			      \}
			
			      interface Wrapper2Props \{
			        items2: \{ age: number \}[];
			        items: \{ name: string \}[];
			        children: NormalItem[];
			      \}
			
			      class Wrapper2 extends Component<Wrapper2Props> \{
			        public render() \{
			          const children = this.props.children.map((c) => \{
			            return cloneVNode(c as any, \{
			              age: (c.props && c.props.index) != null ? this.props.items2[c.props.index as number].age : 'default-age',
			              name: (c.props && c.props.index) != null ? this.props.items[c.props.index as number].name : 'default-name',
			              propsIndex: c.props && c.props.index
			            \});
			          \});
			
			          return <div className="wrapper2">\{children\}</div>;
			        \}
			      \}
			
			      interface ItemProps \{
			        index?: number;
			        name?: string;
			        age?: string;
			      \}
			
			      class Item extends Component<ItemProps> \{
			        public render() \{
			          return (
			            <span>
			              item \{this.props.name\} - age: \{this.props.age\}
			            </span>
			          );
			        \}
			      \}
			
			      interface NormalItemProps \{
			        index?: number;
			        name?: string;
			        age?: string;
			      \}
			      class NormalItem extends Component<NormalItemProps> \{
			        public render() \{
			          return (
			            <span>
			              Normal Item \{this.props.name\} - age: \{this.props.age\}
			            </span>
			          );
			        \}
			      \}
			
			      class App extends Component \{
			        public render() \{
			          const content: NormalItem[] = [<NormalItem />, <NormalItem />];
			
			          items.forEach((_d, idx) => content.push(<Item index=\{idx\} />));
			
			          return (
			            <Wrapper1>
			              <Wrapper2 items=\{[]\} items2=\{items2\}>
			                \{content\}
			              </Wrapper2>
			            </Wrapper1>
			          );
			        \}
			      \}
			
			      render(<App />, container);
			
			      expect(container.innerHTML).toBe(\`<div class="wrapper1"><div class="wrapper2"><span>Normal Item default-name \\
			- age: default-age</span><span>Normal Item default-name - age: default-age</span><span>item Mike Brady - age: \\
			28</span><span>item Carol Brady - age: 26</span><span>item Greg Brady - age: 16</span><span>item Marcia Brady \\
			- age: 15</span></div></div>\`);
			    \});
			  \});
			
			  it('Should not clone all children of Component', () => \{
			    // React fiddle of cloneElement https://jsfiddle.net/5wh3cfn0/
			    class Hello extends Component<\{ name?: string \}> \{
			      public render() \{
			        return <div>Hello \{this.props.name\}</div>;
			      \}
			    \}
			
			    const node1 = (
			      <Hello>
			        <span>1</span>
			      </Hello>
			    );
			    const cloned1 = cloneVNode(node1);
			
			    expect(node1.props.children).toBe(cloned1.props.children);
			    expect(node1).not.toBe(cloned1);
			    expect(node1.props).not.toBe(cloned1.props);
			
			    const node = <div>\{[null, <div>1</div>, [<div>1</div>, <div>2</div>]]\}</div>;
			    const cloned = cloneVNode(node);
			
			    // Following assertion depends on if Inferno-compat is used or not
			    // expect(node.props.children).toBe(cloned.props.children);
			    expect(node).not.toBe(cloned);
			    expect(node.props).not.toBe(cloned.props);
			  \});
			
			  it('Should be possible to clone fragment', () => \{
			    const frag = (
			      <Fragment>
			        <span>1</span>
			        <span>2</span>
			      </Fragment>
			    );
			
			    render(cloneVNode(frag), container);
			
			    expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			
			    const firstChild = container.firstChild;
			
			    render(cloneVNode(frag), container);
			
			    expect(firstChild).toBe(container.firstChild);
			
			    expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-clone-vnode\\__tests__\\cloneVNode.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(38)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\clonevnode.spec.jsx', () => {
        const sourceCode = `
			import \{ createVNode, directClone \} from 'inferno-compat';
			import \{ ChildFlags, VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('directClone inferno-compat', () => \{
			  it('Should not lose props when cloning multiple times', () => \{
			    const vNode = createVNode(
			      VNodeFlags.HtmlElement,
			      'stop',
			      null,
			      null,
			      ChildFlags.HasInvalidChildren,
			      \{
			        offset: 0,
			        stopColor: 'white',
			        stopOpacity: 0.5
			      \},
			      null,
			      null
			    );
			
			    const cloned = directClone(vNode);
			    const cloned2 = directClone(cloned);
			
			    expect(cloned2.props['stop-color']).toBe('white');
			    expect(cloned2.props['stop-opacity']).toBe(0.5);
			    expect(cloned2.props['offset']).toBe(0);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\clonevnode.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\compat_children.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, createElement, isValidElement, render \} from 'inferno-compat';
			
			describe('Compat Children', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  function renderCompatTestElement(element) \{
			    render(element, container);
			  \}
			
			  describe('using createElement', () => \{
			    it('should create a VNode with the correct className', function () \{
			      const element = createElement('div', \{ className: 'foo', test: 'hi' \});
			      expect(element.className).toBe('foo');
			      expect(element.props).toEqual(\{ test: 'hi', className: 'foo' \});
			    \});
			
			    it('Should render element with a text string', function () \{
			      const element = createElement('div', null, 'body text');
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>body text</div>');
			    \});
			
			    it('Should render element with an array of one text string', function () \{
			      const element = createElement('div', null, ['body text']);
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>body text</div>');
			    \});
			
			    it('Should render element with an array of two text strings', function () \{
			      const element = createElement('div', null, ['first text', 'second text']);
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>first textsecond text</div>');
			    \});
			
			    it('Should render element with child element', function () \{
			      const child = createElement('span', null, 'child body text');
			      expect(isValidElement(child)).toBe(true);
			
			      const element = createElement('div', null, child);
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div><span>child body text</span></div>');
			    \});
			
			    it('Should render element with an array of one child element', function () \{
			      const child = createElement('span', null, 'child body text');
			      expect(isValidElement(child)).toBe(true);
			
			      const element = createElement('div', null, [child]);
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div><span>child body text</span></div>');
			    \});
			
			    it('Should render element with an array of two child elements', function () \{
			      const first_child = createElement('span', null, 'first text');
			      expect(isValidElement(first_child)).toBe(true);
			
			      const second_child = createElement('span', null, 'second text');
			      expect(isValidElement(second_child)).toBe(true);
			
			      const element = createElement('div', null, [first_child, second_child]);
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div><span>first text</span><span>second text</span></div>');
			    \});
			
			    it('Should render element with an array of a string and a child element', function () \{
			      const second_child = createElement('span', null, 'second text');
			      expect(isValidElement(second_child)).toBe(true);
			
			      const element = createElement('div', null, ['first text', second_child]);
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>first text<span>second text</span></div>');
			    \});
			
			    // Test Iterator support, skip if it is not supported in browser
			
			    if (typeof Symbol !== 'undefined' && typeof Symbol.iterator !== 'undefined') \{
			      function arrayAsBasicIterator(array) \{
			        return \{
			          [Symbol.iterator]: function () \{
			            let idx = 0;
			            return \{
			              next() \{
			                if (idx < array.length) \{
			                  return \{ value: array[idx++], done: false \};
			                \} else \{
			                  return \{ done: true \};
			                \}
			              \}
			            \};
			          \}
			        \};
			      \}
			
			      it('Should render element with an iterable of one text string', function () \{
			        const iterable = arrayAsBasicIterator(['generated body text']);
			        const element = createElement('div', null, iterable);
			        expect(isValidElement(element)).toBe(true);
			
			        renderCompatTestElement(element);
			
			        expect(container.innerHTML).toBe('<div>generated body text</div>');
			      \});
			
			      it('Should render element with an iterable of one child element', function () \{
			        const child = createElement('span', null, 'generated child body text');
			        expect(isValidElement(child)).toBe(true);
			
			        const iterable = arrayAsBasicIterator([child]);
			        const element = createElement('div', null, iterable);
			        expect(isValidElement(element)).toBe(true);
			
			        renderCompatTestElement(element);
			
			        expect(container.innerHTML).toBe('<div><span>generated child body text</span></div>');
			      \});
			
			      it('Should render element with an iterable of a child element and a string', function () \{
			        const child = createElement('span', null, 'generated child body text');
			        expect(isValidElement(child)).toBe(true);
			
			        const iterable = arrayAsBasicIterator([child, 'generated body text']);
			        const element = createElement('div', null, iterable);
			        expect(isValidElement(element)).toBe(true);
			
			        renderCompatTestElement(element);
			
			        expect(container.innerHTML).toBe('<div><span>generated child body text</span>generated body text</div>');
			      \});
			    \}
			  \});
			
			  describe('using JSX', () => \{
			    it('should create a VNode with the correct className', function () \{
			      const element = <div className="foo" test="hi" />;
			      expect(element.className).toBe('foo');
			      expect(element.props).toEqual(\{ test: 'hi', className: 'foo' \});
			    \});
			
			    it('Should render element with a text string', function () \{
			      const element = <div>body text</div>;
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>body text</div>');
			    \});
			
			    it('Should render element with an array of one text string', function () \{
			      const element = <div>\{['body text']\}</div>;
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>body text</div>');
			    \});
			
			    it('Should render element with an array of two text strings', function () \{
			      const element = <div>\{['first text', 'second text']\}</div>;
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>first textsecond text</div>');
			    \});
			
			    it('Should render element with child element', function () \{
			      const child = <span>\{'child body text'\}</span>;
			      expect(isValidElement(child)).toBe(true);
			
			      const element = <div>\{child\}</div>;
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div><span>child body text</span></div>');
			    \});
			
			    it('Should render element with an array of one child element', function () \{
			      const child = <span>child body text</span>;
			      expect(isValidElement(child)).toBe(true);
			
			      const element = <div>\{[child]\}</div>;
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div><span>child body text</span></div>');
			    \});
			
			    it('Should render element with an array of two child elements', function () \{
			      const first_child = <span>first text</span>;
			      expect(isValidElement(first_child)).toBe(true);
			
			      const second_child = <span>second text</span>;
			      expect(isValidElement(second_child)).toBe(true);
			
			      const element = <div>\{[first_child, second_child]\}</div>;
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div><span>first text</span><span>second text</span></div>');
			    \});
			
			    it('Should render element with an array of a string and a child element', function () \{
			      const second_child = <span>second text</span>;
			      expect(isValidElement(second_child)).toBe(true);
			
			      const element = <div>\{['first text', second_child]\}</div>;
			      expect(isValidElement(element)).toBe(true);
			
			      renderCompatTestElement(element);
			
			      expect(container.innerHTML).toBe('<div>first text<span>second text</span></div>');
			    \});
			
			    // Test Iterator support, skip if it is not supported in browser
			
			    if (typeof Symbol !== 'undefined' && typeof Symbol.iterator !== 'undefined') \{
			      function arrayAsBasicIterator(array) \{
			        return \{
			          [Symbol.iterator]: function () \{
			            let idx = 0;
			            return \{
			              next() \{
			                if (idx < array.length) \{
			                  return \{ value: array[idx++], done: false \};
			                \} else \{
			                  return \{ done: true \};
			                \}
			              \}
			            \};
			          \}
			        \};
			      \}
			
			      it('Should render element with an iterable of one text string', function () \{
			        const iterable = arrayAsBasicIterator(['generated body text']);
			        const element = <div>\{iterable\}</div>;
			        expect(isValidElement(element)).toBe(true);
			
			        renderCompatTestElement(element);
			
			        expect(container.innerHTML).toBe('<div>generated body text</div>');
			      \});
			
			      it('Should render element with an iterable of one child element', function () \{
			        const child = <span>\{'generated child body text'\}</span>;
			        expect(isValidElement(child)).toBe(true);
			
			        const iterable = arrayAsBasicIterator([child]);
			        const element = createElement('div', null, iterable);
			        expect(isValidElement(element)).toBe(true);
			
			        renderCompatTestElement(element);
			
			        expect(container.innerHTML).toBe('<div><span>generated child body text</span></div>');
			      \});
			
			      it('Should render element with an iterable of a child element and a string', function () \{
			        const child = <span>generated child body text</span>;
			        expect(isValidElement(child)).toBe(true);
			
			        const iterable = arrayAsBasicIterator([child, 'generated body text']);
			        const element = createElement('div', null, iterable);
			        expect(isValidElement(element)).toBe(true);
			
			        renderCompatTestElement(element);
			
			        expect(container.innerHTML).toBe('<div><span>generated child body text</span>generated body text</div>');
			      \});
			    \}
			  \});
			
			  // Ref: https://github.com/infernojs/inferno/issues/513
			  describe('String components (React compat)', () => \{
			    it('Should render a string div', () => \{
			      const Div = 'div';
			      render(<Div>Hello World</Div>, container);
			      expect(container.innerHTML).toBe('<div>Hello World</div>');
			    \});
			  \});
			
			  describe('Iterables', () => \{
			    it('Should render 0 as "0" text node (Array)', () => \{
			      class Hello extends Component \{
			        render() \{
			          return <div>Hello \{0\} Inferno</div>;
			        \}
			      \}
			
			      render(<Hello />, container);
			
			      expect(container.innerHTML).toBe('<div>Hello 0 Inferno</div>');
			    \});
			
			    const g = typeof window === 'undefined' ? global : window;
			    const hasSymbolSupport = typeof g.Symbol !== 'undefined';
			
			    if (hasSymbolSupport && 'Set' in window) \{
			      it('Should render 0 as "0" text node (Set)', () => \{
			        class Hello extends Component \{
			          render() \{
			            const set = new Set();
			
			            set.add('Hello ');
			            set.add(0);
			            set.add(' Inferno');
			
			            return <div>\{set\}</div>;
			          \}
			        \}
			
			        render(<Hello />, container);
			
			        expect(container.innerHTML).toBe('<div>Hello 0 Inferno</div>');
			      \});
			    \}
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\compat_children.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(25)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\findDOMNodes.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, findDOMNode, render \} from 'inferno-compat';
			
			describe('findDOMNodes (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('various tests to see if the DOM node is right for the component', () => \{
			    let instance1;
			    let instance2;
			    let instance3;
			    let ref;
			    const refFunc = (dom) => \{
			      if (dom) \{
			        ref = dom;
			      \}
			    \};
			
			    class Example1 extends Component \{
			      render() \{
			        instance1 = this;
			        return <div id="example1" />;
			      \}
			    \}
			
			    class Example2 extends Component \{
			      render() \{
			        instance2 = this;
			        return <div id="example2" />;
			      \}
			    \}
			
			    class Example3 extends Component \{
			      render() \{
			        instance3 = this;
			        return (
			          <div id="example3" ref=\{refFunc\}>
			            <Example2 />
			            <Example1 />
			          </div>
			        );
			      \}
			    \}
			
			    it('simple findDOMNodes', () => \{
			      render(<Example1 />, container);
			      expect(findDOMNode(instance1)).toBe(document.getElementById('example1'));
			      render(null, container);
			      expect(findDOMNode(instance1)).toBe(null);
			      render(<Example2 />, container);
			      expect(findDOMNode(instance2) === document.getElementById('example2')).toBe(true);
			      render(<Example1 />, container);
			      expect(findDOMNode(instance1) === document.getElementById('example1')).toBe(true);
			      render(<Example3 />, container);
			      expect(findDOMNode(instance3) === document.getElementById('example3')).toBe(true);
			      expect(findDOMNode(instance2) === document.getElementById('example2')).toBe(true);
			      expect(findDOMNode(instance1) === document.getElementById('example1')).toBe(true);
			      render(null, container);
			      expect(findDOMNode(instance1)).toBe(null);
			      expect(findDOMNode(instance2)).toBe(null);
			      expect(findDOMNode(instance3)).toBe(null);
			      expect(findDOMNode(ref) === ref).toBe(true);
			    \});
			
			    it('Non existent ref should return null', () => \{
			      expect(findDOMNode(null)).toBe(null);
			      expect(findDOMNode(\{\})).toBe(null);
			    \});
			
			    it('finds the first child when a component returns a fragment', () => \{
			      class FragmentTester extends Component \{
			        render() \{
			          return [<div key="a" />, <span key="b" />];
			        \}
			      \}
			
			      let instance = null;
			      render(<FragmentTester ref=\{(ref) => (instance = ref)\} />, container);
			
			      expect(container.childNodes.length).toBe(2);
			
			      const firstNode = findDOMNode(instance);
			      expect(firstNode).toBe(container.firstChild);
			      expect(firstNode.tagName).toBe('DIV');
			    \});
			
			    it('finds the first child even when fragment is nested', () => \{
			      class Wrapper extends Component \{
			        render() \{
			          return this.props.children;
			        \}
			      \}
			
			      class FragmentTester extends Component \{
			        render() \{
			          return [
			            <Wrapper key="a">
			              <div />
			            </Wrapper>,
			            <span key="b" />
			          ];
			        \}
			      \}
			
			      let instance = null;
			      render(<FragmentTester ref=\{(ref) => (instance = ref)\} />, container);
			
			      expect(container.childNodes.length).toBe(2);
			
			      const firstNode = findDOMNode(instance);
			      expect(firstNode).toBe(container.firstChild);
			      expect(firstNode.tagName).toBe('DIV');
			    \});
			
			    it('finds the first child even when first child renders null', () => \{
			      class NullComponent extends Component \{
			        render() \{
			          return null;
			        \}
			      \}
			
			      class FragmentTester extends Component \{
			        render() \{
			          return [<NullComponent key="a" />, <div key="b" />, <span key="c" />];
			        \}
			      \}
			
			      let instance = null;
			      ReactDOM.render(<FragmentTester ref=\{(ref) => (instance = ref)\} />, container);
			
			      expect(container.childNodes.length).toBe(3);
			
			      const firstNode = findDOMNode(instance);
			      expect(firstNode).toBe(container.firstChild);
			      // expect(firstNode.tagName).toBe('DIV'); This is components placeholder
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\findDOMNodes.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\isValidElement.spec.jsx', () => {
        const sourceCode = `
			import \{ createElement \} from 'inferno-create-element';
			import \{ isValidElement \} from 'inferno-compat';
			import \{ Component \} from 'inferno';
			import \{ cloneVNode \} from 'inferno-clone-vnode';
			import \{ h \} from 'inferno-hyperscript';
			
			describe('isValidElement', () => \{
			  it('Should not work with non-object', () => \{
			    expect(isValidElement(33)).toBe(false);
			    expect(isValidElement(false)).toBe(false);
			    expect(isValidElement(true)).toBe(false);
			    expect(isValidElement('some text')).toBe(false);
			    expect(isValidElement(0)).toBe(false);
			    expect(isValidElement(undefined)).toBe(false);
			  \});
			
			  it('Should not work with invalid object', () => \{
			    expect(isValidElement(null)).toBe(false);
			    expect(isValidElement(\{\})).toBe(false);
			    expect(isValidElement(\{ dom: 'fake data' \})).toBe(false);
			  \});
			
			  it('Should not work with a number', () => \{
			    expect(isValidElement(33)).toBe(false);
			  \});
			
			  it('Should work with createElement (element)', () => \{
			    const el = createElement('div', null, 'Do a thing');
			    expect(isValidElement(el)).toBe(true);
			  \});
			
			  it('Should work with createElement (stateless component)', () => \{
			    const el = createElement('div', null, 'Do a thing');
			    const Comp = () => el;
			    const comp = createElement(Comp);
			    expect(isValidElement(comp)).toBe(true);
			  \});
			
			  it('Should work with createElement (stateful component)', () => \{
			    class Comp extends Component \{
			      render() \{
			        return createElement('div', null, 'Do a thing');
			      \}
			    \}
			    const comp = createElement(Comp);
			    expect(isValidElement(comp)).toBe(true);
			  \});
			
			  it('Should work with JSX', () => \{
			    const node = <div>Hello world</div>;
			    expect(isValidElement(node)).toBe(true);
			  \});
			
			  it('Should work with cloneVNode', () => \{
			    const node = <div>Hello world</div>;
			    const clonedNode = cloneVNode(node, null, 'Hello world 2!');
			    expect(isValidElement(clonedNode)).toBe(true);
			  \});
			
			  it('Should work with hyperscript (element)', () => \{
			    const el = h('div', 'Do a thing');
			    expect(isValidElement(el)).toBe(true);
			  \});
			
			  it('Should work with hyperscript (stateless component)', () => \{
			    const el = h('div', 'Do a thing');
			    const Comp = () => el;
			    const comp = h(Comp);
			    expect(isValidElement(comp)).toBe(true);
			  \});
			
			  it('Should work with hyperscript (stateful component)', () => \{
			    class Comp extends Component \{
			      render() \{
			        return h('div', 'Do a thing');
			      \}
			    \}
			    const comp = h(Comp);
			    expect(isValidElement(comp)).toBe(true);
			  \});
			
			  it('Should not work with a stateless component (using createElement)', () => \{
			    const el = createElement('div', null, 'Do a thing');
			    const Comp = () => el;
			    expect(isValidElement(Comp)).toBe(false);
			  \});
			
			  it('Should not work with a stateless component (using hyperscript)', () => \{
			    const el = h('div', 'Do a thing');
			    const Comp = () => el;
			    expect(isValidElement(Comp)).toBe(false);
			  \});
			
			  it('Should not work with a stateful component (using createElement)', () => \{
			    class Comp extends Component \{
			      render() \{
			        return createElement('div', null, 'Do a thing');
			      \}
			    \}
			    expect(isValidElement(Comp)).toBe(false);
			  \});
			
			  it('Should not work with a stateful component (using hyperscript)', () => \{
			    class Comp extends Component \{
			      render() \{
			        return h('div', 'Do a thing');
			      \}
			    \}
			    expect(isValidElement(Comp)).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\isValidElement.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(15)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\lifecycle.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, createElement, render \} from 'inferno-compat';
			
			describe('Inferno-compat LifeCycle', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('Order of Es6 Lifecycle with string refs and refs', () => \{
			    it('Should go as per React', () => \{
			      // We spy console log to verify order of callbacks
			      // React implementation: https://jsfiddle.net/art58y3L/
			      spyOn(console, 'log');
			
			      class Hello2 extends Component \{
			        componentWillMount() \{
			          console.log('Will mount sub');
			        \}
			
			        componentDidMount() \{
			          console.log('Did mount sub');
			        \}
			
			        componentWillUpdate() \{
			          console.log('Will update sub');
			        \}
			
			        componentDidUpdate() \{
			          console.log('Did update sub');
			        \}
			
			        render() \{
			          return createElement(
			            'div',
			            \{
			              key: 'S1',
			              id: 'S1',
			              ref: (el) => \{
			                console.log('S1' + (el ? el.id : null));
			              \}
			            \},
			            [
			              createElement('div', \{ key: 'ee' \}),
			              createElement('div', \{
			                key: 'S2b',
			                id: 'S2b',
			                ref: (el) => \{
			                  console.log('S2b' + (el ? el.id : null));
			                \}
			              \})
			            ]
			          );
			        \}
			      \}
			
			      class Hello extends Component \{
			        componentWillMount() \{
			          console.log('Will mount');
			        \}
			
			        componentDidMount() \{
			          console.log('Did mount');
			        \}
			
			        componentWillUpdate() \{
			          console.log('Will update');
			        \}
			
			        componentDidUpdate() \{
			          console.log('Did update');
			        \}
			
			        render() \{
			          return createElement(
			            'div',
			            \{
			              key: '1',
			              id: '1',
			              ref: (el) => \{
			                console.log('1' + (el ? el.id : null));
			              \}
			            \},
			            [
			              createElement(
			                'div',
			                \{
			                  key: '2a',
			                  id: '2a',
			                  ref: (el) => \{
			                    console.log('2a' + (el ? el.id : null));
			                  \}
			                \},
			                [
			                  createElement(Hello2, \{ key: 'Hello2' \}),
			                  createElement('div', \{ key: 'empt' \}, [
			                    createElement('div', \{
			                      key: '4a',
			                      id: '4a',
			                      ref: (el) => \{
			                        console.log('4a' + (el ? el.id : null));
			                      \}
			                    \}),
			                    createElement('div', \{
			                      key: '4b',
			                      id: '4b',
			                      ref: (el) => \{
			                        console.log('4b' + (el ? el.id : null));
			                      \}
			                    \})
			                  ]),
			                  createElement('div', \{
			                    key: '3b',
			                    id: '3b',
			                    ref: (el) => \{
			                      console.log('3b' + (el ? el.id : null));
			                    \}
			                  \})
			                ]
			              ),
			              createElement(
			                'div',
			                \{
			                  key: '2b',
			                  id: '2b',
			                  ref: (el) => \{
			                    console.log('2b' + (el ? el.id : null));
			                  \}
			                \},
			                null
			              )
			            ]
			          );
			        \}
			      \}
			
			      render(createElement(Hello, \{ name: 'Inferno' \}), container);
			
			      console.log('UPDATE');
			
			      render(createElement(Hello, \{ name: 'Better Lifecycle' \}), container);
			
			      console.log('REMOVAL');
			
			      render(<div />, container);
			
			      expect(console.log).toHaveBeenCalledTimes(42);
			
			      /*
			      React oder is:, Inferno will differenciate in string refs because they are handled same way as callback refs
			      Will mount
			      Will mount sub
			      S2bS2b
			      S1S1
			      Didountsub
			      4a4a
			      4b4b
			      3b3b
			      2a2a
			      2b2b
			      11
			      Didmount
			      UPDATE
			      Willupdate
			      Willupdatesub
			      S2bnull
			      S1null
			      4anull
			      4bnull
			      3bnull
			      2anull
			      2bnull
			      1null
			      S2bS2b
			      S1S1
			      Didupdatesub
			      4a4a
			      4b4b
			      3b3b
			      2a2a
			      2b2b
			      11
			      Didupdate
			      REMOVAL
			      1null
			      2anull
			      S1null
			      S2bnull
			      4anull
			      4bnull
			      3bnull
			      2bnull
			       */
			
			      // // mount
			      let i = -1;
			
			      const calls = console.log.calls;
			
			      expect(calls.argsFor(++i)).toEqual(['Will mount']);
			      expect(calls.argsFor(++i)).toEqual(['Will mount sub']);
			      expect(calls.argsFor(++i)).toEqual(['S2bS2b']);
			      expect(calls.argsFor(++i)).toEqual(['S1S1']);
			      expect(calls.argsFor(++i)).toEqual(['Did mount sub']);
			      expect(calls.argsFor(++i)).toEqual(['4a4a']);
			      expect(calls.argsFor(++i)).toEqual(['4b4b']);
			      expect(calls.argsFor(++i)).toEqual(['3b3b']);
			      expect(calls.argsFor(++i)).toEqual(['2a2a']);
			      expect(calls.argsFor(++i)).toEqual(['2b2b']);
			      expect(calls.argsFor(++i)).toEqual(['11']);
			      expect(calls.argsFor(++i)).toEqual(['Did mount']);
			
			      // update
			      // expect(calls.argsFor(++i)).toEqual(['UPDATE']);
			      // expect(calls.argsFor(++i)).toEqual(['Will update']);
			      // expect(calls.argsFor(++i)).toEqual(['Will update sub']);
			      // expect(calls.argsFor(++i)).toEqual(['S2bnull']);
			      // expect(calls.argsFor(++i)).toEqual(['S1null']);
			      // expect(calls.argsFor(++i)).toEqual(['4anull']);
			      // expect(calls.argsFor(++i)).toEqual(['4bnull']);
			      // expect(calls.argsFor(++i)).toEqual(['3bnull']);
			      // expect(calls.argsFor(++i)).toEqual(['2anull']);
			      // expect(calls.argsFor(++i)).toEqual(['2bnull']);
			      // expect(calls.argsFor(++i)).toEqual(['1null']);
			      // expect(calls.argsFor(++i)).toEqual(['S2bS2b']);
			      // expect(calls.argsFor(++i)).toEqual(['S1S1']);
			      // expect(calls.argsFor(++i)).toEqual(['Did update sub']);
			      // expect(calls.argsFor(++i)).toEqual(['4a4a']);
			      // expect(calls.argsFor(++i)).toEqual(['4b4b']);
			      // expect(calls.argsFor(++i)).toEqual(['3b3b']);
			      // expect(calls.argsFor(++i)).toEqual(['2a2a']);
			      // expect(calls.argsFor(++i)).toEqual(['2b2b']);
			      // expect(calls.argsFor(++i)).toEqual(['11']);
			
			      // unmount
			      // expect(calls.argsFor(++i)).toEqual(['REMOVAL']);
			      // expect(calls.argsFor(++i)).toEqual(['1null']);
			      // expect(calls.argsFor(++i)).toEqual(['2anull']);
			      // expect(calls.argsFor(++i)).toEqual(['S1null']);
			      // expect(calls.argsFor(++i)).toEqual(['S2bnull']);
			      // expect(calls.argsFor(++i)).toEqual(['4anull']);
			      // expect(calls.argsFor(++i)).toEqual(['4bnull']);
			      // expect(calls.argsFor(++i)).toEqual(['3bnull']);
			      // expect(calls.argsFor(++i)).toEqual(['2bnull']);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\lifecycle.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\misc.spec.jsx', () => {
        const sourceCode = `
			import React, \{
			  Children,
			  cloneElement,
			  Component,
			  createClass,
			  createElement,
			  hydrate,
			  PropTypes,
			  render,
			  unstable_renderSubtreeIntoContainer
			\} from 'inferno-compat';
			
			describe('MISC', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('PropTypes', () => \{
			    it('PropTypes should exists in inferno-compat', () => \{
			      expect(typeof PropTypes).toBe('object');
			      expect(PropTypes.any()).toBeTruthy();
			      expect(typeof PropTypes.any().isRequired).toBe('function');
			      expect(PropTypes.any().isRequired()).toBeUndefined();
			    \});
			
			    it('checkPropTypes should return null', () => \{
			      expect(PropTypes.checkPropTypes()).toBeNull();
			    \});
			  \});
			
			  describe('React Synthetic event simulation', () => \{
			    it('should have isPropagationStopped and isDefaultPrevented defined in Event prototype', () => \{
			      const spyObj = \{
			        foo: (event) => \{
			          expect(event.isDefaultPrevented()).toBe(false);
			          expect(event.isPropagationStopped()).toBe(false);
			
			          event.preventDefault();
			          expect(event.isDefaultPrevented()).toBe(true);
			
			          event.stopPropagation();
			          expect(event.isPropagationStopped()).toBe(true);
			        \}
			      \};
			      spyOn(spyObj, 'foo').and.callThrough();
			
			      render(<div onClick=\{spyObj.foo\} />, container);
			
			      container.firstChild.click();
			
			      expect(spyObj.foo).toHaveBeenCalledTimes(1);
			    \});
			  \});
			
			  describe('Children Only', () => \{
			    it('Should return first of array', () => \{
			      const divOne = <div />;
			      const children = [divOne];
			
			      expect(Children.only(children)).toBe(divOne);
			    \});
			
			    it('Should two if children length is not one', () => \{
			      const divOne = <div />;
			      const children = [divOne, 'two', 3];
			
			      expect(() => Children.only(children)).toThrow();
			    \});
			  \});
			
			  describe('Children toArray', () => \{
			    it('Should return child in array', () => \{
			      const divOne = <div />;
			
			      expect(Children.toArray(divOne)).toEqual([divOne]);
			    \});
			
			    it('Should return array if its already array', () => \{
			      const children = [<div />];
			
			      expect(Children.toArray(children)).toEqual(children);
			    \});
			
			    it('Should return empty array if its null/undef', () => \{
			      const children = null;
			
			      expect(Children.toArray(children)).toEqual([]);
			    \});
			  \});
			
			  describe('render()', () => \{
			    it('should be exported', () => \{
			      expect(React.render).toBe(render);
			    \});
			
			    it('should replace isomorphic content', () => \{
			      let ce = (type) => document.createElement(type);
			      let Text = (text) => document.createTextNode(text);
			      let root = ce('div');
			      let initialChild = ce('div');
			      initialChild.appendChild(Text('initial content'));
			      root.appendChild(initialChild);
			
			      hydrate(<div>dynamic content</div>, root);
			      expect(root.textContent).toEqual('dynamic content');
			    \});
			
			    it('hydrate should remove extra elements', () => \{
			      let ce = (type) => document.createElement(type);
			      let Text = (text) => document.createTextNode(text);
			      let root = ce('div');
			
			      let c1 = ce('div');
			      c1.appendChild(Text('isomorphic content'));
			      root.appendChild(c1);
			
			      let c2 = ce('div');
			      c2.appendChild(Text('extra content'));
			      root.appendChild(c2);
			
			      hydrate(<div>dynamic content</div>, root);
			      expect(root.textContent).toEqual('dynamic content');
			    \});
			
			    it('should remove text nodes', () => \{
			      let ce = (type) => document.createElement(type);
			      let Text = (text) => document.createTextNode(text);
			      let root = ce('div');
			
			      root.appendChild(Text('Text Content in the root'));
			      root.appendChild(Text('More Text Content'));
			
			      hydrate(<div>dynamic content</div>, root);
			      expect(root.textContent).toEqual('dynamic content');
			    \});
			
			    it('should support defaultValue', () => \{
			      let div2 = document.createElement('div');
			      (document.body || document.documentElement).appendChild(div2);
			      render(<input defaultValue="foo" />, div2);
			      expect(div2.firstElementChild.value).toBe('foo');
			
			      render(null, div2);
			      document.body.removeChild(div2);
			    \});
			  \});
			
			  describe('createClass()', () => \{
			    it('should be exported', () => \{
			      expect(React.createClass).toBe(createClass);
			    \});
			
			    it('should not bind blacklisted methods', () => \{
			      let constructor = () => \{\};
			      let render = () => null;
			      const C = createClass(\{
			        constructor,
			        render
			      \});
			      let c = new C();
			      expect(c.constructor).toBe(constructor);
			      expect(c.render).toBe(render);
			    \});
			
			    it('should copy statics', () => \{
			      let def = \{
			        statics: \{
			          foo: 'bar',
			          baz() \{\}
			        \}
			      \};
			      let c = createClass(def);
			      expect(c.foo).toEqual(def.statics.foo);
			      expect(c.baz).toEqual(def.statics.baz);
			    \});
			  \});
			
			  describe('createElement()', () => \{
			    it('should be exported', () => \{
			      expect(React.createElement).toBe(createElement);
			    \});
			  \});
			
			  describe('Component', () => \{
			    it('should be exported', () => \{
			      expect(React.Component).toEqual(Component);
			    \});
			  \});
			
			  describe('cloneElement', () => \{
			    it('should clone elements', () => \{
			      let element = (
			        <foo a="b" c="d">
			          a<span>b</span>
			        </foo>
			      );
			      expect(JSON.stringify(cloneElement(element).children)).toEqual(JSON.stringify(element.children));
			    \});
			
			    it('should support props.children', () => \{
			      let element = <foo children=\{<span>b</span>\} />;
			      let clone = cloneElement(element);
			
			      expect(cloneElement(clone).props.children).toEqual(element.props.children);
			    \});
			
			    it('children take precedence over props.children', () => \{
			      let element = (
			        <foo children=\{<span>c</span>\}>
			          <div>b</div>
			        </foo>
			      );
			      let clone = cloneElement(element);
			
			      expect(clone.children.children).toEqual('b');
			    \});
			
			    it('should support children in prop argument', () => \{
			      let element = <foo />;
			      let children = [<span>b</span>];
			      let clone = cloneElement(element, \{ children \});
			      expect(JSON.stringify(clone.children)).toEqual(JSON.stringify(children));
			    \});
			
			    it('children argument takes precedence over props.children', () => \{
			      let element = <foo />;
			      let childrenA = [<span>b</span>];
			      let childrenB = [<div>c</div>];
			      let clone = cloneElement(element, \{ children: childrenA \}, childrenB);
			      expect(JSON.stringify(clone.children)).toEqual(JSON.stringify(childrenB));
			    \});
			
			    it('children argument takes precedence over props.children even if falsey', () => \{
			      let element = <foo />;
			      let childrenA = [<span>b</span>];
			      let clone = cloneElement(element, \{ children: childrenA \}, undefined);
			      expect(clone.children).toEqual(null);
			    \});
			  \});
			
			  describe('unstable_renderSubtreeIntoContainer', () => \{
			    class Inner extends Component \{
			      render() \{
			        return null;
			      \}
			      getNode() \{
			        return 'inner';
			      \}
			    \}
			
			    it('should export instance', () => \{
			      class App extends Component \{
			        render() \{
			          return null;
			        \}
			        componentDidMount() \{
			          this.renderInner();
			        \}
			        renderInner() \{
			          const wrapper = document.createElement('div');
			          this.inner = unstable_renderSubtreeIntoContainer(this, <Inner />, wrapper);
			        \}
			      \}
			      const root = document.createElement('div');
			      const app = render(<App />, root);
			      expect(typeof app.inner.getNode === 'function').toEqual(true);
			    \});
			
			    it('should there must be a context in callback', () => \{
			      class App extends Component \{
			        render() \{
			          return null;
			        \}
			        componentDidMount() \{
			          this.renderInner();
			        \}
			        renderInner() \{
			          const wrapper = document.createElement('div');
			          const self = this;
			          unstable_renderSubtreeIntoContainer(this, <Inner />, wrapper, function () \{
			            self.inner = this;
			          \});
			        \}
			      \}
			      const root = document.createElement('div');
			      const app = render(<App />, root);
			      expect(typeof app.inner.getNode === 'function').toEqual(true);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\misc.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(26)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\onlyChild.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			
			describe('onlyChild', function () \{
			  var ReactFragment;
			  var onlyChild;
			  var WrapComponent;
			
			  beforeEach(function () \{
			    onlyChild = React.Children.only;
			    WrapComponent = React.createClass(\{
			      render: function () \{
			        return <div>\{onlyChild(this.props.children, this.props.mapFn, this)\}</div>;
			      \}
			    \});
			  \});
			
			  it('should fail when passed two children', function () \{
			    expect(function () \{
			      var instance = (
			        <WrapComponent>
			          <div />
			          <span />
			        </WrapComponent>
			      );
			      onlyChild(instance.props.children);
			    \}).toThrow();
			  \});
			
			  it('should fail when passed nully values', function () \{
			    expect(function () \{
			      var instance = <WrapComponent>\{null\}</WrapComponent>;
			      onlyChild(instance.props.children);
			    \}).toThrow();
			
			    expect(function () \{
			      var instance = <WrapComponent>\{undefined\}</WrapComponent>;
			      onlyChild(instance.props.children);
			    \}).toThrow();
			  \});
			
			  // it('should fail when key/value objects', function() \{
			  //   expect(function() \{
			  //     var instance =
			  //       <WrapComponent>
			  //         \{ReactFragment.create(\{oneThing: <span />\})\}
			  //       </WrapComponent>;
			  //     onlyChild(instance.props.children);
			  //   \}).toThrow();
			  // \});
			
			  it('should not fail when passed interpolated single child', function () \{
			    expect(function () \{
			      var instance = <WrapComponent>\{<span />\}</WrapComponent>;
			      onlyChild(instance.props.children);
			    \}).not.toThrow();
			  \});
			
			  it('should return the only child', function () \{
			    expect(function () \{
			      var instance = (
			        <WrapComponent>
			          <span />
			        </WrapComponent>
			      );
			      onlyChild(instance.props.children);
			    \}).not.toThrow();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\onlyChild.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactChildren.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			describe('ReactChildren', function () \{
			  var ReactChildren;
			
			  beforeEach(function () \{
			    ReactChildren = React.Children;
			  \});
			
			  it('should support identity for simple', function () \{
			    var callback = jasmine.createSpy().and.callFake(function (kid, index) \{
			      return kid;
			    \});
			
			    var simpleKid = <span key="simple" />;
			
			    // First pass children into a component to fully simulate what happens when
			    // using structures that arrive from transforms.
			
			    var instance = (
			      <div>
			        <span key="simple" />
			      </div>
			    );
			    ReactChildren.forEach(instance.children, callback);
			    expect(callback).toHaveBeenCalledWith(simpleKid, 0, jasmine.any(Array));
			    callback.calls.reset();
			    ReactChildren.map(instance.children, callback);
			    expect(callback).toHaveBeenCalledWith(simpleKid, 0, jasmine.any(Array));
			    // expect(mappedChildren[0]).toEqual(<span key="simple" />);
			  \});
			
			  it('should treat single arrayless child as being in array', function () \{
			    var callback = jasmine.createSpy().and.callFake(function (kid, index) \{
			      return kid;
			    \});
			
			    var simpleKid = <span />;
			    var instance = (
			      <div>
			        <span />
			      </div>
			    );
			    ReactChildren.forEach(instance.children, callback);
			    expect(callback).toHaveBeenCalledWith(simpleKid, 0, jasmine.any(Array));
			    callback.calls.reset();
			    ReactChildren.map(instance.children, callback);
			    expect(callback).toHaveBeenCalledWith(simpleKid, 0, jasmine.any(Array));
			    // expect(mappedChildren[0]).toEqual(<span key=".0" />);
			  \});
			
			  it('should treat single child in array as expected', function () \{
			    var callback = jasmine.createSpy().and.callFake(function (kid, index) \{
			      return kid;
			    \});
			
			    var simpleKid = <span key="simple" />;
			    // Use optimization flag to avoid normalization to keep flags same... for below assertion
			    var instance = <div \$HasNonKeyedChildren>\{[<span key="simple" />]\}</div>;
			    ReactChildren.forEach(instance.children, callback);
			    expect(callback).toHaveBeenCalledWith(simpleKid, 0, jasmine.any(Array)); // Third param is the array
			    callback.calls.reset();
			
			    ReactChildren.map(instance.children, callback);
			    expect(callback).toHaveBeenCalledWith(simpleKid, 0, jasmine.any(Array));
			    // expect(mappedChildren[0]).toEqual(<span key="simple" />);
			    // Flags dont match because its implementation detail in Inferno
			  \});
			
			  it('should pass key to returned component', function () \{
			    var mapFn = function (kid, index) \{
			      return <div>\{kid\}</div>;
			    \};
			    var instance = (
			      <div>
			        <span key="simple" />
			      </div>
			    );
			
			    var mappedChildren = ReactChildren.map(instance.children, mapFn);
			
			    expect(ReactChildren.count(mappedChildren)).toBe(1);
			    expect(mappedChildren[0].children.key).toBe('simple');
			  \});
			
			  it('should invoke callback with the right context', function () \{
			    var lastContext;
			    var callback = function (kid, index) \{
			      lastContext = this;
			      return this;
			    \};
			
			    var scopeTester = \{ fooScope: 'barScope' \};
			
			    var simpleKid = <span key="simple" />;
			    var instance = <div>\{simpleKid\}</div>;
			    ReactChildren.forEach(instance.children, callback, scopeTester);
			    expect(lastContext).toEqual(scopeTester);
			
			    var mappedChildren = ReactChildren.map(instance.children, callback, scopeTester);
			
			    expect(ReactChildren.count(mappedChildren)).toBe(1);
			    expect(mappedChildren[0]).toEqual(scopeTester);
			  \});
			
			  it('ForEach should not fail if null children is provided', () => \{
			    expect(React.Children.forEach(null, null, null)).toBe(undefined);
			  \});
			
			  // it('should be called for each child', function() \{
			  //   var zero = <div key="keyZero" />;
			  //   var one = null;
			  //   var two = <div key="keyTwo" />;
			  //   var three = null;
			  //   var four = <div key="keyFour" />;
			  //
			  //   var zeroMapped = <div key="giraffe" />;  // Key should be joined to obj key
			  //   var oneMapped = null;  // Key should be added even if we don't supply it!
			  //   var twoMapped = <div />;  // Key should be added even if not supplied!
			  //   var threeMapped = <span />; // Map from null to something.
			  //   var fourMapped = <div key="keyFour" />;
			  //
			  //   var callback = jasmine.createSpy().and.callFake(function(kid, index) \{
			  //     return index === 0 ? zeroMapped :
			  //       index === 1 ? oneMapped :
			  //       index === 2 ? twoMapped :
			  //       index === 3 ? threeMapped : fourMapped;
			  //   \});
			  //   var instance = (
			  //     <div>
			  //       \{zero\}
			  //       \{one\}
			  //       \{two\}
			  //       \{three\}
			  //       \{four\}
			  //     </div>
			  //   );
			  //
			  //   ReactChildren.forEach(instance.children, callback);
			  //   expect(callback).toHaveBeenCalledWith(zero, 0);
			  //   expect(callback).toHaveBeenCalledWith(one, 1);
			  //   expect(callback).toHaveBeenCalledWith(two, 2);
			  //   expect(callback).toHaveBeenCalledWith(three, 3);
			  //   expect(callback).toHaveBeenCalledWith(four, 4);
			  //   callback.calls.calls.reset();
			  //
			  //   var mappedChildren =
			  //     ReactChildren.map(instance.children, callback);
			  //   expect(callback.calls.count()).toBe(5);
			  //   expect(ReactChildren.count(mappedChildren)).toBe(4);
			  //   // Keys default to indices.
			  //   expect([
			  //     mappedChildren[0].key,
			  //     mappedChildren[1].key,
			  //     mappedChildren[2].key,
			  //     mappedChildren[3].key,
			  //   ]).toEqual(
			  //     ['giraffe/.\$keyZero', '/.\$keyTwo', '/.3', 'keyFour/.\$keyFour']
			  //   );
			  //
			  //   expect(callback).toHaveBeenCalledWith(zero, 0);
			  //   expect(callback).toHaveBeenCalledWith(one, 1);
			  //   expect(callback).toHaveBeenCalledWith(two, 2);
			  //   expect(callback).toHaveBeenCalledWith(three, 3);
			  //   expect(callback).toHaveBeenCalledWith(four, 4);
			  //
			  //   expect(mappedChildren[0]).toEqual(<div key="giraffe/.\$keyZero" />);
			  //   expect(mappedChildren[1]).toEqual(<div key="/.\$keyTwo" />);
			  //   expect(mappedChildren[2]).toEqual(<span key="/.3" />);
			  //   expect(mappedChildren[3]).toEqual(<div key="keyFour/.\$keyFour" />);
			  // \});
			
			  // it('should be called for each child in nested structure', function() \{
			  //   var zero = <div key="keyZero" />;
			  //   var one = null;
			  //   var two = <div key="keyTwo" />;
			  //   var three = null;
			  //   var four = <div key="keyFour" />;
			  //   var five = <div key="keyFiveInner" />;
			  //   // five is placed into a JS object with a key that is joined to the
			  //   // component key attribute.
			  //   // Precedence is as follows:
			  //   // 1. If grouped in an Object, the object key combined with \`key\` prop
			  //   // 2. If grouped in an Array, the \`key\` prop, falling back to array index
			
			  //   var zeroMapped = <div key="giraffe" />;  // Key should be overridden
			  //   var twoMapped = <div />;  // Key should be added even if not supplied!
			  //   var fourMapped = <div key="keyFour" />;
			  //   var fiveMapped = <div />;
			
			  //   var callback = jasmine.createSpy().and.callFake(function(kid, index) \{
			  //     return index === 0 ? zeroMapped :
			  //       index === 1 ? twoMapped :
			  //       index === 2 ? fourMapped : fiveMapped;
			  //   \});
			
			  //   var frag = ReactFragment.create(\{
			  //     firstHalfKey: [zero, one, two],
			  //     secondHalfKey: [three, four],
			  //     keyFive: five,
			  //   \});
			  //   var instance = <div>\{[frag]\}</div>;
			
			  //   expect([
			  //     frag[0].key,
			  //     frag[1].key,
			  //     frag[2].key,
			  //     frag[3].key,
			  //   ]).toEqual([
			  //     'firstHalfKey/.\$keyZero',
			  //     'firstHalfKey/.\$keyTwo',
			  //     'secondHalfKey/.\$keyFour',
			  //     'keyFive/.\$keyFiveInner',
			  //   ]);
			
			  //   ReactChildren.forEach(instance.props.children, callback);
			  //   expect(callback.calls.count()).toBe(4);
			  //   expect(callback).toHaveBeenCalledWith(frag[0], 0);
			  //   expect(callback).toHaveBeenCalledWith(frag[1], 1);
			  //   expect(callback).toHaveBeenCalledWith(frag[2], 2);
			  //   expect(callback).toHaveBeenCalledWith(frag[3], 3);
			  //   callback.calls.calls.reset();
			
			  //   var mappedChildren = ReactChildren.map(instance.props.children, callback);
			  //   expect(callback.calls.count()).toBe(4);
			  //   expect(callback).toHaveBeenCalledWith(frag[0], 0);
			  //   expect(callback).toHaveBeenCalledWith(frag[1], 1);
			  //   expect(callback).toHaveBeenCalledWith(frag[2], 2);
			  //   expect(callback).toHaveBeenCalledWith(frag[3], 3);
			
			  //   expect(ReactChildren.count(mappedChildren)).toBe(4);
			  //   // Keys default to indices.
			  //   expect([
			  //     mappedChildren[0].key,
			  //     mappedChildren[1].key,
			  //     mappedChildren[2].key,
			  //     mappedChildren[3].key,
			  //   ]).toEqual([
			  //     'giraffe/.0:\$firstHalfKey/=1\$keyZero',
			  //     '/.0:\$firstHalfKey/=1\$keyTwo',
			  //     'keyFour/.0:\$secondHalfKey/=1\$keyFour',
			  //     '/.0:\$keyFive/=1\$keyFiveInner',
			  //   ]);
			
			  //   expect(mappedChildren[0]).toEqual(<div key="giraffe/.0:\$firstHalfKey/=1\$keyZero" />);
			  //   expect(mappedChildren[1]).toEqual(<div key="/.0:\$firstHalfKey/=1\$keyTwo" />);
			  //   expect(mappedChildren[2]).toEqual(<div key="keyFour/.0:\$secondHalfKey/=1\$keyFour" />);
			  //   expect(mappedChildren[3]).toEqual(<div key="/.0:\$keyFive/=1\$keyFiveInner" />);
			  // \});
			
			  // it('should retain key across two mappings', function() \{
			  //   var zeroForceKey = <div key="keyZero" />;
			  //   var oneForceKey = <div key="keyOne" />;
			  //
			  //   // Key should be joined to object key
			  //   var zeroForceKeyMapped = <div key="giraffe" />;
			  //   // Key should be added even if we don't supply it!
			  //   var oneForceKeyMapped = <div />;
			  //
			  //   var mapFn = function(kid, index) \{
			  //     return index === 0 ? zeroForceKeyMapped : oneForceKeyMapped;
			  //   \};
			  //
			  //   var forcedKeys = (
			  //     <div>
			  //       \{zeroForceKey\}
			  //       \{oneForceKey\}
			  //     </div>
			  //   );
			  //
			  //   var expectedForcedKeys = ['giraffe/.\$keyZero', '/.\$keyOne'];
			  //   var mappedChildrenForcedKeys =
			  //     ReactChildren.map(forcedKeys.props.children, mapFn);
			  //   var mappedForcedKeys = mappedChildrenForcedKeys.map((c) => c.key);
			  //   expect(mappedForcedKeys).toEqual(expectedForcedKeys);
			  //
			  //   // var expectedRemappedForcedKeys = [
			  //   //   'giraffe/.\$giraffe/=1\$keyZero',
			  //   //   '/.\$/=1\$keyOne',
			  //   // ];
			  //   // var remappedChildrenForcedKeys =
			  //   //   ReactChildren.map(mappedChildrenForcedKeys, mapFn);
			  //   // expect(
			  //   //   remappedChildrenForcedKeys.map((c) => c.key)
			  //   // ).toEqual(expectedRemappedForcedKeys);
			  //
			  // \});
			
			  it('should not throw if key provided is a dupe with array key', function () \{
			    var zero = <div />;
			    var one = <div key="0" />;
			
			    var mapFn = function () \{
			      return null;
			    \};
			
			    var instance = (
			      <div>
			        \{zero\}
			        \{one\}
			      </div>
			    );
			
			    expect(function () \{
			      ReactChildren.map(instance.props.children, mapFn);
			    \}).not.toThrow();
			  \});
			
			  it('should return 0 for null children', function () \{
			    var numberOfChildren = ReactChildren.count(null);
			    expect(numberOfChildren).toBe(0);
			  \});
			
			  it('should return 0 for undefined children', function () \{
			    var numberOfChildren = ReactChildren.count(undefined);
			    expect(numberOfChildren).toBe(0);
			  \});
			
			  it('should return 1 for single child', function () \{
			    var simpleKid = <span key="simple" />;
			    var instance = <div>\{simpleKid\}</div>;
			    var numberOfChildren = ReactChildren.count(instance.children);
			    expect(numberOfChildren).toBe(1);
			  \});
			
			  it('should count the number of children in flat structure', function () \{
			    var zero = <div key="keyZero" />;
			    var one = null;
			    var two = <div key="keyTwo" />;
			    var three = null;
			    var four = <div key="keyFour" />;
			
			    var instance = (
			      <div>
			        \{zero\}
			        \{one\}
			        \{two\}
			        \{three\}
			        \{four\}
			      </div>
			    );
			    var numberOfChildren = ReactChildren.count(instance.children);
			    expect(numberOfChildren).toBe(3); // Nulls are removed in Inferno
			  \});
			
			  // it('should count the number of children in nested structure', function() \{
			  //   var zero = <div key="keyZero" />;
			  //   var one = null;
			  //   var two = <div key="keyTwo" />;
			  //   var three = null;
			  //   var four = <div key="keyFour" />;
			  //   var five = <div key="keyFiveInner" />;
			  //   // five is placed into a JS object with a key that is joined to the
			  //   // component key attribute.
			  //   // Precedence is as follows:
			  //   // 1. If grouped in an Object, the object key combined with \`key\` prop
			  //   // 2. If grouped in an Array, the \`key\` prop, falling back to array index
			
			  //   var instance = (
			  //     <div>\{
			  //       [
			  //         ReactFragment.create(\{
			  //           firstHalfKey: [zero, one, two],
			  //           secondHalfKey: [three, four],
			  //           keyFive: five,
			  //         \}),
			  //         null,
			  //       ]
			  //     \}</div>
			  //   );
			  //   var numberOfChildren = ReactChildren.count(instance.props.children);
			  //   expect(numberOfChildren).toBe(5);
			  // \});
			
			  it('should flatten children to an array', function () \{
			    expect(ReactChildren.toArray(undefined)).toEqual([]);
			    expect(ReactChildren.toArray(null)).toEqual([]);
			
			    expect(ReactChildren.toArray(<div />).length).toBe(1);
			    expect(ReactChildren.toArray([<div />]).length).toBe(1);
			    expect(ReactChildren.toArray(<div />)[0].key).toBe(ReactChildren.toArray([<div />])[0].key);
			
			    var flattened = ReactChildren.toArray([
			      [<div key="apple" />, <div key="banana" />, <div key="camel" />],
			      [<div key="banana" />, <div key="camel" />, <div key="deli" />]
			    ]);
			    expect(flattened.length).toBe(6);
			    expect(flattened[1].key).toContain('banana');
			    expect(flattened[3].key).toContain('banana');
			    // Inferno will do this when it normalizes children
			    // // expect(flattened[1].key).not.toBe(flattened[3].key);
			    //
			    // var reversed = ReactChildren.toArray([
			    //   [<div key="camel" />, <div key="banana" />, <div key="apple" />],
			    //   [<div key="deli" />, <div key="camel" />, <div key="banana" />],
			    // ]);
			    // expect(flattened[0].key).toBe(reversed[2].key);
			    // expect(flattened[1].key).toBe(reversed[1].key);
			    // expect(flattened[2].key).toBe(reversed[0].key);
			    // expect(flattened[3].key).toBe(reversed[5].key);
			    // expect(flattened[4].key).toBe(reversed[4].key);
			    // expect(flattened[5].key).toBe(reversed[3].key);
			    //
			    // // null/undefined/bool are all omitted
			    // expect(ReactChildren.toArray([1, 'two', null, undefined, true])).toEqual(
			    //   [1, 'two']
			    // );
			  \});
			
			  it('should normalize children in forEach', function () \{
			    var children = [];
			    var callback = function (child) \{
			      children.push(child);
			    \};
			
			    ReactChildren.forEach([false, true, undefined], callback);
			    expect(children).toEqual([null, null, null]);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactChildren.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(13)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactClass.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			
			describe('ReactClass-spec', function () \{
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    ReactDOM.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  // it('should warn on invalid prop types', function() \{
			  //   var warn = console.error;
			  //   console.error = mocks.getMockFunction();
			  //   try \{
			
			  //     React.createClass(\{
			  //       displayName: 'Component',
			  //       propTypes: \{
			  //         prop: null,
			  //       \},
			  //       render: function() \{
			  //         return <span>\{this.props.prop\}</span>;
			  //       \},
			  //     \});
			  //     expect(console.error.calls.count()).toBe(1);
			  //     expect(console.error.calls[0][0]).toBe(
			  //       'Warning: Component: prop type \`prop\` is invalid; ' +
			  //       'it must be a function, usually from React.PropTypes.'
			  //     );
			  //   \} finally \{
			  //     console.error = warn;
			  //   \}
			  // \});
			
			  // it('should warn on invalid context types', function() \{
			  //   var warn = console.error;
			  //   console.error = mocks.getMockFunction();
			  //   try \{
			  //     React.createClass(\{
			  //       displayName: 'Component',
			  //       contextTypes: \{
			  //         prop: null,
			  //       \},
			  //       render: function() \{
			  //         return <span>\{this.props.prop\}</span>;
			  //       \},
			  //     \});
			  //     expect(console.error.calls.count()).toBe(1);
			  //     expect(console.error.calls[0][0]).toBe(
			  //       'Warning: Component: context type \`prop\` is invalid; ' +
			  //       'it must be a function, usually from React.PropTypes.'
			  //     );
			  //   \} finally \{
			  //     console.error = warn;
			  //   \}
			  // \});
			
			  // it('should throw on invalid child context types', function() \{
			  //   var warn = console.error;
			  //   console.error = mocks.getMockFunction();
			  //   try \{
			  //     React.createClass(\{
			  //       displayName: 'Component',
			  //       childContextTypes: \{
			  //         prop: null,
			  //       \},
			  //       render: function() \{
			  //         return <span>\{this.props.prop\}</span>;
			  //       \},
			  //     \});
			  //     expect(console.error.calls.count()).toBe(1);
			  //     expect(console.error.calls[0][0]).toBe(
			  //       'Warning: Component: child context type \`prop\` is invalid; ' +
			  //       'it must be a function, usually from React.PropTypes.'
			  //     );
			  //   \} finally \{
			  //     console.error = warn;
			  //   \}
			  // \});
			
			  // it('should warn when mispelling shouldComponentUpdate', function() \{
			  //   React.createClass(\{
			  //     componentShouldUpdate: function() \{
			  //       return false;
			  //     \},
			  //     render: function() \{
			  //       return <div />;
			  //     \},
			  //   \});
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toBe(
			  //     'Warning: A component has a method called componentShouldUpdate(). Did you ' +
			  //     'mean shouldComponentUpdate()? The name is phrased as a question ' +
			  //     'because the function is expected to return a value.'
			  //   );
			
			  //   React.createClass(\{
			  //     displayName: 'NamedComponent',
			  //     componentShouldUpdate: function() \{
			  //       return false;
			  //     \},
			  //     render: function() \{
			  //       return <div />;
			  //     \},
			  //   \});
			  //   expect(console.error.calls.count()).toBe(2);
			  //   expect(console.error.argsForCall[1][0]).toBe(
			  //     'Warning: NamedComponent has a method called componentShouldUpdate(). Did you ' +
			  //     'mean shouldComponentUpdate()? The name is phrased as a question ' +
			  //     'because the function is expected to return a value.'
			  //   );
			  // \});
			
			  // it('should warn when mispelling componentWillReceiveProps', function() \{
			  //   React.createClass(\{
			  //     componentWillRecieveProps: function() \{
			  //       return false;
			  //     \},
			  //     render: function() \{
			  //       return <div />;
			  //     \},
			  //   \});
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toBe(
			  //     'Warning: A component has a method called componentWillRecieveProps(). Did you ' +
			  //     'mean componentWillReceiveProps()?'
			  //   );
			  // \});
			
			  // it('should throw if a reserved property is in statics', function() \{
			  //   expect(function() \{
			  //     React.createClass(\{
			  //       statics: \{
			  //         getDefaultProps: function() \{
			  //           return \{
			  //             foo: 0,
			  //           \};
			  //         \},
			  //       \},
			
			  //       render: function() \{
			  //         return <span />;
			  //       \},
			  //     \});
			  //   \}).toThrow(
			  //     'Invariant Violation: ReactClass: You are attempting to ' +
			  //     'define a reserved property, \`getDefaultProps\`, that shouldn\\'t be on ' +
			  //     'the "statics" key. Define it as an instance property instead; it ' +
			  //     'will still be accessible on the constructor.'
			  //   );
			  // \});
			
			  // // TODO: Consider actually moving these to statics or drop this unit test.
			
			  // xit('should warn when using deprecated non-static spec keys', function() \{
			  //   React.createClass(\{
			  //     mixins: [\{\}],
			  //     propTypes: \{
			  //       foo: React.PropTypes.string,
			  //     \},
			  //     contextTypes: \{
			  //       foo: React.PropTypes.string,
			  //     \},
			  //     childContextTypes: \{
			  //       foo: React.PropTypes.string,
			  //     \},
			  //     render: function() \{
			  //       return <div />;
			  //     \},
			  //   \});
			  //   expect(console.error.calls.count()).toBe(4);
			  //   expect(console.error.argsForCall[0][0]).toBe(
			  //     'createClass(...): \`mixins\` is now a static property and should ' +
			  //     'be defined inside "statics".'
			  //   );
			  //   expect(console.error.argsForCall[1][0]).toBe(
			  //     'createClass(...): \`propTypes\` is now a static property and should ' +
			  //     'be defined inside "statics".'
			  //   );
			  //   expect(console.error.argsForCall[2][0]).toBe(
			  //     'createClass(...): \`contextTypes\` is now a static property and ' +
			  //     'should be defined inside "statics".'
			  //   );
			  //   expect(console.error.argsForCall[3][0]).toBe(
			  //     'createClass(...): \`childContextTypes\` is now a static property and ' +
			  //     'should be defined inside "statics".'
			  //   );
			  // \});
			
			  it('should support statics', function () \{
			    var Component = React.createClass(\{
			      statics: \{
			        abc: 'def',
			        def: 0,
			        ghi: null,
			        jkl: 'mno',
			        pqr: function () \{
			          return this;
			        \}
			      \},
			
			      render: function () \{
			        return <span />;
			      \}
			    \});
			
			    var instance = <Component />;
			    instance = renderIntoDocument(instance).\$LI.children;
			
			    expect(instance.constructor.abc).toBe('def');
			    expect(Component.abc).toBe('def');
			    expect(instance.constructor.def).toBe(0);
			    expect(Component.def).toBe(0);
			    expect(instance.constructor.ghi).toBe(null);
			    expect(Component.ghi).toBe(null);
			    expect(instance.constructor.jkl).toBe('mno');
			    expect(Component.jkl).toBe('mno');
			    expect(instance.constructor.pqr()).toBe(Component);
			    expect(Component.pqr()).toBe(Component);
			  \});
			
			  it('should work with object getInitialState() return values', function () \{
			    var Component = React.createClass(\{
			      getInitialState: function () \{
			        return \{
			          occupation: 'clown'
			        \};
			      \},
			      render: function () \{
			        return <span />;
			      \}
			    \});
			    var instance = <Component />;
			    instance = renderIntoDocument(instance);
			    expect(instance.\$LI.children.state.occupation).toEqual('clown');
			  \});
			
			  it('renders based on context getInitialState', function () \{
			    var Foo = React.createClass(\{
			      contextTypes: \{
			        className: React.PropTypes.string
			      \},
			      getInitialState() \{
			        return \{ className: this.context.className \};
			      \},
			      render() \{
			        return <span className=\{this.state.className\} />;
			      \}
			    \});
			
			    var Outer = React.createClass(\{
			      childContextTypes: \{
			        className: React.PropTypes.string
			      \},
			      getChildContext() \{
			        return \{ className: 'foo' \};
			      \},
			      render() \{
			        return <Foo />;
			      \}
			    \});
			
			    var container = document.createElement('div');
			    ReactDOM.render(<Outer />, container);
			    expect(container.firstChild.className).toBe('foo');
			  \});
			
			  // it('should throw with non-object getInitialState() return values', function() \{
			  //   [['an array'], 'a string', 1234].forEach(function(state) \{
			  //     var Component = React.createClass(\{
			  //       getInitialState: function() \{
			  //         return state;
			  //       \},
			  //       render: function() \{
			  //         return <span />;
			  //       \},
			  //     \});
			  //     var instance = <Component />;
			  //     expect(function() \{
			  //       instance = ReactTestUtils.renderIntoDocument(instance);
			  //     \}).toThrow(
			  //       'Invariant Violation: Component.getInitialState(): ' +
			  //       'must return an object or null'
			  //     );
			  //   \});
			  // \});
			
			  it('should work with a null getInitialState() return value', function () \{
			    var Component = React.createClass(\{
			      getInitialState: function () \{
			        return null;
			      \},
			      render: function () \{
			        return <span />;
			      \}
			    \});
			    expect(() => renderIntoDocument(<Component />)).not.toThrow();
			  \});
			
			  // it('should throw when using legacy factories', function() \{
			  //   var Component = React.createClass(\{
			  //     render() \{
			  //       return <div />;
			  //     \},
			  //   \});
			
			  //   expect(() => Component()).toThrow();
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toBe(
			  //     'Warning: Something is calling a React component directly. Use a ' +
			  //     'factory or JSX instead. See: https://fb.me/react-legacyfactory'
			  //   );
			  // \});
			
			  // it('warns when calling getDOMNode', function() \{
			  //   var MyComponent = React.createClass(\{
			  //     render: function() \{
			  //       return <div />;
			  //     \},
			  //   \});
			
			  //   var container = document.createElement('div');
			  //   var instance = ReactDOM.render(<MyComponent />, container);
			
			  //   instance.getDOMNode();
			
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.calls[0].calls.argsFor(0)[0]).toContain(
			  //     'MyComponent.getDOMNode(...) is deprecated. Please use ' +
			  //     'ReactDOM.findDOMNode(instance) instead.'
			  //   );
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactClass.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactComponent.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			var mocks;
			
			describe('ReactComponent', function () \{
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    mocks = \{
			      getMockFunction: function () \{
			        return jasmine.createSpy();
			      \}
			    \};
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should throw on invalid render targets', function () \{
			    var container = document.createElement('div');
			    // jQuery objects are basically arrays; people often pass them in by mistake
			    expect(function () \{
			      ReactDOM.render(<div />, [container]);
			    \}).toThrow();
			
			    expect(function () \{
			      ReactDOM.render(<div />, null);
			    \}).toThrow();
			  \});
			
			  it('should support new-style refs', function () \{
			    var innerObj = \{\};
			    var outerObj = \{\};
			
			    var Wrapper = React.createClass(\{
			      getObject: function () \{
			        return this.props.object;
			      \},
			      render: function () \{
			        return <div>\{this.props.children\}</div>;
			      \}
			    \});
			
			    var mounted = false;
			    var Component = React.createClass(\{
			      render: function () \{
			        var inner = <Wrapper object=\{innerObj\} ref=\{(c) => (this.innerRef = c)\} />;
			        var outer = (
			          <Wrapper object=\{outerObj\} ref=\{(c) => (this.outerRef = c)\}>
			            \{inner\}
			          </Wrapper>
			        );
			        return outer;
			      \},
			      componentDidMount: function () \{
			        expect(this.innerRef.getObject()).toEqual(innerObj);
			        expect(this.outerRef.getObject()).toEqual(outerObj);
			        mounted = true;
			      \}
			    \});
			
			    var instance = <Component />;
			    renderIntoDocument(instance);
			    expect(mounted).toBe(true);
			  \});
			
			  // it('should call refs at the correct time', function() \{
			  //   var log = [];
			
			  //   var Inner = React.createClass(\{
			  //     render: function() \{
			  //       log.push(\`inner \$\{this.props.id\} render\`);
			  //       return <div />;
			  //     \},
			  //     componentDidMount: function() \{
			  //       log.push(\`inner \$\{this.props.id\} componentDidMount\`);
			  //     \},
			  //     componentDidUpdate: function() \{
			  //       log.push(\`inner \$\{this.props.id\} componentDidUpdate\`);
			  //     \},
			  //     componentWillUnmount: function() \{
			  //       log.push(\`inner \$\{this.props.id\} componentWillUnmount\`);
			  //     \},
			  //   \});
			
			  //   var Outer = React.createClass(\{
			  //     render: function() \{
			  //       return (
			  //         <div>
			  //           <Inner id=\{1\} ref=\{(c) => \{
			  //             log.push(\`ref 1 got \$\{c ? \`instance \$\{c.props.id\}\` : 'null'\}\`);
			  //           \}\}/>
			  //           <Inner id=\{2\} ref=\{(c) => \{
			  //             log.push(\`ref 2 got \$\{c ? \`instance \$\{c.props.id\}\` : 'null'\}\`);
			  //           \}\}/>
			  //         </div>
			  //       );
			  //     \},
			  //     componentDidMount: function() \{
			  //       log.push('outer componentDidMount');
			  //     \},
			  //     componentDidUpdate: function() \{
			  //       log.push('outer componentDidUpdate');
			  //     \},
			  //     componentWillUnmount: function() \{
			  //       log.push('outer componentWillUnmount');
			  //     \},
			  //   \});
			
			  //   // mount, update, unmount
			  //   var el = document.createElement('div');
			  //   log.push('start mount');
			  //   ReactDOM.render(<Outer />, el);
			  //   log.push('start update');
			  //   ReactDOM.render(<Outer />, el);
			  //   log.push('start unmount');
			  //   ReactDOM.unmountComponentAtNode(el);
			  //   console.log(log)
			
			  //   /* eslint-disable indent */
			  //   expect(log).toEqual([
			  //     'start mount',
			  //       'inner 1 render',
			  //       'inner 2 render',
			  //       'inner 1 componentDidMount',
			  //       'ref 1 got instance 1',
			  //       'inner 2 componentDidMount',
			  //       'ref 2 got instance 2',
			  //       'outer componentDidMount',
			  //     'start update',
			  //       // Previous (equivalent) refs get cleared
			  //       'ref 1 got null',
			  //       'inner 1 render',
			  //       'ref 2 got null',
			  //       'inner 2 render',
			  //       'inner 1 componentDidUpdate',
			  //       'ref 1 got instance 1',
			  //       'inner 2 componentDidUpdate',
			  //       'ref 2 got instance 2',
			  //       'outer componentDidUpdate',
			  //     'start unmount',
			  //       'outer componentWillUnmount',
			  //       'ref 1 got null',
			  //       'inner 1 componentWillUnmount',
			  //       'ref 2 got null',
			  //       'inner 2 componentWillUnmount',
			  //   ]);
			  //   /* eslint-enable indent */
			  // \});
			
			  it('fires the callback after a component is rendered', function () \{
			    var callback = mocks.getMockFunction();
			    var container = document.createElement('div');
			    ReactDOM.render(<div />, container, callback);
			    expect(callback.calls.count()).toBe(1);
			    ReactDOM.render(<div className="foo" />, container, callback);
			    expect(callback.calls.count()).toBe(2);
			    ReactDOM.render(<span />, container, callback);
			    expect(callback.calls.count()).toBe(3);
			  \});
			
			  // // it('warns when calling getDOMNode', function() \{
			  // //   spyOn(console, 'error');
			
			  // //   var Potato = React.createClass(\{
			  // //     render: function() \{
			  // //       return <div />;
			  // //     \},
			  // //   \});
			  // //   var container = document.createElement('div');
			  // //   var instance = ReactDOM.render(<Potato />, container);
			
			  // //   instance.getDOMNode();
			
			  // //   expect(console.error.calls.count()).toBe(1);
			  // //   expect(console.error.calls[0].calls.argsFor(0)[0]).toContain(
			  // //     'Potato.getDOMNode(...) is deprecated. Please use ' +
			  // //     'ReactDOM.findDOMNode(instance) instead.'
			  // //   );
			  // // \});
			
			  it('throws usefully when rendering badly-typed elements', function () \{
			    //spyOn(console, 'error');
			
			    var X = undefined;
			    expect(() => renderIntoDocument(<X />)).toThrow();
			
			    var Z = \{\};
			    expect(() => renderIntoDocument(<Z />)).toThrow();
			
			    // One warning for each element creation
			    //expect(console.error.calls.count()).toBe(3);
			  \});
			
			  // other
			  it('should pass context to children when not owner', function () \{
			    var Parent = React.createClass(\{
			      render: function () \{
			        return (
			          <Child>
			            <Grandchild />
			          </Child>
			        );
			      \}
			    \});
			
			    var Child = React.createClass(\{
			      childContextTypes: \{
			        foo: React.PropTypes.string
			      \},
			
			      getChildContext: function () \{
			        return \{
			          foo: 'bar'
			        \};
			      \},
			
			      render: function () \{
			        return React.Children.only(this.props.children);
			      \}
			    \});
			
			    var Grandchild = React.createClass(\{
			      contextTypes: \{
			        foo: React.PropTypes.string
			      \},
			
			      render: function () \{
			        return <div>\{this.context.foo\}</div>;
			      \}
			    \});
			
			    var component = renderIntoDocument(<Parent />);
			    expect(ReactDOM.findDOMNode(component).innerHTML).toBe('bar');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactComponent.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactComponentLifeCycle.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			
			var clone = function (o) \{
			  return JSON.parse(JSON.stringify(o));
			\};
			
			var GET_INIT_STATE_RETURN_VAL = \{
			  hasWillMountCompleted: false,
			  hasRenderCompleted: false,
			  hasDidMountCompleted: false,
			  hasWillUnmountCompleted: false
			\};
			
			var INIT_RENDER_STATE = \{
			  hasWillMountCompleted: true,
			  hasRenderCompleted: false,
			  hasDidMountCompleted: false,
			  hasWillUnmountCompleted: false
			\};
			
			var DID_MOUNT_STATE = \{
			  hasWillMountCompleted: true,
			  hasRenderCompleted: true,
			  hasDidMountCompleted: false,
			  hasWillUnmountCompleted: false
			\};
			
			var NEXT_RENDER_STATE = \{
			  hasWillMountCompleted: true,
			  hasRenderCompleted: true,
			  hasDidMountCompleted: true,
			  hasWillUnmountCompleted: false
			\};
			
			var WILL_UNMOUNT_STATE = \{
			  hasWillMountCompleted: true,
			  hasDidMountCompleted: true,
			  hasRenderCompleted: true,
			  hasWillUnmountCompleted: false
			\};
			
			var POST_WILL_UNMOUNT_STATE = \{
			  hasWillMountCompleted: true,
			  hasDidMountCompleted: true,
			  hasRenderCompleted: true,
			  hasWillUnmountCompleted: true
			\};
			
			/**
			 * Every React component is in one of these life cycles.
			 */
			var ComponentLifeCycle = \{
			  /**
			   * Mounted components have a DOM node representation and are capable of
			   * receiving new props.
			   */
			  MOUNTED: 'MOUNTED',
			  /**
			   * Unmounted components are inactive and cannot receive new props.
			   */
			  UNMOUNTED: 'UNMOUNTED'
			\};
			
			/**
			 * TODO: We should make any setState calls fail in
			 * \`getInitialState\` and \`componentWillMount\`. They will usually fail
			 * anyways because \`this._renderedComponent\` is empty, however, if a component
			 * is *reused*, then that won't be the case and things will appear to work in
			 * some cases. Better to just block all updates in initialization.
			 */
			describe('ReactComponentLifeCycle', function () \{
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should not reuse an instance when it has been unmounted', function () \{
			    var container = document.createElement('div');
			    var StatefulComponent = React.createClass(\{
			      getInitialState: function () \{
			        return \{\};
			      \},
			      render: function () \{
			        return <div />;
			      \}
			    \});
			    var element = <StatefulComponent />;
			
			    var firstInstance = ReactDOM.render(element, container);
			    ReactDOM.unmountComponentAtNode(container);
			    var secondInstance = ReactDOM.render(element, container);
			    expect(firstInstance).not.toBe(secondInstance);
			  \});
			
			  /**
			   * If a state update triggers rerendering that in turn fires an onDOMReady,
			   * that second onDOMReady should not fail.
			   */
			  it('it should fire onDOMReady when already in onDOMReady', function (done) \{
			    var _testJournal = [];
			
			    var Child = React.createClass(\{
			      componentDidMount: function () \{
			        _testJournal.push('Child:onDOMReady');
			      \},
			      render: function () \{
			        return <div />;
			      \}
			    \});
			
			    var SwitcherParent = React.createClass(\{
			      getInitialState: function () \{
			        _testJournal.push('SwitcherParent:getInitialState');
			        return \{ showHasOnDOMReadyComponent: false \};
			      \},
			      componentDidMount: function () \{
			        _testJournal.push('SwitcherParent:onDOMReady');
			        this.switchIt();
			      \},
			      switchIt: function () \{
			        this.setState(\{ showHasOnDOMReadyComponent: true \});
			      \},
			      render: function () \{
			        return <div>\{this.state.showHasOnDOMReadyComponent ? <Child /> : <div> </div>\}</div>;
			      \}
			    \});
			
			    var instance = <SwitcherParent />;
			    renderIntoDocument(instance);
			    setTimeout(() => \{
			      expect(_testJournal).toEqual(['SwitcherParent:getInitialState', 'SwitcherParent:onDOMReady', 'Child:onDOMReady']);
			      done();
			    \}, 20);
			  \});
			
			  // You could assign state here, but not access members of it, unless you
			  // had provided a getInitialState method.
			  // it('throws when accessing state in componentWillMount', function() \{
			  //   var StatefulComponent = React.createClass(\{
			  //     componentWillMount: function() \{
			  //       void this.state.yada;
			  //     \},
			  //     render: function() \{
			  //       return (
			  //         <div></div>
			  //       );
			  //     \},
			  //   \});
			  //   var instance = <StatefulComponent />;
			  //   expect(function() \{
			  //     instance = ReactTestUtils.renderIntoDocument(instance);
			  //   \}).toThrow();
			  // \});
			
			  it('should allow update state inside of componentWillMount', function () \{
			    var StatefulComponent = React.createClass(\{
			      componentWillMount: function () \{
			        this.setState(\{ stateField: 'something' \});
			      \},
			      render: function () \{
			        return <div />;
			      \}
			    \});
			    var instance = <StatefulComponent />;
			    expect(function () \{
			      renderIntoDocument(instance);
			    \}).not.toThrow();
			  \});
			
			  it('should not allow update state inside of getInitialState', function () \{
			    spyOn(console, 'error');
			    var StatefulComponent = React.createClass(\{
			      getInitialState: function () \{
			        this.setState(\{ stateField: 'something' \});
			
			        return \{ stateField: 'somethingelse' \};
			      \},
			      render: function () \{
			        return <div />;
			      \}
			    \});
			    expect(() => renderIntoDocument(<StatefulComponent />)).toThrow();
			    // expect(console.error.calls.count()).toBe(1);
			    // expect(console.error.argsForCall[0][0]).toBe(
			    //   'Warning: setState(...): Can only update a mounted or ' +
			    //   'mounting component. This usually means you called setState() on an ' +
			    //   'unmounted component. This is a no-op. Please check the code for the ' +
			    //   'StatefulComponent component.'
			    // );
			  \});
			
			  it('should correctly determine if a component is mounted', function () \{
			    spyOn(console, 'error');
			    var Component = React.createClass(\{
			      componentWillMount: function () \{
			        expect(this.isMounted()).toBeFalsy();
			      \},
			      componentDidMount: function () \{
			        expect(this.isMounted()).toBeTruthy();
			      \},
			      render: function () \{
			        expect(this.isMounted()).toBeFalsy();
			        return <div />;
			      \}
			    \});
			
			    var element = <Component />;
			
			    var instance = renderIntoDocument(element);
			    expect(instance.\$LI.children.isMounted()).toBeTruthy();
			
			    // expect(console.error.calls.count()).toBe(1);
			    // expect(console.error.argsForCall[0][0]).toContain(
			    //   'Component is accessing isMounted inside its render()'
			    // );
			  \});
			
			  it('should correctly determine if a null component is mounted', function () \{
			    spyOn(console, 'error');
			    var Component = React.createClass(\{
			      componentWillMount: function () \{
			        expect(this.isMounted()).toBeFalsy();
			      \},
			      componentDidMount: function () \{
			        expect(this.isMounted()).toBeTruthy();
			      \},
			      render: function () \{
			        expect(this.isMounted()).toBeFalsy();
			        return null;
			      \}
			    \});
			
			    var element = <Component />;
			
			    var instance = renderIntoDocument(element);
			    expect(instance.\$LI.children.isMounted()).toBeTruthy();
			
			    // expect(console.error.calls.count()).toBe(1);
			    // expect(console.error.argsForCall[0][0]).toContain(
			    //   'Component is accessing isMounted inside its render()'
			    // );
			  \});
			
			  it('isMounted should return false when unmounted', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        return <div />;
			      \}
			    \});
			
			    var container = document.createElement('div');
			    var instance = ReactDOM.render(<Component />, container);
			
			    expect(instance.isMounted()).toBe(true);
			
			    ReactDOM.unmountComponentAtNode(container);
			
			    expect(instance.isMounted()).toBe(false);
			  \});
			
			  //   // A component that is merely "constructed" (as in "constructor") but not
			  //   // yet initialized, or rendered.
			  //   //
			  //   var container = document.createElement('div');
			  //   var instance = ReactDOM.render(<LifeCycleComponent />, container);
			
			  //   // getInitialState
			  //   expect(instance._testJournal.returnedFromGetInitialState).toEqual(
			  //     GET_INIT_STATE_RETURN_VAL
			  //   );
			  //   expect(instance._testJournal.lifeCycleAtStartOfGetInitialState)
			  //     .toBe(ComponentLifeCycle.UNMOUNTED);
			
			  //   // componentWillMount
			  //   expect(instance._testJournal.stateAtStartOfWillMount).toEqual(
			  //     instance._testJournal.returnedFromGetInitialState
			  //   );
			  //   expect(instance._testJournal.lifeCycleAtStartOfWillMount)
			  //     .toBe(ComponentLifeCycle.MOUNTED);
			
			  //   // componentDidMount
			  //   expect(instance._testJournal.stateAtStartOfDidMount)
			  //     .toEqual(DID_MOUNT_STATE);
			  //   expect(instance._testJournal.lifeCycleAtStartOfDidMount).toBe(
			  //     ComponentLifeCycle.MOUNTED
			  //   );
			
			  //   // render
			  //   expect(instance._testJournal.stateInInitialRender)
			  //     .toEqual(INIT_RENDER_STATE);
			  //   expect(instance._testJournal.lifeCycleInInitialRender).toBe(
			  //     ComponentLifeCycle.MOUNTED
			  //   );
			
			  //   expect(getLifeCycleState(instance)).toBe(ComponentLifeCycle.MOUNTED);
			
			  //   // Now *update the component*
			  //   instance.forceUpdate();
			
			  //   // render 2nd time
			  //   expect(instance._testJournal.stateInLaterRender)
			  //     .toEqual(NEXT_RENDER_STATE);
			  //   expect(instance._testJournal.lifeCycleInLaterRender).toBe(
			  //     ComponentLifeCycle.MOUNTED
			  //     ComponentLifeCycle.MOUNTED
			  //   );
			
			  //   expect(getLifeCycleState(instance)).toBe(ComponentLifeCycle.MOUNTED);
			
			  //   ReactDOM.unmountComponentAtNode(container);
			
			  //   expect(instance._testJournal.stateAtStartOfWillUnmount)
			  //     .toEqual(WILL_UNMOUNT_STATE);
			  //   // componentWillUnmount called right before unmount.
			  //   expect(instance._testJournal.lifeCycleAtStartOfWillUnmount).toBe(
			  //     ComponentLifeCycle.MOUNTED
			  //   );
			
			  //   // But the current lifecycle of the component is unmounted.
			  //   expect(getLifeCycleState(instance)).toBe(ComponentLifeCycle.UNMOUNTED);
			  //   expect(instance.state).toEqual(POST_WILL_UNMOUNT_STATE);
			  // \});
			
			  // it('should throw when calling setProps() on an owned component', function() \{
			  //   /**
			  //    * calls setProps in an componentDidMount.
			  //    */
			  //   var Inner = React.createClass(\{
			  //     render: function() \{
			  //       return <div />;
			  //     \},
			  //   \});
			  //   var PropsUpdaterInOnDOMReady = React.createClass(\{
			  //     componentDidMount: function() \{
			  //       this.refs.theSimpleComponent.setProps(\{
			  //         className: this.props.valueToUseInOnDOMReady,
			  //       \});
			  //     \},
			  //     render: function() \{
			  //       return (
			  //         <Inner
			  //           className=\{this.props.valueToUseInitially\}
			  //           ref="theSimpleComponent"
			  //         />
			  //       );
			  //     \},
			  //   \});
			  //   var instance =
			  //     <PropsUpdaterInOnDOMReady
			  //       valueToUseInitially="hello"
			  //       valueToUseInOnDOMReady="goodbye"
			  //     />;
			  //   spyOn(console, 'error');
			  //   expect(function() \{
			  //     instance = ReactTestUtils.renderIntoDocument(instance);
			  //   \}).toThrow(
			  //     'Invariant Violation: setProps(...): You called \`setProps\` on a ' +
			  //     'component with a parent. This is an anti-pattern since props will get ' +
			  //     'reactively updated when rendered. Instead, change the owner\\'s ' +
			  //     '\`render\` method to pass the correct value as props to the component ' +
			  //     'where it is created.'
			  //   );
			  //   expect(console.error.calls.count()).toBe(1);  // setProps deprecated
			  // \});
			
			  it('should not throw when updating an auxiliary component', function () \{
			    var Tooltip = React.createClass(\{
			      render: function () \{
			        return <div>\{this.props.children\}</div>;
			      \},
			      componentDidMount: function () \{
			        this.container = document.createElement('div');
			        this.updateTooltip();
			      \},
			      componentDidUpdate: function () \{
			        this.updateTooltip();
			      \},
			      updateTooltip: function () \{
			        // Even though this.props.tooltip has an owner, updating it shouldn't
			        // throw here because it's mounted as a root component
			        ReactDOM.render(this.props.tooltip, this.container);
			      \}
			    \});
			    var Component = React.createClass(\{
			      render: function () \{
			        return <Tooltip tooltip=\{<div>\{this.props.tooltipText\}</div>\}>\{this.props.text\}</Tooltip>;
			      \}
			    \});
			
			    var container = document.createElement('div');
			    ReactDOM.render(<Component text="uno" tooltipText="one" />, container);
			
			    // Since \`instance\` is a root component, we can set its props. This also
			    // makes Tooltip rerender the tooltip component, which shouldn't throw.
			    ReactDOM.render(<Component text="dos" tooltipText="two" />, container);
			  \});
			
			  it('should allow state updates in componentDidMount', function (done) \{
			    /**
			     * calls setState in an componentDidMount.
			     */
			    var SetStateInComponentDidMount = React.createClass(\{
			      getInitialState: function () \{
			        return \{
			          stateField: this.props.valueToUseInitially
			        \};
			      \},
			      componentDidMount: function () \{
			        this.setState(\{ stateField: this.props.valueToUseInOnDOMReady \});
			      \},
			      render: function () \{
			        return <div />;
			      \}
			    \});
			    var instance = <SetStateInComponentDidMount valueToUseInitially="hello" valueToUseInOnDOMReady="goodbye" />;
			    instance = renderIntoDocument(instance);
			
			    setTimeout(() => \{
			      expect(instance.\$LI.children.state.stateField).toBe('goodbye');
			      done();
			    \}, 25);
			  \});
			
			  it('should call nested lifecycle methods in the right order', function () \{
			    var log;
			    var logger = function (msg) \{
			      return function () \{
			        // return true for shouldComponentUpdate
			        log.push(msg);
			        return true;
			      \};
			    \};
			    var Outer = React.createClass(\{
			      render: function () \{
			        return (
			          <div>
			            <Inner x=\{this.props.x\} />
			          </div>
			        );
			      \},
			      componentWillMount: logger('outer componentWillMount'),
			      componentDidMount: logger('outer componentDidMount'),
			      componentWillReceiveProps: logger('outer componentWillReceiveProps'),
			      shouldComponentUpdate: logger('outer shouldComponentUpdate'),
			      componentWillUpdate: logger('outer componentWillUpdate'),
			      componentDidUpdate: logger('outer componentDidUpdate'),
			      componentWillUnmount: logger('outer componentWillUnmount')
			    \});
			    var Inner = React.createClass(\{
			      render: function () \{
			        return <span>\{this.props.x\}</span>;
			      \},
			      componentWillMount: logger('inner componentWillMount'),
			      componentDidMount: logger('inner componentDidMount'),
			      componentWillReceiveProps: logger('inner componentWillReceiveProps'),
			      shouldComponentUpdate: logger('inner shouldComponentUpdate'),
			      componentWillUpdate: logger('inner componentWillUpdate'),
			      componentDidUpdate: logger('inner componentDidUpdate'),
			      componentWillUnmount: logger('inner componentWillUnmount')
			    \});
			
			    var container = document.createElement('div');
			    log = [];
			    ReactDOM.render(<Outer x=\{17\} />, container);
			    expect(log).toEqual(['outer componentWillMount', 'inner componentWillMount', 'inner componentDidMount', 'outer componentDidMount']);
			
			    log = [];
			    ReactDOM.render(<Outer x=\{42\} />, container);
			    expect(log).toEqual([
			      'outer componentWillReceiveProps',
			      'outer shouldComponentUpdate',
			      'outer componentWillUpdate',
			      'inner componentWillReceiveProps',
			      'inner shouldComponentUpdate',
			      'inner componentWillUpdate',
			      'inner componentDidUpdate',
			      'outer componentDidUpdate'
			    ]);
			
			    log = [];
			    ReactDOM.unmountComponentAtNode(container);
			    expect(log).toEqual(['outer componentWillUnmount', 'inner componentWillUnmount']);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactComponentLifeCycle.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(10)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactCompositeComponentState.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			
			var TestComponent;
			
			describe('ReactCompositeComponent-state', function () \{
			  beforeEach(function () \{
			    TestComponent = React.createClass(\{
			      peekAtState: function (from, state) \{
			        state = state || this.state;
			        this.props.stateListener(from, state && state.color);
			      \},
			
			      peekAtCallback: function (from) \{
			        return () => this.peekAtState(from);
			      \},
			
			      setFavoriteColor: function (nextColor) \{
			        this.setState(\{ color: nextColor \}, this.peekAtCallback('setFavoriteColor'));
			      \},
			
			      getInitialState: function () \{
			        this.peekAtState('getInitialState');
			        return \{ color: 'red' \};
			      \},
			
			      render: function () \{
			        this.peekAtState('render');
			        return <div>\{this.state.color\}</div>;
			      \},
			
			      componentWillMount: function () \{
			        this.peekAtState('componentWillMount-start');
			        this.setState(function (state) \{
			          this.peekAtState('before-setState-sunrise', state);
			        \});
			        this.setState(\{ color: 'sunrise' \}, this.peekAtCallback('setState-sunrise'));
			        this.setState(function (state) \{
			          this.peekAtState('after-setState-sunrise', state);
			        \});
			        this.peekAtState('componentWillMount-after-sunrise');
			        this.setState(\{ color: 'orange' \}, this.peekAtCallback('setState-orange'));
			        this.setState(function (state) \{
			          this.peekAtState('after-setState-orange', state);
			        \});
			        this.peekAtState('componentWillMount-end');
			      \},
			
			      componentDidMount: function () \{
			        this.peekAtState('componentDidMount-start');
			        this.setState(\{ color: 'yellow' \}, this.peekAtCallback('setState-yellow'));
			        this.peekAtState('componentDidMount-end');
			      \},
			
			      componentWillReceiveProps: function (newProps) \{
			        this.peekAtState('componentWillReceiveProps-start');
			        if (newProps.nextColor) \{
			          this.setState(function (state) \{
			            this.peekAtState('before-setState-receiveProps', state);
			            return \{ color: newProps.nextColor \};
			          \});
			          this.replaceState(\{ color: undefined \});
			          this.setState(function (state) \{
			            this.peekAtState('before-setState-again-receiveProps', state);
			            return \{ color: newProps.nextColor \};
			          \}, this.peekAtCallback('setState-receiveProps'));
			          this.setState(function (state) \{
			            this.peekAtState('after-setState-receiveProps', state);
			          \});
			        \}
			        this.peekAtState('componentWillReceiveProps-end');
			      \},
			
			      shouldComponentUpdate: function (nextProps, nextState) \{
			        this.peekAtState('shouldComponentUpdate-currentState');
			        this.peekAtState('shouldComponentUpdate-nextState', nextState);
			        return true;
			      \},
			
			      componentWillUpdate: function (nextProps, nextState) \{
			        this.peekAtState('componentWillUpdate-currentState');
			        this.peekAtState('componentWillUpdate-nextState', nextState);
			      \},
			
			      componentDidUpdate: function (prevProps, prevState) \{
			        this.peekAtState('componentDidUpdate-currentState');
			        this.peekAtState('componentDidUpdate-prevState', prevState);
			      \},
			
			      componentWillUnmount: function () \{
			        this.peekAtState('componentWillUnmount');
			      \}
			    \});
			  \});
			
			  // it('should support setting state', function() \{
			  //   var container = document.createElement('div');
			  //   document.body.appendChild(container);
			  //
			  //   var stateListener = mocks.getMockFunction();
			  //   var instance = ReactDOM.render(
			  //     <TestComponent stateListener=\{stateListener\} />,
			  //     container,
			  //     function peekAtInitialCallback() \{
			  //       this.peekAtState('initial-callback');
			  //     \}
			  //   );
			  //   ReactDOM.render(
			  //     <TestComponent stateListener=\{stateListener\} nextColor="green" />,
			  //     container,
			  //     instance.peekAtCallback('setProps')
			  //   );
			  //   instance.setFavoriteColor('blue');
			  //   instance.forceUpdate(instance.peekAtCallback('forceUpdate'));
			  //
			  //   ReactDOM.unmountComponentAtNode(container);
			  //
			  //   expect(stateListener.calls.join('\\n')).toEqual([
			  //     // there is no state when getInitialState() is called
			  //     ['getInitialState', null],
			  //     ['componentWillMount-start', 'red'],
			  //     // setState()'s only enqueue pending states.
			  //     ['componentWillMount-after-sunrise', 'red'],
			  //     ['componentWillMount-end', 'red'],
			  //     // pending state queue is processed
			  //     ['before-setState-sunrise', 'red'],
			  //     ['after-setState-sunrise', 'sunrise'],
			  //     ['after-setState-orange', 'orange'],
			  //     // pending state has been applied
			  //     ['render', 'orange'],
			  //     ['componentDidMount-start', 'orange'],
			  //     // setState-sunrise and setState-orange should be called here,
			  //     // after the bug in #1740
			  //     // componentDidMount() called setState(\{color:'yellow'\}), which is async.
			  //     // The update doesn't happen until the next flush.
			  //     ['componentDidMount-end', 'orange'],
			  //     ['shouldComponentUpdate-currentState', 'orange'],
			  //     ['shouldComponentUpdate-nextState', 'yellow'],
			  //     ['componentWillUpdate-currentState', 'orange'],
			  //     ['componentWillUpdate-nextState', 'yellow'],
			  //     ['render', 'yellow'],
			  //     ['componentDidUpdate-currentState', 'yellow'],
			  //     ['componentDidUpdate-prevState', 'orange'],
			  //     ['setState-sunrise', 'yellow'],
			  //     ['setState-orange', 'yellow'],
			  //     ['setState-yellow', 'yellow'],
			  //     ['initial-callback', 'yellow'],
			  //     ['componentWillReceiveProps-start', 'yellow'],
			  //     // setState(\{color:'green'\}) only enqueues a pending state.
			  //     ['componentWillReceiveProps-end', 'yellow'],
			  //     // pending state queue is processed
			  //     // before-setState-receiveProps never called, due to replaceState.
			  //     ['before-setState-again-receiveProps', undefined],
			  //     ['after-setState-receiveProps', 'green'],
			  //     ['shouldComponentUpdate-currentState', 'yellow'],
			  //     ['shouldComponentUpdate-nextState', 'green'],
			  //     ['componentWillUpdate-currentState', 'yellow'],
			  //     ['componentWillUpdate-nextState', 'green'],
			  //     ['render', 'green'],
			  //     ['componentDidUpdate-currentState', 'green'],
			  //     ['componentDidUpdate-prevState', 'yellow'],
			  //     ['setState-receiveProps', 'green'],
			  //     ['setProps', 'green'],
			  //     // setFavoriteColor('blue')
			  //     ['shouldComponentUpdate-currentState', 'green'],
			  //     ['shouldComponentUpdate-nextState', 'blue'],
			  //     ['componentWillUpdate-currentState', 'green'],
			  //     ['componentWillUpdate-nextState', 'blue'],
			  //     ['render', 'blue'],
			  //     ['componentDidUpdate-currentState', 'blue'],
			  //     ['componentDidUpdate-prevState', 'green'],
			  //     ['setFavoriteColor', 'blue'],
			  //     // forceUpdate()
			  //     ['componentWillUpdate-currentState', 'blue'],
			  //     ['componentWillUpdate-nextState', 'blue'],
			  //     ['render', 'blue'],
			  //     ['componentDidUpdate-currentState', 'blue'],
			  //     ['componentDidUpdate-prevState', 'blue'],
			  //     ['forceUpdate', 'blue'],
			  //     // unmountComponent()
			  //     // state is available within \`componentWillUnmount()\`
			  //     ['componentWillUnmount', 'blue'],
			  //   ].join('\\n'));
			  // \});
			
			  it('should batch unmounts', function () \{
			    var outer;
			    var Inner = React.createClass(\{
			      render: function () \{
			        return <div />;
			      \},
			      componentWillUnmount: function () \{
			        // This should get silently ignored (maybe with a warning), but it
			        // shouldn't break React.
			        outer.setState(\{ showInner: false \});
			      \}
			    \});
			    var Outer = React.createClass(\{
			      getInitialState: function () \{
			        return \{ showInner: true \};
			      \},
			      render: function () \{
			        return <div>\{this.state.showInner && <Inner />\}</div>;
			      \}
			    \});
			
			    var container = document.createElement('div');
			    outer = ReactDOM.render(<Outer />, container);
			    expect(() => \{
			      ReactDOM.unmountComponentAtNode(container);
			    \}).not.toThrow();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactCompositeComponentState.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactDOM.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			var div = React.createFactory('div');
			
			describe('ReactDOM', function () \{
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  // TODO: uncomment this test once we can run in phantom, which
			  // supports real submit events.
			  /*
			  it('should bubble onSubmit', function() \{
			    var count = 0;
			    var form;
			    var Parent = React.createClass(\{
			      handleSubmit: function() \{
			        count++;
			        return false;
			      \},
			      render: function() \{
			        return <Child />;
			      \}
			    \});
			    var Child = React.createClass(\{
			      render: function() \{
			        return <form><input type="submit" value="Submit" /></form>;
			      \},
			      componentDidMount: function() \{
			        form = ReactDOM.findDOMNode(this);
			      \}
			    \});
			    var instance = ReactTestUtils.renderIntoDocument(<Parent />);
			    form.submit();
			    expect(count).toEqual(1);
			  \});
			  */
			
			  it('allows a DOM element to be used with a string', function () \{
			    var element = React.createElement('div', \{ className: 'foo' \});
			    var instance = renderIntoDocument(element);
			    expect(ReactDOM.findDOMNode(instance).tagName).toBe('DIV');
			  \});
			
			  it('should allow children to be passed as an argument', function () \{
			    var argDiv = renderIntoDocument(div(null, 'child'));
			    var argNode = ReactDOM.findDOMNode(argDiv);
			    expect(argNode.innerHTML).toBe('child');
			  \});
			
			  it('should overwrite props.children with children argument', function () \{
			    var conflictDiv = renderIntoDocument(div(\{ children: 'fakechild' \}, 'child'));
			    var conflictNode = ReactDOM.findDOMNode(conflictDiv);
			    expect(conflictNode.innerHTML).toBe('child');
			  \});
			
			  /**
			   * We need to make sure that updates occur to the actual node that's in the
			   * DOM, instead of a stale cache.
			   */
			  it('should purge the DOM cache when removing nodes', function () \{
			    var myDiv = renderIntoDocument(
			      <div>
			        <div key="theDog" className="dog" />
			        <div key="theBird" className="bird" />
			      </div>
			    );
			    // Warm the cache with theDog
			    myDiv = renderIntoDocument(
			      <div>
			        <div key="theDog" className="dogbeforedelete" />
			        <div key="theBird" className="bird" />
			      </div>
			    );
			    // Remove theDog - this should purge the cache
			    myDiv = renderIntoDocument(
			      <div>
			        <div key="theBird" className="bird" />
			      </div>
			    );
			    // Now, put theDog back. It's now a different DOM node.
			    myDiv = renderIntoDocument(
			      <div>
			        <div key="theDog" className="dog" />
			        <div key="theBird" className="bird" />
			      </div>
			    );
			    // Change the className of theDog. It will use the same element
			    myDiv = renderIntoDocument(
			      <div>
			        <div key="theDog" className="bigdog" />
			        <div key="theBird" className="bird" />
			      </div>
			    );
			
			    var root = ReactDOM.findDOMNode(myDiv);
			    var dog = root.childNodes[0];
			    expect(dog.className).toBe('bigdog');
			  \});
			
			  it('allow React.DOM factories to be called without warnings', function () \{
			    spyOn(console, 'error');
			    var element = div();
			    expect(element.type).toBe('div');
			    expect(console.error.calls.count()).toBe(0);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactDOM.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactDOMComponent.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			
			if (typeof global !== 'undefined' && global.usingJSDOM) \{
			  describe('ReactDOMComponent', function () \{
			    describe('updateDOM', function () \{
			      it('should handle className', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<div style=\{\{\}\} />, container);
			
			        ReactDOM.render(<div className=\{'foo'\} />, container);
			        expect(container.firstChild.className).toEqual('foo');
			        ReactDOM.render(<div className=\{'bar'\} />, container);
			        expect(container.firstChild.className).toEqual('bar');
			        ReactDOM.render(<div className=\{null\} />, container);
			        expect(container.firstChild.className).toEqual('');
			      \});
			
			      it('should gracefully handle various style value types', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<div style=\{\{\}\} />, container);
			        var stubStyle = container.firstChild.style;
			
			        // set initial style
			        var setup = \{ display: 'block', left: '1px', top: '2px', 'font-family': 'Arial' \};
			        ReactDOM.render(<div style=\{setup\} />, container);
			        expect(stubStyle.display).toEqual('block');
			        expect(stubStyle.left).toEqual('1px');
			        expect(stubStyle.fontFamily).toEqual('Arial');
			
			        // reset the style to their default state
			        var reset = \{ display: '', left: null, top: null, fontFamily: null \};
			        ReactDOM.render(<div style=\{reset\} />, container);
			        expect(stubStyle.display).toEqual('');
			        expect(stubStyle.left).toEqual('');
			        expect(stubStyle.top).toEqual('');
			        expect(stubStyle.fontFamily).toEqual('');
			      \});
			
			      it('should update styles if initially null', function () \{
			        var styles = null;
			        var container = document.createElement('div');
			        ReactDOM.render(<div style=\{styles\} />, container);
			
			        var stubStyle = container.firstChild.style;
			
			        styles = \{ display: 'block' \};
			
			        ReactDOM.render(<div style=\{styles\} />, container);
			        expect(stubStyle.display).toEqual('block');
			      \});
			
			      it('should update styles if updated to null multiple times', function () \{
			        var styles = null;
			        var container = document.createElement('div');
			        ReactDOM.render(<div style=\{styles\} />, container);
			
			        styles = \{ display: 'block' \};
			        var stubStyle = container.firstChild.style;
			
			        ReactDOM.render(<div style=\{styles\} />, container);
			        expect(stubStyle.display).toEqual('block');
			
			        ReactDOM.render(<div style=\{null\} />, container);
			        expect(stubStyle.display).toEqual('');
			
			        ReactDOM.render(<div style=\{styles\} />, container);
			        expect(stubStyle.display).toEqual('block');
			
			        ReactDOM.render(<div style=\{null\} />, container);
			        expect(stubStyle.display).toEqual('');
			      \});
			
			      it('should remove attributes', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<img height="17" />, container);
			
			        expect(container.firstChild.hasAttribute('height')).toBe(true);
			        ReactDOM.render(<img />, container);
			        expect(container.firstChild.hasAttribute('height')).toBe(false);
			      \});
			
			      it('should remove properties', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<div className="monkey" />, container);
			
			        expect(container.firstChild.className).toEqual('monkey');
			        ReactDOM.render(<div />, container);
			        expect(container.firstChild.className).toEqual('');
			      \});
			
			      it('should clear a single style prop when changing \`style\`', function () \{
			        var styles = \{ display: 'none', color: 'red' \};
			        var container = document.createElement('div');
			        ReactDOM.render(<div style=\{styles\} />, container);
			
			        var stubStyle = container.firstChild.style;
			
			        styles = \{ color: 'green' \};
			        ReactDOM.render(<div style=\{styles\} />, container);
			        expect(stubStyle.display).toEqual('');
			        expect(stubStyle.color).toEqual('green');
			      \});
			
			      it('should update arbitrary attributes for tags containing dashes', function () \{
			        var container = document.createElement('div');
			
			        var beforeUpdate = React.createElement('x-foo-component', \{\}, null);
			        ReactDOM.render(beforeUpdate, container);
			
			        var afterUpdate = <x-foo-component myattr="myval" />;
			        ReactDOM.render(afterUpdate, container);
			
			        expect(container.childNodes[0].getAttribute('myattr')).toBe('myval');
			      \});
			
			      it('should clear all the styles when removing \`style\`', function () \{
			        var styles = \{ display: 'none', color: 'red' \};
			        var container = document.createElement('div');
			        ReactDOM.render(<div style=\{styles\} />, container);
			
			        var stubStyle = container.firstChild.style;
			
			        ReactDOM.render(<div />, container);
			        expect(stubStyle.display).toEqual('');
			        expect(stubStyle.color).toEqual('');
			      \});
			
			      it('should update styles when \`style\` changes from null to object', function () \{
			        var container = document.createElement('div');
			        var styles = \{ color: 'red' \};
			        ReactDOM.render(<div style=\{styles\} />, container);
			        ReactDOM.render(<div />, container);
			        ReactDOM.render(<div style=\{styles\} />, container);
			
			        var stubStyle = container.firstChild.style;
			        expect(stubStyle.color).toEqual('red');
			      \});
			
			      it('should empty element when removing innerHTML', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<div dangerouslySetInnerHTML=\{\{ __html: ':)' \}\} />, container);
			
			        expect(container.firstChild.innerHTML).toEqual(':)');
			        ReactDOM.render(<div />, container);
			        expect(container.firstChild.innerHTML).toEqual('');
			      \});
			
			      it('should transition from string content to innerHTML', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<div>hello</div>, container);
			
			        expect(container.firstChild.innerHTML).toEqual('hello');
			        ReactDOM.render(<div dangerouslySetInnerHTML=\{\{ __html: 'goodbye' \}\} />, container);
			        expect(container.firstChild.innerHTML).toEqual('goodbye');
			      \});
			
			      it('should transition from innerHTML to string content', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<div dangerouslySetInnerHTML=\{\{ __html: 'bonjour' \}\} />, container);
			
			        expect(container.firstChild.innerHTML).toEqual('bonjour');
			        ReactDOM.render(<div>adieu</div>, container);
			        expect(container.firstChild.innerHTML).toEqual('adieu');
			      \});
			
			      it('should transition from innerHTML to children in nested el', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(
			          <div>
			            <div dangerouslySetInnerHTML=\{\{ __html: 'bonjour' \}\} />
			          </div>,
			          container
			        );
			
			        expect(container.textContent).toEqual('bonjour');
			        ReactDOM.render(
			          <div>
			            <div>
			              <span>adieu</span>
			            </div>
			          </div>,
			          container
			        );
			        expect(container.textContent).toEqual('adieu');
			      \});
			
			      it('should transition from children to innerHTML in nested el', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(
			          <div>
			            <div>
			              <span>adieu</span>
			            </div>
			          </div>,
			          container
			        );
			
			        expect(container.textContent).toEqual('adieu');
			        ReactDOM.render(
			          <div>
			            <div dangerouslySetInnerHTML=\{\{ __html: 'bonjour' \}\} />
			          </div>,
			          container
			        );
			        expect(container.textContent).toEqual('bonjour');
			      \});
			
			      it('should ignore attribute whitelist for elements with the "is: attribute', function () \{
			        var container = document.createElement('div');
			        ReactDOM.render(<button is="test" cowabunga="chevynova" />, container);
			        expect(container.firstChild.hasAttribute('cowabunga')).toBe(true);
			      \});
			    \});
			  \});
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactDOMComponent.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(16)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactElement.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			
			describe('ReactElement', function () \{
			  var ComponentClass;
			  var originalSymbol;
			
			  beforeEach(function () \{
			    // Delete the native Symbol if we have one to ensure we test the
			    // unpolyfilled environment.
			    originalSymbol = global.Symbol;
			    global.Symbol = undefined;
			    ComponentClass = React.createClass(\{
			      render: function () \{
			        return React.createElement('div');
			      \}
			    \});
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    global.Symbol = originalSymbol;
			  \});
			
			  // it('uses the fallback value when in an environment without Symbol', function() \{
			  //   expect(<div />.\$\$typeof).toBe(0xeac7);
			  // \});
			
			  it('returns a complete element according to spec', function () \{
			    var element = React.createFactory(ComponentClass)();
			    expect(element.type).toBe(ComponentClass);
			    expect(element.key).toBe(null);
			    expect(element.ref).toBe(null);
			    var expectation = \{\};
			    Object.freeze(expectation);
			    expect(element.props).toEqual(expectation);
			  \});
			
			  it('allows a string to be passed as the type', function () \{
			    var element = React.createFactory('div')();
			    expect(element.type).toBe('div');
			    expect(element.key).toBe(null);
			    expect(element.ref).toBe(null);
			    var expectation = \{\};
			    Object.freeze(expectation);
			    expect(element.props).toEqual(expectation);
			  \});
			
			  // it('returns an immutable element', function() \{
			  //   var element = React.createFactory(ComponentClass)();
			  //   expect(() => element.type = 'div').toThrow();
			  // \});
			
			  it('does not reuse the original config object', function () \{
			    var config = \{ foo: 1 \};
			    var element = React.createFactory(ComponentClass)(config);
			    expect(element.props.foo).toBe(1);
			    config.foo = 2;
			    expect(element.props.foo).toBe(1);
			  \});
			
			  it('coerces the key to a string', function () \{
			    var element = React.createFactory(ComponentClass)(\{
			      key: 12,
			      foo: '56'
			    \});
			    expect(element.type).toBe(ComponentClass);
			    expect(element.key).toBe(12);
			    expect(element.ref).toBe(null);
			    var expectation = \{ foo: '56' \};
			    Object.freeze(expectation);
			    expect(element.props).toEqual(expectation);
			  \});
			
			  // it('preserves the owner on the element', function() \{
			  //   var Component = React.createFactory(ComponentClass);
			  //   var element;
			
			  //   var Wrapper = React.createClass(\{
			  //     render: function() \{
			  //       element = Component();
			  //       return element;
			  //     \},
			  //   \});
			
			  //   var instance = ReactTestUtils.renderIntoDocument(
			  //     React.createElement(Wrapper)
			  //   );
			
			  //   expect(element._owner.getPublicInstance()).toBe(instance);
			  // \});
			
			  it('merges an additional argument onto the children prop', function () \{
			    spyOn(console, 'error');
			    var a = 1;
			    var element = React.createFactory(ComponentClass)(
			      \{
			        children: 'text'
			      \},
			      a
			    );
			    expect(element.props.children).toBe(a);
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  it('does not override children if no rest args are provided', function () \{
			    spyOn(console, 'error');
			    var element = React.createFactory(ComponentClass)(\{
			      children: 'text'
			    \});
			    expect(element.props.children).toBe('text');
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  it('overrides children if null is provided as an argument', function () \{
			    spyOn(console, 'error');
			    var element = React.createFactory(ComponentClass)(
			      \{
			        children: 'text'
			      \},
			      null
			    );
			    expect(element.props.children).toBe(null);
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  it('merges rest arguments onto the children prop in an array', function () \{
			    spyOn(console, 'error');
			    var a = 1;
			    var b = 2;
			    var c = 3;
			    var element = React.createFactory(ComponentClass)(null, a, b, c);
			    expect(element.props.children).toEqual([1, 2, 3]);
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  it('allows static methods to be called using the type property', function () \{
			    spyOn(console, 'error');
			
			    var StaticMethodComponentClass = React.createClass(\{
			      statics: \{
			        someStaticMethod: function () \{
			          return 'someReturnValue';
			        \}
			      \},
			      getInitialState: function () \{
			        return \{ valueToReturn: 'hi' \};
			      \},
			      render: function () \{
			        return React.createElement('div');
			      \}
			    \});
			
			    var element = React.createElement(StaticMethodComponentClass);
			    expect(element.type.someStaticMethod()).toBe('someReturnValue');
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  it('identifies valid elements', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        return React.createElement('div');
			      \}
			    \});
			
			    expect(React.isValidElement(React.createElement('div'))).toEqual(true);
			    expect(React.isValidElement(React.createElement(Component))).toEqual(true);
			
			    expect(React.isValidElement(null)).toEqual(false);
			    expect(React.isValidElement(true)).toEqual(false);
			    expect(React.isValidElement(\{\})).toEqual(false);
			    expect(React.isValidElement('string')).toEqual(false);
			    expect(React.isValidElement(Component)).toEqual(false);
			    expect(React.isValidElement(\{ type: 'div', props: \{\} \})).toEqual(false);
			
			    // var jsonElement = JSON.stringify(React.createElement('div'));
			    // expect(React.isValidElement(JSON.parse(jsonElement))).toBe(true);
			  \});
			
			  it('allows the use of PropTypes validators in statics', function () \{
			    // TODO: This test was added to cover a special case where we proxied
			    // methods. However, we don't do that any more so this test can probably
			    // be removed. Leaving it in classic as a safety precausion.
			    var Component = React.createClass(\{
			      render: () => null,
			      statics: \{
			        specialType: React.PropTypes.shape(\{ monkey: React.PropTypes.any \})
			      \}
			    \});
			
			    expect(typeof Component.specialType).toBe('function');
			    expect(typeof Component.specialType.isRequired).toBe('function');
			  \});
			
			  // it('is indistinguishable from a plain object', function() \{
			  //   var element = React.createElement('div', \{className: 'foo'\});
			  //   var object = \{\};
			  //   expect(element.constructor).toBe(object.constructor);
			  // \});
			
			  it('should use default prop value when removing a prop', function () \{
			    var Component = React.createClass(\{
			      getDefaultProps: function () \{
			        return \{ fruit: 'persimmon' \};
			      \},
			      render: function () \{
			        return React.createElement('span');
			      \}
			    \});
			
			    var container = document.createElement('div');
			    var instance = ReactDOM.render(React.createElement(Component, \{ fruit: 'mango' \}), container);
			    expect(instance.props.fruit).toBe('mango');
			
			    ReactDOM.render(React.createElement(Component), container);
			    expect(instance.props.fruit).toBe('persimmon');
			  \});
			
			  it('should normalize props with default values', function () \{
			    var Component = React.createClass(\{
			      getDefaultProps: function () \{
			        return \{ prop: 'testKey' \};
			      \},
			      render: function () \{
			        return React.createElement('span', null, this.props.prop);
			      \}
			    \});
			
			    var instance = renderIntoDocument(React.createElement(Component));
			    expect(instance.\$LI.children.props.prop).toBe('testKey');
			
			    var inst2 = renderIntoDocument(React.createElement(Component, \{ prop: null \}));
			    expect(inst2.\$LI.children.props.prop).toBe(null);
			  \});
			
			  // it('throws when changing a prop (in dev) after element creation', function() \{
			  //   var Outer = React.createClass(\{
			  //     render: function() \{
			  //       var el = <div className="moo" />;
			
			  //       expect(function() \{
			  //         el.props.className = 'quack';
			  //       \}).toThrow();
			  //       expect(el.props.className).toBe('moo');
			
			  //       return el;
			  //     \},
			  //   \});
			  //   var outer = ReactTestUtils.renderIntoDocument(<Outer color="orange" />);
			  //   expect(ReactDOM.findDOMNode(outer).className).toBe('moo');
			  // \});
			
			  // it('throws when adding a prop (in dev) after element creation', function() \{
			  //   var container = document.createElement('div');
			  //   var Outer = React.createClass(\{
			  //     getDefaultProps: () => (\{sound: 'meow'\}),
			  //     render: function() \{
			  //       var el = <div>\{this.props.sound\}</div>;
			
			  //       expect(function() \{
			  //         el.props.className = 'quack';
			  //       \}).toThrow();
			
			  //       expect(el.props.className).toBe(undefined);
			
			  //       return el;
			  //     \},
			  //   \});
			  //   var outer = ReactDOM.render(<Outer />, container);
			  //   expect(ReactDOM.findDOMNode(outer).textContent).toBe('meow');
			  //   expect(ReactDOM.findDOMNode(outer).className).toBe('');
			  // \});
			
			  it('does not warn for NaN props', function () \{
			    spyOn(console, 'error');
			    var Test = React.createClass(\{
			      render: function () \{
			        return <div />;
			      \}
			    \});
			    var test = renderIntoDocument(<Test value=\{+undefined\} />);
			    expect(test.\$LI.children.props.value).toBeNaN();
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  it('identifies elements, but not JSON, if Symbols are supported', function () \{
			    // Rudimentary polyfill
			    // Once all jest engines support Symbols natively we can swap this to test
			    // WITH native Symbols by default.
			    var REACT_ELEMENT_TYPE = function () \{\}; // fake Symbol
			    var OTHER_SYMBOL = function () \{\}; // another fake Symbol
			    global.Symbol = function (name) \{
			      return OTHER_SYMBOL;
			    \};
			    global.Symbol.for = function (key) \{
			      if (key === 'react.element') \{
			        return REACT_ELEMENT_TYPE;
			      \}
			      return OTHER_SYMBOL;
			    \};
			
			    var Component = React.createClass(\{
			      render: function () \{
			        return React.createElement('div');
			      \}
			    \});
			
			    expect(React.isValidElement(React.createElement('div'))).toEqual(true);
			    expect(React.isValidElement(React.createElement(Component))).toEqual(true);
			
			    expect(React.isValidElement(null)).toEqual(false);
			    expect(React.isValidElement(true)).toEqual(false);
			    expect(React.isValidElement(\{\})).toEqual(false);
			    expect(React.isValidElement('string')).toEqual(false);
			    expect(React.isValidElement(Component)).toEqual(false);
			    expect(React.isValidElement(\{ type: 'div', props: \{\} \})).toEqual(false);
			
			    // var jsonElement = JSON.stringify(React.createElement('div'));
			    // expect(React.isValidElement(JSON.parse(jsonElement))).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactElement.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(15)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactElementClone.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			
			describe('ReactElementClone', function () \{
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should clone a DOM component with new props', function () \{
			    var Grandparent = React.createClass(\{
			      render: function () \{
			        return <Parent child=\{<div className="child" />\} />;
			      \}
			    \});
			    var Parent = React.createClass(\{
			      render: function () \{
			        return <div className="parent">\{React.cloneElement(this.props.child, \{ className: 'xyz' \})\}</div>;
			      \}
			    \});
			    var component = renderIntoDocument(<Grandparent />);
			    expect(ReactDOM.findDOMNode(component).childNodes[0].className).toBe('xyz');
			  \});
			
			  it('should clone a composite component with new props', function () \{
			    var Child = React.createClass(\{
			      render: function () \{
			        return <div className=\{this.props.className\} />;
			      \}
			    \});
			    var Grandparent = React.createClass(\{
			      render: function () \{
			        return <Parent child=\{<Child className="child" />\} />;
			      \}
			    \});
			    var Parent = React.createClass(\{
			      render: function () \{
			        return <div className="parent">\{React.cloneElement(this.props.child, \{ className: 'xyz' \})\}</div>;
			      \}
			    \});
			    var component = renderIntoDocument(<Grandparent />);
			    expect(ReactDOM.findDOMNode(component).childNodes[0].className).toBe('xyz');
			  \});
			
			  it('should transfer the key property', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        return null;
			      \}
			    \});
			    var clone = React.cloneElement(<Component />, \{ key: 'xyz' \});
			    expect(clone.key).toBe('xyz');
			  \});
			
			  it('should transfer children', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        expect(this.props.children).toBe('xyz');
			        return <div />;
			      \}
			    \});
			
			    renderIntoDocument(React.cloneElement(<Component />, \{ children: 'xyz' \}));
			  \});
			
			  it('should shallow clone children', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        expect(this.props.children).toBe('xyz');
			        return <div />;
			      \}
			    \});
			
			    renderIntoDocument(React.cloneElement(<Component>xyz</Component>, \{\}));
			  \});
			
			  it('should accept children as rest arguments', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        return null;
			      \}
			    \});
			
			    var clone = React.cloneElement(<Component>xyz</Component>, \{ children: <Component /> \}, <div />, <span />);
			
			    expect(clone.props.children).toEqual([<div />, <span />]);
			  \});
			
			  // it('should support keys and refs', function() \{
			  //   var Parent = React.createClass(\{
			  //     render: function() \{
			  //       var clone =
			  //         React.cloneElement(this.props.children, \{key: 'xyz', ref: 'xyz'\});
			  //       expect(clone.key).toBe('xyz');
			  //       // expect(clone.ref).toBe('xyz');
			  //       expect(typeof clone.ref).toBe('function'); // Inferno-compat transform string ref into function ref
			  //       return <div>\{clone\}</div>;
			  //     \},
			  //   \});
			  //
			  //   var Grandparent = React.createClass(\{
			  //     render: function() \{
			  //       return <Parent ref="parent"><span key="abc" /></Parent>;
			  //     \},
			  //   \});
			  //
			  //   var component = ReactTestUtils.renderIntoDocument(<Grandparent />);
			  //   expect(component.refs.parent.refs.xyz.tagName).toBe('SPAN');
			  // \});
			
			  // it('should steal the ref if a new ref is specified', function() \{
			  //   var Parent = React.createClass(\{
			  //     render: function() \{
			  //       var clone = React.cloneElement(this.props.children, \{ref: 'xyz'\});
			  //       return <div>\{clone\}</div>;
			  //     \},
			  //   \});
			  //
			  //   var Grandparent = React.createClass(\{
			  //     render: function() \{
			  //       return <Parent ref="parent"><span ref="child" /></Parent>;
			  //     \},
			  //   \});
			  //
			  //   var component = ReactTestUtils.renderIntoDocument(<Grandparent />);
			  //   expect(component.refs.child).toBeUndefined();
			  //   expect(component.refs.parent.refs.xyz.tagName).toBe('SPAN');
			  // \});
			
			  it('should overwrite props', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        expect(this.props.myprop).toBe('xyz');
			        return <div />;
			      \}
			    \});
			
			    renderIntoDocument(React.cloneElement(<Component myprop="abc" />, \{ myprop: 'xyz' \}));
			  \});
			
			  // it('warns for keys for arrays of elements in rest args', function() \{
			  //   spyOn(console, 'error');
			
			  //   React.cloneElement(<div />, null, [<div />, <div />]);
			
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toContain(
			  //     'Each child in an array or iterator should have a unique "key" prop.'
			  //   );
			  // \});
			
			  // it('does not warns for arrays of elements with keys', function() \{
			  //   spyOn(console, 'error');
			
			  //   React.cloneElement(<div />, null, [<div key="#1" />, <div key="#2" />]);
			
			  //   expect(console.error.calls.count()).toBe(0);
			  // \});
			
			  // it('does not warn when the element is directly in rest args', function() \{
			  //   spyOn(console, 'error');
			
			  //   React.cloneElement(<div />, null, <div />, <div />);
			
			  //   expect(console.error.calls.count()).toBe(0);
			  // \});
			
			  // it('does not warn when the array contains a non-element', function() \{
			  //   spyOn(console, 'error');
			
			  //   React.cloneElement(<div />, null, [\{\}, \{\}]);
			
			  //   expect(console.error.calls.count()).toBe(0);
			  // \});
			
			  // it('should check declared prop types after clone', function() \{
			  //   spyOn(console, 'error');
			  //   var Component = React.createClass(\{
			  //     propTypes: \{
			  //       color: React.PropTypes.string.isRequired,
			  //     \},
			  //     render: function() \{
			  //       return React.createElement('div', null, 'My color is ' + this.color);
			  //     \},
			  //   \});
			  //   var Parent = React.createClass(\{
			  //     render: function() \{
			  //       return React.cloneElement(this.props.child, \{color: 123\});
			  //     \},
			  //   \});
			  //   var GrandParent = React.createClass(\{
			  //     render: function() \{
			  //       return React.createElement(
			  //         Parent,
			  //         \{ child: React.createElement(Component, \{color: 'red'\}) \}
			  //       );
			  //     \},
			  //   \});
			  //   ReactTestUtils.renderIntoDocument(React.createElement(GrandParent));
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.calls[0].calls.argsFor(0)).toBe(
			  //     'Warning: Failed propType: ' +
			  //     'Invalid prop \`color\` of type \`number\` supplied to \`Component\`, ' +
			  //     'expected \`string\`. Check the render method of \`Parent\`.'
			  //   );
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactElementClone.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactES6Class.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			
			describe('ReactES6Class', function () \{
			  var container;
			  var freeze = function (expectation) \{
			    Object.freeze(expectation);
			    return expectation;
			  \};
			  var Inner;
			  var attachedListener = null;
			  var renderedName = null;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    attachedListener = null;
			    renderedName = null;
			    Inner = class extends React.Component \{
			      getName() \{
			        return this.props.name;
			      \}
			      render() \{
			        attachedListener = this.props.onClick;
			        renderedName = this.props.name;
			        return <div className=\{this.props.name\} />;
			      \}
			    \};
			  \});
			
			  function test(element, expectedTag, expectedClassName) \{
			    var instance = ReactDOM.render(element, container);
			    expect(container.firstChild).not.toBeNull();
			    expect(container.firstChild.tagName).toBe(expectedTag);
			    expect(container.firstChild.className).toBe(expectedClassName);
			    return instance;
			  \}
			
			  it('renders a simple stateless component with prop', function () \{
			    class Foo extends React.Component \{
			      render() \{
			        return <Inner name=\{this.props.bar\} />;
			      \}
			    \}
			    test(<Foo bar="foo" />, 'DIV', 'foo');
			    test(<Foo bar="bar" />, 'DIV', 'bar');
			  \});
			
			  it('renders based on state using initial values in this.props', function () \{
			    class Foo extends React.Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ bar: this.props.initialValue \};
			      \}
			      render() \{
			        return <span className=\{this.state.bar\} />;
			      \}
			    \}
			    test(<Foo initialValue="foo" />, 'SPAN', 'foo');
			  \});
			
			  it('renders based on state using props in the constructor', function () \{
			    class Foo extends React.Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ bar: props.initialValue \};
			      \}
			      changeState() \{
			        this.setState(\{ bar: 'bar' \});
			      \}
			      render() \{
			        if (this.state.bar === 'foo') \{
			          return <div className="foo" />;
			        \}
			        return <span className=\{this.state.bar\} />;
			      \}
			    \}
			    var instance = test(<Foo initialValue="foo" />, 'DIV', 'foo');
			    instance.changeState();
			    test(<Foo />, 'SPAN', 'bar');
			  \});
			
			  it('renders based on context in the constructor', function () \{
			    class Foo extends React.Component \{
			      constructor(props, context) \{
			        super(props, context);
			
			        this.state = \{ tag: context.tag, className: this.context.className \};
			      \}
			      render() \{
			        var Tag = this.state.tag;
			        return <Tag className=\{this.state.className\} />;
			      \}
			    \}
			    Foo.contextTypes = \{
			      tag: React.PropTypes.string,
			      className: React.PropTypes.string
			    \};
			
			    class Outer extends React.Component \{
			      getChildContext() \{
			        return \{ tag: 'span', className: 'foo' \};
			      \}
			      render() \{
			        return <Foo />;
			      \}
			    \}
			    Outer.childContextTypes = \{
			      tag: React.PropTypes.string,
			      className: React.PropTypes.string
			    \};
			    test(<Outer />, 'SPAN', 'foo');
			  \});
			
			  it('renders only once when setting state in componentWillMount', function () \{
			    var renderCount = 0;
			    class Foo extends React.Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ bar: props.initialValue \};
			      \}
			      componentWillMount() \{
			        this.setState(\{ bar: 'bar' \});
			      \}
			      render() \{
			        renderCount++;
			        return <span className=\{this.state.bar\} />;
			      \}
			    \}
			    test(<Foo initialValue="foo" />, 'SPAN', 'bar');
			    expect(renderCount).toBe(1);
			  \});
			
			  // it('should throw with non-object in the initial state property', function() \{
			  //   [['an array'], 'a string', 1234].forEach(function(state) \{
			  //     class Foo extends React.Component \{
			  //       constructor() \{
			  //         super();
			  //         this.state = state;
			  //       \}
			  //       render() \{
			  //         return <span />;
			  //       \}
			  //     \}
			  //     expect(() => test(<Foo />, 'span', '')).toThrow();
			  //   \});
			  // \});
			
			  it('should render with null in the initial state property', function () \{
			    class Foo extends React.Component \{
			      constructor() \{
			        super();
			        this.state = null;
			      \}
			      render() \{
			        return <span />;
			      \}
			    \}
			    test(<Foo />, 'SPAN', '');
			  \});
			
			  it('setState through an event handler', function () \{
			    class Foo extends React.Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ bar: props.initialValue \};
			      \}
			      handleClick() \{
			        this.setState(\{ bar: 'bar' \});
			      \}
			      render() \{
			        return <Inner name=\{this.state.bar\} onClick=\{this.handleClick.bind(this)\} />;
			      \}
			    \}
			    test(<Foo initialValue="foo" />, 'DIV', 'foo');
			    attachedListener();
			    expect(renderedName).toBe('bar');
			  \});
			
			  it('should not implicitly bind event handlers', function () \{
			    class Foo extends React.Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ bar: props.initialValue \};
			      \}
			      handleClick() \{
			        this.setState(\{ bar: 'bar' \});
			      \}
			      render() \{
			        return <Inner name=\{this.state.bar\} onClick=\{this.handleClick\} />;
			      \}
			    \}
			    test(<Foo initialValue="foo" />, 'DIV', 'foo');
			    expect(attachedListener).toThrow();
			  \});
			
			  it('renders using forceUpdate even when there is no state', function () \{
			    class Foo extends React.Component \{
			      constructor(props) \{
			        super(props);
			        this.mutativeValue = props.initialValue;
			      \}
			      handleClick() \{
			        this.mutativeValue = 'bar';
			        this.forceUpdate();
			      \}
			      render() \{
			        return <Inner name=\{this.mutativeValue\} onClick=\{this.handleClick.bind(this)\} />;
			      \}
			    \}
			    test(<Foo initialValue="foo" />, 'DIV', 'foo');
			    attachedListener();
			    expect(renderedName).toBe('bar');
			  \});
			
			  it('will call all the normal life cycle methods', function () \{
			    var lifeCycles = [];
			    class Foo extends React.Component \{
			      constructor() \{
			        super();
			        this.state = \{\};
			      \}
			      componentWillMount() \{
			        lifeCycles.push('will-mount');
			      \}
			      componentDidMount() \{
			        lifeCycles.push('did-mount');
			      \}
			      componentWillReceiveProps(nextProps) \{
			        lifeCycles.push('receive-props', nextProps);
			      \}
			      shouldComponentUpdate(nextProps, nextState) \{
			        lifeCycles.push('should-update', nextProps, nextState);
			        return true;
			      \}
			      componentWillUpdate(nextProps, nextState) \{
			        lifeCycles.push('will-update', nextProps, nextState);
			      \}
			      componentDidUpdate(prevProps, prevState) \{
			        lifeCycles.push('did-update', prevProps, prevState);
			      \}
			      componentWillUnmount() \{
			        lifeCycles.push('will-unmount');
			      \}
			      render() \{
			        return <span className=\{this.props.value\} />;
			      \}
			    \}
			    test(<Foo value="foo" />, 'SPAN', 'foo');
			    expect(lifeCycles).toEqual(['will-mount', 'did-mount']);
			    lifeCycles = []; // reset
			    test(<Foo value="bar" />, 'SPAN', 'bar');
			    expect(lifeCycles).toEqual([
			      'receive-props',
			      freeze(\{ value: 'bar' \}),
			      'should-update',
			      freeze(\{ value: 'bar' \}),
			      \{\},
			      'will-update',
			      freeze(\{ value: 'bar' \}),
			      \{\},
			      'did-update',
			      freeze(\{ value: 'foo' \}),
			      \{\}
			    ]);
			    lifeCycles = []; // reset
			    ReactDOM.unmountComponentAtNode(container);
			    expect(lifeCycles).toEqual(['will-unmount']);
			  \});
			
			  it('warns when classic properties are defined on the instance, but does not invoke them.', function () \{
			    spyOn(console, 'error');
			    var getDefaultPropsWasCalled = false;
			    var getInitialStateWasCalled = false;
			    class Foo extends React.Component \{
			      constructor() \{
			        super();
			        this.contextTypes = \{\};
			        this.propTypes = \{\};
			      \}
			      getInitialState() \{
			        getInitialStateWasCalled = true;
			        return \{\};
			      \}
			      getDefaultProps() \{
			        getDefaultPropsWasCalled = true;
			        return \{\};
			      \}
			      render() \{
			        return <span className="foo" />;
			      \}
			    \}
			    test(<Foo />, 'SPAN', 'foo');
			    expect(getInitialStateWasCalled).toBe(false);
			    expect(getDefaultPropsWasCalled).toBe(false);
			    // expect(console.error.calls.count()).toBe(4);
			    // expect(console.error.calls[0].calls.argsFor(0)[0]).toContain(
			    //   'getInitialState was defined on Foo, a plain JavaScript class.'
			    // );
			    // expect(console.error.calls[1].calls.argsFor(0)[0]).toContain(
			    //   'getDefaultProps was defined on Foo, a plain JavaScript class.'
			    // );
			    // expect(console.error.calls[2].calls.argsFor(0)[0]).toContain(
			    //   'propTypes was defined as an instance property on Foo.'
			    // );
			    // expect(console.error.calls[3].calls.argsFor(0)[0]).toContain(
			    //   'contextTypes was defined as an instance property on Foo.'
			    // );
			  \});
			
			  // it('should warn when misspelling shouldComponentUpdate', function() \{
			  //   spyOn(console, 'error');
			
			  //   class NamedComponent extends React.Component \{
			  //     componentShouldUpdate() \{
			  //       return false;
			  //     \}
			  //     render() \{
			  //       return <span className="foo" />;
			  //     \}
			  //   \}
			  //   test(<NamedComponent />, 'SPAN', 'foo');
			
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.calls[0].calls.argsFor(0)).toBe(
			  //     'Warning: ' +
			  //     'NamedComponent has a method called componentShouldUpdate(). Did you ' +
			  //     'mean shouldComponentUpdate()? The name is phrased as a question ' +
			  //     'because the function is expected to return a value.'
			  //   );
			  // \});
			
			  // it('should warn when misspelling componentWillReceiveProps', function() \{
			  //   spyOn(console, 'error');
			
			  //   class NamedComponent extends React.Component \{
			  //     componentWillRecieveProps() \{
			  //       return false;
			  //     \}
			  //     render() \{
			  //       return <span className="foo" />;
			  //     \}
			  //   \}
			  //   test(<NamedComponent />, 'SPAN', 'foo');
			
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.calls[0].calls.argsFor(0)).toBe(
			  //     'Warning: ' +
			  //     'NamedComponent has a method called componentWillRecieveProps(). Did ' +
			  //     'you mean componentWillReceiveProps()?'
			  //   );
			  // \});
			
			  // it('should throw AND warn when trying to access classic APIs', function() \{
			  //   spyOn(console, 'error');
			  //   var instance = test(<Inner name="foo" />, 'DIV', 'foo');
			  //   expect(() => instance.getDOMNode()).toThrow();
			  //   expect(() => instance.replaceState(\{\})).toThrow();
			  //   expect(() => instance.isMounted()).toThrow();
			  //   expect(() => instance.setProps(\{name: 'bar'\})).toThrow();
			  //   expect(() => instance.replaceProps(\{name: 'bar'\})).toThrow();
			  //   expect(console.error.calls.count()).toBe(5);
			  //   expect(console.error.calls[0].calls.argsFor(0)[0]).toContain(
			  //     'getDOMNode(...) is deprecated in plain JavaScript React classes. ' +
			  //     'Use ReactDOM.findDOMNode(component) instead.'
			  //   );
			  //   expect(console.error.calls[1].calls.argsFor(0)[0]).toContain(
			  //     'replaceState(...) is deprecated in plain JavaScript React classes'
			  //   );
			  //   expect(console.error.calls[2].calls.argsFor(0)[0]).toContain(
			  //     'isMounted(...) is deprecated in plain JavaScript React classes'
			  //   );
			  //   expect(console.error.calls[3].calls.argsFor(0)[0]).toContain(
			  //     'setProps(...) is deprecated in plain JavaScript React classes'
			  //   );
			  //   expect(console.error.calls[4].calls.argsFor(0)[0]).toContain(
			  //     'replaceProps(...) is deprecated in plain JavaScript React classes'
			  //   );
			  // \});
			
			  it('supports this.context passed via getChildContext', function () \{
			    class Bar extends React.Component \{
			      render() \{
			        return <div className=\{this.context.bar\} />;
			      \}
			    \}
			    Bar.contextTypes = \{ bar: React.PropTypes.string \};
			    class Foo extends React.Component \{
			      getChildContext() \{
			        return \{ bar: 'bar-through-context' \};
			      \}
			      render() \{
			        return <Bar />;
			      \}
			    \}
			    Foo.childContextTypes = \{ bar: React.PropTypes.string \};
			    test(<Foo />, 'DIV', 'bar-through-context');
			  \});
			
			  it('supports drilling through to the DOM using findDOMNode', function () \{
			    var instance = test(<Inner name="foo" />, 'DIV', 'foo');
			    var node = ReactDOM.findDOMNode(instance);
			    expect(node).toBe(container.firstChild);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactES6Class.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(29)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactJSXElement.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ triggerEvent \} from 'inferno-utils';
			
			var ReactDOM = React;
			
			describe('ReactJSXElement', function () \{
			  class Component extends React.Component \{
			    render() \{
			      return <div />;
			    \}
			  \}
			
			  it('returns a complete element according to spec', function () \{
			    var element = <Component />;
			    expect(element.type).toBe(Component);
			    expect(element.key).toBe(null);
			    expect(element.ref).toBe(null);
			    var expectation = \{\};
			    Object.freeze(expectation);
			    expect(element.props).toEqual(expectation);
			  \});
			
			  it('allows a lower-case to be passed as the string type', function () \{
			    var element = <div />;
			    expect(element.type).toBe('div');
			    expect(element.key).toBe(null);
			    expect(element.ref).toBe(null);
			    var expectation = \{\};
			    Object.freeze(expectation);
			    expect(element.props).toEqual(expectation);
			  \});
			
			  it('allows a string to be passed as the type', function () \{
			    var TagName = 'div';
			    var element = <TagName />;
			    expect(element.type).toBe('div');
			    expect(element.key).toBe(null);
			    expect(element.ref).toBe(null);
			    var expectation = \{\};
			    Object.freeze(expectation);
			    expect(element.props).toEqual(expectation);
			  \});
			
			  // it('returns an immutable element', function() \{
			  //   var element = <Component />;
			  //   expect(() => element.type = 'div').toThrow();
			  // \});
			
			  it('does not reuse the object that is spread into props', function () \{
			    var config = \{ foo: 1 \};
			    var element = <Component \{...config\} />;
			    expect(element.props.foo).toBe(1);
			    config.foo = 2;
			    expect(element.props.foo).toBe(1);
			  \});
			
			  // it('extracts key and ref from the rest of the props', function() \{
			  //   var element = <Component key="12" ref="34" foo="56" />;
			  //   expect(element.type).toBe(Component);
			  //   expect(element.key).toBe('12');
			  //   expect(element.ref).toBe('34');
			  //   var expectation = \{foo:'56'\};
			  //   Object.freeze(expectation);
			  //   expect(element.props).toEqual(expectation);
			  // \});
			
			  // it('coerces the key to a string', function() \{
			  //   var element = <Component key=\{12\} foo="56" />;
			  //   expect(element.type).toBe(Component);
			  //   expect(element.key).toBe('12');
			  //   expect(element.ref).toBe(null);
			  //   var expectation = \{foo:'56'\};
			  //   Object.freeze(expectation);
			  //   expect(element.props).toEqual(expectation);
			  // \});
			
			  // it('merges JSX children onto the children prop', function() \{
			  //   spyOn(console, 'error');
			  //   var a = 1;
			  //   var element = <Component children="text">\{a\}</Component>;
			  //   expect(element.props.children).toBe(a);
			  //   expect(console.error.calls.count()).toBe(0);
			  // \});
			
			  it('does not override children if no JSX children are provided', function () \{
			    spyOn(console, 'error');
			    var element = <Component children="text" />;
			    expect(element.props.children).toBe('text');
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  // it('overrides children if null is provided as a JSX child', function() \{
			  //   spyOn(console, 'error');
			  //   var element = <Component children="text">\{null\}</Component>;
			  //   expect(element.props.children).toBe(null);
			  //   expect(console.error.calls.count()).toBe(0);
			  // \});
			
			  // it('merges JSX children onto the children prop in an array', function() \{
			  //   spyOn(console, 'error');
			  //   var a = 1;
			  //   var b = 2;
			  //   var c = 3;
			  //   var element = <Component>\{a\}\{b\}\{c\}</Component>;
			  //   expect(element.props.children).toEqual([1, 2, 3]);
			  //   expect(console.error.calls.count()).toBe(0);
			  // \});
			
			  it('allows static methods to be called using the type property', function () \{
			    spyOn(console, 'error');
			
			    class StaticMethodComponent \{
			      static someStaticMethod() \{
			        return 'someReturnValue';
			      \}
			      render() \{
			        return <div />;
			      \}
			    \}
			
			    var element = <StaticMethodComponent />;
			    expect(element.type.someStaticMethod()).toBe('someReturnValue');
			    expect(console.error.calls.count()).toBe(0);
			  \});
			
			  it('identifies valid elements', function () \{
			    expect(React.isValidElement(<div />)).toEqual(true);
			    expect(React.isValidElement(<Component />)).toEqual(true);
			
			    expect(React.isValidElement(null)).toEqual(false);
			    expect(React.isValidElement(true)).toEqual(false);
			    expect(React.isValidElement(\{\})).toEqual(false);
			    expect(React.isValidElement('string')).toEqual(false);
			    expect(React.isValidElement(Component)).toEqual(false);
			    expect(React.isValidElement(\{ type: 'div', props: \{\} \})).toEqual(false);
			  \});
			
			  // it('is indistinguishable from a plain object', function() \{
			  //   var element = <div className="foo" />;
			  //   var object = \{\};
			  //   expect(element.constructor).toBe(object.constructor);
			  // \});
			
			  it('should use default prop value when removing a prop', function () \{
			    Component.defaultProps = \{ fruit: 'persimmon' \};
			
			    var container = document.createElement('div');
			    var instance = ReactDOM.render(<Component fruit="mango" />, container);
			    expect(instance.props.fruit).toBe('mango');
			
			    ReactDOM.render(<Component />, container);
			    expect(instance.props.fruit).toBe('persimmon');
			  \});
			
			  // it('should normalize props with default values', function() \{
			  //   class NormalizingComponent extends React.Component \{
			  //     render() \{
			  //       return <span>\{this.props.prop\}</span>;
			  //     \}
			  //   \}
			  //   NormalizingComponent.defaultProps = \{prop: 'testKey'\};
			  //
			  //   var instance = ReactTestUtils.renderIntoDocument(<NormalizingComponent />);
			  //   expect(instance.props.prop).toBe('testKey');
			  //
			  //   var inst2 =
			  //     ReactTestUtils.renderIntoDocument(<NormalizingComponent prop=\{null\} />);
			  //   expect(inst2.props.prop).toBe(null);
			  // \});
			
			  it('Should map onDoubleClick to html native event', () => \{
			    const container = document.createElement('div');
			    document.body.appendChild(container);
			    const spy = jasmine.createSpy('spy');
			    ReactDOM.render(React.createElement('a', \{ onDoubleClick: spy \}, 'test'), container);
			
			    expect(spy.calls.count()).toBe(0);
			    const element = container.querySelector('a');
			    triggerEvent('dblclick', element);
			    expect(spy.calls.count()).toBe(1);
			
			    document.body.removeChild(container);
			  \});
			
			  it('Should map onDoubleClick to html native even (jsx)t', () => \{
			    const container = document.createElement('div');
			    document.body.appendChild(container);
			    const spy = jasmine.createSpy('spy');
			    const node = <a onDoubleClick=\{spy\} />;
			    expect(node.props.onDblClick).toEqual(spy);
			    ReactDOM.render(node, container);
			
			    expect(spy.calls.count()).toBe(0);
			    const element = container.querySelector('a');
			    triggerEvent('dblclick', element);
			    expect(spy.calls.count()).toBe(1);
			
			    document.body.removeChild(container);
			  \});
			
			  it('Should have input onChange event', () => \{
			    const container = document.createElement('div');
			    document.body.appendChild(container);
			    const spy = jasmine.createSpy('spy');
			    ReactDOM.render(React.createElement('input', \{ onChange: spy \}), container);
			
			    expect(spy.calls.count()).toBe(0);
			    const element = container.querySelector('input');
			    element.value = 'test';
			    triggerEvent('input', element);
			    expect(spy.calls.count()).toBe(1);
			
			    document.body.removeChild(container);
			  \});
			
			  it('Should have input onChange event (JSX)', () => \{
			    const container = document.createElement('div');
			    document.body.appendChild(container);
			    const spy = jasmine.createSpy('spy');
			    ReactDOM.render(<input onChange=\{spy\} />, container);
			
			    expect(spy.calls.count()).toBe(0);
			    const element = container.querySelector('input');
			    element.value = 'test';
			    triggerEvent('input', element);
			    expect(spy.calls.count()).toBe(1);
			
			    document.body.removeChild(container);
			  \});
			
			  it('Should map onDoubleClick to html native event #1', () => \{
			    const container = document.createElement('div');
			
			    ReactDOM.render(React.createElement('label', \{ htmlFor: 'foobarID' \}, 'test'), container);
			
			    const element = container.querySelector('label');
			    expect(element.getAttribute('for')).toBe('foobarID');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactJSXElement.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(13)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactMount.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			'use strict';
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			var mocks = \{
			  getMockFunction: function () \{
			    return jasmine.createSpy();
			  \}
			\};
			
			describe('ReactMount', function () \{
			  var ReactMount = React;
			  var WebComponents;
			
			  try \{
			    if (WebComponents === undefined && typeof jest !== 'undefined') \{
			      //WebComponents = require('WebComponents');
			    \}
			  \} catch (e) \{
			    // Parse error expected on engines that don't support setters
			    // or otherwise aren't supportable by the polyfill.
			    // Leave WebComponents undefined.
			  \}
			
			  it('throws when given a factory', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        return <div />;
			      \}
			    \});
			    expect(function () \{
			      React.render(Component, document.createElement('div'));
			    \}).toThrow();
			  \});
			
			  it('should render different components in same root', function () \{
			    var container = document.createElement('container');
			    document.body.appendChild(container);
			
			    ReactMount.render(<div />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			
			    ReactMount.render(<span />, container);
			    expect(container.firstChild.nodeName).toBe('SPAN');
			    document.body.removeChild(container);
			  \});
			
			  it('should unmount and remount if the key changes', function () \{
			    var container = document.createElement('container');
			
			    var mockMount = mocks.getMockFunction();
			    var mockUnmount = mocks.getMockFunction();
			
			    var Component = React.createClass(\{
			      componentDidMount: mockMount,
			      componentWillUnmount: mockUnmount,
			      render: function () \{
			        return <span>\{this.props.text\}</span>;
			      \}
			    \});
			
			    expect(mockMount.calls.count()).toBe(0);
			    expect(mockUnmount.calls.count()).toBe(0);
			
			    ReactMount.render(<Component text="orange" key="A" />, container);
			    expect(container.firstChild.innerHTML).toBe('orange');
			    expect(mockMount.calls.count()).toBe(1);
			    expect(mockUnmount.calls.count()).toBe(0);
			
			    // If we change the key, the component is unmounted and remounted
			    ReactMount.render(<Component text="green" key="B" />, container);
			    expect(container.firstChild.innerHTML).toBe('green');
			    expect(mockMount.calls.count()).toBe(2);
			    expect(mockUnmount.calls.count()).toBe(1);
			
			    // But if we don't change the key, the component instance is reused
			    ReactMount.render(<Component text="blue" key="B" />, container);
			    expect(container.firstChild.innerHTML).toBe('blue');
			    expect(mockMount.calls.count()).toBe(2);
			    expect(mockUnmount.calls.count()).toBe(1);
			  \});
			
			  it('should reuse markup if rendering to the same target twice', function () \{
			    var container = document.createElement('container');
			    var instance1 = ReactDOM.render(<div />, container);
			    var instance2 = ReactDOM.render(<div />, container);
			
			    expect(instance1 === instance2).toBe(true);
			  \});
			
			  // it('should warn if mounting into dirty rendered markup', function() \{
			  //   var container = document.createElement('container');
			  //   container.innerHTML = ReactDOMServer.renderToString(<div />) + ' ';
			
			  //   spyOn(console, 'error');
			  //   ReactMount.render(<div />, container);
			  //   expect(console.error.calls.count()).toBe(1);
			
			  //   container.innerHTML = ' ' + ReactDOMServer.renderToString(<div />);
			
			  //   ReactMount.render(<div />, container);
			  //   expect(console.error.calls.count()).toBe(2);
			  // \});
			
			  // it('should warn when mounting into document.body', function() \{
			  //   var iFrame = document.createElement('iframe');
			  //   document.body.appendChild(iFrame);
			  //   spyOn(console, 'error');
			
			  //   ReactMount.render(<div />, iFrame.contentDocument.body);
			
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.calls[0].calls.argsFor(0)[0]).toContain(
			  //     'Rendering components directly into document.body is discouraged'
			  //   );
			  // \});
			
			  // it('should account for escaping on a checksum mismatch', function() \{
			  //   var div = document.createElement('div');
			  //   var markup = ReactDOMServer.renderToString(
			  //     <div>This markup contains an nbsp entity: &nbsp; server text</div>);
			  //   div.innerHTML = markup;
			
			  //   spyOn(console, 'error');
			  //   ReactDOM.render(
			  //     <div>This markup contains an nbsp entity: &nbsp; client text</div>,
			  //     div
			  //   );
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.calls[0].calls.argsFor(0)[0]).toContain(
			  //     ' (client) nbsp entity: &nbsp; client text</div>\\n' +
			  //     ' (server) nbsp entity: &nbsp; server text</div>'
			  //   );
			  // \});
			
			  if (WebComponents !== undefined) \{
			    it('should allow mounting/unmounting to document fragment container', function () \{
			      var shadowRoot;
			      var proto = Object.create(HTMLElement.prototype, \{
			        createdCallback: \{
			          value: function () \{
			            shadowRoot = this.createShadowRoot();
			            ReactDOM.render(<div>Hi, from within a WC!</div>, shadowRoot);
			            expect(shadowRoot.firstChild.tagName).toBe('DIV');
			            ReactDOM.render(<span>Hi, from within a WC!</span>, shadowRoot);
			            expect(shadowRoot.firstChild.tagName).toBe('SPAN');
			          \}
			        \}
			      \});
			      proto.unmount = function () \{
			        ReactDOM.unmountComponentAtNode(shadowRoot);
			      \};
			      document.registerElement('x-foo', \{ prototype: proto \});
			      var element = document.createElement('x-foo');
			      element.unmount();
			    \});
			  \}
			
			  // it('warns when using two copies of React before throwing', function() \{
			  //   require('mock-modules').dumpCache();
			  //   var RD1 = require('ReactDOM');
			  //   require('mock-modules').dumpCache();
			  //   var RD2 = require('ReactDOM');
			
			  //   var X = React.createClass(\{
			  //     render: function() \{
			  //       return <div />;
			  //     \},
			  //   \});
			
			  //   var container = document.createElement('div');
			  //   spyOn(console, 'error');
			  //   var component = RD1.render(<X />, container);
			  //   expect(console.error.calls.count()).toBe(0);
			
			  //   // This fails but logs a warning first
			  //   expect(function() \{
			  //     RD2.findDOMNode(component);
			  //   \}).toThrow();
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toContain('two copies of React');
			  // \});
			
			  // it('should warn if render removes React-rendered children', function() \{
			  //   var container = document.createElement('container');
			  //   var Component = React.createClass(\{
			  //     render: function() \{
			  //       return <div><div /></div>;
			  //     \},
			  //   \});
			  //   ReactDOM.render(<Component />, container);
			
			  //   // Test that blasting away children throws a warning
			  //   spyOn(console, 'error');
			  //   var rootNode = container.firstChild;
			  //   ReactDOM.render(<span />, rootNode);
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.mostRecentCall.calls.argsFor(0)).toBe(
			  //     'Warning: render(...): Replacing React-rendered children with a new ' +
			  //     'root component. If you intended to update the children of this node, ' +
			  //     'you should instead have the existing children update their state and ' +
			  //     'render the new components instead of calling ReactDOM.render.'
			  //   );
			  // \});
			
			  it('should not crash in node cache when unmounting', function () \{
			    var Component = React.createClass(\{
			      render: function () \{
			        // Add refs to some nodes so that they get traversed and cached
			        return (
			          <div>
			            <div>b</div>
			            \{this.props.showC && <div>c</div>\}
			          </div>
			        );
			      \}
			    \});
			
			    var container = document.createElement('container');
			
			    ReactDOM.render(
			      <div>
			        <Component showC=\{false\} />
			      </div>,
			      container
			    );
			
			    // Right now, A and B are in the cache. When we add C, it won't get added to
			    // the cache (assuming markup-string mode).
			    ReactDOM.render(
			      <div>
			        <Component showC=\{true\} />
			      </div>,
			      container
			    );
			
			    // Remove A, B, and C. Unmounting C shouldn't cause B to get recached.
			    ReactDOM.render(<div />, container);
			
			    // Add them back -- this shouldn't cause a cached node collision.
			    ReactDOM.render(
			      <div>
			        <Component showC=\{true\} />
			      </div>,
			      container
			    );
			
			    ReactDOM.unmountComponentAtNode(container);
			  \});
			
			  it('should not crash in node cache when unmounting, case 2', function () \{
			    var A = React.createClass(\{
			      render: function () \{
			        return <a key=\{this.props.innerKey\}>\{this.props.innerKey\}</a>;
			      \}
			    \});
			    var Component = React.createClass(\{
			      render: function () \{
			        return (
			          <b>
			            <i>\{this.props.step === 1 && <q />\}</i>
			            \{this.props.step === 1 && <A innerKey=\{this.props.step\} />\}
			          </b>
			        );
			      \}
			    \});
			
			    var container = document.createElement('container');
			
			    ReactDOM.render(<Component step=\{1\} />, container);
			    ReactDOM.render(<Component step=\{2\} />, container);
			    ReactDOM.render(<Component step=\{1\} />, container);
			    //ReactMount.getID(container.querySelector('a'));
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactMount.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactMountDestruction.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			
			describe('ReactMount', function () \{
			  it('should destroy a react root upon request', function () \{
			    var mainContainerDiv = document.createElement('div');
			    document.body.appendChild(mainContainerDiv);
			
			    var instanceOne = <div className="firstReactDiv" />;
			    var firstRootDiv = document.createElement('div');
			    mainContainerDiv.appendChild(firstRootDiv);
			    ReactDOM.render(instanceOne, firstRootDiv);
			
			    var instanceTwo = <div className="secondReactDiv" />;
			    var secondRootDiv = document.createElement('div');
			    mainContainerDiv.appendChild(secondRootDiv);
			    ReactDOM.render(instanceTwo, secondRootDiv);
			
			    // Test that two react roots are rendered in isolation
			    expect(firstRootDiv.firstChild.className).toBe('firstReactDiv');
			    expect(secondRootDiv.firstChild.className).toBe('secondReactDiv');
			
			    // Test that after unmounting each, they are no longer in the document.
			    ReactDOM.unmountComponentAtNode(firstRootDiv);
			    expect(firstRootDiv.firstChild).toBeNull();
			    ReactDOM.unmountComponentAtNode(secondRootDiv);
			    expect(secondRootDiv.firstChild).toBeNull();
			    document.body.removeChild(mainContainerDiv);
			  \});
			
			  // it('should warn when unmounting a non-container root node', function() \{
			  //   var mainContainerDiv = document.createElement('div');
			
			  //   var component =
			  //     <div>
			  //       <div />
			  //     </div>;
			  //   ReactDOM.render(component, mainContainerDiv);
			
			  //   // Test that unmounting at a root node gives a helpful warning
			  //   var rootDiv = mainContainerDiv.firstChild;
			  //   spyOn(console, 'error');
			  //   ReactDOM.unmountComponentAtNode(rootDiv);
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.mostRecentCall.calls.argsFor(0)).toBe(
			  //     'Warning: unmountComponentAtNode(): The node you\\'re attempting to ' +
			  //     'unmount was rendered by React and is not a top-level container. You ' +
			  //     'may have accidentally passed in a React root node instead of its ' +
			  //     'container.'
			  //   );
			  // \});
			
			  // it('should warn when unmounting a non-container, non-root node', function() \{
			  //   var mainContainerDiv = document.createElement('div');
			
			  //   var component =
			  //     <div>
			  //       <div>
			  //         <div />
			  //       </div>
			  //     </div>;
			  //   ReactDOM.render(component, mainContainerDiv);
			
			  //   // Test that unmounting at a non-root node gives a different warning
			  //   var nonRootDiv = mainContainerDiv.firstChild.firstChild;
			  //   spyOn(console, 'error');
			  //   ReactDOM.unmountComponentAtNode(nonRootDiv);
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.mostRecentCall.calls.argsFor(0)).toBe(
			  //     'Warning: unmountComponentAtNode(): The node you\\'re attempting to ' +
			  //     'unmount was rendered by React and is not a top-level container. ' +
			  //     'Instead, have the parent component update its state and rerender in ' +
			  //     'order to remove this component.'
			  //   );
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactMountDestruction.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactMultiChild.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			var mocks = \{
			  getMockFunction: function () \{
			    return jasmine.createSpy();
			  \}
			\};
			
			describe('ReactMultiChild', function () \{
			  describe('reconciliation', function () \{
			    it('should update children when possible', function () \{
			      var container = document.createElement('div');
			
			      var mockMount = mocks.getMockFunction();
			      var mockUpdate = mocks.getMockFunction();
			      var mockUnmount = mocks.getMockFunction();
			
			      var MockComponent = React.createClass(\{
			        componentDidMount: mockMount,
			        componentDidUpdate: mockUpdate,
			        componentWillUnmount: mockUnmount,
			        render: function () \{
			          return <span />;
			        \}
			      \});
			
			      expect(mockMount.calls.count()).toBe(0);
			      expect(mockUpdate.calls.count()).toBe(0);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(
			        <div>
			          <MockComponent />
			        </div>,
			        container
			      );
			
			      expect(mockMount.calls.count()).toBe(1);
			      expect(mockUpdate.calls.count()).toBe(0);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(
			        <div>
			          <MockComponent />
			        </div>,
			        container
			      );
			
			      expect(mockMount.calls.count()).toBe(1);
			      expect(mockUpdate.calls.count()).toBe(1);
			      expect(mockUnmount.calls.count()).toBe(0);
			    \});
			
			    it('should replace children with different constructors', function () \{
			      var container = document.createElement('div');
			
			      var mockMount = mocks.getMockFunction();
			      var mockUnmount = mocks.getMockFunction();
			
			      var MockComponent = React.createClass(\{
			        componentDidMount: mockMount,
			        componentWillUnmount: mockUnmount,
			        render: function () \{
			          return <span />;
			        \}
			      \});
			
			      expect(mockMount.calls.count()).toBe(0);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(
			        <div>
			          <MockComponent />
			        </div>,
			        container
			      );
			
			      expect(mockMount.calls.count()).toBe(1);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(
			        <div>
			          <span />
			        </div>,
			        container
			      );
			
			      expect(mockMount.calls.count()).toBe(1);
			      expect(mockUnmount.calls.count()).toBe(1);
			    \});
			
			    it('should NOT replace children with different owners', function () \{
			      var container = document.createElement('div');
			
			      var mockMount = mocks.getMockFunction();
			      var mockUnmount = mocks.getMockFunction();
			
			      var MockComponent = React.createClass(\{
			        componentDidMount: mockMount,
			        componentWillUnmount: mockUnmount,
			        render: function () \{
			          return <span />;
			        \}
			      \});
			
			      var WrapperComponent = React.createClass(\{
			        render: function () \{
			          return this.props.children || <MockComponent />;
			        \}
			      \});
			
			      expect(mockMount.calls.count()).toBe(0);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(<WrapperComponent />, container);
			
			      expect(mockMount.calls.count()).toBe(1);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(
			        <WrapperComponent>
			          <MockComponent />
			        </WrapperComponent>,
			        container
			      );
			
			      expect(mockMount.calls.count()).toBe(1);
			      expect(mockUnmount.calls.count()).toBe(0);
			    \});
			
			    it('should replace children with different keys', function () \{
			      var container = document.createElement('div');
			
			      var mockMount = mocks.getMockFunction();
			      var mockUnmount = mocks.getMockFunction();
			
			      var MockComponent = React.createClass(\{
			        componentDidMount: mockMount,
			        componentWillUnmount: mockUnmount,
			        render: function () \{
			          return <span />;
			        \}
			      \});
			
			      expect(mockMount.calls.count()).toBe(0);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(
			        <div>
			          <MockComponent key="A" />
			        </div>,
			        container
			      );
			
			      expect(mockMount.calls.count()).toBe(1);
			      expect(mockUnmount.calls.count()).toBe(0);
			
			      ReactDOM.render(
			        <div>
			          <MockComponent key="B" />
			        </div>,
			        container
			      );
			
			      expect(mockMount.calls.count()).toBe(2);
			      expect(mockUnmount.calls.count()).toBe(1);
			    \});
			  \});
			
			  // describe('innerHTML', function() \{
			  //   var setInnerHTML;
			
			  //   // Only run this suite if \`Element.prototype.innerHTML\` can be spied on.
			  //   var innerHTMLDescriptor = Object.getOwnPropertyDescriptor(
			  //     Element.prototype,
			  //     'innerHTML'
			  //   );
			  //   if (!innerHTMLDescriptor) \{
			  //     return;
			  //   \}
			
			  //   beforeEach(function() \{
			  //     var ReactDOMFeatureFlags = require('ReactDOMFeatureFlags');
			  //     ReactDOMFeatureFlags.useCreateElement = false;
			
			  //     Object.defineProperty(Element.prototype, 'innerHTML', \{
			  //       set: setInnerHTML = jasmine.createSpy().andCallFake(
			  //         innerHTMLDescriptor.set
			  //       ),
			  //     \});
			  //   \});
			
			  //   it('should only set \`innerHTML\` once on update', function() \{
			  //     var container = document.createElement('div');
			
			  //     ReactDOM.render(
			  //       <div>
			  //         <p><span /></p>
			  //         <p><span /></p>
			  //         <p><span /></p>
			  //       </div>,
			  //       container
			  //     );
			  //     // Warm the cache used by \`getMarkupWrap\`.
			  //     ReactDOM.render(
			  //       <div>
			  //         <p><span /><span /></p>
			  //         <p><span /><span /></p>
			  //         <p><span /><span /></p>
			  //       </div>,
			  //       container
			  //     );
			  //     expect(setInnerHTML).toHaveBeenCalled();
			  //     var callCountOnMount = setInnerHTML.calls.count();
			
			  //     ReactDOM.render(
			  //       <div>
			  //         <p><span /><span /><span /></p>
			  //         <p><span /><span /><span /></p>
			  //         <p><span /><span /><span /></p>
			  //       </div>,
			  //       container
			  //     );
			  //     expect(setInnerHTML.calls.count()).toBe(callCountOnMount + 1);
			  //   \});
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactMultiChild.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactPureComponent.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright 2013-present, Facebook, Inc.
			 * All rights reserved.
			 *
			 * This source code is licensed under the BSD-style license found in the
			 * LICENSE file in the root directory of this source tree. An additional grant
			 * of patent rights can be found in the PATENTS file in the same directory.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			
			var ReactDOM = React;
			
			describe('ReactPureComponent', function () \{
			  it('should render', function () \{
			    var renders = 0;
			    class Component extends React.PureComponent \{
			      constructor() \{
			        super();
			        this.state = \{ type: 'mushrooms' \};
			      \}
			      render() \{
			        renders++;
			        return <div>\{this.props.text[0]\}</div>;
			      \}
			    \}
			
			    var container = document.createElement('div');
			    var text;
			    var component;
			
			    text = ['porcini'];
			    component = ReactDOM.render(<Component text=\{text\} />, container);
			    expect(container.textContent).toBe('porcini');
			    expect(renders).toBe(1);
			
			    text = ['morel'];
			    component = ReactDOM.render(<Component text=\{text\} />, container);
			    expect(container.textContent).toBe('morel');
			    expect(renders).toBe(2);
			
			    text[0] = 'portobello';
			    component = ReactDOM.render(<Component text=\{text\} />, container);
			    expect(container.textContent).toBe('morel');
			    expect(renders).toBe(2);
			
			    // Setting state without changing it doesn't cause a rerender.
			    component.setState(\{ type: 'mushrooms' \});
			    expect(container.textContent).toBe('morel');
			    expect(renders).toBe(2);
			
			    // But changing state does.
			    component.setState(\{ type: 'portobello mushrooms' \});
			    expect(container.textContent).toBe('portobello');
			    expect(renders).toBe(3);
			  \});
			
			  it('should render when props or state mismatch in prop count', function () \{
			    var renders = 0;
			    class Component extends React.PureComponent \{
			      constructor() \{
			        super();
			        this.state = \{ type: 'mushrooms' \};
			      \}
			
			      shouldComponentUpdate(nextProps, state) \{
			        return super.shouldComponentUpdate(nextProps, state);
			      \}
			      render() \{
			        renders++;
			        return <div>\{this.props.text[0]\}</div>;
			      \}
			    \}
			
			    var container = document.createElement('div');
			    var text;
			    var component;
			
			    text = ['porcini'];
			    component = ReactDOM.render(<Component foo=\{'bar'\} text=\{text\} />, container);
			    expect(container.textContent).toBe('porcini');
			    expect(renders).toBe(1);
			
			    component = ReactDOM.render(<Component text=\{text\} />, container);
			    expect(container.textContent).toBe('porcini');
			    expect(renders).toBe(2);
			  \});
			
			  it('can override shouldComponentUpdate', function () \{
			    var renders = 0;
			    class Component extends React.PureComponent \{
			      render() \{
			        renders++;
			        return <div />;
			      \}
			      shouldComponentUpdate() \{
			        return true;
			      \}
			    \}
			    var container = document.createElement('div');
			    ReactDOM.render(<Component />, container);
			    ReactDOM.render(<Component />, container);
			    expect(renders).toBe(2);
			  \});
			
			  it('extends React.Component', function () \{
			    var renders = 0;
			    class Component extends React.PureComponent \{
			      render() \{
			        expect(this instanceof React.Component).toBe(true);
			        expect(this instanceof React.PureComponent).toBe(true);
			        renders++;
			        return <div />;
			      \}
			    \}
			    ReactDOM.render(<Component />, document.createElement('div'));
			    expect(renders).toBe(1);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactPureComponent.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactStatelessComponent.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright 2013-present, Facebook, Inc.
			 * All rights reserved.
			 *
			 * This source code is licensed under the BSD-style license found in the
			 * LICENSE file in the root directory of this source tree. An additional grant
			 * of patent rights can be found in the PATENTS file in the same directory.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			
			function StatelessComponent(props) \{
			  return <div>\{props.name\}</div>;
			\}
			
			describe('ReactStatelessComponent', function () \{
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should render stateless component', function () \{
			    var el = document.createElement('div');
			    ReactDOM.render(<StatelessComponent name="A" />, el);
			
			    expect(el.textContent).toBe('A');
			  \});
			
			  it('should update stateless component', function () \{
			    var Parent = React.createClass(\{
			      render() \{
			        return <StatelessComponent \{...this.props\} />;
			      \}
			    \});
			
			    var el = document.createElement('div');
			    ReactDOM.render(<Parent name="A" />, el);
			    expect(el.textContent).toBe('A');
			
			    ReactDOM.render(<Parent name="B" />, el);
			    expect(el.textContent).toBe('B');
			  \});
			
			  it('should unmount stateless component', function () \{
			    var container = document.createElement('div');
			
			    ReactDOM.render(<StatelessComponent name="A" />, container);
			    expect(container.textContent).toBe('A');
			
			    ReactDOM.unmountComponentAtNode(container);
			    expect(container.textContent).toBe('');
			  \});
			
			  it('should pass context thru stateless component', function () \{
			    var Child = React.createClass(\{
			      contextTypes: \{
			        test: React.PropTypes.string.isRequired
			      \},
			
			      render: function () \{
			        return <div>\{this.context.test\}</div>;
			      \}
			    \});
			
			    function Parent() \{
			      return <Child />;
			    \}
			
			    var GrandParent = React.createClass(\{
			      childContextTypes: \{
			        test: React.PropTypes.string.isRequired
			      \},
			
			      getChildContext() \{
			        return \{ test: this.props.test \};
			      \},
			
			      render: function () \{
			        return <Parent />;
			      \}
			    \});
			
			    var el = document.createElement('div');
			    ReactDOM.render(<GrandParent test="test" />, el);
			
			    expect(el.textContent).toBe('test');
			
			    ReactDOM.render(<GrandParent test="mest" />, el);
			
			    expect(el.textContent).toBe('mest');
			  \});
			
			  it('should warn when stateless component returns array', function () \{
			    spyOn(console, 'error');
			    function NotAComponent() \{
			      return [<div />, <div />];
			    \}
			    expect(function () \{
			      React.render(
			        <div>
			          <NotAComponent />
			        </div>
			      );
			    \}).toThrow();
			    // expect(console.error.calls.count()).toBe(1);
			    // expect(console.error.argsForCall[0][0]).toContain(
			    //   'NotAComponent(...): A valid React element (or null) must be returned. '+
			    //   'You may have returned undefined, an array or some other invalid object.'
			    // );
			  \});
			
			  // it('should throw on string refs in pure functions', function() \{
			  //   function Child() \{
			  //     return <div ref="me" />;
			  //   \}
			
			  //   expect(function() \{
			  //     ReactTestUtils.renderIntoDocument(<Child test="test" />);
			  //   \}).toThrow(
			  //     'Stateless function components cannot have refs.'
			  //   );
			  // \});
			
			  // it('should warn when given a ref', function() \{
			  //   spyOn(console, 'error');
			
			  //   var Parent = React.createClass(\{
			  //     displayName: 'Parent',
			  //     render: function() \{
			  //       return <StatelessComponent name="A" ref="stateless"/>;
			  //     \},
			  //   \});
			  //   ReactTestUtils.renderIntoDocument(<Parent/>);
			
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toContain(
			  //     'Stateless function components cannot be given refs ' +
			  //     '(See ref "stateless" in StatelessComponent created by Parent). ' +
			  //     'Attempts to access this ref will fail.'
			  //   );
			  // \});
			
			  // it('should provide a null ref', function() \{
			  //   function Child() \{
			  //     return <div />;
			  //   \}
			  //
			  //   var comp = ReactTestUtils.renderIntoDocument(<Child />);
			  //   expect(comp).toBe(null);
			  // \});
			
			  // it('should use correct name in key warning', function() \{
			  //   function Child() \{
			  //     return <div>\{[<span />]\}</div>;
			  //   \}
			
			  //   spyOn(console, 'error');
			  //   ReactTestUtils.renderIntoDocument(<Child />);
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toContain('a unique "key" prop');
			  //   expect(console.error.argsForCall[0][0]).toContain('Child');
			  // \});
			
			  // it('should support default props and prop types', function() \{
			  //   function Child(props) \{
			  //     return <div>\{props.test\}</div>;
			  //   \}
			  //   Child.defaultProps = \{test: 2\};
			  //   Child.propTypes = \{test: React.PropTypes.string\};
			
			  //   spyOn(console, 'error');
			  //   ReactTestUtils.renderIntoDocument(<Child />);
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toBe(
			  //     'Warning: Failed propType: Invalid prop \`test\` of type \`number\` ' +
			  //     'supplied to \`Child\`, expected \`string\`.'
			  //   );
			  // \});
			
			  it('should receive context', function () \{
			    var Parent = React.createClass(\{
			      childContextTypes: \{
			        lang: React.PropTypes.string
			      \},
			      getChildContext: function () \{
			        return \{ lang: 'en' \};
			      \},
			      render: function () \{
			        return <Child />;
			      \}
			    \});
			    function Child(props, context) \{
			      return <div>\{context.lang\}</div>;
			    \}
			    Child.contextTypes = \{ lang: React.PropTypes.string \};
			
			    var el = document.createElement('div');
			    ReactDOM.render(<Parent />, el);
			    expect(el.textContent).toBe('en');
			  \});
			
			  it('should work with arrow functions', function () \{
			    var Child = function () \{
			      return <div />;
			    \};
			    // Will create a new bound function without a prototype, much like a native
			    // arrow function.
			    Child = Child.bind(this);
			
			    expect(() => renderIntoDocument(<Child />)).not.toThrow();
			  \});
			
			  it('should allow simple functions to return null', function () \{
			    var Child = function () \{
			      return null;
			    \};
			    expect(() => renderIntoDocument(<Child />)).not.toThrow();
			  \});
			
			  it('should allow simple functions to return false', function () \{
			    function Child() \{
			      return false;
			    \}
			    expect(() => renderIntoDocument(<Child />)).not.toThrow();
			  \});
			
			  // it('should warn when using non-React functions in JSX', function() \{
			  //   spyOn(console, 'error');
			  //   function NotAComponent() \{
			  //     return [<div />, <div />];
			  //   \}
			  //   expect(function() \{
			  //     ReactTestUtils.renderIntoDocument(<div><NotAComponent /></div>);
			  //   \}).toThrow();  // has no method 'render'
			  //   expect(console.error.calls.count()).toBe(1);
			  //   expect(console.error.argsForCall[0][0]).toContain(
			  //     'NotAComponent(...): A valid React element (or null) must be returned. You may ' +
			  //     'have returned undefined, an array or some other invalid object.'
			  //   );
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\ReactStatelessComponent.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\SelectValueElement.spec.jsx', () => {
        const sourceCode = `
			/**
			 * Copyright (c) 2013-present, Facebook, Inc.
			 *
			 * This source code is licensed under the MIT license found in the
			 * LICENSE file in the root directory of this source tree.
			 *
			 * @emails react-core
			 */
			
			import React from 'inferno-compat';
			import \{ createComponentVNode \} from 'inferno';
			import \{ Wrapper \} from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			var ReactDOM = React;
			
			describe('Render Select with multiple values', function () \{
			  let container;
			
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  class Component extends React.Component \{
			    constructor(props, context) \{
			      super(props, context);
			      this.state = \{ selectedValue: [1, 3, 4] \};
			    \}
			
			    render() \{
			      return (
			        <div>
			          <select value=\{this.state.selectedValue\} id="selectNode" multiple>
			            <option value=\{1\}>1</option>
			            <option value=\{2\}>2</option>
			            <option value=\{3\}>3</option>
			            <option value=\{4\}>4</option>
			          </select>
			          \{this.state.selectedValue\}
			        </div>
			      );
			    \}
			  \}
			
			  it('should mark correct option as selected', function () \{
			    var instance = renderIntoDocument(<Component />);
			    var root = ReactDOM.findDOMNode(instance);
			    expect(root.childNodes[0].options[0].selected).toBe(true);
			    expect(root.childNodes[0].options[1].selected).toBe(false);
			    expect(root.childNodes[0].options[2].selected).toBe(true);
			    expect(root.childNodes[0].options[3].selected).toBe(true);
			  \});
			\});
			
			describe('Render Select with single value', function () \{
			  let container;
			  function renderIntoDocument(input) \{
			    return React.render(createComponentVNode(VNodeFlags.ComponentClass, Wrapper, \{ children: input \}), container);
			  \}
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    React.render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  class Component extends React.Component \{
			    constructor(props, context) \{
			      super(props, context);
			      this.state = \{ selectedValue: 2 \};
			    \}
			
			    render() \{
			      return (
			        <div>
			          <select value=\{this.state.selectedValue\} id="selectNode">
			            <option value=\{1\}>1</option>
			            <option value=\{2\}>2</option>
			            <option value=\{3\}>3</option>
			            <option value=\{4\}>4</option>
			          </select>
			          \{this.state.selectedValue\}
			        </div>
			      );
			    \}
			  \}
			
			  it('should mark correct option as selected', function () \{
			    var instance = renderIntoDocument(<Component />);
			    var root = ReactDOM.findDOMNode(instance);
			
			    expect(root.childNodes[0].options[0].selected).toBe(false);
			    expect(root.childNodes[0].options[1].selected).toBe(true);
			    expect(root.childNodes[0].options[2].selected).toBe(false);
			    expect(root.childNodes[0].options[3].selected).toBe(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\SelectValueElement.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\styles.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno-compat';
			
			describe('Compat - styles', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should be possible to use camelCase styles when reactStyles support is on', () => \{
			    render(<div style=\{\{ backgroundColor: 'red' \}\}>Test</div>, container);
			
			    expect(container.innerHTML).toBe(\`<div style="background-color: red;">Test</div>\`);
			  \});
			
			  it('Should automatically add px suffix to whitelisted numeric style properties', () => \{
			    render(<div style=\{\{ width: 10, zIndex: 1 \}\}>foo</div>, container);
			
			    expect(container.innerHTML).toBe(\`<div style="width: 10px; z-index: 1;">foo</div>\`);
			  \});
			
			  it('Should be possible to use hyphen case props too', () => \{
			    render(<div style=\{\{ 'background-color': 'blue', 'z-index': 3 \}\}>foo</div>, container);
			
			    expect(container.firstChild.style.backgroundColor).toBe('blue');
			    expect(container.firstChild.style.zIndex + '').toBe('3');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\styles.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\svg.spec.jsx', () => {
        const sourceCode = `
			import \{ createElement, render \} from 'inferno-compat';
			
			describe('svg', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			  \});
			
			  it('Should work with normal svg attributes', () => \{
			    render(
			      createElement(
			        'svg',
			        \{
			          height: '16',
			          width: '16',
			          viewBox: '0 0 1024 1024'
			        \},
			        [
			          createElement('stop', \{
			            offset: 0,
			            stopColor: 'white',
			            stopOpacity: 0.5
			          \})
			        ]
			      ),
			      container
			    );
			
			    expect(container.firstChild.getAttribute('viewBox')).toBe('0 0 1024 1024');
			    expect(container.firstChild.getAttribute('height')).toBe('16');
			    expect(container.firstChild.getAttribute('width')).toBe('16');
			    expect(container.firstChild.firstChild.tagName).toBe('stop');
			    expect(container.firstChild.firstChild.getAttribute('stop-color')).toBe('white');
			    expect(container.firstChild.firstChild.getAttribute('stop-opacity')).toBe('0.5');
			  \});
			
			  it('Should work with namespace svg attributes', () => \{
			    render(
			      createElement('svg', null, [
			        createElement('image', \{
			          xlinkHref: 'http://i.imgur.com/w7GCRPb.png'
			        \})
			      ]),
			      container
			    );
			
			    expect(container.firstChild.firstChild.tagName).toBe('image');
			    expect(container.firstChild.firstChild.getAttribute('xlink:href')).toBe('http://i.imgur.com/w7GCRPb.png');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\svg.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\testutils.spec.jsx', () => {
        const sourceCode = `
			import \{ createComponentVNode, createElement \} from 'inferno-compat';
			import * as TestUtils from 'inferno-test-utils';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('Inferno-compat: renderToSnapshot', () => \{
			  it('should return a snapshot with className prop, multiple children', () => \{
			    function TestComponent(props) \{
			      return createElement('div', null, [props.children, createElement('span', null, '1')]);
			    \}
			
			    const snapshot = TestUtils.renderToSnapshot(
			      createComponentVNode(VNodeFlags.ComponentFunction, TestComponent, \{
			        children: [
			          createComponentVNode(VNodeFlags.ComponentFunction, TestComponent, \{
			            children: [createElement('span', null, 'a'), createElement('span', null, 'b')]
			          \}),
			          createElement('span', null, 'a'),
			          createElement('span', null, 'b')
			        ]
			      \})
			    );
			
			    expect(JSON.stringify(snapshot)).toBe(
			      '\{"children":[\{"children":[\{"children":["a"],"props":\{\},"type":"span"\},\{"children":["b"],"props":\{\},"type":"span"\},\{"children":["1"],"props":\{\},"type":"span"\}],"props":\{\},"type":"div"\},\{"children":["a"],"props":\{\},"type":"span"\},\{"children":["b"],"props":\{\},"type":"span"\},\{"children":["1"],"props":\{\},"type":"span"\}],"props":\{\},"type":"div"\}'
			    );
			  \});
			
			  it('should correctly handle null children', () => \{
			    function TestComponent(props) \{
			      return createElement('div', null, [props.children, createElement('span', null, '1')]);
			    \}
			
			    const snapshot = TestUtils.renderToSnapshot(
			      createComponentVNode(VNodeFlags.ComponentFunction, TestComponent, \{
			        children: [
			          createComponentVNode(VNodeFlags.ComponentFunction, TestComponent, \{
			            children: [null, undefined]
			          \}),
			          createElement('span', null, 'a'),
			          createElement('span', null, 'b')
			        ]
			      \})
			    );
			
			    expect(JSON.stringify(snapshot)).toBe(
			      '\{"children":[\{"children":[\{"children":["1"],"props":\{\},"type":"span"\}],"props":\{\},"type":"div"\},\{"children":["a"],"props":\{\},"type":"span"\},\{"children":["b"],"props":\{\},"type":"span"\},\{"children":["1"],"props":\{\},"type":"span"\}],"props":\{\},"type":"div"\}'
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\testutils.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-compat\\__tests__\\warnings.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno-compat';
			
			describe('Warnings', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should warn if inferno-compat overrides existing onInput ( text ) handler', () => \{
			    function myTest() \{\}
			    function anotherMethod() \{\}
			
			    const spy = spyOn(console, 'error');
			
			    render(<input type="text" onChange=\{anotherMethod\} onInput=\{myTest\} />, container);
			
			    expect(spy.calls.count()).toBe(1);
			    expect(spy.calls.argsFor(0)).toEqual([
			      \`Inferno-compat Warning! 'onInput' handler is reserved to support React like 'onChange' event flow.
			Original event handler 'function \$\{myTest.name\}' will not be called.\`
			    ]);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-compat\\__tests__\\warnings.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-create-class\\__tests__\\createClass.ext.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Components createClass (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    container.style.display = 'none';
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  const BasicComponent = createClass(\{
			    render() \{
			      return createElement('div', null, 'Hello world!');
			    \}
			  \});
			
			  it('should render a basic component', () => \{
			    render(createElement(BasicComponent), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			  it('should render a basic component with lifecycle', () => \{
			    let componentWillUpdate = false;
			    const LifecycleComponent1 = createClass(\{
			      componentWillUpdate() \{
			        componentWillUpdate = true;
			      \},
			      render() \{
			        return createElement('div', null, 'Hello world!');
			      \}
			    \});
			
			    render(createElement(LifecycleComponent1, \{\}), container);
			    render(createElement(LifecycleComponent1, \{\}), container);
			    expect(componentWillUpdate).toBe(true);
			  \});
			
			  it('should have context available in getInitialState', (done) => \{
			    let context;
			    let context2;
			    const BoundComponent = createClass(\{
			      getInitialState() \{
			        expect(this.context);
			      \},
			      foo() \{
			        context2 = this;
			      \},
			      render() \{
			        return createElement('div', null, 'Hello world!');
			      \}
			    \});
			
			    render(createElement(BoundComponent), container);
			    setTimeout(() => \{
			      expect(context === context2).toBe(true);
			      done();
			    \}, 10);
			  \});
			
			  it('should have propTypes on created class', () => \{
			    const propTypes = \{
			      value() \{\}
			    \};
			    const Component = createClass(\{
			      propTypes,
			      render() \{
			        return createElement('div', null, 'Hello world!');
			      \}
			    \});
			
			    expect(Component.propTypes).toBe(propTypes);
			  \});
			  it('should not have propTypes on created class when not specified', () => \{
			    const Component = createClass(\{
			      render() \{
			        return createElement('div', null, 'Hello world!');
			      \}
			    \});
			
			    expect(Component.propTypes).toBeUndefined();
			  \});
			  it('should have mixins on created class', () => \{
			    const mixins = [
			      \{
			        func1: () => true
			      \}
			    ];
			    const Component = createClass(\{
			      mixins,
			      render() \{
			        return createElement('div', null, 'Hello world!');
			      \}
			    \});
			    render(createElement(Component, \{\}), container);
			    expect(Component.mixins.func1).toBeDefined();
			  \});
			  it('should have nested mixins on created class', () => \{
			    const mixins = [
			      \{
			        mixins: [
			          \{
			            mixins: [
			              \{
			                nestedMixin: () => true
			              \}
			            ]
			          \}
			        ]
			      \}
			    ];
			    const Component = createClass(\{
			      mixins,
			      render() \{
			        return createElement('div', null, 'Hello world!');
			      \}
			    \});
			    render(createElement(Component, \{\}), container);
			    expect(Component.mixins.nestedMixin).toBeDefined();
			  \});
			
			  it('Should be possible to extend prototype by creating instance of class, Github #1380', () => \{
			    function TestMe() \{\}
			
			    TestMe.prototype = \{
			      render() \{
			        return <div>It works!</div>;
			      \}
			    \};
			
			    const TestMeComponent = createClass(new TestMe());
			
			    render(<TestMeComponent />, container);
			
			    expect(container.innerHTML).toBe('<div>It works!</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-class\\__tests__\\createClass.ext.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-create-class\\__tests__\\createClass.ext.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			
			describe('Components createClass (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    container.style.display = 'none';
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  describe('mixins', () => \{
			    describe('mixin methods', () => \{
			      it('receives the class instance', () => \{
			        const Foo = createClass(\{
			          mixins: [
			            \{
			              componentDidMount() \{
			                this.someState = 1;
			              \},
			              doSomething() \{
			                this.anotherState = 2;
			              \}
			            \}
			          ],
			          render() \{
			            this.doSomething();
			            return <div />;
			          \}
			        \});
			
			        let a;
			        render(
			          <Foo
			            ref=\{function (i) \{
			              a = i;
			            \}\}
			          />,
			          container
			        );
			
			        expect(a.someState).toEqual(1);
			        expect(a.anotherState).toEqual(2);
			      \});
			
			      it('returns result through instance', () => \{
			        const Foo = createClass(\{
			          mixins: [
			            \{
			              renderSomething() \{
			                return <div>\{this.props.bar\}</div>;
			              \}
			            \}
			          ],
			          render() \{
			            return <div>\{this.renderSomething()\}</div>;
			          \}
			        \});
			
			        render(<Foo bar="test" />, container);
			        expect(container.innerHTML).toEqual('<div><div>test</div></div>');
			      \});
			
			      it('works as a lifecycle method even when a matching method is already defined', () => \{
			        const Foo = createClass(\{
			          mixins: [
			            \{
			              componentDidMount() \{
			                this.someState = 1;
			              \}
			            \}
			          ],
			          componentDidMount() \{\},
			          render() \{
			            return <div />;
			          \}
			        \});
			
			        let a;
			        render(
			          <Foo
			            ref=\{function (i) \{
			              a = i;
			            \}\}
			          />,
			          container
			        );
			
			        expect(a.someState).toEqual(1);
			      \});
			    \});
			
			    describe('getDefaultProps', () => \{
			      it('should use a mixin', () => \{
			        const Foo = createClass(\{
			          mixins: [\{ getDefaultProps: () => (\{ a: true \}) \}],
			          render() \{
			            return <div />;
			          \}
			        \});
			
			        expect(Foo.defaultProps).toEqual(\{
			          a: true
			        \});
			      \});
			
			      it('should combine the results', () => \{
			        const Foo = createClass(\{
			          mixins: [\{ getDefaultProps: () => (\{ a: true \}) \}, \{ getDefaultProps: () => (\{ b: true \}) \}],
			          getDefaultProps() \{
			            return \{ c: true \};
			          \},
			          render() \{
			            return <div />;
			          \}
			        \});
			
			        expect(Foo.defaultProps).toEqual(\{
			          a: true,
			          b: true,
			          c: true
			        \});
			      \});
			
			      it('should throw an error for duplicate keys', () => \{
			        expect(() =>
			          createClass(\{
			            mixins: [\{ getDefaultProps: () => (\{ a: true \}) \}],
			            getDefaultProps() \{
			              return \{ a: true \};
			            \},
			            render() \{
			              return <div />;
			            \}
			          \})
			        ).toThrowError(Error);
			      \});
			    \});
			
			    describe('getInitialState', () => \{
			      it('should combine the results', () => \{
			        const Foo = createClass(\{
			          mixins: [\{ getInitialState: () => (\{ a: true \}) \}, \{ getInitialState: () => (\{ b: true \}) \}],
			          getInitialState() \{
			            return \{ c: true \};
			          \},
			          render() \{
			            return <div />;
			          \}
			        \});
			
			        let a;
			        render(
			          <Foo
			            ref=\{function (i) \{
			              a = i;
			            \}\}
			          />,
			          container
			        );
			
			        expect(a.state).toEqual(\{
			          a: true,
			          b: true,
			          c: true
			        \});
			      \});
			
			      it('should throw an error for duplicate keys', () => \{
			        const Foo = createClass(\{
			          mixins: [\{ getInitialState: () => (\{ a: true \}) \}],
			          getInitialState() \{
			            return \{ a: true \};
			          \},
			          render() \{
			            return <div />;
			          \}
			        \});
			
			        expect(() => \{
			          render(<Foo />, container);
			        \}).toThrowError();
			      \});
			    \});
			  \});
			
			  describe('Context', () => \{
			    it('It should have context defined when context moved to children', () => \{
			      const App = createClass(\{
			        getDefaultProps() \{
			          return \{
			            wrapContext: false
			          \};
			        \},
			
			        getChildContext() \{
			          return \{
			            foo: 'bar baz'
			          \};
			        \},
			
			        addPageContexts(children) \{
			          const newChildren = [];
			
			          for (let i = 0; i < children.length; i++) \{
			            newChildren.push(<Page \{...children[i].props\} />);
			          \}
			
			          return newChildren;
			        \},
			
			        render() \{
			          let children;
			
			          if (this.props.wrapContext) \{
			            children = this.addPageContexts(this.props.children);
			          \} else \{
			            children = this.props.children;
			          \}
			
			          return <div>\{children\}</div>;
			        \}
			      \});
			
			      const Page = createClass(\{
			        getInitialState() \{
			          return \{
			            foo: this.context.foo
			          \};
			        \},
			        render() \{
			          return (
			            <div>
			              \{this.props.greeting\} \{this.state.foo\}
			            </div>
			          );
			        \}
			      \});
			
			      render(
			        <App wrapContext=\{true\}>
			          <Page greeting="Hello" />
			          <Page greeting="Hai" />
			        </App>,
			        container
			      );
			
			      expect(container.innerHTML).toEqual('<div><div>Hello bar baz</div><div>Hai bar baz</div></div>');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-class\\__tests__\\createClass.ext.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('infernojs_inferno\\packages\\inferno-create-class\\__tests__\\createClass.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			
			function runBenchmark(container) \{
			  const Link0 = createClass(\{
			    render() \{
			      return <a href=\{'/'\} className=\{'_5ljn'\} rel=\{undefined\} onClick=\{function () \{\}\} />;
			    \}
			  \});
			
			  const ReactImage1 = createClass(\{
			    render() \{
			      return <i alt=\{''\} className=\{'_3-99 img sp_UuU9HmrQ397 sx_7e56e9'\} src=\{null\} />;
			    \}
			  \});
			
			  const Link2 = createClass(\{
			    render() \{
			      return (
			        <a
			          style=\{\{ maxWidth: '200px' \}\}
			          image=\{null\}
			          label=\{null\}
			          imageRight=\{\{\}\}
			          className=\{'_387r _55pi _2agf _387r _55pi _4jy0 _4jy3 _517h _51sy _42ft'\}
			          href=\{'#'\}
			          haschevron=\{true\}
			          onClick=\{function () \{\}\}
			          onToggle=\{function () \{\}\}
			          size=\{'medium'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          disabled=\{null\}
			          rel=\{undefined\}
			        >
			          \{null\}
			          <span className=\{'_55pe'\} style=\{\{ maxWidth: '186px' \}\}>
			            \{null\}
			            \{'Dick Madanson (10149999073643408)'\}
			          </span>
			          <ReactImage1 />
			        </a>
			      );
			    \}
			  \});
			
			  const AbstractButton3 = createClass(\{
			    render() \{
			      return <Link2 />;
			    \}
			  \});
			
			  const XUIButton4 = createClass(\{
			    render() \{
			      return <AbstractButton3 />;
			    \}
			  \});
			
			  const AbstractPopoverButton5 = createClass(\{
			    render() \{
			      return <XUIButton4 />;
			    \}
			  \});
			
			  const ReactXUIPopoverButton6 = createClass(\{
			    render() \{
			      return <AbstractPopoverButton5 />;
			    \}
			  \});
			
			  const AdsPEAccountSelector7 = createClass(\{
			    render() \{
			      return <ReactXUIPopoverButton6 />;
			    \}
			  \});
			
			  const AdsPEAccountSelectorContainer8 = createClass(\{
			    render() \{
			      return <AdsPEAccountSelector7 />;
			    \}
			  \});
			
			  const AbstractButton9 = createClass(\{
			    render() \{
			      return (
			        <button
			          id=\{'downloadButton'\}
			          className=\{'_5lk0 _4jy0 _4jy3 _517h _51sy _42ft'\}
			          label=\{null\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          size=\{'medium'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          \{'Download to Power Editor'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton10 = createClass(\{
			    render() \{
			      return <AbstractButton9 />;
			    \}
			  \});
			
			  const DownloadUploadTimestamp11 = createClass(\{
			    render() \{
			      return (
			        <div>
			          \{'Last downloaded'\}\{' '\}
			          <abbr className=\{'livetimestamp'\} data-utime=\{1446062352\} data-shorten=\{false\}>
			            \{'a few seconds ago'\}
			          </abbr>
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage12 = createClass(\{
			    render() \{
			      return <i alt=\{''\} className=\{'_3-8_ img sp_UuU9HmrQ397 sx_dbc06a'\} src=\{null\} />;
			    \}
			  \});
			
			  const AbstractButton13 = createClass(\{
			    render() \{
			      return (
			        <button
			          id=\{'uploadButton'\}
			          className=\{'_5lk0 _4jy0 _4jy3 _517h _51sy _42ft'\}
			          image=\{\{\}\}
			          use=\{'default'\}
			          label=\{null\}
			          onClick=\{function () \{\}\}
			          size=\{'medium'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage12 />
			          \{'Upload Changes'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton14 = createClass(\{
			    render() \{
			      return <AbstractButton13 />;
			    \}
			  \});
			
			  const DownloadUploadTimestamp15 = createClass(\{
			    render() \{
			      return <div />;
			    \}
			  \});
			
			  const AbstractButton16 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_5ljz _4jy0 _4jy3 _517h _51sy _42ft'\}
			          label=\{null\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          size=\{'medium'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          \{'Help'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton17 = createClass(\{
			    render() \{
			      return <AbstractButton16 />;
			    \}
			  \});
			
			  const ReactImage18 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_d5a685'\} />;
			    \}
			  \});
			
			  const AbstractButton19 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_5ljw _p _4jy0 _4jy3 _517h _51sy _42ft'\}
			          image=\{\{\}\}
			          use=\{'default'\}
			          size=\{'medium'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage18 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton20 = createClass(\{
			    render() \{
			      return <AbstractButton19 />;
			    \}
			  \});
			
			  const InlineBlock21 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5ljz uiPopover _6a _6b'\} alignh=\{'right'\} menu=\{\{\}\} alignv=\{'middle'\} disabled=\{null\} fullWidth=\{false\}>
			          <XUIButton20 key=\{'/.0'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactPopoverMenu22 = createClass(\{
			    render() \{
			      return <InlineBlock21 />;
			    \}
			  \});
			
			  const XUIButtonGroup23 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_13xj _51xa'\} id=\{'helpButton'\}>
			          <XUIButton17 />
			          <ReactPopoverMenu22 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEResetDialog24 = createClass(\{
			    render() \{
			      return <span />;
			    \}
			  \});
			
			  const AdsPETopNav25 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5ljl'\} id=\{'ads_pe_top_nav'\}>
			          <div className=\{'_5ljm'\}>
			            <Link0 />
			            <div className=\{'_5rne'\}>
			              <span className=\{'_5ljs'\} data-testid=\{'PETopNavLogoText'\}>
			                \{'Power Editor'\}
			              </span>
			            </div>
			            <span className=\{'_5ljt _5lju'\}>\{'Dick Madanson'\}</span>
			          </div>
			          <div className=\{'_5ljy'\}>
			            <div className=\{'_5ljz _5mun'\}>
			              <AdsPEAccountSelectorContainer8 />
			              <div className=\{'_5lj- _5lju'\}>\{'Account 10149999073643408'\}</div>
			            </div>
			            <div className=\{'_5ljz'\}>
			              <div className=\{'_5lj_'\}>
			                <XUIButton10 />
			              </div>
			              <div className=\{'_5lj- _5lju'\}>
			                <DownloadUploadTimestamp11 />
			              </div>
			            </div>
			            <div className=\{'_5ljz'\}>
			              <div className=\{'_5lj_'\}>
			                <XUIButton14 />
			              </div>
			              <div className=\{'_5lj- _5lju'\}>
			                <DownloadUploadTimestamp15 />
			              </div>
			            </div>
			          </div>
			          <div className=\{'_5lk3'\}>
			            <XUIButtonGroup23 />
			          </div>
			          <AdsPEResetDialog24 />
			        </div>
			      );
			    \}
			  \});
			
			  const FluxContainer_ja_26 = createClass(\{
			    render() \{
			      return <AdsPETopNav25 />;
			    \}
			  \});
			
			  const Wrapper27 = createClass(\{
			    render() \{
			      return (
			        <li
			          selected=\{true\}
			          focused=\{false\}
			          tabIndex=\{null\}
			          hideFocusRing=\{true\}
			          onClick=\{function () \{\}\}
			          onMouseDown=\{function () \{\}\}
			          onFocus=\{function () \{\}\}
			          onBlur=\{function () \{\}\}
			          className=\{'_5vwz _5vwy _45hc _1hqh'\}
			          wrapper=\{function () \{\}\}
			          shouldWrapTab=\{true\}
			          mockSpacebarClick=\{true\}
			          role=\{'presentation'\}
			        >
			          <a
			            ajaxify=\{undefined\}
			            href=\{'#'\}
			            role=\{'tab'\}
			            rel=\{undefined\}
			            target=\{undefined\}
			            tabIndex=\{0\}
			            className=\{''\}
			            aria-selected=\{true\}
			            onKeyDown=\{function () \{\}\}
			          >
			            <div className=\{'_4jq5'\}>\{'Manage Ads'\}</div>
			            <span className=\{'_13xf'\} />
			          </a>
			        </li>
			      );
			    \}
			  \});
			
			  const TabBarItem28 = createClass(\{
			    render() \{
			      return <Wrapper27 />;
			    \}
			  \});
			
			  const XUIPageNavigationItem29 = createClass(\{
			    render() \{
			      return <TabBarItem28 />;
			    \}
			  \});
			
			  const TabBarItemWrapper30 = createClass(\{
			    render() \{
			      return <XUIPageNavigationItem29 key=\{'MANAGE_ADS'\} />;
			    \}
			  \});
			
			  const Wrapper31 = createClass(\{
			    render() \{
			      return (
			        <li
			          selected=\{false\}
			          focused=\{false\}
			          tabIndex=\{null\}
			          hideFocusRing=\{true\}
			          onClick=\{function () \{\}\}
			          onMouseDown=\{function () \{\}\}
			          onFocus=\{function () \{\}\}
			          onBlur=\{function () \{\}\}
			          className=\{'_5vwz _45hc'\}
			          wrapper=\{function () \{\}\}
			          shouldWrapTab=\{true\}
			          mockSpacebarClick=\{true\}
			          role=\{'presentation'\}
			        >
			          <a aria-selected=\{false\} onKeyDown=\{function () \{\}\}>
			            <div className=\{'_4jq5'\}>\{'Audiences'\}</div>
			            <span className=\{'_13xf'\} />
			          </a>
			        </li>
			      );
			    \}
			  \});
			
			  const TabBarItem32 = createClass(\{
			    render() \{
			      return <Wrapper31 />;
			    \}
			  \});
			
			  const XUIPageNavigationItem33 = createClass(\{
			    render() \{
			      return <TabBarItem32 />;
			    \}
			  \});
			
			  const TabBarItemWrapper34 = createClass(\{
			    render() \{
			      return <XUIPageNavigationItem33 key=\{'AUDIENCES'\} />;
			    \}
			  \});
			
			  const Wrapper35 = createClass(\{
			    render() \{
			      return (
			        <li
			          selected=\{false\}
			          focused=\{false\}
			          tabIndex=\{null\}
			          hideFocusRing=\{true\}
			          onClick=\{function () \{\}\}
			          onMouseDown=\{function () \{\}\}
			          onFocus=\{function () \{\}\}
			          onBlur=\{function () \{\}\}
			          className=\{'_5vwz _45hc'\}
			          wrapper=\{function () \{\}\}
			          shouldWrapTab=\{true\}
			          mockSpacebarClick=\{true\}
			          role=\{'presentation'\}
			        >
			          <a aria-selected=\{false\} onKeyDown=\{function () \{\}\}>
			            <div className=\{'_4jq5'\}>\{'Image Library'\}</div>
			            <span className=\{'_13xf'\} />
			          </a>
			        </li>
			      );
			    \}
			  \});
			
			  const TabBarItem36 = createClass(\{
			    render() \{
			      return <Wrapper35 />;
			    \}
			  \});
			
			  const XUIPageNavigationItem37 = createClass(\{
			    render() \{
			      return <TabBarItem36 />;
			    \}
			  \});
			
			  const TabBarItemWrapper38 = createClass(\{
			    render() \{
			      return <XUIPageNavigationItem37 key=\{'IMAGES'\} />;
			    \}
			  \});
			
			  const Wrapper39 = createClass(\{
			    render() \{
			      return (
			        <li
			          selected=\{false\}
			          focused=\{false\}
			          tabIndex=\{null\}
			          hideFocusRing=\{true\}
			          onClick=\{function () \{\}\}
			          onMouseDown=\{function () \{\}\}
			          onFocus=\{function () \{\}\}
			          onBlur=\{function () \{\}\}
			          className=\{'_5vwz _45hc'\}
			          wrapper=\{function () \{\}\}
			          shouldWrapTab=\{true\}
			          mockSpacebarClick=\{true\}
			          role=\{'presentation'\}
			        >
			          <a aria-selected=\{false\} onKeyDown=\{function () \{\}\}>
			            <div className=\{'_4jq5'\}>
			              \{'Reporting'\}
			              \{null\}
			            </div>
			            <span className=\{'_13xf'\} />
			          </a>
			        </li>
			      );
			    \}
			  \});
			
			  const TabBarItem40 = createClass(\{
			    render() \{
			      return <Wrapper39 />;
			    \}
			  \});
			
			  const XUIPageNavigationItem41 = createClass(\{
			    render() \{
			      return <TabBarItem40 />;
			    \}
			  \});
			
			  const TabBarItemWrapper42 = createClass(\{
			    render() \{
			      return <XUIPageNavigationItem41 key=\{'REPORTING'\} />;
			    \}
			  \});
			
			  const Wrapper43 = createClass(\{
			    render() \{
			      return (
			        <li
			          selected=\{false\}
			          focused=\{false\}
			          tabIndex=\{null\}
			          hideFocusRing=\{true\}
			          onClick=\{function () \{\}\}
			          onMouseDown=\{function () \{\}\}
			          onFocus=\{function () \{\}\}
			          onBlur=\{function () \{\}\}
			          className=\{'_5vwz _45hc'\}
			          wrapper=\{function () \{\}\}
			          shouldWrapTab=\{true\}
			          mockSpacebarClick=\{true\}
			          role=\{'presentation'\}
			        >
			          <a aria-selected=\{false\} onKeyDown=\{function () \{\}\}>
			            <div className=\{'_4jq5'\}>\{'Page Posts'\}</div>
			            <span className=\{'_13xf'\} />
			          </a>
			        </li>
			      );
			    \}
			  \});
			
			  const TabBarItem44 = createClass(\{
			    render() \{
			      return <Wrapper43 />;
			    \}
			  \});
			
			  const XUIPageNavigationItem45 = createClass(\{
			    render() \{
			      return <TabBarItem44 />;
			    \}
			  \});
			
			  const TabBarItemWrapper46 = createClass(\{
			    render() \{
			      return <XUIPageNavigationItem45 key=\{'PAGES'\} />;
			    \}
			  \});
			
			  const TabBarItem47 = createClass(\{
			    render() \{
			      return (
			        <a aria-selected=\{false\}>
			          <span className=\{'_1b0'\}>
			            \{'Tools'\}
			            <span className=\{'accessible_elem'\}>\{'additional tabs menu'\}</span>
			          </span>
			        </a>
			      );
			    \}
			  \});
			
			  const InlineBlock48 = createClass(\{
			    render() \{
			      return (
			        <div menu=\{\{\}\} layerBehaviors=\{\{\}\} alignv=\{'middle'\} className=\{'uiPopover _6a _6b'\} disabled=\{null\} fullWidth=\{false\}>
			          <TabBarItem47 key=\{'/.0'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactPopoverMenu49 = createClass(\{
			    render() \{
			      return <InlineBlock48 />;
			    \}
			  \});
			
			  const TabBarDropdownItem50 = createClass(\{
			    render() \{
			      return (
			        <li className=\{' _45hd'\} role=\{'tab'\}>
			          <ReactPopoverMenu49 />
			        </li>
			      );
			    \}
			  \});
			
			  const TabBar51 = createClass(\{
			    render() \{
			      return (
			        <ul
			          onTabClick=\{function () \{\}\}
			          activeTabKey=\{'MANAGE_ADS'\}
			          onWidthCalculated=\{function () \{\}\}
			          width=\{null\}
			          maxTabsVisible=\{5\}
			          moreLabel=\{'Tools'\}
			          alwaysShowActive=\{true\}
			          dropdownTabComponent=\{function () \{\}\}
			          shouldCalculateVisibleTabs=\{true\}
			          className=\{'_43o4'\}
			          role=\{'tablist'\}
			          onKeyDown=\{function () \{\}\}
			          onKeyUp=\{function () \{\}\}
			        >
			          <TabBarItemWrapper30 key=\{'MANAGE_ADS'\} />
			          <TabBarItemWrapper34 key=\{'AUDIENCES'\} />
			          <TabBarItemWrapper38 key=\{'IMAGES'\} />
			          <TabBarItemWrapper42 key=\{'REPORTING'\} />
			          <TabBarItemWrapper46 key=\{'PAGES'\} />
			          <TabBarDropdownItem50 key=\{'_dropdown'\} />
			        </ul>
			      );
			    \}
			  \});
			
			  const XUIPageNavigationGroup52 = createClass(\{
			    render() \{
			      return <TabBar51 />;
			    \}
			  \});
			
			  const LeftRight53 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5vx7 clearfix'\}>
			          <div key=\{'left'\} className=\{'_ohe lfloat'\}>
			            <XUIPageNavigationGroup52 key=\{'0'\} />
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const XUIPageNavigation54 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5vx2 _5vx4 _5vx6 _5kkt'\}>
			          <LeftRight53 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPENavigationBar55 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5_a'\} id=\{'ads_pe_navigation_bar'\}>
			          <XUIPageNavigation54 />
			        </div>
			      );
			    \}
			  \});
			
			  const FluxContainer_w_56 = createClass(\{
			    render() \{
			      return <AdsPENavigationBar55 />;
			    \}
			  \});
			
			  const ReactImage57 = createClass(\{
			    render() \{
			      return (
			        <i alt=\{'Warning'\} className=\{'_585p img sp_R48dKBxiJkP sx_aed870'\} src=\{null\}>
			          <u>\{'Warning'\}</u>
			        </i>
			      );
			    \}
			  \});
			
			  const Link58 = createClass(\{
			    render() \{
			      return (
			        <a
			          className=\{'_585q _50zy _50-0 _50z- _5upp _42ft'\}
			          href=\{'#'\}
			          onClick=\{function () \{\}\}
			          size=\{'medium'\}
			          shade=\{'dark'\}
			          type=\{null\}
			          label=\{null\}
			          title=\{'Remove'\}
			          aria-label=\{undefined\}
			          data-hover=\{undefined\}
			          data-tooltip-alignh=\{undefined\}
			          disabled=\{null\}
			          rel=\{undefined\}
			        >
			          \{undefined\}
			          \{'Remove'\}
			          \{undefined\}
			        </a>
			      );
			    \}
			  \});
			
			  const AbstractButton59 = createClass(\{
			    render() \{
			      return <Link58 />;
			    \}
			  \});
			
			  const XUIAbstractGlyphButton60 = createClass(\{
			    render() \{
			      return <AbstractButton59 />;
			    \}
			  \});
			
			  const XUICloseButton61 = createClass(\{
			    render() \{
			      return <XUIAbstractGlyphButton60 />;
			    \}
			  \});
			
			  const XUIText62 = createClass(\{
			    render() \{
			      return (
			        <span weight=\{'bold'\} size=\{'inherit'\} display=\{'inline'\} className=\{' _50f7'\}>
			          \{'Ads Manager'\}
			        </span>
			      );
			    \}
			  \});
			
			  const Link63 = createClass(\{
			    render() \{
			      return (
			        <a href=\{'/ads/manage/billing.php?act=10149999073643408'\} target=\{'_blank'\} rel=\{undefined\} onClick=\{function () \{\}\}>
			          <XUIText62 />
			        </a>
			      );
			    \}
			  \});
			
			  const XUINotice64 = createClass(\{
			    render() \{
			      return (
			        <div size=\{'medium'\} className=\{'_585n _585o _2wdd'\}>
			          <ReactImage57 />
			          <XUICloseButton61 />
			          <div className=\{'_585r _2i-a _50f4'\}>
			            \{'Please go to '\}
			            <Link63 />
			            \{' to set up a payment method for this ad account.'\}
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const ReactCSSTransitionGroupChild65 = createClass(\{
			    render() \{
			      return <XUINotice64 />;
			    \}
			  \});
			
			  const ReactTransitionGroup66 = createClass(\{
			    render() \{
			      return (
			        <span
			          transitionEnterTimeout=\{500\}
			          transitionLeaveTimeout=\{500\}
			          transitionName=\{\{\}\}
			          transitionAppear=\{false\}
			          transitionEnter=\{true\}
			          transitionLeave=\{true\}
			          childFactory=\{function () \{\}\}
			          component=\{'span'\}
			        >
			          <ReactCSSTransitionGroupChild65 key=\{'.0'\} />
			        </span>
			      );
			    \}
			  \});
			
			  const ReactCSSTransitionGroup67 = createClass(\{
			    render() \{
			      return <ReactTransitionGroup66 />;
			    \}
			  \});
			
			  const AdsPETopError68 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_2wdc'\}>
			          <ReactCSSTransitionGroup67 />
			        </div>
			      );
			    \}
			  \});
			
			  const FluxContainer_r_69 = createClass(\{
			    render() \{
			      return <AdsPETopError68 />;
			    \}
			  \});
			
			  const ReactImage70 = createClass(\{
			    render() \{
			      return <i className=\{'_3-8_ img sp_UuU9HmrQ397 sx_bae57d'\} src=\{null\} />;
			    \}
			  \});
			
			  const ReactImage71 = createClass(\{
			    render() \{
			      return <i alt=\{''\} className=\{'_3-99 img sp_UuU9HmrQ397 sx_7e56e9'\} src=\{null\} />;
			    \}
			  \});
			
			  const Link72 = createClass(\{
			    render() \{
			      return (
			        <a
			          style=\{\{ maxWidth: '200px' \}\}
			          image=\{null\}
			          label=\{null\}
			          imageRight=\{\{\}\}
			          className=\{' _5bbf _55pi _2agf  _5bbf _55pi _4jy0 _4jy4 _517h _51sy _42ft'\}
			          href=\{'#'\}
			          haschevron=\{true\}
			          onClick=\{function () \{\}\}
			          size=\{'large'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          disabled=\{null\}
			          rel=\{undefined\}
			        >
			          \{null\}
			          <span className=\{'_55pe'\} style=\{\{ maxWidth: '186px' \}\}>
			            <ReactImage70 />
			            \{'Search'\}
			          </span>
			          <ReactImage71 />
			        </a>
			      );
			    \}
			  \});
			
			  const AbstractButton73 = createClass(\{
			    render() \{
			      return <Link72 />;
			    \}
			  \});
			
			  const XUIButton74 = createClass(\{
			    render() \{
			      return <AbstractButton73 />;
			    \}
			  \});
			
			  const AbstractPopoverButton75 = createClass(\{
			    render() \{
			      return <XUIButton74 />;
			    \}
			  \});
			
			  const ReactXUIPopoverButton76 = createClass(\{
			    render() \{
			      return <AbstractPopoverButton75 />;
			    \}
			  \});
			
			  const ReactImage77 = createClass(\{
			    render() \{
			      return <i className=\{'_3-8_ img sp_UuU9HmrQ397 sx_81d5f0'\} src=\{null\} />;
			    \}
			  \});
			
			  const ReactImage78 = createClass(\{
			    render() \{
			      return <i alt=\{''\} className=\{'_3-99 img sp_UuU9HmrQ397 sx_7e56e9'\} src=\{null\} />;
			    \}
			  \});
			
			  const Link79 = createClass(\{
			    render() \{
			      return (
			        <a
			          style=\{\{ maxWidth: '200px' \}\}
			          image=\{null\}
			          label=\{null\}
			          imageRight=\{\{\}\}
			          className=\{' _5bbf _55pi _2agf  _5bbf _55pi _4jy0 _4jy4 _517h _51sy _42ft'\}
			          href=\{'#'\}
			          haschevron=\{true\}
			          onClick=\{function () \{\}\}
			          size=\{'large'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          disabled=\{null\}
			          rel=\{undefined\}
			        >
			          \{null\}
			          <span className=\{'_55pe'\} style=\{\{ maxWidth: '186px' \}\}>
			            <ReactImage77 />
			            \{'Filters'\}
			          </span>
			          <ReactImage78 />
			        </a>
			      );
			    \}
			  \});
			
			  const AbstractButton80 = createClass(\{
			    render() \{
			      return <Link79 />;
			    \}
			  \});
			
			  const XUIButton81 = createClass(\{
			    render() \{
			      return <AbstractButton80 />;
			    \}
			  \});
			
			  const AbstractPopoverButton82 = createClass(\{
			    render() \{
			      return <XUIButton81 />;
			    \}
			  \});
			
			  const ReactXUIPopoverButton83 = createClass(\{
			    render() \{
			      return <AbstractPopoverButton82 />;
			    \}
			  \});
			
			  const AdsPEFiltersPopover84 = createClass(\{
			    render() \{
			      return (
			        <span className=\{'_5b-l  _5bbe'\}>
			          <ReactXUIPopoverButton76 />
			          <ReactXUIPopoverButton83 />
			        </span>
			      );
			    \}
			  \});
			
			  const ReactImage85 = createClass(\{
			    render() \{
			      return <i className=\{'_3yz6 _5whs img sp_UuU9HmrQ397 sx_5fe5c2'\} src=\{null\} />;
			    \}
			  \});
			
			  const AbstractButton86 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_3yz9 _1t-2 _50z_ _50zy _50zz _50z- _5upp _42ft'\}
			          size=\{'small'\}
			          onClick=\{function () \{\}\}
			          shade=\{'dark'\}
			          type=\{'button'\}
			          label=\{null\}
			          title=\{'Remove'\}
			          aria-label=\{undefined\}
			          data-hover=\{undefined\}
			          data-tooltip-alignh=\{undefined\}
			        >
			          \{undefined\}
			          \{'Remove'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIAbstractGlyphButton87 = createClass(\{
			    render() \{
			      return <AbstractButton86 />;
			    \}
			  \});
			
			  const XUICloseButton88 = createClass(\{
			    render() \{
			      return <XUIAbstractGlyphButton87 />;
			    \}
			  \});
			
			  const ReactImage89 = createClass(\{
			    render() \{
			      return <i className=\{'_5b5p _4gem img sp_UuU9HmrQ397 sx_5fe5c2'\} src=\{null\} />;
			    \}
			  \});
			
			  const ReactImage90 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'_541d img sp_R48dKBxiJkP sx_dc2cdb'\} />;
			    \}
			  \});
			
			  const AdsPopoverLink91 = createClass(\{
			    render() \{
			      return (
			        <span onMouseEnter=\{function () \{\}\} onMouseLeave=\{function () \{\}\}>
			          <span className=\{'_3o_j'\} />
			          <ReactImage90 />
			        </span>
			      );
			    \}
			  \});
			
			  const AdsHelpLink92 = createClass(\{
			    render() \{
			      return <AdsPopoverLink91 />;
			    \}
			  \});
			
			  const AbstractButton93 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_5b5u _5b5v _4jy0 _4jy3 _517h _51sy _42ft'\}
			          label=\{null\}
			          use=\{'default'\}
			          onClick=\{function () \{\}\}
			          size=\{'medium'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          \{'Apply'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton94 = createClass(\{
			    render() \{
			      return <AbstractButton93 />;
			    \}
			  \});
			
			  const BUIFilterTokenInput95 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5b5o _3yz3 _4cld'\}>
			          <div className=\{'_5b5t _2d2k'\}>
			            <ReactImage89 />
			            <div className=\{'_5b5r'\}>
			              \{'Ads: (1)'\}
			              <AdsHelpLink92 />
			            </div>
			          </div>
			          <XUIButton94 />
			        </div>
			      );
			    \}
			  \});
			
			  const BUIFilterToken96 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3yz1 _3yz2 _3dad'\}>
			          <div aria-hidden=\{false\}>
			            <div onClick=\{function () \{\}\} className=\{'_3yz5'\}>
			              <ReactImage85 />
			              <div className=\{'_3yz7'\}>\{'Ads:'\}</div>
			              <div className=\{'ellipsis _3yz8'\} data-hover=\{'tooltip'\} data-tooltip-display=\{'overflow'\}>
			                \{'(1)'\}
			              </div>
			            </div>
			            <XUICloseButton88 />
			          </div>
			          <BUIFilterTokenInput95 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage97 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_158e8d'\} />;
			    \}
			  \});
			
			  const AbstractButton98 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_1wdf _4jy0 _517i _517h _51sy _42ft'\}
			          size=\{'small'\}
			          onClick=\{function () \{\}\}
			          image=\{\{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage97 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton99 = createClass(\{
			    render() \{
			      return <AbstractButton98 />;
			    \}
			  \});
			
			  const BUIFilterTokenCreateButton100 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1tc'\}>
			          <XUIButton99 />
			        </div>
			      );
			    \}
			  \});
			
			  const BUIFilterTokenizer101 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5b-m _3o1v clearfix'\}>
			          \{undefined\}
			          \{[]\}
			          <BUIFilterToken96 key=\{'token0'\} />
			          <BUIFilterTokenCreateButton100 />
			          \{null\}
			          <div className=\{'_49u3'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEAmbientNUXMegaphone102 = createClass(\{
			    render() \{
			      return <span />;
			    \}
			  \});
			
			  const AdsPEFilters103 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4rw_'\}>
			          <AdsPEFiltersPopover84 />
			          \{null\}
			          <BUIFilterTokenizer101 />
			          \{''\}
			          <AdsPEAmbientNUXMegaphone102 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEFilterContainer104 = createClass(\{
			    render() \{
			      return <AdsPEFilters103 />;
			    \}
			  \});
			
			  const AdsPECampaignTimeLimitNotice105 = createClass(\{
			    render() \{
			      return <div />;
			    \}
			  \});
			
			  const AdsPECampaignTimeLimitNoticeContainer106 = createClass(\{
			    render() \{
			      return <AdsPECampaignTimeLimitNotice105 />;
			    \}
			  \});
			
			  const AdsPETablePager107 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEAdgroupTablePagerContainer108 = createClass(\{
			    render() \{
			      return <AdsPETablePager107 />;
			    \}
			  \});
			
			  const AdsPETablePagerContainer109 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupTablePagerContainer108 />;
			    \}
			  \});
			
			  const ReactImage110 = createClass(\{
			    render() \{
			      return <i alt=\{''\} className=\{'_3-99 img sp_UuU9HmrQ397 sx_132804'\} src=\{null\} />;
			    \}
			  \});
			
			  const Link111 = createClass(\{
			    render() \{
			      return (
			        <a
			          style=\{\{ maxWidth: '200px' \}\}
			          image=\{null\}
			          label=\{null\}
			          imageRight=\{\{\}\}
			          className=\{'_55pi _2agf _55pi _4jy0 _4jy4 _517h _51sy _42ft'\}
			          href=\{'#'\}
			          disabled=\{null\}
			          maxwidth=\{undefined\}
			          size=\{'large'\}
			          suppressed=\{false\}
			          chevron=\{\{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          onClick=\{function () \{\}\}
			          rel=\{undefined\}
			        >
			          \{null\}
			          <span className=\{'_55pe'\} style=\{\{ maxWidth: '186px' \}\}>
			            \{null\}
			            \{'Lifetime'\}
			          </span>
			          <ReactImage110 />
			        </a>
			      );
			    \}
			  \});
			
			  const AbstractButton112 = createClass(\{
			    render() \{
			      return <Link111 />;
			    \}
			  \});
			
			  const XUIButton113 = createClass(\{
			    render() \{
			      return <AbstractButton112 />;
			    \}
			  \});
			
			  const AbstractPopoverButton114 = createClass(\{
			    render() \{
			      return <XUIButton113 />;
			    \}
			  \});
			
			  const ReactXUIPopoverButton115 = createClass(\{
			    render() \{
			      return <AbstractPopoverButton114 />;
			    \}
			  \});
			
			  const XUISingleSelectorButton116 = createClass(\{
			    render() \{
			      return <ReactXUIPopoverButton115 />;
			    \}
			  \});
			
			  const InlineBlock117 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_3c5o _3c5p _6a _6b'\}
			          defaultValue=\{'LIFETIME'\}
			          size=\{'large'\}
			          onChange=\{function () \{\}\}
			          disabled=\{false\}
			          alignv=\{'middle'\}
			          fullWidth=\{false\}
			        >
			          <input type=\{'hidden'\} autoComplete=\{'off'\} name=\{undefined\} value=\{'LIFETIME'\} />
			          <XUISingleSelectorButton116 />
			        </div>
			      );
			    \}
			  \});
			
			  const XUISingleSelector118 = createClass(\{
			    render() \{
			      return <InlineBlock117 />;
			    \}
			  \});
			
			  const ReactImage119 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_6c732d'\} />;
			    \}
			  \});
			
			  const AbstractButton120 = createClass(\{
			    render() \{
			      return (
			        <button
			          aria-label=\{'List Settings'\}
			          className=\{'_u_k _3c5o _1-r0 _4jy0 _4jy4 _517h _51sy _42ft'\}
			          data-hover=\{'tooltip'\}
			          image=\{\{\}\}
			          size=\{'large'\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage119 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton121 = createClass(\{
			    render() \{
			      return <AbstractButton120 />;
			    \}
			  \});
			
			  const AdsPEStatRange122 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3c5k'\}>
			          <span className=\{'_3c5j'\}>\{'Stats:'\}</span>
			          <span className=\{'_3c5l'\}>
			            <XUISingleSelector118 key=\{'range'\} />
			            \{null\}
			            <XUIButton121 key=\{'settings'\} />
			          </span>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEStatRangeContainer123 = createClass(\{
			    render() \{
			      return <AdsPEStatRange122 />;
			    \}
			  \});
			
			  const Column124 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4bl8 _4bl7'\}>
			          <div className=\{'_3c5f'\}>
			            \{null\}
			            <AdsPETablePagerContainer109 />
			            <div className=\{'_3c5i'\} />
			            <AdsPEStatRangeContainer123 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage125 = createClass(\{
			    render() \{
			      return <i alt=\{''\} className=\{'_3-8_ img sp_UuU9HmrQ397 sx_158e8d'\} src=\{null\} />;
			    \}
			  \});
			
			  const AbstractButton126 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_u_k _4jy0 _4jy4 _517h _51sy _42ft'\}
			          label=\{null\}
			          size=\{'large'\}
			          onClick=\{function () \{\}\}
			          image=\{\{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage125 />
			          \{'Create Ad'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton127 = createClass(\{
			    render() \{
			      return <AbstractButton126 />;
			    \}
			  \});
			
			  const ReactImage128 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_d5a685'\} />;
			    \}
			  \});
			
			  const AbstractButton129 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_u_k _p _4jy0 _4jy4 _517h _51sy _42ft'\}
			          image=\{\{\}\}
			          size=\{'large'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage128 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton130 = createClass(\{
			    render() \{
			      return <AbstractButton129 />;
			    \}
			  \});
			
			  const InlineBlock131 = createClass(\{
			    render() \{
			      return (
			        <div menu=\{\{\}\} alignh=\{'right'\} layerBehaviors=\{\{\}\} alignv=\{'middle'\} className=\{'uiPopover _6a _6b'\} disabled=\{null\} fullWidth=\{false\}>
			          <XUIButton130 key=\{'/.0'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactPopoverMenu132 = createClass(\{
			    render() \{
			      return <InlineBlock131 />;
			    \}
			  \});
			
			  const XUIButtonGroup133 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5n7z _51xa'\}>
			          <XUIButton127 />
			          <ReactPopoverMenu132 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage134 = createClass(\{
			    render() \{
			      return <i alt=\{''\} className=\{'_3-8_ img sp_UuU9HmrQ397 sx_990b54'\} src=\{null\} />;
			    \}
			  \});
			
			  const AbstractButton135 = createClass(\{
			    render() \{
			      return (
			        <button
			          size=\{'large'\}
			          disabled=\{false\}
			          className=\{'_d2_ _u_k _5n7z _4jy0 _4jy4 _517h _51sy _42ft'\}
			          image=\{\{\}\}
			          data-hover=\{'tooltip'\}
			          aria-label=\{'Edit Ads (Ctrl+U)'\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          label=\{null\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage134 />
			          \{'Edit'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton136 = createClass(\{
			    render() \{
			      return <AbstractButton135 />;
			    \}
			  \});
			
			  const ReactImage137 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_203adb'\} />;
			    \}
			  \});
			
			  const AbstractButton138 = createClass(\{
			    render() \{
			      return (
			        <button
			          aria-label=\{'Duplicate'\}
			          className=\{'_u_k _4jy0 _4jy4 _517h _51sy _42ft'\}
			          data-hover=\{'tooltip'\}
			          disabled=\{false\}
			          image=\{\{\}\}
			          size=\{'large'\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage137 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton139 = createClass(\{
			    render() \{
			      return <AbstractButton138 />;
			    \}
			  \});
			
			  const ReactImage140 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_0c342e'\} />;
			    \}
			  \});
			
			  const AbstractButton141 = createClass(\{
			    render() \{
			      return (
			        <button
			          aria-label=\{'Revert'\}
			          className=\{'_u_k _4jy0 _4jy4 _517h _51sy _42ft _42fr'\}
			          data-hover=\{'tooltip'\}
			          disabled=\{true\}
			          image=\{\{\}\}
			          size=\{'large'\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage140 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton142 = createClass(\{
			    render() \{
			      return <AbstractButton141 />;
			    \}
			  \});
			
			  const ReactImage143 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_0e75f5'\} />;
			    \}
			  \});
			
			  const AbstractButton144 = createClass(\{
			    render() \{
			      return (
			        <button
			          aria-label=\{'Delete'\}
			          className=\{'_u_k _4jy0 _4jy4 _517h _51sy _42ft'\}
			          image=\{\{\}\}
			          data-hover=\{'tooltip'\}
			          disabled=\{false\}
			          size=\{'large'\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage143 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton145 = createClass(\{
			    render() \{
			      return <AbstractButton144 />;
			    \}
			  \});
			
			  const XUIButtonGroup146 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5n7z _51xa'\}>
			          <XUIButton139 key=\{'duplicate'\} />
			          <XUIButton142 key=\{'revert'\} />
			          <XUIButton145 key=\{'delete'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage147 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_8c19ae'\} />;
			    \}
			  \});
			
			  const AbstractButton148 = createClass(\{
			    render() \{
			      return (
			        <button
			          size=\{'large'\}
			          disabled=\{false\}
			          className=\{'_u_k _4jy0 _4jy4 _517h _51sy _42ft'\}
			          image=\{\{\}\}
			          data-hover=\{'tooltip'\}
			          aria-label=\{'Save Audience'\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage147 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton149 = createClass(\{
			    render() \{
			      return <AbstractButton148 />;
			    \}
			  \});
			
			  const ReactImage150 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_d2b33c'\} />;
			    \}
			  \});
			
			  const AbstractButton151 = createClass(\{
			    render() \{
			      return (
			        <button
			          size=\{'large'\}
			          className=\{'_u_k noMargin _p _4jy0 _4jy4 _517h _51sy _42ft'\}
			          onClick=\{function () \{\}\}
			          image=\{\{\}\}
			          data-hover=\{'tooltip'\}
			          aria-label=\{'Export & Import'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage150 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton152 = createClass(\{
			    render() \{
			      return <AbstractButton151 />;
			    \}
			  \});
			
			  const InlineBlock153 = createClass(\{
			    render() \{
			      return (
			        <div menu=\{\{\}\} size=\{'large'\} alignv=\{'middle'\} className=\{'uiPopover _6a _6b'\} disabled=\{null\} fullWidth=\{false\}>
			          <XUIButton152 key=\{'/.0'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactPopoverMenu154 = createClass(\{
			    render() \{
			      return <InlineBlock153 />;
			    \}
			  \});
			
			  const AdsPEExportImportMenu155 = createClass(\{
			    render() \{
			      return <ReactPopoverMenu154 key=\{'export'\} />;
			    \}
			  \});
			
			  const FluxContainer_x_156 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEExportAsTextDialog157 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const FluxContainer_q_158 = createClass(\{
			    render() \{
			      return <AdsPEExportAsTextDialog157 />;
			    \}
			  \});
			
			  const AdsPEExportImportMenuContainer159 = createClass(\{
			    render() \{
			      return (
			        <span>
			          <AdsPEExportImportMenu155 />
			          <FluxContainer_x_156 />
			          <FluxContainer_q_158 />
			          \{null\}
			        </span>
			      );
			    \}
			  \});
			
			  const ReactImage160 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img sp_UuU9HmrQ397 sx_872db1'\} />;
			    \}
			  \});
			
			  const AbstractButton161 = createClass(\{
			    render() \{
			      return (
			        <button
			          size=\{'large'\}
			          disabled=\{false\}
			          onClick=\{function () \{\}\}
			          className=\{'_u_k _5n7z _4jy0 _4jy4 _517h _51sy _42ft'\}
			          image=\{\{\}\}
			          style=\{\{ boxSizing: 'border-box', height: '28px', width: '48px' \}\}
			          data-hover=\{'tooltip'\}
			          aria-label=\{'Create Report'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          label=\{null\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          <ReactImage160 />
			          \{undefined\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton162 = createClass(\{
			    render() \{
			      return <AbstractButton161 />;
			    \}
			  \});
			
			  const AbstractButton163 = createClass(\{
			    render() \{
			      return (
			        <button
			          size=\{'large'\}
			          disabled=\{true\}
			          className=\{'hidden_elem _5n7z _4jy0 _4jy4 _517h _51sy _42ft _42fr'\}
			          label=\{null\}
			          onClick=\{function () \{\}\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          \{'Generate Variations'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton164 = createClass(\{
			    render() \{
			      return <AbstractButton163 />;
			    \}
			  \});
			
			  const XUIButtonGroup165 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5n7z _51xa'\}>
			          <XUIButton149 key=\{'saveAudience'\} />
			          <AdsPEExportImportMenuContainer159 key="159" />
			          <XUIButton162 key=\{'createReport'\} />
			          <XUIButton164 key=\{'variations'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const FillColumn166 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4bl9'\}>
			          <span className=\{'_3c5e'\}>
			            <span>
			              <XUIButtonGroup133 />
			              <XUIButton136 />
			              <XUIButtonGroup146 />
			            </span>
			            <XUIButtonGroup165 />
			          </span>
			        </div>
			      );
			    \}
			  \});
			
			  const Layout167 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'clearfix'\}>
			          <Column124 key=\{'1'\} />
			          <FillColumn166 key=\{'0'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEMainPaneToolbar168 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3c5b clearfix'\}>
			          <Layout167 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEAdgroupToolbarContainer169 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsPEMainPaneToolbar168 />
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AbstractButton170 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_tm3 _tm6 _4jy0 _4jy6 _517h _51sy _42ft'\}
			          label=\{null\}
			          data-tooltip-position=\{'right'\}
			          aria-label=\{'Campaigns'\}
			          data-hover=\{'tooltip'\}
			          onClick=\{function () \{\}\}
			          size=\{'xxlarge'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          <div>
			            <div className=\{'_tma'\} />
			            <div className=\{'_tm8'\} />
			            <div className=\{'_tm9'\}>\{1\}</div>
			          </div>
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton171 = createClass(\{
			    render() \{
			      return <AbstractButton170 />;
			    \}
			  \});
			
			  const AbstractButton172 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_tm4 _tm6 _4jy0 _4jy6 _517h _51sy _42ft'\}
			          label=\{null\}
			          data-tooltip-position=\{'right'\}
			          aria-label=\{'Ad Sets'\}
			          data-hover=\{'tooltip'\}
			          onClick=\{function () \{\}\}
			          size=\{'xxlarge'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          <div>
			            <div className=\{'_tma'\} />
			            <div className=\{'_tm8'\} />
			            <div className=\{'_tm9'\}>\{1\}</div>
			          </div>
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton173 = createClass(\{
			    render() \{
			      return <AbstractButton172 />;
			    \}
			  \});
			
			  const AbstractButton174 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_tm5 _tm6 _tm7 _4jy0 _4jy6 _517h _51sy _42ft'\}
			          label=\{null\}
			          data-tooltip-position=\{'right'\}
			          aria-label=\{'Ads'\}
			          data-hover=\{'tooltip'\}
			          onClick=\{function () \{\}\}
			          size=\{'xxlarge'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          <div>
			            <div className=\{'_tma'\} />
			            <div className=\{'_tm8'\} />
			            <div className=\{'_tm9'\}>\{1\}</div>
			          </div>
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton175 = createClass(\{
			    render() \{
			      return <AbstractButton174 />;
			    \}
			  \});
			
			  const AdsPESimpleOrganizer176 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_tm2'\}>
			          <XUIButton171 />
			          <XUIButton173 />
			          <XUIButton175 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEOrganizerContainer177 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsPESimpleOrganizer176 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableColumnResizeHandle178 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3487 _3488 _3489'\} style=\{\{ width: 0, height: 532, left: 0 \}\}>
			          <div className=\{'_348a'\} style=\{\{ height: 532 \}\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage179 = createClass(\{
			    render() \{
			      return <i className=\{'_1cie _1cif img sp_R48dKBxiJkP sx_dc0ad2'\} src=\{null\} />;
			    \}
			  \});
			
			  const AdsPETableHeader180 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _1ksv _1vd7 _4h2r'\}>
			          <ReactImage179 />
			          <span className=\{'_1cid'\}>\{'Ads'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell181 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Ads'\}
			          dataKey=\{0\}
			          groupHeaderRenderer=\{function () \{\}\}
			          groupHeaderLabels=\{\{\}\}
			          groupHeaderData=\{\{\}\}
			          columnKey=\{undefined\}
			          height=\{40\}
			          width=\{521\}
			          rowIndex=\{0\}
			          className=\{'_4lgc _4h2u'\}
			          style=\{\{ height: 40, width: 521 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader180 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell182 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 40, width: 521, left: 0 \}\}>
			          \{undefined\}
			          <TransitionCell181 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroupImpl183 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_3pzj'\}
			          style=\{\{
			            height: 40,
			            position: 'absolute',
			            width: 521,
			            zIndex: 2,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			        >
			          <FixedDataTableCell182 key=\{'cell_0'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroup184 = createClass(\{
			    render() \{
			      return (
			        <div style=\{\{ height: 40, left: 0 \}\} className=\{'_3pzk'\}>
			          <FixedDataTableCellGroupImpl183 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader185 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _1vd7 _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Delivery'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell186 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Delivery'\}
			          dataKey=\{1\}
			          groupHeaderRenderer=\{function () \{\}\}
			          groupHeaderLabels=\{\{\}\}
			          groupHeaderData=\{\{\}\}
			          columnKey=\{undefined\}
			          height=\{40\}
			          width=\{298\}
			          rowIndex=\{0\}
			          className=\{'_4lgc _4h2u'\}
			          style=\{\{ height: 40, width: 298 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader185 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell187 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 40, width: 298, left: 0 \}\}>
			          \{undefined\}
			          <TransitionCell186 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader188 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _1vd7 _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Performance'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell189 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Performance'\}
			          dataKey=\{2\}
			          groupHeaderRenderer=\{function () \{\}\}
			          groupHeaderLabels=\{\{\}\}
			          groupHeaderData=\{\{\}\}
			          columnKey=\{undefined\}
			          height=\{40\}
			          width=\{490\}
			          rowIndex=\{0\}
			          className=\{'_4lgc _4h2u'\}
			          style=\{\{ height: 40, width: 490 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader188 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell190 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 40, width: 490, left: 298 \}\}>
			          \{undefined\}
			          <TransitionCell189 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader191 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _1vd7 _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Overview'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell192 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Overview'\}
			          dataKey=\{3\}
			          groupHeaderRenderer=\{function () \{\}\}
			          groupHeaderLabels=\{\{\}\}
			          groupHeaderData=\{\{\}\}
			          columnKey=\{undefined\}
			          height=\{40\}
			          width=\{972\}
			          rowIndex=\{0\}
			          className=\{'_4lgc _4h2u'\}
			          style=\{\{ height: 40, width: 972 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader191 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell193 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 40, width: 972, left: 788 \}\}>
			          \{undefined\}
			          <TransitionCell192 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader194 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _1vd7 _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Creative Assets'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell195 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Creative Assets'\}
			          dataKey=\{4\}
			          groupHeaderRenderer=\{function () \{\}\}
			          groupHeaderLabels=\{\{\}\}
			          groupHeaderData=\{\{\}\}
			          columnKey=\{undefined\}
			          height=\{40\}
			          width=\{514\}
			          rowIndex=\{0\}
			          className=\{'_4lgc _4h2u'\}
			          style=\{\{ height: 40, width: 514 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader194 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell196 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 40, width: 514, left: 1760 \}\}>
			          \{undefined\}
			          <TransitionCell195 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader197 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _1vd7 _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Toplines'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell198 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Toplines'\}
			          dataKey=\{5\}
			          groupHeaderRenderer=\{function () \{\}\}
			          groupHeaderLabels=\{\{\}\}
			          groupHeaderData=\{\{\}\}
			          columnKey=\{undefined\}
			          height=\{40\}
			          width=\{0\}
			          rowIndex=\{0\}
			          className=\{'_4lgc _4h2u'\}
			          style=\{\{ height: 40, width: 0 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader197 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell199 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 40, width: 0, left: 2274 \}\}>
			          \{undefined\}
			          <TransitionCell198 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader200 = createClass(\{
			    render() \{
			      return <div className=\{'_1cig _1vd7 _4h2r'\} />;
			    \}
			  \});
			
			  const TransitionCell201 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{''\}
			          dataKey=\{6\}
			          groupHeaderRenderer=\{function () \{\}\}
			          groupHeaderLabels=\{\{\}\}
			          groupHeaderData=\{\{\}\}
			          columnKey=\{undefined\}
			          height=\{40\}
			          width=\{25\}
			          rowIndex=\{0\}
			          className=\{'_4lgc _4h2u'\}
			          style=\{\{ height: 40, width: 25 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader200 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell202 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 40, width: 25, left: 2274 \}\}>
			          \{undefined\}
			          <TransitionCell201 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroupImpl203 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_3pzj'\}
			          style=\{\{
			            height: 40,
			            position: 'absolute',
			            width: 2299,
			            zIndex: 0,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			        >
			          <FixedDataTableCell187 key=\{'cell_0'\} />
			          <FixedDataTableCell190 key=\{'cell_1'\} />
			          <FixedDataTableCell193 key=\{'cell_2'\} />
			          <FixedDataTableCell196 key=\{'cell_3'\} />
			          <FixedDataTableCell199 key=\{'cell_4'\} />
			          <FixedDataTableCell202 key=\{'cell_5'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroup204 = createClass(\{
			    render() \{
			      return (
			        <div style=\{\{ height: 40, left: 521 \}\} className=\{'_3pzk'\}>
			          <FixedDataTableCellGroupImpl203 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableRowImpl205 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_1gd4 _4li _52no _3h1a _1mib'\}
			          onClick=\{null\}
			          onDoubleClick=\{null\}
			          onMouseDown=\{null\}
			          onMouseEnter=\{null\}
			          onMouseLeave=\{null\}
			          style=\{\{ width: 1083, height: 40 \}\}
			        >
			          <div className=\{'_1gd5'\}>
			            <FixedDataTableCellGroup184 key=\{'fixed_cells'\} />
			            <FixedDataTableCellGroup204 key=\{'scrollable_cells'\} />
			            <div key="_1gd6 _1gd8" className=\{'_1gd6 _1gd8'\} style=\{\{ left: 521, height: 40 \}\} />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableRow206 = createClass(\{
			    render() \{
			      return (
			        <div
			          style=\{\{
			            width: 1083,
			            height: 40,
			            zIndex: 1,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			          className=\{'_1gda'\}
			        >
			          <FixedDataTableRowImpl205 />
			        </div>
			      );
			    \}
			  \});
			
			  const AbstractCheckboxInput207 = createClass(\{
			    render() \{
			      return (
			        <label className=\{'_4h2r _55sg _kv1'\}>
			          <input checked=\{undefined\} onChange=\{function () \{\}\} className=\{null\} type=\{'checkbox'\} />
			          <span data-hover=\{null\} aria-label=\{undefined\} />
			        </label>
			      );
			    \}
			  \});
			
			  const XUICheckboxInput208 = createClass(\{
			    render() \{
			      return <AbstractCheckboxInput207 />;
			    \}
			  \});
			
			  const TransitionCell209 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{undefined\}
			          width=\{42\}
			          dataKey=\{'common.id'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'common.id'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 42 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <XUICheckboxInput208 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell210 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg6 _4h2m'\} style=\{\{ height: 25, width: 42, left: 0 \}\}>
			          \{undefined\}
			          <TransitionCell209 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader211 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Ad Name'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader212 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader211 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader213 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader212 />;
			    \}
			  \});
			
			  const TransitionCell214 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Ad Name'\}
			          width=\{200\}
			          dataKey=\{'ad.name'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.name'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 200 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader213 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell215 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 200, left: 42 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell214 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage216 = createClass(\{
			    render() \{
			      return <i className=\{'_1cie img sp_UuU9HmrQ397 sx_844e7d'\} src=\{null\} />;
			    \}
			  \});
			
			  const AdsPETableHeader217 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          <ReactImage216 />
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader218 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _1kst _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader217 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader219 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader218 />;
			    \}
			  \});
			
			  const TransitionCell220 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{undefined\}
			          width=\{33\}
			          dataKey=\{'edit_status'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'edit_status'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 33 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader219 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell221 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 33, left: 242 \}\}>
			          \{undefined\}
			          <TransitionCell220 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage222 = createClass(\{
			    render() \{
			      return <i className=\{'_1cie img sp_UuU9HmrQ397 sx_36dc45'\} src=\{null\} />;
			    \}
			  \});
			
			  const AdsPETableHeader223 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          <ReactImage222 />
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader224 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _1kst _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader223 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader225 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader224 />;
			    \}
			  \});
			
			  const TransitionCell226 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{undefined\}
			          width=\{36\}
			          dataKey=\{'errors'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'errors'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 36 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader225 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell227 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 36, left: 275 \}\}>
			          \{undefined\}
			          <TransitionCell226 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader228 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Status'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader229 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader228 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader230 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader229 />;
			    \}
			  \});
			
			  const TransitionCell231 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Status'\}
			          width=\{60\}
			          dataKey=\{'ad.adgroup_status'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.adgroup_status'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 60 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader230 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell232 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 60, left: 311 \}\}>
			          \{undefined\}
			          <TransitionCell231 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader233 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Delivery'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader234 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader233 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader235 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader234 />;
			    \}
			  \});
			
			  const TransitionCell236 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Delivery'\}
			          width=\{150\}
			          dataKey=\{'ukiAdData.computed_activity_status'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ukiAdData.computed_activity_status'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 150 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader235 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell237 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 150, left: 371 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell236 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroupImpl238 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_3pzj'\}
			          style=\{\{
			            height: 25,
			            position: 'absolute',
			            width: 521,
			            zIndex: 2,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			        >
			          <FixedDataTableCell210 key=\{'cell_0'\} />
			          <FixedDataTableCell215 key=\{'cell_1'\} />
			          <FixedDataTableCell221 key=\{'cell_2'\} />
			          <FixedDataTableCell227 key=\{'cell_3'\} />
			          <FixedDataTableCell232 key=\{'cell_4'\} />
			          <FixedDataTableCell237 key=\{'cell_5'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroup239 = createClass(\{
			    render() \{
			      return (
			        <div style=\{\{ height: 25, left: 0 \}\} className=\{'_3pzk'\}>
			          <FixedDataTableCellGroupImpl238 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader240 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Reach'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader241 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader240 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader242 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader241 />;
			    \}
			  \});
			
			  const TransitionCell243 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Reach'\}
			          width=\{60\}
			          dataKey=\{'stats.unique_impressions'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.unique_impressions'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 60 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader242 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell244 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 60, left: 0 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell243 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader245 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Ad Impressions'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader246 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader245 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader247 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader246 />;
			    \}
			  \});
			
			  const TransitionCell248 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Ad Impressions'\}
			          width=\{80\}
			          dataKey=\{'stats.impressions'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.impressions'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader247 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell249 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 80, left: 60 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell248 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader250 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Avg. CPM'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader251 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader250 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader252 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader251 />;
			    \}
			  \});
			
			  const TransitionCell253 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Avg. CPM'\}
			          width=\{80\}
			          dataKey=\{'stats.avg_cpm'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.avg_cpm'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader252 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell254 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 80, left: 140 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell253 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader255 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Avg. CPC'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader256 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader255 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader257 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader256 />;
			    \}
			  \});
			
			  const TransitionCell258 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Avg. CPC'\}
			          width=\{78\}
			          dataKey=\{'stats.avg_cpc'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.avg_cpc'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 78 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader257 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell259 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 78, left: 220 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell258 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader260 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Results'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell261 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Results'\}
			          width=\{140\}
			          dataKey=\{'stats.actions'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.actions'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 140 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader260 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell262 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 140, left: 298 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell261 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader263 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Cost'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell264 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Cost'\}
			          width=\{140\}
			          dataKey=\{'stats.cpa'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.cpa'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 140 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader263 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell265 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 140, left: 438 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell264 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader266 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Clicks'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader267 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader266 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader268 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader267 />;
			    \}
			  \});
			
			  const TransitionCell269 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Clicks'\}
			          width=\{60\}
			          dataKey=\{'stats.clicks'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.clicks'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 60 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader268 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell270 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 60, left: 578 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell269 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader271 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'CTR %'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader272 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader271 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader273 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader272 />;
			    \}
			  \});
			
			  const TransitionCell274 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'CTR %'\}
			          width=\{70\}
			          dataKey=\{'stats.ctr'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.ctr'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 70 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader273 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell275 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 70, left: 638 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell274 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader276 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Social %'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader277 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader276 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader278 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader277 />;
			    \}
			  \});
			
			  const TransitionCell279 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Social %'\}
			          width=\{80\}
			          dataKey=\{'stats.social_percent'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.social_percent'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader278 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell280 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 80, left: 708 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell279 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader281 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Ad Set Name'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader282 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader281 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader283 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader282 />;
			    \}
			  \});
			
			  const TransitionCell284 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Ad Set Name'\}
			          width=\{100\}
			          dataKey=\{'campaign.name'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'campaign.name'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 100 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader283 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell285 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 100, left: 788 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell284 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader286 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Campaign Name'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader287 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader286 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader288 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader287 />;
			    \}
			  \});
			
			  const TransitionCell289 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Campaign Name'\}
			          width=\{150\}
			          dataKey=\{'campaignGroup.name'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'campaignGroup.name'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 150 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader288 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell290 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 150, left: 888 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell289 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader291 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Ad ID'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader292 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader291 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader293 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader292 />;
			    \}
			  \});
			
			  const TransitionCell294 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Ad ID'\}
			          width=\{120\}
			          dataKey=\{'ad.id'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.id'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 120 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader293 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell295 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 120, left: 1038 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell294 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader296 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Objective'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader297 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader296 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader298 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader297 />;
			    \}
			  \});
			
			  const TransitionCell299 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Objective'\}
			          width=\{80\}
			          dataKey=\{'campaignGroup.objective'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'campaignGroup.objective'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader298 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell300 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 80, left: 1158 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell299 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader301 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Spent'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader302 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader301 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader303 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader302 />;
			    \}
			  \});
			
			  const TransitionCell304 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Spent'\}
			          width=\{70\}
			          dataKey=\{'stats.spent_100'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'stats.spent_100'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 70 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader303 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell305 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 25, width: 70, left: 1238 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell304 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader306 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Start'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader307 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader306 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader308 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader307 />;
			    \}
			  \});
			
			  const TransitionCell309 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Start'\}
			          width=\{113\}
			          dataKey=\{'derivedCampaign.startDate'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'derivedCampaign.startDate'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader308 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell310 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 113, left: 1308 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell309 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader311 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'End'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader312 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader311 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader313 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader312 />;
			    \}
			  \});
			
			  const TransitionCell314 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'End'\}
			          width=\{113\}
			          dataKey=\{'derivedCampaign.endDate'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'derivedCampaign.endDate'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader313 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell315 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 113, left: 1421 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell314 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader316 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Date created'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader317 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader316 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader318 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader317 />;
			    \}
			  \});
			
			  const TransitionCell319 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Date created'\}
			          width=\{113\}
			          dataKey=\{'ad.created_time'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.created_time'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader318 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell320 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 113, left: 1534 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell319 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader321 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Date last edited'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader322 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader321 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader323 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader322 />;
			    \}
			  \});
			
			  const TransitionCell324 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Date last edited'\}
			          width=\{113\}
			          dataKey=\{'ad.updated_time'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.updated_time'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader323 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell325 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 113, left: 1647 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell324 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader326 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Title'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader327 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader326 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader328 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader327 />;
			    \}
			  \});
			
			  const TransitionCell329 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Title'\}
			          width=\{80\}
			          dataKey=\{'ad.title'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.title'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader328 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell330 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 80, left: 1760 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell329 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader331 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Body'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader332 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader331 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader333 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader332 />;
			    \}
			  \});
			
			  const TransitionCell334 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Body'\}
			          width=\{80\}
			          dataKey=\{'ad.creative.body'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.creative.body'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader333 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell335 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 80, left: 1840 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell334 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader336 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Destination'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader337 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader336 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader338 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader337 />;
			    \}
			  \});
			
			  const TransitionCell339 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Destination'\}
			          width=\{92\}
			          dataKey=\{'destination'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'destination'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 92 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader338 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell340 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 92, left: 1920 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell339 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader341 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Link'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader342 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader341 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader343 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader342 />;
			    \}
			  \});
			
			  const TransitionCell344 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Link'\}
			          width=\{70\}
			          dataKey=\{'ad.creative.link_url'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.creative.link_url'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 70 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader343 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell345 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 70, left: 2012 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell344 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader346 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Related Page'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableAbstractSortableHeader347 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_54_8 _4h2r _2wzx'\}>
			          <div className=\{'_2eq6'\}>
			            \{null\}
			            <AdsPETableHeader346 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableSortableHeader348 = createClass(\{
			    render() \{
			      return <FixedDataTableAbstractSortableHeader347 />;
			    \}
			  \});
			
			  const TransitionCell349 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Related Page'\}
			          width=\{92\}
			          dataKey=\{'page'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'page'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 92 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <FixedDataTableSortableHeader348 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell350 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 92, left: 2082 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell349 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader351 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1cig _25fg _4h2r'\}>
			          \{null\}
			          <span className=\{'_1cid'\}>\{'Preview Link'\}</span>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell352 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{'Preview Link'\}
			          width=\{100\}
			          dataKey=\{'ad.demolink_hash'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'ad.demolink_hash'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 100 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader351 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell353 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 100, left: 2174 \}\}>
			          <div className=\{'_4lg9'\} style=\{\{ height: 25 \}\} onMouseDown=\{function () \{\}\}>
			            <div className=\{'_4lga _4lgb'\} style=\{\{ height: 25 \}\} />
			          </div>
			          <TransitionCell352 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPETableHeader354 = createClass(\{
			    render() \{
			      return <div className=\{'_1cig _25fg _4h2r'\} />;
			    \}
			  \});
			
			  const TransitionCell355 = createClass(\{
			    render() \{
			      return (
			        <div
			          isHeaderCell=\{true\}
			          label=\{''\}
			          width=\{25\}
			          dataKey=\{'scrollbar_spacer'\}
			          className=\{'_4lgc _4h2u'\}
			          columnData=\{\{\}\}
			          cellRenderer=\{function () \{\}\}
			          headerDataGetter=\{function () \{\}\}
			          columnKey=\{'scrollbar_spacer'\}
			          height=\{25\}
			          style=\{\{ height: 25, width: 25 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsPETableHeader354 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell356 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 25, width: 25, left: 2274 \}\}>
			          \{undefined\}
			          <TransitionCell355 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroupImpl357 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_3pzj'\}
			          style=\{\{
			            height: 25,
			            position: 'absolute',
			            width: 2299,
			            zIndex: 0,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			        >
			          <FixedDataTableCell244 key=\{'cell_0'\} />
			          <FixedDataTableCell249 key=\{'cell_1'\} />
			          <FixedDataTableCell254 key=\{'cell_2'\} />
			          <FixedDataTableCell259 key=\{'cell_3'\} />
			          <FixedDataTableCell262 key=\{'cell_4'\} />
			          <FixedDataTableCell265 key=\{'cell_5'\} />
			          <FixedDataTableCell270 key=\{'cell_6'\} />
			          <FixedDataTableCell275 key=\{'cell_7'\} />
			          <FixedDataTableCell280 key=\{'cell_8'\} />
			          <FixedDataTableCell285 key=\{'cell_9'\} />
			          <FixedDataTableCell290 key=\{'cell_10'\} />
			          <FixedDataTableCell295 key=\{'cell_11'\} />
			          <FixedDataTableCell300 key=\{'cell_12'\} />
			          <FixedDataTableCell305 key=\{'cell_13'\} />
			          <FixedDataTableCell310 key=\{'cell_14'\} />
			          <FixedDataTableCell315 key=\{'cell_15'\} />
			          <FixedDataTableCell320 key=\{'cell_16'\} />
			          <FixedDataTableCell325 key=\{'cell_17'\} />
			          <FixedDataTableCell330 key=\{'cell_18'\} />
			          <FixedDataTableCell335 key=\{'cell_19'\} />
			          <FixedDataTableCell340 key=\{'cell_20'\} />
			          <FixedDataTableCell345 key=\{'cell_21'\} />
			          <FixedDataTableCell350 key=\{'cell_22'\} />
			          <FixedDataTableCell353 key=\{'cell_23'\} />
			          <FixedDataTableCell356 key=\{'cell_24'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroup358 = createClass(\{
			    render() \{
			      return (
			        <div style=\{\{ height: 25, left: 521 \}\} className=\{'_3pzk'\}>
			          <FixedDataTableCellGroupImpl357 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableRowImpl359 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_1gd4 _4li _3h1a _1mib'\}
			          onClick=\{null\}
			          onDoubleClick=\{null\}
			          onMouseDown=\{null\}
			          onMouseEnter=\{null\}
			          onMouseLeave=\{null\}
			          style=\{\{ width: 1083, height: 25 \}\}
			        >
			          <div className=\{'_1gd5'\}>
			            <FixedDataTableCellGroup239 key=\{'fixed_cells'\} />
			            <FixedDataTableCellGroup358 key=\{'scrollable_cells'\} />
			            <div key="_1gd6 _1gd8" className=\{'_1gd6 _1gd8'\} style=\{\{ left: 521, height: 25 \}\} />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableRow360 = createClass(\{
			    render() \{
			      return (
			        <div
			          style=\{\{
			            width: 1083,
			            height: 25,
			            zIndex: 1,
			            transform: 'translate3d(0px,40px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			          className=\{'_1gda'\}
			        >
			          <FixedDataTableRowImpl359 />
			        </div>
			      );
			    \}
			  \});
			
			  const AbstractCheckboxInput361 = createClass(\{
			    render() \{
			      return (
			        <label className=\{'_5hhv _55sg _kv1'\}>
			          <input className=\{null\} disabled=\{false\} inline=\{true\} checked=\{true\} value=\{undefined\} onChange=\{function () \{\}\} type=\{'checkbox'\} />
			          <span data-hover=\{null\} aria-label=\{undefined\} />
			        </label>
			      );
			    \}
			  \});
			
			  const XUICheckboxInput362 = createClass(\{
			    render() \{
			      return <AbstractCheckboxInput361 />;
			    \}
			  \});
			
			  const TransitionCell363 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'common.id'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{42\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'common.id'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 42 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <span className=\{'_5hhu _4h2r'\} onMouseDown=\{function () \{\}\}>
			                <XUICheckboxInput362 />
			              </span>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell364 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg6 _4h2m'\} style=\{\{ height: 32, width: 42, left: 0 \}\}>
			          \{undefined\}
			          <TransitionCell363 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsEditableTextCellDisplay365 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_vew'\} onDoubleClick=\{function () \{\}\} onMouseEnter=\{function () \{\}\} onMouseLeave=\{function () \{\}\}>
			          <div className=\{'_vex _5w6k'\}>
			            <div className=\{'_vey'\}>\{'Test Ad'\}</div>
			            <div className=\{'_5w6_'\} />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsEditableCell366 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_2d6h _2-ev _4h2r _5abb'\}>
			          <AdsEditableTextCellDisplay365 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell367 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.name'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{200\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.name'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 200 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <AdsEditableCell366 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell368 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 200, left: 42 \}\}>
			          \{undefined\}
			          <TransitionCell367 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellDefault369 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'edit_status'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{33\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'edit_status'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 33 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_4h2r'\}>\{''\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell370 = createClass(\{
			    render() \{
			      return <FixedDataTableCellDefault369 />;
			    \}
			  \});
			
			  const FixedDataTableCell371 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 33, left: 242 \}\}>
			          \{undefined\}
			          <TransitionCell370 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellDefault372 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'errors'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{36\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'errors'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 36 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_4h2r'\} />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell373 = createClass(\{
			    render() \{
			      return <FixedDataTableCellDefault372 />;
			    \}
			  \});
			
			  const FixedDataTableCell374 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 36, left: 275 \}\}>
			          \{undefined\}
			          <TransitionCell373 />
			        </div>
			      );
			    \}
			  \});
			
			  const BUISwitch375 = createClass(\{
			    render() \{
			      return (
			        <div
			          value=\{true\}
			          disabled=\{true\}
			          onToggle=\{function () \{\}\}
			          data-hover=\{'tooltip'\}
			          data-tooltip-position=\{'below'\}
			          aria-label=\{'Currently active and you can not deactivate it.'\}
			          animate=\{true\}
			          className=\{'_128j _128k _128m _128n'\}
			          role=\{'checkbox'\}
			          aria-checked=\{'true'\}
			        >
			          <div className=\{'_128o'\} onClick=\{function () \{\}\} onKeyDown=\{function () \{\}\} onMouseDown=\{function () \{\}\} tabIndex=\{'-1'\}>
			            <div className=\{'_128p'\} />
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsStatusSwitchInternal376 = createClass(\{
			    render() \{
			      return <BUISwitch375 />;
			    \}
			  \});
			
			  const AdsStatusSwitch377 = createClass(\{
			    render() \{
			      return <AdsStatusSwitchInternal376 />;
			    \}
			  \});
			
			  const TransitionCell378 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.adgroup_status'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{60\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.adgroup_status'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 60 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_15si _4h2r'\}>
			                <AdsStatusSwitch377 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell379 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 60, left: 311 \}\}>
			          \{undefined\}
			          <TransitionCell378 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage380 = createClass(\{
			    render() \{
			      return <i aria-label=\{'Pending Review'\} data-hover=\{'tooltip'\} className=\{'_4ms8 img sp_UuU9HmrQ397 sx_ced63f'\} src=\{null\} width=\{'7'\} height=\{'7'\} />;
			    \}
			  \});
			
			  const AdsPEActivityStatusIndicator381 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_k4-'\}>
			          <ReactImage380 />
			          \{'Pending Review'\}
			          \{undefined\}
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell382 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ukiAdData.computed_activity_status'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{150\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ukiAdData.computed_activity_status'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 150 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>
			                <AdsPEActivityStatusIndicator381 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell383 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 150, left: 371 \}\}>
			          \{undefined\}
			          <TransitionCell382 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroupImpl384 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_3pzj'\}
			          style=\{\{
			            height: 32,
			            position: 'absolute',
			            width: 521,
			            zIndex: 2,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			        >
			          <FixedDataTableCell364 key=\{'cell_0'\} />
			          <FixedDataTableCell368 key=\{'cell_1'\} />
			          <FixedDataTableCell371 key=\{'cell_2'\} />
			          <FixedDataTableCell374 key=\{'cell_3'\} />
			          <FixedDataTableCell379 key=\{'cell_4'\} />
			          <FixedDataTableCell383 key=\{'cell_5'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroup385 = createClass(\{
			    render() \{
			      return (
			        <div style=\{\{ height: 32, left: 0 \}\} className=\{'_3pzk'\}>
			          <FixedDataTableCellGroupImpl384 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell386 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.unique_impressions'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{60\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.unique_impressions'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 60 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell387 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 60, left: 0 \}\}>
			          \{undefined\}
			          <TransitionCell386 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell388 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.impressions'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{80\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.impressions'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell389 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 80, left: 60 \}\}>
			          \{undefined\}
			          <TransitionCell388 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell390 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.avg_cpm'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{80\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.avg_cpm'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell391 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 80, left: 140 \}\}>
			          \{undefined\}
			          <TransitionCell390 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell392 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.avg_cpc'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{78\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.avg_cpc'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 78 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell393 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 78, left: 220 \}\}>
			          \{undefined\}
			          <TransitionCell392 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell394 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.actions'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{140\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.actions'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 140 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell395 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 140, left: 298 \}\}>
			          \{undefined\}
			          <TransitionCell394 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell396 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.cpa'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{140\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.cpa'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 140 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell397 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 140, left: 438 \}\}>
			          \{undefined\}
			          <TransitionCell396 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell398 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.clicks'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{60\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.clicks'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 60 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell399 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 60, left: 578 \}\}>
			          \{undefined\}
			          <TransitionCell398 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell400 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.ctr'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{70\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.ctr'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 70 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell401 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 70, left: 638 \}\}>
			          \{undefined\}
			          <TransitionCell400 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell402 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.social_percent'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{80\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.social_percent'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell403 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 80, left: 708 \}\}>
			          \{undefined\}
			          <TransitionCell402 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellDefault404 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'campaign.name'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{100\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{undefined\}
			          columnKey=\{'campaign.name'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 100 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_4h2r'\}>\{'Test Ad Set'\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell405 = createClass(\{
			    render() \{
			      return <FixedDataTableCellDefault404 />;
			    \}
			  \});
			
			  const FixedDataTableCell406 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 100, left: 788 \}\}>
			          \{undefined\}
			          <TransitionCell405 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellDefault407 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'campaignGroup.name'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{150\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{undefined\}
			          columnKey=\{'campaignGroup.name'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 150 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_4h2r'\}>\{'Test Campaign'\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell408 = createClass(\{
			    render() \{
			      return <FixedDataTableCellDefault407 />;
			    \}
			  \});
			
			  const FixedDataTableCell409 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 150, left: 888 \}\}>
			          \{undefined\}
			          <TransitionCell408 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell410 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.id'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{120\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.id'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 120 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>\{'98010048849345'\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell411 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 120, left: 1038 \}\}>
			          \{undefined\}
			          <TransitionCell410 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell412 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'campaignGroup.objective'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{80\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'campaignGroup.objective'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>\{'Clicks to Website'\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell413 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 80, left: 1158 \}\}>
			          \{undefined\}
			          <TransitionCell412 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell414 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'stats.spent_100'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{70\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'stats.spent_100'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 70 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _2g7x _4h2r'\}>\{' — '\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell415 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4lg5 _4h2p _4h2m'\} style=\{\{ height: 32, width: 70, left: 1238 \}\}>
			          \{undefined\}
			          <TransitionCell414 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactDate416 = createClass(\{
			    render() \{
			      return <span>\{'10/24/2015'\}</span>;
			    \}
			  \});
			
			  const TransitionCell417 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'derivedCampaign.startDate'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{113\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'derivedCampaign.startDate'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>
			                <ReactDate416 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell418 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 113, left: 1308 \}\}>
			          \{undefined\}
			          <TransitionCell417 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell419 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'derivedCampaign.endDate'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{113\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'derivedCampaign.endDate'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>\{'Ongoing'\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell420 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 113, left: 1421 \}\}>
			          \{undefined\}
			          <TransitionCell419 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactDate421 = createClass(\{
			    render() \{
			      return <span>\{'10/24/2015'\}</span>;
			    \}
			  \});
			
			  const TransitionCell422 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.created_time'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{113\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.created_time'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>
			                <ReactDate421 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell423 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 113, left: 1534 \}\}>
			          \{undefined\}
			          <TransitionCell422 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactDate424 = createClass(\{
			    render() \{
			      return <span>\{'10/24/2015'\}</span>;
			    \}
			  \});
			
			  const TransitionCell425 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.updated_time'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{113\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.updated_time'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 113 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>
			                <ReactDate424 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell426 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 113, left: 1647 \}\}>
			          \{undefined\}
			          <TransitionCell425 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell427 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.title'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{80\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.title'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>\{'Example'\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell428 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 80, left: 1760 \}\}>
			          \{undefined\}
			          <TransitionCell427 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell429 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.creative.body'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{80\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.creative.body'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 80 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>It's an example.</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell430 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 80, left: 1840 \}\}>
			          \{undefined\}
			          <TransitionCell429 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell431 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'destination'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{92\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'destination'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 92 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\} />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell432 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 92, left: 1920 \}\}>
			          \{undefined\}
			          <TransitionCell431 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell433 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.creative.link_url'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{70\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.creative.link_url'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 70 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\}>\{'http://www.example.com/'\}</div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell434 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 70, left: 2012 \}\}>
			          \{undefined\}
			          <TransitionCell433 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellDefault435 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'page'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{92\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'page'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 92 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_4h2r'\} />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell436 = createClass(\{
			    render() \{
			      return <FixedDataTableCellDefault435 />;
			    \}
			  \});
			
			  const FixedDataTableCell437 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 92, left: 2082 \}\}>
			          \{undefined\}
			          <TransitionCell436 />
			        </div>
			      );
			    \}
			  \});
			
			  const Link438 = createClass(\{
			    render() \{
			      return (
			        <a
			          href=\{'https://www.facebook.com/?demo_ad=98010048849345&h=AQA24w3temAtB-5f#pagelet_ego_pane'\}
			          target=\{'_blank'\}
			          rel=\{undefined\}
			          onClick=\{function () \{\}\}
			        >
			          \{'Preview Ad'\}
			        </a>
			      );
			    \}
			  \});
			
			  const ReactImage439 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'_541d img sp_R48dKBxiJkP sx_dc2cdb'\} />;
			    \}
			  \});
			
			  const AdsPopoverLink440 = createClass(\{
			    render() \{
			      return (
			        <span onMouseEnter=\{function () \{\}\} onMouseLeave=\{function () \{\}\}>
			          <span className=\{'_3o_j'\} />
			          <ReactImage439 />
			        </span>
			      );
			    \}
			  \});
			
			  const AdsHelpLink441 = createClass(\{
			    render() \{
			      return <AdsPopoverLink440 />;
			    \}
			  \});
			
			  const TransitionCell442 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'ad.demolink_hash'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{100\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'ad.demolink_hash'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 100 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_4h2r'\}>
			                <Link438 />
			                <AdsHelpLink441 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell443 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 100, left: 2174 \}\}>
			          \{undefined\}
			          <TransitionCell442 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionCell444 = createClass(\{
			    render() \{
			      return (
			        <div
			          dataKey=\{'scrollbar_spacer'\}
			          className=\{'_4lgc _4h2u'\}
			          rowGetter=\{function () \{\}\}
			          width=\{25\}
			          columnData=\{\{\}\}
			          cellDataGetter=\{function () \{\}\}
			          cellRenderer=\{function () \{\}\}
			          columnKey=\{'scrollbar_spacer'\}
			          height=\{32\}
			          rowIndex=\{0\}
			          style=\{\{ height: 32, width: 25 \}\}
			        >
			          <div className=\{'_4lgd _4h2w'\}>
			            <div className=\{'_4lge _4h2x'\}>
			              <div className=\{'_2d6h _4h2r'\} />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCell445 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_4lg0 _4h2m'\} style=\{\{ height: 32, width: 25, left: 2274 \}\}>
			          \{undefined\}
			          <TransitionCell444 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroupImpl446 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_3pzj'\}
			          style=\{\{
			            height: 32,
			            position: 'absolute',
			            width: 2299,
			            zIndex: 0,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			        >
			          <FixedDataTableCell387 key=\{'cell_0'\} />
			          <FixedDataTableCell389 key=\{'cell_1'\} />
			          <FixedDataTableCell391 key=\{'cell_2'\} />
			          <FixedDataTableCell393 key=\{'cell_3'\} />
			          <FixedDataTableCell395 key=\{'cell_4'\} />
			          <FixedDataTableCell397 key=\{'cell_5'\} />
			          <FixedDataTableCell399 key=\{'cell_6'\} />
			          <FixedDataTableCell401 key=\{'cell_7'\} />
			          <FixedDataTableCell403 key=\{'cell_8'\} />
			          <FixedDataTableCell406 key=\{'cell_9'\} />
			          <FixedDataTableCell409 key=\{'cell_10'\} />
			          <FixedDataTableCell411 key=\{'cell_11'\} />
			          <FixedDataTableCell413 key=\{'cell_12'\} />
			          <FixedDataTableCell415 key=\{'cell_13'\} />
			          <FixedDataTableCell418 key=\{'cell_14'\} />
			          <FixedDataTableCell420 key=\{'cell_15'\} />
			          <FixedDataTableCell423 key=\{'cell_16'\} />
			          <FixedDataTableCell426 key=\{'cell_17'\} />
			          <FixedDataTableCell428 key=\{'cell_18'\} />
			          <FixedDataTableCell430 key=\{'cell_19'\} />
			          <FixedDataTableCell432 key=\{'cell_20'\} />
			          <FixedDataTableCell434 key=\{'cell_21'\} />
			          <FixedDataTableCell437 key=\{'cell_22'\} />
			          <FixedDataTableCell443 key=\{'cell_23'\} />
			          <FixedDataTableCell445 key=\{'cell_24'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableCellGroup447 = createClass(\{
			    render() \{
			      return (
			        <div style=\{\{ height: 32, left: 521 \}\} className=\{'_3pzk'\}>
			          <FixedDataTableCellGroupImpl446 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableRowImpl448 = createClass(\{
			    render() \{
			      return (
			        <div
			          className=\{'_1gd4 _4li _52no _35m0 _35m1 _3c7k _4efq _4efs'\}
			          onClick=\{null\}
			          onDoubleClick=\{null\}
			          onMouseDown=\{function () \{\}\}
			          onMouseEnter=\{null\}
			          onMouseLeave=\{null\}
			          style=\{\{ width: 1083, height: 32 \}\}
			        >
			          <div className=\{'_1gd5'\}>
			            <FixedDataTableCellGroup385 key=\{'fixed_cells'\} />
			            <FixedDataTableCellGroup447 key=\{'scrollable_cells'\} />
			            <div key="_1gd6 _1gd8" className=\{'_1gd6 _1gd8'\} style=\{\{ left: 521, height: 32 \}\} />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableRow449 = createClass(\{
			    render() \{
			      return (
			        <div
			          style=\{\{
			            width: 1083,
			            height: 32,
			            zIndex: 0,
			            transform: 'translate3d(0px,0px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			          className=\{'_1gda'\}
			        >
			          <FixedDataTableRowImpl448 />
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTableBufferedRows450 = createClass(\{
			    render() \{
			      return (
			        <div
			          style=\{\{
			            position: 'absolute',
			            pointerEvents: 'auto',
			            transform: 'translate3d(0px,65px,0)',
			            backfaceVisibility: 'hidden'
			          \}\}
			        >
			          <FixedDataTableRow449 key=\{'0'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const Scrollbar451 = createClass(\{
			    render() \{
			      return (
			        <div
			          onFocus=\{function () \{\}\}
			          onBlur=\{function () \{\}\}
			          onKeyDown=\{function () \{\}\}
			          onMouseDown=\{function () \{\}\}
			          onWheel=\{function () \{\}\}
			          className=\{'_1t0r _1t0t _4jdr _1t0u'\}
			          style=\{\{ width: 1083, zIndex: 99 \}\}
			          tabIndex=\{0\}
			        >
			          <div
			            style=\{\{
			              width: 407.918085106383,
			              transform: 'translate3d(4px,0px,0)',
			              backfaceVisibility: 'hidden'
			            \}\}
			          />
			        </div>
			      );
			    \}
			  \});
			
			  const HorizontalScrollbar452 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3h1k _3h1m'\} style=\{\{ height: 15, width: 1083 \}\}>
			          <div
			            style=\{\{
			              height: 15,
			              position: 'absolute',
			              overflow: 'hidden',
			              width: 1083,
			              transform: 'translate3d(0px,0px,0)',
			              backfaceVisibility: 'hidden'
			            \}\}
			          >
			            <Scrollbar451 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FixedDataTable453 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3h1i _1mie'\} onWheel=\{function () \{\}\} style=\{\{ height: 532, width: 1083 \}\}>
			          <div className=\{'_3h1j'\} style=\{\{ height: 515, width: 1083 \}\}>
			            <FixedDataTableColumnResizeHandle178 />
			            <FixedDataTableRow206 key=\{'group_header'\} />
			            <FixedDataTableRow360 key=\{'header'\} />
			            <FixedDataTableBufferedRows450 />
			            \{null\}
			            \{undefined\}
			            \{undefined\}
			          </div>
			          \{undefined\}
			          <HorizontalScrollbar452 />
			        </div>
			      );
			    \}
			  \});
			
			  const TransitionTable454 = createClass(\{
			    render() \{
			      return <FixedDataTable453 />;
			    \}
			  \});
			
			  const AdsSelectableFixedDataTable455 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5hht'\}>
			          <TransitionTable454 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsDataTableKeyboardSupportDecorator456 = createClass(\{
			    render() \{
			      return (
			        <div onKeyDown=\{function () \{\}\}>
			          <AdsSelectableFixedDataTable455 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsEditableDataTableDecorator457 = createClass(\{
			    render() \{
			      return (
			        <div onCopy=\{function () \{\}\}>
			          <AdsDataTableKeyboardSupportDecorator456 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEDataTableContainer458 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_35l_'\}>
			          \{null\}
			          \{null\}
			          <AdsEditableDataTableDecorator457 />
			        </div>
			      );
			    \}
			  \});
			
			  const ResponsiveBlock459 = createClass(\{
			    render() \{
			      return (
			        <div onResize=\{function () \{\}\} className=\{'_4u-c'\}>
			          <AdsPEDataTableContainer458 />
			          <div className=\{'_4u-f'\}>
			            <iframe tabIndex=\{'-1'\} />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEAdTableContainer460 = createClass(\{
			    render() \{
			      return <ResponsiveBlock459 />;
			    \}
			  \});
			
			  const AdsPEManageAdsPaneContainer461 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_2utw'\}>
			          \{null\}
			          <div className=\{'_2utx _41tt'\}>
			            <AdsPEFilterContainer104 />
			            <AdsPECampaignTimeLimitNoticeContainer106 />
			            \{null\}
			          </div>
			          <div className=\{' _41ts'\}>
			            <AdsPEAdgroupToolbarContainer169 />
			          </div>
			          <div className=\{'_2utz'\}>
			            <div className=\{'_2ut-'\}>
			              <AdsPEOrganizerContainer177 />
			            </div>
			            <div className=\{'_2ut_'\}>
			              <AdsPEAdTableContainer460 />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEContentContainer462 = createClass(\{
			    render() \{
			      return <AdsPEManageAdsPaneContainer461 />;
			    \}
			  \});
			
			  const FluxContainer_r_463 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'mainWrapper'\} style=\{\{ width: 1192 \}\}>
			          <FluxContainer_r_69 />
			          <AdsPEContentContainer462 />
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const FluxContainer_q_464 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEUploadDialog465 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const FluxContainer_y_466 = createClass(\{
			    render() \{
			      return <AdsPEUploadDialog465 />;
			    \}
			  \});
			
			  const ReactImage467 = createClass(\{
			    render() \{
			      return <i className=\{'_1-lx img sp_UuU9HmrQ397 sx_990b54'\} src=\{null\} />;
			    \}
			  \});
			
			  const AdsPESideTrayTabButton468 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{'_1-ly _59j9 _d9a'\}>
			          <ReactImage467 />
			          <div className=\{'_vf7'\} />
			          <div className=\{'_vf8'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEEditorTrayTabButton469 = createClass(\{
			    render() \{
			      return <AdsPESideTrayTabButton468 />;
			    \}
			  \});
			
			  const ReactImage470 = createClass(\{
			    render() \{
			      return <i className=\{'_1-lx img sp_UuU9HmrQ397 sx_94017f'\} src=\{null\} />;
			    \}
			  \});
			
			  const AdsPESideTrayTabButton471 = createClass(\{
			    render() \{
			      return (
			        <div onClick=\{function () \{\}\} className=\{' _1-lz _d9a'\}>
			          <ReactImage470 />
			          <div className=\{'_vf7'\} />
			          <div className=\{'_vf8'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEInsightsTrayTabButton472 = createClass(\{
			    render() \{
			      return <AdsPESideTrayTabButton471 />;
			    \}
			  \});
			
			  const AdsPESideTrayTabButton473 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPENekoDebuggerTrayTabButton474 = createClass(\{
			    render() \{
			      return <AdsPESideTrayTabButton473 />;
			    \}
			  \});
			
			  const FBDragHandle475 = createClass(\{
			    render() \{
			      return (
			        <div
			          style=\{\{ height: 550 \}\}
			          className=\{'_4a2j _2ciy _2ciz'\}
			          horizontal=\{true\}
			          onStart=\{function () \{\}\}
			          onEnd=\{function () \{\}\}
			          onChange=\{function () \{\}\}
			          initialData=\{function () \{\}\}
			          vertical=\{false\}
			          throttle=\{25\}
			          delay=\{0\}
			          threshold=\{0\}
			          onMouseDown=\{function () \{\}\}
			          onMouseUp=\{function () \{\}\}
			          onMouseLeave=\{function () \{\}\}
			        />
			      );
			    \}
			  \});
			
			  const XUIText476 = createClass(\{
			    render() \{
			      return (
			        <span size=\{'large'\} weight=\{'bold'\} className=\{'_2x9f  _50f5 _50f7'\} display=\{'inline'\}>
			          \{'Editing Ad'\}
			        </span>
			      );
			    \}
			  \});
			
			  const XUIText477 = createClass(\{
			    render() \{
			      return (
			        <span size=\{'large'\} weight=\{'bold'\} display=\{'inline'\} className=\{' _50f5 _50f7'\}>
			          \{'Test Ad'\}
			        </span>
			      );
			    \}
			  \});
			
			  const AdsPEEditorChildLink478 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEEditorChildLinkContainer479 = createClass(\{
			    render() \{
			      return <AdsPEEditorChildLink478 />;
			    \}
			  \});
			
			  const AdsPEHeaderSection480 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_yke'\}>
			          <div className=\{'_2x9d _pry'\} />
			          <XUIText476 />
			          <div className=\{'_3a-a'\}>
			            <div className=\{'_3a-b'\}>
			              <XUIText477 />
			            </div>
			          </div>
			          \{null\}
			          <AdsPEEditorChildLinkContainer479 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEAdgroupHeaderSectionContainer481 = createClass(\{
			    render() \{
			      return <AdsPEHeaderSection480 />;
			    \}
			  \});
			
			  const AdsPEAdgroupDisapprovalMessage482 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const FluxContainer_r_483 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupDisapprovalMessage482 />;
			    \}
			  \});
			
			  const AdsPEAdgroupAutoNamingConfirmationContainer484 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsLabeledField485 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5ir9 _3bvz'\} label=\{'Ad Name'\} labelSize=\{'small'\}>
			          <label className=\{'_4el4 _3qwj _3hy-'\} htmlFor=\{undefined\}>
			            \{'Ad Name'\} \{undefined\}
			          </label>
			          \{null\}
			          <div className=\{'_3bv-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError486 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5ira _2vl4 _1h18'\}>
			          \{null\}
			          \{null\}
			          <div className=\{'_2vl9 _1h1f'\} style=\{\{ 'background-color': '#fff' \}\}>
			            <div className=\{'_2vla _1h1g'\}>
			              <div>
			                \{null\}
			                <textarea value=\{'Test Ad'\} />
			                \{null\}
			              </div>
			              <div className=\{'_2vlk'\} />
			            </div>
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsTextInput487 = createClass(\{
			    render() \{
			      return <ReactXUIError486 />;
			    \}
			  \});
			
			  const Link488 = createClass(\{
			    render() \{
			      return (
			        <a className=\{'_5ir9'\} label=\{'Rename using available fields'\} onMouseDown=\{function () \{\}\} href=\{'#'\} rel=\{undefined\} onClick=\{function () \{\}\}>
			          \{'Rename using available fields'\}
			        </a>
			      );
			    \}
			  \});
			
			  const AdsAutoNamingTemplateDialog489 = createClass(\{
			    render() \{
			      return <Link488 />;
			    \}
			  \});
			
			  const AdsPEAmbientNUXMegaphone490 = createClass(\{
			    render() \{
			      return (
			        <span>
			          <AdsAutoNamingTemplateDialog489 />
			        </span>
			      );
			    \}
			  \});
			
			  const AdsLabeledField491 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5ir9 _3bvz'\} label=\{'Status'\} labelSize=\{'small'\}>
			          <label className=\{'_4el4 _3qwj _3hy-'\} htmlFor=\{undefined\}>
			            \{'Status'\} \{undefined\}
			          </label>
			          \{null\}
			          <div className=\{'_3bv-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const BUISwitch492 = createClass(\{
			    render() \{
			      return (
			        <div
			          value=\{true\}
			          disabled=\{true\}
			          onToggle=\{function () \{\}\}
			          data-hover=\{'tooltip'\}
			          data-tooltip-position=\{'below'\}
			          aria-label=\{'Currently active and you can not deactivate it.'\}
			          animate=\{true\}
			          className=\{'_128j _128k _128m _128n'\}
			          role=\{'checkbox'\}
			          aria-checked=\{'true'\}
			        >
			          <div className=\{'_128o'\} onClick=\{function () \{\}\} onKeyDown=\{function () \{\}\} onMouseDown=\{function () \{\}\} tabIndex=\{'-1'\}>
			            <div className=\{'_128p'\} />
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsStatusSwitchInternal493 = createClass(\{
			    render() \{
			      return <BUISwitch492 />;
			    \}
			  \});
			
			  const AdsStatusSwitch494 = createClass(\{
			    render() \{
			      return <AdsStatusSwitchInternal493 />;
			    \}
			  \});
			
			  const LeftRight495 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'clearfix'\}>
			          <div key=\{'left'\} className=\{'_ohe lfloat'\}>
			            <div>
			              <AdsLabeledField485 />
			              <span className=\{'_5irl'\}>
			                <AdsTextInput487 key=\{'nameEditor98010048849345'\} />
			                <AdsPEAmbientNUXMegaphone490 key="490" />
			              </span>
			            </div>
			          </div>
			          <div key=\{'right'\} className=\{'_ohf rfloat'\}>
			            <div>
			              <AdsLabeledField491 />
			              <div className=\{'_5irp'\}>
			                <AdsStatusSwitch494 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const XUICard496 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5ir8 _12k2 _4-u2  _4-u8'\} xuiErrorPosition=\{'above'\} background=\{'white'\}>
			          <LeftRight495 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError497 = createClass(\{
			    render() \{
			      return <XUICard496 />;
			    \}
			  \});
			
			  const AdsCard498 = createClass(\{
			    render() \{
			      return <ReactXUIError497 />;
			    \}
			  \});
			
			  const AdsPENameSection499 = createClass(\{
			    render() \{
			      return <AdsCard498 />;
			    \}
			  \});
			
			  const AdsPEAdgroupNameSectionContainer500 = createClass(\{
			    render() \{
			      return <AdsPENameSection499 />;
			    \}
			  \});
			
			  const XUICardHeaderTitle501 = createClass(\{
			    render() \{
			      return (
			        <span itemComponent=\{'span'\} className=\{'_38my'\}>
			          \{'Ad Links'\}
			          \{null\}
			          <span className=\{'_c1c'\} />
			        </span>
			      );
			    \}
			  \});
			
			  const XUICardSection502 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5dw9 _5dwa _4-u3'\} background=\{'transparent'\}>
			          \{[<XUICardHeaderTitle501 key=\{'/.0'\} />]\}
			          \{undefined\}
			          \{undefined\}
			          <div className=\{'_3s3-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardHeader503 = createClass(\{
			    render() \{
			      return <XUICardSection502 />;
			    \}
			  \});
			
			  const AdsCardHeader504 = createClass(\{
			    render() \{
			      return <XUICardHeader503 />;
			    \}
			  \});
			
			  const XUIText505 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_502s'\} display=\{'block'\} size=\{'inherit'\} weight=\{'inherit'\}>
			          \{'Ad ID 98010048849345'\}
			        </div>
			      );
			    \}
			  \});
			
			  const Link506 = createClass(\{
			    render() \{
			      return (
			        <a target=\{'_blank'\} href=\{'/ads/manager/ad/?ids=98010048849345'\} onClick=\{function () \{\}\} rel=\{undefined\}>
			          \{'Open in Ads Manager'\}
			        </a>
			      );
			    \}
			  \});
			
			  const Link507 = createClass(\{
			    render() \{
			      return (
			        <a target=\{'_blank'\} href=\{'#'\} onClick=\{function () \{\}\} rel=\{undefined\}>
			          \{'Open in Ads Reporting'\}
			        </a>
			      );
			    \}
			  \});
			
			  const Link508 = createClass(\{
			    render() \{
			      return (
			        <a
			          target=\{'_blank'\}
			          href=\{'https://www.facebook.com/?demo_ad=98010048849345&h=AQA24w3temAtB-5f#pagelet_ego_pane'\}
			          onClick=\{function () \{\}\}
			          rel=\{undefined\}
			        >
			          \{'View on Desktop Right Column'\}
			        </a>
			      );
			    \}
			  \});
			
			  const Link509 = createClass(\{
			    render() \{
			      return (
			        <a target=\{'_blank'\} href=\{'/ads/manage/powereditor/?act=10149999073643408&adgroup=98010048849345'\} onClick=\{function () \{\}\} rel=\{undefined\}>
			          \{'Open Power Editor with this ad selected'\}
			        </a>
			      );
			    \}
			  \});
			
			  const List510 = createClass(\{
			    render() \{
			      return (
			        <ul spacing=\{'small'\} border=\{'none'\} direction=\{'vertical'\} valign=\{'top'\} className=\{'uiList _4kg _6-i _6-h _704'\}>
			          \{null\}
			          <li key=\{'/ads/manager/ad/?ids=98010048849345'\}>
			            <Link506 />
			          </li>
			          <li key=\{'#'\}>
			            <Link507 />
			          </li>
			          \{null\}
			          <li key=\{'https://www.facebook.com/?demo_ad=98010048849345&h=AQA24w3temAtB-5f#pagelet_ego_pane'\}>
			            <Link508 />
			          </li>
			          \{null\}
			          \{null\}
			          \{null\}
			          <li key=\{'/ads/manage/powereditor/?act=10149999073643408&adgroup=98010048849345'\}>
			            <Link509 />
			          </li>
			          \{null\}
			        </ul>
			      );
			    \}
			  \});
			
			  const XUICardSection511 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_12jy _4-u3'\} background=\{'transparent'\}>
			          <div className=\{'_3-8j'\}>
			            <XUIText505 />
			            <List510 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsCardSection512 = createClass(\{
			    render() \{
			      return <XUICardSection511 />;
			    \}
			  \});
			
			  const XUICard513 = createClass(\{
			    render() \{
			      return (
			        <div xuiErrorPosition=\{'above'\} className=\{'_12k2 _4-u2  _4-u8'\} background=\{'white'\}>
			          <AdsCardHeader504 />
			          <AdsCardSection512 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError514 = createClass(\{
			    render() \{
			      return <XUICard513 />;
			    \}
			  \});
			
			  const AdsCard515 = createClass(\{
			    render() \{
			      return <ReactXUIError514 />;
			    \}
			  \});
			
			  const AdsPELinkList516 = createClass(\{
			    render() \{
			      return <AdsCard515 />;
			    \}
			  \});
			
			  const AdsPEAdgroupLinksSection517 = createClass(\{
			    render() \{
			      return <AdsPELinkList516 />;
			    \}
			  \});
			
			  const AdsPEAdgroupLinksSectionContainer518 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsPEAdgroupLinksSection517 />
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardHeaderTitle519 = createClass(\{
			    render() \{
			      return (
			        <span itemComponent=\{'span'\} className=\{'_38my'\}>
			          \{'Preview'\}
			          \{null\}
			          <span className=\{'_c1c'\} />
			        </span>
			      );
			    \}
			  \});
			
			  const XUICardSection520 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5dw9 _5dwa _4-u3'\} background=\{'transparent'\}>
			          \{[<XUICardHeaderTitle519 key=\{'/.0'\} />]\}
			          \{undefined\}
			          \{undefined\}
			          <div className=\{'_3s3-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardHeader521 = createClass(\{
			    render() \{
			      return <XUICardSection520 />;
			    \}
			  \});
			
			  const AdsCardHeader522 = createClass(\{
			    render() \{
			      return <XUICardHeader521 />;
			    \}
			  \});
			
			  const PillButton523 = createClass(\{
			    render() \{
			      return (
			        <a label=\{null\} selected=\{true\} onClick=\{function () \{\}\} href=\{'#'\} className=\{'uiPillButton uiPillButtonSelected'\}>
			          \{'Desktop Right Column'\}
			        </a>
			      );
			    \}
			  \});
			
			  const List524 = createClass(\{
			    render() \{
			      return (
			        <ul className=\{'uiList  _4ki _509- _6-i _6-h _704'\} border=\{'none'\} direction=\{'horizontal'\} spacing=\{'small'\} valign=\{'top'\}>
			          <li key=\{'0/.\$RIGHT_COLUMN_STANDARD'\}>
			            <PillButton523 key=\{'RIGHT_COLUMN_STANDARD'\} />
			          </li>
			        </ul>
			      );
			    \}
			  \});
			
			  const PillList525 = createClass(\{
			    render() \{
			      return <List524 />;
			    \}
			  \});
			
			  const XUICardSection526 = createClass(\{
			    render() \{
			      return (
			        <div background=\{'light-wash'\} className=\{'_14p9 _12jy _4-u3  _57d8'\}>
			          <div className=\{'_3-8j'\}>
			            <PillList525 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsCardSection527 = createClass(\{
			    render() \{
			      return <XUICardSection526 />;
			    \}
			  \});
			
			  const AdsPEPreviewPillList528 = createClass(\{
			    render() \{
			      return <AdsCardSection527 />;
			    \}
			  \});
			
			  const XUISpinner529 = createClass(\{
			    render() \{
			      return (
			        <span
			          size=\{'large'\}
			          className=\{'hidden_elem img _55ym _55yq _55yo'\}
			          showOnAsync=\{false\}
			          background=\{'light'\}
			          aria-label=\{'Loading...'\}
			          aria-busy=\{true\}
			        />
			      );
			    \}
			  \});
			
			  const ReactImage530 = createClass(\{
			    render() \{
			      return (
			        <i alt=\{'Warning'\} className=\{'_585p img sp_R48dKBxiJkP sx_aed870'\} src=\{null\}>
			          <u>\{'Warning'\}</u>
			        </i>
			      );
			    \}
			  \});
			
			  const XUINotice531 = createClass(\{
			    render() \{
			      return (
			        <div size=\{'medium'\} className=\{'_585n _585o'\}>
			          <ReactImage530 />
			          \{null\}
			          <div className=\{'_585r _50f4'\}>\{'Unable to display a preview for this ad.'\}</div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdPreview532 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_2hm6'\}>
			          <div className=\{undefined\}>
			            <div className=\{'_3akw'\}>
			              <XUISpinner529 />
			            </div>
			            <div className=\{'hidden_elem'\}>
			              <XUINotice531 />
			            </div>
			            <div className=\{''\} />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardSection533 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3m4g _12jy _4-u3'\} style=\{\{ maxHeight: '425px' \}\} background=\{'transparent'\}>
			          <div className=\{'_3-8j'\}>
			            <div className=\{'_14p7'\}>
			              <div className=\{'_14p8'\}>
			                <AdPreview532 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsCardSection534 = createClass(\{
			    render() \{
			      return <XUICardSection533 />;
			    \}
			  \});
			
			  const AdsPEPreview535 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsPEPreviewPillList528 />
			          \{undefined\}
			          <AdsCardSection534 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEStandardPreview536 = createClass(\{
			    render() \{
			      return <AdsPEPreview535 />;
			    \}
			  \});
			
			  const AdsPEStandardPreviewContainer537 = createClass(\{
			    render() \{
			      return <AdsPEStandardPreview536 />;
			    \}
			  \});
			
			  const XUICard538 = createClass(\{
			    render() \{
			      return (
			        <div xuiErrorPosition=\{'above'\} className=\{'_12k2 _4-u2  _4-u8'\} background=\{'white'\}>
			          <AdsCardHeader522 />
			          \{null\}
			          <AdsPEStandardPreviewContainer537 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError539 = createClass(\{
			    render() \{
			      return <XUICard538 />;
			    \}
			  \});
			
			  const AdsCard540 = createClass(\{
			    render() \{
			      return <ReactXUIError539 />;
			    \}
			  \});
			
			  const AdsPEAdgroupPreviewSection541 = createClass(\{
			    render() \{
			      return <AdsCard540 />;
			    \}
			  \});
			
			  const AdsPEAdgroupPreviewSectionContainer542 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupPreviewSection541 />;
			    \}
			  \});
			
			  const AdsPEStickyArea543 = createClass(\{
			    render() \{
			      return (
			        <div>
			          \{null\}
			          <div>
			            <AdsPEAdgroupPreviewSectionContainer542 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardHeaderTitle544 = createClass(\{
			    render() \{
			      return (
			        <span itemComponent=\{'span'\} className=\{'_38my'\}>
			          \{'Facebook Page'\}
			          \{null\}
			          <span className=\{'_c1c'\} />
			        </span>
			      );
			    \}
			  \});
			
			  const XUICardSection545 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5dw9 _5dwa _4-u3'\} background=\{'transparent'\}>
			          \{[<XUICardHeaderTitle544 key=\{'/.0'\} />]\}
			          \{undefined\}
			          \{undefined\}
			          <div className=\{'_3s3-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardHeader546 = createClass(\{
			    render() \{
			      return <XUICardSection545 />;
			    \}
			  \});
			
			  const AdsCardHeader547 = createClass(\{
			    render() \{
			      return <XUICardHeader546 />;
			    \}
			  \});
			
			  const Link548 = createClass(\{
			    render() \{
			      return (
			        <a className=\{'fwb'\} onClick=\{function () \{\}\} href=\{'#'\} rel=\{undefined\}>
			          \{'Connect a Facebook Page'\}
			        </a>
			      );
			    \}
			  \});
			
			  const AdsPEWebsiteNoPageDestinationSection549 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <div className=\{'_3-95'\}>\{'This ad is not connected to a Facebook Page. It will not show in News Feed.'\}</div>
			          <Link548 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEWebsiteNoPageDestinationSectionContainer550 = createClass(\{
			    render() \{
			      return <AdsPEWebsiteNoPageDestinationSection549 />;
			    \}
			  \});
			
			  const XUICardSection551 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_12jy _4-u3'\} background=\{'transparent'\}>
			          <div className=\{'_3-8j'\}>
			            <AdsPEWebsiteNoPageDestinationSectionContainer550 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsCardSection552 = createClass(\{
			    render() \{
			      return <XUICardSection551 />;
			    \}
			  \});
			
			  const XUICard553 = createClass(\{
			    render() \{
			      return (
			        <div xuiErrorPosition=\{'above'\} className=\{'_12k2 _4-u2  _4-u8'\} background=\{'white'\}>
			          <AdsCardHeader547 />
			          <AdsCardSection552 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError554 = createClass(\{
			    render() \{
			      return <XUICard553 />;
			    \}
			  \});
			
			  const AdsCard555 = createClass(\{
			    render() \{
			      return <ReactXUIError554 />;
			    \}
			  \});
			
			  const AdsPEAdgroupDestinationSection556 = createClass(\{
			    render() \{
			      return <AdsCard555 />;
			    \}
			  \});
			
			  const AdsPEAdgroupDestinationSectionContainer557 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupDestinationSection556 />;
			    \}
			  \});
			
			  const XUICardHeaderTitle558 = createClass(\{
			    render() \{
			      return (
			        <span itemComponent=\{'span'\} className=\{'_38my'\}>
			          \{'Creative'\}
			          \{null\}
			          <span className=\{'_c1c'\} />
			        </span>
			      );
			    \}
			  \});
			
			  const XUICardSection559 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5dw9 _5dwa _4-u3'\} background=\{'transparent'\}>
			          \{[<XUICardHeaderTitle558 key=\{'/.0'\} />]\}
			          \{undefined\}
			          \{undefined\}
			          <div className=\{'_3s3-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardHeader560 = createClass(\{
			    render() \{
			      return <XUICardSection559 />;
			    \}
			  \});
			
			  const AdsCardHeader561 = createClass(\{
			    render() \{
			      return <XUICardHeader560 />;
			    \}
			  \});
			
			  const ReactImage562 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'_541d img sp_R48dKBxiJkP sx_dc2cdb'\} />;
			    \}
			  \});
			
			  const AdsPopoverLink563 = createClass(\{
			    render() \{
			      return (
			        <span onMouseEnter=\{function () \{\}\} onMouseLeave=\{function () \{\}\}>
			          <span className=\{'_3o_j'\} />
			          <ReactImage562 />
			        </span>
			      );
			    \}
			  \});
			
			  const AdsHelpLink564 = createClass(\{
			    render() \{
			      return <AdsPopoverLink563 />;
			    \}
			  \});
			
			  const AdsLabeledField565 = createClass(\{
			    render() \{
			      return (
			        <div
			          htmlFor=\{undefined\}
			          label=\{'Website URL'\}
			          helpText=\{'Enter the website URL you want to promote. Ex: http://www.example.com/page'\}
			          helpLinger=\{undefined\}
			          optional=\{undefined\}
			          labelSize=\{'small'\}
			          className=\{'_3bvz'\}
			        >
			          <label className=\{'_4el4 _3qwj _3hy-'\} htmlFor=\{undefined\}>
			            \{'Website URL'\} \{undefined\}
			          </label>
			          <AdsHelpLink564 />
			          <div className=\{'_3bv-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError566 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_gon _2vl4 _1h18'\}>
			          <div className=\{'_2vln'\}>\{1001\}</div>
			          <AdsLabeledField565 />
			          <div className=\{'_2vl9 _1h1f'\} style=\{\{ 'background-color': '#fff' \}\}>
			            <div className=\{'_2vla _1h1g'\}>
			              <div>
			                \{null\}
			                <textarea value=\{'http://www.example.com/'\} />
			                \{null\}
			              </div>
			              <div className=\{'_2vlk'\} />
			            </div>
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsTextInput567 = createClass(\{
			    render() \{
			      return <ReactXUIError566 />;
			    \}
			  \});
			
			  const AdsBulkTextInput568 = createClass(\{
			    render() \{
			      return <AdsTextInput567 />;
			    \}
			  \});
			
			  const AdsPEWebsiteURLField569 = createClass(\{
			    render() \{
			      return <AdsBulkTextInput568 />;
			    \}
			  \});
			
			  const ReactImage570 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'_541d img sp_R48dKBxiJkP sx_dc2cdb'\} />;
			    \}
			  \});
			
			  const AdsPopoverLink571 = createClass(\{
			    render() \{
			      return (
			        <span onMouseEnter=\{function () \{\}\} onMouseLeave=\{function () \{\}\}>
			          <span className=\{'_3o_j'\} />
			          <ReactImage570 />
			        </span>
			      );
			    \}
			  \});
			
			  const AdsHelpLink572 = createClass(\{
			    render() \{
			      return <AdsPopoverLink571 />;
			    \}
			  \});
			
			  const AdsLabeledField573 = createClass(\{
			    render() \{
			      return (
			        <div
			          htmlFor=\{undefined\}
			          label=\{'Headline'\}
			          helpText=\{
			            'Your headline text will appear differently depending on the placement of your ad. Check the previews to make sure your headline looks the way you want in the placements it appears in.'
			          \}
			          helpLinger=\{undefined\}
			          optional=\{undefined\}
			          labelSize=\{'small'\}
			          className=\{'_3bvz'\}
			        >
			          <label className=\{'_4el4 _3qwj _3hy-'\} htmlFor=\{undefined\}>
			            \{'Headline'\} \{undefined\}
			          </label>
			          <AdsHelpLink572 />
			          <div className=\{'_3bv-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError574 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_gon _2vl4 _1h18'\}>
			          <div className=\{'_2vln'\}>\{18\}</div>
			          <AdsLabeledField573 />
			          <div className=\{'_2vl9 _1h1f'\} style=\{\{ 'background-color': '#fff' \}\}>
			            <div className=\{'_2vla _1h1g'\}>
			              <div>
			                \{null\}
			                <textarea value=\{'Example'\} />
			                \{null\}
			              </div>
			              <div className=\{'_2vlk'\} />
			            </div>
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsTextInput575 = createClass(\{
			    render() \{
			      return <ReactXUIError574 />;
			    \}
			  \});
			
			  const AdsBulkTextInput576 = createClass(\{
			    render() \{
			      return <AdsTextInput575 />;
			    \}
			  \});
			
			  const AdsPEHeadlineField577 = createClass(\{
			    render() \{
			      return <AdsBulkTextInput576 />;
			    \}
			  \});
			
			  const AdsLabeledField578 = createClass(\{
			    render() \{
			      return (
			        <div htmlFor=\{undefined\} label=\{'Text'\} helpText=\{undefined\} helpLinger=\{undefined\} optional=\{undefined\} labelSize=\{'small'\} className=\{'_3bvz'\}>
			          <label className=\{'_4el4 _3qwj _3hy-'\} htmlFor=\{undefined\}>
			            \{'Text'\} \{undefined\}
			          </label>
			          \{null\}
			          <div className=\{'_3bv-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError579 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_gon _2vl4 _2vl6 _1h18 _1h1a'\}>
			          <div className=\{'_2vln'\}>\{74\}</div>
			          <AdsLabeledField578 />
			          <div className=\{'_2vl9 _1h1f'\} style=\{\{ 'background-color': '#fff' \}\}>
			            <div className=\{'_2vla _1h1g'\}>
			              <div>
			                \{null\}
			                <textarea value="It's an example." />
			                \{null\}
			              </div>
			              <div className=\{'_2vlk'\} />
			            </div>
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsTextInput580 = createClass(\{
			    render() \{
			      return <ReactXUIError579 />;
			    \}
			  \});
			
			  const AdsBulkTextInput581 = createClass(\{
			    render() \{
			      return <AdsTextInput580 />;
			    \}
			  \});
			
			  const AdsPEMessageField582 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsBulkTextInput581 />
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AbstractButton583 = createClass(\{
			    render() \{
			      return (
			        <button
			          label=\{null\}
			          onClick=\{function () \{\}\}
			          size=\{'large'\}
			          use=\{'default'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          className=\{'_4jy0 _4jy4 _517h _51sy _42ft'\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          \{'Change Image'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton584 = createClass(\{
			    render() \{
			      return <AbstractButton583 />;
			    \}
			  \});
			
			  const BackgroundImage585 = createClass(\{
			    render() \{
			      return (
			        <div
			          src=\{'https://scontent.xx.fbcdn.net/hads-xap1/t45.1600-4/12124737_98010048849339_1665004369_n.png'\}
			          width=\{114.6\}
			          height=\{60\}
			          backgroundSize=\{'contain'\}
			          optimizeResizeSpeed=\{false\}
			          loadingIndicatorStyle=\{'none'\}
			          className=\{'_5f0d'\}
			          style=\{\{ width: '114.6px', height: '60px' \}\}
			          onContextMenu=\{undefined\}
			        >
			          <img
			            alt=\{''\}
			            className=\{'_5i4g'\}
			            style=\{\{ width: '90px', height: '60px', left: '12px', top: '0px' \}\}
			            src=\{'https://scontent.xx.fbcdn.net/hads-xap1/t45.1600-4/12124737_98010048849339_1665004369_n.png'\}
			          />
			          \{undefined\}
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const XUIText586 = createClass(\{
			    render() \{
			      return (
			        <span shade=\{'light'\} className=\{'_50f8'\} size=\{'inherit'\} weight=\{'inherit'\} display=\{'inline'\}>
			          \{'1000 × 667'\}
			        </span>
			      );
			    \}
			  \});
			
			  const XUIGrayText587 = createClass(\{
			    render() \{
			      return <XUIText586 />;
			    \}
			  \});
			
			  const XUIText588 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3-95  _50f7'\} display=\{'block'\} weight=\{'bold'\} size=\{'inherit'\}>
			          \{'untitled – '\}
			          <XUIGrayText587 />
			          \{''\}
			        </div>
			      );
			    \}
			  \});
			
			  const CenteredContainer589 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_50vi'\} horizontal=\{false\} vertical=\{true\} fullHeight=\{false\}>
			          <div className=\{'_3bwv'\}>
			            <div className=\{'_3bwy'\}>
			              <div key=\{'/.0'\} className=\{'_3bwx'\}>
			                <XUIText588 />
			              </div>
			              <div key=\{'/.1'\} className=\{'_3bwx'\} />
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const Link590 = createClass(\{
			    render() \{
			      return (
			        <a href=\{'/business/ads-guide/'\} target=\{'_blank'\} rel=\{undefined\} onClick=\{function () \{\}\}>
			          \{'Facebook Ad Guidelines'\}
			        </a>
			      );
			    \}
			  \});
			
			  const XUIText591 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3-96'\} display=\{'block'\} size=\{'inherit'\} weight=\{'inherit'\}>
			          \{'For questions and more information, see the '\}
			          <Link590 />
			          \{'.'\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsImageInput592 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <div>
			            <XUIButton584 />
			            \{undefined\}
			          </div>
			          \{null\}
			          <div className=\{'_50vh _3-8n _2ph_'\}>
			            <div className=\{'_37xq'\}>
			              <div className=\{'_3-90'\}>
			                <div className=\{' _1yi2'\} onContextMenu=\{undefined\}>
			                  <BackgroundImage585 />
			                </div>
			              </div>
			              <CenteredContainer589 />
			            </div>
			            \{null\}
			          </div>
			          <XUIText591 />
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsBulkImageInput593 = createClass(\{
			    render() \{
			      return <AdsImageInput592 />;
			    \}
			  \});
			
			  const AdsLabeledField594 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3-96 _3bvz'\} label=\{'Image'\} labelSize=\{'small'\}>
			          <label className=\{'_4el4 _3qwj _3hy-'\} htmlFor=\{undefined\}>
			            \{'Image'\} \{undefined\}
			          </label>
			          \{null\}
			          <div className=\{'_3bv-'\}>
			            <AdsBulkImageInput593 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEImageSelector595 = createClass(\{
			    render() \{
			      return <AdsLabeledField594 />;
			    \}
			  \});
			
			  const AdsPEImageSelectorContainer596 = createClass(\{
			    render() \{
			      return <AdsPEImageSelector595 />;
			    \}
			  \});
			
			  const AdsPEWebsiteNoPageCreative597 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsPEWebsiteURLField569 />
			          <AdsPEHeadlineField577 />
			          <AdsPEMessageField582 />
			          <AdsPEImageSelectorContainer596 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEWebsiteNoPageCreativeContainer598 = createClass(\{
			    render() \{
			      return <AdsPEWebsiteNoPageCreative597 />;
			    \}
			  \});
			
			  const XUICardSection599 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_12jy _4-u3'\} background=\{'transparent'\}>
			          <div className=\{'_3-8j'\}>
			            <div />
			            <AdsPEWebsiteNoPageCreativeContainer598 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsCardSection600 = createClass(\{
			    render() \{
			      return <XUICardSection599 />;
			    \}
			  \});
			
			  const XUICard601 = createClass(\{
			    render() \{
			      return (
			        <div xuiErrorPosition=\{'above'\} className=\{'_12k2 _4-u2  _4-u8'\} background=\{'white'\}>
			          <AdsCardHeader561 />
			          <AdsCardSection600 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError602 = createClass(\{
			    render() \{
			      return <XUICard601 />;
			    \}
			  \});
			
			  const AdsCard603 = createClass(\{
			    render() \{
			      return <ReactXUIError602 />;
			    \}
			  \});
			
			  const AdsPEAdgroupCreativeSection604 = createClass(\{
			    render() \{
			      return <AdsCard603 />;
			    \}
			  \});
			
			  const AdsPEAdgroupCreativeSectionContainer605 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupCreativeSection604 />;
			    \}
			  \});
			
			  const AdsPELeadGenFormSection606 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPELeadGenFormContainer607 = createClass(\{
			    render() \{
			      return <AdsPELeadGenFormSection606 />;
			    \}
			  \});
			
			  const XUICardHeaderTitle608 = createClass(\{
			    render() \{
			      return (
			        <span itemComponent=\{'span'\} className=\{'_38my'\}>
			          \{'Tracking'\}
			          \{null\}
			          <span className=\{'_c1c'\} />
			        </span>
			      );
			    \}
			  \});
			
			  const XUICardSection609 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_5dw9 _5dwa _4-u3'\} background=\{'transparent'\}>
			          \{[<XUICardHeaderTitle608 key=\{'/.0'\} />]\}
			          \{undefined\}
			          \{undefined\}
			          <div className=\{'_3s3-'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const XUICardHeader610 = createClass(\{
			    render() \{
			      return <XUICardSection609 />;
			    \}
			  \});
			
			  const AdsCardHeader611 = createClass(\{
			    render() \{
			      return <XUICardHeader610 />;
			    \}
			  \});
			
			  const XUIText612 = createClass(\{
			    render() \{
			      return (
			        <span weight=\{'bold'\} className=\{'_3ga-  _50f7'\} size=\{'inherit'\} display=\{'inline'\}>
			          \{'Conversion Tracking'\}
			        </span>
			      );
			    \}
			  \});
			
			  const ReactImage613 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'_5s_w _541d img sp_R48dKBxiJkP sx_dc2cdb'\} />;
			    \}
			  \});
			
			  const AdsPopoverLink614 = createClass(\{
			    render() \{
			      return (
			        <span onMouseEnter=\{function () \{\}\} onMouseLeave=\{function () \{\}\}>
			          <span className=\{'_3o_j'\} />
			          <ReactImage613 />
			        </span>
			      );
			    \}
			  \});
			
			  const AdsHelpLink615 = createClass(\{
			    render() \{
			      return <AdsPopoverLink614 />;
			    \}
			  \});
			
			  const AdsCFHelpLink616 = createClass(\{
			    render() \{
			      return <AdsHelpLink615 />;
			    \}
			  \});
			
			  const AdsPixelTrackingLabel617 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3gay'\}>
			          <XUIText612 />
			          <AdsCFHelpLink616 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactImage618 = createClass(\{
			    render() \{
			      return <i src=\{null\} className=\{'img _8o _8r img sp_UuU9HmrQ397 sx_ad67ef'\} />;
			    \}
			  \});
			
			  const XUIText619 = createClass(\{
			    render() \{
			      return (
			        <div size=\{'medium'\} weight=\{'bold'\} shade=\{'medium'\} display=\{'block'\} className=\{'_3-8m  _c24  _50f4 _50f7'\}>
			          \{'Facebook Pixel'\}
			        </div>
			      );
			    \}
			  \});
			
			  const XUIGrayText620 = createClass(\{
			    render() \{
			      return <XUIText619 />;
			    \}
			  \});
			
			  const XUIText621 = createClass(\{
			    render() \{
			      return (
			        <span size=\{'medium'\} weight=\{'inherit'\} display=\{'inline'\} className=\{' _50f4'\}>
			          \{'Learn More'\}
			        </span>
			      );
			    \}
			  \});
			
			  const Link622 = createClass(\{
			    render() \{
			      return (
			        <a href=\{'/help/336923339852238'\} target=\{'_blank'\} rel=\{undefined\} onClick=\{function () \{\}\}>
			          <XUIText621 />
			        </a>
			      );
			    \}
			  \});
			
			  const XUIText623 = createClass(\{
			    render() \{
			      return (
			        <span shade=\{'medium'\} size=\{'medium'\} className=\{' _c24  _50f4'\} weight=\{'inherit'\} display=\{'inline'\}>
			          \{'You can now create one pixel for tracking, optimization and remarketing.'\}
			          <span className=\{'_3-99'\}>
			            <Link622 />
			          </span>
			        </span>
			      );
			    \}
			  \});
			
			  const XUIGrayText624 = createClass(\{
			    render() \{
			      return <XUIText623 />;
			    \}
			  \});
			
			  const AbstractButton625 = createClass(\{
			    render() \{
			      return (
			        <button
			          className=\{'_23ng _4jy0 _4jy4 _4jy1 _51sy selected _42ft'\}
			          label=\{null\}
			          onClick=\{function () \{\}\}
			          size=\{'large'\}
			          use=\{'confirm'\}
			          borderShade=\{'light'\}
			          suppressed=\{false\}
			          type=\{'submit'\}
			          value=\{'1'\}
			        >
			          \{undefined\}
			          \{'Create a Pixel'\}
			          \{undefined\}
			        </button>
			      );
			    \}
			  \});
			
			  const XUIButton626 = createClass(\{
			    render() \{
			      return <AbstractButton625 />;
			    \}
			  \});
			
			  const AdsPixelCreateButton627 = createClass(\{
			    render() \{
			      return <XUIButton626 />;
			    \}
			  \});
			
			  const LeftRight628 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_23nf clearfix'\} direction=\{'left'\}>
			          <div key=\{'left'\} className=\{'_ohe lfloat'\}>
			            <ReactImage618 />
			          </div>
			          <div key=\{'right'\} className=\{''\}>
			            <div className=\{'_42ef _8u'\}>
			              <div>
			                <XUIGrayText620 />
			                <XUIGrayText624 />
			                <div className=\{'_3-8x'\}>
			                  <AdsPixelCreateButton627 />
			                </div>
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const ImageBlock629 = createClass(\{
			    render() \{
			      return <LeftRight628 />;
			    \}
			  \});
			
			  const AdsPixelCreationCard630 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_2pie'\} horizontal=\{true\}>
			          <div className=\{'_23ne _4fsl'\}>
			            <ImageBlock629 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPixelTrackingSelector631 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_3-8x _4fsk'\}>
			          <AdsPixelCreationCard630 key=\{'FacebookPixelNUX'\} />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPixelTracking632 = createClass(\{
			    render() \{
			      return (
			        <div className=\{undefined\}>
			          <AdsPixelTrackingLabel617 />
			          <div className=\{'_3-8x'\}>
			            <div />
			          </div>
			          <AdsPixelTrackingSelector631 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEPixelTracking633 = createClass(\{
			    render() \{
			      return <AdsPixelTracking632 key=\{'tracking'\} />;
			    \}
			  \});
			
			  const AdsPEPixelTrackingContainer634 = createClass(\{
			    render() \{
			      return <AdsPEPixelTracking633 />;
			    \}
			  \});
			
			  const AdsPEAdgroupAppTrackingSelectorContainer635 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEStandardTrackingSection636 = createClass(\{
			    render() \{
			      return (
			        <div>
			          \{null\}
			          <div className=\{'_3-96'\}>
			            <AdsPEPixelTrackingContainer634 />
			          </div>
			          <div className=\{'_3-96'\}>
			            <AdsPEAdgroupAppTrackingSelectorContainer635 />
			          </div>
			          \{null\}
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEStandardTrackingContainer637 = createClass(\{
			    render() \{
			      return <AdsPEStandardTrackingSection636 />;
			    \}
			  \});
			
			  const XUICardSection638 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_12jy _4-u3'\} background=\{'transparent'\}>
			          <div className=\{'_3-8j'\}>
			            <AdsPEStandardTrackingContainer637 />
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const AdsCardSection639 = createClass(\{
			    render() \{
			      return <XUICardSection638 />;
			    \}
			  \});
			
			  const XUICard640 = createClass(\{
			    render() \{
			      return (
			        <div xuiErrorPosition=\{'above'\} className=\{'_12k2 _4-u2  _4-u8'\} background=\{'white'\}>
			          <AdsCardHeader611 />
			          <AdsCardSection639 />
			        </div>
			      );
			    \}
			  \});
			
			  const ReactXUIError641 = createClass(\{
			    render() \{
			      return <XUICard640 />;
			    \}
			  \});
			
			  const AdsCard642 = createClass(\{
			    render() \{
			      return <ReactXUIError641 />;
			    \}
			  \});
			
			  const AdsPEAdgroupTrackingSection643 = createClass(\{
			    render() \{
			      return <AdsCard642 />;
			    \}
			  \});
			
			  const AdsPEAdgroupTrackingSectionContainer644 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupTrackingSection643 />;
			    \}
			  \});
			
			  const AdsPEAdgroupIOSection645 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEAdgroupIOSectionContainer646 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupIOSection645 />;
			    \}
			  \});
			
			  const LeftRight647 = createClass(\{
			    render() \{
			      return (
			        <div flex=\{'left'\} direction=\{'right'\} className=\{'clearfix'\}>
			          <div key=\{'right'\} className=\{'_ohf rfloat'\}>
			            <div className=\{'_20ro _20rp'\}>
			              <div>
			                \{null\}
			                <AdsPEAdgroupLinksSectionContainer518 />
			                <AdsPEStickyArea543 />
			              </div>
			            </div>
			          </div>
			          <div key=\{'left'\} className=\{''\}>
			            <div className=\{'_42ef'\}>
			              <div>
			                <AdsPEAdgroupDestinationSectionContainer557 />
			                <AdsPEAdgroupCreativeSectionContainer605 />
			                <AdsPELeadGenFormContainer607 />
			                <AdsPEAdgroupTrackingSectionContainer644 />
			                <AdsPEAdgroupIOSectionContainer646 />
			              </div>
			            </div>
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FlexibleBlock648 = createClass(\{
			    render() \{
			      return <LeftRight647 />;
			    \}
			  \});
			
			  const AdsPEMultiColumnEditor649 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_2j_c _ykd'\}>
			          <div>
			            <FluxContainer_r_483 />
			            \{null\}
			            <AdsPEAdgroupAutoNamingConfirmationContainer484 />
			            <AdsPEAdgroupNameSectionContainer500 />
			          </div>
			          <FlexibleBlock648 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEAdgroupEditor650 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsPEAdgroupHeaderSectionContainer481 />
			          <AdsPEMultiColumnEditor649 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEAdgroupEditorContainer651 = createClass(\{
			    render() \{
			      return <AdsPEAdgroupEditor650 key=\{'98010048849345'\} />;
			    \}
			  \});
			
			  const AdsPESideTrayTabContent652 = createClass(\{
			    render() \{
			      return (
			        <div className=\{'_1o_8 _44ra _5cyn'\}>
			          <AdsPEAdgroupEditorContainer651 />
			        </div>
			      );
			    \}
			  \});
			
			  const AdsPEEditorTrayTabContent653 = createClass(\{
			    render() \{
			      return <AdsPESideTrayTabContent652 />;
			    \}
			  \});
			
			  const AdsPEMultiTabDrawer654 = createClass(\{
			    render() \{
			      return (
			        <div style=\{\{ height: 550, width: 1027 \}\} tabButtons=\{\{\}\} tabContentPanes=\{\{\}\} enableAnimation=\{true\} showButton=\{true\} className=\{'_2kev _2kew _2kex'\}>
			          <div className=\{'_2kf0'\}>
			            <AdsPEEditorTrayTabButton469 key=\{'editor_tray_button'\} />
			            <AdsPEInsightsTrayTabButton472 key=\{'insights_tray_button'\} />
			            <AdsPENekoDebuggerTrayTabButton474 key=\{'neko_debugger_tray_button'\} />
			          </div>
			          <div className=\{'_2kf1'\}>
			            <FBDragHandle475 />
			            <AdsPEEditorTrayTabContent653 key=\{'EDITOR_DRAWER'\} />
			            \{null\}
			          </div>
			        </div>
			      );
			    \}
			  \});
			
			  const FluxContainer_x_655 = createClass(\{
			    render() \{
			      return <AdsPEMultiTabDrawer654 />;
			    \}
			  \});
			
			  const AdsBugReportContainer656 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEAudienceSplittingDialog657 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEAudienceSplittingDialogContainer658 = createClass(\{
			    render() \{
			      return (
			        <div>
			          <AdsPEAudienceSplittingDialog657 />
			        </div>
			      );
			    \}
			  \});
			
			  const FluxContainer_p_659 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPECreateDialogContainer660 = createClass(\{
			    render() \{
			      return null;
			    \}
			  \});
			
			  const AdsPEContainer661 = createClass(\{
			    render() \{
			      return (
			        <div id=\{'ads_pe_container'\}>
			          \{null\}
			          <FluxContainer_ja_26 />
			          <FluxContainer_w_56 />
			          <FluxContainer_r_463 />
			          <FluxContainer_q_464 />
			          <FluxContainer_y_466 />
			          \{null\}
			          <FluxContainer_x_655 />
			          <AdsBugReportContainer656 />
			          \{null\}
			          <AdsPEAudienceSplittingDialogContainer658 />
			          \{null\}
			          \{null\}
			          \{null\}
			          <FluxContainer_p_659 />
			          <AdsPECreateDialogContainer660 />
			        </div>
			      );
			    \}
			  \});
			
			  const Benchmark = createClass(\{
			    render() \{
			      return <AdsPEContainer661 />;
			    \}
			  \});
			
			  render(<Benchmark />, container);
			\}
			
			describe('Benchmark - createClass (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  it('Run the benchmark once', () => \{
			    runBenchmark(container);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-class\\__tests__\\createClass.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\callback.in.ctr.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render, rerender \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			import \{ combineFrom \} from 'inferno-shared';
			
			describe('Callbacks in constructor', () => \{
			  // https://github.com/infernojs/inferno/issues/1103
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('Github #1103', () => \{
			    it('Should be possible to call callbacks from Component constructor - Use case 1', () => \{
			      function InfoLi(props) \{
			        const iddy = props.conf.key;
			        return (
			          <li>
			            <input id=\{iddy\} type="checkbox" checked=\{props.checked\} onClick=\{props.onChange\} />
			            <label for=\{iddy\}>\{props.conf.label\}</label>
			            <div>\{props.children\}</div>
			          </li>
			        );
			      \}
			
			      interface ConfigsListProps \{
			        onConfChanged: (arg: \{ targetIndex: number; newValue: unknown \}) => void;
			        configs: unknown[];
			      \}
			      interface ConfigsListState \{
			        checks: boolean[];
			      \}
			
			      class ConfigsList extends Component<ConfigsListProps, ConfigsListState> \{
			        public state: ConfigsListState;
			
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            checks: props.configs.map((conf) => Boolean(conf.value))
			          \};
			        \}
			
			        public handleCheck(index, ifChecked) \{
			          this.setState(\{
			            checks: this.state.checks.map((ch, i) => (i === index ? ifChecked : ch))
			          \});
			        \}
			
			        public handleNewValue(index, newValue) \{
			          this.props.onConfChanged(\{
			            newValue,
			            targetIndex: index
			          \});
			        \}
			
			        public render(props) \{
			          return (
			            <ol>
			              \{props.configs.map((conf, index) => \{
			                const childElement = props.configToChild && props.configToChild[conf.key];
			
			                const child =
			                  childElement &&
			                  this.state.checks[index] &&
			                  createElement(
			                    childElement,
			                    combineFrom(props, \{
			                      conf,
			                      onNewValue: (newValue) => this.handleNewValue(index, newValue)
			                    \})
			                  );
			
			                return (
			                  <InfoLi conf=\{conf\} checked=\{conf.value\} onChange=\{(event) => this.handleCheck(index, event.target.checked)\}>
			                    \{child\}
			                  </InfoLi>
			                );
			              \})\}
			            </ol>
			          );
			        \}
			      \}
			
			      interface ProxyEditorProps \{
			        onNewValue: (arg: string) => void;
			      \}
			
			      class ProxyEditor extends Component<ProxyEditorProps> \{
			        constructor(props) \{
			          super(props);
			
			          const oldValue = props.conf.value;
			          const newValue = oldValue || 'BA BA BA!';
			          if (!oldValue) \{
			            this.props.onNewValue(newValue);
			          \}
			        \}
			
			        public render() \{
			          return <div />;
			        \}
			      \}
			
			      interface MainState \{
			        configs: \{ category: string; key: string; label: string; value: boolean \}[];
			      \}
			
			      class Main extends Component<any, MainState> \{
			        public state: MainState;
			
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            configs: [
			              \{
			                category: 'ownProxies',
			                key: 'customProxyStringRaw',
			                label: 'Use proxy? (click this)',
			                value: false
			              \},
			              \{
			                category: 'ownProxies',
			                key: 'This one is needed for reproduction too!',
			                label: 'needed too',
			                value: false
			              \}
			            ]
			          \};
			          this.handleModChange = this.handleModChange.bind(this);
			        \}
			
			        public handleModChange(\{ targetIndex, newValue \}) \{
			          this.setState(\{
			            configs: this.state.configs.map((oldConf, index) => (index !== targetIndex ? oldConf : combineFrom(oldConf, \{ value: newValue \})))
			          \});
			        \}
			
			        public render(props) \{
			          return createElement(
			            ConfigsList,
			            combineFrom(props, \{
			              configToChild: \{
			                customProxyStringRaw: ProxyEditor
			              \},
			              configs: this.state.configs,
			              onConfChanged: this.handleModChange
			            \})
			          );
			        \}
			      \}
			
			      render(<Main />, container);
			
			      // Renders correctly
			      expect(container.innerHTML).toBe(
			        '<ol><li><input id="customProxyStringRaw" type="checkbox"><label for="customProxyStringRaw">Use proxy? (click this)</label><div></div></li><li><input id="This one is needed for reproduction too!" type="checkbox"><label for="This one is needed for reproduction too!">needed too</label><div></div></li></ol>'
			      );
			
			      let checkBoxes = container.querySelectorAll('input');
			
			      expect(checkBoxes.length).toBe(2);
			
			      expect(checkBoxes[0].checked).toBe(false);
			      expect(checkBoxes[1].checked).toBe(false);
			
			      checkBoxes[0].click(); // Click first checkbox
			      rerender();
			      checkBoxes = container.querySelectorAll('input');
			
			      expect(checkBoxes.length).toBe(2);
			
			      expect(checkBoxes[0].checked).toBe(true);
			      expect(checkBoxes[1].checked).toBe(false);
			
			      checkBoxes[0].click(); // Click first checkbox again
			      rerender();
			      checkBoxes = container.querySelectorAll('input');
			
			      expect(checkBoxes.length).toBe(2);
			
			      expect(checkBoxes[0].checked).toBe(true); // This is current expected behavior, same as React
			      expect(checkBoxes[1].checked).toBe(false);
			
			      checkBoxes[1].click(); // Click second checkbox, it should do nothing
			      rerender();
			      expect(checkBoxes[1].checked).toBe(false);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\callback.in.ctr.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\children.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Children - (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  const preDefined = [
			    \{
			      name: 'undefined',
			      value: undefined,
			      expected: ''
			    \},
			    \{
			      name: 'null',
			      value: null,
			      expected: ''
			    \},
			    \{
			      name: 'one whitespace',
			      value: ' ',
			      expected: ' '
			    \},
			    \{
			      name: 'whitespace to left',
			      value: 'a ',
			      expected: 'a '
			    \},
			    \{
			      name: 'whitespace to right',
			      value: ' a',
			      expected: ' a'
			    \},
			    \{
			      name: 'should set children as empty string',
			      value: '',
			      expected: ''
			    \},
			    \{
			      name: 'should create a div with text, children property',
			      value: 'string',
			      expected: 'string'
			    \},
			    \{
			      name: '0',
			      value: 0,
			      expected: '0'
			    \},
			    \{
			      name: '0 (cast to string)',
			      value: '0',
			      expected: '0'
			    \},
			    \{
			      name: 'negative number',
			      value: -44444,
			      expected: '-44444'
			    \},
			    \{
			      name: 'negative number (cast to string)',
			      value: '-2344',
			      expected: '-2344'
			    \},
			    \{
			      name: 'NaN',
			      value: NaN,
			      expected: 'NaN'
			    \},
			    \{
			      name: 'empty array',
			      value: [],
			      expected: ''
			    \},
			    \{
			      name: 'simple math',
			      value: 123 - 33,
			      expected: '90'
			    \},
			    \{
			      name: 'advanced math',
			      value: 123 - 33 / 4 - 444 * 345,
			      expected: '-153065.25'
			    \},
			    \{
			      name: 'number array',
			      value: [1, 2, 3],
			      expected: '123'
			    \},
			    \{
			      name: 'number array (long array)',
			      value: [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3],
			      expected: '123123123123'
			    \},
			    \{
			      name: 'number array (long mixed array)',
			      value: [1, '2', 3, '1', 2, 3, '1', 2, 3, 1, 2, '3'],
			      expected: '123123123123'
			    \},
			    \{
			      name: 'number array (long mixed array) and undefined and empty string',
			      value: [1, '2', '', '1', 2, 3, '1', 2, undefined, 1, 2, '3'],
			      expected: '1212312123'
			    \},
			    \{
			      name: 'number array (cast to string)',
			      value: ['1', '2', '3'],
			      expected: '123'
			    \},
			    \{
			      name: 'number array (cast to string) and various whitespaces',
			      value: [' 1 ', '2', '3  '],
			      expected: ' 1 23  '
			    \},
			    \{
			      name: 'single undefined in an array',
			      value: [1, 2, undefined],
			      expected: '12'
			    \},
			    \{
			      name: 'undefined in the middle of an array',
			      value: [1, undefined, 3],
			      expected: '13'
			    \},
			    \{
			      name: 'dobule undefined in an array',
			      value: [1, undefined, undefined],
			      expected: '1'
			    \},
			    \{
			      name: 'triple undefined in an array',
			      value: [undefined, undefined, undefined],
			      expected: ''
			    \},
			    \{
			      name: 'triple empty string in an array',
			      value: ['', '', ''],
			      expected: ''
			    \},
			    \{
			      name: 'triple null in an array',
			      value: [null, null, null],
			      expected: ''
			    \},
			    \{
			      name: 'single null in an array',
			      value: [null],
			      expected: ''
			    \},
			    \{
			      name: 'single null in an array',
			      value: ['\{\}'],
			      expected: '\{\}'
			    \},
			    \{
			      name: 'mix of null and undefined in an array',
			      value: [null, undefined],
			      expected: ''
			    \},
			    \{
			      name: 'mix of null, undefined and empty string in an array',
			      value: [null, undefined, ''],
			      expected: ''
			    \},
			    \{
			      name: 'mix of null, undefined and a number in an array',
			      value: [null, undefined, 123],
			      expected: '123'
			    \},
			    \{
			      name: 'mix of null, undefined and a number in an array',
			      value: [null, undefined, 123, ' ', undefined, null, undefined],
			      expected: '123 '
			    \},
			    \{
			      name: 'single empty string in an array',
			      value: [1, 2, ''],
			      expected: '12'
			    \},
			    \{
			      name: 'dobule empty string in an array',
			      value: [1, '', ''],
			      expected: '1'
			    \},
			    \{
			      name: 'triple empty string in an array',
			      value: ['', '', ''],
			      expected: ''
			    \},
			    \{
			      name: 'cast to string value, + single number in an array',
			      value: ['1', 2, 3],
			      expected: '123'
			    \},
			    \{
			      name: 'cast to strng value, + single number + a letter in an array',
			      value: ['1', 2, 'a'],
			      expected: '12a'
			    \},
			    \{
			      name: 'cast to strng value, + single number + a letter in an array',
			      value: ['1', null, 'a'],
			      expected: '1a'
			    \},
			    \{
			      name: 'cast to strng value, + single number + a letter in an array',
			      value: [undefined, null, 'a'],
			      expected: 'a'
			    \},
			    \{
			      name: 'cast to strng value, + single number + a letter in an array',
			      value: [undefined, null, 123, undefined, null],
			      expected: '123'
			    \}
			  ];
			
			  preDefined.forEach((arg, i) => \{
			    [
			      \{
			        description: 'should set static children as ' + arg.name,
			        template: () => createElement('div', null, arg.value)
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  preDefined.forEach((arg) => \{
			    [
			      \{
			        description: 'should set static deep children as ' + arg.name,
			        template: () => createElement('div', null, createElement('span', null, arg.value))
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  preDefined.forEach((arg) => \{
			    [
			      \{
			        description: 'should set very deep static children as ' + arg.name,
			        template: () => createElement('div', null, createElement('span', null, createElement('b', null, createElement('b', null, arg.value))))
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  preDefined.forEach((arg) => \{
			    [
			      \{
			        description: 'should set dynamic children as ' + arg.name,
			
			        template: (child) => createElement('div', null, child)
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			
			      it(test.description, () => \{
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			
			      it(test.description, () => \{
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			      \});
			
			      it(test.description, () => \{
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			        render(test.template(undefined), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			      \});
			
			      it(test.description, () => \{
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			      \});
			    \});
			  \});
			
			  preDefined.forEach((arg) => \{
			    [
			      \{
			        description: 'should set deep dynamic children as ' + arg.name,
			        template: (child) => createElement('div', null, createElement('b', null, child))
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			        render(test.template(arg.value), container);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			        render(test.template(null), container);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe('');
			        render(test.template(undefined), container);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe('');
			        render(test.template(), container);
			        expect(container.firstChild.firstChild.nodeType).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe('');
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\children.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(10)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\components.spec.js', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Components (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  it('should pass', () => \{
			    expect(true).toBeTruthy();
			  \});
			
			  if (typeof global !== 'undefined' && !global.usingJSDOM) \{
			    class BasicComponent1 extends Component \{
			      render() \{
			        const template = (name, title) =>
			          createElement(
			            'div',
			            \{
			              className: 'basic'
			            \},
			            createElement(
			              'span',
			              \{
			                className: name
			              \},
			              'The title is ',
			              title
			            )
			          );
			        return template(this.props.name, this.props.title);
			      \}
			    \}
			
			    it('should recover from a basic error', () => \{
			      const template = (Component, title) =>
			        createElement(
			          'div',
			          null,
			          createElement(Component, \{
			            title,
			            name: 'basic-render'
			          \})
			        );
			
			      expect(() => \{
			        render(template(null, 'abc'), container);
			      \}).toThrowError();
			
			      expect(() => \{
			        render(template(\{\}, 'abc'), container);
			      \}).toThrowError();
			
			      render(template(BasicComponent1, 'abc'), container);
			
			      expect(container.textContent).toBe('The title is abc');
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('basic-render');
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			      expect(container.firstChild.firstChild.firstChild.innerHTML).toBe('The title is abc');
			
			      expect(() => \{
			        render(template(\{\}, 'abc'), container);
			      \}).toThrowError();
			
			      expect(() => render(template(BasicComponent1, \{\}), container)).toThrow();
			
			      render(template(BasicComponent1, []), container);
			
			      expect(container.textContent).toBe('The title is ');
			
			      render(template(BasicComponent1, 'abcdef'), container);
			
			      expect(container.textContent).toBe('The title is abcdef');
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('basic-render');
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			      expect(container.firstChild.firstChild.firstChild.innerHTML).toBe('The title is abcdef');
			
			      render(template(BasicComponent1, null), container);
			
			      expect(container.textContent).toBe('The title is ');
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('basic-render');
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			      expect(container.firstChild.firstChild.firstChild.innerHTML).toBe('The title is ');
			
			      render(template(BasicComponent1, undefined), container);
			
			      expect(container.textContent).toBe('The title is ');
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('basic-render');
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			      expect(container.firstChild.firstChild.firstChild.innerHTML).toBe('The title is ');
			
			      render(template(BasicComponent1, '1234'), container);
			
			      expect(container.textContent).toBe('The title is 1234');
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('basic-render');
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			      expect(container.firstChild.firstChild.firstChild.innerHTML).toBe('The title is 1234');
			    \});
			
			    class BasicComponent1b extends Component \{
			      render() \{
			        const template = (isChecked, title) =>
			          createElement(
			            'div',
			            \{
			              className: 'basic'
			            \},
			            createElement(
			              'label',
			              \{\},
			              createElement('input', \{
			                type: 'checkbox',
			                checked: isChecked
			              \}),
			              'The title is ',
			              title
			            )
			          );
			        return template(this.props.isChecked, this.props.title);
			      \}
			    \}
			
			    it('should render a basic component with inputs', () => \{
			      const template = (Component, title, isChecked) =>
			        createElement(
			          'div',
			          null,
			          createElement(Component, \{
			            title,
			            isChecked
			          \})
			        );
			
			      render(null, container);
			
			      render(template(BasicComponent1b, 'abc', true), container);
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.firstChild.getAttribute('type')).toBe('checkbox');
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('LABEL');
			      expect(container.firstChild.firstChild.firstChild.innerHTML).toBe('<input type="checkbox">The title is abc');
			      expect(container.querySelector('input').checked).toBe(true);
			
			      render(null, container);
			      render(null, container);
			
			      render(template(BasicComponent1b, 'abc', null), container);
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.firstChild.getAttribute('type')).toBe('checkbox');
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('LABEL');
			      expect(container.firstChild.firstChild.firstChild.innerHTML).toBe('<input type="checkbox">The title is abc');
			      expect(container.querySelector('input').checked).toBe(false);
			    \});
			
			    class BasicComponent1c extends Component \{
			      render() \{
			        const template = (isEnabled, title, type) =>
			          createElement(
			            'div',
			            \{
			              className: 'basic'
			            \},
			            createElement(
			              'label',
			              \{\},
			              createElement('input', \{
			                type,
			                disabled: !isEnabled
			              \}),
			              'The title is ',
			              title
			            )
			          );
			        return template(this.props.isEnabled, this.props.title, this.props.type);
			      \}
			    \}
			
			    it('should render a basic component with input tag and attributes', () => \{
			      const template = (Component, title, isEnabled) =>
			        createElement(
			          'div',
			          null,
			          createElement(Component, \{
			            title,
			            isEnabled,
			            type: 'password'
			          \})
			        );
			
			      render(template(BasicComponent1c, 'abc', true), container);
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('LABEL');
			      expect(container.firstChild.firstChild.firstChild.firstChild.tagName).toBe('INPUT');
			      expect(container.firstChild.firstChild.firstChild.firstChild.getAttribute('type')).toBe('password');
			      expect(container.firstChild.firstChild.firstChild.firstChild.disabled).toBe(false);
			      expect(container.firstChild.firstChild.firstChild.textContent).toBe('The title is abc');
			      render(template(BasicComponent1c, ['abc'], true), container);
			      expect(container.firstChild.firstChild.tagName).toBe('DIV');
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			      expect(container.firstChild.firstChild.firstChild.tagName).toBe('LABEL');
			      expect(container.firstChild.firstChild.firstChild.firstChild.tagName).toBe('INPUT');
			      expect(container.firstChild.firstChild.firstChild.firstChild.getAttribute('type')).toBe('password');
			      expect(container.firstChild.firstChild.firstChild.firstChild.disabled).toBe(false);
			      expect(container.firstChild.firstChild.firstChild.textContent).toBe('The title is abc');
			    \});
			
			    class BasicComponent1d extends Component \{
			      render() \{
			        const template = (isDisabled, title) =>
			          createElement(
			            'div',
			            \{ className: 'basic' \},
			            createElement(
			              'label',
			              \{\},
			              createElement('input', \{
			                disabled: isDisabled,
			                type: 'password'
			              \}),
			              'The title is ',
			              title
			            )
			          );
			        return template(this.props.isDisabled, this.props.title);
			      \}
			    \}
			
			    it('should render a basic component with inputs #3 #3', () => \{
			      const template = (Component, title, isDisabled) => createElement('div', null, createElement(Component, \{ title, isDisabled \}));
			      render(template(BasicComponent1d, 'abc', true), container);
			      expect(container.innerHTML).toBe('<div><div class="basic"><label><input disabled="" type="password">The title is abc</label></div></div>');
			      expect(container.querySelector('input').disabled).toBe(true);
			
			      render(template(BasicComponent1d, '123', false), container);
			      expect(container.innerHTML).toBe('<div><div class="basic"><label><input type="password">The title is 123</label></div></div>');
			      expect(container.querySelector('input').disabled).toBe(false);
			    \});
			
			    it('should render a basic component and remove property if null #1', () => \{
			      const template = (Component, title, name) => createElement('div', null, createElement(Component, \{ title, name \}));
			
			      render(template(BasicComponent1, 'abc', 'basic-render'), container);
			
			      expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is abc</span></div></div>');
			
			      render(template(BasicComponent1, '123', null), container);
			      expect(container.innerHTML).toBe('<div><div class="basic"><span>The title is 123</span></div></div>');
			    \});
			
			    it('should render a basic component and remove property if null #2', () => \{
			      const template = (Component, title, name) => createElement('div', null, createElement(Component, \{ title, name \}));
			
			      render(template(BasicComponent1, 'abc', null), container);
			
			      expect(container.innerHTML).toBe('<div><div class="basic"><span>The title is abc</span></div></div>');
			
			      render(null, container);
			
			      render(template(BasicComponent1, '123', 'basic-update'), container);
			      expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-update">The title is 123</span></div></div>');
			    \});
			
			    it('should render a basic root component', () => \{
			      const template = (Component, title, name) => createElement(Component, \{ title, name \});
			
			      render(template(BasicComponent1, 'abc', 'basic-render'), container);
			
			      expect(container.innerHTML).toBe('<div class="basic"><span class="basic-render">The title is abc</span></div>');
			      render(template(BasicComponent1, 'abc', 'basic-render'), container);
			
			      expect(container.innerHTML).toBe('<div class="basic"><span class="basic-render">The title is abc</span></div>');
			
			      render(template(BasicComponent1, 'abc', \{\}), container);
			
			      expect(container.innerHTML).toBe('<div class="basic"><span class="[object Object]">The title is abc</span></div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    class BasicComponent2 extends Component \{
			      render() \{
			        const template = (name, title, children) =>
			          createElement(
			            'div',
			            \{
			              className: 'basic'
			            \},
			            createElement(
			              'span',
			              \{
			                className: name
			              \},
			              'The title is ',
			              title
			            ),
			            children
			          );
			        return template(this.props.name, this.props.title, this.props.children);
			      \}
			    \}
			
			    it('should render a basic component with children', () => \{
			      const template = (Component, title, name) =>
			        createElement(
			          'div',
			          null,
			          createElement(
			            Component,
			            \{
			              title,
			              name
			            \},
			            createElement('span', null, "I'm a child")
			          )
			        );
			
			      render(template(BasicComponent2, 'abc', 'basic-render'), container);
			
			      expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is abc</span><span>I\\'m a child</span></div></div>');
			      render(template(BasicComponent2, 'abc', 'basic-render'), container);
			
			      expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is abc</span><span>I\\'m a child</span></div></div>');
			
			      render(template(BasicComponent2, '123', 'basic-update'), container);
			      expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-update">The title is 123</span><span>I\\'m a child</span></div></div>');
			      render(template(BasicComponent2, '1234', 'basic-update'), container);
			      expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-update">The title is 1234</span><span>I\\'m a child</span></div></div>');
			    \});
			
			    class BasicComponent2b extends Component \{
			      render() \{
			        const template = (children) => createElement('div', null, createElement('span', null, 'component!'), createElement('div', null, children));
			        return template(this.props.children);
			      \}
			    \}
			
			    class BasicComponent2c extends Component \{
			      render() \{
			        const template = (children) => createElement('div', null, createElement('span', null, 'other component!'), createElement('div', null, children));
			        return template(this.props.children);
			      \}
			    \}
			
			    class BasicComponent3 extends Component \{
			      render() \{
			        const template = (styles, title) =>
			          createElement(
			            'div',
			            \{
			              style: styles
			            \},
			            createElement(
			              'span',
			              \{
			                style: styles
			              \},
			              'The title is ',
			              title
			            )
			          );
			
			        return template(this.props.styles, this.props.title);
			      \}
			    \}
			
			    if (typeof global !== 'undefined' && !global.usingJSDOM) \{
			      it('should render a basic component with styling', () => \{
			        const template = (Component, props) => createElement(Component, props);
			
			        render(
			          template(BasicComponent3, \{
			            title: 'styled!',
			            styles: \{
			              color: 'red',
			              'padding-left': '10px'
			            \}
			          \}),
			          container
			        );
			
			        expect(container.innerHTML).toBe(
			          '<div style="color: red; padding-left: 10px;"><span style="color: red; padding-left: 10px;">The title is styled!</span></div>'
			        );
			        render(
			          template(BasicComponent3, \{
			            title: 'styled!',
			            styles: \{
			              color: 'red',
			              'padding-left': '10px'
			            \}
			          \}),
			          container
			        );
			
			        expect(container.innerHTML).toBe(
			          '<div style="color: red; padding-left: 10px;"><span style="color: red; padding-left: 10px;">The title is styled!</span></div>'
			        );
			
			        render(
			          template(BasicComponent3, \{
			            title: 'styled (again)!',
			            styles: \{
			              color: 'blue',
			              'padding-right': '20px'
			            \}
			          \}),
			          container
			        );
			        expect(container.innerHTML).toBe(
			          '<div style="color: blue; padding-right: 20px;"><span style="color: blue; padding-right: 20px;">The title is styled (again)!</span></div>'
			        );
			      \});
			    \}
			
			    it('should render a basic component with component children', () => \{
			      const template = (Component1, Component2, Component3) =>
			        createElement(Component1, null, createElement(Component2, null, createElement(Component3, null)));
			      render(template(BasicComponent2b, BasicComponent2b, BasicComponent2b), container);
			
			      expect(container.innerHTML).toBe(
			        '<div><span>component!</span><div><div><span>component!</span><div><div><span>component!</span><div></div></div></div></div></div></div>'
			      );
			
			      render(null, container);
			
			      render(template(BasicComponent2b, BasicComponent2b, BasicComponent2b), container);
			      expect(container.innerHTML).toBe(
			        '<div><span>component!</span><div><div><span>component!</span><div><div><span>component!</span><div></div></div></div></div></div></div>'
			      );
			
			      render(template(BasicComponent2b, BasicComponent2b, BasicComponent2c), container);
			      expect(container.innerHTML).toBe(
			        '<div><span>component!</span><div><div><span>component!</span><div><div><span>other component!</span><div></div></div></div></div></div></div>'
			      );
			
			      render(template(BasicComponent2b, BasicComponent2c, BasicComponent2c), container);
			      expect(container.innerHTML).toBe(
			        '<div><span>component!</span><div><div><span>other component!</span><div><div><span>other component!</span><div></div></div></div></div></div></div>'
			      );
			
			      render(template(BasicComponent2b, BasicComponent2c, BasicComponent2c), container);
			      expect(container.innerHTML).toBe(
			        '<div><span>component!</span><div><div><span>other component!</span><div><div><span>other component!</span><div></div></div></div></div></div></div>'
			      );
			
			      render(template(BasicComponent2c, BasicComponent2c, BasicComponent2c), container);
			      expect(container.innerHTML).toBe(
			        '<div><span>other component!</span><div><div><span>other component!</span><div><div><span>other component!</span><div></div></div></div></div></div></div>'
			      );
			      render(template(BasicComponent2c, BasicComponent2c, BasicComponent2c), container);
			      expect(container.innerHTML).toBe(
			        '<div><span>other component!</span><div><div><span>other component!</span><div><div><span>other component!</span><div></div></div></div></div></div></div>'
			      );
			    \});
			
			    it('should render a basic component and correctly mount', () => \{
			      let template;
			      let componentWillMountCount;
			
			      class ComponentLifecycleCheck extends Component \{
			        render() \{
			          const _template = (children) => createElement('div', null, createElement('span', null, 'component!'), createElement('div', null, children));
			          return _template(this.props.children);
			        \}
			
			        componentWillMount() \{
			          componentWillMountCount++;
			        \}
			      \}
			
			      componentWillMountCount = 0;
			      template = (Component1, Component2, Component3) => createElement(Component1, null, createElement(Component2, null, createElement(Component3, null)));
			
			      render(template(ComponentLifecycleCheck, ComponentLifecycleCheck, ComponentLifecycleCheck), container);
			      expect(componentWillMountCount).toBe(3);
			
			      render(template(ComponentLifecycleCheck, ComponentLifecycleCheck, ComponentLifecycleCheck), container);
			      expect(componentWillMountCount).toBe(3);
			    \});
			
			    describe('should render multiple components', () => \{
			      it('should render multiple components', () => \{
			        const template = (Component, title1, name1, Component2, title2, name2) =>
			          createElement(
			            'div',
			            null,
			            createElement(Component, \{
			              title: title1,
			              name: name1
			            \}),
			            createElement(Component2, \{
			              title: title2,
			              name: name2
			            \})
			          );
			
			        render(template(BasicComponent1, 'component 1', 'basic-render', BasicComponent1, 'component 2', 'basic-render'), container);
			
			        expect(container.innerHTML).toBe(
			          '<div><div class="basic"><span class="basic-render">The title is component 1</span></div>' +
			            '<div class="basic"><span class="basic-render">The title is component 2</span></div></div>'
			        );
			
			        render(template(BasicComponent1, 'component 1', 'basic-render', BasicComponent1, 'component 2', 'basic-render'), container);
			
			        expect(container.innerHTML).toBe(
			          '<div><div class="basic"><span class="basic-render">The title is component 1</span></div>' +
			            '<div class="basic"><span class="basic-render">The title is component 2</span></div></div>'
			        );
			      \});
			    \});
			
			    it('should mount and unmount a basic component', () => \{
			      let mountCount;
			      let unmountCount;
			      let template;
			
			      class ComponentLifecycleCheck extends Component \{
			        render() \{
			          const _template = () => createElement('div', null, createElement('span', null));
			          return _template();
			        \}
			
			        componentDidMount() \{
			          mountCount++;
			        \}
			
			        componentWillUnmount() \{
			          unmountCount++;
			        \}
			      \}
			
			      mountCount = 0;
			      unmountCount = 0;
			      template = (Component) => createElement(Component, null);
			      render(template(ComponentLifecycleCheck), container);
			
			      expect(mountCount).toBe(1);
			      render(null, container);
			      expect(unmountCount).toBe(1);
			    \});
			
			    it('should mount and unmount a basic component #2', () => \{
			      let mountCount;
			      let unmountCount;
			
			      class ComponentLifecycleCheck extends Component \{
			        render() \{
			          return createElement('div', null, createElement('span', null));
			        \}
			
			        componentDidMount() \{
			          mountCount++;
			        \}
			
			        componentWillUnmount() \{
			          unmountCount++;
			        \}
			      \}
			
			      mountCount = 0;
			      unmountCount = 0;
			
			      render(createElement(ComponentLifecycleCheck, null), container);
			      expect(mountCount).toBe(1);
			      render(null, container);
			      expect(unmountCount).toBe(1);
			      render(createElement(ComponentLifecycleCheck, null), container);
			      expect(mountCount).toBe(2);
			      render(null, container);
			      expect(unmountCount).toBe(2);
			    \});
			
			    describe('state changes should trigger all lifecycle events for an update', () => \{
			      let componentWillMountCount;
			      let template;
			
			      class ComponentLifecycleCheck extends Component \{
			        constructor() \{
			          super(null);
			          this.state = \{
			            counter: 0
			          \};
			        \}
			
			        render() \{
			          const _template = (counter) => createElement('div', null, createElement('span', \{\}, counter));
			          return _template(this.state.counter);
			        \}
			
			        componentWillMount() \{
			          componentWillMountCount++;
			          this.setState(\{
			            counter: this.state.counter + 1
			          \});
			        \}
			      \}
			
			      beforeEach(() => \{
			        componentWillMountCount = 0;
			        template = (Component) => createElement(Component, null);
			        render(template(ComponentLifecycleCheck), container);
			      \});
			
			      it('componentWillMountCount to have fired once', () => \{
			        expect(componentWillMountCount).toBe(1);
			      \});
			      it('the element in the component should show the new state', () => \{
			        expect(container.innerHTML).toBe('<div><span>1</span></div>');
			      \});
			    \});
			
			    describe('state changes should trigger all lifecycle events for an update #2', () => \{
			      let componentWillMountCount;
			      let shouldComponentUpdateCount;
			      let componentDidUpdateCount;
			      let componentWillUpdateCount;
			      let template;
			      let update;
			
			      class ComponentLifecycleCheck extends Component \{
			        constructor() \{
			          super(null);
			          this.state = \{
			            counter: 0
			          \};
			
			          update = () => \{
			            this.setState(\{
			              counter: this.state.counter + 1
			            \});
			          \};
			        \}
			
			        render() \{
			          const _template = (counter) => createElement('div', null, createElement('span', \{\}, counter));
			          return _template(this.state.counter);
			        \}
			
			        componentWillMount() \{
			          componentWillMountCount++;
			        \}
			
			        shouldComponentUpdate() \{
			          shouldComponentUpdateCount++;
			          return true;
			        \}
			
			        componentDidUpdate() \{
			          componentDidUpdateCount++;
			        \}
			
			        componentWillUpdate() \{
			          componentWillUpdateCount++;
			        \}
			      \}
			
			      beforeEach(() => \{
			        componentWillMountCount = 0;
			        shouldComponentUpdateCount = 0;
			        componentDidUpdateCount = 0;
			        componentWillUpdateCount = 0;
			        template = (Component) => createElement(Component, null);
			        render(template(ComponentLifecycleCheck), container);
			        update();
			      \});
			
			      it('componentWillMountCount to have fired once', () => \{
			        expect(componentWillMountCount).toBe(1);
			      \});
			      it('shouldComponentUpdateCount to have fired once', () => \{
			        expect(shouldComponentUpdateCount).toBe(1);
			      \});
			      it('componentWillUpdateCount to have fired once', () => \{
			        expect(componentWillUpdateCount).toBe(1);
			      \});
			      it('componentDidUpdateCount to have fired once', () => \{
			        expect(componentDidUpdateCount).toBe(1);
			      \});
			      it('the element in the component should show the new state', () => \{
			        expect(container.innerHTML).toBe('<div><span>1</span></div>');
			      \});
			    \});
			
			    describe('should render a basic component with conditional fragment', () => \{
			      const tpl3625453295 = function () \{
			        return createElement('h1', null, 'BIG');
			      \};
			      const tpl4021787591 = function () \{
			        return createElement('h2', null, 'small');
			      \};
			
			      class ConditionalComponent extends Component \{
			        render() \{
			          return createElement('div', null, [this.props.condition ? tpl3625453295() : tpl4021787591(), createElement('p', null, 'test')]);
			        \}
			      \}
			
			      it('Initial render (creation)', () => \{
			        render(createElement(ConditionalComponent, \{ condition: true \}), container);
			        expect(container.innerHTML).toBe('<div><h1>BIG</h1><p>test</p></div>');
			        render(createElement(ConditionalComponent, \{ condition: false \}), container);
			        expect(container.innerHTML).toBe('<div><h2>small</h2><p>test</p></div>');
			      \});
			    \});
			
			    describe('should render a basic component with a list of values from state', () => \{
			      const tpl2026545261 = function (v0) \{
			        return createElement('ul', \{ class: 'login-organizationlist' \}, '', v0, '');
			      \};
			      const tpl3192647933 = function (v0) \{
			        return createElement('li', null, v0);
			      \};
			      const tpl1546018623 = function (v0) \{
			        return createElement(v0, null);
			      \};
			
			      class ValueComponent extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            organizations: [
			              \{ name: 'test1', key: '1' \},
			              \{ name: 'test2', key: 2 \},
			              \{ name: 'test3', key: '3' \},
			              \{ name: 'test4', key: '4' \},
			              \{ name: 'test5', key: '5' \},
			              \{ name: 'test6', key: '6' \}
			            ]
			          \};
			        \}
			
			        render() \{
			          return tpl2026545261(
			            this.state.organizations.map(function (result) \{
			              return tpl3192647933(result.name);
			            \})
			          );
			        \}
			      \}
			
			      it('Initial render (creation)', () => \{
			        render(tpl1546018623(ValueComponent), container);
			        expect(container.innerHTML).toBe(
			          '<ul class="login-organizationlist"><li>test1</li><li>test2</li><li>test3</li><li>test4</li><li>test5</li><li>test6</li></ul>'
			        );
			        render(tpl1546018623(ValueComponent), container);
			        expect(container.innerHTML).toBe(
			          '<ul class="login-organizationlist"><li>test1</li><li>test2</li><li>test3</li><li>test4</li><li>test5</li><li>test6</li></ul>'
			        );
			        render(tpl1546018623(ValueComponent), container);
			        expect(container.innerHTML).toBe(
			          '<ul class="login-organizationlist"><li>test1</li><li>test2</li><li>test3</li><li>test4</li><li>test5</li><li>test6</li></ul>'
			        );
			      \});
			    \});
			
			    describe('BasicStateless', () => \{
			      function BasicStatelessComponent1(\{ name, title \}) \{
			        const template = (_name, _title) =>
			          createElement(
			            'div',
			            \{
			              className: 'basic'
			            \},
			            createElement(
			              'span',
			              \{
			                className: _name
			              \},
			              'The title is ',
			              _title
			            )
			          );
			        return template(name, title);
			      \}
			
			      it('should render a stateless component', () => \{
			        const template = (Component, title) =>
			          createElement(
			            'div',
			            null,
			            createElement(Component, \{
			              title,
			              name: 'Hello, World!'
			            \})
			          );
			
			        render(template(BasicStatelessComponent1, 'abc'), container);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			        expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('Hello, World!');
			        expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			        expect(container.firstChild.firstChild.firstChild.textContent).toBe('The title is abc');
			        render(template(BasicStatelessComponent1, null), container);
			        render(template(BasicStatelessComponent1, 'abc'), container);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			        expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('Hello, World!');
			        expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			        expect(container.firstChild.firstChild.firstChild.textContent).toBe('The title is abc');
			
			        render(template(BasicStatelessComponent1), container);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			        expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('Hello, World!');
			        expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			        expect(container.firstChild.firstChild.firstChild.textContent).toBe('The title is ');
			
			        render(template(BasicStatelessComponent1), container);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.getAttribute('class')).toBe('basic');
			        expect(container.firstChild.firstChild.firstChild.getAttribute('class')).toBe('Hello, World!');
			        expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			        expect(container.firstChild.firstChild.firstChild.textContent).toBe('The title is ');
			      \});
			    \});
			
			    describe('should render a component with a conditional state item', () => \{
			      const tpl3578458729 = function (v0) \{
			        return createElement('div', \{ className: 'login-view bg-visma' \}, v0);
			      \};
			      const tpl188998005 = function () \{
			        return createElement('div', null, 'VISIBLE');
			      \};
			
			      const tpl3754840163 = function (v0) \{
			        return createElement('div', null, createElement('button', \{ onclick: v0 \}, 'Make visible'));
			      \};
			
			      class TEST extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            show: false
			          \};
			
			          this.makeVisible = function () \{
			            this.setState(\{
			              show: true
			            \});
			          \}.bind(this);
			        \}
			
			        render() \{
			          return tpl3578458729(
			            function () \{
			              if (this.state.show === true) \{
			                return tpl188998005();
			              \} else \{
			                return tpl3754840163(this.makeVisible);
			              \}
			            \}.call(this)
			          );
			        \}
			      \}
			
			      const tpl79713834 = function (v0) \{
			        return createElement(v0, null);
			      \};
			
			      it('Initial render (creation)', () => \{
			        render(tpl79713834(TEST), container);
			        expect(container.innerHTML).toBe('<div class="login-view bg-visma"><div><button>Make visible</button></div></div>');
			      \});
			
			      it('Second render (update with state change)', (done) => \{
			        render(tpl79713834(TEST), container);
			        render(tpl79713834(TEST), container);
			        const buttons = container.querySelectorAll('button');
			
			        buttons.forEach((button) => button.click());
			
			        setTimeout(() => \{
			          expect(container.innerHTML).toBe('<div class="login-view bg-visma"><div>VISIBLE</div></div>');
			          done();
			        \}, 25);
			      \});
			    \});
			
			    describe('should render a component with a list of divs', () => \{
			      const BaseView = function (v0, v1) \{
			        return createElement('div', \{ class: 'login-view' \}, createElement('button', \{ onclick: v0 \}, 'ADD'), createElement('br', null), v1);
			      \};
			
			      const Looper = function (v0) \{
			        return createElement('div', null, createElement('h1', null, v0));
			      \};
			
			      const starter = function (v0) \{
			        return createElement(v0, null);
			      \};
			
			      class SomeError extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            list: ['SS', 'SS1']
			          \};
			        \}
			
			        render() \{
			          /* eslint new-cap:0 */
			          return BaseView(
			            this.toggle,
			            function () \{
			              return this.state.list.map(function (result) \{
			                return Looper(result);
			              \});
			            \}.call(this)
			          );
			        \}
			      \}
			
			      it('Initial render (creation)', () => \{
			        render(starter(SomeError), container);
			
			        expect(container.innerHTML).toBe('<div class="login-view"><button>ADD</button><br><div><h1>SS</h1></div><div><h1>SS1</h1></div></div>');
			
			        render(starter(SomeError), container);
			
			        expect(container.innerHTML).toBe('<div class="login-view"><button>ADD</button><br><div><h1>SS</h1></div><div><h1>SS1</h1></div></div>');
			      \});
			    \});
			
			    describe('should render a component with a list of text nodes', () => \{
			      const root = function (children) \{
			        return createElement('div', null, children);
			      \};
			
			      const header = function (children) \{
			        return createElement('div', null, children);
			      \};
			
			      const view = function (state) \{
			        return root([state ? header(['Foo']) : header(['Bar', 'Qux'])]);
			      \};
			
			      it('Initial render (creation)', () => \{
			        render(view(true), container);
			        expect(container.innerHTML).toBe('<div><div>Foo</div></div>');
			      \});
			      it('Second render (update)', () => \{
			        render(view(true), container);
			        render(view(false), container);
			        expect(container.innerHTML).toBe('<div><div>BarQux</div></div>');
			      \});
			    \});
			
			    describe('SetState function callback', () => \{
			      it('Should have state, props, and context as parameters', (done) => \{
			        function checkParams(state, props, context) \{
			          expect(state).toEqual(\{ btnstate: 'btnstate' \});
			          expect(props).toEqual(\{ buttonProp: 'magic', children: 'btn' \});
			          expect(context).toEqual(\{ color: 'purple' \});
			          done();
			        \}
			
			        class Button extends Component \{
			          constructor(props) \{
			            super(props);
			            this.state = \{
			              btnstate: 'btnstate'
			            \};
			          \}
			
			          click() \{
			            this.setState(checkParams);
			          \}
			
			          render() \{
			            return createElement(
			              'button',
			              \{
			                onClick: this.click.bind(this),
			                style: \{
			                  background: this.context.color
			                \}
			              \},
			              this.props.children
			            );
			          \}
			        \}
			
			        class Message extends Component \{
			          render() \{
			            return createElement('div', null, [this.props.text, createElement(Button, \{ buttonProp: 'magic' \}, 'btn')]);
			          \}
			        \}
			
			        class MessageList extends Component \{
			          getChildContext() \{
			            return \{ color: 'purple' \};
			          \}
			
			          render() \{
			            const children = this.props.messages.map(function (message) \{
			              return createElement(Message, \{ text: message.text \});
			            \});
			
			            return createElement('div', null, children);
			          \}
			        \}
			
			        render(
			          createElement(MessageList, \{
			            messages: [\{ text: 'eka' \}, \{ text: 'toka' \}]
			          \}),
			          container
			        );
			
			        container.querySelector('button').click();
			      \});
			    \});
			  \}
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\components.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(31)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\components.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render, rerender \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Components (JSX)', () => \{
			  let container;
			  let Inner;
			  let attachedListener = null;
			  let renderedName = null;
			
			  beforeEach(function () \{
			    attachedListener = null;
			    renderedName = null;
			    container = document.createElement('div');
			    document.body.appendChild(container);
			
			    Inner = class extends Component \{
			      render() \{
			        attachedListener = this.props.onClick;
			        renderedName = this.props.name;
			        return <div className=\{this.props.name\} />;
			      \}
			    \};
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  class BasicComponent1 extends Component \{
			    render() \{
			      return (
			        <div className="basic">
			          <span className=\{this.props.name\}>The title is \{this.props.title\}</span>
			        </div>
			      );
			    \}
			  \}
			
			  it('should render a basic component jsx', () => \{
			    render(
			      <div>
			        <BasicComponent1 title="abc" name="basic-render" />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is abc</span></div></div>');
			
			    render(
			      <div>
			        <BasicComponent1 title="abc" name="basic-render" />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is abc</span></div></div>');
			
			    const attrs = \{ title: 'abc', name: 'basic-render2', foo: 'bar' \};
			
			    // JSX Spread Attribute
			    render(
			      <div>
			        <BasicComponent1 \{...attrs\} />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render2">The title is abc</span></div></div>');
			  \});
			
			  class BasicComponent1b extends Component \{
			    render() \{
			      return (
			        <div className="basic">
			          <label>
			            <input checked=\{this.props.isChecked\} />
			            The title is \{this.props.title\}
			          </label>
			        </div>
			      );
			    \}
			  \}
			
			  it('should render a basic component with inputs', () => \{
			    render(
			      <div>
			        <BasicComponent1b title="abc" isChecked=\{true\} />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><label><input>The title is abc</label></div></div>');
			    expect(container.querySelector('input').checked).toBe(true);
			
			    render(
			      <div>
			        <BasicComponent1b title="123" isChecked=\{false\} />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div class="basic"><label><input>The title is 123</label></div></div>');
			    expect(container.querySelector('input').checked).toBe(false);
			
			    render(
			      <div>
			        <BasicComponent1b title="123" isChecked=\{null\} />
			      </div>,
			      container
			    );
			
			    render(<div />, container);
			
			    render(
			      <div>
			        <BasicComponent1b title="123" isChecked=\{true\} />
			      </div>,
			      container
			    );
			    expect(container.querySelector('input').checked).toBe(true);
			  \});
			
			  it('should render a basic component and remove property if null', () => \{
			    render(
			      <div>
			        <BasicComponent1 title="abc" name="basic-render" />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is abc</span></div></div>');
			
			    render(<div />, container);
			    render(
			      <div>
			        <BasicComponent1 title="Hello, World!" name="basic-render" />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is Hello, World!</span></div></div>');
			
			    render(
			      <div>
			        <BasicComponent1 title="123" name=\{null\} />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div class="basic"><span>The title is 123</span></div></div>');
			    render(
			      <div>
			        <BasicComponent1 title=\{[]\} name=\{null\} />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div class="basic"><span>The title is </span></div></div>');
			
			    render(
			      <div>
			        <BasicComponent1 title=\{null\} name=\{null\} />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span>The title is </span></div></div>');
			
			    render(
			      <div>
			        <BasicComponent1 title="abc" name=\{null\} />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span>The title is abc</span></div></div>');
			
			    render(
			      <div>
			        <BasicComponent1 title="123" name="basic-update" />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-update">The title is 123</span></div></div>');
			  \});
			
			  it('should render a basic root component', () => \{
			    render(<BasicComponent1 title="abc" name="basic-render" />, container);
			
			    expect(container.firstChild.getAttribute('class')).toBe('basic');
			
			    render(<BasicComponent1 title="abc" name="basic-render" />, container);
			
			    expect(container.firstChild.getAttribute('class')).toBe('basic');
			
			    render(<BasicComponent1 title="123" name="basic-update" />, container);
			    expect(container.innerHTML).toBe('<div class="basic"><span class="basic-update">The title is 123</span></div>');
			  \});
			
			  class BasicComponent2 extends Component \{
			    render() \{
			      return (
			        <div className="basic">
			          <span className=\{this.props.name\}>The title is \{this.props.title\}</span>
			          \{this.props.children\}
			        </div>
			      );
			    \}
			  \}
			
			  it('should render a basic component with children', () => \{
			    render(
			      <div>
			        <BasicComponent2 title="abc" name="basic-render">
			          <span>Im a child</span>
			        </BasicComponent2>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is abc</span><span>Im a child</span></div></div>');
			
			    render(
			      <div>
			        <BasicComponent2 title="123" name="basic-update">
			          <span>Im a child</span>
			        </BasicComponent2>
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-update">The title is 123</span><span>Im a child</span></div></div>');
			  \});
			
			  it('should render multiple components', () => \{
			    render(
			      <div>
			        <BasicComponent1 title="component 1" name="basic-render" />
			        <BasicComponent1 title="component 2" name="basic-render" />
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toBe(
			      '<div><div class="basic"><span class="basic-render">The title is component 1</span></div>' +
			        '<div class="basic"><span class="basic-render">The title is component 2</span></div></div>'
			    );
			
			    render(
			      <div>
			        <BasicComponent1 title="component 1" name="basic-render" />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div class="basic"><span class="basic-render">The title is component 1</span></div></div>');
			  \});
			
			  class BasicComponent3 extends Component \{
			    render() \{
			      return (
			        <div style=\{this.props.styles\}>
			          <span style=\{this.props.styles\}>The title is \{this.props.title\}</span>
			        </div>
			      );
			    \}
			  \}
			
			  it('should render a basic component with styling', () => \{
			    render(<BasicComponent3 title="styled!" styles=\{\{ color: 'red', 'padding-left': '10px' \}\} />, container);
			
			    expect(container.innerHTML).toBe(
			      '<div style="color: red; padding-left: 10px;"><span style="color: red; padding-left: 10px;">The title is styled!</span></div>'
			    );
			
			    render(<BasicComponent3 />, container);
			
			    render(<BasicComponent3 title="styled (again)!" styles=\{\{ color: 'blue', 'margin-bottom': '20px' \}\} />, container);
			
			    expect(container.innerHTML).toBe(
			      '<div style="color: blue; margin-bottom: 20px;"><span style="color: blue; margin-bottom: 20px;">The title is styled (again)!</span></div>'
			    );
			  \});
			
			  it('should render a basic component and remove styling', () => \{
			    render(<BasicComponent3 title="styled!" styles=\{\{ color: 'red', 'padding-top': '20px' \}\} />, container);
			
			    expect(container.innerHTML).toBe(
			      '<div style="color: red; padding-top: 20px;"><span style="color: red; padding-top: 20px;">The title is styled!</span></div>'
			    );
			
			    render(<BasicComponent3 title="styles are removed!" styles=\{null\} />, container);
			
			    expect([null, '']).toContain(container.firstChild.getAttribute('style'));
			    expect(container.firstChild.tagName).toEqual('DIV');
			    expect(container.firstChild.firstChild.innerHTML).toEqual('The title is styles are removed!');
			  \});
			
			  class SuperComponent extends Component \{
			    constructor(props) \{
			      super(props);
			      this.state = \{
			        organizations: [
			          \{ name: 'test1', key: '1' \},
			          \{ name: 'test2', key: '2' \},
			          \{ name: 'test3', key: '3' \},
			          \{ name: 'test4', key: '4' \},
			          \{ name: 'test5', key: '5' \},
			          \{ name: 'test6', key: '6' \}
			        ]
			      \};
			    \}
			
			    render() \{
			      return (
			        <ul class="login-organizationlist">
			          \{this.state.organizations.map((result) => \{
			            return <li>\{result.name\}</li>;
			          \})\}
			        </ul>
			      );
			    \}
			  \}
			  it('should render a basic component with a list of values from state', () => \{
			    render(<SuperComponent />, container);
			    expect(container.innerHTML).toBe(
			      '<ul class="login-organizationlist"><li>test1</li><li>test2</li><li>test3</li><li>test4</li><li>test5</li><li>test6</li></ul>'
			    );
			  \});
			
			  it('should render a basic component with an element and components as children', () => \{
			    class Navbar extends Component \{
			      render() \{
			        return (
			          <ul>
			            <li>Nav1</li>
			          </ul>
			        );
			      \}
			    \}
			
			    class Main extends Component \{
			      render() \{
			        return (
			          <div className="main">
			            <Navbar />
			            <div id="app" />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Main />, container);
			  \});
			
			  function test(element, expectedTag, expectedClassName, callback) \{
			    render(element, container, () => \{
			      expect(container.firstChild).not.toBe(null);
			      expect(container.firstChild.tagName).toBe(expectedTag);
			      expect(container.firstChild.className).toBe(expectedClassName);
			      callback();
			    \});
			  \}
			
			  it('should only render once when setting state in componentWillMount', function (done) \{
			    let renderCount = 0;
			    class Foo extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ bar: props.initialValue \};
			      \}
			
			      componentWillMount() \{
			        this.setState(\{ bar: 'bar' \});
			      \}
			
			      render() \{
			        renderCount++;
			        return <span className=\{this.state.bar\} />;
			      \}
			    \}
			    test(<Foo initialValue=\{null\} />, 'SPAN', 'bar', () => \{
			      test(<Foo initialValue="foo" />, 'SPAN', 'bar', () => \{
			        expect(renderCount).toBe(2);
			        done();
			      \});
			    \});
			  \});
			
			  it('should render with null in the initial state property', function (done) \{
			    class Foo extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = null;
			      \}
			
			      render() \{
			        return <span />;
			      \}
			    \}
			    test(<Foo />, 'SPAN', '', done);
			  \});
			
			  it('should setState through an event handler', (done) => \{
			    class Foo extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ bar: props.initialValue \};
			      \}
			
			      handleClick() \{
			        this.setState(\{ bar: 'bar' \});
			      \}
			
			      render() \{
			        return <Inner name=\{this.state.bar\} onClick=\{this.handleClick.bind(this)\} />;
			      \}
			    \}
			    test(<Foo initialValue="foo" />, 'DIV', 'foo', () => \{
			      expect(renderedName).toBe('foo');
			      attachedListener();
			      setTimeout(() => \{
			        expect(renderedName).toBe('bar');
			        done();
			      \}, 10);
			    \});
			  \});
			
			  it('should render using forceUpdate even when there is no state', (done) => \{
			    class Foo extends Component \{
			      constructor(props) \{
			        super(props);
			        this.mutativeValue = props.initialValue;
			      \}
			
			      handleClick() \{
			        this.mutativeValue = 'bar';
			        this.forceUpdate();
			      \}
			
			      render() \{
			        return <Inner name=\{this.mutativeValue\} onClick=\{this.handleClick.bind(this)\} />;
			      \}
			    \}
			    test(<Foo initialValue="foo" />, 'DIV', 'foo', function () \{
			      attachedListener();
			      expect(renderedName).toBe('bar');
			      done();
			    \});
			  \});
			
			  describe('should render a component with a list of children that dynamically update via setState', () => \{
			    class Counter extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          count: 0
			        \};
			        this.incrementCount = this.incrementCount.bind(this);
			      \}
			
			      incrementCount() \{
			        this.setState(\{
			          count: this.state.count + 1
			        \});
			      \}
			
			      render() \{
			        return (
			          <div class="my-component">
			            <h1>
			              \{this.props.car\} \{this.state.count\}
			            </h1>
			            <button type="button" onClick=\{this.incrementCount\}>
			              Increment
			            </button>
			          </div>
			        );
			      \}
			    \}
			
			    class Wrapper extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{['Saab', 'Volvo', 'BMW'].map(function (c) \{
			              return <Counter car=\{c\} />;
			            \})\}
			          </div>
			        );
			      \}
			    \}
			
			    it('Initial render (creation)', () => \{
			      render(<Wrapper />, container);
			
			      expect(container.innerHTML).toBe(
			        '<div><div class="my-component"><h1>Saab 0</h1><button type="button">Increment</button></div><div class="my-component"><h1>Volvo 0</h1><button type="button">Increment</button></div><div class="my-component"><h1>BMW 0</h1><button type="button">Increment</button></div></div>'
			      );
			    \});
			
			    it('Second render (update) #1', (done) => \{
			      render(<Wrapper />, container);
			      const buttons = container.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe(
			          '<div><div class="my-component"><h1>Saab 1</h1><button type="button">Increment</button></div><div class="my-component"><h1>Volvo 1</h1><button type="button">Increment</button></div><div class="my-component"><h1>BMW 1</h1><button type="button">Increment</button></div></div>'
			        );
			        done();
			      \}, 25);
			    \});
			  \});
			
			  describe('should render a component with a conditional state item', () => \{
			    class SomeError extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          show: false
			        \};
			
			        this.toggle = this.toggle.bind(this);
			      \}
			
			      toggle() \{
			        this.setState(\{
			          show: !this.state.show
			        \});
			      \}
			
			      render() \{
			        return (
			          <div className="login-view bg-visma">
			            <button onClick=\{this.toggle\}>TOGGLE</button>
			            <br />
			            \{function () \{
			              if (this.state.show === true) \{
			                return <h1>This is cool!</h1>;
			              \} else \{
			                return <h1>Not so cool</h1>;
			              \}
			            \}.call(this)\}
			          </div>
			        );
			      \}
			    \}
			
			    it('Initial render (creation)', () => \{
			      render(<SomeError />, container);
			
			      expect(container.innerHTML).toBe('<div class="login-view bg-visma"><button>TOGGLE</button><br><h1>Not so cool</h1></div>');
			    \});
			
			    it('Second render (update with state change) #2', () => \{
			      render(<SomeError />, container);
			      const buttons = container.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      expect(container.innerHTML).toBe('<div class="login-view bg-visma"><button>TOGGLE</button><br><h1>This is cool!</h1></div>');
			    \});
			  \});
			
			  describe('should render a stateless component with a conditional state item', () => \{
			    const StatelessComponent = (props) => <p>\{props.name\}</p>;
			
			    class Testing extends Component \{
			      constructor(props) \{
			        super(props);
			        this.name = 'Kalle';
			
			        this.state = \{
			          show: false
			        \};
			
			        this.toggle = this.toggle.bind(this);
			      \}
			
			      toggle() \{
			        this.setState(\{
			          show: !this.state.show
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{function () \{
			              if (this.state.show === true) \{
			                return <StatelessComponent name=\{this.name\} />;
			              \} else \{
			                return <h1>Hello folks</h1>;
			              \}
			            \}.call(this)\}
			            <button onClick=\{this.toggle\}>toggle</button>
			          </div>
			        );
			      \}
			    \}
			
			    it('Initial render (creation)', () => \{
			      render(null, container);
			
			      render(<Testing />, container);
			
			      expect(container.innerHTML).toBe('<div><h1>Hello folks</h1><button>toggle</button></div>');
			    \});
			
			    it('Second render (update with state change) #3', (done) => \{
			      render(<Testing />, container);
			      const buttons = container.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><p>Kalle</p><button>toggle</button></div>');
			        done();
			      \}, 25);
			    \});
			  \});
			
			  describe('should render a repeating counter component with component children', () => \{
			    let id = 0;
			
			    class Value extends Component \{
			      constructor(props) \{
			        super(props);
			        this.id = ++id;
			      \}
			
			      render() \{
			        return <div>\{this.props.value\}</div>;
			      \}
			    \}
			
			    class Repeater extends Component \{
			      render() \{
			        const children = [];
			        for (let i = 0; i < 3; i++) \{
			          children.push(<Value key=\{i\} value=\{this.props.value\} />);
			        \}
			
			        return <div>\{children\}</div>;
			      \}
			    \}
			
			    it('should correctly render as values increase', () => \{
			      let value = 0;
			
			      render(<Repeater value=\{value\} />, container);
			      expect(container.innerHTML).toBe('<div><div>0</div><div>0</div><div>0</div></div>');
			
			      value++;
			      render(<Repeater value=\{value\} />, container);
			      expect(container.innerHTML).toBe('<div><div>1</div><div>1</div><div>1</div></div>');
			
			      value++;
			      render(<Repeater value=\{value\} />, container);
			      expect(container.innerHTML).toBe('<div><div>2</div><div>2</div><div>2</div></div>');
			    \});
			  \});
			
			  describe('should render a component with component children as the only child', () => \{
			    class Jaska extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div>
			            <h1>Okdokfwoe</h1>
			            <p>odkodwq</p>
			          </div>
			        );
			      \}
			    \}
			
			    class Container extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return <div>\{this.props.children\}</div>;
			      \}
			    \}
			
			    class TestingProps extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div>
			            <Container>
			              <Jaska />
			            </Container>
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', () => \{
			      render(<TestingProps />, container);
			      expect(container.innerHTML).toBe('<div><div><div><h1>Okdokfwoe</h1><p>odkodwq</p></div></div></div>');
			    \});
			  \});
			
			  describe('should render a component with with mapped text nodes', () => \{
			    class MyComponent98 extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          isok: false
			        \};
			      \}
			
			      componentDidMount() \{
			        this.setState(\{ isok: true \});
			      \}
			
			      render() \{
			        return <MyComponent99 isok=\{this.state.isok\} />;
			      \}
			    \}
			
			    class MyComponent99 extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div>
			            isok=
			            \{this.props.isok ? 'true' : 'false'\}
			            <div>
			              \{this.props.isok &&
			                ['a', 'b'].map((x) => \{
			                  return <span>\{x\}</span>;
			                \})\}
			            </div>
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', () => \{
			      render(<MyComponent98 />, container);
			
			      expect(container.innerHTML).toBe('<div>isok=false<div></div></div>');
			
			      rerender();
			
			      expect(container.innerHTML).toBe('<div>isok=true<div><span>a</span><span>b</span></div></div>');
			    \});
			  \});
			
			  describe('should render a component with conditional boolean text nodes', () => \{
			    class MyComponent98 extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          isok: false
			        \};
			      \}
			
			      componentDidMount() \{
			        this.setState(\{ isok: true \});
			      \}
			
			      render() \{
			        return <MyComponent99 isok=\{this.state.isok\} />;
			      \}
			    \}
			
			    class MyComponent99 extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        const z = function (v) \{
			          if (v) \{
			            return <span>a</span>;
			          \} else \{
			            return <span>b</span>;
			          \}
			        \};
			
			        return (
			          <div>
			            <div>\{z(this.props.isok)\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', (done) => \{
			      render(<MyComponent98 />, container);
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><div><span>a</span></div></div>');
			        done();
			      \}, 25);
			    \});
			  \});
			
			  const StatelessComponent2 = (props) => <div>\{props.name\}</div>;
			
			  it('should render stateless component', () => \{
			    render(<StatelessComponent2 name="A" />, container);
			    expect(container.textContent).toBe('A');
			  \});
			
			  it('should unmount stateless component', function () \{
			    render(<StatelessComponent2 name="A" />, container);
			    expect(container.textContent).toBe('A');
			
			    render(null, container);
			    expect(container.textContent).toBe('');
			  \});
			
			  it('should support module pattern components', function () \{
			    function Child(\{ test \}) \{
			      return <div>\{test\}</div>;
			    \}
			
			    render(<Child test="test" />, container);
			
			    expect(container.textContent).toBe('test');
			  \});
			
			  describe('should render a component with a conditional list that changes upon toggle', () => \{
			    class BuggyRender extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          empty: true
			        \};
			
			        this.toggle = this.toggle.bind(this);
			      \}
			
			      toggle() \{
			        this.setState(\{
			          empty: !this.state.empty
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <button onClick=\{this.toggle\}>Empty</button>
			            <ul>
			              \{(() => \{
			                if (this.state.empty === true) \{
			                  return <li>No cars!</li>;
			                \} else \{
			                  return ['BMW', 'Volvo', 'Saab'].map(function (car) \{
			                    return <li>\{car\}</li>;
			                  \});
			                \}
			              \})()\}
			            </ul>
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', () => \{
			      render(<BuggyRender />, container);
			      expect(container.innerHTML).toBe('<div><button>Empty</button><ul><li>No cars!</li></ul></div>');
			    \});
			
			    it('should handle update upon click', () => \{
			      render(<BuggyRender />, container);
			      const buttons = container.querySelectorAll('button');
			
			      buttons.forEach((button) => button.click());
			
			      expect(container.innerHTML).toBe('<div><button>Empty</button><ul><li>BMW</li><li>Volvo</li><li>Saab</li></ul></div>');
			    \});
			  \});
			
			  describe('should render a component with a list that instantly changes', () => \{
			    class ChangeChildrenCount extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          list: ['1', '2', '3', '4']
			        \};
			
			        this.handleClick = this.handleClick.bind(this);
			      \}
			
			      handleClick() \{
			        this.setState(\{
			          list: ['1']
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <button onClick=\{this.handleClick\}>1</button>
			            \{this.state.list.map(function (x, i) \{
			              return <div>\{i\}</div>;
			            \})\}
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', () => \{
			      render(<ChangeChildrenCount />, container);
			      expect(container.innerHTML).toBe('<div><button>1</button><div>0</div><div>1</div><div>2</div><div>3</div></div>');
			    \});
			
			    it('should handle update upon click', (done) => \{
			      render(<ChangeChildrenCount />, container);
			      const buttons = container.querySelectorAll('button');
			
			      buttons.forEach((button) => button.click());
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><button>1</button><div>0</div></div>');
			        done();
			      \}, 10);
			    \});
			  \});
			
			  describe('should render a stateless component with context', () => \{
			    const StatelessComponent3 = (\{ value \}, \{ fortyTwo \}) => (
			      <p>
			        \{value\}-\{fortyTwo || 'ERROR'\}
			      </p>
			    );
			
			    class First extends Component \{
			      constructor(props, context) \{
			        super(props, context);
			
			        this.state = \{
			          counter: 0
			        \};
			
			        this._onClick = this._onClick.bind(this);
			      \}
			
			      _onClick() \{
			        this.setState(\{
			          counter: 1
			        \});
			      \}
			
			      getChildContext() \{
			        return \{
			          fortyTwo: 42
			        \};
			      \}
			
			      render() \{
			        return (
			          <div>
			            <button onClick=\{this._onClick\}>Increase! \{this.state.counter\}</button>
			            <StatelessComponent3 value=\{this.state.counter\} />
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', () => \{
			      render(<First />, container);
			      expect(container.innerHTML).toBe('<div><button>Increase! 0</button><p>0-42</p></div>');
			    \});
			
			    it('should handle update upon click', (done) => \{
			      render(<First />, container);
			      const buttons = container.querySelectorAll('button');
			
			      buttons.forEach((button) => button.click());
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><button>Increase! 1</button><p>1-42</p></div>');
			        done();
			      \}, 10);
			    \});
			  \});
			
			  describe('should render a conditional stateless component', () => \{
			    const StatelessComponent4 = (\{ value \}) => <p>\{value\}</p>;
			
			    class First extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          counter: 0
			        \};
			
			        this.condition = true;
			        this._onClick = this._onClick.bind(this);
			      \}
			
			      _onClick() \{
			        this.setState(\{
			          counter: 1
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <button onClick=\{this._onClick\}>Increase! \{this.state.counter\}</button>
			            \{this.condition ? <StatelessComponent4 value=\{this.state.counter\} /> : null\}
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', () => \{
			      render(<First />, container);
			      expect(container.innerHTML).toBe('<div><button>Increase! 0</button><p>0</p></div>');
			    \});
			
			    it('should handle update upon click', (done) => \{
			      render(<First />, container);
			      const buttons = container.querySelectorAll('button');
			
			      buttons.forEach((button) => button.click());
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><button>Increase! 1</button><p>1</p></div>');
			        done();
			      \}, 10);
			    \});
			  \});
			
			  describe('should render stateless component correctly when changing states', () => \{
			    let firstDiv, secondDiv;
			
			    beforeEach(function () \{
			      firstDiv = document.createElement('div');
			      secondDiv = document.createElement('div');
			
			      container.appendChild(firstDiv);
			      container.appendChild(secondDiv);
			    \});
			
			    afterEach(function () \{
			      render(null, firstDiv);
			      render(null, secondDiv);
			    \});
			
			    const StatelessComponent = (\{ value \}) => <p>\{value\}</p>;
			
			    class First extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          counter: 0
			        \};
			
			        this.condition = true;
			        this._onClick = this._onClick.bind(this);
			      \}
			
			      _onClick() \{
			        this.setState(\{
			          counter: 1
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <button onClick=\{this._onClick\}>
			              \{this.props.name\} \{this.state.counter\}
			            </button>
			            \{this.condition ? <StatelessComponent value=\{this.state.counter\} /> : null\}
			          </div>
			        );
			      \}
			    \}
			
			    it('should correctly render', () => \{
			      render(<First name="guy1" />, firstDiv);
			      render(<First name="guy2" />, secondDiv);
			
			      expect(container.innerHTML).toBe('<div><div><button>guy1 0</button><p>0</p></div></div><div><div><button>guy2 0</button><p>0</p></div></div>');
			    \});
			
			    it('should handle update when changing first component', (done) => \{
			      render(<First name="guy1" />, firstDiv);
			      render(<First name="guy2" />, secondDiv);
			
			      const buttons = firstDiv.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><div><button>guy1 1</button><p>1</p></div></div><div><div><button>guy2 0</button><p>0</p></div></div>');
			        done();
			      \}, 10);
			    \});
			
			    it('should handle update when changing second component', (done) => \{
			      render(<First name="guy1" />, firstDiv);
			      render(<First name="guy2" />, secondDiv);
			
			      const buttons = secondDiv.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><div><button>guy1 0</button><p>0</p></div></div><div><div><button>guy2 1</button><p>1</p></div></div>');
			        done();
			      \}, 10);
			    \});
			  \});
			
			  describe('updating child should not cause rendering parent to fail', () => \{
			    it('should render parent correctly after child changes', (done) => \{
			      let updateParent, updateChild;
			
			      class Parent extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{ x: false \};
			
			          updateParent = () => \{
			            this.setState(\{ x: true \});
			          \};
			        \}
			
			        render() \{
			          return (
			            <div>
			              <p>parent</p>
			              \{!this.state.x ? <ChildA /> : <ChildB />\}
			            </div>
			          );
			        \}
			      \}
			
			      class ChildB extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        render() \{
			          return <div>Y</div>;
			        \}
			      \}
			
			      class ChildA extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{ z: false \};
			
			          updateChild = () => \{
			            this.setState(\{ z: true \});
			          \};
			        \}
			
			        render() \{
			          if (!this.state.z) \{
			            return <div>A</div>;
			          \}
			          return <SubChild />;
			        \}
			      \}
			
			      class SubChild extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        render() \{
			          return <div>B</div>;
			        \}
			      \}
			
			      render(<Parent />, container);
			      expect(container.innerHTML).toBe('<div><p>parent</p><div>A</div></div>');
			      updateChild();
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><p>parent</p><div>B</div></div>');
			        updateParent();
			        setTimeout(() => \{
			          expect(container.innerHTML).toBe('<div><p>parent</p><div>Y</div></div>');
			          done();
			        \}, 10);
			      \}, 10);
			    \});
			  \});
			
			  describe('recursive component', () => \{
			    it('Should be possible to pass props recursively', () => \{
			      class List extends Component \{
			        render() \{
			          const children = this.props.data.map((entity) => \{
			            const \{ key, data \} = entity;
			            const child = Array.isArray(data) ? <List data=\{data\} \{...entity\} /> : <Text data=\{data\} \{...entity\} />;
			            return <li key=\{key\}>\{child\}</li>;
			          \});
			
			          return <ul>\{children\}</ul>;
			        \}
			      \}
			
			      class Text extends Component \{
			        render() \{
			          return <span>\{this.props.data\}</span>;
			        \}
			      \}
			
			      const data = [
			        \{ key: '0', data: 'Foo' \},
			        \{
			          key: '1',
			          data: [
			            \{ key: '1/1', data: 'a' \},
			            \{ key: '1/2', data: 'b' \}
			          ]
			        \}
			      ];
			
			      render(<List data=\{data\} />, container);
			      expect(container.innerHTML).toBe('<ul><li><span>Foo</span></li><li><ul><li><span>a</span></li><li><span>b</span></li></ul></li></ul>');
			    \});
			
			    it('Should be possible to pass props recursively AT BEGINNING (JSX plugin change required)', () => \{
			      class List extends Component \{
			        render() \{
			          const children = this.props.data.map((entity) => \{
			            const \{ key, data \} = entity;
			            const child = Array.isArray(data) ? <List \{...entity\} data=\{data\} /> : <Text \{...entity\} data=\{data\} />;
			            return <li key=\{key\}>\{child\}</li>;
			          \});
			
			          return <ul>\{children\}</ul>;
			        \}
			      \}
			
			      class Text extends Component \{
			        render() \{
			          return <span>\{this.props.data\}</span>;
			        \}
			      \}
			
			      const data = [
			        \{ key: '0', data: 'Foo' \},
			        \{
			          key: '1',
			          data: [
			            \{ key: '1/1', data: 'a' \},
			            \{ key: '1/2', data: 'b' \}
			          ]
			        \}
			      ];
			
			      render(<List data=\{data\} />, container);
			      expect(container.innerHTML).toBe('<ul><li><span>Foo</span></li><li><ul><li><span>a</span></li><li><span>b</span></li></ul></li></ul>');
			    \});
			  \});
			
			  it('Should render (github #117)', (done) => \{
			    class MakeX extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ x: false \};
			      \}
			
			      componentWillMount() \{
			        setTimeout(() => \{
			          this.setState(\{ x: true \});
			        \}, 10);
			      \}
			
			      render() \{
			        return <div>\{!this.state.x ? <MakeA /> : <MakeY />\}</div>;
			      \}
			    \}
			
			    class MakeY extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return <div>Y</div>;
			      \}
			    \}
			
			    class MakeA extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ z: false \};
			      \}
			
			      componentWillMount() \{
			        setTimeout(() => \{
			          this.setState(\{ z: true \});
			        \}, 20);
			      \}
			
			      render() \{
			        if (!this.state.z) \{
			          return <div>A</div>;
			        \}
			
			        return <MakeB />;
			      \}
			    \}
			
			    class MakeB extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return <div>B</div>;
			      \}
			    \}
			
			    render(<MakeX />, container);
			    setTimeout(function () \{
			      done();
			    \}, 50);
			  \});
			
			  it('Events should propagate between components (github #135)', (done) => \{
			    class Label extends Component \{
			      render() \{
			        const style = \{
			          'background-color': 'red',
			          padding: '0 20px',
			          fontSize: '40px'
			        \};
			        return <span style=\{style\}>\{this.props.text\}</span>;
			      \}
			    \}
			
			    let btnFlag = false;
			    let containerFlag = false;
			
			    class Button extends Component \{
			      onClick(event) \{
			        btnFlag = !btnFlag;
			      \}
			
			      render() \{
			        const \{ text \} = this.props;
			        return (
			          <button onClick=\{this.onClick\}>
			            <Label text=\{text\} />
			          </button>
			        );
			      \}
			    \}
			
			    class Container extends Component \{
			      onClick(event) \{
			        containerFlag = !containerFlag;
			      \}
			
			      render() \{
			        return (
			          <div onClick=\{this.onClick\}>
			            <Button text="Click me" />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Container />, container);
			
			    expect(btnFlag).toBe(false);
			    expect(containerFlag).toBe(false);
			
			    const spans = container.querySelectorAll('span');
			    spans.forEach((span) => span.click());
			
			    expect(btnFlag).toBe(true);
			    expect(containerFlag).toBe(true);
			    done();
			  \});
			
			  it('Should be possible to stop propagation', (done) => \{
			    class Label extends Component \{
			      render() \{
			        const style = \{
			          'background-color': 'red',
			          padding: '0 20px',
			          fontSize: '40px'
			        \};
			        return <span style=\{style\}>\{this.props.text\}</span>;
			      \}
			    \}
			
			    let btnFlag = false;
			    let containerFlag = false;
			
			    class Button extends Component \{
			      onClick(event) \{
			        event.stopPropagation();
			        btnFlag = !btnFlag;
			      \}
			
			      render() \{
			        const \{ text \} = this.props;
			        return (
			          <button onClick=\{this.onClick\}>
			            <Label text=\{text\} />
			          </button>
			        );
			      \}
			    \}
			
			    class Container extends Component \{
			      onClick(event) \{
			        containerFlag = !containerFlag;
			      \}
			
			      render() \{
			        return (
			          <div onClick=\{this.onClick\}>
			            <Button text="Click me" />
			          </div>
			        );
			      \}
			    \}
			
			    render(<Container />, container);
			
			    expect(btnFlag).toBe(false);
			    expect(containerFlag).toBe(false);
			
			    const spans = container.querySelectorAll('span');
			    spans.forEach((span) => span.click());
			
			    expect(btnFlag).toBe(true);
			    expect(containerFlag).toBe(false);
			    done();
			  \});
			
			  describe('Inheritance should work', () => \{
			    it('Should render div', () => \{
			      class A extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			      \}
			
			      class B extends A \{
			        constructor(props) \{
			          super(props);
			        \}
			      \}
			
			      class C extends B \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        render() \{
			          return <div />;
			        \}
			      \}
			
			      render(<C />, container);
			      expect(container.innerHTML).toBe('<div></div>');
			    \});
			  \});
			
			  describe('A component rendering a component should work as expected', () => \{
			    let forceUpdate;
			    let forceUpdate2;
			    let foo;
			    let bar;
			
			    class Bar extends Component \{
			      constructor() \{
			        super();
			        bar = this;
			        forceUpdate = this.forceUpdate.bind(this);
			      \}
			
			      render() \{
			        return <div>Hello world</div>;
			      \}
			    \}
			    class Foo extends Component \{
			      constructor() \{
			        super();
			        foo = this;
			        forceUpdate2 = this.forceUpdate.bind(this);
			      \}
			
			      render() \{
			        return <Bar />;
			      \}
			    \}
			
			    it('should render the div correctly', () => \{
			      render(<Foo />, container);
			      expect(container.firstChild.innerHTML).toBe('Hello world');
			    \});
			
			    it('should update correctly', () => \{
			      render(<Foo />, container);
			      render(<Foo />, container);
			      expect(container.firstChild.innerHTML).toBe('Hello world');
			    \});
			
			    it('should update correctly via forceUpdate', () => \{
			      render(<Foo />, container);
			      forceUpdate();
			      forceUpdate2();
			      render(<Foo />, container);
			      forceUpdate2();
			      forceUpdate();
			      expect(container.firstChild.innerHTML).toBe('Hello world');
			    \});
			  \});
			
			  it('Should trigger ref lifecycle after patch', (done) => \{
			    let updater;
			    const obj = \{
			      fn() \{\}
			    \};
			
			    spyOn(obj, 'fn');
			
			    class Bar extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          bool: true
			        \};
			
			        this.changeDOM = this.changeDOM.bind(this);
			        updater = this.changeDOM;
			      \}
			
			      changeDOM() \{
			        this.setState(\{
			          bool: !this.state.bool
			        \});
			      \}
			
			      render() \{
			        if (this.state.bool === true) \{
			          return <div>Hello world</div>;
			        \} else \{
			          return (
			            <div>
			              <div ref=\{obj.fn\}>Hello world2</div>
			            </div>
			          );
			        \}
			      \}
			    \}
			
			    render(<Bar />, container);
			    expect(container.innerHTML).toBe('<div>Hello world</div>');
			    expect(obj.fn).not.toHaveBeenCalled();
			
			    updater();
			    setTimeout(() => \{
			      expect(container.innerHTML).toBe('<div><div>Hello world2</div></div>');
			      expect(obj.fn).toHaveBeenCalledTimes(1);
			      done();
			    \}, 10);
			  \});
			
			  describe('Should be able to swap between invalid node and valid node', () => \{
			    it('Should be able to swap between invalid node and valid node', () => \{
			      let updater;
			
			      class Bar extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            bool: true
			          \};
			
			          this.changeDOM = this.changeDOM.bind(this);
			          updater = this.changeDOM;
			        \}
			
			        changeDOM() \{
			          this.setState(\{
			            bool: !this.state.bool
			          \});
			        \}
			
			        render() \{
			          if (this.state.bool === true) \{
			            return null;
			          \} else \{
			            return <div>Rendered!</div>;
			          \}
			        \}
			      \}
			
			      render(<Bar />, container);
			      expect(container.innerHTML).toBe('');
			
			      updater();
			      expect(container.innerHTML).toBe('<div>Rendered!</div>');
			
			      updater();
			      expect(container.innerHTML).toBe('');
			
			      updater();
			      expect(container.innerHTML).toBe('<div>Rendered!</div>');
			
			      updater();
			      expect(container.innerHTML).toBe('');
			
			      updater();
			      expect(container.innerHTML).toBe('<div>Rendered!</div>');
			    \});
			  \});
			
			  it('Should be able to swap between text node and html node', () => \{
			    let updater;
			
			    class Bar extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          bool: true
			        \};
			
			        this.changeDOM = this.changeDOM.bind(this);
			        updater = this.changeDOM;
			      \}
			
			      changeDOM() \{
			        this.setState(\{
			          bool: !this.state.bool
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{this.state.bool ? <span>span</span> : 'text'\}
			            <div>div</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Bar />, container);
			    expect(container.innerHTML).toBe('<div><span>span</span><div>div</div></div>');
			
			    updater();
			    expect(container.innerHTML).toBe('<div>text<div>div</div></div>');
			
			    updater();
			    expect(container.innerHTML).toBe('<div><span>span</span><div>div</div></div>');
			
			    updater();
			    expect(container.innerHTML).toBe('<div>text<div>div</div></div>');
			  \});
			
			  it('Should be able to swap between text node and html node #2', (done) => \{
			    let updater;
			
			    class Bar extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          bool: false
			        \};
			
			        this.changeDOM = this.changeDOM.bind(this);
			        updater = this.changeDOM;
			      \}
			
			      changeDOM() \{
			        this.setState(\{
			          bool: !this.state.bool
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{this.state.bool ? <span>span</span> : ''\}
			            <div>div</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Bar />, container);
			    expect(container.innerHTML).toBe('<div><div>div</div></div>');
			
			    updater();
			    setTimeout(() => \{
			      expect(container.innerHTML).toBe('<div><span>span</span><div>div</div></div>');
			      updater();
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div><div>div</div></div>');
			        updater();
			        setTimeout(() => \{
			          expect(container.innerHTML).toBe('<div><span>span</span><div>div</div></div>');
			          done();
			        \}, 10);
			      \}, 10);
			    \}, 10);
			  \});
			
			  describe('handling of sCU', () => \{
			    let instance;
			    let shouldUpdate = false;
			
			    class Test extends Component \{
			      shouldComponentUpdate() \{
			        return shouldUpdate;
			      \}
			
			      render() \{
			        instance = this;
			        return <div contentEditable=\{true\}>\{this.props.foo\}</div>;
			      \}
			    \}
			
			    class Test2 extends Component \{
			      shouldComponentUpdate() \{
			        return shouldUpdate;
			      \}
			
			      render() \{
			        instance = this;
			        return createElement('div', \{ contenteditable: true \}, this.props.foo);
			      \}
			    \}
			
			    it('should correctly render once but never again', () => \{
			      shouldUpdate = false;
			      render(<Test foo="bar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			      render(<Test foo="yar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			      instance.setState(\{ foo: 'woo' \});
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should not fail if text node has external change Github#1207 - createElement', () => \{
			      shouldUpdate = false;
			      render(<Test2 foo="bar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			      render(<Test2 foo="yar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			
			      container.firstChild.removeChild(container.firstChild.firstChild); // When div is contentEditable user can remove whole text content
			      expect(container.innerHTML).toBe('<div contenteditable="true"></div>');
			
			      shouldUpdate = true;
			      render(<Test2 foo="foo" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">foo</div>');
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should not fail if text node has external change Github#1207', () => \{
			      shouldUpdate = false;
			      render(<Test foo="bar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			      render(<Test foo="yar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			
			      container.firstChild.removeChild(container.firstChild.firstChild); // When div is contentEditable user can remove whole text content
			      expect(container.innerHTML).toBe('<div contenteditable="true"></div>');
			
			      shouldUpdate = true;
			      render(<Test foo="foo" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">foo</div>');
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should not fail if text node has external change Github#1207 (variation - 2)', () => \{
			      shouldUpdate = false;
			      render(<Test foo="bar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			      render(<Test foo="yar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			
			      container.firstChild.removeChild(container.firstChild.firstChild); // When div is contentEditable user can remove whole text content
			      expect(container.innerHTML).toBe('<div contenteditable="true"></div>');
			
			      shouldUpdate = true;
			      render(<Test foo="" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true"></div>');
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			    \});
			  \});
			  describe('handling of different primatives', () => \{
			    it('Should correctly handle boolean values (github#255)', () => \{
			      const Todo = (\{ todo \}) => (
			        <tr>
			          <td>\{todo.id\}</td>
			          <td>\{todo.desc\}</td>
			          <td>\{todo.done\}</td>
			        </tr>
			      );
			
			      render(<Todo todo=\{\{ done: false \}\} />, container);
			      expect(container.innerHTML).toBe('<tr><td></td><td></td><td></td></tr>');
			      render(<Todo todo=\{\{ done: true \}\} />, container);
			      expect(container.innerHTML).toBe('<tr><td></td><td></td><td></td></tr>');
			    \});
			  \});
			
			  describe('handling JSX spread attributes', () => \{
			    it('should properly handle multiple attributes using spread', () => \{
			      class Input extends Component \{
			        constructor() \{
			          super();
			          this.handleBlur = this.handleBlur.bind(this);
			        \}
			
			        handleBlur(event) \{\}
			
			        render() \{
			          const props = \{
			            onBlur: this.handleBlur,
			            className: 'foo',
			            id: 'test'
			          \};
			
			          return <input \{...props\} />;
			        \}
			      \}
			
			      render(<Input />, container);
			      expect(container.innerHTML).toBe('<input class="foo" id="test">');
			    \});
			  \});
			
			  describe('Swapping Component to DOM node', () => \{
			    it('Should be able to swap statefull component to DOM list when doing setState', () => \{
			      let change1 = null;
			      let unMountCalled = false;
			
			      class FooBar extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        componentWillUnmount() \{
			          unMountCalled = true;
			        \}
			
			        render() \{
			          return (
			            <div>
			              <span>foo1</span>
			              <span>foo2</span>
			              <span>foo3</span>
			              <span>foo4</span>
			            </div>
			          );
			        \}
			      \}
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            toggle1: false
			          \};
			
			          change1 = this.toggle1.bind(this);
			        \}
			
			        toggle1() \{
			          this.setState(\{
			            toggle1: !this.state.toggle1
			          \});
			        \}
			
			        renderContent() \{
			          if (this.state.toggle1) \{
			            return <FooBar />;
			          \} else \{
			            return (
			              <div className="login-container">
			                <h1>foo</h1>
			              </div>
			            );
			          \}
			        \}
			
			        render() \{
			          return <div>\{this.renderContent()\}</div>;
			        \}
			      \}
			
			      render(<Tester />, container);
			      expect(container.innerHTML).toBe('<div><div class="login-container"><h1>foo</h1></div></div>');
			      expect(unMountCalled).toEqual(false);
			      change1();
			      expect(unMountCalled).toEqual(false);
			      expect(container.innerHTML).toBe('<div><div><span>foo1</span><span>foo2</span><span>foo3</span><span>foo4</span></div></div>');
			      change1();
			      expect(unMountCalled).toEqual(true);
			      expect(container.innerHTML).toBe('<div><div class="login-container"><h1>foo</h1></div></div>');
			    \});
			
			    it('Should be able to swap stateless component to DOM list when doing setState', () => \{
			      let change1 = null;
			
			      const FooBar = () => (
			        <div>
			          <span>foo1</span>
			          <span>foo2</span>
			          <span>foo3</span>
			          <span>foo4</span>
			        </div>
			      );
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            toggle1: false
			          \};
			
			          change1 = this.toggle1.bind(this);
			        \}
			
			        toggle1() \{
			          this.setState(\{
			            toggle1: !this.state.toggle1
			          \});
			        \}
			
			        renderContent() \{
			          if (this.state.toggle1) \{
			            return <FooBar />;
			          \} else \{
			            return (
			              <div className="login-container">
			                <h1>foo</h1>
			              </div>
			            );
			          \}
			        \}
			
			        render() \{
			          return <div>\{this.renderContent()\}</div>;
			        \}
			      \}
			
			      render(<Tester />, container);
			      expect(container.innerHTML).toBe('<div><div class="login-container"><h1>foo</h1></div></div>');
			      change1();
			      expect(container.innerHTML).toBe('<div><div><span>foo1</span><span>foo2</span><span>foo3</span><span>foo4</span></div></div>');
			      change1();
			      expect(container.innerHTML).toBe('<div><div class="login-container"><h1>foo</h1></div></div>');
			    \});
			  \});
			
			  describe('handling componentWillReceiveProps lifecycle event', () => \{
			    it('should correctly handle setState within the lifecycle function', () => \{
			      let renderCount = 0;
			      class Comp1 extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{
			            foo: 0
			          \};
			        \}
			
			        componentWillReceiveProps() \{
			          this.setState(\{ foo: 1 \});
			        \}
			
			        render() \{
			          renderCount++;
			          return <div>\{this.state.foo\}</div>;
			        \}
			      \}
			
			      render(<Comp1 />, container);
			      expect(container.innerHTML).toBe('<div>0</div>');
			      render(<Comp1 />, container);
			      expect(container.innerHTML).toBe('<div>1</div>');
			      expect(renderCount).toBe(2);
			    \});
			  \});
			
			  it('mixing JSX components with non-JSX components', () => \{
			    function Comp() \{
			      return createElement('div', \{\});
			    \}
			
			    function Comp2() \{
			      return createElement('span', \{\});
			    \}
			
			    function Comp3() \{
			      return <div />;
			    \}
			
			    render(
			      <div>
			        <Comp />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><div></div></div>');
			    render(
			      <div>
			        <Comp2 />
			      </div>,
			      container
			    );
			    expect(container.innerHTML).toBe('<div><span></span></div>');
			    render(
			      <span>
			        <Comp />
			      </span>,
			      container
			    );
			    expect(container.innerHTML).toBe('<span><div></div></span>');
			    render(createElement('span', null, <Comp3 />), container);
			    expect(container.innerHTML).toBe('<span><div></div></span>');
			  \});
			
			  describe('components should be able to use defaultProps', () => \{
			    class Comp1 extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      static defaultProps = \{
			        a: 'A',
			        b: 'B'
			      \};
			
			      render() \{
			        return (
			          <div className=\{this.props.a\} id=\{this.props.b\}>
			            Hello \{this.props.c\}!
			          </div>
			        );
			      \}
			    \}
			
			    class Comp2 extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      static defaultProps = \{
			        a: 'aye',
			        b: 'bee'
			      \};
			
			      render() \{
			        return (
			          <div className=\{this.props.a\} id=\{this.props.b\}>
			            Hello \{this.props.c\}!
			          </div>
			        );
			      \}
			    \}
			
			    it('should mount component with defaultProps', () => \{
			      render(<Comp1 c="C" />, container);
			      expect(container.innerHTML).toBe('<div class="A" id="B">Hello C!</div>');
			    \});
			
			    it('should mount child component with its defaultProps', () => \{
			      const Parent = (props) => <div>\{props.children.props.a\}</div>;
			      render(
			        <Parent>
			          <Comp1 c="C" />
			        </Parent>,
			        container
			      );
			      expect(container.innerHTML).toBe('<div>A</div>');
			    \});
			
			    it('should patch component with defaultProps', () => \{
			      render(<Comp1 c="C" />, container);
			      render(<Comp1 c="C2" />, container);
			      expect(container.innerHTML).toBe('<div class="A" id="B">Hello C2!</div>');
			    \});
			    it('should patch component with defaultProps #2', () => \{
			      render(<Comp1 c="C" />, container);
			      render(<Comp2 c="C1" />, container);
			      expect(container.innerHTML).toBe('<div class="aye" id="bee">Hello C1!</div>');
			      render(<Comp1 c="C2" />, container);
			      expect(container.innerHTML).toBe('<div class="A" id="B">Hello C2!</div>');
			    \});
			
			    it('should as per React: Have childrens defaultProps set before children is mounted', () => \{
			      let childrenPropertABeforeMount = 'A';
			      class Parent extends Component \{
			        render() \{
			          expect(this.props.children.props.a).toEqual(childrenPropertABeforeMount);
			
			          return <div>\{this.props.children\}</div>;
			        \}
			      \}
			
			      render(
			        <Parent>
			          <Comp1 />
			        </Parent>,
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div><div class="A" id="B">Hello !</div></div>');
			
			      childrenPropertABeforeMount = 'ABCD';
			
			      render(
			        <Parent>
			          <Comp1 a="ABCD" />
			        </Parent>,
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div><div class="ABCD" id="B">Hello !</div></div>');
			    \});
			  \});
			
			  describe('when calling setState with a function', () => \{
			    let reference;
			
			    class Comp1 extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          foo: 'yar'
			        \};
			        reference = this.update.bind(this);
			      \}
			
			      update() \{
			        this.setState(() => (\{
			          foo: 'bar'
			        \}));
			      \}
			
			      render() \{
			        return <div>\{this.state.foo\}</div>;
			      \}
			    \}
			
			    it('the state should update properly', (done) => \{
			      render(<Comp1 />, container);
			      expect(container.innerHTML).toBe('<div>yar</div>');
			      reference();
			      setTimeout(() => \{
			        expect(container.innerHTML).toBe('<div>bar</div>');
			        done();
			      \}, 10);
			    \});
			  \});
			
			  describe('node change in updateComponent', () => \{
			    it('Should not crash when invalid node returned - statefull', () => \{
			      class Comp1 extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        render() \{
			          if (this.props.foo) \{
			            return null;
			          \}
			
			          return <div>rendered</div>;
			        \}
			      \}
			
			      render(<Comp1 />, container);
			      expect(container.innerHTML).toEqual('<div>rendered</div>');
			      render(<Comp1 foo=\{true\} />, container);
			      expect(container.innerHTML).toEqual('');
			    \});
			
			    it('Should not crash when invalid node returned - stateless', () => \{
			      const Comp1 = (\{ foo \}) => \{
			        if (foo) \{
			          return null;
			        \}
			
			        return <div>rendered</div>;
			      \};
			
			      render(<Comp1 />, container);
			      expect(container.innerHTML).toEqual('<div>rendered</div>');
			      render(<Comp1 foo=\{true\} />, container);
			      expect(container.innerHTML).toEqual('');
			    \});
			  \});
			
			  describe('Root handling issues #1', () => \{
			    let div;
			
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ n: false \};
			
			        this.onClick = () => \{
			          this.setState(\{ n: !this.state.n \});
			        \};
			      \}
			
			      render() \{
			        if (this.state.n) \{
			          // eslint-disable-next-line
			          return (
			            <div ref=\{(dom) => (div = dom)\} onClick=\{this.onClick\}>
			              DIV
			            </div>
			          );
			        \}
			        return <span onClick=\{this.onClick\}>SPAN</span>;
			      \}
			    \}
			
			    class B extends Component \{
			      shouldComponentUpdate() \{
			        return false;
			      \}
			
			      render() \{
			        return <A />;
			      \}
			    \}
			
			    class Test extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          reverse: false
			        \};
			      \}
			
			      render() \{
			        const children = [<B key="b" />, <div key="a">ROW</div>];
			        if (this.state.reverse) \{
			          children.reverse();
			        \}
			
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                this.setState(\{ reverse: !this.state.reverse \});
			              \}\}
			            >
			              Swap Rows
			            </button>
			            <div>\{children\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    // this test is to replicate https://jsfiddle.net/localvoid/r070sgrq/2/
			    it('should correct swap rows', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><span>SPAN</span><div>ROW</div></div></div>');
			      // click on "SPAN"
			      container.querySelector('span').click();
			      // "SPAN" should now be "DIV"
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>DIV</div><div>ROW</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>ROW</div><div>DIV</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>DIV</div><div>ROW</div></div></div>');
			      // click on "DIV"
			      div.click();
			      // "DIV" should now be "SPAN"
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><span>SPAN</span><div>ROW</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>ROW</div><span>SPAN</span></div></div>');
			    \});
			  \});
			
			  describe('Root handling issues #2', () => \{
			    let div;
			
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ n: false \};
			
			        this.onClick = () => \{
			          this.setState(\{ n: !this.state.n \});
			        \};
			      \}
			
			      render() \{
			        if (this.state.n) \{
			          // eslint-disable-next-line
			          return (
			            <div ref=\{(dom) => (div = dom)\} onClick=\{this.onClick\}>
			              DIV
			            </div>
			          );
			        \}
			        return <span onClick=\{this.onClick\}>SPAN</span>;
			      \}
			    \}
			
			    function F() \{
			      return <A />;
			    \}
			
			    class B extends Component \{
			      shouldComponentUpdate() \{
			        return false;
			      \}
			
			      render() \{
			        return <F />;
			      \}
			    \}
			
			    class Test extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          reverse: false
			        \};
			      \}
			
			      render() \{
			        const children = [<B key="b" />, <div key="a">ROW</div>];
			        if (this.state.reverse) \{
			          children.reverse();
			        \}
			
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                this.setState(\{ reverse: !this.state.reverse \});
			              \}\}
			            >
			              Swap Rows
			            </button>
			            <div>\{children\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    // this test is to replicate https://jsfiddle.net/localvoid/r070sgrq/2/
			    it('should correct swap rows', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><span>SPAN</span><div>ROW</div></div></div>');
			      // click on "SPAN"
			      container.querySelector('span').click();
			      // "SPAN" should now be "DIV"
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>DIV</div><div>ROW</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>ROW</div><div>DIV</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>DIV</div><div>ROW</div></div></div>');
			      // click on "DIV"
			      div.click();
			      // "DIV" should now be "SPAN"
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><span>SPAN</span><div>ROW</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>ROW</div><span>SPAN</span></div></div>');
			    \});
			  \});
			
			  describe('Root handling issues #3', () => \{
			    let div;
			
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ n: false \};
			
			        this.onClick = () => \{
			          this.setState(\{ n: !this.state.n \});
			        \};
			      \}
			
			      render() \{
			        if (this.state.n) \{
			          // eslint-disable-next-line
			          return (
			            <div ref=\{(dom) => (div = dom)\} onClick=\{this.onClick\}>
			              DIV
			            </div>
			          );
			        \}
			        return <span onClick=\{this.onClick\}>SPAN</span>;
			      \}
			    \}
			
			    function F() \{
			      return <A />;
			    \}
			
			    function B() \{
			      return <F onComponentShouldUpdate=\{() => false\} />;
			    \}
			
			    class Test extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          reverse: false
			        \};
			      \}
			
			      render() \{
			        const children = [<B key="b" onComponentShouldUpdate=\{() => false\} />, <div key="a">ROW</div>];
			        if (this.state.reverse) \{
			          children.reverse();
			        \}
			
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                this.setState(\{ reverse: !this.state.reverse \});
			              \}\}
			            >
			              Swap Rows
			            </button>
			            <div>\{children\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    // this test is to replicate https://jsfiddle.net/localvoid/r070sgrq/2/
			    it('should correct swap rows', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><span>SPAN</span><div>ROW</div></div></div>');
			      // click on "SPAN"
			      container.querySelector('span').click();
			      // "SPAN" should now be "DIV"
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>DIV</div><div>ROW</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>ROW</div><div>DIV</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>DIV</div><div>ROW</div></div></div>');
			      // click on "DIV"
			      div.click();
			
			      // "DIV" should now be "SPAN"
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><span>SPAN</span><div>ROW</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>ROW</div><span>SPAN</span></div></div>');
			
			      render(null, container);
			    \});
			  \});
			
			  describe('Root handling issues #4', () => \{
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ n: false \};
			
			        this.onClick = () => \{
			          this.setState(\{ n: !this.state.n \});
			        \};
			      \}
			
			      render() \{
			        if (this.state.n) \{
			          return <div onClick=\{this.onClick\}>DIV</div>;
			        \}
			        return <span onClick=\{this.onClick\}>SPAN</span>;
			      \}
			    \}
			
			    class B extends Component \{
			      shouldComponentUpdate() \{
			        return false;
			      \}
			
			      render() \{
			        return this.props.children;
			      \}
			    \}
			
			    class Test extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          reverse: false
			        \};
			      \}
			
			      render() \{
			        const children = [
			          <B key="b">
			            <A />
			          </B>,
			          <div key="a">A</div>
			        ];
			        if (this.state.reverse) \{
			          children.reverse();
			        \}
			
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                this.setState(\{ reverse: !this.state.reverse \});
			              \}\}
			            >
			              Swap Rows
			            </button>
			            <div>\{children\}</div>
			            <div>\{children\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    it('should correct swap rows', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual(
			        '<div><button>Swap Rows</button><div><span>SPAN</span><div>A</div></div><div><span>SPAN</span><div>A</div></div></div>'
			      );
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual(
			        '<div><button>Swap Rows</button><div><div>A</div><span>SPAN</span></div><div><div>A</div><span>SPAN</span></div></div>'
			      );
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual(
			        '<div><button>Swap Rows</button><div><span>SPAN</span><div>A</div></div><div><span>SPAN</span><div>A</div></div></div>'
			      );
			    \});
			  \});
			
			  describe('Root handling issues #5', () => \{
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{ n: false \};
			
			        this.onClick = () => \{
			          this.setState(\{ n: !this.state.n \});
			        \};
			      \}
			
			      render() \{
			        if (this.state.n) \{
			          return <div onClick=\{this.onClick\}>DIV</div>;
			        \}
			        return <span onClick=\{this.onClick\}>SPAN</span>;
			      \}
			    \}
			
			    const hoisted = <A />;
			
			    class B extends Component \{
			      shouldComponentUpdate() \{
			        return false;
			      \}
			
			      render() \{
			        return hoisted;
			      \}
			    \}
			
			    class Test extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          reverse: false
			        \};
			      \}
			
			      render() \{
			        const children = [<B key="b" />, <div key="a">A</div>];
			        if (this.state.reverse) \{
			          children.reverse();
			        \}
			        Object.freeze(children);
			
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                this.setState(\{ reverse: !this.state.reverse \});
			              \}\}
			            >
			              Swap Rows
			            </button>
			            <div>\{children\}</div>
			            <div>\{children\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    it('should correct swap rows', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual(
			        '<div><button>Swap Rows</button><div><span>SPAN</span><div>A</div></div><div><span>SPAN</span><div>A</div></div></div>'
			      );
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual(
			        '<div><button>Swap Rows</button><div><div>A</div><span>SPAN</span></div><div><div>A</div><span>SPAN</span></div></div>'
			      );
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual(
			        '<div><button>Swap Rows</button><div><span>SPAN</span><div>A</div></div><div><span>SPAN</span><div>A</div></div></div>'
			      );
			    \});
			  \});
			
			  describe('Root handling issues #6', () => \{
			    let i;
			
			    beforeEach(function () \{
			      i = 1;
			    \});
			
			    class B extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      shouldComponentUpdate() \{
			        return false;
			      \}
			
			      render() \{
			        return <div>\{i\}</div>;
			      \}
			    \}
			
			    class Test extends Component \{
			      render() \{
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                i++;
			                this.setState(\{\});
			              \}\}
			            >
			              Replace
			            </button>
			            <div>
			              <B key=\{i\} />
			            </div>
			          </div>
			        );
			      \}
			    \}
			
			    it('should replace keyed component if key changes', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual('<div><button>Replace</button><div><div>1</div></div></div>');
			      // click "Replace"
			      container.querySelector('button').click();
			      expect(container.innerHTML).toEqual('<div><button>Replace</button><div><div>2</div></div></div>');
			    \});
			  \});
			
			  describe('Cloned children issues #1', () => \{
			    class Test extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          reverse: false
			        \};
			      \}
			
			      render() \{
			        const a = <div key="b">B</div>;
			        const b = <div key="a">A</div>;
			
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                this.setState(\{ reverse: !this.state.reverse \});
			              \}\}
			            >
			              Swap Rows
			            </button>
			            <div>\{this.state.reverse ? [a, b].reverse() : [a, b]\}</div>
			            <div>\{this.state.reverse ? [a, b].reverse() : [a, b]\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    // this test is to replicate https://jsfiddle.net/localvoid/fmznjwxv/
			    it('should correct swap rows', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>B</div><div>A</div></div><div><div>B</div><div>A</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			    \});
			  \});
			  describe('Cloned children issues #2', () => \{
			    class Test extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          reverse: false
			        \};
			      \}
			
			      render() \{
			        const children = [<div key="b">B</div>, <div key="a">A</div>];
			        if (this.state.reverse) \{
			          children.reverse();
			        \}
			
			        return (
			          <div>
			            <button
			              onClick=\{() => \{
			                this.setState(\{ reverse: !this.state.reverse \});
			              \}\}
			            >
			              Swap Rows
			            </button>
			            <div>\{children\}</div>
			            <div>\{children\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    // this test is to replicate https://jsfiddle.net/localvoid/fmznjwxv/
			    it('should correct swap rows', () => \{
			      render(<Test />, container);
			      expect(container.innerHTML).toEqual('<div><button>Swap Rows</button><div><div>B</div><div>A</div></div><div><div>B</div><div>A</div></div></div>');
			      // click "SWAP ROWS"
			      container.querySelector('button').click();
			    \});
			  \});
			
			  describe('Asynchronous setStates', () => \{
			    it('Should not fail when parent component calls setState on unmounting children', (done) => \{
			      class Parent extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            text: 'bar'
			          \};
			
			          this.changeState = this.changeState.bind(this);
			        \}
			
			        changeState() \{
			          this.setState(\{
			            text: 'foo'
			          \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              <span>\{this.state.text\}</span>
			              \{this.props.toggle ? (
			                [<Tester toggle=\{this.props.toggle\} call=\{this.changeState\} />]
			              ) : (
			                <span style=\{this.props.toggle ? \{ color: 'blue' \} : null\}>tester</span>
			              )\}
			            </div>
			          );
			        \}
			      \}
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			        \}
			
			        componentWillUnmount() \{
			          // parent will do setState
			          this.props.call();
			        \}
			
			        render() \{
			          return (
			            <div>
			              <span style=\{this.props.toggle ? \{ color: 'blue' \} : null\}>foo</span>
			            </div>
			          );
			        \}
			      \}
			
			      render(<Parent toggle=\{true\} />, container);
			
			      expect(container.innerHTML).toEqual('<div><span>bar</span><div><span style="color: blue;">foo</span></div></div>');
			
			      render(<Parent toggle=\{false\} />, container);
			
			      setTimeout(() => \{
			        done();
			      \}, 40);
			    \});
			  \});
			
			  // Crappy test, not all browsers throw exception if frozen object is assigned value
			  // describe('Context', () => \{
			  //   it('Should be the same object always (dev frozen)', () => \{
			  //     class ContextClass extends Component \{
			  //       constructor(props, context) \{
			  //         super(props, context);
			  //         context.foo = 'bar';
			  //       \}
			  //     \}
			  //
			  //     expect(() => \{
			  //       render(<ContextClass />, container);
			  //     \}).toThrowError();
			  //   \});
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\components.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(84)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\createElement.fragment.spec.js', () => {
        const sourceCode = `
			import \{ Component, createFragment, createPortal, Fragment, render, rerender \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			import \{ ChildFlags \} from 'inferno-vnode-flags';
			
			describe('CreateElement (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('Fragments', () => \{
			    it('Should render and unmount fragment', () => \{
			      let Example = class Example extends Component \{
			        render() \{
			          return createFragment([createElement('div', null, 'First'), createElement('div', null, 'second')], ChildFlags.HasNonKeyedChildren);
			        \}
			      \};
			
			      render(createElement(Example, null), container);
			
			      expect(container.innerHTML).toBe('<div>First</div><div>second</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should render nested fragment', () => \{
			      let Example = class Example extends Component \{
			        render() \{
			          return createFragment(
			            [
			              createElement('div', null, 'First'),
			              createFragment([createElement('div', null, 'Sub1'), createElement('div', null, 'Sub2')], ChildFlags.HasNonKeyedChildren),
			              createElement('div', null, 'second')
			            ],
			            ChildFlags.HasNonKeyedChildren
			          );
			        \}
			      \};
			
			      render(createElement(Example, null), container);
			
			      expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be to replace component with fragment with another component', () => \{
			      let Example = class Example extends Component \{
			        render() \{
			          return createFragment(
			            [
			              createElement('div', null, 'First'),
			              createFragment([createElement('div', null, 'Sub1'), createElement('div', null, 'Sub2')], ChildFlags.HasNonKeyedChildren),
			              createElement('div', null, 'second')
			            ],
			            ChildFlags.HasNonKeyedChildren
			          );
			        \}
			      \};
			
			      function FunctionalComp() \{
			        return createFragment([createElement('div', null, 'Functional')], ChildFlags.HasNonKeyedChildren);
			      \}
			
			      render(createElement(Example, null), container);
			
			      expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			      render(createElement(FunctionalComp, null), container);
			
			      expect(container.innerHTML).toBe('<div>Functional</div>');
			
			      render(createElement(Example, null), container);
			
			      expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			      render(createElement(FunctionalComp, null), container);
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to move fragments', () => \{
			      const fragmentA = () => createFragment([createElement('div', \{ id: 'a1' \}, 'A1'), createElement('div', null, 'A2')], ChildFlags.HasNonKeyedChildren, 'A');
			
			      const fragmentB = () => createFragment([createElement('div', \{ id: 'b1' \}, 'B1')], ChildFlags.HasNonKeyedChildren, 'B');
			
			      const fragmentC = () =>
			        createFragment(
			          [createElement('div', \{ id: 'c1' \}, 'C1'), createElement('div', null, 'C2'), createElement('div', null, 'C3')],
			          ChildFlags.HasNonKeyedChildren,
			          'C'
			        );
			
			      render(createElement('div', null, fragmentA(), fragmentB(), fragmentC()), container);
			
			      expect(container.innerHTML).toBe('<div><div id="a1">A1</div><div>A2</div><div id="b1">B1</div><div id="c1">C1</div><div>C2</div><div>C3</div></div>');
			
			      let A1 = container.querySelector('#a1');
			      let B1 = container.querySelector('#b1');
			      let C1 = container.querySelector('#c1');
			
			      // Switch order
			      render(createElement('div', null, fragmentC(), fragmentA(), fragmentB()), container);
			
			      // Verify dom has changed and nodes are the same
			      expect(container.innerHTML).toBe('<div><div id="c1">C1</div><div>C2</div><div>C3</div><div id="a1">A1</div><div>A2</div><div id="b1">B1</div></div>');
			
			      expect(container.querySelector('#a1')).toBe(A1);
			      expect(container.querySelector('#b1')).toBe(B1);
			      expect(container.querySelector('#c1')).toBe(C1);
			
			      // Switch order again
			      render(createElement('div', null, fragmentB(), fragmentC()), container);
			
			      // Verify dom has changed and nodes are the same
			      expect(container.innerHTML).toBe('<div><div id="b1">B1</div><div id="c1">C1</div><div>C2</div><div>C3</div></div>');
			
			      expect(container.querySelector('#a1')).toBe(null);
			      expect(container.querySelector('#b1')).toBe(B1);
			      expect(container.querySelector('#c1')).toBe(C1);
			    \});
			
			    it('Should clone fragment children if they are passed as reference', () => \{
			      const fragmentA = createFragment([createElement('div', \{ id: 'a1' \}, 'A1'), createElement('div', null, 'A2')], ChildFlags.HasNonKeyedChildren, 'A');
			      const fragmentB = createFragment([createElement('div', \{ id: 'b1' \}, 'B1')], ChildFlags.HasNonKeyedChildren, 'B');
			      const fragmentC = createFragment(
			        [createElement('div', \{ id: 'c1' \}, 'C1'), createElement('div', null, 'C2'), createElement('div', null, 'C3')],
			        ChildFlags.HasNonKeyedChildren,
			        'C'
			      );
			
			      const content = [fragmentC];
			
			      function SFC() \{
			        return createElement(Fragment, null, createElement('span', null, '1'), createElement(Fragment, null, content), createElement('span', null, '2'));
			      \}
			
			      render(createElement(Fragment, null, fragmentA, createElement(SFC, \{ key: 'sfc' \}), fragmentB, fragmentC), container);
			
			      const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			      const FragmentBHtml = '<div id="b1">B1</div>';
			      const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			      const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			      expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + FragmentCHtml);
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to move component with fragment root', () => \{
			      const fragmentA = createFragment([createElement('div', \{ id: 'a1' \}, 'A1'), createElement('div', null, 'A2')], ChildFlags.HasNonKeyedChildren, 'A');
			      const fragmentB = createFragment([createElement('div', \{ id: 'b1' \}, 'B1')], ChildFlags.HasNonKeyedChildren, 'B');
			      const fragmentC = createFragment(
			        [createElement('div', \{ id: 'c1' \}, 'C1'), createElement('div', null, 'C2'), createElement('div', null, 'C3')],
			        ChildFlags.HasNonKeyedChildren,
			        'C'
			      );
			
			      const content = [fragmentC];
			
			      function SFC() \{
			        return createElement(Fragment, null, createElement('span', null, '1'), createElement(Fragment, null, content), createElement('span', null, '2'));
			      \}
			
			      render(createElement(Fragment, null, fragmentA, createElement(SFC, \{ key: 'sfc' \}), fragmentB, fragmentC), container);
			
			      const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			      const FragmentBHtml = '<div id="b1">B1</div>';
			      const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			      const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			      expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + FragmentCHtml);
			
			      // Switch order
			      render(createElement(Fragment, null, fragmentA, fragmentC, createElement(SFC, \{ key: 'sfc' \})), container);
			
			      expect(container.innerHTML).toBe(FragmentAHtml + FragmentCHtml + SFCHtml);
			
			      // Switch order again
			      render(
			        createElement(
			          Fragment,
			          null,
			          createElement('div', \{ key: '1' \}, '1'),
			          createElement(SFC, \{ key: 'sfc' \}),
			          fragmentA,
			          fragmentC,
			          createElement('div', \{ key: '1' \}, '2')
			        ),
			        container
			      );
			
			      // Verify dom has changed and nodes are the same
			      expect(container.innerHTML).toBe('<div>1</div>' + SFCHtml + FragmentAHtml + FragmentCHtml + '<div>2</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to move component with fragment root #2', () => \{
			      const fragmentA = createFragment([createElement('div', \{ id: 'a1' \}, 'A1'), createElement('div', null, 'A2')], ChildFlags.HasNonKeyedChildren, 'A');
			      const fragmentB = createFragment([createElement('div', \{ id: 'b1' \}, 'B1')], ChildFlags.HasNonKeyedChildren, 'B');
			      const fragmentC = createFragment(
			        [createElement('div', \{ id: 'c1' \}, 'C1'), createElement('div', null, 'C2'), createElement('div', null, 'C3')],
			        ChildFlags.HasNonKeyedChildren,
			        'C'
			      );
			
			      const content = [fragmentC];
			
			      function SFC() \{
			        return createElement(Fragment, null, createElement('span', null, '1'), createElement(Fragment, null, content), createElement('span', null, '2'));
			      \}
			
			      render(
			        createElement(
			          Fragment,
			          null,
			          fragmentA,
			          createElement(SFC, \{ key: 'sfc1' \}),
			          fragmentB,
			          createElement(SFC, \{ key: 'sfc2' \}),
			          fragmentC,
			          createElement(SFC, \{ key: 'sfc3' \})
			        ),
			        container
			      );
			
			      const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			      const FragmentBHtml = '<div id="b1">B1</div>';
			      const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			      const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			      expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + SFCHtml + FragmentCHtml + SFCHtml);
			
			      // Switch order
			      render(
			        createElement(
			          Fragment,
			          null,
			          createElement(SFC, \{ key: 'sfc3' \}),
			          fragmentA,
			          createElement(SFC, \{ key: 'sfc1' \}),
			          fragmentC,
			          createElement(SFC, \{ key: 'sfc2' \})
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe(SFCHtml + FragmentAHtml + SFCHtml + FragmentCHtml + SFCHtml);
			
			      // Switch order again
			      render(
			        createElement(
			          Fragment,
			          null,
			          createElement('div', \{ key: '1' \}, '1'),
			          createElement(SFC, \{ key: 'sfc1' \}),
			          createElement(SFC, \{ key: 'sfc2' \}),
			          fragmentA,
			          fragmentC,
			          createElement('div', \{ key: '1' \}, '2'),
			          createElement(SFC, \{ key: 'sfc3' \})
			        ),
			        container
			      );
			
			      // Verify dom has changed and nodes are the same
			      expect(container.innerHTML).toBe('<div>1</div>' + SFCHtml + SFCHtml + FragmentAHtml + FragmentCHtml + '<div>2</div>' + SFCHtml);
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to render fragments JSX way', () => \{
			      function Fragmenter(\{ first, mid, last, changeOrder \}) \{
			        if (changeOrder) \{
			          return createElement(
			            Fragment,
			            null,
			            createElement('div', null, first),
			            createElement(
			              Fragment,
			              null,
			              'More',
			              null,
			              'Hey!',
			              createElement(Fragment, null, createElement(Fragment, null, 'Large ', last), createElement(Fragment, null, 'And Small')),
			              createElement(Fragment, null, 'Nesting'),
			              mid
			            ),
			            createElement('span', null, 'bar'),
			            null
			          );
			        \}
			        return createElement(
			          Fragment,
			          null,
			          createElement('div', null, first),
			          'Hey!',
			          createElement(
			            Fragment,
			            null,
			            'More',
			            createElement(Fragment, null, 'Nesting'),
			            mid,
			            createElement(Fragment, null, createElement(Fragment, null, 'Large ', last), createElement(Fragment, null, 'And Small'))
			          ),
			          createElement('span', null, 'bar')
			        );
			      \}
			
			      let mountCounter = 0;
			      let unmountCounter = 0;
			
			      let FoobarCom = class FoobarCom extends Component \{
			        componentWillMount() \{
			          mountCounter++;
			        \}
			
			        componentWillUnmount() \{
			          unmountCounter++;
			        \}
			
			        render(props) \{
			          return createElement(
			            Fragment,
			            null,
			            props.children,
			            createPortal(createElement('div', null, 'InvisiblePortalCreator'), props.node),
			            null,
			            'Try out some crazy stuff'
			          );
			        \}
			      \};
			
			      const portalNode = document.createElement('div');
			
			      render(
			        createElement(
			          FoobarCom,
			          \{ node: portalNode \},
			          createElement(Fragmenter, \{
			            first: 'first',
			            mid: 'MID',
			            last: createElement('div', null, 'Why?')
			          \})
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div>first</div>Hey!MoreNestingMIDLarge <div>Why?</div>And Small<span>bar</span>Try out some crazy stuff');
			      expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			
			      render(
			        createElement(
			          FoobarCom,
			          \{ node: portalNode \},
			          createElement(Fragmenter, \{
			            first: createElement('span', null, 'GoGo'),
			            mid: 'MID',
			            last: createElement('div', null, 'Why?'),
			            changeOrder: true
			          \})
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div><span>GoGo</span></div>MoreHey!Large <div>Why?</div>And SmallNestingMID<span>bar</span>Try out some crazy stuff');
			      expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			
			      render(
			        createElement(
			          FoobarCom,
			          \{ node: portalNode \},
			          createElement(Fragmenter, \{
			            first: 'first',
			            mid: 'MID',
			            last: createElement('div', null, 'Why?')
			          \})
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div>first</div>Hey!MoreNestingMIDLarge <div>Why?</div>And Small<span>bar</span>Try out some crazy stuff');
			      expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			    \});
			
			    it('Should render deeply nested fragment', () => \{
			      function Fragmenter2() \{
			        return createElement(
			          Fragment,
			          null,
			          createElement(
			            Fragment,
			            null,
			            createElement(
			              Fragment,
			              null,
			              createElement(
			                Fragment,
			                null,
			                createElement(Fragment, null, createElement(Fragment, null, createElement(Fragment, null, createElement(Fragment, null, 'Okay!'))))
			              )
			            )
			          )
			        );
			      \}
			
			      render(createElement(Fragmenter2, null), container);
			
			      expect(container.innerHTML).toBe('Okay!');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should append DOM nodes to correct position when component root Fragmnet change', () => \{
			      let TestRoot = class TestRoot extends Component \{
			        render() \{
			          return createElement(Fragment, null, this.props.children);
			        \}
			      \};
			
			      render(
			        createElement(
			          'div',
			          null,
			          createElement(TestRoot, null, createElement('div', null, '1'), createElement('div', null, '2')),
			          createElement(TestRoot, null, createElement('span', null, 'Ok'), createElement('span', null, 'Test'))
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><span>Ok</span><span>Test</span></div>');
			
			      render(
			        createElement(
			          'div',
			          null,
			          createElement(
			            TestRoot,
			            null,
			            createElement('div', null, '1'),
			            createElement('div', null, '2'),
			            createElement('div', null, '3'),
			            createElement('div', null, '4')
			          ),
			          createElement(TestRoot, null, createElement('div', null, 'Other'))
			        ),
			        container
			      );
			      expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><div>3</div><div>4</div><div>Other</div></div>');
			    \});
			
			    it('Should not clear whole parent element when fragment children are cleared', () => \{
			      let TestRoot = class TestRoot extends Component \{
			        render() \{
			          return createElement(Fragment, null, this.props.children);
			        \}
			      \};
			
			      render(
			        createElement(
			          'div',
			          null,
			          createElement(TestRoot, null, createElement('div', null, '1'), createElement('div', null, '2')),
			          createElement(TestRoot, null, createElement('span', null, 'Ok'), createElement('span', null, 'Test'))
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><span>Ok</span><span>Test</span></div>');
			
			      render(
			        createElement(
			          'div',
			          null,
			          createElement(
			            TestRoot,
			            null,
			            createElement('div', null, '1'),
			            createElement('div', null, '2'),
			            createElement('div', null, '3'),
			            createElement('div', null, '4')
			          ),
			          createElement(TestRoot, null)
			        ),
			        container
			      );
			      expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><div>3</div><div>4</div></div>');
			    \});
			
			    it('Should move fragment and all its contents when using Fragment long syntax with keys', () => \{
			      let unmountCounter = 0;
			      let mountCounter = 0;
			
			      let TestLifecycle = class TestLifecycle extends Component \{
			        componentWillUnmount() \{
			          unmountCounter++;
			        \}
			
			        componentWillMount() \{
			          mountCounter++;
			        \}
			
			        render() \{
			          return createElement(Fragment, null, this.props.children);
			        \}
			      \};
			
			      render(
			        createElement(
			          'div',
			          null,
			          createElement(Fragment, \{ key: '1' \}, createElement(TestLifecycle, null, '1a'), createElement(TestLifecycle, null, '1b')),
			          createElement(Fragment, \{ key: '2' \}, createElement(TestLifecycle, null, '2a'), createElement(TestLifecycle, null, '2b'))
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div>1a1b2a2b</div>');
			      expect(unmountCounter).toBe(0);
			      expect(mountCounter).toBe(4);
			
			      render(
			        createElement(
			          'div',
			          null,
			          createElement(
			            Fragment,
			            \{ key: '2' \},
			            createElement(TestLifecycle, null, '2a'),
			            createElement(TestLifecycle, null, '2b'),
			            createElement(TestLifecycle, null, '2c')
			          ),
			          createElement(Fragment, \{ key: '1' \}, createElement(TestLifecycle, null, '1a'), createElement(TestLifecycle, null, '1b'))
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div>2a2b2c1a1b</div>');
			      expect(unmountCounter).toBe(0);
			      expect(mountCounter).toBe(5);
			
			      render(
			        createElement(
			          'div',
			          null,
			          createElement(
			            Fragment,
			            \{ key: '3' \},
			            createElement(TestLifecycle, null, '3a'),
			            createElement(TestLifecycle, null, '3b'),
			            createElement(TestLifecycle, null, '3c')
			          ),
			          createElement(Fragment, \{ key: '2' \}, createElement(TestLifecycle, null, '2a'), createElement(TestLifecycle, null, '2Patched'))
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<div>3a3b3c2a2Patched</div>');
			      expect(unmountCounter).toBe(3);
			      expect(mountCounter).toBe(8);
			    \});
			
			    it('Should unmount empty fragments', () => \{
			      render(createElement(Fragment, null, createElement(Fragment, null)), container);
			
			      expect(container.innerHTML).toBe('');
			
			      render(createElement(Fragment, null, createElement('div', null)), container);
			
			      expect(container.innerHTML).toBe('<div></div>');
			
			      render(createElement(Fragment, null, createElement(Fragment, null)), container);
			
			      expect(container.innerHTML).toBe('');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to replace last element in fragment', () => \{
			      render(
			        createElement(
			          Fragment,
			          null,
			          createElement(Fragment, null, createElement('span', null, '1a'), createElement('span', null, '1b'), createElement('div', null, '1c')),
			          createElement(Fragment, null, createElement('span', null, '2a'), createElement('span', null, '2b'), createElement('span', null, '2c')),
			          createElement(Fragment, null)
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<span>1a</span><span>1b</span><div>1c</div><span>2a</span><span>2b</span><span>2c</span>');
			
			      render(
			        createElement(
			          Fragment,
			          null,
			          createElement(Fragment, null, createElement('span', null, '1a'), createElement('span', null, '1c')),
			          createElement(Fragment, null, createElement('span', null, '2a'), createElement('span', null, '2b'), createElement('span', null, '2c')),
			          createElement(Fragment, null)
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<span>1a</span><span>1c</span><span>2a</span><span>2b</span><span>2c</span>');
			
			      render(createElement(Fragment, null, createElement(Fragment, null)), container);
			
			      expect(container.innerHTML).toBe('');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should mount Fragment with invalid children', () => \{
			      render(createElement(Fragment, null, null, undefined), container);
			
			      expect(container.innerHTML).toBe('');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should mount Fragment with invalid children #2', () => \{
			      function Foobar() \{
			        return null;
			      \}
			
			      render(createElement(Fragment, null, null, createElement(Foobar, null), undefined), container);
			
			      expect(container.innerHTML).toBe('');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should mount Fragment with invalid children #2', () => \{
			      let add = false;
			
			      function Foobar() \{
			        if (add) \{
			          return createElement('div', null, 'Ok');
			        \}
			        return null;
			      \}
			
			      render(createElement(Fragment, null, null, createElement(Foobar, null), undefined), container);
			
			      expect(container.innerHTML).toBe('');
			
			      add = true;
			
			      render(createElement(Fragment, null, null, createElement(Foobar, null), undefined), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div>');
			    \});
			
			    it('Should be possible to update from 0 to 1', () => \{
			      function Foobar() \{
			        return createElement('div', null, 'Ok');
			      \}
			
			      let content = [null];
			
			      render(
			        createElement(Fragment, null, createElement('span', null, '1'), createElement(Fragment, null, content), createElement('span', null, '2')),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			
			      content = [createElement(Foobar, null)];
			
			      render(
			        createElement(Fragment, null, createElement('span', null, '1'), createElement(Fragment, null, content), createElement('span', null, '2')),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<span>1</span><div>Ok</div><span>2</span>');
			    \});
			
			    it('Should be possible to update from 0 to 1 fragment -> fragment', () => \{
			      function Foobar() \{
			        return createElement('div', null, 'Ok');
			      \}
			
			      let content = [];
			
			      render(
			        createElement(Fragment, null, createElement('span', null, '1'), createElement(Fragment, null, content), createElement('span', null, '2')),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			
			      content = [createElement(Fragment, null, createElement(Foobar, null))];
			
			      render(
			        createElement(Fragment, null, createElement('span', null, '1'), createElement(Fragment, null, content), createElement('span', null, '2')),
			        container
			      );
			
			      expect(container.innerHTML).toBe('<span>1</span><div>Ok</div><span>2</span>');
			    \});
			
			    it('Should be possible to mount and patch single component fragment children', () => \{
			      let counter = 0;
			
			      let Foobar = class Foobar extends Component \{
			        componentWillMount() \{
			          counter++;
			        \}
			
			        render() \{
			          return null;
			        \}
			      \};
			
			      render(createElement(Fragment, null), container);
			
			      render(createElement(Fragment, null, createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('');
			      expect(counter).toBe(1);
			
			      render(createElement(Fragment, null, createElement('div', null, 'Ok'), createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to mount and patch single component fragment children - variation 2', () => \{
			      let counter = 0;
			
			      let Foobar = class Foobar extends Component \{
			        componentWillMount() \{
			          counter++;
			        \}
			
			        render() \{
			          return null;
			        \}
			      \};
			
			      let nodes = [];
			
			      render(createElement(Fragment, null, nodes), container);
			
			      nodes = [createElement(Foobar, null)];
			
			      render(createElement(Fragment, null, nodes), container);
			
			      nodes = [createElement(Foobar, null), createElement(Foobar, null), createElement(Foobar, null)];
			
			      render(createElement(Fragment, null, nodes), container);
			
			      nodes = [];
			
			      render(createElement(Fragment, null, nodes), container);
			
			      expect(container.innerHTML).toBe('');
			      expect(counter).toBe(3);
			
			      render(createElement(Fragment, null, createElement('div', null, 'Ok'), createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to patch single fragment child component', () => \{
			      let counter = 0;
			
			      let Foobar = class Foobar extends Component \{
			        componentWillMount() \{
			          counter++;
			        \}
			
			        render() \{
			          return null;
			        \}
			      \};
			
			      render(
			        createElement(Fragment, null, createElement(Fragment, null, createElement(Foobar, null)), createElement(Fragment, null, createElement(Foobar, null))),
			        container
			      );
			
			      expect(container.innerHTML).toBe('');
			      expect(counter).toBe(2);
			
			      render(
			        createElement(
			          Fragment,
			          null,
			          createElement(Fragment, null),
			          createElement(Fragment, null, createElement(Foobar, null)),
			          createElement(Fragment, null, createElement(Foobar, null)),
			          createElement(Fragment, null),
			          createElement(Foobar, null)
			        ),
			        container
			      );
			
			      expect(container.innerHTML).toBe('');
			      expect(counter).toBe(4);
			
			      render(createElement(Fragment, null, createElement('div', null, 'Ok'), createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to mount and patch single component fragment children', () => \{
			      let Foobar = class Foobar extends Component \{
			        render() \{
			          return null;
			        \}
			      \};
			
			      render(createElement(Fragment, null, createElement(Foobar, null)), container);
			
			      render(createElement(Fragment, null, createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('');
			
			      render(createElement(Fragment, null, createElement('div', null, 'Ok'), createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should be possible to mount and patch single component fragment children #2', () => \{
			      let Foobar = class Foobar extends Component \{
			        render() \{
			          return null;
			        \}
			      \};
			
			      render(createElement(Fragment, null, null), container);
			
			      render(createElement(Fragment, null, createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('');
			
			      render(createElement(Fragment, null, createElement('div', null, 'Ok'), createElement(Foobar, null)), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div>');
			
			      render(null, container);
			
			      expect(container.innerHTML).toBe('');
			    \});
			
			    it('Should mount fragment children to correct position Github #1412', () => \{
			      const f = (...xs) => createFragment(xs, 0);
			
			      class Articles extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ articles: ['id2', 'id3'], sections: ['id0', 'id1'] \};
			        \}
			
			        componentDidMount() \{
			          expect(container.innerHTML).toEqual(
			            '<h1>App</h1><section><h2>id0</h2><aside>Today</aside><article>id2</article><article>id3</article></section><section><h2>id1</h2><aside>Today</aside><article>id2</article><article>id3</article></section><footer>2018</footer>'
			          );
			
			          this.setState(\{ sections: [] \});
			
			          rerender();
			
			          expect(container.innerHTML).toEqual('<h1>App</h1><footer>2018</footer>');
			
			          this.setState(\{ articles: ['id2', 'id3'], sections: ['id0', 'id1'] \});
			
			          rerender();
			
			          expect(container.innerHTML).toEqual(
			            '<h1>App</h1><section><h2>id0</h2><aside>Today</aside><article>id2</article><article>id3</article></section><section><h2>id1</h2><aside>Today</aside><article>id2</article><article>id3</article></section><footer>2018</footer>'
			          );
			        \}
			
			        render() \{
			          return f(
			            this.state.sections.map((section) =>
			              createElement('section', null, [
			                createElement('h2', null, section),
			                this.state.articles.map((article) => f(article === 'id2' && createElement('aside', null, 'Today'), createElement('article', null, article)))
			              ])
			            )
			          );
			        \}
			      \}
			
			      class App extends Component \{
			        render() \{
			          return f(createElement('h1', null, 'App'), createElement(Articles), createElement('footer', null, '2018'));
			        \}
			      \}
			
			      render(createElement(App), container);
			
			      rerender();
			    \});
			
			    it('Should re-mount fragment children to correct position when edge is component', () => \{
			      const f = (...xs) => createFragment(xs, 0);
			
			      class Articles extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ articles: ['id2', 'id3'], sections: ['id0', 'id1'] \};
			        \}
			
			        componentDidMount() \{
			          expect(container.innerHTML).toEqual(
			            '<h1>App</h1><section><h2>id0</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><section><h2>id1</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><footer>2018</footer><div>1</div><div>2</div>'
			          );
			
			          this.setState(\{ sections: [] \});
			
			          rerender();
			
			          expect(container.innerHTML).toEqual('<h1>App</h1><footer>2018</footer><div>1</div><div>2</div>');
			
			          this.setState(\{ articles: ['id2', 'id3'], sections: ['id0', 'id1'] \});
			
			          rerender();
			
			          expect(container.innerHTML).toEqual(
			            '<h1>App</h1><section><h2>id0</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><section><h2>id1</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><footer>2018</footer><div>1</div><div>2</div>'
			          );
			        \}
			
			        render() \{
			          return f(
			            this.state.sections.map((section) =>
			              createElement(Section, \{
			                children: [
			                  createElement('h2', null, section),
			                  this.state.articles.map((article) => f(article === 'id2' && createElement('aside', null, 'Today'), createElement('article', null, article)))
			                ]
			              \})
			            )
			          );
			        \}
			      \}
			
			      function Section(props) \{
			        return f(createElement('section', null, props.children), createElement('div', null, 'end'));
			      \}
			
			      function EdgeComponent() \{
			        return f(createElement('footer', null, '2018'), createElement('div', null, '1'), createElement('div', null, '2'));
			      \}
			
			      class App extends Component \{
			        render() \{
			          return f(createElement('h1', null, 'App'), createElement(Articles), createElement(EdgeComponent));
			        \}
			      \}
			
			      render(createElement(App), container);
			
			      rerender();
			    \});
			
			    it('Should append more fragment children to correct position when edge is component', () => \{
			      const f = (...xs) => createFragment(xs, 0);
			
			      class Articles extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ articles: ['id2', 'id3'], sections: ['id0', 'id1'] \};
			        \}
			
			        componentDidMount() \{
			          expect(container.innerHTML).toEqual(
			            '<h1>App</h1><section><h2>id0</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><section><h2>id1</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><footer>2018</footer><div>1</div><div>2</div>'
			          );
			
			          this.setState(\{ articles: [], sections: ['id0'] \});
			
			          rerender();
			
			          expect(container.innerHTML).toEqual('<h1>App</h1><section><h2>id0</h2></section><div>end</div><footer>2018</footer><div>1</div><div>2</div>');
			
			          this.setState(\{ articles: ['id2', 'id3'], sections: ['id0', 'id1'] \});
			
			          rerender();
			
			          expect(container.innerHTML).toEqual(
			            '<h1>App</h1><section><h2>id0</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><section><h2>id1</h2><aside>Today</aside><article>id2</article><article>id3</article></section><div>end</div><footer>2018</footer><div>1</div><div>2</div>'
			          );
			        \}
			
			        render() \{
			          return f(
			            this.state.sections.map((section) =>
			              createElement(Section, \{
			                children: [
			                  createElement('h2', null, section),
			                  this.state.articles.map((article) => f(article === 'id2' && createElement('aside', null, 'Today'), createElement('article', null, article)))
			                ]
			              \})
			            )
			          );
			        \}
			      \}
			
			      function Section(props) \{
			        return f(createElement('section', null, props.children), createElement('div', null, 'end'));
			      \}
			
			      function EdgeComponent() \{
			        return f(createElement('footer', null, '2018'), createElement('div', null, '1'), createElement('div', null, '2'));
			      \}
			
			      class App extends Component \{
			        render() \{
			          return f(createElement('h1', null, 'App'), createElement(Articles), createElement(EdgeComponent));
			        \}
			      \}
			
			      render(createElement(App), container);
			
			      rerender();
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\createElement.fragment.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(27)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\createElement.spec.js', () => {
        const sourceCode = `
			import \{ Component, createRef, forwardRef, Fragment, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('CreateElement (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should handle events correctly when having multiple children', () => \{
			    let triggered = false;
			
			    const App = () => \{
			      return createElement(
			        'div',
			        null,
			        createElement('div', \{ className: 'title' \}, 'Example'),
			        createElement(
			          'button',
			          \{
			            type: 'button',
			            onClick: () => \{
			              triggered = !triggered;
			            \}
			          \},
			          'Do a thing'
			        )
			      );
			    \};
			
			    // eslint-disable-next-line
			    render(App(), container);
			    expect(container.innerHTML).toBe('<div><div class="title">Example</div><button type="button">Do a thing</button></div>');
			    expect(triggered).toBe(false);
			
			    const buttons = container.querySelectorAll('button');
			    buttons.forEach((button) => button.click());
			
			    expect(triggered).toBe(true);
			  \});
			
			  it('Should handle events correctly when having single child', () => \{
			    let triggered = false;
			
			    const app = () => \{
			      return createElement(
			        'div',
			        null,
			        createElement(
			          'button',
			          \{
			            type: 'button',
			            onClick: () => \{
			              triggered = !triggered;
			            \}
			          \},
			          'Do a thing'
			        )
			      );
			    \};
			
			    render(app(), container);
			    expect(container.innerHTML).toBe('<div><button type="button">Do a thing</button></div>');
			    expect(triggered).toBe(false);
			
			    const buttons = container.querySelectorAll('button');
			    buttons.forEach((button) => button.click());
			
			    expect(triggered).toBe(true);
			  \});
			
			  it('Should allow passing childs through "children" property (native component)', () => \{
			    const app = () => \{
			      return createElement(
			        'div',
			        null,
			        createElement('button', \{
			          type: 'button',
			          children: ['Do a thing']
			        \})
			      );
			    \};
			
			    render(app(), container);
			    expect(container.innerHTML).toBe('<div><button type="button">Do a thing</button></div>');
			  \});
			
			  it('Should allow passing childs through "children" property (custom component)', () => \{
			    const Button = (props) => createElement('button', props);
			    const app = () => \{
			      return createElement(
			        'div',
			        null,
			        createElement(Button, \{
			          type: 'button',
			          children: ['Do a thing']
			        \})
			      );
			    \};
			
			    render(app(), container);
			    expect(container.innerHTML).toBe('<div><button type="button">Do a thing</button></div>');
			  \});
			
			  it('Should handle node with hooks and key', (done) => \{
			    const node = () => createElement('div', \{ key: 'key2' \}, 'Hooks');
			    const app = createElement(node, \{
			      key: 'key1',
			      onComponentDidMount(domNode) \{
			        expect(app.key).toBe('key1');
			        expect(domNode.tagName).toBe('DIV');
			        done();
			      \}
			    \});
			
			    render(app, container);
			    expect(container.innerHTML).toBe('<div>Hooks</div>');
			  \});
			
			  it('Should handle node with children but no props', () => \{
			    const node = () => createElement('div', null, 'Hooks');
			    const app = createElement(node, null, 'Hooks');
			
			    render(app, container);
			    expect(container.innerHTML).toBe('<div>Hooks</div>');
			  \});
			
			  it('Should handle node with refs', (done) => \{
			    let myRef = 'myRef';
			
			    const app = () => \{
			      const node = () =>
			        createElement('a', \{
			          ref: (c) => (myRef = c)
			        \});
			      return createElement(node, \{
			        onComponentDidMount() \{
			          expect(myRef.tagName).toBe('A');
			          done();
			        \}
			      \});
			    \};
			    render(createElement(app, null), container);
			  \});
			
			  describe('Fragments', () => \{
			    it('Should render Fragment with key', () => \{
			      render(createElement(Fragment, \{ key: 'first' \}, createElement('div', null, 'Ok'), createElement('span', null, 'Test')), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div><span>Test</span>');
			
			      const div = container.querySelector('div');
			      const span = container.querySelector('span');
			
			      render(createElement(Fragment, \{ key: 'foobar' \}, createElement('div', null, 'Ok'), createElement('span', null, 'Test')), container);
			
			      // Verify key works
			      expect(container.innerHTML).toBe('<div>Ok</div><span>Test</span>');
			
			      expect(div).not.toBe(container.querySelector('div'));
			      expect(span).not.toBe(container.querySelector('span'));
			    \});
			  \});
			
			  it('Should be possible to forward createRef', () => \{
			    const FancyButton = forwardRef((props, ref) => createElement('button', \{ ref: ref, className: 'FancyButton' \}, props.children));
			
			    expect(FancyButton.render).toBeDefined();
			
			    class Hello extends Component \{
			      constructor(props) \{
			        super(props);
			
			        // You can now get a ref directly to the DOM button:
			        this.btn = createRef();
			      \}
			
			      componentDidMount() \{
			        expect(this.btn.current).toBe(container.querySelector('button'));
			      \}
			      render() \{
			        return createElement(FancyButton, \{ ref: this.btn \}, 'Click me!');
			      \}
			    \}
			
			    render(createElement(Hello), container);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\createElement.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\createElementTyped.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('CreateElement (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should render zero children', () => \{
			    const App = () => createElement('div', null);
			    render(App(), container);
			  \});
			
			  it('Should render null children', () => \{
			    const App = () => createElement('div', null, null);
			    render(App(), container);
			  \});
			
			  it('Should render undefined children', () => \{
			    const App = () => createElement('div', null, undefined);
			    render(App(), container);
			  \});
			
			  it('Should render one child', () => \{
			    const App = () => createElement('div', null, createElement('div', \{ className: 'title' \}, 'Example'));
			
			    render(App(), container);
			  \});
			
			  it('Should render multiple children', () => \{
			    const App = () =>
			      createElement('div', null, createElement('div', \{ className: 'title' \}, 'Example'), createElement('button', \{ type: 'button' \}, 'Do a thing'));
			
			    render(App(), container);
			  \});
			
			  it('Should render array of children', () => \{
			    const App = () =>
			      createElement('div', null, [createElement('div', \{ className: 'title' \}, 'Example'), createElement('button', \{ type: 'button' \}, 'Do a thing')]);
			
			    render(App(), container);
			  \});
			
			  it('Should check component props', () => \{
			    type MyComponentProps = \{ className: string \};
			
			    class App extends Component<MyComponentProps, any> \{
			      public render() \{
			        return createElement('div', \{ className: this.props.className \}, createElement('div', \{ className: 'title' \}, 'Example'), createElement('hr'));
			      \}
			    \}
			
			    render(createElement(App, \{ className: 'App' \}), container);
			
			    /** Should be an error if uncommented: */
			    // render(createElement(App, \{ className: 1 \}), container);
			    // render(createElement(App, \{\}), container);
			
			    /** Would like to be an error, but it'd break createElement('hr'): */
			    render(createElement(App), container);
			  \});
			
			  it('Should check functional component props', () => \{
			    const App = (\{ className \}: \{ className: string \}) =>
			      createElement('div', \{ className \}, createElement('div', \{ className: 'title' \}, 'Example'), createElement('hr'));
			
			    render(createElement(App, \{ className: 'App' \}), container);
			
			    /** Should be an error if uncommented: */
			    // render(createElement(App, \{ className: 1 \}), container);
			    // render(createElement(App, \{\}), container);
			
			    /** Would like to be an error but it'd break createElement('hr'): */
			    render(createElement(App), container);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\createElementTyped.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\creation.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Creation - (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  [
			    \{
			      description: 'should render div with span child',
			      template: () => \{
			        return createElement('div', null, createElement('span'));
			      \},
			      tagName: 'div',
			      children: 1,
			      textContent: ''
			    \},
			    \{
			      description: 'should render span with span child',
			      template: () => createElement('span', null, createElement('span')),
			      tagName: 'span',
			      children: 1,
			      textContent: ''
			    \},
			    \{
			      description: 'should render div with two span children',
			      template: () => createElement('div', null, createElement('div'), createElement('div')),
			      tagName: 'div',
			      children: 2,
			      textContent: ''
			    \},
			    \{
			      description: 'should render div with three span children and unset middle child',
			      template: () => createElement('div', null, createElement('span'), null, createElement('span')),
			      tagName: 'div',
			      children: 2,
			      textContent: ''
			    \},
			    \{
			      description: 'should render div with three span children and unset first, and middle child',
			      template: () => createElement('div', null, null, null, createElement('span')),
			      tagName: 'div',
			      children: 1,
			      textContent: ''
			    \},
			    \{
			      description: 'should render div with three span children and unset first, and middle child',
			      template: () => createElement('div', null, null, null, null),
			      tagName: 'div',
			      children: 0,
			      textContent: ''
			    \},
			    \{
			      description: 'should render div with two null children and one text node',
			      template: () => createElement('div', null, null, 'Baboy', null),
			      tagName: 'div',
			      children: 1,
			      textContent: 'Baboy'
			    \},
			    \{
			      description: 'should render div with one textNode and a span children',
			      template: () => createElement('div', null, 'Hello!', null, createElement('span')),
			      tagName: 'div',
			      children: 2,
			      textContent: 'Hello!'
			    \},
			    \{
			      description: 'should render div with two textNodes and a span children',
			      template: () => createElement('div', null, 'Hello, ', null, 'World!', createElement('span')),
			      tagName: 'div',
			      children: 3,
			      textContent: 'Hello, World!'
			    \},
			    \{
			      description: 'should render div with two textNodes and a two span children',
			      template: () => createElement('div', null, 'Hello, ', createElement('span'), 'World!', createElement('span')),
			      tagName: 'div',
			      children: 4,
			      textContent: 'Hello, World!'
			    \},
			    \{
			      description: 'should render div with two textNodes and one span children, and span with textNode',
			      template: () => createElement('div', null, 'Hello', createElement('span'), ', ', createElement('span', null, 'World!')),
			      tagName: 'div',
			      children: 4,
			      textContent: 'Hello, World!'
			    \},
			    \{
			      description: 'should render div with tree null values in an array for children',
			      template: () => createElement('div', null, null, null, null),
			      tagName: 'div',
			      children: 0,
			      textContent: ''
			    \},
			    \{
			      description: 'should render div with b child, and tree null values in an array for children',
			      template: () => createElement('div', null, createElement('b', null, null, null, null)),
			      tagName: 'div',
			      children: 1,
			      textContent: ''
			    \},
			    \{
			      description: 'should render div with b child, and number and two null values in an array for children',
			      template: () => createElement('div', null, createElement('b', null, null, 123, null)),
			      tagName: 'div',
			      children: 1,
			      textContent: '123'
			    \},
			    \{
			      description: 'should render empty div',
			      template: () => createElement('div'),
			      tagName: 'div',
			      children: 0,
			      textContent: ''
			    \},
			    \{
			      description: 'should render empty span',
			      template: () => createElement('span'),
			      tagName: 'span',
			      children: 0,
			      textContent: ''
			    \}
			  ].forEach((test) => \{
			    it(test.description, () => \{
			      render(test.template(), container);
			      expect(container.firstChild.nodeType).toBe(1);
			      expect(container.firstChild.tagName.toLowerCase()).toBe(test.tagName);
			      expect(container.firstChild.childNodes.length).toBe(test.children);
			      expect(container.firstChild.textContent).toBe(test.textContent);
			
			      render(test.template(), container);
			      expect(container.firstChild.nodeType).toBe(1);
			      expect(container.firstChild.tagName.toLowerCase()).toBe(test.tagName);
			      expect(container.firstChild.childNodes.length).toBe(test.children);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\creation.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\elements.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('Elements (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should render a simple div', () => \{
			    render(<div />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    render(<div />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			  \});
			
			  it('should render a simple div with multiple children', () => \{
			    render(
			      <div>
			        <span />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    render(
			      <div>
			        <span />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    render(<div />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    render(
			      <div>
			        <span />
			        <span />
			        <span />
			        <span />
			        <span />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			
			    render(
			      <div>
			        <span />
			        <span />
			        <span />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    render(undefined, container);
			    render(
			      <div>
			        <span />
			        <b>Hello, World!</b>
			        <span />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			  \});
			
			  it('should render a simple div with multiple children #2', () => \{
			    const items = [1, 2, 3];
			    const header = 'Hello ';
			
			    render(
			      <div>
			        \{header\}
			        \{items\}
			      </div>,
			      container
			    );
			    expect(container.firstChild.innerHTML).toBe('Hello 123');
			
			    render(
			      <div>
			        \{header\}
			        \{[4, 5, 6]\}
			      </div>,
			      container
			    );
			    expect(container.firstChild.innerHTML).toBe('Hello 456');
			  \});
			
			  it('should render a simple div with span child and dynamic id attribute', () => \{
			    render(<div id=\{'hello'\} />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.getAttribute('id')).toBe('hello');
			
			    render(<div id=\{null\} />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.getAttribute('id')).toBe(null);
			
			    render(<div className=\{'hello'\} />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.getAttribute('class')).toBe('hello'); // class attribute exist!
			
			    render(<div id="hello" />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.getAttribute('id')).toBe('hello');
			
			    // unset
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			  \});
			
			  it('should render a simple div with span child and various dynamic attributes', () => \{
			    render(<div id=\{'hello'\} />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.getAttribute('id')).toBe('hello');
			
			    render(<div />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			
			    render(<div className=\{'hello'\} />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.getAttribute('class')).toBe('hello');
			
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should render a simple div with dynamic span child', () => \{
			    const child = <span />;
			
			    render(<div>\{undefined\}</div>, container);
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    render(<div>\{null\}</div>, container);
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    // unset
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should render a advanced div with static child and dynamic attributes', () => \{
			    let attrs;
			
			    attrs = 'id#1';
			
			    render(
			      <div>
			        <div id=\{attrs\} />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.getAttribute('id')).toBe('id#1');
			
			    attrs = null;
			
			    render(
			      <div>
			        <div id=\{attrs\} />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.getAttribute('id')).toBe(null);
			
			    attrs = undefined;
			
			    render(<div id=\{attrs\} />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.getAttribute('id')).toBe(null);
			
			    attrs = 'id#4';
			
			    render(
			      <div>
			        <div id=\{attrs\} />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.getAttribute('id')).toBe('id#4');
			
			    attrs = 13 - (44 * 4) / 4;
			
			    let b = <b className=\{123\}>Hello, World!</b>;
			    let n = <n>\{b\}</n>;
			
			    render(
			      <div className="Hello, World!">
			        <span>
			          <div id=\{attrs\}>\{n\}</div>
			        </span>
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('Hello, World!');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    expect(container.firstChild.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.firstChild.getAttribute('id')).toBe('-31');
			    expect(container.firstChild.firstChild.firstChild.firstChild.nodeName).toBe('N');
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.nodeName).toBe('B');
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.innerHTML).toBe('Hello, World!');
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.getAttribute('class')).toBe('123');
			
			    attrs = 13 - (44 * 4) / 4;
			
			    b = <b className=\{1243\}>Hello, World!</b>;
			    n = <n>\{b\}</n>;
			
			    render(
			      <div className="Hello, World!">
			        <span>
			          <div id=\{attrs\}>\{n\}</div>
			        </span>
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('Hello, World!');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    expect(container.firstChild.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.firstChild.getAttribute('id')).toBe('-31');
			    expect(container.firstChild.firstChild.firstChild.firstChild.nodeName).toBe('N');
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.nodeName).toBe('B');
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.innerHTML).toBe('Hello, World!');
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.getAttribute('class')).toBe('1243');
			
			    // unset
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			
			    attrs = 'id#444';
			
			    render(
			      <div className="Hello, Dominic" id=\{attrs\}>
			        <div id=\{attrs\} />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('Hello, Dominic');
			    expect(container.firstChild.getAttribute('id')).toBe('id#444');
			    expect(container.firstChild.firstChild.getAttribute('id')).toBe('id#444');
			
			    attrs = 'id#' + 333 - 333 / 3;
			
			    render(
			      <div className="Hello, Dominic" id=\{attrs\}>
			        <div id=\{attrs\} />
			      </div>,
			      container
			    );
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('Hello, Dominic');
			    expect(container.firstChild.getAttribute('id')).toBe('NaN');
			    expect(container.firstChild.firstChild.getAttribute('id')).toBe('NaN');
			
			    // unset
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			  \});
			
			  it('should render a simple div with dynamic span child and update to div child', () => \{
			    let child = <span />;
			
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			
			    render(<div />, container);
			
			    child = <div />;
			
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			
			    child = (
			      <div>
			        <div />
			        <div />
			        <div />
			        <div />
			        <div />
			        <div />
			        <div />
			        <div />
			        <div />
			      </div>
			    );
			
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.childNodes.length).toBe(9);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.firstChild.nodeName).toBe('DIV');
			    child = <div>Hello, World!</div>;
			
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.innerHTML).toBe('Hello, World!');
			
			    render(<div>\{null\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			
			    render(<div />, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			  \});
			
			  it('should render and unset a simple div with dynamic span child', () => \{
			    let child;
			
			    child = (
			      <span>
			        <span />
			        <span />
			      </span>
			    );
			
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.childNodes.length).toBe(2);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    expect(container.firstChild.firstChild.firstChild.nodeName).toBe('SPAN');
			
			    render(<div>\{null\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			
			    const divs = <div />;
			
			    child = (
			      <span>
			        <span>\{divs\}</span>
			      </span>
			    );
			
			    render(<div>\{child\}</div>, container);
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.nodeName).toBe('SPAN');
			    expect(container.firstChild.firstChild.firstChild.nodeName).toBe('SPAN');
			    expect(container.firstChild.firstChild.firstChild.firstChild.nodeName).toBe('DIV');
			  \});
			
			  it('should render a simple div children set to undefined', () => \{
			    render(<div>\{undefined\}</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('');
			
			    render(<div>\{undefined\}</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('');
			  \});
			
			  it('should render a simple div children set to null', () => \{
			    render(<div>\{null\}</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('');
			
			    render(<div>\{null\}</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('');
			
			    // unset
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			  \});
			
			  it('should render a simple div children set to null', () => \{
			    render(
			      <div>
			        <div>\{null\}</div>
			      </div>,
			      container
			    );
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			
			    render(
			      <div>
			        <div>\{null\}</div>
			      </div>,
			      container
			    );
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			  \});
			
			  it('should render a double div and a text node', () => \{
			    render(<div>\{<div>Hello, World!</div>\}</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('Hello, World!');
			
			    render(<div>\{null\}</div>, container);
			
			    render(<div>\{<div>Hello, Inferno!</div>\}</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('Hello, Inferno!');
			  \});
			
			  it('should render a single div with text node', () => \{
			    render(
			      <div>
			        <span />
			        <span />
			      </div>,
			      container
			    );
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('');
			
			    // unset
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			  \});
			
			  it('should render a simple div with a text node', () => \{
			    render(<div>Hello, world!</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('Hello, world!');
			
			    render(<div>Hello, world! 2</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.textContent).toBe('Hello, world! 2');
			  \});
			
			  it('should render a simple div with attributes', () => \{
			    render(<div id=\{123\}>Hello, world!</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.getAttribute('id')).toBe('123');
			    expect(container.firstChild.textContent).toBe('Hello, world!');
			
			    render(<div id=\{'foo'\}>Hello, world! 2</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			    expect(container.firstChild.getAttribute('id')).toBe('foo');
			    expect(container.firstChild.textContent).toBe('Hello, world! 2');
			  \});
			
			  it('should render a simple div with inline style', () => \{
			    render(<div style="background-color:lightgrey;">Hello, world!</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			
			    render(<div id=\{'foo'\}>Hello, world! 2</div>, container);
			
			    expect(container.nodeName).toBe('DIV');
			
			    // unset
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			  \});
			
			  it('should render "className" attribute', () => \{
			    render(<div className="123" />, container);
			    expect(container.firstChild.getAttribute('class')).toEqual('123');
			
			    render(<div className=\{null\} />, container);
			    expect(container.firstChild.className).toEqual('');
			
			    render(<div className=\{undefined\} />, container);
			    expect(container.firstChild.className).toEqual('');
			
			    render(<div className="Inferno rocks!" />, container);
			    expect(container.firstChild.className).toEqual('Inferno rocks!');
			    expect(container.firstChild.innerHTML).toBe('');
			  \});
			
			  it("shouldn't render null value", () => \{
			    render(<input values=\{null\} />, container);
			
			    expect(container.value).toBe(undefined);
			    expect(container.innerHTML).toBe('<input>');
			
			    render(<input values=\{undefined\} />, container);
			    expect(container.value).toBe(undefined);
			
			    render(<input values=\{null\} />, container);
			    expect(container.value).toBe(undefined);
			
			    expect(container.innerHTML).toBe('<input>');
			
			    render(null, container);
			    expect(container.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(0);
			  \});
			
			  it('should set values as properties by default', () => \{
			    render(<input title="Tip!" />, container);
			
			    expect(container.firstChild.getAttribute('title')).toEqual('Tip!');
			    expect(container.innerHTML).toBe('<input title="Tip!">');
			
			    render(<input name="Tip!" />, container);
			
			    expect(container.firstChild.getAttribute('name')).toEqual('Tip!');
			    expect(container.innerHTML).toBe('<input name="Tip!">');
			
			    render(<input title="Tip!" />, container);
			
			    expect(container.firstChild.getAttribute('title')).toEqual('Tip!');
			    expect(container.innerHTML).toBe('<input title="Tip!">');
			  \});
			
			  it('should render a simple div with dynamic values and props', () => \{
			    let val1, val2;
			
			    val1 = 'Inferno';
			    val2 = 'Sucks!';
			
			    render(
			      <div className="foo">
			        <span className="bar">\{val1\}</span>
			        <span className="yar">\{val2\}</span>
			      </div>,
			      container
			    );
			
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.childNodes[0].childNodes[0].getAttribute('class')).toEqual('bar');
			    expect(container.childNodes[0].childNodes[0].textContent).toEqual('Inferno');
			    expect(container.childNodes[0].childNodes[1].getAttribute('class')).toEqual('yar');
			    expect(container.childNodes[0].childNodes[1].textContent).toEqual('Sucks!');
			
			    render(
			      <div className="fooo">
			        <span className="bar">\{val1\}</span>
			        <span className="yar">\{val2\}</span>
			      </div>,
			      container
			    );
			
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.childNodes[0].childNodes[0].getAttribute('class')).toEqual('bar');
			    expect(container.childNodes[0].childNodes[0].textContent).toEqual('Inferno');
			    expect(container.childNodes[0].childNodes[1].getAttribute('class')).toEqual('yar');
			    expect(container.childNodes[0].childNodes[1].textContent).toEqual('Sucks!');
			  \});
			
			  it('should properly render a input with download attribute', () => \{
			    let val1;
			
			    val1 = 'false';
			
			    render(<input download=\{val1\} />, container);
			
			    expect(container.firstChild.nodeName).toBe('INPUT');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('download')).toBe('false');
			
			    val1 = 'true';
			
			    render(<input download=\{val1\} />, container);
			
			    expect(container.firstChild.nodeName).toBe('INPUT');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('download')).toBe('true');
			  \});
			
			  it('should properly render "className" property on a custom element', () => \{
			    render(<custom-elem className="Hello, world!" />, container);
			
			    expect(container.firstChild.nodeName).toBe('CUSTOM-ELEM');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('class')).toBe('Hello, world!');
			
			    render(<custom-elem className="Hello, world!" />, container);
			
			    expect(container.firstChild.nodeName).toBe('CUSTOM-ELEM');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('class')).toBe('Hello, world!');
			  \});
			
			  it('should properly render "width" and "height" attributes', () => \{
			    render(<img src="" alt="Smiley face" height=\{42\} width=\{42\} />, container);
			
			    expect(container.firstChild.nodeName).toBe('IMG');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('src')).toBe('');
			    expect(container.firstChild.getAttribute('alt')).toBe('Smiley face');
			    expect(container.firstChild.getAttribute('height')).toBe('42');
			    expect(container.firstChild.getAttribute('width')).toBe('42');
			
			    render(<img src="" alt="Smiley face" height=\{42\} width=\{42\} fooBar=\{[]\} />, container);
			
			    expect(container.firstChild.nodeName).toBe('IMG');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('src')).toBe('');
			    expect(container.firstChild.getAttribute('alt')).toBe('Smiley face');
			    expect(container.firstChild.getAttribute('height')).toBe('42');
			    expect(container.firstChild.getAttribute('width')).toBe('42');
			  \});
			
			  it('should properly render "width" and "height" attributes #2', () => \{
			    render(<input type="file" multiple="multiple" capture="capture" accept="image/*" />, container);
			
			    expect(container.firstChild.nodeName).toBe('INPUT');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('type')).toBe('file');
			
			    let multipleValue = container.firstChild.multiple;
			
			    // Inferno sets multiple using dom property always to boolean,
			    // but some browsers fe. IE9 still set it as multiple="multiple" which also works as expected
			    if (typeof multipleValue === 'string') \{
			      expect(multipleValue).toBe('multiple');
			    \} else \{
			      expect(multipleValue).toBe(true);
			    \}
			
			    expect(container.firstChild.capture).toBeTruthy(); // true and "true" are both valid
			    // expect(container.firstChild.getAttribute('accept')).toBe('image/*');
			
			    render(<input type="file" multiple="multiple" capture="capture" accept="image/*" />, container);
			
			    expect(container.firstChild.nodeName).toBe('INPUT');
			    expect(container.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('type')).toBe('file');
			
			    multipleValue = container.firstChild.multiple;
			
			    // Inferno sets multiple using dom property always to boolean,
			    // but some browsers fe. IE9 still set it as multiple="multiple" which also works as expected
			    if (typeof multipleValue === 'string') \{
			      expect(multipleValue).toBe('multiple');
			    \} else \{
			      expect(multipleValue).toBe(true);
			    \}
			
			    expect(container.firstChild.capture).toBeTruthy(); // true and "true" are both valid;
			    // expect(container.firstChild.getAttribute('accept')).toBe('image/*');
			  \});
			
			  it('should handle className', () => \{
			    render(<div className=\{'foo'\} />, container);
			    expect(container.firstChild.className).toBe('foo');
			    render(<div className=\{'bar'\} />, container);
			    expect(container.firstChild.className).toBe('bar');
			    render(<div className=\{null\} />, container);
			    expect(container.firstChild.className).toBe('');
			    render(<div className=\{undefined\} />, container);
			    expect(container.firstChild.className).toBe('');
			    render(<svg className=\{'fooBar'\} />, container);
			    expect(container.firstChild.getAttribute('class')).toBe('fooBar');
			  \});
			
			  it('should remove attributes', () => \{
			    render(<img height="17" />, container);
			    expect(container.firstChild.hasAttribute('height')).toBe(true);
			    render(<img />, container);
			    expect(container.firstChild.hasAttribute('height')).toBe(false);
			    render(<img height=\{null\} />, container);
			    expect(container.firstChild.hasAttribute('height')).toBe(false);
			  \});
			
			  it('should remove properties #2', () => \{
			    render(<div className="monkey" />, container);
			    expect(container.firstChild.getAttribute('class')).toBe('monkey');
			    render(<div />, container);
			    expect(container.firstChild.className).toBe('');
			    render(<svg className="monkey" />, container);
			    expect(container.firstChild.getAttribute('class')).toBe('monkey');
			    render(<svg />, container);
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			  \});
			
			  it('should not update when switching between null/undefined', () => \{
			    render(<div id=\{null\} />, container);
			    render(<div id=\{123\} />, container);
			    render(<div id=\{null\} />, container);
			    render(<div id=\{undefined\} />, container);
			    render(<div />, container);
			    render(<div id="ltr" />, container);
			    render(<div id=\{[]\} />, container);
			  \});
			
			  it('should render an iframe', () => \{
			    render(<iframe src="http://infernojs.org" />, container);
			    expect(container.firstChild.contentWindow).not.toBe(undefined);
			  \});
			
			  it('should dangerously set innerHTML', () => \{
			    render(<div dangerouslySetInnerHTML=\{\{ __html: 'Hello world!' \}\} />, container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			
			  it('Should not dangerously set innerHTML when previous is same as new one', () => \{
			    render(<div dangerouslySetInnerHTML=\{\{ __html: 'same' \}\} />, container);
			    expect(container.innerHTML).toBe('<div>same</div>');
			
			    render(<div dangerouslySetInnerHTML=\{\{ __html: 'same' \}\} />, container);
			    expect(container.innerHTML).toBe('<div>same</div>');
			
			    render(<div dangerouslySetInnerHTML=\{\{ __html: 'change' \}\} />, container);
			    expect(container.innerHTML).toBe('<div>change</div>');
			  \});
			
			  it('Should throw error if __html property is not set', () => \{
			    try \{
			      render(<div dangerouslySetInnerHTML=\{\{ __html: null \}\} />, container);
			    \} catch (e) \{
			      expect(e.message).toEqual('Inferno Error: dangerouslySetInnerHTML requires an object with a __html propety containing the innerHTML content.');
			    \}
			  \});
			
			  it('handles JSX spread props (including children)', () => \{
			    const foo = \{
			      children: 'Hello world!',
			      className: 'lol'
			    \};
			    const bar = \{
			      id: 'test'
			    \};
			
			    render(<div \{...foo\} \{...bar\} />, container);
			    expect(container.innerHTML).toBe('<div class="lol" id="test">Hello world!</div>');
			  \});
			
			  it('mixing JSX with non-JSX', () => \{
			    render(<div>\{createElement('div', null)\}</div>, container);
			    expect(container.innerHTML).toBe('<div><div></div></div>');
			    render(<div>\{createElement('span', null)\}</div>, container);
			    expect(container.innerHTML).toBe('<div><span></span></div>');
			    render(<span>\{createElement('div', null)\}</span>, container);
			    expect(container.innerHTML).toBe('<span><div></div></span>');
			  \});
			
			  it('should be able to construct input with Hooks, Events, Attributes defined', (done) => \{
			    function test() \{\}
			
			    const obj = \{
			      ref() \{\},
			      click() \{\}
			    \};
			    const bool = false;
			    const newValue = 't';
			    const spread = \{ id: 'test' \};
			
			    spyOn(obj, 'ref');
			    spyOn(obj, 'click');
			
			    render(
			      <input
			        type="text"
			        ref=\{obj.ref\}
			        spellcheck="false"
			        readOnly=\{bool ? 'readonly' : false\}
			        disabled=\{bool\}
			        ondragenter=\{test\}
			        ondragover=\{test\}
			        value=\{newValue\}
			        oninput=\{test\}
			        onclick=\{obj.click\}
			        className="edit-field"
			        onkeydown=\{test\}
			        onkeyup=\{test\}
			        onBlur=\{test\}
			        \{...spread\}
			      />,
			      container
			    );
			    const input = container.querySelector('#test');
			    expect(obj.click).toHaveBeenCalledTimes(0);
			    expect(obj.ref).toHaveBeenCalledTimes(1); // Verify hook works
			    input.click();
			    setTimeout(() => \{
			      expect(obj.click).toHaveBeenCalledTimes(1); // Verify hook works
			      done();
			    \}, 25);
			  \});
			
			  describe('should correctly handle VNodes as quasi-immutable objects, like ReactElement does', () => \{
			    const a = <div>Hello world</div>;
			    const b = <span>This works!</span>;
			    const C = (\{ children \}) => \{
			      return (
			        <div>
			          \{children\}
			          \{children\}
			          \{children\}
			        </div>
			      );
			    \};
			
			    it('basic example ', () => \{
			      render(a, container);
			      expect(container.innerHTML).toBe('<div>Hello world</div>');
			      render(b, container);
			      expect(container.innerHTML).toBe('<span>This works!</span>');
			    \});
			
			    it('basic example #2 ', () => \{
			      render(<div>\{[a, a, a]\}</div>, container);
			      expect(container.innerHTML).toBe('<div><div>Hello world</div><div>Hello world</div><div>Hello world</div></div>');
			      render(b, container);
			      expect(container.innerHTML).toBe('<span>This works!</span>');
			    \});
			
			    it('basic nested example ', () => \{
			      render(
			        <div>
			          \{a\}
			          \{b\}
			        </div>,
			        container
			      );
			      expect(container.innerHTML).toBe('<div><div>Hello world</div><span>This works!</span></div>');
			      render(
			        <div>
			          \{b\}
			          \{a\}
			        </div>,
			        container
			      );
			      expect(container.innerHTML).toBe('<div><span>This works!</span><div>Hello world</div></div>');
			    \});
			
			    it('basic nested component example ', () => \{
			      render(<C>\{a\}</C>, container);
			      expect(container.innerHTML).toBe('<div><div>Hello world</div><div>Hello world</div><div>Hello world</div></div>');
			      render(
			        <C>
			          \{b\}
			          \{a\}
			        </C>,
			        container
			      );
			      expect(container.innerHTML).toBe(
			        '<div><span>This works!</span><div>Hello world</div><span>This works!</span><div>Hello world</div><span>This works!</span><div>Hello world</div></div>'
			      );
			    \});
			  \});
			
			  describe('should correctly handle TEXT VNodes as quasi-immutable objects, like ReactElement does', () => \{
			    const a = createVNode(VNodeFlags.Text, null, null, 'Hello world');
			    const b = createVNode(VNodeFlags.Text, null, null, 'This works!');
			    const C = (\{ children \}) => (
			      <div>
			        \{children\}
			        \{children\}
			        \{children\}
			      </div>
			    );
			
			    it('basic example ', () => \{
			      render(a, container);
			      expect(container.innerHTML).toBe('Hello world');
			      render(b, container);
			      expect(container.innerHTML).toBe('This works!');
			    \});
			
			    it('basic example #2 ', () => \{
			      render(<div>\{[a, a, a]\}</div>, container);
			      expect(container.innerHTML).toBe('<div>Hello worldHello worldHello world</div>');
			      render(b, container);
			      expect(container.innerHTML).toBe('This works!');
			    \});
			
			    it('basic nested example ', () => \{
			      render(
			        <div>
			          \{a\}
			          \{b\}
			        </div>,
			        container
			      );
			      expect(container.innerHTML).toBe('<div>Hello worldThis works!</div>');
			      render(
			        <div>
			          \{b\}
			          \{a\}
			        </div>,
			        container
			      );
			      expect(container.innerHTML).toBe('<div>This works!Hello world</div>');
			    \});
			
			    it('basic nested component example #2 ', () => \{
			      render(<C>\{a\}</C>, container);
			      expect(container.innerHTML).toBe('<div>Hello worldHello worldHello world</div>');
			      render(
			        <C>
			          \{b\}
			          \{a\}
			        </C>,
			        container
			      );
			      expect(container.innerHTML).toBe('<div>This works!Hello worldThis works!Hello worldThis works!Hello world</div>');
			    \});
			  \});
			
			  describe('should properly render multiline text via JSX', () => \{
			    it('should render accordingly', () => \{
			      render(
			        <div class="tesla-battery__notice">
			          <p>
			            The actual amount of range that you experience will vary based on your particular use conditions. See how particular use conditions may affect your
			            range in our simulation model.
			          </p>
			          <p>
			            Vehicle range may vary depending on the vehicle configuration, battery age and condition, driving style and operating, environmental and climate
			            conditions.
			          </p>
			        </div>,
			        container
			      );
			      expect(container.innerHTML).toBe(
			        '<div class="tesla-battery__notice"><p>The actual amount of range that you experience will vary based on your particular use conditions. See how particular use conditions may affect your range in our simulation model.</p><p>Vehicle range may vary depending on the vehicle configuration, battery age and condition, driving style and operating, environmental and climate conditions.</p></div>'
			      );
			    \});
			  \});
			
			  describe('REST Spread JSX', () => \{
			    it('Should render click event, style, className', (done) => \{
			      const TextField = function (props) \{
			        return <input \{...props\} />;
			      \};
			      const MyTextField = (\{ name, className, changeName \}) => (
			        <TextField
			          className=\{className\}
			          value=\{name\}
			          onClick=\{function () \{
			            done();
			          \}\}
			        />
			      );
			
			      render(<MyTextField className="foobar" name="test" />, container);
			
			      expect(container.firstChild.value).toBe('test');
			      expect(container.firstChild.getAttribute('class')).toBe('foobar');
			      container.firstChild.click();
			    \});
			  \});
			
			  if (typeof global !== 'undefined' && !global.usingJSDOM && 'position' in document.createElement('progress')) \{
			    describe('Progress element', () => \{
			      it('Should be possible to change value of Progress element Github#714', () => \{
			        render(<progress max=\{100\} value="10" />, container);
			
			        expect(container.firstChild.getAttribute('value')).toEqual('10');
			
			        render(<progress max=\{100\} value="33" />, container);
			
			        expect(container.firstChild.getAttribute('value')).toEqual('33');
			
			        render(<progress max=\{100\} value=\{'0'\} />, container);
			
			        expect(container.firstChild.getAttribute('value')).toEqual('0');
			      \});
			      it('Should be possible to render Progress element without value', () => \{
			        render(<progress max=\{100\} />, container);
			        expect(container.firstChild.tagName).toEqual('PROGRESS');
			        expect([null, '', 0, '0']).toContain(container.firstChild.getAttribute('value'));
			
			        // Add as string
			        render(<progress max=\{100\} value="3" />, container);
			        expect(container.firstChild.tagName).toEqual('PROGRESS');
			        expect(container.firstChild.getAttribute('value')).toEqual('3');
			      \});
			    \});
			  \}
			
			  describe('Value for components', () => \{
			    it('Should be possible to pass down value prop', () => \{
			      function Foo(\{ value \}) \{
			        return <div>\{value\}</div>;
			      \}
			
			      render(<Foo value="100" />, container);
			
			      expect(container.innerHTML).toEqual('<div>100</div>');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\elements.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(49)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\events.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Basic event tests', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should attach basic click events', (done) => \{
			    const template = (val) =>
			      createElement('div', \{
			        id: 'test',
			        onclick: val
			      \});
			
			    let calledFirstTest = false;
			
			    function test() \{
			      calledFirstTest = true;
			    \}
			
			    // different event
			    let calledSecondTest = false;
			
			    function test2() \{
			      calledSecondTest = true;
			    \}
			
			    render(template(test), container);
			
			    let divs = container.querySelectorAll('div');
			    divs.forEach((div) => div.click());
			    expect(calledFirstTest).toBe(true);
			
			    // reset
			    calledFirstTest = false;
			
			    render(template(test2), container);
			    divs = container.querySelectorAll('div');
			    divs.forEach((div) => div.click());
			
			    expect(calledFirstTest).toBe(false);
			    expect(calledSecondTest).toBe(true);
			
			    // reset
			    calledFirstTest = false;
			    calledSecondTest = false;
			
			    render(null, container);
			    divs = container.querySelectorAll('div');
			    divs.forEach((div) => div.click());
			
			    expect(calledFirstTest).toBe(false);
			    expect(calledSecondTest).toBe(false);
			    done();
			  \});
			
			  it('should update events', () => \{
			    let data = \{
			      count: 0
			    \};
			
			    function onClick(d) \{
			      return function (e) \{
			        data = \{ count: d.count + 1 \};
			
			        renderIt();
			      \};
			    \}
			
			    function App(d) \{
			      return createElement(
			        'button',
			        \{
			          onclick: onClick(d)
			        \},
			        'Count ',
			        d.count
			      );
			    \}
			
			    function renderIt() \{
			      // eslint-disable-next-line
			      render(App(data), container);
			    \}
			
			    renderIt();
			    const buttons = container.querySelectorAll('button');
			
			    expect(container.firstChild.innerHTML).toBe('Count 0');
			    expect(data.count).toBe(0);
			    buttons.forEach((button) => button.click());
			    expect(container.firstChild.innerHTML).toBe('Count 1');
			    expect(data.count).toBe(1);
			    buttons.forEach((button) => button.click());
			    expect(container.firstChild.innerHTML).toBe('Count 2');
			    expect(data.count).toBe(2);
			  \});
			
			  it('should not trigger click at all if target is disabled', () => \{
			    let data = \{
			      count: 0
			    \};
			
			    function onClick(d) \{
			      return function (e) \{
			        data = \{ count: d.count + 1 \};
			
			        renderIt();
			      \};
			    \}
			
			    function App(d) \{
			      return createElement(
			        'button',
			        \{
			          disabled: 'disabled',
			          onClick: onClick(d)
			        \},
			        createElement('span', null, 'Count ', d.count)
			      );
			    \}
			
			    function renderIt() \{
			      // eslint-disable-next-line
			      render(App(data), container);
			    \}
			
			    renderIt();
			    const buttons = container.querySelectorAll('span');
			
			    expect(container.firstChild.innerHTML).toBe('<span>Count 0</span>');
			    expect(data.count).toBe(0);
			    buttons.forEach((button) => button.click());
			    expect(container.firstChild.innerHTML).toBe('<span>Count 0</span>');
			  \});
			
			  it('should not leak memory', () => \{
			    const eventHandler = function () \{\};
			
			    function AppTwo() \{
			      return createElement('button', null, [2]);
			    \}
			
			    function App() \{
			      return createElement(
			        'button',
			        \{
			          onsubmit: eventHandler
			        \},
			        ['1']
			      );
			    \}
			
			    // eslint-disable-next-line
			    render(App(), container);
			    expect(container.firstChild.innerHTML).toBe('1');
			
			    // eslint-disable-next-line
			    render(App(), container);
			    expect(container.firstChild.innerHTML).toBe('1');
			
			    // eslint-disable-next-line
			    render(AppTwo(), container);
			    expect(container.firstChild.innerHTML).toBe('2');
			  \});
			
			  it('should not leak memory #2', () => \{
			    const eventHandler = function () \{\};
			
			    function App(\{ toggle \}) \{
			      return createElement(
			        'button',
			        \{
			          onsubmit: toggle ? eventHandler : null
			        \},
			        ['1']
			      );
			    \}
			
			    // eslint-disable-next-line
			    render(App(\{ toggle: true \}), container);
			    expect(container.firstChild.innerHTML).toBe('1');
			
			    // eslint-disable-next-line
			    render(App(\{ toggle: false \}), container);
			    expect(container.firstChild.innerHTML).toBe('1');
			  \});
			
			  it('should not leak memory when child changes', () => \{
			    const eventHandler = function () \{\};
			
			    function smallComponent() \{
			      return createElement(
			        'div',
			        \{
			          onkeyup: eventHandler
			        \},
			        '2'
			      );
			    \}
			
			    const childrenArray = [smallComponent(), smallComponent(), smallComponent()];
			
			    function AppTwo() \{
			      return createElement('p', null, ['2']);
			    \}
			
			    function App(children) \{
			      return createElement(
			        'p',
			        \{
			          onkeydown: eventHandler
			        \},
			        children.slice(0)
			      );
			    \}
			
			    // eslint-disable-next-line
			    render(App(childrenArray), container);
			    expect(container.innerHTML).toBe('<p><div>2</div><div>2</div><div>2</div></p>');
			
			    childrenArray.pop();
			    // eslint-disable-next-line
			    render(App(childrenArray), container);
			    expect(container.innerHTML).toBe('<p><div>2</div><div>2</div></p>');
			
			    // eslint-disable-next-line
			    render(AppTwo(), container);
			    expect(container.innerHTML).toBe('<p>2</p>');
			  \});
			
			  describe('Event Propagation', () => \{
			    it('Should stop propagating Synthetic event to document', (done) => \{
			      const eventHandlerSpy = jasmine.createSpy('spy');
			      const eventHandler = function (event) \{
			        eventHandlerSpy();
			        event.stopPropagation();
			      \};
			
			      function SmallComponent() \{
			        return createElement(
			          'div',
			          \{
			            onClick: eventHandler,
			            id: 'tester'
			          \},
			          '2'
			        );
			      \}
			
			      render(<SmallComponent />, container);
			
			      const bodySpy = jasmine.createSpy('spy');
			      document.addEventListener('click', bodySpy);
			
			      container.querySelector('#tester').click();
			      setTimeout(function () \{
			        expect(eventHandlerSpy.calls.count()).toBe(1);
			        expect(bodySpy.calls.count()).toBe(0);
			        document.removeEventListener('click', bodySpy);
			        done();
			      \}, 20);
			    \});
			
			    it('Should stop propagating Synthetic event to parentElement with synthetic event', (done) => \{
			      const eventHandlerSpy = jasmine.createSpy('spy');
			      const eventHandler = function (event) \{
			        eventHandlerSpy();
			        event.stopPropagation();
			      \};
			
			      const eventHandlerSpy2 = jasmine.createSpy('spy');
			      const eventHandler2 = function (event) \{
			        eventHandlerSpy2();
			      \};
			
			      function SmallComponent() \{
			        return createElement(
			          'div',
			          \{
			            onClick: eventHandler2,
			            id: 'parent'
			          \},
			          createElement(
			            'div',
			            \{
			              onClick: eventHandler,
			              id: 'tester'
			            \},
			            '2'
			          )
			        );
			      \}
			
			      render(<SmallComponent />, container);
			
			      container.querySelector('#tester').click();
			      setTimeout(function () \{
			        expect(eventHandlerSpy.calls.count()).toBe(1);
			        expect(eventHandlerSpy2.calls.count()).toBe(0);
			        done();
			      \}, 20);
			    \});
			
			    // React does not block propagating synthetic event to parent with normal event either.
			    it('Should NOT stop propagating Synthetic event to parentElement with normal event', (done) => \{
			      const eventHandlerSpy = jasmine.createSpy('spy');
			      const eventHandler = function (event) \{
			        eventHandlerSpy();
			        event.stopPropagation();
			      \};
			
			      const eventHandlerSpy2 = jasmine.createSpy('spy');
			      const eventHandler2 = function (event) \{
			        eventHandlerSpy2();
			      \};
			
			      function SmallComponent() \{
			        return createElement(
			          'div',
			          \{
			            onclick: eventHandler2,
			            id: 'parent'
			          \},
			          createElement(
			            'div',
			            \{
			              onClick: eventHandler,
			              id: 'tester'
			            \},
			            '2'
			          )
			        );
			      \}
			
			      render(<SmallComponent />, container);
			
			      container.querySelector('#tester').click();
			      setTimeout(function () \{
			        expect(eventHandlerSpy.calls.count()).toBe(1);
			        expect(eventHandlerSpy2.calls.count()).toBe(1);
			        done();
			      \}, 20);
			    \});
			
			    // https://github.com/infernojs/inferno/issues/979
			    it('Should trigger child elements synthetic event even if parent Element has null listener', () => \{
			      const spy1 = jasmine.createSpy('spy');
			      const spy2 = jasmine.createSpy('spy');
			
			      function FooBarCom(\{ test \}) \{
			        return (
			          <div onClick=\{test !== '1' ? null : spy1\}>
			            <div onClick=\{null\}>
			              <span onClick=\{spy2\}>test</span>
			            </div>
			          </div>
			        );
			      \}
			
			      render(<FooBarCom test="1" />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(1);
			      expect(spy1.calls.count()).toBe(1);
			
			      render(<FooBarCom test="2" />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(2);
			      expect(spy1.calls.count()).toBe(1);
			
			      render(<FooBarCom test="3" />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(3);
			      expect(spy1.calls.count()).toBe(1);
			    \});
			
			    it('Should remove synthetic listener if patched to null/undef', () => \{
			      const spy1 = jasmine.createSpy('spy');
			      const spy2 = jasmine.createSpy('spy');
			
			      function FooBarCom(\{ test \}) \{
			        return (
			          <div>
			            \{test ? (
			              <div onClick=\{spy1\}>
			                <span onClick=\{spy2\}>test</span>
			              </div>
			            ) : (
			              <div>
			                <span onClick=\{spy2\}>test</span>
			              </div>
			            )\}
			          </div>
			        );
			      \}
			
			      render(<FooBarCom test=\{true\} />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(1);
			      expect(spy1.calls.count()).toBe(1);
			
			      render(<FooBarCom test=\{false\} />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(2);
			      expect(spy1.calls.count()).toBe(1);
			
			      render(<FooBarCom test=\{true\} />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(3);
			      expect(spy1.calls.count()).toBe(2);
			    \});
			
			    it('Should remove native listener if patched to null/undef', () => \{
			      const spy1 = jasmine.createSpy('spy');
			      const spy2 = jasmine.createSpy('spy');
			
			      function FooBarCom(\{ test \}) \{
			        return (
			          <div>
			            \{test ? (
			              <div onclick=\{spy1\}>
			                <span onclick=\{spy2\}>test</span>
			              </div>
			            ) : (
			              <div>
			                <span onclick=\{spy2\}>test</span>
			              </div>
			            )\}
			          </div>
			        );
			      \}
			
			      render(<FooBarCom test=\{true\} />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(1);
			      expect(spy1.calls.count()).toBe(1);
			
			      render(<FooBarCom test=\{false\} />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(2);
			      expect(spy1.calls.count()).toBe(1);
			
			      render(<FooBarCom test=\{true\} />, container);
			      container.querySelector('span').click();
			      expect(spy2.calls.count()).toBe(3);
			      expect(spy1.calls.count()).toBe(2);
			    \});
			
			    it('Should stop propagating normal event to document', () => \{
			      const eventHandlerSpy = jasmine.createSpy('spy');
			      const eventHandler = function (event) \{
			        eventHandlerSpy();
			        event.stopPropagation();
			      \};
			
			      function SmallComponent() \{
			        return createElement(
			          'div',
			          \{
			            onclick: eventHandler,
			            id: 'tester'
			          \},
			          '2'
			        );
			      \}
			
			      render(<SmallComponent />, container);
			      const bodySpy = jasmine.createSpy('spy');
			      document.addEventListener('click', bodySpy);
			
			      container.querySelector('#tester').click();
			
			      expect(eventHandlerSpy.calls.count()).toBe(1);
			      expect(bodySpy.calls.count()).toBe(0);
			      document.removeEventListener('click', bodySpy);
			    \});
			
			    it('Should stop propagating normal event to parentElement with synthetic event', (done) => \{
			      const eventHandlerSpy = jasmine.createSpy('spy');
			      const eventHandler = function (event) \{
			        eventHandlerSpy();
			        event.stopPropagation();
			      \};
			
			      const eventHandlerSpy2 = jasmine.createSpy('spy');
			      const eventHandler2 = function (event) \{
			        eventHandlerSpy2();
			      \};
			
			      function SmallComponent() \{
			        return createElement(
			          'div',
			          \{
			            onClick: eventHandler2,
			            id: 'parent'
			          \},
			          createElement(
			            'div',
			            \{
			              onclick: eventHandler,
			              id: 'tester'
			            \},
			            '2'
			          )
			        );
			      \}
			
			      render(<SmallComponent />, container);
			
			      container.querySelector('#tester').click();
			      setTimeout(function () \{
			        expect(eventHandlerSpy.calls.count()).toBe(1);
			        expect(eventHandlerSpy2.calls.count()).toBe(0);
			        done();
			      \}, 20);
			    \});
			
			    it('Should stop propagating normal event to normal event', (done) => \{
			      const eventHandlerSpy = jasmine.createSpy('spy');
			      const eventHandler = function (event) \{
			        eventHandlerSpy();
			        event.stopPropagation();
			      \};
			
			      const eventHandlerSpy2 = jasmine.createSpy('spy');
			      const eventHandler2 = function () \{
			        eventHandlerSpy2();
			      \};
			
			      function SmallComponent() \{
			        return createElement(
			          'div',
			          \{
			            onclick: eventHandler2,
			            id: 'parent'
			          \},
			          createElement(
			            'div',
			            \{
			              onclick: eventHandler,
			              id: 'tester'
			            \},
			            '2'
			          )
			        );
			      \}
			
			      render(<SmallComponent />, container);
			
			      container.querySelector('#tester').click();
			      setTimeout(function () \{
			        expect(eventHandlerSpy.calls.count()).toBe(1);
			        expect(eventHandlerSpy2.calls.count()).toBe(0);
			        done();
			      \}, 20);
			    \});
			  \});
			
			  it('Should work with spread attributes', (done) => \{
			    function SmallComponent(props) \{
			      return (
			        <div id="testClick" \{...props\}>
			          FooBar
			        </div>
			      );
			    \}
			
			    const obj = \{
			      test: function () \{
			        done();
			      \}
			    \};
			
			    render(<SmallComponent className="testing" onClick=\{obj.test\} />, container);
			
			    container.querySelector('#testClick').click();
			  \});
			
			  it('Synthetic Events - Should not reduce listener count when nothing was removed', () => \{
			    const spy = jasmine.createSpy('spy');
			    const root1 = document.createElement('div');
			    const root2 = document.createElement('div');
			    const root3 = document.createElement('div');
			    const root4 = document.createElement('div');
			
			    document.body.appendChild(root1);
			    document.body.appendChild(root2);
			    document.body.appendChild(root3);
			    document.body.appendChild(root4);
			
			    render(<div onClick=\{spy\} />, root1);
			    render(<div onClick=\{undefined\} />, root2);
			    render(<div onClick=\{void 0\} />, root3);
			    render(<div onClick=\{null\} />, root4);
			
			    root1.firstChild.click();
			    root2.firstChild.click();
			    root3.firstChild.click();
			    root4.firstChild.click();
			
			    expect(spy.calls.count()).toBe(1);
			
			    render(null, root1);
			    render(null, root2);
			    render(null, root3);
			    render(null, root4);
			
			    document.body.removeChild(root1);
			    document.body.removeChild(root2);
			    document.body.removeChild(root3);
			    document.body.removeChild(root4);
			  \});
			
			  describe('currentTarget', () => \{
			    it('Should have currentTarget', (done) => \{
			      function verifyCurrentTarget(event) \{
			        expect(event.currentTarget).toBe(container.firstChild);
			        done();
			      \}
			
			      render(<div onClick=\{verifyCurrentTarget\} />, container);
			
			      container.firstChild.click();
			    \});
			
			    it('Current target should not be the clicked element, but the one with listener', () => \{
			      let called = false;
			
			      function verifyCurrentTarget(event) \{
			        expect(event.currentTarget).toBe(container.firstChild);
			        called = true;
			      \}
			
			      render(
			        <div onClick=\{verifyCurrentTarget\}>
			          <span>test</span>
			        </div>,
			        container
			      );
			
			      container.querySelector('span').click();
			
			      expect(called).toBe(true);
			    \});
			
			    it('Should work with deeply nested tree', (done) => \{
			      function verifyCurrentTarget(event) \{
			        expect(event.currentTarget).toBe(container.querySelector('#test'));
			        done();
			      \}
			
			      render(
			        <div>
			          <div>
			            <div>
			              <div>
			                <div>1</div>
			                <div id="test" onClick=\{verifyCurrentTarget\}>
			                  <div>foo</div>
			                  <span>2</span>
			                </div>
			              </div>
			            </div>
			          </div>
			          <span>test</span>
			        </div>,
			        container
			      );
			
			      container.querySelector('span').click();
			    \});
			
			    it('currentTarget should propagate work with multiple levels of children', (done) => \{
			      function verifyCurrentTarget(event) \{
			        expect(event.currentTarget).toBe(container.querySelector('#test'));
			        done();
			      \}
			
			      render(
			        <div>
			          <div>
			            <div>
			              <div>
			                <div>1</div>
			                <div id="test" onClick=\{verifyCurrentTarget\}>
			                  <div>foo</div>
			                  <div>
			                    <div>
			                      <div>
			                        <div>
			                          <span>test</span>
			                        </div>
			                      </div>
			                    </div>
			                  </div>
			                  <div>1</div>
			                </div>
			              </div>
			            </div>
			          </div>
			          <span>test</span>
			        </div>,
			        container
			      );
			
			      container.querySelector('span').click();
			    \});
			  \});
			
			  describe('Event removal', () => \{
			    it('Should remove events when parent changes', () => \{
			      const spy = jasmine.createSpy('spy');
			      render(
			        <div>
			          <div id="test" onClick=\{spy\}>
			            1
			          </div>
			        </div>,
			        container
			      );
			
			      expect(spy.calls.count()).toBe(0);
			      container.querySelector('#test').click();
			      expect(spy.calls.count()).toBe(1);
			
			      render(
			        <div>
			          <div id="test">2</div>
			        </div>,
			        container
			      );
			
			      container.querySelector('#test').click();
			      expect(spy.calls.count()).toBe(1);
			    \});
			
			    it('Should NOT remove events when listener remains there', () => \{
			      const spy = jasmine.createSpy('spy');
			      render(
			        <div>
			          <div id="test" onClick=\{spy\}>
			            1
			          </div>
			        </div>,
			        container
			      );
			
			      expect(spy.calls.count()).toBe(0);
			      container.querySelector('#test').click();
			      expect(spy.calls.count()).toBe(1);
			
			      render(
			        <div>
			          <div id="test" onClick=\{spy\}>
			            2
			          </div>
			        </div>,
			        container
			      );
			
			      container.querySelector('#test').click();
			      expect(spy.calls.count()).toBe(2);
			    \});
			
			    it('Should remove events when listener is nulled', () => \{
			      const spy = jasmine.createSpy('spy');
			      render(
			        <div>
			          <div id="test" onClick=\{spy\}>
			            1
			          </div>
			        </div>,
			        container
			      );
			
			      expect(spy.calls.count()).toBe(0);
			      container.querySelector('#test').click();
			      expect(spy.calls.count()).toBe(1);
			
			      render(
			        <div>
			          <div id="test" onClick=\{null\}>
			            2
			          </div>
			        </div>,
			        container
			      );
			
			      container.querySelector('#test').click();
			      expect(spy.calls.count()).toBe(1);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\events.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(24)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\hooks.spec.js', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('lifecycle hooks', () => \{
			  describe('Stateless component hooks', () => \{
			    let template;
			    let container;
			    let animationTemplate;
			
			    function StatelessComponent() \{
			      const divTemplate = () => \{
			        return createElement('div', null, 'Hello world!');
			      \};
			      return divTemplate();
			    \}
			
			    afterEach(function () \{
			      render(null, container);
			    \});
			
			    beforeEach(function () \{
			      container = document.createElement('div');
			
			      template =
			        (
			          onComponentWillMount,
			          onComponentDidMount,
			          onComponentWillUnmount,
			          onComponentWillUpdate,
			          onComponentDidUpdate,
			          onComponentShouldUpdate,
			          StatelessComponent
			        ) =>
			        (props) => \{
			          return createElement(
			            StatelessComponent,
			            \{
			              onComponentWillMount,
			              onComponentDidMount,
			              onComponentWillUnmount,
			              onComponentWillUpdate,
			              onComponentDidUpdate,
			              onComponentShouldUpdate,
			              ...props
			            \},
			            null
			          );
			        \};
			
			      animationTemplate = (onComponentDidAppear, onComponentWillDisappear, StatelessComponent) => (props) => \{
			        return createElement(
			          StatelessComponent,
			          \{
			            onComponentDidAppear,
			            onComponentWillDisappear,
			            ...props
			          \},
			          null
			        );
			      \};
			    \});
			
			    it('"onComponentWillMount" hook should fire, args props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      const node = template(spyObj.fn, null, null, null, null, null, StatelessComponent)(\{ a: 1 \});
			      render(node, container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(1);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1, children: null \});
			    \});
			
			    it('"onComponentDidMount" hook should fire, args DOM props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      const node = template(null, spyObj.fn, null, null, null, null, StatelessComponent)(\{ a: 1 \});
			      render(node, container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toBe(container.firstChild);
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 1, children: null \});
			    \});
			
			    it('"onComponentWillUnmount" hook should fire, args DOM props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      const node = template(null, null, spyObj.fn, null, null, null, StatelessComponent)(\{ a: 1 \});
			      render(node, container);
			      expect(spy.calls.count()).toBe(0);
			      // do unmount
			      render(null, container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0].outerHTML).toBe('<div>Hello world!</div>');
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 1, children: null \});
			    \});
			
			    it('"onComponentWillUpdate" hook should fire, args props nextProps', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      const t = template(null, null, null, spyObj.fn, null, null, StatelessComponent);
			
			      const node1 = t(\{ a: 1 \});
			      render(node1, container);
			      expect(spy.calls.count()).toBe(0);
			
			      const node2 = t(\{ a: 2 \});
			      render(node2, container);
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1, children: null \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2, children: null \});
			    \});
			
			    it('"onComponentDidUpdate" hook should fire, args prevProps props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      const t = template(null, null, null, null, spyObj.fn, null, StatelessComponent);
			
			      const node1 = t(\{ a: 1 \});
			      render(node1, container);
			      expect(spy.calls.count()).toBe(0); // Update 1
			
			      const node2 = t(\{ a: 2 \});
			      render(node2, container);
			      expect(spy.calls.count()).toBe(1); // Update 2
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1, children: null \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2, children: null \});
			    \});
			
			    it('"onComponentShouldUpdate" hook should fire, should call render when return true, args props nextProps', () => \{
			      let onComponentShouldUpdateCount = 0;
			      let renderCount = 0;
			      const spyObj = \{
			        fn: () => \{
			          onComponentShouldUpdateCount++;
			          return true;
			        \}
			      \};
			      const spy = spyOn(spyObj, 'fn').and.callThrough();
			      const StatelessComponent = () => \{
			        renderCount++;
			        return null;
			      \};
			      const t = template(null, null, null, null, null, spyObj.fn, StatelessComponent);
			
			      const node1 = t(\{ a: 1 \});
			      render(node1, container);
			      expect(onComponentShouldUpdateCount).toBe(0); // Update 1
			      expect(renderCount).toBe(1); // Rendered 1 time
			
			      const node2 = t(\{ a: 2 \});
			      render(node2, container);
			      expect(onComponentShouldUpdateCount).toBe(1); // Update 2
			      expect(renderCount).toBe(2); // Rendered 2 time
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1, children: null \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2, children: null \});
			    \});
			
			    it('"onComponentShouldUpdate" hook should fire, should not call render when return false, args props nextProps', () => \{
			      let onComponentShouldUpdateCount = 0;
			      let renderCount = 0;
			      const spyObj = \{
			        fn: () => \{
			          onComponentShouldUpdateCount++;
			          return false;
			        \}
			      \};
			      const spy = spyOn(spyObj, 'fn').and.callThrough();
			      const StatelessComponent = () => \{
			        renderCount++;
			        return null;
			      \};
			      const t = template(null, null, null, null, null, spyObj.fn, StatelessComponent);
			
			      const node1 = t(\{ a: 1 \});
			      render(node1, container);
			      expect(onComponentShouldUpdateCount).toBe(0); // Update 1
			      expect(renderCount).toBe(1); // Rendered 1 time
			
			      const node2 = t(\{ a: 2 \});
			      render(node2, container);
			      expect(onComponentShouldUpdateCount).toBe(1); // Update 2
			      expect(renderCount).toBe(1); // Rendered 1 time
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0]).toEqual(\{ a: 1, children: null \});
			      expect(spy.calls.argsFor(0)[1]).toEqual(\{ a: 2, children: null \});
			    \});
			
			    it('"onComponentDidAppear" hook should fire, args dom props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			
			      const spy = spyOn(spyObj, 'fn');
			      const t = animationTemplate(spyObj.fn, null, StatelessComponent);
			
			      const node1 = t(\{ a: 1 \});
			      render(node1, container);
			      expect(spy.calls.count()).toBe(1); // Update 1
			      expect(spy.calls.argsFor(0).length).toBe(2);
			      expect(spy.calls.argsFor(0)[0] instanceof HTMLDivElement).toEqual(true);
			      expect(typeof spy.calls.argsFor(0)[1] === 'object').toEqual(true);
			
			      const node2 = t(\{ a: 2 \});
			      render(node2, container);
			      expect(spy.calls.count()).toBe(1); // Update 2 (shouldn't trigger animation)
			    \});
			
			    it('"onComponentWillDisappear" hook should fire, args dom props', () => \{
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			
			      const spy = spyOn(spyObj, 'fn');
			      const t = animationTemplate(null, spyObj.fn, StatelessComponent);
			
			      const node1 = t(\{ a: 1 \});
			      render(node1, container);
			      render(null, container);
			
			      expect(spy.calls.count()).toBe(1); // animation triggers on remove
			      expect(spy.calls.argsFor(0).length).toBe(3);
			      expect(spy.calls.argsFor(0)[0] instanceof HTMLDivElement).toEqual(true);
			      expect(typeof spy.calls.argsFor(0)[1] === 'object').toEqual(true);
			      expect(typeof spy.calls.argsFor(0)[2] === 'function').toEqual(true);
			    \});
			  \});
			
			  describe('Class Component hooks', function () \{
			    it('Should trigger ref callback when component is mounting and unmounting', () => \{
			      const container = document.createElement('div');
			      class FooBar extends Component \{
			        render() \{
			          return createElement('div');
			        \}
			      \}
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      const node = createElement(FooBar, \{ ref: spyObj.fn \});
			
			      render(node, container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(1);
			      expect(spy.calls.argsFor(0)[0]).not.toEqual(null);
			
			      render(null, container);
			
			      expect(spy.calls.count()).toBe(2);
			      expect(spy.calls.argsFor(1).length).toBe(1);
			      expect(spy.calls.argsFor(1)[0]).toEqual(null);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\hooks.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(10)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patching.spec.js', () => {
        const sourceCode = `
			import \{ Component, createFragment, render, rerender \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('patching keyed lists (non-jsx)', () => \{
			  function createDataModels() \{
			    const dataModels = [];
			
			    dataModels.push(addGroupSingleChild(500));
			    dataModels.push(addGroupSingleChild(400));
			    dataModels.push(addGroupSingleChild(5));
			    dataModels.push(addGroupSingleChild(50));
			    dataModels.push(addGroupSingleChild(300));
			    dataModels.push(addGroupSingleChild(0));
			
			    return dataModels;
			  \}
			
			  function addGroupSingleChild(count) \{
			    const dataModel = [];
			    for (let i = 0; i < count; i++) \{
			      dataModel.push(\{
			        key: i,
			        children: null
			      \});
			    \}
			    return dataModel;
			  \}
			
			  function shuffle(dataModel) \{
			    for (let e, t, n = dataModel.length; n !== 0; ) \{
			      e = Math.floor(Math.random() * n--);
			      t = dataModel[n];
			      dataModel[n] = dataModel[e];
			      dataModel[e] = t;
			    \}
			  \}
			
			  function createExpectedChildren(nodes) \{
			    const children = [];
			    let i, e, n;
			
			    for (i = 0; i < nodes.length; i++) \{
			      n = nodes[i];
			      if (n.children !== null) \{
			        e = document.createElement('div');
			        render(n.children, e);
			        // This code is here to make typescript happy... lol
			        for (let a = 0; a < e.children.length; a++) \{
			          children.push(e.children[a]);
			        \}
			        // We could just return e.children, but that conflicts with typescript types...
			        return children;
			      \} else \{
			        e = document.createElement('span');
			        e.textContent = n.key.toString();
			        children.push(e);
			      \}
			    \}
			
			    return children;
			  \}
			
			  function createExpected(nodes) \{
			    const c = document.createElement('div');
			    const e = document.createElement('div');
			    const children = createExpectedChildren(nodes);
			    for (let i = 0; i < children.length; i++) \{
			      e.appendChild(children[i]);
			    \}
			    c.appendChild(e);
			    return c.innerHTML;
			  \}
			
			  const container = document.createElement('div');
			  let dataModels = null;
			
			  beforeEach(function () \{
			    dataModels = createDataModels();
			  \});
			
			  afterEach(function () \{
			    dataModels = null;
			  \});
			
			  function renderTree(nodes) \{
			    const children = new Array(nodes.length);
			    let i;
			    let n;
			
			    for (i = 0; i < nodes.length; i++) \{
			      n = nodes[i];
			      if (n.children !== null) \{
			        children[i] = createElement('div', \{ key: n.key \}, renderTree(n.children));
			      \} else \{
			        children[i] = createElement('span', \{ key: n.key \}, n.key);
			      \}
			    \}
			    return children;
			  \}
			
			  function renderModel(dataModel) \{
			    render(createElement('div', null, renderTree(dataModel)), container);
			  \}
			
			  it('should render various combinations', () => \{
			    let dataModel = dataModels[0];
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    dataModel = dataModels[0];
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    dataModel = dataModels[3];
			    dataModel.reverse();
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[0];
			    dataModel.reverse();
			    render(null, container);
			
			    dataModel = dataModels[0];
			    dataModel.reverse();
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[1];
			    dataModel.reverse();
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[3];
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[1];
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[4];
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[2];
			    dataModel.reverse();
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[3];
			    dataModel.reverse();
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			
			    dataModel = dataModels[1];
			    shuffle(dataModel);
			
			    renderModel(dataModel);
			
			    expect(container.innerHTML).toBe(createExpected(dataModel));
			
			    render(null, container);
			  \});
			
			  it('Portal content should stay within its own portal - Github #1421', () => \{
			    const f = (...xs) => createFragment(xs, 0);
			
			    class App extends Component \{
			      constructor() \{
			        super();
			        this.state = \{ ids: [] \};
			      \}
			
			      componentDidMount() \{
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><p>Not found</p><button>Create</button><footer>2018</footer></div>');
			
			        this.setState(\{ ids: ['test'] \});
			        rerender();
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><h2>test</h2><footer>2018</footer></div>');
			
			        this.setState(\{ ids: [] \});
			        rerender();
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><p>Not found</p><button>Create</button><footer>2018</footer></div>'); // Fails too, when skipping the previous assertion.
			      \}
			
			      render() \{
			        const \{ ids \} = this.state;
			        return f(
			          createElement('h1', null, 'App'),
			          f(
			            ids.length ? ids.map((id) => createElement('h2', null, id)) : createElement('p', null, 'Not found'),
			            !ids.length && createElement('button', null, 'Create') // Same condition for simple example.
			          ),
			          createElement('footer', null, '2018')
			        );
			      \}
			    \}
			
			    render(createElement(App), container);
			  \});
			
			  it('Portal content should stay within its own portal - Github #1421 - variation 2', () => \{
			    const f = (...xs) => createFragment(xs, 0);
			
			    class App extends Component \{
			      constructor() \{
			        super();
			        this.state = \{ ids: [] \};
			      \}
			
			      componentDidMount() \{
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><p>Not found</p><button>Create</button><footer>2018</footer></div>');
			
			        this.setState(\{ ids: ['test', 'test2'] \});
			        rerender();
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><h2>test</h2><h2>test2</h2><footer>2018</footer></div>');
			
			        this.setState(\{ ids: [] \});
			        rerender();
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><p>Not found</p><button>Create</button><footer>2018</footer></div>'); // Fails too, when skipping the previous assertion.
			      \}
			
			      render() \{
			        const \{ ids \} = this.state;
			        return f(
			          createElement('h1', null, 'App'),
			          f(
			            ids.length ? ids.map((id) => createElement('h2', null, id)) : createElement('p', null, 'Not found'),
			            !ids.length && createElement('button', null, 'Create') // Same condition for simple example.
			          ),
			          createElement('footer', null, '2018')
			        );
			      \}
			    \}
			
			    render(createElement(App), container);
			  \});
			
			  it('Portal content should stay within its own portal - Github #1421 - variation 3', () => \{
			    const f = (...xs) => createFragment(xs, 0);
			
			    class App extends Component \{
			      constructor() \{
			        super();
			        this.state = \{ ids: [] \};
			      \}
			
			      componentDidMount() \{
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><p>Not found</p><button>Create</button><footer>2018</footer></div>');
			
			        this.setState(\{ ids: ['test', 'test2', 'test3'] \});
			        rerender();
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><h2>test</h2><h2>test2</h2><h2>test3</h2><footer>2018</footer></div>');
			
			        this.setState(\{ ids: [] \});
			        rerender();
			        expect(container.outerHTML).toEqual('<div><h1>App</h1><p>Not found</p><button>Create</button><footer>2018</footer></div>'); // Fails too, when skipping the previous assertion.
			      \}
			
			      render() \{
			        const \{ ids \} = this.state;
			        return f(
			          createElement('h1', null, 'App'),
			          f(
			            ids.length ? ids.map((id) => createElement('h2', null, id)) : createElement('p', null, 'Not found'),
			            !ids.length && createElement('button', null, 'Create') // Same condition for simple example.
			          ),
			          createElement('footer', null, '2018')
			        );
			      \}
			    \}
			
			    render(createElement(App), container);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patching.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patchKeyedChildren.spec.js', () => {
        const sourceCode = `
			import \{ createTextVNode, createVNode, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			import \{ ChildFlags, VNodeFlags \} from 'inferno-vnode-flags';
			
			function generateKeyNodes(array) \{
			  let i, id, key;
			  const children = [];
			  let newKey;
			
			  for (i = 0; i < array.length; i++) \{
			    id = key = array[i];
			    if (key !== null && (typeof key !== 'string' || key[0] !== '#')) \{
			      newKey = key;
			    \} else \{
			      newKey = null;
			    \}
			
			    children.push(
			      createElement(
			        'div',
			        \{
			          key: newKey,
			          id: String(id)
			        \},
			        id
			      )
			    );
			  \}
			  return children;
			\}
			
			describe('keyed-nodes', () => \{
			  let container;
			
			  const template = function (child) \{
			    return createElement('div', null, child);
			  \};
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should add all nodes', () => \{
			    render(template(generateKeyNodes([])), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'])), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should remove two keys at the beginning', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['c'])), container);
			    expect(container.textContent).toBe('c');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should size up', () => \{
			    render(template(generateKeyNodes(['#0', '#1'])), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'])), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should size down', () => \{
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1'])), container);
			    expect(container.textContent).toBe('#0#1');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1'])), container);
			    expect(container.textContent).toBe('#0#1');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			
			  it('should clear all nodes', () => \{
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes([])), container);
			    expect(container.textContent).toBe('');
			    expect(container.firstChild.childNodes.length).toBe(0);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes([])), container);
			  \});
			
			  it('should work with mixed nodes', () => \{
			    render(template(generateKeyNodes(['1', '#0', '#1', '#2'])), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3'])), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key for start to end', () => \{
			    render(template(generateKeyNodes(['a', '#0', '#1', '#2'])), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', 'a'])), container);
			    expect(container.textContent).toBe('#0#1#2a');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key', () => \{
			    render(template(generateKeyNodes(['#0', 'a', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1', 'a', '#3'])), container);
			    expect(container.textContent).toBe('#0#1a#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key with a size up', () => \{
			    render(template(generateKeyNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			  it('should move a key with a size down', () => \{
			    render(template(generateKeyNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should avoid unnecessary reordering', () => \{
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should work with keyed nodes', () => \{
			    render(template(generateKeyNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateKeyNodes([1, 2, 3, 4, 0])), container);
			    expect(container.textContent).toBe('12340');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should reorder keys', () => \{
			    render(template(generateKeyNodes(['1', '2', '3', '4', 'abc', '6', 'def', '7'])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			  \});
			  it('should remove one key at the start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['b', 'c'])), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should do a complex reverse', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateKeyNodes(['d', 'c', 'b', 'a'])), container);
			    expect(container.textContent).toBe('dcba');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should remove two keys at the start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['c'])), container);
			    expect(container.textContent).toBe('c');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key to start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should add two key to start', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['c'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove one key at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should remove two keys at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    render(template(generateKeyNodes(['a'])), container);
			    expect(container.textContent).toBe('a');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key at the end', () => \{
			    render(template(generateKeyNodes(['a', 'b'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add two key at the end', () => \{
			    render(template(generateKeyNodes(['a'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add to end, delete from center & reverse', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateKeyNodes(['e', 'd', 'c', 'a'])), container);
			    expect(container.textContent).toBe('edca');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should add to the beginning and remove', () => \{
			    render(template(generateKeyNodes(['c', 'd'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'e'])), container);
			    expect(container.textContent).toBe('abce');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should keep a central pivot', () => \{
			    render(template(generateKeyNodes(['1', '2', '3'])), container);
			    render(template(generateKeyNodes(['4', '2', '5'])), container);
			    expect(container.textContent).toBe('425');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should insert to the middle', () => \{
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['a', 'b', 'e'])), container);
			    expect(container.textContent).toBe('abe');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['c', 'd', 'e'])), container);
			    render(template(generateKeyNodes(['a', 'p', 'e'])), container);
			    expect(container.textContent).toBe('ape');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should shuffle, insert and remove', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 'e', 'f', 'g'])), container);
			    render(template(generateKeyNodes(['b', 'c', 'a'])), container);
			    expect(container.textContent).toBe('bca');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove a element from the middle', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([1, 2, 4, 5])), container);
			    expect(container.textContent).toBe('1245');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a element forward', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([2, 3, 1, 4])), container);
			    expect(container.textContent).toBe('2314');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([3, 2, 1, 4])), container);
			    expect(container.textContent).toBe('3214');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([3, 2, 4, 1])), container);
			    expect(container.textContent).toBe('3241');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should move a element to the end', () => \{
			    render(template(generateKeyNodes([1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes([2, 3, 1])), container);
			    expect(container.textContent).toBe('231');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should move a element backwards', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([1, 4, 2, 3])), container);
			    expect(container.textContent).toBe('1423');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should swap first and last', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([4, 2, 3, 1])), container);
			    expect(container.textContent).toBe('4231');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should move to left and replace', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([4, 1, 2, 3, 6])), container);
			    expect(container.textContent).toBe('41236');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateKeyNodes([4, 5, 2, 3, 0])), container);
			    expect(container.textContent).toBe('45230');
			    render(template(generateKeyNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			  \});
			
			  it('should move to left and leave a hole', () => \{
			    render(template(generateKeyNodes([1, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateKeyNodes([4, 6])), container);
			    expect(container.textContent).toBe('46');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should do something', () => \{
			    render(template(generateKeyNodes([0, 1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateKeyNodes([4, 3, 2, 1, 5, 0])), container);
			    expect(container.textContent).toBe('432150');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			
			  it('should cycle order correctly', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			    render(template(generateKeyNodes([2, 3, 4, 1])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('2341');
			    render(template(generateKeyNodes([3, 4, 1, 2])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('3412');
			    render(template(generateKeyNodes([4, 1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('4123');
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			  \});
			
			  it('should cycle order correctly in the other direction', () => \{
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			    render(template(generateKeyNodes([4, 1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('4123');
			    render(template(generateKeyNodes([3, 4, 1, 2])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('3412');
			    render(template(generateKeyNodes([2, 3, 4, 1])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('2341');
			    render(template(generateKeyNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    expect(container.textContent).toBe('1234');
			  \});
			
			  it('should allow any character as a key', () => \{
			    render(template(generateKeyNodes(['<WEIRD/&\\\\key>'])), container);
			    render(template(generateKeyNodes(['INSANE/(/&\\\\key', '<CRAZY/&\\\\key>', '<WEIRD/&\\\\key>'])), container);
			    expect(container.textContent).toBe('INSANE/(/&\\\\key<CRAZY/&\\\\key><WEIRD/&\\\\key>');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			
			  it('should reorder nodes', () => \{
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['1', '2', '3', '4', 'abc', '6', 'def', '7'])), container);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			    render(template(generateKeyNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			  \});
			
			  it('should do a advanced shuffle - numbers and letters', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([1, 'e', 2, 'b', 'f', 'g', 'c', 'a', 3])), container);
			    expect(container.textContent).toBe('1e2bfgca3');
			    expect(container.firstChild.childNodes.length).toBe(9);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([0, 'e', 2, 'b', 'f', 'g', 'c', 'a', 4])), container);
			    expect(container.textContent).toBe('0e2bfgca4');
			    expect(container.firstChild.childNodes.length).toBe(9);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd', 1, 2, 3])), container);
			    expect(container.textContent).toBe('abcd123');
			    expect(container.firstChild.childNodes.length).toBe(7);
			    render(template(generateKeyNodes([1, 'e', 2, 'b', 'f', 'g', 'c', 'a', 3])), container);
			    expect(container.textContent).toBe('1e2bfgca3');
			    expect(container.firstChild.childNodes.length).toBe(9);
			  \});
			
			  it('should do a complex removal at the beginning', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['c', 'd'])), container);
			    expect(container.textContent).toBe('cd');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should do move and sync nodes from right to left', () => \{
			    render(template(generateKeyNodes(['a', 'b', 'c', 'd'])), container);
			    expect(container.textContent).toBe('abcd');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateKeyNodes(['c', 'l', 1, 2, 3, 4, 5, 6, 7, 8, 9, 'd', 'g', 'b'])), container);
			    expect(container.textContent).toBe('cl123456789dgb');
			    expect(container.firstChild.childNodes.length).toBe(14);
			  \});
			
			  describe('Should handle massive large arrays', () => \{
			    let items;
			
			    beforeEach(function () \{
			      items = new Array(1000);
			      for (let i = 0; i < 1000; i++) \{
			        items[i] = i;
			      \}
			    \});
			
			    it('Should handle massive large arrays - initial', () => \{
			      render(template(generateKeyNodes(items)), container);
			
			      expect(container.textContent).toEqual(items.join(''));
			    \});
			
			    it('Should handle massive arrays shifting once by 2', () => \{
			      items = items.concat(items.splice(0, 2));
			      render(template(generateKeyNodes(items)), container);
			
			      expect(container.textContent).toEqual(items.join(''));
			    \});
			
			    for (let i = 0; i < 10; i++) \{
			      // eslint-disable-next-line
			      it('Should handle massive arrays shifting ' + i + ' times by ' + i, () => \{
			        for (let j = 0; j < i; j++) \{
			          items = items.concat(items.splice(i, j));
			        \}
			        render(template(generateKeyNodes(items)), container);
			        expect(container.textContent).toEqual(items.join(''));
			      \});
			    \}
			  \});
			
			  describe('Calendar like layout', () => \{
			    function o(text) \{
			      return createElement(
			        'span',
			        \{
			          key: 'o' + text
			        \},
			        ',o' + text
			      );
			    \}
			
			    function d(text) \{
			      return createElement(
			        'span',
			        \{
			          key: 'd' + text
			        \},
			        ',d' + text
			      );
			    \}
			
			    function wk(text) \{
			      return createElement(
			        'span',
			        \{
			          key: 'wk' + text
			        \},
			        ',wk' + text
			      );
			    \}
			
			    it('Should do complex suffle without duplications', () => \{
			      const layout1 = [
			        wk(31),
			        d(1),
			        d(2),
			        d(3),
			        d(4),
			        d(5),
			        d(6),
			        d(7),
			        wk(32),
			        d(8),
			        d(9),
			        d(10),
			        d(11),
			        d(12),
			        d(13),
			        d(14),
			        wk(33),
			        d(15),
			        d(16),
			        d(17),
			        d(18),
			        d(19),
			        d(20),
			        d(21),
			        wk(34),
			        d(22),
			        d(23),
			        d(24),
			        d(25),
			        d(26),
			        d(27),
			        d(28),
			        wk(35),
			        d(29),
			        d(30),
			        d(31),
			        o(1),
			        o(2),
			        o(3),
			        o(4),
			        wk(36),
			        o(5),
			        o(6),
			        o(7),
			        o(8),
			        o(9),
			        o(10),
			        o(11)
			      ];
			      render(template(layout1), container);
			
			      expect(container.textContent).toBe(
			        ',wk31,d1,d2,d3,d4,d5,d6,d7,wk32,d8,d9,d10,d11,d12,d13,d14,wk33,d15,d16,d17,d18,d19,d20,d21,wk34,d22,d23,d24,d25,d26,d27,d28,wk35,d29,d30,d31,o1,o2,o3,o4,wk36,o5,o6,o7,o8,o9,o10,o11'
			      );
			
			      const layout2 = [
			        wk(35),
			        o(29),
			        o(30),
			        o(31),
			        d(1),
			        d(2),
			        d(3),
			        d(4),
			        wk(36),
			        d(5),
			        d(6),
			        d(7),
			        d(8),
			        d(9),
			        d(10),
			        d(11),
			        wk(37),
			        d(12),
			        d(13),
			        d(14),
			        d(15),
			        d(16),
			        d(17),
			        d(18),
			        wk(38),
			        d(19),
			        d(20),
			        d(21),
			        d(22),
			        d(23),
			        d(24),
			        d(25),
			        wk(39),
			        d(26),
			        d(27),
			        d(28),
			        d(29),
			        d(30),
			        o(1),
			        o(2),
			        wk(40),
			        o(3),
			        o(4),
			        o(5),
			        o(6),
			        o(7),
			        o(8),
			        o(9)
			      ];
			      render(template(layout2), container);
			
			      expect(container.textContent).toBe(
			        ',wk35,o29,o30,o31,d1,d2,d3,d4,wk36,d5,d6,d7,d8,d9,d10,d11,wk37,d12,d13,d14,d15,d16,d17,d18,wk38,d19,d20,d21,d22,d23,d24,d25,wk39,d26,d27,d28,d29,d30,o1,o2,wk40,o3,o4,o5,o6,o7,o8,o9'
			      );
			    \});
			  \});
			
			  // VDom tests ported from Kivi - credits: https://github.com/localvoid
			  // https://github.com/localvoid/kivi/blob/master/tests/vdom.spec.ts
			  describe('children', () => \{
			    const TESTS = [
			      [[0], [0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]],
			      [
			        [0, 1, 2],
			        [0, 1, 2],
			        [0, 0, 0, 0, 0, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			
			      [[], [1], [0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0]],
			      [[], [4, 9], [0, 0, 2, 0, 2, 0, 0], [0, 0, 2, 0, 2, 0, 0]],
			      [[], [9, 3, 6, 1, 0], [0, 0, 5, 0, 5, 0, 0], [0, 0, 5, 0, 5, 0, 0]],
			
			      [[999], [1], [0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0]],
			      [[999], [1, 999], [0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0]],
			      [[999], [999, 1], [0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0]],
			      [[999], [4, 9, 999], [0, 0, 2, 0, 2, 0, 0], [0, 0, 2, 0, 2, 0, 0]],
			      [[999], [999, 4, 9], [0, 0, 2, 0, 2, 0, 0], [0, 0, 2, 0, 2, 0, 0]],
			      [[999], [9, 3, 6, 1, 0, 999], [0, 0, 5, 0, 5, 0, 0], [0, 0, 5, 0, 5, 0, 0]],
			      [[999], [999, 9, 3, 6, 1, 0], [0, 0, 5, 0, 5, 0, 0], [0, 0, 5, 0, 5, 0, 0]],
			      [[999], [0, 999, 1], [0, 0, 2, 0, 2, 0, 0], [0, 0, 2, 0, 2, 0, 0]],
			      [[999], [0, 3, 999, 1, 4], [0, 0, 4, 0, 4, 0, 0], [0, 0, 4, 0, 4, 0, 0]],
			      [[999], [0, 999, 1, 4, 5], [0, 0, 4, 0, 4, 0, 0], [0, 0, 4, 0, 4, 0, 0]],
			
			      [
			        [998, 999],
			        [1, 998, 999],
			        [0, 0, 1, 0, 1, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [998, 999],
			        [998, 999, 1],
			        [0, 0, 1, 0, 1, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [998, 999],
			        [998, 1, 999],
			        [0, 0, 1, 0, 1, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [998, 999],
			        [1, 2, 998, 999],
			        [0, 0, 2, 0, 2, 0, 0],
			        [0, 0, 2, 0, 2, 0, 0]
			      ],
			      [
			        [998, 999],
			        [998, 999, 1, 2],
			        [0, 0, 2, 0, 2, 0, 0],
			        [0, 0, 2, 0, 2, 0, 0]
			      ],
			      [
			        [998, 999],
			        [1, 998, 999, 2],
			        [0, 0, 2, 0, 2, 0, 0],
			        [0, 0, 2, 0, 2, 0, 0]
			      ],
			      [
			        [998, 999],
			        [1, 998, 2, 999, 3],
			        [0, 0, 3, 0, 3, 0, 0],
			        [0, 0, 3, 0, 3, 0, 0]
			      ],
			      [
			        [998, 999],
			        [1, 4, 998, 2, 5, 999, 3, 6],
			        [0, 0, 6, 0, 6, 0, 0],
			        [0, 0, 6, 0, 6, 0, 0]
			      ],
			      [
			        [998, 999],
			        [1, 998, 2, 999],
			        [0, 0, 2, 0, 2, 0, 0],
			        [0, 0, 2, 0, 2, 0, 0]
			      ],
			      [
			        [998, 999],
			        [998, 1, 999, 2],
			        [0, 0, 2, 0, 2, 0, 0],
			        [0, 0, 2, 0, 2, 0, 0]
			      ],
			      [
			        [998, 999],
			        [1, 2, 998, 3, 4, 999],
			        [0, 0, 4, 0, 4, 0, 0],
			        [0, 0, 4, 0, 4, 0, 0]
			      ],
			      [
			        [998, 999],
			        [998, 1, 2, 999, 3, 4],
			        [0, 0, 4, 0, 4, 0, 0],
			        [0, 0, 4, 0, 4, 0, 0]
			      ],
			      [
			        [998, 999],
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 998, 999],
			        [0, 0, 10, 0, 10, 0, 0],
			        [0, 0, 10, 0, 10, 0, 0]
			      ],
			      [
			        [998, 999],
			        [998, 999, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [0, 0, 10, 0, 10, 0, 0],
			        [0, 0, 10, 0, 10, 0, 0]
			      ],
			      [
			        [998, 999],
			        [0, 1, 2, 3, 4, 998, 999, 5, 6, 7, 8, 9],
			        [0, 0, 10, 0, 10, 0, 0],
			        [0, 0, 10, 0, 10, 0, 0]
			      ],
			      [
			        [998, 999],
			        [0, 1, 2, 998, 3, 4, 5, 6, 999, 7, 8, 9],
			        [0, 0, 10, 0, 10, 0, 0],
			        [0, 0, 10, 0, 10, 0, 0]
			      ],
			      [
			        [998, 999],
			        [0, 1, 2, 3, 4, 998, 5, 6, 7, 8, 9, 999],
			        [0, 0, 10, 0, 10, 0, 0],
			        [0, 0, 10, 0, 10, 0, 0]
			      ],
			      [
			        [998, 999],
			        [998, 0, 1, 2, 3, 4, 999, 5, 6, 7, 8, 9],
			        [0, 0, 10, 0, 10, 0, 0],
			        [0, 0, 10, 0, 10, 0, 0]
			      ],
			
			      [[1], [], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]],
			      [[1, 2], [2], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1]],
			      [[1, 2], [1], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1]],
			      [
			        [1, 2, 3],
			        [2, 3],
			        [0, 0, 0, 0, 0, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [1, 2, 3],
			        [1, 2],
			        [0, 0, 0, 0, 0, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [1, 2, 3],
			        [1, 3],
			        [0, 0, 0, 0, 0, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [1, 2, 3, 4, 5],
			        [2, 3, 4, 5],
			        [0, 0, 0, 0, 0, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [1, 2, 3, 4, 5],
			        [1, 2, 3, 4],
			        [0, 0, 0, 0, 0, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [1, 2, 3, 4, 5],
			        [1, 2, 4, 5],
			        [0, 0, 0, 0, 0, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			
			      [[1, 2], [], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]],
			      [[1, 2, 3], [3], [0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 2]],
			      [[1, 2, 3], [1], [0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 2]],
			      [
			        [1, 2, 3, 4],
			        [3, 4],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [1, 2, 3, 4],
			        [1, 2],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [1, 2, 3, 4],
			        [1, 4],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [1, 2, 3, 4, 5, 6],
			        [2, 3, 4, 5],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [1, 2, 3, 4, 5, 6],
			        [2, 3, 5, 6],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [1, 2, 3, 4, 5, 6],
			        [1, 2, 3, 5],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [2, 3, 4, 5, 6, 7, 8, 9],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [0, 1, 2, 3, 4, 5, 6, 7],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [1, 2, 3, 4, 6, 7, 8, 9],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [0, 1, 2, 3, 4, 6, 7, 8],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [0, 1, 2, 4, 6, 7, 8, 9],
			        [0, 0, 0, 0, 0, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			
			      [
			        [0, 1],
			        [1, 0],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3],
			        [3, 2, 1, 0],
			        [0, 0, 0, 0, 3, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [1, 2, 3, 4, 0],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [4, 0, 1, 2, 3],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [1, 0, 2, 3, 4],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [2, 0, 1, 3, 4],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [0, 1, 4, 2, 3],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [0, 1, 3, 4, 2],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [0, 1, 3, 2, 4],
			        [0, 0, 0, 0, 1, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6],
			        [2, 1, 0, 3, 4, 5, 6],
			        [0, 0, 0, 0, 2, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6],
			        [0, 3, 4, 1, 2, 5, 6],
			        [0, 0, 0, 0, 2, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6],
			        [0, 2, 3, 5, 6, 1, 4],
			        [0, 0, 0, 0, 2, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6],
			        [0, 1, 5, 3, 2, 4, 6],
			        [0, 0, 0, 0, 2, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [8, 1, 3, 4, 5, 6, 0, 7, 2, 9],
			        [0, 0, 0, 0, 3, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
			        [9, 5, 0, 7, 1, 2, 3, 4, 6, 8],
			        [0, 0, 0, 0, 3, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			
			      [
			        [0, 1],
			        [2, 1, 0],
			        [0, 0, 1, 0, 2, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [0, 1],
			        [1, 0, 2],
			        [0, 0, 1, 0, 2, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [0, 1, 2],
			        [3, 0, 2, 1],
			        [0, 0, 1, 0, 2, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [0, 1, 2],
			        [0, 2, 1, 3],
			        [0, 0, 1, 0, 2, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [0, 1, 2],
			        [0, 2, 3, 1],
			        [0, 0, 1, 0, 2, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [0, 1, 2],
			        [1, 2, 3, 0],
			        [0, 0, 1, 0, 2, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [5, 4, 3, 2, 1, 0],
			        [0, 0, 1, 0, 5, 0, 0],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [5, 4, 3, 6, 2, 1, 0],
			        [0, 0, 2, 0, 6, 0, 0],
			        [0, 0, 2, 0, 2, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4],
			        [5, 4, 3, 6, 2, 1, 0, 7],
			        [0, 0, 3, 0, 7, 0, 0],
			        [0, 0, 3, 0, 3, 0, 0]
			      ],
			
			      [
			        [0, 1, 2],
			        [1, 0],
			        [0, 0, 0, 0, 1, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [2, 0, 1],
			        [1, 0],
			        [0, 0, 0, 0, 1, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [7, 0, 1, 8, 2, 3, 4, 5, 9],
			        [7, 5, 4, 8, 3, 2, 1, 0],
			        [0, 0, 0, 0, 5, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [7, 0, 1, 8, 2, 3, 4, 5, 9],
			        [5, 4, 8, 3, 2, 1, 0, 9],
			        [0, 0, 0, 0, 5, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [7, 0, 1, 8, 2, 3, 4, 5, 9],
			        [7, 5, 4, 3, 2, 1, 0, 9],
			        [0, 0, 0, 0, 5, 0, 1],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [7, 0, 1, 8, 2, 3, 4, 5, 9],
			        [5, 4, 3, 2, 1, 0, 9],
			        [0, 0, 0, 0, 5, 0, 2],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			      [
			        [7, 0, 1, 8, 2, 3, 4, 5, 9],
			        [5, 4, 3, 2, 1, 0],
			        [0, 0, 0, 0, 5, 0, 3],
			        [0, 0, 0, 0, 0, 0, 3]
			      ],
			
			      [[0], [1], [0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0]],
			      [[0], [1, 2], [0, 0, 2, 0, 2, 0, 0], [0, 0, 1, 0, 1, 0, 0]],
			      [[0, 2], [1], [0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1]],
			      [
			        [0, 2],
			        [1, 2],
			        [0, 0, 1, 0, 1, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 2],
			        [2, 1],
			        [0, 0, 1, 0, 2, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2],
			        [3, 4, 5],
			        [0, 0, 3, 0, 3, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2],
			        [2, 4, 5],
			        [0, 0, 2, 0, 3, 0, 2],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5],
			        [6, 7, 8, 9, 10, 11],
			        [0, 0, 6, 0, 6, 0, 0],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5],
			        [6, 1, 7, 3, 4, 8],
			        [0, 0, 3, 0, 3, 0, 3],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5],
			        [6, 7, 3, 8],
			        [0, 0, 3, 0, 3, 0, 5],
			        [0, 0, 0, 0, 0, 0, 2]
			      ],
			
			      [
			        [0, 1, 2],
			        [3, 2, 1],
			        [0, 0, 1, 0, 2, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2],
			        [2, 1, 3],
			        [0, 0, 1, 0, 3, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [1, 2, 0],
			        [2, 1, 3],
			        [0, 0, 1, 0, 2, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [1, 2, 0],
			        [3, 2, 1],
			        [0, 0, 1, 0, 3, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5],
			        [6, 1, 3, 2, 4, 7],
			        [0, 0, 2, 0, 3, 0, 2],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5],
			        [6, 1, 7, 3, 2, 4],
			        [0, 0, 2, 0, 3, 0, 2],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			      [
			        [0, 1, 2, 3, 4, 5],
			        [6, 7, 3, 2, 4],
			        [0, 0, 2, 0, 3, 0, 3],
			        [0, 0, 0, 0, 0, 0, 1]
			      ],
			      [
			        [0, 2, 3, 4, 5],
			        [6, 1, 7, 3, 2, 4],
			        [0, 0, 3, 0, 4, 0, 2],
			        [0, 0, 1, 0, 1, 0, 0]
			      ],
			
			      [[\{ key: 0, children: [0] \}], [\{ key: 0, children: [] \}], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]],
			
			      [[0, 1, \{ children: [0], key: 2 \}], [\{ key: 2, children: [] \}], [0, 0, 0, 0, 0, 0, 2], [1, 0, 0, 0, 0, 1, 2]],
			
			      [[\{ key: 0, children: [] \}], [1, 2, \{ key: 0, children: [0] \}], [0, 0, 3, 0, 3, 0, 0], [1, 0, 3, 0, 3, 1, 0]],
			
			      [
			        [0, \{ key: 1, children: [0, 1] \}, 2],
			        [3, 2, \{ key: 1, children: [1, 0] \}],
			        [0, 0, 1, 0, 3, 0, 1],
			        [1, 0, 3, 0, 2, 2, 0]
			      ],
			
			      [
			        [0, \{ key: 1, children: [0, 1] \}, 2],
			        [2, \{ key: 1, children: [1, 0] \}, 3],
			        [0, 0, 1, 0, 4, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			
			      [
			        [\{ key: 1, children: [0, 1] \}, \{ key: 2, children: [0, 1] \}, 0],
			        [\{ key: 2, children: [1, 0] \}, \{ key: 1, children: [1, 0] \}, 3],
			        [0, 0, 1, 0, 4, 0, 1],
			        [0, 0, 0, 0, 0, 0, 0]
			      ],
			
			      [
			        [\{ key: 1, children: [0, 1] \}, \{ key: 2, children: [] \}, 0],
			        [3, \{ key: 2, children: [1, 0] \}, \{ key: 1, children: [] \}],
			        [0, 0, 3, 0, 5, 0, 1],
			        [1, 0, 3, 0, 2, 2, 0]
			      ],
			
			      [
			        [0, \{ key: 1, children: [] \}, 2, \{ key: 3, children: [1, 0] \}, 4, 5],
			        [6, \{ key: 1, children: [0, 1] \}, \{ key: 3, children: [] \}, 2, 4, 7],
			        [0, 0, 4, 0, 5, 0, 2],
			        [1, 0, 3, 0, 2, 2, 0]
			      ],
			
			      [
			        [0, \{ key: 1, children: [] \}, \{ key: 2, children: [] \}, \{ key: 3, children: [] \}, \{ key: 4, children: [] \}, 5],
			        [\{ key: 6, children: [\{ key: 1, children: [1] \}] \}, 7, \{ key: 3, children: [1] \}, \{ key: 2, children: [1] \}, \{ key: 4, children: [1] \}],
			        [2, 0, 5, 0, 8, 0, 3],
			        [2, 0, 5, 0, 5, 2, 1]
			      ],
			
			      [
			        [0, 1, \{ key: 2, children: [0] \}, 3, \{ key: 4, children: [0] \}, 5],
			        [6, 7, 3, \{ key: 2, children: [] \}, \{ key: 4, children: [] \}],
			        [0, 0, 2, 0, 3, 0, 3],
			        [1, 0, 1, 0, 0, 2, 1]
			      ]
			    ];
			
			    describe('syncChildren string children', () => \{
			      it("null => 'abc'", () => \{
			        const f = document.createDocumentFragment();
			        const a = createElement('div', null);
			        const b = createElement('div', null, 'abc');
			        render(a, f);
			        render(b, f);
			        expect(f.firstChild.childNodes.length).toBe(1);
			        expect(f.firstChild.firstChild.nodeValue).toBe('abc');
			      \});
			
			      it("'abc' => null", () => \{
			        const f = document.createDocumentFragment();
			        const a = createElement('div', null, 'abc');
			        const b = createElement('div', null);
			        render(a, f);
			        render(b, f);
			        expect(f.firstChild.childNodes.length).toBe(0);
			      \});
			
			      it("'abc' => 'cde'", () => \{
			        const f = document.createDocumentFragment();
			        const a = createElement('div', null, 'abc');
			        const b = createElement('div', null, 'cde');
			        render(a, f);
			        render(b, f);
			        expect(f.firstChild.childNodes.length).toBe(1);
			        expect(f.firstChild.firstChild.nodeValue).toBe('cde');
			      \});
			
			      it("[ div ] => 'cde'", () => \{
			        const f = document.createDocumentFragment();
			        const a = createElement('div', null, createElement('div', null));
			        const b = createElement('div', null, 'cde');
			        render(a, f);
			        render(b, f);
			        expect(f.firstChild.childNodes.length).toBe(1);
			        expect(f.firstChild.firstChild.nodeValue).toBe('cde');
			      \});
			
			      it("'cde' => [ div ]", () => \{
			        const f = document.createDocumentFragment();
			        const a = createElement('div', null, 'cde');
			        const b = createElement('div', null, createElement('div', null));
			        render(a, f);
			        render(b, f);
			        expect(f.firstChild.childNodes.length).toBe(1);
			        expect(f.firstChild.firstChild.tagName).toBe('DIV');
			      \});
			
			      function gen(item, keys) \{
			        if (typeof item === 'number') \{
			          return keys
			            ? createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode(item), ChildFlags.HasVNodeChildren, null, item)
			            : createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode(item), ChildFlags.HasVNodeChildren);
			        \} else if (Array.isArray(item)) \{
			          const result = [];
			          for (let i = 0; i < item.length; i++) \{
			            result.push(gen(item[i], keys));
			          \}
			          return result;
			        \} else \{
			          if (keys) \{
			            return createElement('div', \{ key: item.key \}, gen(item.children, keys));
			          \} else \{
			            return createElement('div', null, gen(item.children, keys));
			          \}
			        \}
			      \}
			
			      function checkInnerHtmlEquals(ax, bx, cx, keys) \{
			        let a, b, c;
			
			        if (keys) \{
			          a = createElement('div', \{ key: ax \}, ax);
			          b = createElement('div', \{ key: bx \}, bx);
			          c = createElement('div', \{ key: cx \}, cx);
			        \} else \{
			          a = createElement('div', null, ax);
			          b = createElement('div', null, bx);
			          c = createElement('div', null, cx);
			        \}
			
			        const aDiv = document.createElement('div');
			        const bDiv = document.createElement('div');
			        render(a, aDiv);
			        render(b, bDiv);
			
			        render(c, aDiv);
			
			        expect(aDiv.innerHTML).toBe(bDiv.innerHTML);
			      \}
			
			      describe('Keyed algorithm', () => \{
			        TESTS.forEach((t) => \{
			          const name = JSON.stringify(t[0]) + ' => ' + JSON.stringify(t[1]);
			          const testFn = () => \{
			            checkInnerHtmlEquals(gen(t[0], true), gen(t[1], true), gen(t[1], true), true);
			          \};
			          it(name, testFn);
			        \});
			      \});
			
			      describe('Non keyed algorithm', () => \{
			        TESTS.forEach((t) => \{
			          const name = JSON.stringify(t[0]) + ' => ' + JSON.stringify(t[1]);
			          const testFn = () => \{
			            checkInnerHtmlEquals(gen(t[0], false), gen(t[1], false), gen(t[1], false), false);
			          \};
			          it(name, testFn);
			        \});
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patchKeyedChildren.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(53)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patchMixedKeyed.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			function spanTagWithText(text) \{
			  return createElement(
			    'span',
			    \{
			      className: 'TableCell'
			    \},
			    text
			  );
			\}
			
			function spanTagWithKeyAndText(key, text) \{
			  return createElement(
			    'span',
			    \{
			      className: 'TableCell',
			      key
			    \},
			    text
			  );
			\}
			
			const template = function (child) \{
			  return createElement('div', null, child);
			\};
			
			describe('Mixed of Keyed/Non-Keyed nodes', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  // TOOD: Is mixin keyed non keyed supported this way?
			  it('should remove two keyed nodes, and move a non-key child node', () => \{
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c')]), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c'), spanTagWithText('c')]), container);
			    expect(container.textContent).toBe('abcc');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c')]), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c'), spanTagWithText('c')]), container);
			    expect(container.textContent).toBe('abcc');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(
			      template([spanTagWithKeyAndText('a', 'a'), null, spanTagWithKeyAndText('b', 'b'), undefined, spanTagWithKeyAndText('e', 'c'), spanTagWithText('c')]),
			      container
			    );
			    expect(container.textContent).toBe('abcc');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(
			      template([spanTagWithKeyAndText('a', 'a'), null, spanTagWithKeyAndText('b', 'b'), undefined, spanTagWithKeyAndText('e', 'c'), spanTagWithText('c')]),
			      container
			    );
			    expect(container.textContent).toBe('abcc');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c')]), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			
			  it('should swap the last child and add three non-key children', () => \{
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b')]), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c'), spanTagWithKeyAndText('e', 'a'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bcac');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b')]), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			
			  it('should swap, and a keyed child at the end, and add one non-key child', () => \{
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithKeyAndText('e', 'a'), spanTagWithKeyAndText('f', 'c'), spanTagWithText('c')]), container);
			    expect(container.textContent).toBe('bacc');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), null, spanTagWithKeyAndText('b', 'b')]), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithKeyAndText('e', 'a'), spanTagWithKeyAndText('f', 'c'), spanTagWithText('c')]), container);
			    expect(container.textContent).toBe('bacc');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(
			      template([spanTagWithKeyAndText('d', 'b'), undefined, spanTagWithKeyAndText('e', 'a'), spanTagWithKeyAndText('f', 'c'), spanTagWithText('c')]),
			      container
			    );
			    expect(container.textContent).toBe('bacc');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b')]), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			
			  it('should insert keyed nodes where the last key is a non-keyed node', () => \{
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('f', 'b')]), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(
			      template([
			        spanTagWithKeyAndText('a', 'c'),
			        spanTagWithKeyAndText('e', 'c'),
			        spanTagWithKeyAndText('d', 'b'),
			        spanTagWithKeyAndText('e2', 'b'),
			        spanTagWithText('g')
			      ]),
			      container
			    );
			    expect(container.textContent).toBe('ccbbg');
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('f', 'b')]), container);
			    expect(container.textContent).toBe('ab');
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('f', 'b')]), container);
			    expect(container.textContent).toBe('ab');
			  \});
			
			  it('should remove the first keyed node child, and add two non-key child nodes', () => \{
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template([spanTagWithKeyAndText('a', 'a'), spanTagWithKeyAndText('b', 'b'), spanTagWithKeyAndText('e', 'c')]), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template([spanTagWithKeyAndText('d', 'b'), spanTagWithText('c1'), spanTagWithText('c2'), spanTagWithKeyAndText('f', 'c')]), container);
			    expect(container.textContent).toBe('bc1c2c');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patchMixedKeyed.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patchNonKeyedChildren.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			function generateNodes(array) \{
			  let i, id;
			  const children = [];
			
			  for (i = 0; i < array.length; i++) \{
			    id = array[i];
			
			    children.push(createElement('div', \{ key: String(id) \}, id));
			  \}
			  return children;
			\}
			
			function spanTagWithText(text) \{
			  return createElement(
			    'span',
			    \{
			      className: 'TableCell'
			    \},
			    text
			  );
			\}
			
			describe('Non Keyed nodes', () => \{
			  let container;
			
			  const template = function (child) \{
			    return createElement('div', null, child);
			  \};
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should add all nodes', () => \{
			    render(template(generateNodes([])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3'])), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should remove two keys at the beginning', () => \{
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    render(template(generateNodes(['c'])), container);
			    expect(container.textContent).toBe('c');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should size up', () => \{
			    render(template(generateNodes(['#0', '#1'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3'])), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should size down', () => \{
			    render(template(generateNodes(['#0', '#1', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', '#1'])), container);
			    expect(container.textContent).toBe('#0#1');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should clear all nodes', () => \{
			    render(template(generateNodes(['#0', '#1', '#2', '#3'])), container);
			    render(template(generateNodes([])), container);
			    expect(container.textContent).toBe('');
			    expect(container.firstChild.childNodes.length).toBe(0);
			  \});
			  it('should work with mixed nodes', () => \{
			    render(template(generateNodes(['1', '#0', '#1', '#2'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3'])), container);
			    expect(container.textContent).toBe('#0#1#2#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key for start to end', () => \{
			    render(template(generateNodes(['a', '#0', '#1', '#2'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', 'a'])), container);
			    expect(container.textContent).toBe('#0#1#2a');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key', () => \{
			    render(template(generateNodes(['#0', 'a', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', '#1', 'a', '#3'])), container);
			    expect(container.textContent).toBe('#0#1a#3');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a key with a size up', () => \{
			    render(template(generateNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateNodes(['a', '#1', '#2', '#4'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#4', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#4a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', '#1', '#2', '#3', 'a', '#5'])), container);
			    expect(container.textContent).toBe('#0#1#2#3a#5');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			
			  it('should move a key with a size down', () => \{
			    render(template(generateNodes(['a', '#1', '#2', '#3'])), container);
			    render(template(generateNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should avoid unnecessary reordering', () => \{
			    render(template(generateNodes(['#0', 'a', '#2'])), container);
			    render(template(generateNodes(['#0', 'a', '#2'])), container);
			    expect(container.textContent).toBe('#0a#2');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should work with keyed nodes', () => \{
			    render(template(generateNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateNodes([1, 2, 3, 4, 0])), container);
			    expect(container.textContent).toBe('12340');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateNodes([0, 1, 2, 3, 4])), container);
			    render(template(generateNodes([1, 7, 3, 4, 5])), container); // this originally had duplicate keys!
			    expect(container.textContent).toBe('17345');
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateNodes([1, 2, 3, 4, 0])), container);
			    expect(container.textContent).toBe('12340');
			  \});
			
			  it('should reorder keys', () => \{
			    render(template(generateNodes(['1', '2', '3', '4', 'abc', '6', 'def', '7'])), container);
			    render(template(generateNodes(['7', '4', '3', '2', '6', 'abc', 'def', '1'])), container);
			    expect(container.textContent).toBe('74326abcdef1');
			    expect(container.firstChild.childNodes.length).toBe(8);
			  \});
			  it('should remove one key at the start', () => \{
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    render(template(generateNodes(['b', 'c'])), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    render(template(generateNodes(['b', 'c'])), container);
			    expect(container.textContent).toBe('bc');
			    expect(container.firstChild.childNodes.length).toBe(2);
			    render(template(generateNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateNodes(['d', 'c', 'b', 'a'])), container);
			    expect(container.textContent).toBe('dcba');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should do a complex reverse', () => \{
			    render(template(generateNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateNodes(['d', 'c', 'b', 'a'])), container);
			    expect(container.textContent).toBe('dcba');
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    render(template(generateNodes([0])), container);
			    expect(container.textContent).toBe('0');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    render(template(generateNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateNodes(['d', 'c', 'b', 'a'])), container);
			    expect(container.textContent).toBe('dcba');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			
			  it('should remove two keys at the start', () => \{
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    render(template(generateNodes(['c'])), container);
			    expect(container.textContent).toBe('c');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key to start', () => \{
			    render(template(generateNodes(['a', 'b'])), container);
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add two key to start', () => \{
			    render(template(generateNodes(['c'])), container);
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove one key at the end', () => \{
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    render(template(generateNodes(['a', 'b'])), container);
			    expect(container.textContent).toBe('ab');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should remove two keys at the end', () => \{
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    render(template(generateNodes(['a'])), container);
			    expect(container.textContent).toBe('a');
			    expect(container.firstChild.childNodes.length).toBe(1);
			  \});
			  it('should add one key at the end', () => \{
			    render(template(generateNodes(['a', 'b'])), container);
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add two key at the end', () => \{
			    render(template(generateNodes(['a'])), container);
			    render(template(generateNodes(['a', 'b', 'c'])), container);
			    expect(container.textContent).toBe('abc');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should add to end, delete from center & reverse', () => \{
			    render(template(generateNodes(['a', 'b', 'c', 'd'])), container);
			    render(template(generateNodes(['e', 'd', 'c', 'a'])), container);
			    expect(container.textContent).toBe('edca');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should add to the beginning and remove', () => \{
			    render(template(generateNodes(['c', 'd'])), container);
			    render(template(generateNodes(['a', 'b', 'c', 'e'])), container);
			    expect(container.textContent).toBe('abce');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should keep a central pivot', () => \{
			    render(template(generateNodes(['1', '2', '3'])), container);
			    render(template(generateNodes(['4', '2', '5'])), container);
			    expect(container.textContent).toBe('425');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should insert to the middle', () => \{
			    render(template(generateNodes(['c', 'd', 'e'])), container);
			    render(template(generateNodes(['a', 'b', 'e'])), container);
			    expect(container.textContent).toBe('abe');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should shuffle, insert and remove', () => \{
			    render(template(generateNodes(['a', 'b', 'c', 'd', 'e', 'f', 'g'])), container);
			    render(template(generateNodes(['b', 'c', 'a'])), container);
			    expect(container.textContent).toBe('bca');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should remove a element from the middle', () => \{
			    render(template(generateNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateNodes([1, 2, 4, 5])), container);
			    expect(container.textContent).toBe('1245');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a element forward', () => \{
			    render(template(generateNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateNodes([2, 3, 1, 4])), container);
			    expect(container.textContent).toBe('2314');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move a element to the end', () => \{
			    render(template(generateNodes([1, 2, 3])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateNodes([2, 3, 1])), container);
			    expect(container.textContent).toBe('231');
			    expect(container.firstChild.childNodes.length).toBe(3);
			  \});
			  it('should move a element backwards', () => \{
			    render(template(generateNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateNodes([1, 4, 2, 3])), container);
			    expect(container.textContent).toBe('1423');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should swap first and last', () => \{
			    render(template(generateNodes([1, 2, 3, 4])), container);
			    expect(container.firstChild.childNodes.length).toBe(4);
			    render(template(generateNodes([4, 2, 3, 1])), container);
			    expect(container.textContent).toBe('4231');
			    expect(container.firstChild.childNodes.length).toBe(4);
			  \});
			  it('should move to left and replace', () => \{
			    render(template(generateNodes([1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(5);
			    render(template(generateNodes([4, 1, 2, 3, 6])), container);
			    expect(container.textContent).toBe('41236');
			    expect(container.firstChild.childNodes.length).toBe(5);
			  \});
			  it('should move to left and leave a hole', () => \{
			    render(template(generateNodes([1, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(3);
			    render(template(generateNodes([4, 6])), container);
			    expect(container.textContent).toBe('46');
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			  it('should do something', () => \{
			    render(template(generateNodes([0, 1, 2, 3, 4, 5])), container);
			    expect(container.firstChild.childNodes.length).toBe(6);
			    render(template(generateNodes([4, 3, 2, 1, 5, 0])), container);
			    expect(container.textContent).toBe('432150');
			    expect(container.firstChild.childNodes.length).toBe(6);
			  \});
			
			  describe('Without blueprints', () => \{
			    it('should swap two non-keyed children', () => \{
			      render(template([spanTagWithText('a'), [], spanTagWithText('b')]), container);
			      expect(container.textContent).toBe('ab');
			      render(template([spanTagWithText('b'), null, spanTagWithText('a')]), container);
			      expect(container.textContent).toBe('ba');
			    \});
			
			    it('should do a complex move of non-keyed to the beginning', () => \{
			      render(
			        template([
			          spanTagWithText('x'),
			          spanTagWithText('y'),
			          spanTagWithText('a'),
			          spanTagWithText('b'),
			          spanTagWithText('d'),
			          spanTagWithText('c'),
			          spanTagWithText('v'),
			          spanTagWithText('w')
			        ]),
			        container
			      );
			      expect(container.textContent).toBe('xyabdcvw');
			      expect(container.firstChild.childNodes.length).toBe(8);
			      render(
			        template([
			          spanTagWithText('y'),
			          spanTagWithText('x'),
			          spanTagWithText('a'),
			          spanTagWithText('d2'),
			          spanTagWithText('f'),
			          spanTagWithText('g'),
			          spanTagWithText('w'),
			          spanTagWithText('v')
			        ]),
			        container
			      );
			      expect(container.textContent).toBe('yxad2fgwv');
			      expect(container.firstChild.childNodes.length).toBe(8);
			      render(
			        template([
			          spanTagWithText('x'),
			          spanTagWithText('y'),
			          spanTagWithText('a'),
			          spanTagWithText('b'),
			          spanTagWithText('d'),
			          spanTagWithText('c'),
			          spanTagWithText('v'),
			          spanTagWithText('w')
			        ]),
			        container
			      );
			      expect(container.textContent).toBe('xyabdcvw');
			      expect(container.firstChild.childNodes.length).toBe(8);
			      render(
			        template([
			          spanTagWithText('y'),
			          spanTagWithText('x'),
			          undefined,
			          spanTagWithText('a'),
			          spanTagWithText('d2'),
			          spanTagWithText('f'),
			          spanTagWithText('g'),
			          spanTagWithText('w'),
			          spanTagWithText('v')
			        ]),
			        container
			      );
			      expect(container.textContent).toBe('yxad2fgwv');
			      expect(container.firstChild.childNodes.length).toBe(8);
			    \});
			
			    it('should do a advanced shuffle', () => \{
			      render(template([spanTagWithText('a'), spanTagWithText('b'), spanTagWithText('c'), spanTagWithText('d')]), container);
			      expect(container.textContent).toBe('abcd');
			      expect(container.firstChild.childNodes.length).toBe(4);
			      render(
			        template([spanTagWithText('e'), spanTagWithText('b'), spanTagWithText('f'), spanTagWithText('g'), spanTagWithText('c'), spanTagWithText('a')]),
			        container
			      );
			      expect(container.textContent).toBe('ebfgca');
			      expect(container.firstChild.childNodes.length).toBe(6);
			      render(template([spanTagWithText('a'), spanTagWithText('6'), null, spanTagWithText('c'), spanTagWithText('d')]), container);
			      expect(container.textContent).toBe('a6cd');
			      expect(container.firstChild.childNodes.length).toBe(4);
			      render(
			        template([spanTagWithText('e'), spanTagWithText('b'), spanTagWithText('f'), spanTagWithText('g'), spanTagWithText('c'), spanTagWithText('a')]),
			        container
			      );
			      expect(container.textContent).toBe('ebfgca');
			      expect(container.firstChild.childNodes.length).toBe(6);
			      render(template([spanTagWithText('a'), spanTagWithText('b'), undefined, spanTagWithText('c'), spanTagWithText('d')]), container);
			      expect(container.textContent).toBe('abcd');
			      expect(container.firstChild.childNodes.length).toBe(4);
			      render(
			        template([spanTagWithText('e'), spanTagWithText('b'), spanTagWithText('f'), spanTagWithText('g'), spanTagWithText('c'), spanTagWithText('a')]),
			        container
			      );
			      expect(container.textContent).toBe('ebfgca');
			      expect(container.firstChild.childNodes.length).toBe(6);
			    \});
			
			    it('should do a complex reverse #2', () => \{
			      render(template([spanTagWithText('#0'), spanTagWithText('#1'), spanTagWithText('#2')]), container);
			      render(template([spanTagWithText('#2'), spanTagWithText('#1'), spanTagWithText('#0')]), container);
			      expect(container.textContent).toBe('#2#1#0');
			      expect(container.firstChild.childNodes.length).toBe(3);
			      render(template([spanTagWithText('#2'), spanTagWithText('#1'), spanTagWithText('#0')]), container);
			      expect(container.textContent).toBe('#2#1#0');
			      expect(container.firstChild.childNodes.length).toBe(3);
			      render(template([spanTagWithText('#2'), spanTagWithText('#1'), null, null, null, spanTagWithText('#0')]), container);
			      expect(container.textContent).toBe('#2#1#0');
			      expect(container.firstChild.childNodes.length).toBe(3);
			      render(template([spanTagWithText('#2'), spanTagWithText('#1'), spanTagWithText('#4')]), container);
			      expect(container.textContent).toBe('#2#1#4');
			      expect(container.firstChild.childNodes.length).toBe(3);
			    \});
			
			    it('should add to end, delete from center & reverse #2', () => \{
			      render(template([spanTagWithText('a'), spanTagWithText('b'), spanTagWithText('c'), spanTagWithText('d')]), container);
			      render(template([spanTagWithText('e'), spanTagWithText('d'), spanTagWithText('c'), spanTagWithText('a')]), container);
			      expect(container.textContent).toBe('edca');
			      expect(container.firstChild.childNodes.length).toBe(4);
			      render(template([spanTagWithText('#2'), spanTagWithText('#1'), spanTagWithText('#0')]), container);
			      expect(container.textContent).toBe('#2#1#0');
			      expect(container.firstChild.childNodes.length).toBe(3);
			      render(template([spanTagWithText('#2'), spanTagWithText('#1'), spanTagWithText('#4')]), container);
			      expect(container.textContent).toBe('#2#1#4');
			      expect(container.firstChild.childNodes.length).toBe(3);
			      render(template([spanTagWithText('a'), spanTagWithText('b'), spanTagWithText('c'), spanTagWithText('d')]), container);
			      render(template([spanTagWithText('e'), spanTagWithText('d'), spanTagWithText('c'), spanTagWithText('a')]), container);
			      expect(container.textContent).toBe('edca');
			      expect(container.firstChild.childNodes.length).toBe(4);
			    \});
			
			    it('should insert to the middle #2', () => \{
			      render(template([spanTagWithText('c'), spanTagWithText('d'), spanTagWithText('e')]), container);
			      expect(container.textContent).toBe('cde');
			      expect(container.firstChild.childNodes.length).toBe(3);
			      render(template([spanTagWithText('a'), spanTagWithText('b'), spanTagWithText('e')]), container);
			      expect(container.textContent).toBe('abe');
			      expect(container.firstChild.childNodes.length).toBe(3);
			      render(template([spanTagWithText('c'), spanTagWithText('d'), null, null, null, spanTagWithText('e')]), container);
			      expect(container.textContent).toBe('cde');
			      expect(container.firstChild.childNodes.length).toBe(3);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\patchNonKeyedChildren.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(41)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\select.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Select / select multiple (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('should render "select" boolean on select options with numbers', () => \{
			    const template = (val) =>
			      createElement(
			        'select',
			        \{
			          multiple: true,
			          value: val
			        \},
			        createElement(
			          'option',
			          \{
			            value: 1
			          \},
			          1
			        ),
			        createElement(
			          'option',
			          \{
			            value: 2
			          \},
			          2
			        )
			      );
			
			    render(template(null), container);
			    render(template(), container);
			    render(template(2), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="1">1</option><option value="2">2</option></select>');
			
			    render(template(1), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="1">1</option><option value="2">2</option></select>');
			
			    render(template('foo'), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="1">1</option><option value="2">2</option></select>');
			  \});
			
			  // it('should render "select" boolean on select options #1 browser', () => \{
			  //
			  // 	const template = (val) => createElement('select', \{
			  // 		multiple: true,
			  // 		value: val
			  // 	\}, createElement('option', \{
			  // 		value: 'foo'
			  // 	\}, 'foo'), createElement('option', \{
			  // 		value: 'bar'
			  // 	\}, 'bar'));
			  //
			  // 	render(template(\{\}), container);
			  // 	render(template(null), container);
			  // 	render(template(undefined), container);
			  // 	render(template('foo'), container);
			  // 	expect(container.firstChild.children[ 0 ].selected).to.eql(true);
			  // 	expect(container.firstChild.children[ 1 ].selected).to.eql(false);
			  // 	expect(
			  // 		container.innerHTML
			  // 	).toEqual(
			  // 		('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>')
			  // 	);
			  // 	render(template(undefined), container);
			  // 	render(template(null), container);
			  // 	expect(container.firstChild.children[ 0 ].selected).to.eql(false);
			  // 	expect(container.firstChild.children[ 1 ].selected).to.eql(false);
			  // 	expect(
			  // 		container.innerHTML
			  // 	).toEqual(
			  // 		('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>')
			  // 	);
			  //
			  // 	render(template('bar'), container);
			  // 	expect(container.firstChild.children[ 0 ].selected).to.eql(false);
			  // 	expect(container.firstChild.children[ 1 ].selected).to.eql(true);
			  // 	expect(
			  // 		container.innerHTML
			  // 	).toEqual(
			  // 		('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>')
			  // 	);
			  // \});
			
			  it('should render "select" boolean on select options #2 browser', () => \{
			    const template = (val) =>
			      createElement(
			        'select',
			        \{
			          multiple: true,
			          value: val
			        \},
			        createElement(
			          'option',
			          \{
			            value: 'foo'
			          \},
			          'foo'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'bar'
			          \},
			          'bar'
			        )
			      );
			
			    render(template('foo'), container);
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      // Missing selected markup
			      '<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>'
			    );
			  \});
			
			  it('should populate the value attribute on select multiple using groups', () => \{
			    const template = (val) =>
			      createElement(
			        'select',
			        \{
			          multiple: true,
			          value: val
			        \},
			        createElement('optgroup', \{ label: 'foo-group' \}, createElement('option', \{ value: 'foo' \})),
			        createElement('optgroup', \{ label: 'bar-group', disabled: true \}, createElement('option', \{ value: 'bar' \}))
			      );
			
			    // render(template(undefined), container);
			    render(template(['foo', 'bar']), container);
			
			    expect(container.firstChild.children[0].disabled).toEqual(false);
			    expect(container.firstChild.children[1].disabled).toEqual(true);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(true);
			
			    render(template([]), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			
			    render(template('foo'), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			
			    render(template('bar'), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(true);
			
			    render(template(false), container);
			
			    expect(container.firstChild.childNodes[0].innerHTML).toEqual('<option value="foo"></option>');
			    expect(container.firstChild.childNodes[1].innerHTML).toEqual('<option value="bar"></option>');
			
			    expect(container.firstChild.children[0].children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].children[0].selected).toEqual(false);
			  \});
			
			  it('should render "select" boolean on select options #3 browser', () => \{
			    const template = (val) =>
			      createElement(
			        'select',
			        \{
			          multiple: true,
			          value: val
			        \},
			        createElement(
			          'option',
			          \{
			            value: 'foo'
			          \},
			          'foo'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'bar'
			          \},
			          'bar'
			        )
			      );
			
			    render(template('bar'), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>');
			
			    render(template(''), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(false);
			    expect(container.innerHTML).toBe('<select multiple=""><option value="foo">foo</option><option value="bar">bar</option></select>');
			  \});
			
			  it('should assure a \`textarea\` with no value should show no value', () => \{
			    render(createElement('textarea', null), container);
			    expect(container.firstChild.value).toEqual('');
			  \});
			
			  it('should assure the value attribute also set the value property for \`textarea\`', () => \{
			    const template = (val) =>
			      createElement('textarea', \{
			        value: val
			      \});
			
			    render(template('foo'), container);
			    expect(container.firstChild.value).toEqual('foo');
			    render(template('bar'), container);
			    expect(container.firstChild.value).toEqual('bar');
			    render(template('bar'), container);
			    expect(container.firstChild.value).toEqual('bar');
			    render(template('foo'), container);
			    expect(container.firstChild.value).toEqual('foo');
			    render(template(null), container);
			    expect(container.firstChild.value).toEqual('');
			    render(template(undefined), container);
			    expect(container.firstChild.value).toEqual('');
			    render(template('bar'), container);
			    expect(container.firstChild.value).toEqual('bar');
			    render(template([]), container);
			    expect(container.firstChild.value).toEqual('');
			    render(template(\{\}), container);
			    expect(container.firstChild.value).toEqual('[object Object]');
			  \});
			
			  it('should handle when multiple values passed in as an array', () => \{
			    const template = (val) =>
			      createElement(
			        'select',
			        \{
			          multiple: true,
			          value: val
			        \},
			        createElement(
			          'option',
			          \{
			            value: 'a'
			          \},
			          'a'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'b'
			          \},
			          'b'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'c'
			          \},
			          'c'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'd'
			          \},
			          'd'
			        )
			      );
			    render(template(['a', 'b', 'c']), container);
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(true);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select multiple=""><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('should handle when multiple options with selected set', () => \{
			    const template = () =>
			      createElement(
			        'select',
			        \{
			          multiple: true
			        \},
			        createElement(
			          'option',
			          \{
			            value: 'a',
			            selected: true
			          \},
			          'a'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'b',
			            selected: true
			          \},
			          'b'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'c',
			            selected: true
			          \},
			          'c'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'd'
			          \},
			          'd'
			        )
			      );
			    render(template(), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(true);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select multiple=""><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('should render defaultValue', () => \{
			    const template = () =>
			      createElement(
			        'select',
			        \{
			          defaultValue: 'b'
			        \},
			        createElement(
			          'option',
			          \{
			            value: 'a'
			          \},
			          'a'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'b'
			          \},
			          'b'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'c'
			          \},
			          'c'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'd'
			          \},
			          'd'
			        )
			      );
			    render(template(), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(false);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('should render multiple defaultValue', () => \{
			    const template = () =>
			      createElement(
			        'select',
			        \{
			          multiple: true,
			          defaultValue: ['a', 'b', 'c']
			        \},
			        createElement(
			          'option',
			          \{
			            value: 'a'
			          \},
			          'a'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'b'
			          \},
			          'b'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'c'
			          \},
			          'c'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'd'
			          \},
			          'd'
			        )
			      );
			    render(template(), container);
			
			    expect(container.firstChild.children[0].selected).toEqual(true);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			    expect(container.firstChild.children[2].selected).toEqual(true);
			    expect(container.firstChild.children[3].selected).toEqual(false);
			    expect(container.innerHTML).toBe(
			      '<select multiple=""><option value="a">a</option><option value="b">b</option><option value="c">c</option><option value="d">d</option></select>'
			    );
			  \});
			
			  it('should not touch selections, if value or selected, is null or undefined', () => \{
			    render(
			      createElement(
			        'select',
			        null,
			        createElement(
			          'option',
			          \{
			            value: 'a'
			          \},
			          'a'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'b'
			          \},
			          'b'
			        )
			      ),
			      container
			    );
			    container.firstChild.children[1].selected = true;
			    render(
			      createElement(
			        'select',
			        null,
			        createElement(
			          'option',
			          \{
			            value: 'a'
			          \},
			          'a'
			        ),
			        createElement(
			          'option',
			          \{
			            value: 'b'
			          \},
			          'b'
			        )
			      ),
			      container
			    );
			    expect(container.firstChild.children[0].selected).toEqual(false);
			    expect(container.firstChild.children[1].selected).toEqual(true);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\select.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(11)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\svg.ext.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('SVG (non-jsx)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			  \});
			
			  it('should set attributes correctly', () => \{
			    const template = (val1) => createElement('svg', \{ height: val1 \});
			
			    render(template(null), container);
			    render(template(200), container);
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('height')).toEqual('200');
			    render(template(null), container);
			    render(template(200), container);
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('height')).toEqual('200');
			  \});
			
			  it('should respect SVG namespace and render SVG attributes', () => \{
			    let template;
			
			    template = (val1) =>
			      createElement(
			        'svg',
			        \{
			          xmlns: 'http://www.w3.org/2000/svg',
			          version: '1.1',
			          baseProfile: 'full',
			          width: '200',
			          height: val1
			        \},
			        null
			      );
			
			    render(template(200), container);
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('xmlns')).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('version')).toEqual('1.1');
			    expect(container.firstChild.getAttribute('baseProfile')).toEqual('full');
			    expect(container.firstChild.getAttribute('width')).toEqual('200');
			
			    render(template(null), container);
			
			    template = () => createElement('svg', \{ width: 200 \}, null);
			    render(template(), container);
			
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('width')).toEqual('200');
			
			    render(template(), container);
			
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('width')).toEqual('200');
			  \});
			
			  it('should set SVG as default namespace for <svg>', () => \{
			    let template;
			
			    template = () => createElement('svg', null);
			
			    render(template(), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    render(template(), container);
			
			    template = () => createElement('svg', null, createElement('path', null));
			
			    render(template(), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should unset a namespaced attributes #1', () => \{
			    const template = (val) => createElement('svg', null, createElement('image', \{ 'xlink:href': val \}));
			
			    render(template(null), container);
			    render(template('test.jpg'), container);
			    expect(container.firstChild.firstChild.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe('test.jpg');
			
			    render(template(null), container);
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			  \});
			
			  it('should unset a namespaced attributes #2', () => \{
			    const template = (val) =>
			      createElement('image', \{
			        'xlink:href': val
			      \});
			
			    render(template(null), container);
			    expect(container.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			
			    render(template(null), container);
			    expect(container.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			  \});
			
			  it('should unset a namespaced attributes #3', () => \{
			    const template = (val) =>
			      createElement('svg', \{
			        xmlns: 'http://www.w3.org/2000/svg',
			        'xlink:href': val
			      \});
			
			    render(template(null), container);
			    expect(container.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			
			    render(template('test.jpg'), container);
			    expect(container.firstChild.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe('test.jpg');
			  \});
			
			  it('should use the parent namespace by default (static)', () => \{
			    let template;
			
			    template = () => createElement('svg', null, createElement('circle', null));
			
			    render(template(), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    render(template(), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    template = () => createElement('svg', null, createElement('path', null));
			
			    render(template(), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    template = () => createElement('svg', null);
			
			    render(template(), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should handle SVG edge case (static)', () => \{
			    const template = (child) => createElement('div', null, createElement('svg', null));
			
			    render(template(), container);
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    render(template(), container);
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should keep parent namespace (dynamic)', () => \{
			    let child,
			      template = (_child) =>
			        createElement(
			          'svg',
			          \{
			            xmlns: 'http://www.w3.org/2000/svg'
			          \},
			          _child
			        );
			
			    child = () => createElement('circle', null);
			
			    render(template(child()), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    render(template(null), container);
			
			    child = () =>
			      createElement(
			        'circle',
			        \{
			          xmlns: 'http://www.w3.org/2000/svg'
			        \},
			        createElement('circle', \{
			          xmlns: 'http://www.w3.org/2000/svg'
			        \})
			      );
			
			    render(template(child()), container);
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    render(template(null), container);
			
			    child = () =>
			      createElement(
			        'circle',
			        null,
			        createElement(
			          'circle',
			          null,
			          createElement('g', \{
			            xmlns: 'http://www.w3.org/2000/svg'
			          \})
			        )
			      );
			
			    render(template(child()), container);
			    expect(container.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    child = () => createElement('circle', null, createElement('circle', null, createElement('g', null, createElement('g', null))));
			    render(template(child()), container);
			    expect(container.firstChild.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    child = () =>
			      createElement('circle', null, createElement('circle', null, createElement('g', null, createElement('g', null, createElement('circle', null)))));
			
			    render(template(null), container);
			    render(template(child()), container);
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    render(template(null), container);
			    render(template(child()), container);
			    expect(container.firstChild.firstChild.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should set class attribute', () => \{
			    const template = (val) =>
			      createElement('image', \{
			        class: val
			      \});
			
			    render(template('foo'), container);
			    expect(container.firstChild.getAttribute('class')).toBe('foo');
			    render(template(null), container);
			
			    render(template('bar'), container);
			    expect(container.firstChild.getAttribute('class')).toBe('bar');
			
			    render(template(['bar']), container);
			    expect(container.firstChild.getAttribute('class')).toBe('bar');
			
			    render(template(['bar', 'zoo']), container);
			    expect(container.firstChild.getAttribute('class')).toBe('bar,zoo');
			  \});
			
			  it('should respect SVG namespace and render SVG attributes', () => \{
			    const template = (val1, val2) =>
			      createElement('svg', \{
			        xmlns: 'http://www.w3.org/2000/svg',
			        version: '1.1',
			        baseProfile: 'full',
			        width: val1,
			        height: val2
			      \});
			
			    render(template(200, 200), container);
			
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('xmlns')).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('version')).toEqual('1.1');
			    expect(container.firstChild.getAttribute('baseProfile')).toEqual('full');
			    expect(container.firstChild.getAttribute('width')).toEqual('200');
			    expect(container.firstChild.getAttribute('height')).toEqual('200');
			
			    render(template(300, 300), container);
			
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('xmlns')).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('version')).toEqual('1.1');
			    expect(container.firstChild.getAttribute('baseProfile')).toEqual('full');
			    expect(container.firstChild.getAttribute('width')).toEqual('300');
			    expect(container.firstChild.getAttribute('height')).toEqual('300');
			  \});
			
			  it('should set "viewBox" attribute', () => \{
			    const template = () =>
			      createElement('svg', \{
			        xmlns: 'http://www.w3.org/2000/svg',
			        viewBox: '0 0 50 20'
			      \});
			
			    render(template(), container);
			
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('xmlns')).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('viewBox')).toEqual('0 0 50 20');
			
			    render(template(), container);
			
			    expect(container.firstChild.tagName.toLowerCase()).toEqual('svg');
			    expect(container.firstChild.namespaceURI).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('xmlns')).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.getAttribute('viewBox')).toEqual('0 0 50 20');
			  \});
			
			  it('should solve SVG edge when wrapped inside a non-namespace element (static)', () => \{
			    const template = () => createElement('div', null, createElement('svg', null));
			
			    render(template(), container);
			    // expect(container.firstChild.firstChild.tagName).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should solve SVG edge case with XMLNS attribute when wrapped inside a non-namespace element (static)', () => \{
			    const template = () =>
			      createElement(
			        'div',
			        \{
			          xmlns: 'http://www.w3.org/2000/svg'
			        \},
			        createElement('svg', null)
			      );
			
			    render(template(), container);
			    // expect(container.firstChild.firstChild.tagName).toEqual('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should solve SVG edge when wrapped inside a non-namespace element (static)', () => \{
			    const template = () =>
			      createElement(
			        'div',
			        null,
			        createElement('svg', \{
			          xmlns: 'http://www.w3.org/2000/svg'
			        \})
			      );
			
			    render(template(), container);
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    render(template(), container);
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should be possible to add className to SVG', () => \{
			    const template = () =>
			      createElement('svg', \{
			        xmlns: 'http://www.w3.org/2000/svg',
			        className: 'class1 class2'
			      \});
			
			    render(template(), container);
			    expect(container.firstChild.getAttribute('class')).toBe('class1 class2');
			  \});
			
			  it('should be possible to remove className from SVG', () => \{
			    const template = (val) =>
			      createElement('svg', \{
			        xmlns: 'http://www.w3.org/2000/svg',
			        className: val
			      \});
			
			    render(template('class1 class2'), container);
			    expect(container.firstChild.getAttribute('class')).toBe('class1 class2');
			    render(template('class1'), container);
			    expect(container.firstChild.getAttribute('class')).toBe('class1');
			    render(template(), container);
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			  \});
			
			  it('should follow last wins when both class and className are defined', () => \{
			    const template = () =>
			      createElement('svg', \{
			        xmlns: 'http://www.w3.org/2000/svg',
			        class: 'test',
			        className: 'class1 class2'
			      \});
			
			    render(template(), container);
			    expect(container.firstChild.getAttribute('class')).toBe('class1 class2');
			  \});
			
			  it('should respect XHTML namespace inside foreignObject of SVG', () => \{
			    const template = (extraElement) =>
			      createElement('svg', null, createElement('foreignObject', null, createElement('div', null, extraElement ? createElement('p') : null)));
			
			    render(template(false), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/1999/xhtml');
			    render(template(true), container);
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/1999/xhtml');
			    expect(container.firstChild.firstChild.firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/1999/xhtml');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\svg.ext.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(19)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\svg.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			import \{ rerender \} from '../../inferno-compat/src';
			
			describe('createTree - SVG (JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			  \});
			
			  it('should render svg as <svg>', () => \{
			    render(null, container);
			    render(<svg />, container);
			    expect(container.innerHTML).toBe('<svg></svg>');
			  \});
			
			  it('should use the parent namespace by default', () => \{
			    render(null, container);
			    render(
			      <svg xmlns="http://www.w3.org/2000/svg">
			        <circle xmlns="http://www.w3.org/2000/svg" />
			      </svg>,
			      container
			    );
			    expect(container.firstChild.firstChild.tagName).toBe('circle');
			    expect(container.firstChild.getAttribute('xmlns')).toBe('http://www.w3.org/2000/svg');
			
			    render(null, container);
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should keep parent namespace', () => \{
			    render(
			      <svg xmlns="http://www.w3.org/2000/svg">
			        <circle />
			      </svg>,
			      container
			    );
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    render(null, container);
			    render(
			      <svg width="100" height="100">
			        <g>
			          <circle cx="50" cy="50" r="40" stroke="green" fill="yellow" />
			        </g>
			        <g>
			          <g>
			            <circle cx="50" cy="50" r="40" stroke="green" fill="yellow" />
			          </g>
			        </g>
			      </svg>,
			      container
			    );
			    expect(container.childNodes[0].namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[0].tagName).toBe('g');
			    expect(container.childNodes[0].childNodes[0].namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[0].firstChild.tagName).toBe('circle');
			    expect(container.childNodes[0].childNodes[0].firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    expect(container.childNodes[0].childNodes[1].tagName).toBe('g');
			    expect(container.childNodes[0].childNodes[1].namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[1].firstChild.tagName).toBe('g');
			    expect(container.childNodes[0].childNodes[1].firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[1].firstChild.firstChild.tagName).toBe('circle');
			    expect(container.childNodes[0].childNodes[1].firstChild.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    render(
			      <svg xmlns="http://www.w3.org/2000/svg">
			        <circle />
			      </svg>,
			      container
			    );
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should keep parent namespace with xmlns attribute', () => \{
			    render(
			      <svg xmlns="http://www.w3.org/2000/svg">
			        <circle />
			      </svg>,
			      container
			    );
			    expect(container.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    render(
			      <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
			        <g>
			          <circle xmlns="http://www.w3.org/2000/svg" cx="50" cy="50" r="40" stroke="green" fill="yellow" />
			        </g>
			        <g>
			          <circle xmlns="http://www.w3.org/2000/svg" cx="50" cy="50" r="40" stroke="green" fill="yellow" foo=\{undefined\} />
			        </g>
			      </svg>,
			      container
			    );
			    expect(container.childNodes[0].namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[0].tagName).toBe('g');
			    expect(container.childNodes[0].childNodes[0].namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[0].firstChild.tagName).toBe('circle');
			    expect(container.childNodes[0].childNodes[0].firstChild.getAttribute('xmlns')).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[0].firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			
			    expect(container.childNodes[0].childNodes[1].tagName).toBe('g');
			    expect(container.childNodes[0].childNodes[1].namespaceURI).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[1].firstChild.tagName).toBe('circle');
			    expect(container.childNodes[0].childNodes[1].firstChild.getAttribute('xmlns')).toBe('http://www.w3.org/2000/svg');
			    expect(container.childNodes[0].childNodes[1].firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg');
			  \});
			
			  it('should set and remove dynamic class property', () => \{
			    const value = 'foo';
			
			    render(<svg className=\{value\} />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.getAttribute('class')).toBe('foo');
			
			    render(<svg />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.hasAttribute('class')).toBe(false);
			  \});
			
			  it('should set and remove dynamic class attribute', () => \{
			    const value = 'foo';
			
			    render(<svg className=\{value\} />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.getAttribute('class')).toBe('foo');
			
			    render(<svg />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.hasAttribute('class')).toBe(false);
			  \});
			
			  it('should set static class attribute, update to dynamic attr, and remove', () => \{
			    render(<svg className=\{null\} />, container);
			    render(<svg className=\{\{\}\} />, container);
			    render(<svg className="bar" />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.getAttribute('class')).toBe('bar');
			
			    const value = 'foo';
			
			    render(<svg className=\{value\} />, container);
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.getAttribute('class')).toBe('foo');
			
			    render(<svg />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			    expect(container.firstChild.hasAttribute('class')).toBe(false);
			  \});
			
			  it('should remove arbitrary SVG camel case attributes', () => \{
			    render(<svg theWord="theBird" />, container);
			
			    expect(container.firstChild.hasAttribute('theWord')).toBe(true);
			    render(<svg />, container);
			    expect(container.firstChild.hasAttribute('theWord')).toBe(false);
			  \});
			
			  it('should remove namespaced SVG attributes', () => \{
			    render(<svg clip-path="0 0 110 110" />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			
			    expect(container.firstChild.hasAttribute('clip-path')).toBe(true);
			
			    render(
			      <svg>
			        <image />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			  \});
			
			  it('should remove namespaced SVG attributes', () => \{
			    render(<svg clip-path="0 0 110 110" />, container);
			
			    expect(container.firstChild.tagName).toEqual('svg');
			
			    expect(container.firstChild.hasAttribute('clip-path')).toBe(true);
			
			    render(
			      <svg>
			        <image />
			      </svg>,
			      container
			    );
			
			    expect(container.firstChild.firstChild.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(false);
			  \});
			
			  it('Should make SVG and children with spread attribute', () => \{
			    const spread = \{ id: 'test' \};
			
			    render(<svg \{...spread\} />, container);
			    expect(container.innerHTML).toBe('<svg id="test"></svg>');
			  \});
			
			  describe('SVG elements', () => \{
			    it('Should keep SVG children flagged when parent is SVG', () => \{
			      class Rect extends Component \{
			        constructor(p, c) \{
			          super(p, c);
			          this.state = \{ className: 'foo' \};
			        \}
			
			        componentDidMount() \{
			          this.setState(\{ className: 'bar' \});
			        \}
			
			        render() \{
			          return createElement('rect', \{
			            className: this.state.className
			          \});
			        \}
			      \}
			
			      render(
			        <svg>
			          <Rect />
			        </svg>,
			        container
			      );
			
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('foo');
			
			      rerender();
			
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('bar');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\svg.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(12)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\text.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Text', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			  \});
			
			  const emptyDefinitions = [
			    \{
			      name: 'normal text',
			      value: 'Hello, World!',
			      expected: 'Hello, World!'
			    \},
			    \{
			      name: 'number value (cast to string)',
			      value: 123,
			      expected: '123'
			    \},
			    \{
			      name: 'number value (Addition)',
			      value: 123 + 123,
			      expected: '246'
			    \},
			    \{
			      name: 'number value (subtraction)',
			      value: 123 - 122,
			      expected: '1'
			    \},
			    \{
			      name: 'number value (Associative of Addition)',
			      value: '(a + b) + c = a + (b + c)',
			      expected: '(a + b) + c = a + (b + c)'
			    \},
			    \{
			      name: 'number and text',
			      value: 123 + 'Hello',
			      expected: '123Hello'
			    \},
			    \{
			      name: 'number',
			      value: '123',
			      expected: '123'
			    \},
			    \{
			      name: 'math',
			      value: 44 - 44 * 3 - 333,
			      expected: '-421'
			    \},
			    \{
			      name: 'chinese',
			      value: '您好',
			      expected: '您好'
			    \},
			    \{
			      name: 'multiple whitespace',
			      value: '         ',
			      expected: '         '
			    \},
			    \{
			      name: 'multiple whitespace and single number',
			      value: '         ' + 123,
			      expected: '         123'
			    \},
			    \{
			      name: 'empty string with whitespace',
			      value: ' ',
			      expected: ' '
			    \},
			    \{
			      name: 'empty string with double whitespace',
			      value: '  ',
			      expected: '  '
			    \},
			    \{
			      name: 'empty string with triple whitespaces',
			      value: '   ',
			      expected: '   '
			    \},
			    \{
			      name: 'empty string with one whitespace to left',
			      value: ' a',
			      expected: ' a'
			    \},
			    \{
			      name: 'empty string with triple whitespaces to left',
			      value: '   a',
			      expected: '   a'
			    \}
			  ];
			
			  emptyDefinitions.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a static text node with ' + arg.name,
			        template: () => createElement('div', null, arg.value)
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  emptyDefinitions.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a static text node with null',
			        template: () => createElement('div', null, null)
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			
			        render(test.template(), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			      \});
			    \});
			  \});
			
			  emptyDefinitions.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a dynamic text node with ' + arg.name + ' - text property',
			        template: (text) => createElement('div', null, text)
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			
			      it(test.description, () => \{
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  emptyDefinitions.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a dynamic text node with ' + arg.name + ' - children node text',
			        template: (text) => createElement('div', null, createElement('span', null, text))
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  emptyDefinitions.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a dynamic text node with ' + arg.name + ' - single child with text ',
			        template: (text) => createElement('div', null, text)
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  emptyDefinitions.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a dynamic text node with ' + arg.name + ' - deep child with text property ',
			        template: (text) => createElement('div', null, createElement('span', null, text))
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			
			  emptyDefinitions.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a dynamic text node with ' + arg.name + ' - deeper child with text property ',
			        template: (text) => createElement('div', null, createElement('span', null, createElement('b', null, text)))
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			
			      it(test.description, () => \{
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			      \});
			
			      it(test.description, () => \{
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			
			        render(test.template(null), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(1);
			        expect(container.firstChild.textContent).toBe('');
			      \});
			    \});
			  \});
			
			  const multiArray = [
			    \{
			      name: 'multiple text',
			      value: ['Hello', ' World'],
			      expected: 'Hello World',
			      children: 2
			    \},
			    \{
			      name: 'multiple numbers (cast to string)',
			      value: ['12', '3'],
			      expected: '123',
			      children: 2
			    \},
			    \{
			      name: 'multiple numbers',
			      value: [12, 3],
			      expected: '123',
			      children: 2
			    \},
			    \{
			      name: 'null value',
			      value: null,
			      expected: '',
			      children: 0
			    \},
			    \{
			      name: 'undefined value',
			      value: undefined,
			      expected: '',
			      children: 0
			    \},
			    \{
			      name: 'empty string',
			      value: '',
			      expected: '',
			      children: 0
			    \},
			    \{
			      name: 'string with whitespace',
			      value: ' ',
			      expected: ' ',
			      children: 1
			    \},
			    \{
			      name: 'string as null',
			      value: null,
			      expected: '',
			      children: 0
			    \},
			    \{
			      name: 'string as undefined',
			      value: null,
			      expected: '',
			      children: 0
			    \},
			    \{
			      name: 'empty array',
			      value: [],
			      expected: '',
			      children: 0
			    \},
			    \{
			      name: 'number',
			      value: 123,
			      expected: '123',
			      children: 1
			    \},
			    \{
			      name: 'multiple numbers (Addition)',
			      value: [12 + 3, 3],
			      expected: '153',
			      children: 2
			    \},
			    \{
			      name: 'multiple numbers (subtraction)',
			      value: [12 - 3, 3],
			      expected: '93',
			      children: 2
			    \},
			    \{
			      name: 'multiple numbers (math)',
			      value: [12 - 3 - 3 * 4 - 1],
			      expected: '-4',
			      children: 1
			    \},
			    \{
			      name: 'multiple numbers (mixed math)',
			      value: [12 - 3, 3 * 4 - 1],
			      expected: '911',
			      children: 2
			    \}
			  ];
			
			  multiArray.forEach((arg) => \{
			    [
			      \{
			        description: 'should create a children property with ' + arg.name,
			        template: (textVar) => createElement('div', null, textVar)
			      \}
			    ].forEach((test) => \{
			      it(test.description, () => \{
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(arg.children);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			
			        render(test.template(arg.value), container);
			        expect(container.firstChild.nodeType).toBe(1);
			        expect(container.childNodes.length).toBe(1);
			        expect(container.firstChild.childNodes.length).toBe(arg.children);
			        expect(container.firstChild.textContent).toBe(arg.expected);
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\text.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(12)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\update.ext.spec.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Update (non-jsx)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			  \});
			
			  it('should insert an additionnal tag node', () => \{
			    const template = (child) => createElement('div', null, child);
			    let span;
			
			    span = () => createElement('div', null, 'hello ', 'to');
			
			    render(template(span()), container);
			
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.textContent).toBe('hello to');
			
			    render(template(span()), container);
			
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.textContent).toBe('hello to');
			
			    span = () => createElement('div', null);
			
			    render(template(span()), container);
			
			    expect(container.firstChild.nodeName).toBe('DIV');
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.textContent).toBe('');
			  \});
			
			  it('should insert an additional tag node', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = () => createElement('span', null);
			
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span></span>');
			    render(template(null), container);
			    expect(container.firstChild.innerHTML).toBe('');
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span></span>');
			  \});
			
			  it('should insert an additional tag node', () => \{
			    const template = (child) => createElement('div', null, child);
			    const div = () => createElement('div', null);
			
			    render(template(null), container);
			    expect(container.firstChild.innerHTML).toBe('');
			    render(template(div()), container);
			    expect(container.firstChild.innerHTML).toBe('<div></div>');
			  \});
			
			  it('should insert an additional tag node', () => \{
			    const template = (child) => createElement('div', null, child);
			    // const span = () => createElement('div');
			
			    render(template(null), container);
			    expect(container.firstChild.innerHTML).toBe('');
			    render(template(null), container);
			    expect(container.firstChild.innerHTML).toBe('');
			  \});
			
			  it('should insert multiple additional tag node', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = () => createElement('div', null);
			
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<div></div>');
			  \});
			
			  it('should render a node with dynamic values', () => \{
			    const template = (val1, val2) => createElement('div', null, 'Hello world - ', val1, ' ', val2);
			
			    render(template('Inferno', 'Owns'), container);
			    expect(container.innerHTML).toBe('<div>Hello world - Inferno Owns</div>');
			    render(template('Inferno', 'Owns'), container);
			    expect(container.innerHTML).toBe('<div>Hello world - Inferno Owns</div>');
			
			    render(template('Inferno', null), container);
			    expect(container.innerHTML).toBe('<div>Hello world - Inferno </div>');
			
			    render(template(null, 'Owns'), container);
			    expect(container.innerHTML).toBe('<div>Hello world -  Owns</div>');
			
			    render(template(null), container);
			    expect(container.innerHTML).toBe('<div>Hello world -  </div>');
			
			    render(template(undefined), container);
			    expect(container.innerHTML).toBe('<div>Hello world -  </div>');
			
			    render(template(null, 'Owns'), container);
			    expect(container.innerHTML).toBe('<div>Hello world -  Owns</div>');
			
			    render(template('Test', 'Works!'), container);
			    expect(container.innerHTML).toBe('<div>Hello world - Test Works!</div>');
			  \});
			
			  it('should update a wrapped text node', () => \{
			    const template = (val1, val2) => createElement('div', null, val1, ' foo', val2);
			
			    render(template(null), container);
			    expect(container.innerHTML).toBe('<div> foo</div>');
			
			    render(template('Hello', 'Bar'), container);
			    expect(container.innerHTML).toBe('<div>Hello fooBar</div>');
			
			    render(template(undefined), container);
			    expect(container.innerHTML).toBe('<div> foo</div>');
			
			    render(template('The', ' is dead!'), container);
			    expect(container.innerHTML).toBe('<div>The foo is dead!</div>');
			  \});
			
			  it('should update a wrapped text node', () => \{
			    const template = (val1, val2) => createElement('div', null, val1, ' foo', val2);
			
			    render(template(null), container);
			    expect(container.innerHTML).toBe('<div> foo</div>');
			
			    render(template(undefined), container);
			    expect(container.innerHTML).toBe('<div> foo</div>');
			
			    render(template('Hello', 'Bar'), container);
			    expect(container.innerHTML).toBe('<div>Hello fooBar</div>');
			
			    render(template('Hello', null), container);
			    expect(container.innerHTML).toBe('<div>Hello foo</div>');
			
			    render(template(null, 'Bar'), container);
			    expect(container.innerHTML).toBe('<div> fooBar</div>');
			
			    render(template(undefined), container);
			    expect(container.innerHTML).toBe('<div> foo</div>');
			
			    render(template('The', ' is dead!'), container);
			    expect(container.innerHTML).toBe('<div>The foo is dead!</div>');
			  \});
			
			  it('should update a wrapped text node with 4 arguments', () => \{
			    const template = (val1, val2, val3, val4) => createElement('div', null, val1, val2, val3, val4);
			
			    render(template('Hello', ' world!', ' and ', 'Bar'), container);
			    expect(container.innerHTML).toBe('<div>Hello world! and Bar</div>');
			
			    render(template(null, null, null, null), container);
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(template(), container);
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(template('Hello', ' world!', ' and ', 'Zoo'), container);
			    expect(container.innerHTML).toBe('<div>Hello world! and Zoo</div>');
			
			    render(template('Hello', null, ' and ', 'Zoo'), container);
			    expect(container.innerHTML).toBe('<div>Hello and Zoo</div>');
			
			    expect(() => render(template('Hello', \{\}, ' and ', 'Zoo'), container)).toThrow();
			
			    render(template('Hello', ' poz', ' and ', 'Zoo'), container);
			    expect(container.innerHTML).toBe('<div>Hello poz and Zoo</div>');
			
			    render(template('The ', 'bar', ' is', ' is dead!'), container);
			    expect(container.innerHTML).toBe('<div>The bar is is dead!</div>');
			
			    render(template('Hello', ' world!', null), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			
			  it('should update a node with static text', () => \{
			    const template = (val) =>
			      createElement(
			        'div',
			        \{
			          id: val
			        \},
			        'Hello, World'
			      );
			
			    render(template('Hello'), container);
			    expect(container.innerHTML).toBe('<div id="Hello">Hello, World</div>');
			
			    render(template('Bar'), container);
			    expect(container.innerHTML).toBe('<div id="Bar">Hello, World</div>');
			
			    render(template(), container);
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template(), container);
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template(null), container);
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template(null), container);
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template('foo'), container);
			    expect(container.innerHTML).toBe('<div id="foo">Hello, World</div>');
			  \});
			
			  it('should update a node with multiple children and static text', () => \{
			    const template = (val1) =>
			      createElement(
			        'div',
			        \{
			          id: val1
			        \},
			        'Hello, World'
			      );
			
			    render(template('Hello'), container);
			    expect(container.innerHTML).toBe('<div id="Hello">Hello, World</div>');
			
			    render(template('Hello'), container);
			    expect(container.innerHTML).toBe('<div id="Hello">Hello, World</div>');
			
			    render(template(null), container); // should unset
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template('foo'), container);
			    expect(container.innerHTML).toBe('<div id="foo">Hello, World</div>');
			  \});
			
			  it('should update a node with multiple children and static text #2', () => \{
			    const template = (val1) =>
			      createElement(
			        'div',
			        \{
			          id: val1
			        \},
			        'Hello, World'
			      );
			
			    render(template(null), container); // should unset
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template('Hello'), container);
			    expect(container.innerHTML).toBe('<div id="Hello">Hello, World</div>');
			
			    render(template(undefined), container); // should unset
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template('foo'), container);
			    expect(container.innerHTML).toBe('<div id="foo">Hello, World</div>');
			
			    render(template(), container); // should unset
			    expect(container.innerHTML).toBe('<div>Hello, World</div>');
			  \});
			
			  it('should update a div with class attribute, and dynamic children with static text', () => \{
			    const template = (child) =>
			      createElement(
			        'div',
			        \{
			          class: 'hello, world'
			        \},
			        child
			      );
			
			    const spanList = () => createElement('span', null, '1', '2', '3');
			
			    const span = (_b) => createElement('span', null, _b);
			
			    render(template(null), container);
			
			    expect(container.firstChild.nodeType).toBe(1);
			    expect(container.firstChild.childNodes.length).toBe(0);
			    expect(container.firstChild.tagName).toBe('DIV');
			
			    render(template(span(spanList())), container);
			    expect(container.firstChild.nodeType).toBe(1);
			    expect(container.firstChild.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.firstChild.firstChild.childNodes.length).toBe(3);
			    expect(container.firstChild.tagName).toBe('DIV');
			
			    render(template(span(null)), container);
			
			    expect(container.firstChild.nodeType).toBe(1);
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.tagName).toBe('DIV');
			  \});
			
			  it('should handle lots of dynamic variables', () => \{
			    const template = function (val1, val2, val3, val4, val5, val6) \{
			      return createElement(
			        'div',
			        \{
			          className: val2,
			          id: val1
			        \},
			        createElement(
			          'div',
			          \{
			            id: val5
			          \},
			          createElement('span', null, val6)
			        ),
			        createElement(
			          'div',
			          \{
			            className: val4
			          \},
			          val3
			        )
			      );
			    \};
			
			    render(template(), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			
			    render(template('foo1', 'bar1', 'foo2', 'bar2', 'foo3', 'bar3'), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('bar1');
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('bar3');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('bar3');
			
			    render(template('foo1', 'foo2', 'bar2', 'foo3', 'bar3'), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('foo2');
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			
			    render(template(null), container);
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			
			    render(template(undefined), container);
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			
			    render(template('yar1', 'noo1', [], 'noo2', 'yar3', 'noo3'), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('noo1');
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('noo3');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('noo3');
			
			    render(template('yar1', 'noo1', [], 'noo2', 'yar3', 123), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('noo1');
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('123');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('123');
			
			    render(template('yar1', 'noo1', 'yar2', 'noo2', 'yar3', 'noo3'), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('noo1');
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('noo3');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('noo3');
			
			    render(template('yar1', null, 'yar2', 'noo2', 'yar3', null), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			
			    render(template('yar1', null, null, 'noo2', null, null), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			
			    render(template([], null, null, [], null, null), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe(null);
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			
			    render(template([], [], 123, [], null, null), container);
			
			    expect(container.firstChild.firstChild.tagName).toBe('DIV');
			    expect(container.firstChild.getAttribute('class')).toBe('');
			    expect(container.firstChild.firstChild.firstChild.tagName).toBe('SPAN');
			    expect(container.firstChild.firstChild.textContent).toBe('');
			    expect(container.firstChild.firstChild.firstChild.textContent).toBe('');
			  \});
			
			  it('should render a basic example #7', () => \{
			    const div = (child) => createElement('div', null, child);
			    const span1 = () => 'Hello world!';
			
			    render(div(span1()), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			    const span2 = (child) => createElement('span', null, 'Im updated!');
			
			    render(div(span2()), container);
			  \});
			
			  it('should patch a wrapped text node with its container', () => \{
			    const template = (child) => createElement('div', null, child);
			
			    render(template(null), container);
			    expect(container.innerHTML).toBe('<div></div>');
			
			    render(template(null), container);
			    expect(container.innerHTML).toBe('<div></div>');
			    const span = () => createElement('div', null, 'Hello');
			
			    render(template(span()), container);
			    expect(container.innerHTML).toBe('<div><div>Hello</div></div>');
			  \});
			
			  it('should patch a text node into a tag node', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = function () \{
			      return 'Hello';
			    \};
			
			    render(template(span()), container);
			    expect(container.innerHTML).toBe('<div>Hello</div>');
			  \});
			
			  it('should patch a tag node into a text node #2', () => \{
			    const template = (child) => createElement('div', null, child);
			
			    const span = () => createElement('span', null, 'Good bye!');
			    render(template(span()), container);
			    expect(container.innerHTML).toBe('<div><span>Good bye!</span></div>');
			
			    render(template(), container);
			    expect(container.innerHTML).toBe('<div></div>');
			  \});
			
			  it('should render text then update it', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = function () \{
			      return 'Hello';
			    \};
			
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('Hello');
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('Hello');
			  \});
			
			  it('should render text then update to an array of text nodes', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = function () \{
			      return createElement('span', null, 'Hello ', 'World', '!');
			    \};
			
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span>Hello World!</span>');
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span>Hello World!</span>');
			  \});
			
			  it('should render an array of text nodes then update to a single text node', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = function () \{
			      return createElement('span', null, 'Hello ', 'World', '!');
			    \};
			
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span>Hello World!</span>');
			  \});
			
			  it('should update and array of text nodes to another array of text nodes', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = function () \{
			      return createElement('span', null, 'Hello ', 'World');
			    \};
			
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span>Hello World</span>');
			  \});
			
			  it('should update and array of text nodes to another array of text nodes #2', () => \{
			    const template = (child) => createElement('div', null, child);
			    const span = function () \{
			      return createElement('span', null, 'Hello ', 'World', '!');
			    \};
			
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span>Hello World!</span>');
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<span>Hello World!</span>');
			  \});
			
			  it('should update an node with static child', () => \{
			    const template = (child) =>
			      createElement(
			        'div',
			        null,
			        createElement(
			          'div',
			          null,
			          createElement('span', \{
			            id: child
			          \})
			        )
			      );
			
			    render(template('id#1'), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span id="id#1"></span></div>');
			
			    render(template('id#2'), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span id="id#2"></span></div>');
			    render(template('id#3'), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span id="id#3"></span></div>');
			  \});
			
			  it('should update an node with static child and dynamic custom attribute', () => \{
			    const template = (child) => createElement('div', null, createElement('div', null, child));
			    const span = function (val) \{
			      return createElement('span', \{
			        custom_attr: val
			      \});
			    \};
			
			    render(template(span('id#1')), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span custom_attr="id#1"></span></div>');
			    render(template(span('id#1')), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span custom_attr="id#1"></span></div>');
			  \});
			
			  it('should update an node with static child and dynamic custom attribute and static text', () => \{
			    const template = (child) => createElement('div', null, createElement('div', null, child));
			    const span = function (val) \{
			      return createElement(
			        'span',
			        \{
			          custom_attr: val
			        \},
			        'Hello!!'
			      );
			    \};
			
			    render(template(span('id#1')), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span custom_attr="id#1">Hello!!</span></div>');
			    render(template(span('id#2')), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span custom_attr="id#2">Hello!!</span></div>');
			  \});
			
			  it('should update an node with static child and dynamic custom attribute and static text #2', () => \{
			    const template = (child) => createElement('div', null, createElement('div', null, child));
			    const span = function (val) \{
			      return createElement(
			        'span',
			        \{
			          custom_attr: val
			        \},
			        'Hello!!'
			      );
			    \};
			
			    render(template(span('id#1')), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span custom_attr="id#1">Hello!!</span></div>');
			  \});
			
			  it('should not ignore a empty text node', () => \{
			    const template = () => createElement('span', null, '');
			
			    render(template(), container);
			    expect(container.childNodes.length).toBe(1);
			    render(template(), container);
			    expect(container.childNodes.length).toBe(1);
			  \});
			
			  it('should remove a text node', () => \{
			    const template = (child) => createElement('div', null, child);
			
			    render(template(['hello', 'world']), container);
			    expect(container.firstChild.childNodes.length).toBe(2);
			  \});
			
			  it('should update multiple changes', () => \{
			    const template = (val1, val2) =>
			      createElement(
			        'div',
			        \{
			          className: val1
			        \},
			        val2
			      );
			
			    render(template('hello', ['hello', 'world']), container);
			    expect(container.firstChild.childNodes.length).toBe(2);
			    expect(container.firstChild.getAttribute('class')).toBe('hello');
			
			    render(template('good bye', ['hello']), container);
			    expect(container.firstChild.childNodes.length).toBe(1);
			    expect(container.firstChild.getAttribute('class')).toBe('good bye');
			  \});
			
			  it('should update an node with static child and text', () => \{
			    const template = () => createElement('div', null, createElement('div', null, 'Hello, World'));
			
			    render(template(), container);
			    expect(container.firstChild.innerHTML).toBe('<div>Hello, World</div>');
			    render(template(), container);
			    expect(container.firstChild.innerHTML).toBe('<div>Hello, World</div>');
			
			    render(template(), container);
			    expect(container.firstChild.innerHTML).toBe('<div>Hello, World</div>');
			  \});
			
			  it('should update an node with dynamic child', () => \{
			    const template = (child) => createElement('div', null, createElement('div', null, child));
			    const span = function () \{
			      return createElement('span', null, 'Hello ', 'World');
			    \};
			    render(template(span()), container);
			    expect(container.firstChild.innerHTML).toBe('<div><span>Hello World</span></div>');
			  \});
			
			  it('should inject dynamic text various places', () => \{
			    const div = (text) => createElement('div', null, 'There is ', text, ' spoon!');
			
			    render(div('no'), container);
			    expect(container.innerHTML).toBe('<div>There is no spoon!</div>');
			
			    render(div('one'), container);
			    expect(container.innerHTML).toBe('<div>There is one spoon!</div>');
			
			    render(div(), container);
			    expect(container.innerHTML).toBe('<div>There is  spoon!</div>');
			
			    render(div(null), container);
			    expect(container.innerHTML).toBe('<div>There is  spoon!</div>');
			
			    render(div(undefined), container);
			    expect(container.innerHTML).toBe('<div>There is  spoon!</div>');
			  \});
			
			  it('should render a div tag and remove styling', () => \{
			    let template;
			
			    template = (styleRule) =>
			      createElement('div', \{
			        style: styleRule
			      \});
			
			    render(
			      template(\{
			        color: 'red',
			        'padding-left': '10px'
			      \}),
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div style="color: red; padding-left: 10px;"></div>');
			
			    render(template(null), container);
			
			    expect([null, '']).toContain(container.firstChild.getAttribute('style'));
			  \});
			
			  if (typeof global !== 'undefined' && !global.usingJSDOM) \{
			    describe('should render styling on root node, and set and remove styling on multiple children', () => \{
			      let template;
			
			      template = (styleRule) =>
			        createElement(
			          'div',
			          \{
			            style: \{
			              width: '200px'
			            \}
			          \},
			          createElement(
			            'div',
			            \{
			              class: 'Hello, world!'
			            \},
			            createElement('div', \{
			              style: styleRule
			            \})
			          )
			        );
			
			      it('Initial render (creation)', () => \{
			        render(
			          template(\{
			            color: 'red',
			            'padding-top': '10px'
			          \}),
			          container
			        );
			
			        expect(container.innerHTML).toBe(
			          '<div style="width: 200px;"><div class="Hello, world!"><div style="color: red; padding-top: 10px;"></div></div></div>'
			        );
			        render(
			          template(\{
			            color: 'red',
			            'padding-left': '10px'
			          \}),
			          container
			        );
			
			        expect(container.innerHTML).toBe(
			          '<div style="width: 200px;"><div class="Hello, world!"><div style="color: red; padding-left: 10px;"></div></div></div>'
			        );
			      \});
			
			      it('Second render (update)', () => \{
			        render(template(null), container); // change style to null
			
			        expect([null, '']).toContain(container.firstChild.firstChild.getAttribute('style'));
			      \});
			
			      it('Third render (update)', () => \{
			        render(
			          template(\{
			            color: 'blue',
			            'margin-bottom': '20px'
			          \}),
			          container
			        );
			
			        expect(container.innerHTML).toBe(
			          '<div style="width: 200px;"><div class="Hello, world!"><div style="color: blue; margin-bottom: 20px;"></div></div></div>'
			        );
			      \});
			    \});
			  \}
			
			  describe('Github #142', () => \{
			    describe('nonKeyed updates', () => \{
			      it('variation 1', () => \{
			        function A() \{
			          return createElement(
			            'div',
			            null,
			            createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'Text'))))
			          );
			        \}
			
			        function B() \{
			          return createElement(
			            'div',
			            null,
			            createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'bar'))))
			          );
			        \}
			
			        function C() \{
			          return createElement(
			            'div',
			            null,
			            createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'text1'))))
			          );
			        \}
			
			        // eslint-disable-next-line
			        render(A(), container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>Text</td></tr></table></div></div>');
			        // eslint-disable-next-line
			        render(B(), container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>bar</td></tr></table></div></div>');
			        // eslint-disable-next-line
			        render(C(), container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text1</td></tr></table></div></div>');
			      \});
			
			      it('variation 2', () => \{
			        const A = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'text', createElement('br', null)))))
			        );
			        const B = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, ['text']))))
			        );
			        const C = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, ['value'], createElement('br', null)))))
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text<br></td></tr></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text</td></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>value<br></td></tr></table></div></div>');
			      \});
			
			      it('variation 3', () => \{
			        const A = createElement('div', null, createElement('div', null, createElement('table', null)));
			        const B = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement(
			              'table',
			              null,
			              createElement('tr', null),
			              createElement('tr', null, createElement('td', null, 'A', createElement('br', null)), createElement('td', null, 'B', createElement('br', null))),
			              createElement('tr', null)
			            )
			          )
			        );
			        const C = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', null), createElement('tr', null, createElement('td', null, createElement('br', null))))
			          )
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr></tr><tr><td>A<br></td><td>B<br></td></tr><tr></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr></tr><tr><td><br></td></tr></table></div></div>');
			      \});
			
			      it('variation 4', () => \{
			        const A = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'text 1', createElement('br', null)))))
			        );
			
			        const B = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, createElement('br', null)))))
			        );
			
			        const C = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'text 2', createElement('br', null)))))
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 1<br></td></tr></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td><br></td></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 2<br></td></tr></table></div></div>');
			      \});
			
			      it('variation 5', () => \{
			        const A = [];
			
			        A[0] = createElement('table', null, createElement('tr', null, createElement('td', null, createElement('br', null))));
			        A[1] = createElement('table', null, createElement('tr', null, createElement('td', null, 'text 1', 'text a', createElement('br', null))));
			        A[2] = createElement('table', null, createElement('tr', null, createElement('td', null, 'text 2', createElement('br', null))));
			        A[3] = createElement(
			          'table',
			          null,
			          createElement('tr', null, createElement('td', null, [createElement('br', null), 'text 3'], createElement('br', null)))
			        );
			        render(A[0], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br></td></tr></table>');
			        render(A[1], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 1text a<br></td></tr></table>');
			        render(A[2], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 2<br></td></tr></table>');
			        render(A[3], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br>text 3<br></td></tr></table>');
			      \});
			
			      it('variation 6', () => \{
			        const A = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'text 1', createElement('br', null)))))
			        );
			
			        const B = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, createElement('br', null)))))
			        );
			
			        const C = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', null, createElement('td', null, 'text 2', createElement('br', null)))))
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 1<br></td></tr></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td><br></td></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 2<br></td></tr></table></div></div>');
			      \});
			
			      it('variation 7', () => \{
			        const A = [];
			        A[0] = createElement('table', null, createElement('tr', null, createElement('td', null, createElement('br', null))));
			        A[1] = createElement('table', null, createElement('tr', null, createElement('td', null, 'text 1', createElement('br', null))));
			        A[2] = createElement('table', null, createElement('tr', null, createElement('td', null, 'text 2', createElement('br', null))));
			        A[3] = createElement(
			          'table',
			          null,
			          createElement('tr', null, createElement('td', null, [createElement('br', null)], 'text 3', createElement('br', null)))
			        );
			
			        render(A[0], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br></td></tr></table>');
			        render(A[1], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 1<br></td></tr></table>');
			        render(A[2], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 2<br></td></tr></table>');
			        render(A[3], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br>text 3<br></td></tr></table>');
			      \});
			    \});
			
			    describe('KEYED updates', () => \{
			      it('variation 1', () => \{
			        function A() \{
			          return createElement(
			            'div',
			            null,
			            createElement('div', null, createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1' \}, 'Text'))))
			          );
			        \}
			
			        function B() \{
			          return createElement(
			            'div',
			            null,
			            createElement('div', null, createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1' \}, 'bar'))))
			          );
			        \}
			
			        function C() \{
			          return createElement(
			            'div',
			            null,
			            createElement('div', null, createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1' \}, 'text1'))))
			          );
			        \}
			
			        // eslint-disable-next-line
			        render(A(), container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>Text</td></tr></table></div></div>');
			        // eslint-disable-next-line
			        render(B(), container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>bar</td></tr></table></div></div>');
			        // eslint-disable-next-line
			        render(C(), container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text1</td></tr></table></div></div>');
			      \});
			
			      it('variation 2', () => \{
			        const A = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1' \}, ['text', createElement('br', null)])))
			          )
			        );
			
			        const B = createElement(
			          'div',
			          null,
			          createElement('div', null, createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1' \}, ['text']))))
			        );
			
			        const C = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1' \}, ['value', createElement('br', null)])))
			          )
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text<br></td></tr></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text</td></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>value<br></td></tr></table></div></div>');
			      \});
			
			      it('variation 3', () => \{
			        const A = createElement('div', null, createElement('div', null, createElement('table', null)));
			        const B = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement(
			              'table',
			              null,
			              createElement('tr', \{ key: 'row1' \}),
			              createElement(
			                'tr',
			                \{ key: 'row2' \},
			                createElement('td', \{ key: 'td2-1' \}, 'A', createElement('br', null)),
			                createElement('td', \{ key: 'td2-2' \}, 'B', createElement('br', null))
			              ),
			              createElement('tr', \{ key: 'row3' \})
			            )
			          )
			        );
			        const C = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement(
			              'table',
			              null,
			              createElement('tr', \{ key: 'row1' \}),
			              createElement('tr', \{ key: 'row2' \}, createElement('td', \{ key: 'td2-2' \}, '', createElement('br', null)))
			            )
			          )
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr></tr><tr><td>A<br></td><td>B<br></td></tr><tr></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr></tr><tr><td><br></td></tr></table></div></div>');
			      \});
			
			      it('variation 4', () => \{
			        const A = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, 'text 1', createElement('br', null))))
			          )
			        );
			
			        const B = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, '', createElement('br', null))))
			          )
			        );
			
			        const C = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, 'text 2', createElement('br', null))))
			          )
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 1<br></td></tr></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td><br></td></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 2<br></td></tr></table></div></div>');
			      \});
			
			      it('variation 5', () => \{
			        const A = [];
			
			        A[0] = createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, '', createElement('br', null))));
			
			        A[1] = createElement(
			          'table',
			          null,
			          createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, ['text 1', 'text a'], createElement('br', null)))
			        );
			
			        A[2] = createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, ['text 2'], createElement('br', null))));
			
			        A[3] = createElement(
			          'table',
			          null,
			          createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, [createElement('br', null), 'text 3'], createElement('br', null)))
			        );
			
			        render(A[0], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br></td></tr></table>');
			        render(A[1], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 1text a<br></td></tr></table>');
			        render(A[2], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 2<br></td></tr></table>');
			        render(A[3], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br>text 3<br></td></tr></table>');
			      \});
			
			      it('variation 6', () => \{
			        const A = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, ['text 1', createElement('br', null)])))
			          )
			        );
			
			        const B = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, ['', createElement('br', null)])))
			          )
			        );
			
			        const C = createElement(
			          'div',
			          null,
			          createElement(
			            'div',
			            null,
			            createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, ['text 2', createElement('br', null)])))
			          )
			        );
			
			        render(A, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 1<br></td></tr></table></div></div>');
			        render(B, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td><br></td></tr></table></div></div>');
			        render(C, container);
			        expect(container.innerHTML).toBe('<div><div><table><tr><td>text 2<br></td></tr></table></div></div>');
			      \});
			
			      it('variation 7', () => \{
			        const A = [];
			
			        A[0] = createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, '', createElement('br', null))));
			
			        A[1] = createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, 'text 1', createElement('br', null))));
			
			        A[2] = createElement('table', null, createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, 'text 2', createElement('br', null))));
			
			        A[3] = createElement(
			          'table',
			          null,
			          createElement('tr', \{ key: 'row1' \}, createElement('td', \{ key: 'td1-1' \}, [createElement('br', null), 'text 3'], createElement('br', null)))
			        );
			
			        render(A[0], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br></td></tr></table>');
			        render(A[1], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 1<br></td></tr></table>');
			        render(A[2], container);
			        expect(container.innerHTML).toBe('<table><tr><td>text 2<br></td></tr></table>');
			        render(A[3], container);
			        expect(container.innerHTML).toBe('<table><tr><td><br>text 3<br></td></tr></table>');
			      \});
			    \});
			  \});
			
			  describe('Github #162', () => \{
			    it('works', () => \{
			      const A = [];
			
			      A[0] = createElement('div', null, 'text 1');
			      A[1] = createElement('div', null, 'text 2', createElement('br', null), 'text 3');
			      A[2] = createElement('div', null, 'text 4');
			
			      render(A[0], container);
			      expect(container.innerHTML).toBe('<div>text 1</div>');
			      render(A[1], container);
			      expect(container.innerHTML).toBe('<div>text 2<br>text 3</div>');
			      render(A[2], container);
			      expect(container.innerHTML).toBe('<div>text 4</div>');
			    \});
			  \});
			
			  describe('Github #162', () => \{
			    it('works', () => \{
			      const A = [];
			
			      A[0] = createElement('div', null, 'text 1', createElement('br', null));
			
			      A[1] = createElement('div', null, 'text 2');
			
			      A[2] = createElement('div', null, createElement('br', null), 'text 4');
			
			      render(A[0], container);
			      expect(container.innerHTML).toBe('<div>text 1<br></div>');
			      render(A[1], container);
			      expect(container.innerHTML).toBe('<div>text 2</div>');
			      render(A[2], container);
			      expect(container.innerHTML).toBe('<div><br>text 4</div>');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\update.ext.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(53)
    });
    it('infernojs_inferno\\packages\\inferno-create-element\\__tests__\\update.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('Stateful Component updates', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should forget old updates', (done) => \{
			    let updatesAfromOutside;
			
			    class A extends Component \{
			      componentWillUnmount() \{\}
			
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          stuff: true
			        \};
			
			        updatesAfromOutside = this.updateMe.bind(this);
			      \}
			
			      updateMe() \{
			        this.setState(\{
			          stuff: false
			        \});
			      \}
			
			      render() \{
			        return <div>A Component A</div>;
			      \}
			    \}
			
			    class B extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return <div>B Component B</div>;
			      \}
			    \}
			
			    // Render A
			    const spy = spyOn(A.prototype, 'componentWillUnmount');
			    render(<A />, container);
			    expect(container.innerHTML).toBe('<div>A Component A</div>');
			    // Render B
			    render(<B />, container);
			    expect(container.innerHTML).toBe('<div>B Component B</div>');
			    expect(spy).toHaveBeenCalledTimes(1); // componentUnMount should have been called
			    spy.calls.reset();
			
			    // delayed update triggers for A
			    updatesAfromOutside();
			    expect(container.innerHTML).toBe('<div>B Component B</div>');
			
			    done();
			  \});
			
			  it('Should give better error message when calling setState from constructor ??', () => \{
			    // Following test simulates situation that setState is called when mounting process has not finished, fe. in constructor
			
			    class Parent extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          show: false
			        \};
			
			        this.domagic = this.domagic.bind(this);
			
			        // Call setState
			        expect(() =>
			          this.setState(\{
			            show: true
			          \})
			        ).toThrow();
			      \}
			
			      domagic() \{
			        this.setState(\{
			          show: !this.state.show
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <button onclick=\{this.domagic\} />
			            <Child show=\{this.state.show\} />
			          </div>
			        );
			      \}
			    \}
			
			    class Child extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{this.props.show ? (
			              <span className="hr red">
			                <span className="hr-text">Late</span>
			              </span>
			            ) : null\}
			            <p>More content</p>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			  \});
			
			  it('Should update boolean properties when children change same time', () => \{
			    let updateCaller = null;
			
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          values: [\{ checked: false \}, \{ checked: false \}, \{ checked: false \}]
			        \};
			
			        this.updateCaller = this.updateCaller.bind(this);
			        updateCaller = this.updateCaller;
			      \}
			
			      updateCaller() \{
			        this.setState(\{
			          values: [\{ checked: false \}, \{ checked: false \}]
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{this.state.values.map(function (value) \{
			              return <input type="checkbox" checked=\{value.checked\} />;
			            \})\}
			          </div>
			        );
			      \}
			    \}
			
			    render(<A />, container);
			    expect(container.innerHTML).toBe('<div><input type="checkbox"><input type="checkbox"><input type="checkbox"></div>');
			    const firstChild = container.firstChild;
			    expect(firstChild.childNodes[0].checked).toBe(false);
			    expect(firstChild.childNodes[1].checked).toBe(false);
			    expect(firstChild.childNodes[2].checked).toBe(false);
			
			    const checkbox = container.querySelector('input');
			    checkbox.checked = true; // SIMULATE user selecting checkbox
			    expect(firstChild.childNodes[0].checked).toBe(true);
			
			    updateCaller(); // New render
			    expect(container.innerHTML).toBe('<div><input type="checkbox"><input type="checkbox"></div>');
			    expect(firstChild.childNodes[0].checked).toBe(false);
			    expect(firstChild.childNodes[1].checked).toBe(false);
			  \});
			
			  it('Should Not get stuck in UNMOUNTED state', () => \{
			    let updateCaller = null;
			
			    // This parent is used for setting up Test scenario, not much related
			    class Parent extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div>
			            <A />
			          </div>
			        );
			      \}
			    \}
			
			    // A component holds all the stuff together
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          obj: \{
			            test: true
			          \}
			        \};
			
			        this.updateCaller = this.updateCaller.bind(this);
			        updateCaller = this.updateCaller;
			      \}
			
			      updateCaller() \{
			        this.setState(\{
			          obj: \{
			            test: !this.state.obj.test
			          \}
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <B data=\{this.state.obj\} />
			          </div>
			        );
			      \}
			    \}
			    // B has direct child C, B Is simple wrapper component
			    class B extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return <C data=\{this.props.data\} />;
			      \}
			    \}
			
			    let stuckChild = null;
			
			    // C is real component which does the job
			    // C is the one that gets unmounted...
			    class C extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          b: false
			        \};
			
			        this.imstuck = this.imstuck.bind(this);
			        stuckChild = this.imstuck;
			      \}
			
			      imstuck() \{
			        this.setState(\{
			          b: !this.state.b
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{this.props.data.test + ''\}
			            \{this.state.b + ''\}
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    expect(container.innerHTML).toBe('<div><div><div>truefalse</div></div></div>');
			
			    updateCaller();
			    expect(container.innerHTML).toBe('<div><div><div>falsefalse</div></div></div>');
			    updateCaller();
			    expect(container.innerHTML).toBe('<div><div><div>truefalse</div></div></div>');
			    updateCaller();
			    expect(container.innerHTML).toBe('<div><div><div>falsefalse</div></div></div>');
			    stuckChild();
			    expect(container.innerHTML).toBe('<div><div><div>falsetrue</div></div></div>');
			    stuckChild();
			    expect(container.innerHTML).toBe('<div><div><div>falsefalse</div></div></div>');
			    stuckChild();
			    expect(container.innerHTML).toBe('<div><div><div>falsetrue</div></div></div>');
			  \});
			
			  it('Should Not get stuck in UNMOUNTED state - variation2', () => \{
			    let updateCaller = null;
			
			    // This parent is used for setting up Test scenario, not much related
			    class Parent extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div>
			            <A />
			          </div>
			        );
			      \}
			    \}
			
			    // A component holds all the stuff together
			    class A extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          obj: \{
			            test: true
			          \}
			        \};
			
			        this.updateCaller = this.updateCaller.bind(this);
			        updateCaller = this.updateCaller;
			      \}
			
			      updateCaller() \{
			        this.setState(\{
			          obj: \{
			            test: !this.state.obj.test
			          \}
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <B data=\{this.state.obj\} />
			          </div>
			        );
			      \}
			    \}
			    // B has direct child C, B Is simple wrapper component
			    class B extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return <C data=\{this.props.data\} />;
			      \}
			    \}
			
			    let stuckChild = null;
			
			    // C is real component which does the job
			    // C is the one that gets unmounted...
			    class C extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          b: false
			        \};
			
			        this.imstuck = this.imstuck.bind(this);
			        stuckChild = this.imstuck;
			      \}
			
			      imstuck() \{
			        this.setState(\{
			          b: !this.state.b
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{this.props.data.test + ''\}
			            \{this.state.b + ''\}
			          </div>
			        );
			      \}
			    \}
			
			    render(<Parent />, container);
			
			    expect(container.innerHTML).toBe('<div><div><div>truefalse</div></div></div>');
			
			    stuckChild();
			    expect(container.innerHTML).toBe('<div><div><div>truetrue</div></div></div>');
			    stuckChild();
			    expect(container.innerHTML).toBe('<div><div><div>truefalse</div></div></div>');
			    stuckChild();
			    expect(container.innerHTML).toBe('<div><div><div>truetrue</div></div></div>');
			
			    updateCaller();
			    expect(container.innerHTML).toBe('<div><div><div>falsetrue</div></div></div>');
			    updateCaller();
			    expect(container.innerHTML).toBe('<div><div><div>truetrue</div></div></div>');
			    updateCaller();
			    expect(container.innerHTML).toBe('<div><div><div>falsetrue</div></div></div>');
			
			    stuckChild();
			    expect(container.innerHTML).toBe('<div><div><div>falsefalse</div></div></div>');
			  \});
			
			  it('Should keep order of nodes', () => \{
			    let setItems = null;
			
			    class InnerComponentToGetUnmounted extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <div className="common-root">
			            \{(() => \{
			              if (this.props.i % 2 === 0) \{
			                return (
			                  <div>
			                    DIV
			                    \{this.props.value\}
			                  </div>
			                );
			              \} else \{
			                return (
			                  <span>
			                    SPAN
			                    \{this.props.value\}
			                  </span>
			                );
			              \}
			            \})()\}
			          </div>
			        );
			      \}
			    \}
			
			    const DropdownItem = (\{ children \}) => <li>\{children\}</li>;
			
			    class Looper extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          items: []
			        \};
			
			        this.setItems = this.setItems.bind(this);
			
			        setItems = this.setItems;
			      \}
			
			      setItems(collection) \{
			        this.setState(\{
			          items: collection
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            <ul>
			              \{this.state.items.map(function (item, i) \{
			                return (
			                  <DropdownItem key=\{item.value\}>
			                    <InnerComponentToGetUnmounted key=\{0\} i=\{i\} value=\{item.value\} />
			                    <span key=\{1\}>\{item.text\}</span>
			                  </DropdownItem>
			                );
			              \})\}
			            </ul>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Looper />, container);
			    expect(container.innerHTML).toBe('<div><ul></ul></div>');
			    setItems([
			      \{ value: 'val1', text: 'key1' \},
			      \{ value: 'val2', text: 'key2' \},
			      \{ value: 'val3', text: 'key3' \},
			      \{ value: 'val4', text: 'key4' \}
			    ]);
			
			    expect(container.innerHTML).toBe(
			      '<div><ul><li><div class="common-root"><div>DIVval1</div></div><span>key1</span></li><li><div class="common-root"><span>SPANval2</span></div><span>key2</span></li><li><div class="common-root"><div>DIVval3</div></div><span>key3</span></li><li><div class="common-root"><span>SPANval4</span></div><span>key4</span></li></ul></div>'
			    );
			
			    setItems([
			      \{ value: 'val2', text: 'key2' \},
			      \{ value: 'val3', text: 'key3' \}
			    ]);
			    expect(container.innerHTML).toBe(
			      '<div><ul><li><div class="common-root"><div>DIVval2</div></div><span>key2</span></li><li><div class="common-root"><span>SPANval3</span></div><span>key3</span></li></ul></div>'
			    );
			
			    setItems([
			      \{ value: 'val1', text: 'key1' \},
			      \{ value: 'val2', text: 'key2' \},
			      \{ value: 'val3', text: 'key3' \},
			      \{ value: 'val4', text: 'key4' \}
			    ]);
			    expect(container.innerHTML).toBe(
			      '<div><ul><li><div class="common-root"><div>DIVval1</div></div><span>key1</span></li><li><div class="common-root"><span>SPANval2</span></div><span>key2</span></li><li><div class="common-root"><div>DIVval3</div></div><span>key3</span></li><li><div class="common-root"><span>SPANval4</span></div><span>key4</span></li></ul></div>'
			    );
			  \});
			
			  it('Should not crash when patching array to array with hooks', () => \{
			    let updater = null;
			    const stuff = [<div>\{['Test']\}</div>, <span>1</span>];
			    const orig = [[<span ref=\{function () \{\}\}>\{'1'\}</span>]];
			    class Stuff extends Component \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          stuff
			        \};
			
			        updater = (_stuff) => \{
			          this.setState(\{ stuff: _stuff \});
			        \};
			      \}
			
			      render() \{
			        return (
			          <div>
			            <div>\{this.state.stuff\}</div>
			          </div>
			        );
			      \}
			    \}
			
			    render(<Stuff />, container);
			    updater(orig);
			    expect(container.innerHTML).toBe('<div><div><span>1</span></div></div>');
			  \});
			
			  it('Should allow camelCase properties when using JSX plugin', () => \{
			    const fakeObj = \{
			      func() \{\}
			    \};
			    const submitSpy = spyOn(fakeObj, 'func');
			
			    class Tester extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <form>
			            <input
			              id="inputId"
			              onFocus=\{(e) => \{
			                expect(e).toBeTruthy();
			              \}\}
			              type="text"
			            />
			          </form>
			        );
			      \}
			    \}
			
			    render(<Tester />, container);
			    expect(container.innerHTML).toEqual('<form><input id="inputId" type="text"></form>');
			    const input = container.querySelector('#inputId');
			    expect(submitSpy).not.toHaveBeenCalled();
			    input.focus();
			  \});
			
			  it('Should not append when replacing ES6 component with functional component', () => \{
			    const A = function () \{
			      return (
			        <div>
			          <div className="topheader">
			            <h1>A</h1>
			          </div>
			        </div>
			      );
			    \};
			
			    function B() \{
			      return (
			        <div className="simplegrid">
			          <div className="topheader">
			            <h1>B</h1>
			          </div>
			          <div className="viewcontent fullscreen">
			            <C />
			          </div>
			        </div>
			      );
			    \}
			
			    class C extends Component \{
			      componentWillUnmount() \{\}
			
			      render() \{
			        return <div className="report-container">C</div>;
			      \}
			    \}
			
			    const expectedA = '<div><div class="topheader"><h1>A</h1></div></div>';
			    const expectedB =
			      '<div class="simplegrid"><div class="topheader"><h1>B</h1></div><div class="viewcontent fullscreen"><div class="report-container">C</div></div></div>';
			    render(<A />, container);
			    expect(container.innerHTML).toEqual(expectedA);
			
			    render(<B />, container);
			    expect(container.innerHTML).toEqual(expectedB);
			
			    // SO FAR SO GOOD
			
			    // NOW START SWAPPING
			
			    render(<A />, container);
			    expect(container.innerHTML).toEqual(expectedA);
			
			    render(<B />, container);
			    expect(container.innerHTML).toEqual(expectedB);
			
			    render(<A />, container);
			    expect(container.innerHTML).toEqual(expectedA);
			
			    render(<B />, container);
			    expect(container.innerHTML).toEqual(expectedB);
			
			    render(<A />, container);
			    expect(container.innerHTML).toEqual(expectedA);
			
			    render(<B />, container);
			    expect(container.innerHTML).toEqual(expectedB);
			
			    render(<A />, container);
			    expect(container.innerHTML).toEqual(expectedA);
			
			    render(<B />, container);
			    expect(container.innerHTML).toEqual(expectedB);
			  \});
			
			  it('Should not fail removing child of component node Github #1111', () => \{
			    const InfoLi = function InfoLi(props) \{
			      return (
			        <li>
			          \{createElement('input', \{
			            checked: props.check,
			            type: props.type,
			            label: props.label,
			            onClick: props.onClick
			          \})\}\{' '\}
			          \{props.label\}: check, then uncheck
			          <div>\{props.children\}</div>
			        </li>
			      );
			    \};
			
			    class ConfigsList extends Component \{
			      constructor(props) \{
			        super(props);
			        this.state = \{
			          checks: props.orderedConfigs.map((mod) => Boolean(mod.value))
			        \};
			      \}
			
			      handleCheck(index, ifChecked) \{
			        this.setState(\{
			          checks: this.state.checks.map((ch, i) => (i === index ? ifChecked : ch))
			        \});
			      \}
			
			      render(props) \{
			        return (
			          <ol>
			            \{props.orderedConfigs.map((conf, index) => \{
			              const child = this.state.checks[index] && createElement('div', null, 'hi there');
			              return (
			                <InfoLi
			                  label=\{conf\}
			                  type="checkbox"
			                  checked=\{this.state.checks[index]\}
			                  onClick=\{(event) => \{
			                    this.handleCheck(index, event.target.checked);
			                  \}\}
			                >
			                  \{child\}
			                </InfoLi>
			              );
			            \})\}
			          </ol>
			        );
			      \}
			    \}
			
			    render(<ConfigsList orderedConfigs=\{['use proxy?']\} />, container);
			
			    const input = container.querySelector('input');
			
			    input.click();
			
			    input.click();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-create-element\\__tests__\\update.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(10)
    });
    it('infernojs_inferno\\packages\\inferno-extras\\__tests__\\extras.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, createPortal, render \} from 'inferno';
			import \{ isDOMInsideComponent, isDOMInsideVNode \} from 'inferno-extras';
			
			describe('Extras', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('isDOMInsideComponent', () => \{
			    it('Should return true if event.target is found outside Portal', () => \{
			      const secondRoot = document.createElement('div');
			
			      let instance;
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			
			          instance = this;
			        \}
			
			        render(props, state) \{
			          return (
			            <div>
			              Move It
			              \{createPortal(
			                <div>
			                  <span>test</span>
			                  <ul id="target">
			                    <li />
			                  </ul>
			                </div>,
			                secondRoot
			              )\}
			            </div>
			          );
			        \}
			      \}
			
			      render(<Tester />, container);
			
			      expect(container.innerHTML).toBe('<div>Move It</div>');
			
			      const target = secondRoot.querySelector('#target');
			
			      expect(isDOMInsideComponent(target, instance)).toBe(true);
			
			      render(null, container);
			
			      expect(isDOMInsideComponent(target, instance)).toBe(false);
			    \});
			
			    it('Should search through all different shapes of virtual nodes', () => \{
			      const secondRoot = document.createElement('div');
			
			      let instance;
			
			      function Functional(\{ children \}) \{
			        return (
			          <div>
			            <span>\{children\}</span>
			          </div>
			        );
			      \}
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			
			          instance = this;
			        \}
			
			        render(props, state) \{
			          return (
			            <div>
			              Move It
			              <div>
			                <div>
			                  <div />
			                  <div />
			                </div>
			              </div>
			              \{createPortal(
			                <div>
			                  <span>
			                    <Functional>\{[<div />, 'Okay', <span id="target" />]\}</Functional>
			                  </span>
			                  <ul>
			                    <li />
			                  </ul>
			                </div>,
			                secondRoot
			              )\}
			            </div>
			          );
			        \}
			      \}
			
			      render(<Tester />, container);
			
			      expect(container.innerHTML).toBe('<div>Move It<div><div><div></div><div></div></div></div></div>');
			
			      const target = secondRoot.querySelector('#target');
			
			      expect(isDOMInsideComponent(target, instance)).toBe(true);
			
			      render(null, container);
			
			      expect(isDOMInsideComponent(target, instance)).toBe(false);
			    \});
			
			    it('Should return true if target node is the root', () => \{
			      let instance;
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			
			          instance = this;
			        \}
			
			        render() \{
			          return (
			            <div id="target">
			              <span />
			            </div>
			          );
			        \}
			      \}
			
			      render(<Tester />, container);
			
			      const target = container.querySelector('#target');
			
			      expect(isDOMInsideComponent(target, instance)).toBe(true);
			    \});
			
			    it('Should return false if target is not found', () => \{
			      let instances = [];
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			
			          instances.push(this);
			        \}
			
			        render() \{
			          return (
			            <div id=\{this.props.id\}>
			              <span />
			            </div>
			          );
			        \}
			      \}
			
			      render(
			        <div>
			          <Tester />
			          <Tester id="target" />
			          <Tester />
			        </div>,
			        container
			      );
			
			      const target = container.querySelector('#target');
			
			      expect(isDOMInsideComponent(target, instances[0])).toBe(false);
			      expect(isDOMInsideComponent(target, instances[1])).toBe(true);
			      expect(isDOMInsideComponent(target, instances[2])).toBe(false);
			    \});
			
			    it('Should return false if target is detached', () => \{
			      let instances = [];
			
			      class Tester extends Component \{
			        constructor(props) \{
			          super(props);
			
			          instances.push(this);
			        \}
			
			        render() \{
			          return (
			            <div id=\{this.props.id\}>
			              <span />
			            </div>
			          );
			        \}
			      \}
			
			      render(
			        <div>
			          <Tester key="1" />
			          <Tester key="2" id="target" />
			          <Tester key="3" />
			        </div>,
			        container
			      );
			
			      const target = container.querySelector('#target');
			
			      expect(isDOMInsideComponent(target, instances[0])).toBe(false);
			      expect(isDOMInsideComponent(target, instances[1])).toBe(true);
			      expect(isDOMInsideComponent(target, instances[2])).toBe(false);
			
			      render(
			        <div>
			          <Tester key="1" />
			          <Tester key="change-it" id="target" />
			          <Tester key="3" />
			        </div>,
			        container
			      );
			
			      expect(isDOMInsideComponent(target, instances[0])).toBe(false);
			      expect(isDOMInsideComponent(target, instances[1])).toBe(false);
			      expect(isDOMInsideComponent(target, instances[2])).toBe(false);
			    \});
			  \});
			
			  describe('isDOMInsideVNode', () => \{
			    it('Should work same way but for vNode', () => \{
			      const vNode = (
			        <div>
			          <div id="target">Ok</div>
			        </div>
			      );
			
			      render(
			        <div>
			          <span>Test</span>
			          \{vNode\}
			        </div>,
			        container
			      );
			
			      expect(isDOMInsideVNode(container.querySelector('#target'), vNode)).toBe(true);
			    \});
			
			    it('Should return true if that is the ndoe', () => \{
			      const vNode = <div id="target">Ok</div>;
			
			      render(
			        <div>
			          <span>Test</span>
			          \{vNode\}
			        </div>,
			        container
			      );
			
			      expect(isDOMInsideVNode(container.querySelector('#target'), vNode)).toBe(true);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-extras\\__tests__\\extras.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(7)
    });
    it('infernojs_inferno\\packages\\inferno-hydrate\\__tests__\\hydrate-forward-ref.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, createRef, forwardRef, render \} from 'inferno';
			import \{ hydrate \} from 'inferno-hydrate';
			
			describe('Hydrate - Forward Ref', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should be possible to forward createRef', () => \{
			    const FancyButton = forwardRef((props, ref) => (
			      <button ref=\{ref\} className="FancyButton">
			        \{props.children\}
			      </button>
			    ));
			
			    expect(FancyButton.render).toBeDefined();
			
			    class Hello extends Component \{
			      constructor(props) \{
			        super(props);
			
			        // You can now get a ref directly to the DOM button:
			        this.btn = createRef();
			      \}
			
			      componentDidMount() \{
			        expect(this.btn.current).toBe(container.querySelector('button'));
			      \}
			      render() \{
			        return <FancyButton ref=\{this.btn\}>Click me!</FancyButton>;
			      \}
			    \}
			
			    container.innerHTML = '<button class="FancyButton">Click me!</button>';
			
			    hydrate(<Hello />, container);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			  \});
			
			  it('Should be possible to forward callback ref', () => \{
			    const FancyButton = forwardRef((props, ref) => (
			      <button ref=\{ref\} className="FancyButton">
			        \{props.children\}
			      </button>
			    ));
			
			    expect(FancyButton.render).toBeDefined();
			
			    class Hello extends Component \{
			      render() \{
			        return (
			          <FancyButton
			            ref=\{(btn) => \{
			              if (btn) \{
			                expect(btn).toBe(container.querySelector('button'));
			              \}
			            \}\}
			          >
			            Click me!
			          </FancyButton>
			        );
			      \}
			    \}
			
			    container.innerHTML = '<button class="FancyButton">Click me!</button>';
			
			    hydrate(<Hello />, container);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			
			    render(null, container);
			
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('Should be possible to patch forwardRef component', () => \{
			    const FancyButton = forwardRef((props, ref) => \{
			      return (
			        <button ref=\{ref\} className="FancyButton">
			          \{props.children\}
			        </button>
			      );
			    \});
			
			    expect(FancyButton.render).toBeDefined();
			
			    let firstVal = null;
			
			    container.innerHTML = '<button class="FancyButton">Click me!</button>';
			
			    hydrate(
			      <FancyButton
			        ref=\{(btn) => \{
			          firstVal = btn;
			        \}\}
			      >
			        Click me!
			      </FancyButton>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			    expect(firstVal).not.toBe(null);
			
			    let secondVal = null;
			
			    render(
			      <FancyButton
			        ref=\{(btn) => \{
			          secondVal = btn;
			        \}\}
			      >
			        Click me! 222
			      </FancyButton>,
			      container
			    );
			
			    expect(firstVal).toBe(null);
			    expect(secondVal).not.toBe(null);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me! 222</button>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-hydrate\\__tests__\\hydrate-forward-ref.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-hydrate\\__tests__\\hydrate.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, createFragment, createPortal, createRef, Fragment, render, rerender \} from 'inferno';
			import \{ hydrate \} from 'inferno-hydrate';
			import \{ h \} from 'inferno-hyperscript';
			import \{ triggerEvent \} from 'inferno-utils';
			import \{ ChildFlags \} from 'inferno-vnode-flags';
			import \{ createElement \} from 'inferno-create-element';
			
			describe('rendering routine', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('hydrate', () => \{
			    it('Should be possible to hydrate manually', () => \{
			      // create matching DOM
			      container.innerHTML = '<input type="checkbox"/>';
			
			      let clickChecked = null;
			      let changeChecked = null;
			
			      // Hydrate manually, instead rendering
			      hydrate(
			        <input
			          type="checkbox"
			          checked=\{false\}
			          onClick=\{(e) => \{
			            clickChecked = e.target.checked;
			          \}\}
			          onChange=\{(e) => \{
			            changeChecked = e.target.checked;
			          \}\}
			        />,
			        container
			      );
			      const input = container.firstChild;
			
			      triggerEvent('click', input);
			
			      expect(input.checked).toBe(false);
			      expect(clickChecked).toBe(true);
			      expect(changeChecked).toBe(true);
			    \});
			
			    it('Should Manually hydrating should also attach root and patch when rendering next time', () => \{
			      // create matching DOM
			      const spy = jasmine.createSpy('spy');
			      container.innerHTML = '<div><input type="checkbox"/></div>';
			
			      let clickChecked = null;
			      let changeChecked = null;
			
			      // Hydrate manually, instead rendering
			      hydrate(
			        <div ref=\{spy\}>
			          <input
			            type="checkbox"
			            checked=\{false\}
			            onClick=\{(e) => \{
			              clickChecked = e.target.checked;
			            \}\}
			            onChange=\{(e) => \{
			              changeChecked = e.target.checked;
			            \}\}
			          />
			        </div>,
			        container
			      );
			
			      const oldInput = container.firstChild.firstChild;
			
			      expect(spy.calls.count()).toBe(1);
			
			      render(
			        <div ref=\{spy\}>
			          <input
			            type="checkbox"
			            checked=\{true\}
			            className="new-class"
			            onClick=\{(e) => \{
			              clickChecked = e.target.checked;
			            \}\}
			            onChange=\{(e) => \{
			              changeChecked = e.target.checked;
			            \}\}
			          />
			        </div>,
			        container
			      );
			
			      expect(spy.calls.count()).toBe(1);
			
			      const input = container.querySelector('input.new-class');
			
			      expect(oldInput).toBe(input); // It should still be the same DOM node
			
			      triggerEvent('click', input);
			
			      expect(input.checked).toBe(true);
			      expect(clickChecked).toBe(false);
			      expect(changeChecked).toBe(false);
			
			      render(null, container);
			
			      expect(spy.calls.count()).toBe(2);
			    \});
			
			    it('Should change value and defaultValue to empty when hydrating over existing textArea', () => \{
			      container.innerHTML = '<textarea>foobar</textarea>';
			
			      hydrate(<textarea />, container);
			      expect(container.firstChild.value).toBe('');
			      expect(container.firstChild.defaultValue).toBe('');
			    \});
			
			    it('Should work with object ref on element vNode', () => \{
			      // create matching DOM
			      container.innerHTML = '<div>Okay<span>foobar</span></div>';
			
			      let newRef = createRef();
			
			      hydrate(
			        <div>
			          Okay
			          <span ref=\{newRef\}>Foobar</span>
			        </div>,
			        container
			      );
			
			      expect(newRef.current).toBe(container.querySelector('span'));
			      expect(container.innerHTML).toBe('<div>Okay<span>Foobar</span></div>');
			    \});
			
			    it('Should work with object ref on component vNode', () => \{
			      // create matching DOM
			      container.innerHTML = '<div>Okay<span>foobar</span></div>';
			
			      let instance = null;
			
			      class Foobar extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          instance = this;
			        \}
			        render() \{
			          return (
			            <Fragment>
			              <span>1</span>
			              \{this.props.children\}
			              <span>2</span>
			            </Fragment>
			          );
			        \}
			      \}
			
			      let newRef = createRef();
			
			      hydrate(
			        <div>
			          Okay
			          <Foobar ref=\{newRef\}>Foobar</Foobar>
			        </div>,
			        container
			      );
			
			      expect(newRef.current).toBe(instance);
			      expect(container.innerHTML).toBe('<div>Okay<span>1</span>Foobar<span>2</span></div>');
			    \});
			  \});
			
			  describe('Hydrate fragments', () => \{
			    function runAllTests() \{
			      it('Should hydrate and unmount fragment', () => \{
			        class Example extends Component \{
			          render() \{
			            return createFragment([<div>First</div>, <div>second</div>], ChildFlags.HasNonKeyedChildren);
			          \}
			        \}
			
			        hydrate(<Example />, container);
			
			        expect(container.innerHTML).toBe('<div>First</div><div>second</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should hydrate nested fragment', () => \{
			        class Example extends Component \{
			          render() \{
			            return createFragment(
			              [<div>First</div>, createFragment([<div>Sub1</div>, <div>Sub2</div>], ChildFlags.HasNonKeyedChildren), <div>second</div>],
			              ChildFlags.HasNonKeyedChildren
			            );
			          \}
			        \}
			
			        hydrate(<Example />, container);
			
			        expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be to replace component with fragment with another component', () => \{
			        class Example extends Component \{
			          render() \{
			            return createFragment(
			              [<div>First</div>, createFragment([<div>Sub1</div>, <div>Sub2</div>], ChildFlags.HasNonKeyedChildren), <div>second</div>],
			              ChildFlags.HasNonKeyedChildren
			            );
			          \}
			        \}
			
			        function FunctionalComp() \{
			          return createFragment([<div>Functional</div>], ChildFlags.HasNonKeyedChildren);
			        \}
			
			        hydrate(<Example />, container);
			
			        expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			        render(<FunctionalComp />, container);
			
			        expect(container.innerHTML).toBe('<div>Functional</div>');
			
			        render(<Example />, container);
			
			        expect(container.innerHTML).toBe('<div>First</div><div>Sub1</div><div>Sub2</div><div>second</div>');
			
			        render(<FunctionalComp />, container);
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to move fragments', () => \{
			        const fragmentA = () => createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			
			        const fragmentB = () => createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			
			        const fragmentC = () => createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			        hydrate(
			          <div>
			            \{fragmentA()\}
			            \{fragmentB()\}
			            \{fragmentC()\}
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div><div id="a1">A1</div><div>A2</div><div id="b1">B1</div><div id="c1">C1</div><div>C2</div><div>C3</div></div>');
			
			        let A1 = container.querySelector('#a1');
			        let B1 = container.querySelector('#b1');
			        let C1 = container.querySelector('#c1');
			
			        // Switch order
			        render(
			          <div>
			            \{fragmentC()\}
			            \{fragmentA()\}
			            \{fragmentB()\}
			          </div>,
			          container
			        );
			
			        // Verify dom has changed and nodes are the same
			        expect(container.innerHTML).toBe('<div><div id="c1">C1</div><div>C2</div><div>C3</div><div id="a1">A1</div><div>A2</div><div id="b1">B1</div></div>');
			
			        expect(container.querySelector('#a1')).toBe(A1);
			        expect(container.querySelector('#b1')).toBe(B1);
			        expect(container.querySelector('#c1')).toBe(C1);
			
			        // Switch order again
			        render(
			          <div>
			            \{fragmentB()\}
			            \{fragmentC()\}
			          </div>,
			          container
			        );
			
			        // Verify dom has changed and nodes are the same
			        expect(container.innerHTML).toBe('<div><div id="b1">B1</div><div id="c1">C1</div><div>C2</div><div>C3</div></div>');
			
			        expect(container.querySelector('#a1')).toBe(null);
			        expect(container.querySelector('#b1')).toBe(B1);
			        expect(container.querySelector('#c1')).toBe(C1);
			      \});
			
			      it('Should clone fragment children if they are passed as reference', () => \{
			        const fragmentA = createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			        const fragmentB = createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			        const fragmentC = createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			        const content = [fragmentC];
			
			        function SFC() \{
			          return (
			            <Fragment>
			              <span>1</span>
			              <Fragment>\{content\}</Fragment>
			              <span>2</span>
			            </Fragment>
			          );
			        \}
			
			        hydrate(
			          <Fragment>
			            \{fragmentA\}
			            <SFC key="sfc" />
			            \{fragmentB\}
			            \{fragmentC\}
			          </Fragment>,
			          container
			        );
			
			        const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			        const FragmentBHtml = '<div id="b1">B1</div>';
			        const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			        const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			        expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + FragmentCHtml);
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to move component with fragment root', () => \{
			        const fragmentA = createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			        const fragmentB = createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			        const fragmentC = createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			        const content = [fragmentC];
			
			        function SFC() \{
			          return (
			            <Fragment>
			              <span>1</span>
			              <Fragment>\{content\}</Fragment>
			              <span>2</span>
			            </Fragment>
			          );
			        \}
			
			        hydrate(
			          <Fragment>
			            \{fragmentA\}
			            <SFC key="sfc" />
			            \{fragmentB\}
			            \{fragmentC\}
			          </Fragment>,
			          container
			        );
			
			        const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			        const FragmentBHtml = '<div id="b1">B1</div>';
			        const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			        const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			        expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + FragmentCHtml);
			
			        // Switch order
			        render(
			          <Fragment>
			            \{fragmentA\}
			            \{fragmentC\}
			            <SFC key="sfc" />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe(FragmentAHtml + FragmentCHtml + SFCHtml);
			
			        // Switch order again
			        render(
			          <Fragment>
			            <div key="1">1</div>
			            <SFC key="sfc" />
			            \{fragmentA\}
			            \{fragmentC\}
			            <div key="1">2</div>
			          </Fragment>,
			          container
			        );
			
			        // Verify dom has changed and nodes are the same
			        expect(container.innerHTML).toBe('<div>1</div>' + SFCHtml + FragmentAHtml + FragmentCHtml + '<div>2</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to move component with fragment root #2', () => \{
			        const fragmentA = createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			        const fragmentB = createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			        const fragmentC = createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			        const content = [fragmentC];
			
			        function SFC() \{
			          return (
			            <Fragment>
			              <span>1</span>
			              <Fragment>\{content\}</Fragment>
			              <span>2</span>
			            </Fragment>
			          );
			        \}
			
			        hydrate(
			          <Fragment>
			            \{fragmentA\}
			            <SFC key="sfc1" />
			            \{fragmentB\}
			            <SFC key="sfc2" />
			            \{fragmentC\}
			            <SFC key="sfc3" />
			          </Fragment>,
			          container
			        );
			
			        const FragmentAHtml = '<div id="a1">A1</div><div>A2</div>';
			        const FragmentBHtml = '<div id="b1">B1</div>';
			        const FragmentCHtml = '<div id="c1">C1</div><div>C2</div><div>C3</div>';
			        const SFCHtml = '<span>1</span>' + FragmentCHtml + '<span>2</span>';
			
			        expect(container.innerHTML).toBe(FragmentAHtml + SFCHtml + FragmentBHtml + SFCHtml + FragmentCHtml + SFCHtml);
			
			        // Switch order
			        render(
			          <Fragment>
			            <SFC key="sfc3" />
			            \{fragmentA\}
			            <SFC key="sfc1" />
			            \{fragmentC\}
			            <SFC key="sfc2" />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe(SFCHtml + FragmentAHtml + SFCHtml + FragmentCHtml + SFCHtml);
			
			        // Switch order again
			        render(
			          <Fragment>
			            <div key="1">1</div>
			            <SFC key="sfc1" />
			            <SFC key="sfc2" />
			            \{fragmentA\}
			            \{fragmentC\}
			            <div key="1">2</div>
			            <SFC key="sfc3" />
			          </Fragment>,
			          container
			        );
			
			        // Verify dom has changed and nodes are the same
			        expect(container.innerHTML).toBe('<div>1</div>' + SFCHtml + SFCHtml + FragmentAHtml + FragmentCHtml + '<div>2</div>' + SFCHtml);
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to hydrate fragments JSX way', () => \{
			        function Fragmenter(\{ first, mid, last, changeOrder \}) \{
			          if (changeOrder) \{
			            return (
			              <>
			                <div>\{first\}</div>
			                <>
			                  More
			                  \{null\}
			                  Hey!
			                  <Fragment>
			                    <>Large \{last\}</>
			                    <Fragment>And Small</Fragment>
			                  </Fragment>
			                  <>Nesting</>
			                  \{mid\}
			                </>
			                <span>bar</span>
			                \{null\}
			              </>
			            );
			          \}
			          return (
			            <>
			              <div>\{first\}</div>
			              Hey!
			              <>
			                More
			                <>Nesting</>
			                \{mid\}
			                <Fragment>
			                  <>Large \{last\}</>
			                  <Fragment>And Small</Fragment>
			                </Fragment>
			              </>
			              <span>bar</span>
			            </>
			          );
			        \}
			
			        let mountCounter = 0;
			        let unmountCounter = 0;
			
			        class FoobarCom extends Component \{
			          componentWillMount() \{
			            mountCounter++;
			          \}
			
			          componentWillUnmount() \{
			            unmountCounter++;
			          \}
			
			          render(props) \{
			            return (
			              <>
			                \{props.children\}
			                \{createPortal(<div>InvisiblePortalCreator</div>, props.node)\}
			                \{null\}
			                Try out some crazy stuff
			              </>
			            );
			          \}
			        \}
			
			        const portalNode = document.createElement('div');
			
			        hydrate(
			          <FoobarCom node=\{portalNode\}>
			            <Fragmenter first="first" mid="MID" last=\{<div>Why?</div>\} />
			          </FoobarCom>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>first</div>Hey!MoreNestingMIDLarge <div>Why?</div>And Small<span>bar</span>Try out some crazy stuff');
			        expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			
			        render(
			          <FoobarCom node=\{portalNode\}>
			            <Fragmenter first=\{<span>GoGo</span>\} mid="MID" last=\{<div>Why?</div>\} changeOrder=\{true\} />
			          </FoobarCom>,
			          container
			        );
			
			        expect(container.innerHTML).toBe(
			          '<div><span>GoGo</span></div>MoreHey!Large <div>Why?</div>And SmallNestingMID<span>bar</span>Try out some crazy stuff'
			        );
			        expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			
			        render(
			          <FoobarCom node=\{portalNode\}>
			            <Fragmenter first="first" mid="MID" last=\{<div>Why?</div>\} />
			          </FoobarCom>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>first</div>Hey!MoreNestingMIDLarge <div>Why?</div>And Small<span>bar</span>Try out some crazy stuff');
			        expect(portalNode.innerHTML).toBe('<div>InvisiblePortalCreator</div>');
			      \});
			
			      it('Should hydrate deeply nested fragment', () => \{
			        function Fragmenter2() \{
			          return (
			            <>
			              <>
			                <>
			                  <>
			                    <>
			                      <>
			                        <>
			                          <>Okay!</>
			                        </>
			                      </>
			                    </>
			                  </>
			                </>
			              </>
			            </>
			          );
			        \}
			
			        hydrate(<Fragmenter2 />, container);
			
			        expect(container.innerHTML).toBe('Okay!');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should append DOM nodes to correct position when component root Fragmnet change', () => \{
			        class TestRoot extends Component \{
			          render() \{
			            return <>\{this.props.children\}</>;
			          \}
			        \}
			
			        hydrate(
			          <div>
			            <TestRoot>
			              <div>1</div>
			              <div>2</div>
			            </TestRoot>
			            <TestRoot>
			              <span>Ok</span>
			              <span>Test</span>
			            </TestRoot>
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><span>Ok</span><span>Test</span></div>');
			
			        render(
			          <div>
			            <TestRoot>
			              <div>1</div>
			              <div>2</div>
			              <div>3</div>
			              <div>4</div>
			            </TestRoot>
			            <TestRoot>
			              <div>Other</div>
			            </TestRoot>
			          </div>,
			          container
			        );
			        expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><div>3</div><div>4</div><div>Other</div></div>');
			      \});
			
			      it('Should not clear whole parent element when fragment children are cleared', () => \{
			        class TestRoot extends Component \{
			          render() \{
			            return <>\{this.props.children\}</>;
			          \}
			        \}
			
			        hydrate(
			          <div>
			            <TestRoot>
			              <div>1</div>
			              <div>2</div>
			            </TestRoot>
			            <TestRoot>
			              <span>Ok</span>
			              <span>Test</span>
			            </TestRoot>
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><span>Ok</span><span>Test</span></div>');
			
			        render(
			          <div>
			            <TestRoot>
			              <div>1</div>
			              <div>2</div>
			              <div>3</div>
			              <div>4</div>
			            </TestRoot>
			            <TestRoot />
			          </div>,
			          container
			        );
			        expect(container.innerHTML).toBe('<div><div>1</div><div>2</div><div>3</div><div>4</div></div>');
			      \});
			
			      it('Should move fragment and all its contents when using Fragment long syntax with keys', () => \{
			        let unmountCounter = 0;
			        let mountCounter = 0;
			
			        class TestLifecycle extends Component \{
			          componentWillUnmount() \{
			            unmountCounter++;
			          \}
			
			          componentWillMount() \{
			            mountCounter++;
			          \}
			
			          render() \{
			            return <>\{this.props.children\}</>;
			          \}
			        \}
			
			        hydrate(
			          <div>
			            <Fragment key="1">
			              <TestLifecycle>1a</TestLifecycle>
			              <TestLifecycle>1b</TestLifecycle>
			            </Fragment>
			            <Fragment key="2">
			              <TestLifecycle>2a</TestLifecycle>
			              <TestLifecycle>2b</TestLifecycle>
			            </Fragment>
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>1a1b2a2b</div>');
			        expect(unmountCounter).toBe(0);
			        expect(mountCounter).toBe(4);
			
			        render(
			          <div>
			            <Fragment key="2">
			              <TestLifecycle>2a</TestLifecycle>
			              <TestLifecycle>2b</TestLifecycle>
			              <TestLifecycle>2c</TestLifecycle>
			            </Fragment>
			            <Fragment key="1">
			              <TestLifecycle>1a</TestLifecycle>
			              <TestLifecycle>1b</TestLifecycle>
			            </Fragment>
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>2a2b2c1a1b</div>');
			        expect(unmountCounter).toBe(0);
			        expect(mountCounter).toBe(5);
			
			        render(
			          <div>
			            <Fragment key="3">
			              <TestLifecycle>3a</TestLifecycle>
			              <TestLifecycle>3b</TestLifecycle>
			              <TestLifecycle>3c</TestLifecycle>
			            </Fragment>
			            <Fragment key="2">
			              <TestLifecycle>2a</TestLifecycle>
			              <TestLifecycle>2Patched</TestLifecycle>
			            </Fragment>
			          </div>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>3a3b3c2a2Patched</div>');
			        expect(unmountCounter).toBe(3);
			        expect(mountCounter).toBe(8);
			      \});
			
			      it('Should unmount empty fragments', () => \{
			        hydrate(
			          <Fragment>
			            <Fragment />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        render(
			          <Fragment>
			            <div />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div></div>');
			
			        render(
			          <Fragment>
			            <Fragment />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to replace last element in fragment', () => \{
			        hydrate(
			          <Fragment>
			            <Fragment>
			              <span>1a</span>
			              <span>1b</span>
			              <div>1c</div>
			            </Fragment>
			            <Fragment>
			              <span>2a</span>
			              <span>2b</span>
			              <span>2c</span>
			            </Fragment>
			            <Fragment />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<span>1a</span><span>1b</span><div>1c</div><span>2a</span><span>2b</span><span>2c</span>');
			
			        render(
			          <Fragment>
			            <Fragment>
			              <span>1a</span>
			              <span>1c</span>
			            </Fragment>
			            <Fragment>
			              <span>2a</span>
			              <span>2b</span>
			              <span>2c</span>
			            </Fragment>
			            <Fragment />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<span>1a</span><span>1c</span><span>2a</span><span>2b</span><span>2c</span>');
			
			        render(
			          <Fragment>
			            <Fragment />
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should mount Fragment with invalid children', () => \{
			        hydrate(
			          <Fragment>
			            \{null\}
			            \{undefined\}
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should mount Fragment with invalid children #2', () => \{
			        function Foobar() \{
			          return null;
			        \}
			
			        hydrate(
			          <Fragment>
			            \{null\}
			            <Foobar />
			            \{undefined\}
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should mount Fragment with invalid children #2', () => \{
			        let add = false;
			
			        function Foobar() \{
			          if (add) \{
			            return <div>Ok</div>;
			          \}
			          return null;
			        \}
			
			        hydrate(
			          <Fragment>
			            \{null\}
			            <Foobar />
			            \{undefined\}
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        add = true;
			
			        render(
			          <Fragment>
			            \{null\}
			            <Foobar />
			            \{undefined\}
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>Ok</div>');
			      \});
			
			      it('Should be possible to update from 0 to 1', () => \{
			        function Foobar() \{
			          return <div>Ok</div>;
			        \}
			
			        let content = [null];
			
			        hydrate(
			          <Fragment>
			            <span>1</span>
			            <Fragment>\{content\}</Fragment>
			            <span>2</span>
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			
			        content = [<Foobar />];
			
			        render(
			          <Fragment>
			            <span>1</span>
			            <Fragment>\{content\}</Fragment>
			            <span>2</span>
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<span>1</span><div>Ok</div><span>2</span>');
			      \});
			
			      it('Should be possible to update from 0 to 1 fragment -> fragment', () => \{
			        function Foobar() \{
			          return <div>Ok</div>;
			        \}
			
			        let content = [];
			
			        hydrate(
			          <Fragment>
			            <span>1</span>
			            <Fragment>\{content\}</Fragment>
			            <span>2</span>
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<span>1</span><span>2</span>');
			
			        content = [
			          <Fragment>
			            <Foobar />
			          </Fragment>
			        ];
			
			        render(
			          <Fragment>
			            <span>1</span>
			            <Fragment>\{content\}</Fragment>
			            <span>2</span>
			          </Fragment>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<span>1</span><div>Ok</div><span>2</span>');
			      \});
			
			      it('Should be possible to mount and patch single component fragment children', () => \{
			        let counter = 0;
			
			        class Foobar extends Component \{
			          componentWillMount() \{
			            counter++;
			          \}
			          render() \{
			            return null;
			          \}
			        \}
			
			        hydrate(<></>, container);
			
			        expect(container.innerHTML).toBe('');
			
			        render(
			          <>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			        expect(counter).toBe(1);
			
			        render(
			          <>
			            <div>Ok</div>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>Ok</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to mount and patch single component fragment children - variation 2', () => \{
			        let counter = 0;
			
			        class Foobar extends Component \{
			          componentWillMount() \{
			            counter++;
			          \}
			          render() \{
			            return null;
			          \}
			        \}
			
			        let nodes = [];
			
			        hydrate(<>\{nodes\}</>, container);
			
			        nodes = [<Foobar />];
			
			        render(<>\{nodes\}</>, container);
			
			        nodes = [<Foobar />, <Foobar />, <Foobar />];
			
			        render(<>\{nodes\}</>, container);
			
			        nodes = [];
			
			        render(<>\{nodes\}</>, container);
			
			        expect(container.innerHTML).toBe('');
			        expect(counter).toBe(3);
			
			        render(
			          <>
			            <div>Ok</div>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>Ok</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to patch single fragment child component', () => \{
			        let counter = 0;
			
			        class Foobar extends Component \{
			          componentWillMount() \{
			            counter++;
			          \}
			          render() \{
			            return null;
			          \}
			        \}
			
			        hydrate(
			          <>
			            <>
			              <Foobar />
			            </>
			            <>
			              <Foobar />
			            </>
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			        expect(counter).toBe(2);
			
			        render(
			          <>
			            <></>
			            <>
			              <Foobar />
			            </>
			            <>
			              <Foobar />
			            </>
			            <></>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			        expect(counter).toBe(4);
			
			        render(
			          <>
			            <div>Ok</div>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>Ok</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to mount and patch single component fragment children', () => \{
			        class Foobar extends Component \{
			          render() \{
			            return null;
			          \}
			        \}
			
			        hydrate(
			          <>
			            <Foobar />
			          </>,
			          container
			        );
			
			        render(
			          <>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        render(
			          <>
			            <div>Ok</div>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>Ok</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			
			      it('Should be possible to mount and patch single component fragment children', () => \{
			        class Foobar extends Component \{
			          render() \{
			            return null;
			          \}
			        \}
			
			        hydrate(<>\{null\}</>, container);
			
			        render(
			          <>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('');
			
			        render(
			          <>
			            <div>Ok</div>
			            <Foobar />
			          </>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<div>Ok</div>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			      \});
			    \}
			
			    describe('empty container', () => \{
			      runAllTests();
			    \});
			
			    describe('mismatching container', () => \{
			      beforeEach(() => \{
			        container.innerHTML = '<div>Okay<span>Foo</span></div><em></em>';
			      \});
			
			      runAllTests();
			    \});
			  \});
			
			  describe('SVG elements', () => \{
			    it('Should keep SVG children flagged when parent is SVG', () => \{
			      class Rect extends Component \{
			        constructor(p, c) \{
			          super(p, c);
			          this.state = \{ className: 'foo' \};
			        \}
			
			        componentDidMount() \{
			          this.setState(\{ className: 'bar' \});
			        \}
			
			        render() \{
			          return createElement('rect', \{
			            className: this.state.className
			          \});
			        \}
			      \}
			
			      hydrate(
			        <svg>
			          <Rect />
			        </svg>,
			        container
			      );
			
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('foo');
			
			      rerender();
			
			      expect(container.firstChild.firstChild.getAttribute('class')).toBe('bar');
			    \});
			  \});
			
			  it('Should not re-mount after hydrate render render, Github #1426', () => \{
			    container.innerHTML = '<div><span>do not replace me</span></div>';
			
			    const span = container.firstChild.firstChild;
			
			    let vtree = h('div', [h('span', 'do not replace me')]);
			
			    hydrate(vtree, container);
			
			    expect(span).toBe(container.firstChild.firstChild);
			
			    render(vtree, container);
			
			    expect(span).toBe(container.firstChild.firstChild);
			
			    let vtree2 = h('div', [h('span', 'do not replace me')]);
			
			    render(vtree2, container);
			
			    expect(span).toBe(container.firstChild.firstChild);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-hydrate\\__tests__\\hydrate.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(31)
    });
    it('infernojs_inferno\\packages\\inferno-hyperscript\\__tests__\\hyperscript.spec.jsx', () => {
        const sourceCode = `
			import \{ h \} from 'inferno-hyperscript';
			import \{ Component, createRef, forwardRef, Fragment, render \} from 'inferno';
			
			describe('HyperScript (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should handle a basic example', () => \{
			    render(h('div'), container);
			    expect(container.innerHTML).toBe('<div></div>');
			  \});
			
			  it('Should handle a basic example #2', () => \{
			    render(h('div', 'Hello world!'), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			
			  it('Should handle a basic example #3', () => \{
			    render(h('div', \{ className: 'foo' \}, 'Hello world!'), container);
			    expect(container.innerHTML).toBe('<div class="foo">Hello world!</div>');
			  \});
			
			  const StatelessComponent = () => h('div', 'Hello world!');
			
			  describe('Class Component hooks', function () \{
			    it('Should trigger ref callback when component is mounting and unmounting', () => \{
			      const container = document.createElement('div');
			      class FooBar extends Component \{
			        render() \{
			          return h('div');
			        \}
			      \}
			      const spyObj = \{
			        fn: () => \{\}
			      \};
			      const spy = spyOn(spyObj, 'fn');
			      const node = h(FooBar, \{ ref: spyObj.fn \});
			
			      render(node, container);
			
			      expect(spy.calls.count()).toBe(1);
			      expect(spy.calls.argsFor(0).length).toBe(1);
			      expect(spy.calls.argsFor(0)[0]).not.toEqual(null);
			
			      render(null, container);
			
			      expect(spy.calls.count()).toBe(2);
			      expect(spy.calls.argsFor(1).length).toBe(1);
			      expect(spy.calls.argsFor(1)[0]).toEqual(null);
			    \});
			  \});
			
			  it('Should handle a basic example #4', () => \{
			    render(h(StatelessComponent), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			
			  it('Should handle a hooks example #1', () => \{
			    const Component = (\{ children \}) => \{
			      return h('div', children);
			    \};
			    const ComponentHooks = () =>
			      h(Component, \{
			        hooks: \{
			          onComponentDidUnmount() \{\}
			        \},
			        children: 'Hello world!'
			      \});
			
			    render(h(ComponentHooks), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			
			  it('Should handle children as third argument', () => \{
			    const Component = (\{ children \}) => \{
			      return h('div', children);
			    \};
			    const ComponentHooks = () => h(Component, null, 'Hello world!');
			
			    render(h(ComponentHooks), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			
			  it('Should handle different props (key, class, id, ref, children)', () => \{
			    const ComponentHooks = () =>
			      h('div#myId.test', \{
			        onComponentDidMount() \{\},
			        key: 'myKey',
			        ref: (c) => c,
			        className: 'myClass',
			        children: 'Hello world!'
			      \});
			
			    render(h(ComponentHooks), container);
			    expect(container.innerHTML).toBe('<div class="test myClass" id="myId">Hello world!</div>');
			  \});
			
			  it('Should handle tag with no name', () => \{
			    const ComponentHooks = () => h('', \{ children: 'Hello world!' \});
			    render(h(ComponentHooks), container);
			    expect(container.innerHTML).toBe('<div>Hello world!</div>');
			  \});
			
			  it('Should be possible to create textarea with hyperscript', () => \{
			    const ComponentHooks = () => h('textarea', \{ id: 'test' \});
			    render(h(ComponentHooks), container);
			    expect(container.innerHTML).toBe('<textarea id="test"></textarea>');
			  \});
			
			  it('Should be possible to create select element with hyperscript', () => \{
			    const ComponentHooks = () => h('select', \{ id: 'select' \}, [h('option', \{ value: 1 \}, '1'), h('option', \{ value: 2 \}, '2')]);
			    render(h(ComponentHooks), container);
			    expect(container.innerHTML).toBe('<select id="select"><option value="1">1</option><option value="2">2</option></select>');
			  \});
			
			  it('Should handle tag with no tag name but id is present', () => \{
			    const ComponentHooks = () => h('#myId');
			    render(h(ComponentHooks), container);
			    expect(container.innerHTML).toBe('<div id="myId"></div>');
			  \});
			
			  it('Should support lifecycle methods on functional components willMount', () => \{
			    const callbackSpy = jasmine.createSpy('spy');
			    const ComponentHooks = () => h('#myId');
			    render(h(ComponentHooks, \{ onComponentWillMount: callbackSpy \}), container);
			    expect(container.innerHTML).toBe('<div id="myId"></div>');
			    expect(callbackSpy).toHaveBeenCalledTimes(1);
			  \});
			
			  it('Should support lifecycle methods on functional components didMount', () => \{
			    const callbackSpy = jasmine.createSpy('spy');
			    const ComponentHooks = () => h('#myId');
			    render(h(ComponentHooks, \{ onComponentDidMount: callbackSpy \}), container);
			    expect(container.innerHTML).toBe('<div id="myId"></div>');
			    expect(callbackSpy).toHaveBeenCalledTimes(1);
			  \});
			
			  it('Should pass classNames through', () => \{
			    function Test1(\{ children, ...props \}) \{
			      return h('div.test1', props, children);
			    \}
			
			    function Test2(\{ children, ...props \}) \{
			      return h('div', props, children);
			    \}
			
			    function Test3(\{ children, ...props \}) \{
			      return h('div', \{ className: 'test3' \}, children);
			    \}
			
			    function Test4(\{ children, className, ...props \}) \{
			      return h('div', \{ className, ...props \}, children);
			    \}
			
			    render(
			      h('div', \{\}, [h(Test1, \{ className: 'test1prop' \}), h(Test2, \{ className: 'test2prop' \}), h(Test3), h(Test4, \{ className: 'test4prop' \})]),
			      container
			    );
			
			    const children = container.firstChild.childNodes;
			
			    expect(children[0].className).toBe('test1 test1prop');
			    expect(children[1].className).toBe('test2prop');
			    expect(children[2].className).toBe('test3');
			    expect(children[3].className).toBe('test4prop');
			  \});
			
			  if (typeof global !== 'undefined' && !global.usingJSDOM) \{
			    it('Should not lower case SVG tags', () => \{
			      render(h('svg', null, h('filter', \{ id: 'blur' \}, h('feGaussianBlur', \{ in: 'SourceGraphic' \}))), container);
			
			      expect(container.firstChild.firstChild.firstChild.tagName).toEqual('feGaussianBlur'); // tag name is case sensitive
			      expect(container.firstChild.firstChild.tagName).toEqual('filter');
			      expect(container.firstChild.tagName).toEqual('svg');
			    \});
			  \}
			
			  describe('CreateElement variations (non-JSX)', () => \{
			    it('Should handle events correctly when having multiple children', () => \{
			      let triggered = false;
			
			      const App = () => \{
			        return h('div', null, [
			          h('div', \{ className: 'title' \}, 'Example'),
			          h(
			            'button',
			            \{
			              type: 'button',
			              onClick: () => \{
			                triggered = !triggered;
			              \}
			            \},
			            'Do a thing'
			          )
			        ]);
			      \};
			
			      // eslint-disable-next-line
			      render(App(), container);
			      expect(container.innerHTML).toBe('<div><div class="title">Example</div><button type="button">Do a thing</button></div>');
			      expect(triggered).toBe(false);
			
			      const buttons = container.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      expect(triggered).toBe(true);
			    \});
			
			    it('Should handle events correctly when having single child', () => \{
			      let triggered = false;
			
			      const app = () => \{
			        return h(
			          'div',
			          null,
			          h(
			            'button',
			            \{
			              type: 'button',
			              onClick: () => \{
			                triggered = !triggered;
			              \}
			            \},
			            'Do a thing'
			          )
			        );
			      \};
			
			      render(app(), container);
			      expect(container.innerHTML).toBe('<div><button type="button">Do a thing</button></div>');
			      expect(triggered).toBe(false);
			
			      const buttons = container.querySelectorAll('button');
			      buttons.forEach((button) => button.click());
			
			      expect(triggered).toBe(true);
			    \});
			
			    it('Should allow passing childs through "children" property (native component)', () => \{
			      const app = () => \{
			        return h(
			          'div',
			          null,
			          h('button', \{
			            type: 'button',
			            children: ['Do a thing']
			          \})
			        );
			      \};
			
			      render(app(), container);
			      expect(container.innerHTML).toBe('<div><button type="button">Do a thing</button></div>');
			    \});
			
			    it('Should allow passing childs through "children" property (custom component)', () => \{
			      const Button = (props) => h('button', props);
			      const app = () => \{
			        return h(
			          'div',
			          null,
			          h(Button, \{
			            type: 'button',
			            children: ['Do a thing']
			          \})
			        );
			      \};
			
			      render(app(), container);
			      expect(container.innerHTML).toBe('<div><button type="button">Do a thing</button></div>');
			    \});
			
			    it('Should handle node with hooks and key', (done) => \{
			      const node = () => h('div', \{ key: 'key2' \}, 'Hooks');
			      const app = h(node, \{
			        key: 'key1',
			        onComponentDidMount(domNode) \{
			          expect(app.key).toBe('key1');
			          expect(domNode.tagName).toBe('DIV');
			          done();
			        \}
			      \});
			
			      render(app, container);
			      expect(container.innerHTML).toBe('<div>Hooks</div>');
			    \});
			
			    it('Should handle node with children but no props', () => \{
			      const node = () => h('div', null, 'Hooks');
			      const app = h(node, null, 'Hooks');
			
			      render(app, container);
			      expect(container.innerHTML).toBe('<div>Hooks</div>');
			    \});
			
			    it('Should handle node with refs', (done) => \{
			      let myRef = 'myRef';
			
			      const app = () => \{
			        const node = () =>
			          h('a', \{
			            ref: (c) => (myRef = c)
			          \});
			        return h(node, \{
			          onComponentDidMount() \{
			            expect(myRef.tagName).toBe('A');
			            done();
			          \}
			        \});
			      \};
			      render(h(app, null), container);
			    \});
			
			    let shouldUpdate = false;
			
			    class Test2 extends Component \{
			      shouldComponentUpdate() \{
			        return shouldUpdate;
			      \}
			
			      render() \{
			        return h('div', \{ contenteditable: true \}, this.props.foo);
			      \}
			    \}
			
			    it('Should not fail contenteditable if text node has external change Github#1207 - createElement', () => \{
			      shouldUpdate = false;
			      render(<Test2 foo="bar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			      render(<Test2 foo="yar" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">bar</div>');
			
			      container.firstChild.removeChild(container.firstChild.firstChild); // When div is contentEditable user can remove whole text content
			      expect(container.innerHTML).toBe('<div contenteditable="true"></div>');
			
			      shouldUpdate = true;
			      render(<Test2 foo="foo" />, container);
			      expect(container.innerHTML).toBe('<div contenteditable="true">foo</div>');
			      render(null, container);
			      expect(container.innerHTML).toBe('');
			    \});
			  \});
			
			  describe('Fragments', () => \{
			    it('Should render Fragment with key', () => \{
			      render(h(Fragment, \{ key: 'first' \}, [h('div', null, 'Ok'), h('span', null, 'Test')]), container);
			
			      expect(container.innerHTML).toBe('<div>Ok</div><span>Test</span>');
			
			      const div = container.querySelector('div');
			      const span = container.querySelector('span');
			
			      render(h(Fragment, \{ key: 'foobar' \}, [h('div', null, 'Ok'), h('span', null, 'Test')]), container);
			
			      // Verify key works
			      expect(container.innerHTML).toBe('<div>Ok</div><span>Test</span>');
			
			      expect(div).not.toBe(container.querySelector('div'));
			      expect(span).not.toBe(container.querySelector('span'));
			    \});
			  \});
			
			  it('Should be possible to forward createRef', () => \{
			    const FancyButton = forwardRef((props, ref) => h('button', \{ ref: ref, className: 'FancyButton' \}, props.children));
			
			    expect(FancyButton.render).toBeDefined();
			
			    class Hello extends Component \{
			      constructor(props) \{
			        super(props);
			
			        // You can now get a ref directly to the DOM button:
			        this.btn = createRef();
			      \}
			
			      componentDidMount() \{
			        expect(this.btn.current).toBe(container.querySelector('button'));
			      \}
			      render() \{
			        return h(FancyButton, \{ ref: this.btn \}, 'Click me!');
			      \}
			    \}
			
			    render(h(Hello), container);
			
			    expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-hyperscript\\__tests__\\hyperscript.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(26)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\context.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			import \{ observer, Provider \} from 'inferno-mobx';
			import \{ observable \} from 'mobx';
			
			describe('observer based context', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('using observer to inject throws warning', (done) => \{
			    const w = console.error;
			    const warns = [];
			    console.error = (msg) => warns.push(msg);
			
			    observer(['test'], () => null);
			
			    expect(warns.length).toBe(1);
			    expect(warns[0]).toEqual(
			      'Mobx observer: Using observer to inject stores is deprecated since 4.0. Use \`@inject("store1", "store2") @observer ComponentClass\` or \`inject("store1", "store2")(observer(componentClass))\` instead of \`@observer(["store1", "store2"]) ComponentClass\`'
			    );
			
			    console.error = w;
			    done();
			  \});
			
			  it('basic context', (done) => \{
			    const C = observer(
			      ['foo'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = () => <C />;
			    const A = () => (
			      <Provider foo="bar">
			        <B />
			      </Provider>
			    );
			    render(<A />, container);
			    expect(container.querySelector('div').textContent).toBe('context:bar');
			
			    done();
			  \});
			
			  it('props override context', (done) => \{
			    const C = observer(
			      ['foo'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = () => <C foo=\{42\} />;
			    const A = () => (
			      <Provider foo="bar">
			        <B />
			      </Provider>
			    );
			    render(<A />, container);
			    expect(container.querySelector('div').textContent).toBe('context:42');
			    done();
			  \});
			
			  it('overriding stores is supported', (done) => \{
			    const C = observer(
			      ['foo', 'bar'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			              \{this.props.bar\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = () => <C />;
			    const A = () => (
			      <Provider foo="bar" bar=\{1337\}>
			        <div>
			          <span>
			            <B />
			          </span>
			          <section>
			            <Provider foo=\{42\}>
			              <B />
			            </Provider>
			          </section>
			        </div>
			      </Provider>
			    );
			    render(<A />, container);
			
			    expect(container.querySelector('span').textContent).toBe('context:bar1337');
			    expect(container.querySelector('section').textContent).toBe('context:421337');
			    done();
			  \});
			
			  it('store should be available', (done) => \{
			    const C = observer(
			      ['foo'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = () => <C />;
			    const A = () => (
			      <Provider baz=\{42\}>
			        <B />
			      </Provider>
			    );
			    try \{
			      render(<A />, container);
			    \} catch (e) \{
			      expect(e.message).toBe("MobX injector: Store 'foo' is not available! Make sure it is provided by some Provider");
			      done();
			    \}
			  \});
			
			  it('store is not required if prop is available', (done) => \{
			    const C = observer(
			      ['foo'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = () => <C foo="bar" />;
			    render(<B />, container);
			    expect(container.querySelector('div').textContent).toBe('context:bar');
			    done();
			  \});
			
			  it('warning is printed when changing stores', (done) => \{
			    let msg = null;
			    const baseWarn = console.error;
			    console.error = (m) => (msg = m);
			    const a = observable.box(3);
			    const C = observer(
			      ['foo'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = observer(
			      createClass(\{
			        render: () => <C />
			      \})
			    );
			    const A = observer(
			      createClass(\{
			        render: () => (
			          <section>
			            <span>\{a.get()\}</span>,
			            <Provider foo=\{a.get()\}>
			              <B />
			            </Provider>
			          </section>
			        )
			      \})
			    );
			    render(<A />, container);
			    expect(container.querySelector('span').textContent).toBe('3');
			    expect(container.querySelector('div').textContent).toBe('context:3');
			    a.set(42);
			    expect(container.querySelector('span').textContent).toBe('42');
			    expect(container.querySelector('div').textContent).toBe('context:3');
			    expect(msg).toEqual("MobX Provider: Provided store 'foo' has changed. Please avoid replacing stores as the change might not propagate to all children");
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('warning is not printed when changing stores, but suppressed explicitly', (done) => \{
			    let msg = null;
			    const baseWarn = console.error;
			    console.error = (m) => (msg = m);
			    const a = observable.box(3);
			    const C = observer(
			      ['foo'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = observer(
			      createClass(\{
			        render: () => <C />
			      \})
			    );
			    const A = observer(
			      createClass(\{
			        render: () => (
			          <section>
			            <span>\{a.get()\}</span>,
			            <Provider foo=\{a.get()\} suppressChangedStoreWarning>
			              <B />
			            </Provider>
			          </section>
			        )
			      \})
			    );
			    render(<A />, container);
			    expect(container.querySelector('span').textContent).toBe('3');
			    expect(container.querySelector('div').textContent).toBe('context:3');
			    a.set(42);
			    expect(container.querySelector('span').textContent).toBe('42');
			    expect(container.querySelector('div').textContent).toBe('context:3');
			    expect(msg).toBe(null);
			    console.error = baseWarn;
			    done();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\context.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\extra\\eventemitter.spec.js', () => {
        const sourceCode = `
			import \{ EventEmitter \} from 'inferno-mobx';
			
			describe('EventEmitter', () => \{
			  it('Should be possible to listen changes and remove listeners by calling callback', () => \{
			    const emitter = new EventEmitter();
			    const listener1 = function () \{\};
			    expect(emitter.listeners.length).toEqual(0);
			
			    const listener = emitter.on(listener1);
			
			    expect(emitter.listeners.length).toEqual(1);
			    expect(emitter.listeners[0]).toEqual(listener1);
			
			    listener();
			
			    expect(emitter.listeners.length).toEqual(0);
			  \});
			
			  it('Should do nothing if removing same callback twice/or more', () => \{
			    const emitter = new EventEmitter();
			    const listener1 = function () \{\};
			    expect(emitter.listeners.length).toEqual(0);
			
			    const listener = emitter.on(listener1);
			
			    expect(emitter.listeners.length).toEqual(1);
			    expect(emitter.listeners[0]).toEqual(listener1);
			
			    listener();
			    listener();
			    listener();
			
			    expect(emitter.listeners.length).toEqual(0);
			  \});
			
			  it('Should emit the change data to all active listeners', () => \{
			    const emitter = new EventEmitter();
			    const listener1 = function () \{\};
			    const listener2 = function (data) \{
			      console.error(data);
			    \};
			
			    spyOn(console, 'error');
			
			    expect(emitter.listeners.length).toEqual(0);
			
			    const listener = emitter.on(listener1);
			    const listenerTwo = emitter.on(listener2);
			
			    expect(emitter.listeners.length).toEqual(2);
			    expect(emitter.listeners[0]).toEqual(listener1);
			
			    listener();
			    listener();
			    listener();
			
			    expect(emitter.listeners.length).toEqual(1);
			
			    emitter.emit('foobar');
			
			    expect(console.error.calls.count()).toBe(1);
			    expect(console.error.calls.argsFor(0)[0]).toContain('foobar');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\extra\\eventemitter.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\generic.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ observer, Provider \} from 'inferno-mobx';
			
			describe('generic higher order components', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('injects and observes', (done) => \{
			    /** @type \{<T>(x: T | null | undefined) => T\} */
			    const nullthrows = (/** @type \{any\} */ x) => \{
			      if (!x) \{
			        throw new Error('Unexpected falsy value.');
			      \}
			
			      return x;
			    \};
			
			    class ApiService \{
			      constructor() \{
			        this.foo = 'bar';
			      \}
			    \}
			
			    class TodoService \{
			      constructor() \{
			        this.baz = 'qux';
			      \}
			    \}
			
			    /**
			     * @typedef IProps
			     * @property \{ApiService?\} [apiService]
			     * @property \{TodoService?\} [todoService]
			     *
			     * @extends Component<IProps>
			     */
			    class TodoView extends Component \{
			      render() \{
			        const \{ foo \} = nullthrows(this.props.apiService);
			        const \{ baz \} = nullthrows(this.props.todoService);
			
			        return (
			          <p>
			            \{foo\}
			            \{baz\}
			          </p>
			        );
			      \}
			    \}
			
			    const Todo = observer(['apiService', 'todoService'], TodoView);
			
			    const services = \{
			      apiService: new ApiService(),
			      todoService: new TodoService()
			    \};
			
			    const A = () => (
			      <Provider \{...services\}>
			        <Todo />
			      </Provider>
			    );
			
			    render(<A />, container);
			    expect(container.querySelector('p').textContent).toBe('barqux');
			
			    done();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\generic.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\inject.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			import \{ inject, observer, Provider \} from 'inferno-mobx';
			import \{ observable \} from 'mobx';
			
			describe('inject based context', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('basic context', (done) => \{
			    const C = inject('foo')(
			      observer(
			        createClass(\{
			          render() \{
			            return (
			              <div>
			                context:
			                \{this.props.foo\}
			              </div>
			            );
			          \}
			        \})
			      )
			    );
			    const B = () => <C />;
			    const A = () => (
			      <Provider foo="bar">
			        <B />
			      </Provider>
			    );
			    render(<A />, container);
			    expect(container.querySelector('div').textContent).toBe('context:bar');
			    done();
			  \});
			
			  it('props override context', (done) => \{
			    const C = inject('foo')(
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = () => <C foo=\{42\} />;
			    const A = createClass(\{
			      render: () => (
			        <Provider foo="bar">
			          <B />
			        </Provider>
			      )
			    \});
			    render(<A />, container);
			    expect(container.querySelector('div').textContent).toBe('context:42');
			    done();
			  \});
			
			  it('overriding stores is supported', (done) => \{
			    const C = inject(
			      'foo',
			      'bar'
			    )(
			      observer(
			        createClass(\{
			          render() \{
			            return (
			              <div>
			                context:
			                \{this.props.foo\}
			                \{this.props.bar\}
			              </div>
			            );
			          \}
			        \})
			      )
			    );
			    const B = () => <C />;
			    const A = createClass(\{
			      render: () => (
			        <Provider foo="bar" bar=\{1337\}>
			          <div>
			            <span>
			              <B />
			            </span>
			            <section>
			              <Provider foo=\{42\}>
			                <B />
			              </Provider>
			            </section>
			          </div>
			        </Provider>
			      )
			    \});
			    render(<A />, container);
			    expect(container.querySelector('span').textContent).toBe('context:bar1337');
			    expect(container.querySelector('section').textContent).toBe('context:421337');
			    done();
			  \});
			
			  it('store should be available', (done) => \{
			    const C = inject('foo')(
			      observer(
			        createClass(\{
			          render() \{
			            return (
			              <div>
			                context:
			                \{this.props.foo\}
			              </div>
			            );
			          \}
			        \})
			      )
			    );
			    const B = () => <C />;
			    const A = createClass(\{
			      render: () => (
			        <Provider baz=\{42\}>
			          <B />
			        </Provider>
			      )
			    \});
			
			    try \{
			      render(<A />, container);
			    \} catch (e) \{
			      expect(e.message).toBe("MobX injector: Store 'foo' is not available! Make sure it is provided by some Provider");
			      done();
			    \}
			  \});
			
			  it('store is not required if prop is available', (done) => \{
			    const C = inject('foo')(
			      observer(
			        createClass(\{
			          render() \{
			            return (
			              <div>
			                context:
			                \{this.props.foo\}
			              </div>
			            );
			          \}
			        \})
			      )
			    );
			    const B = () => <C foo="bar" />;
			    render(<B />, container);
			    expect(container.querySelector('div').textContent).toBe('context:bar');
			    done();
			  \});
			
			  it('inject merges (and overrides) props', (done) => \{
			    const C = inject(() => (\{ a: 1 \}))(
			      observer(
			        createClass(\{
			          render() \{
			            expect(this.props).toEqual(\{ a: 1, b: 2 \});
			            return null;
			          \}
			        \})
			      )
			    );
			    const B = () => <C a=\{2\} b=\{2\} />;
			    render(<B />, container);
			    done();
			  \});
			
			  it('warning is printed when changing stores', (done) => \{
			    let msg;
			    const baseWarn = console.error;
			    console.error = (m) => (msg = m);
			    const a = observable.box(3);
			    const C = observer(
			      ['foo'],
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    const B = observer(
			      createClass(\{
			        render: () => <C />
			      \})
			    );
			    const A = observer(
			      createClass(\{
			        render: () => (
			          <section>
			            <span>\{a.get()\}</span>
			            <Provider foo=\{a.get()\}>
			              <B />
			            </Provider>
			          </section>
			        )
			      \})
			    );
			    render(<A />, container);
			
			    expect(container.querySelector('span').textContent).toBe('3');
			    expect(container.querySelector('div').textContent).toBe('context:3');
			
			    a.set(42);
			
			    expect(container.querySelector('span').textContent).toBe('42');
			    expect(container.querySelector('div').textContent).toBe('context:3');
			
			    expect(msg).toBe("MobX Provider: Provided store 'foo' has changed. Please avoid replacing stores as the change might not propagate to all children");
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('custom storesToProps', (done) => \{
			    const C = inject((stores, props, context) => \{
			      expect(context).toEqual(\{ mobxStores: \{ foo: 'bar' \} \});
			      expect(stores).toEqual(\{ foo: 'bar' \});
			      expect(props).toEqual(\{ baz: 42 \});
			
			      return \{
			        zoom: stores.foo,
			        baz: props.baz * 2
			      \};
			    \})(
			      observer(
			        createClass(\{
			          render() \{
			            return (
			              <div>
			                context:
			                \{this.props.zoom\}
			                \{this.props.baz\}
			              </div>
			            );
			          \}
			        \})
			      )
			    );
			    const B = createClass(\{
			      render: () => <C baz=\{42\} />
			    \});
			    const A = () => (
			      <Provider foo="bar">
			        <B />
			      </Provider>
			    );
			    render(<A />, container);
			    expect(container.querySelector('div').textContent).toBe('context:bar84');
			    done();
			  \});
			
			  it('support static hoisting, wrappedComponent and wrappedInstance', (done) => \{
			    const B = createClass(\{
			      render() \{
			        this.testField = 1;
			        return <div>\{this.testField\}</div>;
			      \}
			    \});
			    B.bla = 17;
			    B.bla2 = \{\};
			    const C = inject('booh')(B);
			
			    expect(C.wrappedComponent).toBe(B);
			    expect(B.bla).toBe(17);
			    expect(C.bla).toBe(17);
			
			    let c = null;
			    render(<C ref=\{(i) => (c = i)\} booh=\{42\} />, container);
			    expect(c.wrappedInstance.testField).toBe(1);
			    done();
			  \});
			
			  // DefaultProps only, there are no propTypes in inferno
			  it('propTypes and defaultProps are forwarded', (done) => \{
			    const msg = [];
			    const baseError = console.error;
			    console.error = (m) => msg.push(m);
			
			    const C = inject('foo')(
			      createClass(\{
			        displayName: 'C',
			        render() \{
			          expect(this.props.y).toBe(3);
			          return null;
			        \}
			      \})
			    );
			    C.defaultProps = \{
			      y: 3
			    \};
			    const B = () => <C z="test" />;
			    const A = () => (
			      <Provider foo="bar">
			        <B />
			      </Provider>
			    );
			    render(<A />, container);
			    expect(msg.length).toBe(0);
			    console.error = baseError;
			    done();
			  \});
			
			  it('using a custom injector is reactive', (done) => \{
			    const user = observable(\{ name: 'Noa' \});
			    const mapper = (stores) => (\{ name: stores.user.name \});
			    const DisplayName = (props) => <h1>\{props.name\}</h1>;
			    const User = inject(mapper)(DisplayName);
			    const App = () => (
			      <Provider user=\{user\}>
			        <User />
			      </Provider>
			    );
			    render(<App />, container);
			
			    expect(container.querySelector('h1').textContent).toBe('Noa');
			
			    user.name = 'Veria';
			    expect(container.querySelector('h1').textContent).toBe('Veria');
			    done();
			  \});
			
			  // it('using a custom injector is not too reactive', done => \{
			  //   let listRender = 0;
			  //   let itemRender = 0;
			  //   let injectRender = 0;
			  //
			  //   function connect() \{
			  //     return (component) => inject.apply(this, arguments)(observer(component))
			  //   \}
			  //
			  //   class State \{
			  //     @observable highlighted = null;
			  //     isHighlighted(item) \{
			  //       return this.highlighted == item;
			  //     \}
			  //
			  //     @action.bound highlight(item) \{
			  //       this.highlighted = item;
			  //     \}
			  //   \}
			  //
			  //   const items = observable([
			  //     \{ title: 'ItemA' \},
			  //     \{ title: 'ItemB' \},
			  //     \{ title: 'ItemC' \},
			  //     \{ title: 'ItemD' \},
			  //     \{ title: 'ItemE' \},
			  //     \{ title: 'ItemF' \},
			  //   ]);
			  //
			  //   const state = new State();
			  //
			  //   class ListComponent extends Component \{
			  //
			  //     render() \{
			  //       listRender++;
			  //       const \{items\} = this.props;
			  //
			  //       return <ul>\{
			  //         items.map((item) => <ItemComponent key=\{item.title\} item=\{item\}/>)
			  //       \}</ul>
			  //     \}
			  //   \}
			  //
			  //   @connect((\{state\}, \{item\}) => \{
			  //     injectRender++;
			  //     if (injectRender > 6) \{
			  //     \}
			  //     return (\{
			  //       // Using
			  //       // highlighted: expr(() => state.isHighlighted(item)) // seems to fix the problem
			  //       highlighted: state.isHighlighted(item),
			  //       highlight: state.highlight
			  //     \})
			  //   \})
			  //   class ItemComponent extends Component \{
			  //     highlight = () => \{
			  //       const \{item, highlight\} = this.props;
			  //       highlight(item);
			  //     \};
			  //
			  //     render() \{
			  //       itemRender++;
			  //       const \{highlighted, item\} = this.props;
			  //       return <li className=\{"hl_" + item.title\} onClick=\{this.highlight\}>\{ item.title \} \{ highlighted ? '(highlighted)' : '' \} </li>
			  //     \}
			  //   \}
			  //
			  //   render(
			  //     <Provider state=\{state\}>
			  //       <ListComponent items=\{items\}/>
			  //     </Provider>,
			  //     container
			  //   );
			  //
			  //   expect(listRender).toBe(1);
			  //   expect(injectRender).toBe(6);
			  //   expect(itemRender).toBe(6);
			  //
			  //
			  //   container.querySelectorAll(".hl_ItemB").forEach(e => e.click());
			  //   setTimeout(() => \{
			  //     expect(listRender).toBe(1);
			  //     expect(injectRender).toBe(12); // ideally, 7
			  //     expect(itemRender).toBe(7);
			  //
			  //     container.querySelectorAll(".hl_ItemF").forEach(e => e.click());
			  //     setTimeout(() => \{
			  //       expect(listRender).toBe(1);
			  //       expect(injectRender).toBe(18); // ideally, 9
			  //       expect(itemRender).toBe(9);
			  //       done();
			  //     \}, 20);
			  //   \}, 20);
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\inject.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(11)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\misc.spec.jsx', () => {
        const sourceCode = `
			import \{ render, rerender \} from 'inferno';
			import \{ observer \} from 'inferno-mobx';
			import \{ createClass \} from 'inferno-create-class';
			import \{ extendObservable, observable \} from 'mobx';
			
			describe('Mobx Misc', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('custom shouldComponentUpdate is not respected for observable changes (#50)', (done) => \{
			    let called = 0;
			    const x = observable.box(3);
			    const C = observer(
			      createClass(\{
			        render: () => (
			          <div>
			            value:
			            \{x.get()\}
			          </div>
			        ),
			        shouldComponentUpdate: () => called++
			      \})
			    );
			    render(<C />, container);
			    expect(container.querySelector('div').textContent).toBe('value:3');
			    expect(called).toBe(0);
			    x.set(42);
			    expect(container.querySelector('div').textContent).toBe('value:42');
			    expect(called).toBe(0);
			    done();
			  \});
			
			  it('custom shouldComponentUpdate is not respected for observable changes (#50) - 2', (done) => \{
			    let called = 0;
			    const y = observable.box(5);
			    const C = observer(
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              value:
			              \{this.props.y\}
			            </div>
			          );
			        \},
			        shouldComponentUpdate(nextProps) \{
			          called++;
			          return nextProps.y !== 42;
			        \}
			      \})
			    );
			    const B = observer(
			      createClass(\{
			        render: () => (
			          <span>
			            <C y=\{y.get()\} />
			          </span>
			        )
			      \})
			    );
			    render(<B />, container);
			    expect(container.querySelector('div').textContent).toBe('value:5');
			    expect(called).toBe(0);
			
			    y.set(6);
			    expect(container.querySelector('div').textContent).toBe('value:6');
			    expect(called).toBe(1);
			
			    y.set(42); // SCU => False
			    expect(container.querySelector('div').textContent).toBe('value:42');
			    expect(called).toBe(2);
			
			    y.set(7);
			    expect(container.querySelector('div').textContent).toBe('value:7');
			    expect(called).toBe(3);
			
			    done();
			  \});
			
			  it('issue mobx 405', (done) => \{
			    function ExampleState() \{
			      extendObservable(this, \{
			        name: 'test',
			        get greetings() \{
			          return 'Hello my name is ' + this.name;
			        \}
			      \});
			    \}
			
			    const ExampleView = observer(
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              <input type="text" onChange=\{(e) => (this.props.exampleState.name = e.target.value)\} value=\{this.props.exampleState.name\} />
			              <span>\{this.props.exampleState.greetings\}</span>
			            </div>
			          );
			        \}
			      \})
			    );
			
			    const exampleState = new ExampleState();
			    render(<ExampleView exampleState=\{exampleState\} />, container);
			    expect(container.querySelector('span').textContent).toBe('Hello my name is test');
			
			    done();
			  \});
			
			  it('#85 Should handle state changing in constructors', function () \{
			    const a = observable.box(2);
			    const Child = observer(
			      createClass(\{
			        displayName: 'Child',
			        getInitialState() \{
			          a.set(3); // one shouldn't do this!
			          return \{\};
			        \},
			        render: () => (
			          <div>
			            child:
			            \{a.get()\} -\{' '\}
			          </div>
			        )
			      \})
			    );
			    const ParentWrapper = observer(function Parent() \{
			      return (
			        <span>
			          <Child />
			          parent:
			          \{a.get()\}
			        </span>
			      );
			    \});
			    render(<ParentWrapper />, container);
			
			    expect(container.getElementsByTagName('span')[0].textContent).toBe('child:3 - parent:2');
			    a.set(5);
			
			    rerender();
			
			    expect(container.getElementsByTagName('span')[0].textContent).toBe('child:5 - parent:5');
			    a.set(7);
			
			    rerender();
			
			    expect(container.getElementsByTagName('span')[0].textContent).toBe('child:7 - parent:7');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\misc.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\observer.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ extendObservable, getObserverTree, observable, runInAction \} from 'mobx';
			import \{ inject, observer, Observer, onError, trackComponents, useStaticRendering \} from 'inferno-mobx';
			import \{ createClass \} from 'inferno-create-class';
			
			const store = observable(\{
			  todos: [
			    \{
			      title: 'a',
			      completed: false
			    \}
			  ]
			\});
			
			let todoItemRenderings = 0;
			const TodoItem = observer(function TodoItem(props) \{
			  todoItemRenderings++;
			  return <li>|\{props.todo.title\}</li>;
			\});
			
			let todoListRenderings = 0;
			let todoListWillReactCount = 0;
			const TodoList = observer(
			  createClass(\{
			    renderings: 0,
			    componentWillReact() \{
			      todoListWillReactCount++;
			    \},
			    render() \{
			      todoListRenderings++;
			      const todos = store.todos;
			      return (
			        <div>
			          <hi>\{todos.length\}</hi>
			          \{todos.map((todo, idx) => (
			            <TodoItem key=\{idx\} todo=\{todo\} />
			          ))\}
			        </div>
			      );
			    \}
			  \})
			);
			
			const App = () => <TodoList />;
			
			describe('Mobx Observer', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  beforeAll(function () \{
			    trackComponents();
			  \});
			
			  it('nestedRendering', () => \{
			    render(<App />, container);
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(todoListWillReactCount).toEqual(0); //, 'should not have reacted yet')
			    expect(container.querySelectorAll('li').length).toEqual(1);
			    expect(container.querySelector('li').textContent).toEqual('|a');
			
			    expect(todoItemRenderings).toEqual(1); // 'item1 should render once'
			
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1);
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1);
			
			    store.todos[0].title += 'a';
			
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(todoListWillReactCount).toEqual(0); //, 'should not have reacted')
			    expect(todoItemRenderings).toEqual(2); //, 'item1 should have rendered twice');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			
			    store.todos.push(\{
			      title: 'b',
			      completed: true
			    \});
			
			    expect(container.querySelectorAll('li').length).toBe(2); //, 'list should two items in the list');
			    const expectedOutput = [];
			    const nodes = container.querySelectorAll('li');
			
			    for (let i = 0; i < nodes.length; i++) \{
			      expectedOutput.push(nodes[i].textContent);
			    \}
			    expect(expectedOutput).toEqual(['|aa', '|b']);
			
			    expect(todoListRenderings).toBe(2); //'should have rendered list twice');
			    expect(todoListWillReactCount).toBe(1); //, 'should have reacted')
			    expect(todoItemRenderings).toBe(3); //, 'item2 should have rendered as well');
			    expect(getObserverTree(store.todos[1], 'title').observers.length).toBe(1); //, 'title observers should have increased');
			    expect(getObserverTree(store.todos[1], 'completed').observers).not.toBeDefined(); //, 'completed observers should not have increased');
			
			    const oldTodo = store.todos.pop();
			
			    expect(todoListRenderings).toBe(3); //, 'should have rendered list another time');
			    expect(todoListWillReactCount).toBe(2); //, 'should have reacted')
			    expect(todoItemRenderings).toBe(3); //, 'item1 should not have rerendered');
			    expect(container.querySelectorAll('li').length).toBe(1); //, 'list should have only on item in list now');
			    expect(getObserverTree(oldTodo, 'title').observers).not.toBeDefined(); //, 'title observers should have decreased');
			    expect(getObserverTree(oldTodo, 'completed').observers).not.toBeDefined(); //, 'completed observers should not have decreased');
			  \});
			
			  it('keep views alive', () => \{
			    let yCalcCount = 0;
			    const data = observable(\{
			      x: 3,
			      get y() \{
			        yCalcCount++;
			        return this.x * 2;
			      \},
			      z: 'hi'
			    \});
			
			    const TestComponent = observer(function testComponent() \{
			      return (
			        <div>
			          \{data.z\}
			          \{data.y\}
			        </div>
			      );
			    \});
			
			    render(<TestComponent />, container);
			    expect(yCalcCount).toBe(1);
			    expect(container.textContent).toBe('hi6');
			
			    data.z = 'hello';
			    // test: rerender should not need a recomputation of data.y because the subscription is kept alive
			
			    expect(yCalcCount).toBe(1);
			
			    expect(container.textContent).toBe('hello6');
			    expect(yCalcCount).toBe(1);
			
			    expect(getObserverTree(data, 'y').observers.length).toBe(1);
			
			    render(<div />, container);
			
			    expect(getObserverTree(data, 'y').observers).not.toBeDefined();
			  \});
			
			  it('componentWillMount from mixin is run first', (done) => \{
			    let origRenderMethod;
			    const clss = createClass(\{
			      componentWillMount: function () \{
			        // ugly check, but proofs that observer.willmount has run
			        // We cannot use function.prototype.name here like in react-redux tests because it is not supported in Edge/IE
			        expect(this.render).not.toBe(origRenderMethod);
			      \},
			      render() \{
			        return null;
			      \}
			    \});
			    origRenderMethod = clss.prototype.render;
			
			    const Comp = observer(clss);
			    render(<Comp />, container);
			    done();
			  \});
			
			  it('does not views alive when using static rendering', () => \{
			    useStaticRendering(true);
			
			    let renderCount = 0;
			    const data = observable(\{
			      z: 'hi'
			    \});
			
			    const TestComponent = observer(function testComponent() \{
			      renderCount++;
			      return <div>\{data.z\}</div>;
			    \});
			
			    render(<TestComponent />, container);
			
			    expect(renderCount).toBe(1);
			    expect(container.querySelector('div').textContent).toBe('hi');
			
			    data.z = 'hello';
			    // no re-rendering on static rendering
			
			    expect(renderCount).toBe(1);
			
			    expect(container.querySelector('div').textContent).toBe('hi');
			    expect(renderCount).toBe(1);
			
			    expect(getObserverTree(data, 'z').observers).not.toBeDefined();
			
			    useStaticRendering(false);
			  \});
			
			  it('issue 12', function () \{
			    const data = observable(\{
			      selected: 'coffee',
			      items: [
			        \{
			          name: 'coffee'
			        \},
			        \{
			          name: 'tea'
			        \}
			      ]
			    \});
			
			    /** Row Class */
			    class Row extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <span>
			            \{this.props.item.name\}
			            \{data.selected === this.props.item.name ? '!' : ''\}
			          </span>
			        );
			      \}
			    \}
			
			    /** table stateles component */
			    const Table = observer(function table() \{
			      return (
			        <div>
			          \{data.items.map((item) => (
			            <Row key=\{item.name\} item=\{item\} />
			          ))\}
			        </div>
			      );
			    \});
			
			    render(<Table />, container);
			
			    expect(container.querySelector('div').textContent).toBe('coffee!tea');
			
			    runInAction(() => \{
			      data.items[1].name = 'boe';
			      data.items.splice(0, 2, \{ name: 'soup' \});
			      data.selected = 'tea';
			    \});
			
			    expect(container.querySelector('div').textContent).toBe('soup');
			  \});
			
			  it('component should not be inject', function (done) \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    observer(
			      inject('foo')(
			        createClass(\{
			          render() \{
			            return (
			              <div>
			                context:
			                \{this.props.foo\}
			              </div>
			            );
			          \}
			        \})
			      )
			    );
			
			    expect(msg.length).toBe(1);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('observer component can be injected', (done) => \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    inject('foo')(
			      observer(
			        createClass(\{
			          render: () => null
			        \})
			      )
			    );
			
			    // N.B, the injected component will be observer since mobx-react 4.0!
			    inject(() => \{\})(
			      observer(
			        createClass(\{
			          render: () => null
			        \})
			      )
			    );
			
			    expect(msg.length).toBe(0);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('124 - react to changes in this.props via computed', function () \{
			    const Comp = observer(
			      createClass(\{
			        componentWillMount() \{
			          extendObservable(this, \{
			            get computedProp() \{
			              return this.props.x;
			            \}
			          \});
			        \},
			        render() \{
			          return (
			            <span>
			              x:
			              \{this.computedProp\}
			            </span>
			          );
			        \}
			      \})
			    );
			
			    const Parent = createClass(\{
			      getInitialState() \{
			        return \{ v: 1 \};
			      \},
			      render() \{
			        return (
			          <div onClick=\{() => this.setState(\{ v: 2 \})\}>
			            <Comp x=\{this.state.v\} />
			          </div>
			        );
			      \}
			    \});
			
			    render(<Parent />, container);
			
			    expect(container.querySelector('span').textContent).toBe('x:1');
			    container.querySelector('div').click();
			    expect(container.querySelector('span').textContent).toBe('x:2');
			  \});
			
			  it('should render component even if setState called with exactly the same props', function (done) \{
			    let renderCount = 0;
			    const Component = observer(
			      createClass(\{
			        onClick() \{
			          this.setState(\{\});
			        \},
			        render() \{
			          renderCount++;
			          return <div onClick=\{this.onClick\} id="clickableDiv" />;
			        \}
			      \})
			    );
			    render(<Component />, container);
			
			    expect(renderCount).toBe(1); //'renderCount === 1');
			    container.querySelector('#clickableDiv').click();
			    expect(renderCount).toBe(2); // 'renderCount === 2');
			    container.querySelector('#clickableDiv').click();
			    expect(renderCount).toBe(3); //'renderCount === 3');
			    done();
			  \});
			
			  // it('it rerenders correctly if some props are non-observables - 1', done => \{
			  //   let renderCount = 0;
			  //   let odata = observable(\{ x: 1 \})
			  //   let data = \{ y : 1 \}
			  //
			  //   @observer class Com extends Component \{
			  //     @computed get computed () \{
			  //       // n.b: data.y would not rerender! shallowly new equal props are not stored
			  //       return this.props.odata.x;
			  //     \}
			  //     render() \{
			  //       renderCount++;
			  //       return <span onClick=\{stuff\} >\{this.props.odata.x\}-\{this.props.data.y\}-\{this.computed\}</span>
			  //     \}
			  //   \}
			  //
			  //   const Parent = observer(createClass(\{
			  //     render() \{
			  //       // this.props.odata.x;
			  //       return <Com data=\{this.props.data\} odata=\{this.props.odata\} />
			  //     \}
			  //   \}))
			  //
			  //   function stuff() \{
			  //     data.y++;
			  //     odata.x++;
			  //   \}
			  //
			  //   render(<Parent odata=\{odata\} data=\{data\} />, container);
			  //
			  //   expect(renderCount).toBe(1) // 'renderCount === 1');
			  //   expect(container.querySelector("span").textContent).toBe("1-1-1");
			  //
			  //   container.querySelector("span").click();
			  //   setTimeout(() => \{
			  //     expect(renderCount).toBe(2) // 'renderCount === 2');
			  //     expect(container.querySelector("span").textContent).toBe("2-2-2");
			  //
			  //     container.querySelector("span").click();
			  //     setTimeout(() => \{
			  //       expect(renderCount).toBe(3) // 'renderCount === 3');
			  //       expect(container.querySelector("span").textContent).toBe("3-3-3");
			  //
			  //       done();
			  //     \}, 10);
			  //   \}, 20);
			  // \});
			
			  // it('it rerenders correctly if some props are non-observables - 2', done => \{
			  //   let renderCount = 0;
			  //   let odata = observable(\{ x: 1 \})
			  //
			  //   @observer class Com extends Component \{
			  //     @computed get computed () \{
			  //       return this.props.data.y; // should recompute, since props.data is changed
			  //     \}
			  //
			  //     render() \{
			  //       renderCount++;
			  //       return <span onClick=\{stuff\}>\{this.props.data.y\}-\{this.computed\}</span>
			  //     \}
			  //   \}
			  //
			  //   const Parent = observer(createClass(\{
			  //     render() \{
			  //       let data = \{ y : this.props.odata.x \}
			  //       return <Com data=\{data\} odata=\{this.props.odata\} />
			  //     \}
			  //   \}))
			  //
			  //   function stuff() \{
			  //     odata.x++;
			  //   \}
			  //
			  //   render(<Parent odata=\{odata\} />, container);
			  //   expect(renderCount).toBe(1) // 'renderCount === 1');
			  //   expect(container.querySelector("span").textContent).toBe("1-1");
			  //
			  //   container.querySelector("span").click();
			  //   setTimeout(() => \{
			  //     expect(renderCount).toBe(2) // 'renderCount === 2');
			  //     expect(container.querySelector("span").textContent).toBe("2-2");
			  //
			  //     container.querySelector("span").click();
			  //     setTimeout(() => \{
			  //       expect(renderCount).toBe(3) // 'renderCount === 3');
			  //       expect(container.querySelector("span").textContent).toBe("3-3");
			  //
			  //       done();
			  //     \}, 10);
			  //   \}, 20);
			  // \})
			
			  it('Observer regions should react', (done) => \{
			    const data = observable.box('hi');
			    const Comp = () => (
			      <div>
			        <Observer>\{() => <span>\{data.get()\}</span>\}</Observer>
			        <li>\{data.get()\}</li>
			      </div>
			    );
			    render(<Comp />, container);
			
			    expect(container.querySelector('span').textContent).toBe('hi');
			    expect(container.querySelector('li').textContent).toBe('hi');
			
			    data.set('hello');
			    expect(container.querySelector('span').textContent).toBe('hello');
			    expect(container.querySelector('li').textContent).toBe('hi');
			    done();
			  \});
			
			  it('Observer should not re-render on shallow equal new props', () => \{
			    let childRendering = 0;
			    let parentRendering = 0;
			    const data = \{ x: 1 \};
			    const odata = observable(\{ y: 1 \});
			
			    const Child = observer((\{ data \}) => \{
			      childRendering++;
			      return <span>\{data.x\}</span>;
			    \});
			    const Parent = observer(() => \{
			      parentRendering++;
			      odata.y; /// depend
			      return <Child data=\{data\} />;
			    \});
			
			    render(<Parent />, container);
			    expect(parentRendering).toBe(1);
			    expect(childRendering).toBe(1);
			    expect(container.querySelector('span').textContent).toBe('1');
			
			    odata.y++;
			    expect(parentRendering).toBe(2);
			    expect(childRendering).toBe(1);
			    expect(container.querySelector('span').textContent).toBe('1');
			  \});
			
			  it('observer should throw on new life cycle hooks', () => \{
			    class A extends Component \{
			      static getDerivedStateFromProps() \{
			        return \{\};
			      \}
			    \}
			    expect(() => observer(A)).toThrow();
			    class B extends Component \{
			      getSnapshotBeforeUpdate() \{
			        return \{\};
			      \}
			    \}
			    expect(() => observer(B)).toThrow();
			    expect(() =>
			      observer(\{
			        render: () => undefined,
			        getSnapshotBeforeUpdate: () => \{
			          return \{\};
			        \}
			      \})
			    ).toThrow();
			  \});
			
			  it('observer should send exception to errorsReporter and re-thrown', () => \{
			    const exception = new Error('dummy error');
			    let reported;
			    const off = onError((error) => \{
			      reported = error;
			    \});
			    class Faulty extends Component \{
			      render() \{
			        throw exception;
			      \}
			    \}
			    observer(Faulty);
			    expect(() => \{
			      render(<Faulty />, container);
			    \}).toThrow(exception);
			    expect(reported).toEqual(exception);
			    off();
			  \});
			
			  // TODO: Reaction Scheduler
			  // it('parent / childs render in the right order', done => \{
			  //   // See: https://jsfiddle.net/gkaemmer/q1kv7hbL/13/
			  //   let events = []
			  //
			  //   let ostore = observable(\{
			  //     user: observable(\{ name: 'tester' \}),
			  //     logout() \{
			  //       this.user = null;
			  //     \}
			  //   \})
			  //
			  //   // var OUser = observable(class User \{
			  //   //   name = "Tester"
			  //   // \});
			  //   //
			  //   // // class User \{
			  //   // //   @observable name = "Tester";
			  //   // // \}
			  //   //
			  //   // var OStore = observable(class Store \{
			  //   //   user = new OUser();
			  //   //   @action logout() \{
			  //   //     this.user = null;
			  //   //   \}
			  //   // \});
			  //
			  //   function tryLogout() \{
			  //     console.log("Logging out...");
			  //     // try \{
			  //       // ReactDOM.unstable_batchedUpdates(() => \{
			  //       ostore.logout();
			  //       // \});
			  //     // \} catch(e) \{
			  //     //   throw Error('failure');
			  //     // \}
			  //   \}
			  //   //
			  //   // const store = OStore();
			  //   expect(ostore.user.name).toBe('tester');
			  //
			  //   const Parent = observer(() => \{
			  //     events.push("parent")
			  //     if (!ostore.user)
			  //       return <span>Not logged in.</span>;
			  //     return <div>
			  //       <Child />
			  //       <button onClick=\{tryLogout\}>Logout</button>
			  //     </div>;
			  //   \});
			  //
			  //   const Child = observer(() => \{
			  //     events.push("child")
			  //     return <span>Logged in as: \{ostore.user.name\}</span>;
			  //   \});
			  //
			  //   render(<Parent />, container)
			  //   expect(container.textContent).toBe('Logged in as: testerLogout');
			  //   tryLogout();
			  //   expect(container.textContent).toBe('wqd');
			  //   expect(events).toEqual(["parent", "child", "parent"])
			  //   done()
			  //
			  // \})
			  //
			  //
			  // it('206 - @observer should produce usefull errors if it throws', done => \{
			  //   const data = observable(\{x : 1\})
			  //   let renderCount = 0;
			  //
			  //   const emmitedErrors = [];
			  //   const disposeErrorsHandler = onError(error => emmitedErrors.push(error));
			  //
			  //   @observer
			  //   class Child extends Component \{
			  //     render() \{
			  //       renderCount++;
			  //       if (data.x === 42)
			  //         throw new Error("Oops!")
			  //       return <span>\{data.x\}</span>;
			  //     \}
			  //   \}
			  //
			  //   render(<Child />, container);
			  //   expect(renderCount).toBe(1);
			  //
			  //   try \{
			  //     data.x = 42;
			  //     throw Error('should fail before this line');
			  //   \} catch (e) \{
			  //     const lines = e.stack.split("\\n");
			  //     expect(lines[0]).toBe("Error: Oops!");
			  //     expect(lines[1].indexOf("at Child.render")).toBe(4);
			  //     expect(renderCount).toBe(2);
			  //   \}
			  //
			  //   data.x = 3; // component recovers!
			  //   expect(renderCount).toBe(3);
			  //
			  //   expect(emmitedErrors).toEqual([new Error("Oops!")]);
			  //   disposeErrorsHandler();
			  //   done();
			  // \});
			  //
			  // it('195 - async componentWillMount does not work', done => \{
			  //   const renderedValues = []
			  //
			  //   @observer
			  //   class WillMount extends Component \{
			  //     @observable counter = 0
			  //
			  //     @action inc = () => this.counter++
			  //
			  //     componentWillMount() \{
			  //       setTimeout(() => this.inc(), 300)
			  //     \}
			  //
			  //     render() \{
			  //       renderedValues.push(this.counter)
			  //       return <p>\{this.counter\}<button onClick=\{this.inc\}>+</button></p>
			  //     \}
			  //   \}
			  //
			  //   render(<WillMount />, container);
			  //
			  //   setTimeout(() => \{
			  //     expect(renderedValues).toEqual([0, 1])
			  //     done()
			  //   \}, 500)
			  // \})
			  //
			  //
			  // test.skip('195 - should throw if trying to overwrite lifecycle methods', done => \{
			  //   // Test disabled, see #231...
			  //
			  //   @observer
			  //   class WillMount extends Component \{
			  //     componentWillMount = () => \{
			  //     \}
			  //
			  //     render() \{
			  //       return null;
			  //     \}
			  //   \}
			  //
			  //   try \{
			  //     render(<WillMount />, container);
			  //   \} catch (e) \{
			  //     expect(e.message).toBe("Cannot assign to read only property 'componentWillMount'");
			  //     done();
			  //   \}
			  // \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\observer.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(13)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\observerPatch.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ getObserverTree, observable, runInAction \} from 'mobx';
			import \{ inject, observer, observerPatch \} from 'inferno-mobx';
			import \{ createClass \} from 'inferno-create-class';
			
			describe('Mobx Observer Patch', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('nestedRendering', () => \{
			    const store = observable(\{
			      todos: [
			        \{
			          title: 'a',
			          completed: false
			        \}
			      ]
			    \});
			
			    let todoItemRenderings = 0;
			    class TodoItem extends Component \{
			      render(\{ todo \}) \{
			        todoItemRenderings++;
			        return <li>|\{todo.title\}</li>;
			      \}
			      shouldComponentUpdate(\{ todo: \{ title \} \}) \{
			        return title !== this.props.todo.title;
			      \}
			    \}
			
			    observerPatch(TodoItem);
			
			    let todoListRenderings = 0;
			    let todoListWillReactCount = 0;
			    const TodoList = createClass(\{
			      componentWillReact() \{
			        todoListWillReactCount++;
			      \},
			      render() \{
			        todoListRenderings++;
			        const todos = store.todos;
			        return (
			          <div>
			            <hi>\{todos.length\}</hi>
			            \{todos.map((todo, idx) => (
			              <TodoItem key=\{idx\} todo=\{todo\} />
			            ))\}
			          </div>
			        );
			      \}
			    \});
			
			    observerPatch(TodoList);
			
			    render(<TodoList />, container);
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(todoListWillReactCount).toEqual(0); //, 'should never call componentWillReact')
			    expect(container.querySelectorAll('li').length).toEqual(1);
			    expect(container.querySelector('li').textContent).toEqual('|a');
			
			    expect(todoItemRenderings).toEqual(1); // 'item1 should render once'
			
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1);
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1);
			
			    store.todos[0].title += 'a';
			
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(todoListWillReactCount).toEqual(0); //, 'should never call componentWillReact')
			    expect(todoItemRenderings).toEqual(2); //, 'item1 should have rendered twice');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			
			    store.todos.push(\{
			      title: 'b',
			      completed: true
			    \});
			
			    expect(container.querySelectorAll('li').length).toBe(2); //, 'list should two items in in the list');
			    const expectedOutput = [];
			    const nodes = container.querySelectorAll('li');
			
			    for (let i = 0; i < nodes.length; i++) \{
			      expectedOutput.push(nodes[i].textContent);
			    \}
			    expect(expectedOutput).toEqual(['|aa', '|b']);
			
			    expect(todoListRenderings).toBe(2); //'should have rendered list twice');
			    expect(todoListWillReactCount).toBe(0); //, 'should never call componentWillReact')
			    expect(todoItemRenderings).toBe(3); //, 'item2 should have rendered as well');
			    expect(getObserverTree(store.todos[1], 'title').observers.length).toBe(1); //, 'title observers should have increased');
			    expect(getObserverTree(store.todos[1], 'completed').observers).not.toBeDefined(); //, 'completed observers should not have increased');
			
			    const oldTodo = store.todos.pop();
			
			    expect(todoListRenderings).toBe(3); //, 'should have rendered list another time');
			    expect(todoListWillReactCount).toBe(0); //, 'should never call componentWillReact')
			    expect(todoItemRenderings).toBe(3); //, 'item1 should not have rerendered');
			    expect(container.querySelectorAll('li').length).toBe(1); //, 'list should have only on item in list now');
			    expect(getObserverTree(oldTodo, 'title').observers).not.toBeDefined(); //, 'title observers should have decreased');
			    expect(getObserverTree(oldTodo, 'completed').observers).not.toBeDefined(); //, 'completed observers should not have decreased');
			  \});
			
			  it('keep views alive', () => \{
			    let yCalcCount = 0;
			    const data = observable(\{
			      x: 3,
			      get y() \{
			        yCalcCount++;
			        return this.x * 2;
			      \},
			      z: 'hi'
			    \});
			
			    class TestComponent extends Component \{
			      render() \{
			        return (
			          <div>
			            \{data.z\}
			            \{data.y\}
			          </div>
			        );
			      \}
			    \}
			    observerPatch(TestComponent);
			
			    render(<TestComponent />, container);
			    expect(yCalcCount).toBe(1);
			    expect(container.textContent).toBe('hi6');
			
			    data.z = 'hello';
			    // test: rerender should not need a recomputation of data.y because the subscription is kept alive
			
			    expect(yCalcCount).toBe(1);
			
			    expect(container.textContent).toBe('hello6');
			    expect(yCalcCount).toBe(1);
			
			    expect(getObserverTree(data, 'y').observers.length).toBe(1);
			
			    render(<div />, container);
			
			    expect(getObserverTree(data, 'y').observers).not.toBeDefined();
			  \});
			
			  it('patched render is run first', (done) => \{
			    let origRenderMethod;
			    const Comp = createClass(\{
			      render() \{
			        // ugly check, but proofs that observer.willmount has run
			        // We cannot use function.prototype.name here like in react-redux tests because it is not supported in Edge/IE
			        expect(this.render).not.toBe(origRenderMethod);
			        return null;
			      \}
			    \});
			    origRenderMethod = Comp.prototype.render;
			
			    observerPatch(Comp);
			    render(<Comp />, container);
			    done();
			  \});
			
			  it('issue 12', function () \{
			    const data = observable(\{
			      selected: 'coffee',
			      items: [
			        \{
			          name: 'coffee'
			        \},
			        \{
			          name: 'tea'
			        \}
			      ]
			    \});
			
			    /** Row Class */
			    class Row extends Component \{
			      constructor(props) \{
			        super(props);
			      \}
			
			      render() \{
			        return (
			          <span>
			            \{this.props.item.name\}
			            \{data.selected === this.props.item.name ? '!' : ''\}
			          </span>
			        );
			      \}
			    \}
			
			    /** table stateles component */
			    class Table extends Component \{
			      render() \{
			        return (
			          <div>
			            \{data.items.map((item) => (
			              <Row key=\{item.name\} item=\{item\} />
			            ))\}
			          </div>
			        );
			      \}
			    \}
			    observerPatch(Table);
			
			    render(<Table />, container);
			
			    expect(container.querySelector('div').textContent).toBe('coffee!tea');
			
			    runInAction(() => \{
			      data.items[1].name = 'boe';
			      data.items.splice(0, 2, \{ name: 'soup' \});
			      data.selected = 'tea';
			    \});
			
			    expect(container.querySelector('div').textContent).toBe('soup');
			  \});
			
			  it('component should not be inject', function (done) \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    const Foo = inject('foo')(
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    observerPatch(Foo);
			
			    expect(msg.length).toBe(1);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('component should not be observer', function (done) \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    const Foo = observer(
			      createClass(\{
			        render() \{
			          return (
			            <div>
			              context:
			              \{this.props.foo\}
			            </div>
			          );
			        \}
			      \})
			    );
			    observerPatch(Foo);
			
			    expect(msg.length).toBe(1);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('component should not be already be patched', function (done) \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    const Foo = createClass(\{
			      render() \{
			        return (
			          <div>
			            context:
			            \{this.props.foo\}
			          </div>
			        );
			      \}
			    \});
			    observerPatch(Foo);
			    observerPatch(Foo);
			
			    expect(msg.length).toBe(1);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('observer component can be injected', (done) => \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    const fooA = createClass(\{
			      render: () => null
			    \});
			    observerPatch(fooA);
			    inject('foo')(fooA);
			
			    // N.B, the injected component will be observer since mobx-react 4.0!
			    const fooB = createClass(\{
			      render: () => null
			    \});
			    observerPatch(fooB);
			    inject(() => \{\})(fooB);
			
			    expect(msg.length).toBe(0);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('should do warn when a patching a class extended from a patched class', (done) => \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    class fooA extends Component \{
			      render() \{
			        return <p>Foo A</p>;
			      \}
			    \}
			    observerPatch(fooA);
			
			    class fooB extends fooA \{
			      render() \{
			        return <p>Foo B</p>;
			      \}
			    \}
			    observerPatch(fooB);
			
			    expect(msg.length).toBe(1);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('should render component even if setState called with exactly the same props', function (done) \{
			    let renderCount = 0;
			    const Component = createClass(\{
			      onClick() \{
			        this.setState(\{\});
			      \},
			      render() \{
			        renderCount++;
			        return <div onClick=\{this.onClick\} id="clickableDiv" />;
			      \}
			    \});
			    observerPatch(Component);
			    render(<Component />, container);
			
			    expect(renderCount).toBe(1); //'renderCount === 1');
			    container.querySelector('#clickableDiv').click();
			    expect(renderCount).toBe(2); // 'renderCount === 2');
			    container.querySelector('#clickableDiv').click();
			    expect(renderCount).toBe(3); //'renderCount === 3');
			    done();
			  \});
			
			  it('observerPatch should keep MobX from eating exceptions', () => \{
			    const exception = new Error('dummy error');
			    class Faulty extends Component \{
			      render() \{
			        throw exception;
			      \}
			    \}
			    observerPatch(Faulty);
			    expect(() => \{
			      render(<Faulty />, container);
			    \}).toThrow(exception);
			  \});
			
			  // it('it rerenders correctly if some props are non-observables - 1', done => \{
			  //   let renderCount = 0;
			  //   let odata = observable(\{ x: 1 \})
			  //   let data = \{ y : 1 \}
			  //
			  //   @observer class Com extends Component \{
			  //     @computed get computed () \{
			  //       // n.b: data.y would not rerender! shallowly new equal props are not stored
			  //       return this.props.odata.x;
			  //     \}
			  //     render() \{
			  //       renderCount++;
			  //       return <span onClick=\{stuff\} >\{this.props.odata.x\}-\{this.props.data.y\}-\{this.computed\}</span>
			  //     \}
			  //   \}
			  //
			  //   const Parent = observer(createClass(\{
			  //     render() \{
			  //       // this.props.odata.x;
			  //       return <Com data=\{this.props.data\} odata=\{this.props.odata\} />
			  //     \}
			  //   \}))
			  //
			  //   function stuff() \{
			  //     data.y++;
			  //     odata.x++;
			  //   \}
			  //
			  //   render(<Parent odata=\{odata\} data=\{data\} />, container);
			  //
			  //   expect(renderCount).toBe(1) // 'renderCount === 1');
			  //   expect(container.querySelector("span").textContent).toBe("1-1-1");
			  //
			  //   container.querySelector("span").click();
			  //   setTimeout(() => \{
			  //     expect(renderCount).toBe(2) // 'renderCount === 2');
			  //     expect(container.querySelector("span").textContent).toBe("2-2-2");
			  //
			  //     container.querySelector("span").click();
			  //     setTimeout(() => \{
			  //       expect(renderCount).toBe(3) // 'renderCount === 3');
			  //       expect(container.querySelector("span").textContent).toBe("3-3-3");
			  //
			  //       done();
			  //     \}, 10);
			  //   \}, 20);
			  // \});
			
			  // it('it rerenders correctly if some props are non-observables - 2', done => \{
			  //   let renderCount = 0;
			  //   let odata = observable(\{ x: 1 \})
			  //
			  //   @observer class Com extends Component \{
			  //     @computed get computed () \{
			  //       return this.props.data.y; // should recompute, since props.data is changed
			  //     \}
			  //
			  //     render() \{
			  //       renderCount++;
			  //       return <span onClick=\{stuff\}>\{this.props.data.y\}-\{this.computed\}</span>
			  //     \}
			  //   \}
			  //
			  //   const Parent = observer(createClass(\{
			  //     render() \{
			  //       let data = \{ y : this.props.odata.x \}
			  //       return <Com data=\{data\} odata=\{this.props.odata\} />
			  //     \}
			  //   \}))
			  //
			  //   function stuff() \{
			  //     odata.x++;
			  //   \}
			  //
			  //   render(<Parent odata=\{odata\} />, container);
			  //   expect(renderCount).toBe(1) // 'renderCount === 1');
			  //   expect(container.querySelector("span").textContent).toBe("1-1");
			  //
			  //   container.querySelector("span").click();
			  //   setTimeout(() => \{
			  //     expect(renderCount).toBe(2) // 'renderCount === 2');
			  //     expect(container.querySelector("span").textContent).toBe("2-2");
			  //
			  //     container.querySelector("span").click();
			  //     setTimeout(() => \{
			  //       expect(renderCount).toBe(3) // 'renderCount === 3');
			  //       expect(container.querySelector("span").textContent).toBe("3-3");
			  //
			  //       done();
			  //     \}, 10);
			  //   \}, 20);
			  // \})
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\observerPatch.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(11)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\observerWrap.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ inject, observer, observerWrap \} from 'inferno-mobx';
			import \{ createElement \} from 'inferno-create-element';
			import \{ getObserverTree, observable, runInAction \} from 'mobx';
			
			const stateLessComp = (\{ testProp \}) => <div>result: \{testProp\}</div>;
			
			stateLessComp.defaultProps = \{
			  testProp: 'default value for prop testProp'
			\};
			
			describe('Stateless components observerWrap', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('stateless component', (done) => \{
			    const StatelessCompObserver = observerWrap(stateLessComp);
			    expect(StatelessCompObserver.defaultProps.testProp).toBe('default value for prop testProp');
			    const wrapper = <StatelessCompObserver testProp=\{10\} />;
			
			    render(<StatelessCompObserver testProp="hello world" />, container);
			
			    expect(container.textContent).toBe('result: hello world');
			    done();
			  \});
			
			  it('stateless component with context support', () => \{
			    const InnerComp = (_props, context) => createElement('p', \{\}, 'inner: ' + context.testContext);
			    const StateLessCompWithContext = (\{ store: \{ value \} \}, context) => \{
			      return createElement('div', \{\}, [
			        createElement('p', \{\}, 'value: ' + value + ', '),
			        createElement('p', \{\}, 'outer: ' + context.testContext + ', '),
			        createElement(InnerComp, \{\})
			      ]);
			    \};
			    const StateLessCompWithContextObserver = observerWrap(StateLessCompWithContext);
			    const store = observable(\{
			      value: 0
			    \});
			    class ContextProvider extends Component \{
			      getChildContext() \{
			        return \{ testContext: 'hello' \};
			      \}
			      render() \{
			        return <StateLessCompWithContextObserver store=\{store\} />;
			      \}
			    \}
			    render(<ContextProvider />, container);
			    expect(container.textContent.replace(/\\n/, '')).toBe('value: 0, outer: hello, inner: hello');
			    store.value = 1;
			    expect(container.textContent.replace(/\\n/, '')).toBe('value: 1, outer: hello, inner: hello');
			  \});
			
			  it('nestedRendering', () => \{
			    const store = observable(\{
			      todos: [
			        \{
			          title: 'a',
			          completed: false
			        \}
			      ]
			    \});
			
			    let todoItemRenderings = 0;
			    let todoItemUnmounts = 0;
			    let todoItemUpdates = 0;
			    let todoItemWillUpdates = 0;
			    const TodoItemBase = (\{ todo \}) => \{
			      todoItemRenderings++;
			      return <li>|\{todo.title\}</li>;
			    \};
			    TodoItemBase.defaultHooks = \{
			      onComponentDidUpdate: () => \{
			        todoItemUpdates++;
			      \},
			      onComponentShouldUpdate: (\{ todo: \{ title: prev \} \}, \{ todo: \{ title: next \} \}) => \{
			        return prev !== next;
			      \},
			      onComponentWillUnmount: () => \{
			        todoItemUnmounts++;
			      \},
			      onComponentWillUpdate: () => \{
			        todoItemWillUpdates++;
			      \}
			    \};
			    const TodoItem = observerWrap(TodoItemBase);
			
			    let todoListRenderings = 0;
			    const TodoList = observerWrap(() => \{
			      todoListRenderings++;
			      const todos = store.todos;
			      return (
			        <div>
			          <p>\{todos.length\}</p>
			          \{todos.map((todo, idx) => (
			            <TodoItem key=\{idx\} todo=\{todo\} />
			          ))\}
			        </div>
			      );
			    \});
			
			    render(<TodoList />, container);
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(container.querySelectorAll('li').length).toEqual(1);
			    expect(container.querySelector('li').textContent).toEqual('|a');
			
			    expect(todoItemRenderings).toEqual(1); // 'item1 should render once'
			
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1);
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1);
			
			    store.todos[0].title += 'a';
			
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(todoItemRenderings).toEqual(2); //, 'item1 should have rendered twice');
			    expect(container.querySelector('li').textContent).toEqual('|aa');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			
			    store.todos.push(\{
			      title: 'b',
			      completed: true
			    \});
			
			    expect(container.querySelectorAll('li').length).toBe(2); //, 'list should two items in in the list');
			    let expectedOutput = [];
			    let nodes = container.querySelectorAll('li');
			
			    for (let i = 0; i < nodes.length; i++) \{
			      expectedOutput.push(nodes[i].textContent);
			    \}
			    expect(expectedOutput).toEqual(['|aa', '|b']);
			
			    expect(todoListRenderings).toBe(2); //'should have rendered list twice');
			    expect(todoItemRenderings).toBe(3); //, 'item2 should have rendered as well');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			    expect(getObserverTree(store.todos[1], 'title').observers.length).toBe(1); //, 'title observers should have increased');
			    expect(getObserverTree(store.todos[1], 'completed').observers).not.toBeDefined(); //, 'completed observers should not have increased');
			
			    store.todos[1].title += 'b';
			
			    expect(container.querySelectorAll('li').length).toBe(2); //, 'list should two items in in the list');
			    expectedOutput = [];
			    nodes = container.querySelectorAll('li');
			
			    for (let i = 0; i < nodes.length; i++) \{
			      expectedOutput.push(nodes[i].textContent);
			    \}
			    expect(expectedOutput).toEqual(['|aa', '|bb']);
			
			    expect(todoListRenderings).toBe(2); //'should have rendered list twice');
			    expect(todoItemRenderings).toBe(4); //, 'item2 should have rendered as well');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			    expect(getObserverTree(store.todos[1], 'title').observers.length).toBe(1); //, 'title observers should have increased');
			    expect(getObserverTree(store.todos[1], 'completed').observers).not.toBeDefined(); //, 'completed observers should not have increased');
			
			    const oldTodo = store.todos.pop();
			
			    expect(todoListRenderings).toBe(3); //, 'should have rendered list another time');
			    expect(todoItemRenderings).toBe(4); //, 'item1 should not have rerendered');
			    expect(container.querySelectorAll('li').length).toBe(1); //, 'list should have only on item in list now');
			    expect(getObserverTree(oldTodo, 'title').observers).not.toBeDefined(); //, 'title observers should have decreased');
			    expect(getObserverTree(oldTodo, 'completed').observers).not.toBeDefined(); //, 'completed observers should not have decreased');
			    render(null, container);
			    expect(todoItemUnmounts).toBe(2);
			    expect(todoItemUpdates).toBe(2);
			    expect(todoItemWillUpdates).toBe(2);
			    expect(getObserverTree(store, 'todos').observers).not.toBeDefined();
			    expect(getObserverTree(store.todos[0], 'title').observers).not.toBeDefined();
			  \});
			
			  it('nestedRendering without should update hook', () => \{
			    const store = observable(\{
			      todos: [
			        \{
			          title: 'a',
			          completed: false
			        \}
			      ]
			    \});
			
			    let todoItemRenderings = 0;
			    let todoItemUnmounts = 0;
			    let todoItemUpdates = 0;
			    let todoItemWillUpdates = 0;
			    const TodoItemBase = (\{ todo \}) => \{
			      todoItemRenderings++;
			      return <li>|\{todo.title\}</li>;
			    \};
			    TodoItemBase.defaultHooks = \{
			      onComponentDidUpdate: () => \{
			        todoItemUpdates++;
			      \},
			      onComponentWillUnmount: () => \{
			        todoItemUnmounts++;
			      \},
			      onComponentWillUpdate: () => \{
			        todoItemWillUpdates++;
			      \}
			    \};
			    const TodoItem = observerWrap(TodoItemBase);
			
			    let todoListRenderings = 0;
			    const TodoList = observerWrap(() => \{
			      todoListRenderings++;
			      const todos = store.todos;
			      return (
			        <div>
			          <p>\{todos.length\}</p>
			          \{todos.map((todo, idx) => (
			            <TodoItem key=\{idx\} todo=\{todo\} />
			          ))\}
			        </div>
			      );
			    \});
			
			    render(<TodoList />, container);
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(container.querySelectorAll('li').length).toEqual(1);
			    expect(container.querySelector('li').textContent).toEqual('|a');
			
			    expect(todoItemRenderings).toEqual(1); // 'item1 should render once'
			
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1);
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1);
			
			    store.todos[0].title += 'a';
			
			    expect(todoListRenderings).toEqual(1); //, 'should have rendered list once');
			    expect(todoItemRenderings).toEqual(2); //, 'item1 should have rendered twice');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			
			    store.todos.push(\{
			      title: 'b',
			      completed: true
			    \});
			
			    expect(container.querySelectorAll('li').length).toBe(2); //, 'list should two items in in the list');
			    let expectedOutput = [];
			    let nodes = container.querySelectorAll('li');
			
			    for (let i = 0; i < nodes.length; i++) \{
			      expectedOutput.push(nodes[i].textContent);
			    \}
			    expect(expectedOutput).toEqual(['|aa', '|b']);
			
			    expect(todoListRenderings).toBe(2); //'should have rendered list twice');
			    expect(todoItemRenderings).toBe(4); //, 'item2 should have rendered as well');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			    expect(getObserverTree(store.todos[1], 'title').observers.length).toBe(1); //, 'title observers should have increased');
			    expect(getObserverTree(store.todos[1], 'completed').observers).not.toBeDefined(); //, 'completed observers should not have increased');
			
			    store.todos[1].title += 'b';
			
			    expect(container.querySelectorAll('li').length).toBe(2); //, 'list should two items in in the list');
			    expectedOutput = [];
			    nodes = container.querySelectorAll('li');
			
			    for (let i = 0; i < nodes.length; i++) \{
			      expectedOutput.push(nodes[i].textContent);
			    \}
			    expect(expectedOutput).toEqual(['|aa', '|bb']);
			
			    expect(todoListRenderings).toBe(2); //'should have rendered list twice');
			    expect(todoItemRenderings).toBe(5); //, 'item2 should have rendered as well');
			    expect(getObserverTree(store, 'todos').observers.length).toBe(1); //, 'observers count shouldn\\'t change');
			    expect(getObserverTree(store.todos[0], 'title').observers.length).toBe(1); //, 'title observers should not have increased');
			    expect(getObserverTree(store.todos[1], 'title').observers.length).toBe(1); //, 'title observers should have increased');
			    expect(getObserverTree(store.todos[1], 'completed').observers).not.toBeDefined(); //, 'completed observers should not have increased');
			
			    const oldTodo = store.todos.pop();
			
			    expect(todoListRenderings).toBe(3); //, 'should have rendered list another time');
			    expect(todoItemRenderings).toBe(6); //, 'item1 should not have rerendered');
			    expect(container.querySelectorAll('li').length).toBe(1); //, 'list should have only on item in list now');
			    expect(getObserverTree(oldTodo, 'title').observers).not.toBeDefined(); //, 'title observers should have decreased');
			    expect(getObserverTree(oldTodo, 'completed').observers).not.toBeDefined(); //, 'completed observers should not have decreased');
			    render(null, container);
			    expect(todoItemUnmounts).toBe(2);
			    expect(todoItemUpdates).toBe(4);
			    expect(todoItemWillUpdates).toBe(4);
			    expect(getObserverTree(store, 'todos').observers).not.toBeDefined();
			    expect(getObserverTree(store.todos[0], 'title').observers).not.toBeDefined();
			  \});
			
			  it('keep views alive', () => \{
			    let yCalcCount = 0;
			    const data = observable(\{
			      x: 3,
			      get y() \{
			        yCalcCount++;
			        return this.x * 2;
			      \},
			      z: 'hi'
			    \});
			
			    const TestComponent = observerWrap(() => \{
			      return (
			        <div>
			          \{data.z\}
			          \{data.y\}
			        </div>
			      );
			    \});
			
			    render(<TestComponent />, container);
			    expect(yCalcCount).toBe(1);
			    expect(container.textContent).toBe('hi6');
			
			    data.z = 'hello';
			    // test: rerender should not need a recomputation of data.y because the subscription is kept alive
			
			    expect(yCalcCount).toBe(1);
			
			    expect(container.textContent).toBe('hello6');
			    expect(yCalcCount).toBe(1);
			
			    expect(getObserverTree(data, 'y').observers.length).toBe(1);
			
			    render(<div />, container);
			
			    expect(getObserverTree(data, 'y').observers).not.toBeDefined();
			  \});
			
			  it('issue 12', function () \{
			    const data = observable(\{
			      selected: 'coffee',
			      items: [
			        \{
			          name: 'coffee'
			        \},
			        \{
			          name: 'tea'
			        \}
			      ]
			    \});
			
			    const Row = observerWrap((\{ item \}) => \{
			      return (
			        <span>
			          \{item.name\}
			          \{data.selected === item.name ? '!' : ''\}
			        </span>
			      );
			    \});
			
			    const Table = observerWrap(() => \{
			      return (
			        <div>
			          \{data.items.map((item) => (
			            <Row key=\{item.name\} item=\{item\} />
			          ))\}
			        </div>
			      );
			    \});
			
			    render(<Table />, container);
			
			    expect(container.querySelector('div').textContent).toBe('coffee!tea');
			
			    runInAction(() => \{
			      data.items[1].name = 'boe';
			      data.items.splice(0, 2, \{ name: 'soup' \});
			      data.selected = 'tea';
			    \});
			
			    expect(container.querySelector('div').textContent).toBe('soup');
			  \});
			
			  it('Callbacks are bound on render', function () \{
			    const data = observable(\{
			      name: 'tea'
			    \});
			
			    let a = 0;
			    let x = 0;
			    let y = 0;
			    let z = 0;
			
			    const ViewFn = (\{ item \}) => \{
			      return <span>\{item.name\}</span>;
			    \};
			
			    const View = observerWrap(ViewFn);
			
			    const check = (\{ item: prev \}, \{ item: next \}) => prev !== next;
			
			    render(<View item=\{data\} onComponentWillUpdate=\{(p, n) => (p !== n ? a++ : x++)\} />, container);
			
			    expect(a).toBe(0);
			    expect(x).toBe(0);
			
			    runInAction(() => \{
			      data.name = 'coffee';
			    \});
			
			    expect(x).toBe(1);
			
			    render(<View item=\{data\} onComponentWillUpdate=\{(p, n) => (p !== n ? a++ : y++)\} />, container);
			
			    expect(a).toBe(1);
			    expect(x).toBe(1);
			    expect(y).toBe(0);
			
			    runInAction(() => \{
			      data.name = 'soda';
			    \});
			
			    expect(a).toBe(1);
			    expect(x).toBe(1);
			    expect(y).toBe(1);
			
			    render(<View item=\{data\} onComponentWillUpdate=\{(p, n) => (p !== n ? a++ : z++)\} onComponentShouldUpdate=\{check\} />, container);
			
			    expect(a).toBe(1);
			    expect(z).toBe(0);
			    expect(y).toBe(1);
			
			    runInAction(() => \{
			      data.name = 'water';
			    \});
			
			    expect(y).toBe(2);
			
			    render(<View item=\{data\} onComponentWillUpdate=\{(p, n) => (p !== n ? a++ : x++)\} />, container);
			
			    expect(a).toBe(2);
			    expect(x).toBe(1);
			    expect(y).toBe(2);
			
			    runInAction(() => \{
			      data.name = 'juice';
			    \});
			
			    expect(a).toBe(2);
			    expect(y).toBe(2);
			    expect(x).toBe(2);
			  \});
			
			  it('component should not be inject', () => \{
			    const Foo = (\{ foo \}) => \{
			      return (
			        <div>
			          context:
			          \{foo\}
			        </div>
			      );
			    \};
			    // inject wraps in a class component, which will make observerWrap throw
			    expect(() => observerWrap(observer(Foo))).toThrow();
			  \});
			
			  it('component should not be observer', () => \{
			    const Foo = (\{ foo \}) => \{
			      return (
			        <div>
			          context:
			          \{foo\}
			        </div>
			      );
			    \};
			    // observer wraps in a class component, which will make observerWrap throw
			    expect(() => observerWrap(observer(Foo))).toThrow();
			  \});
			
			  it('component should not be already be wrapped', () => \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    observerWrap(
			      observerWrap((\{ foo \}) => \{
			        return (
			          <div>
			            context:
			            \{foo\}
			          </div>
			        );
			      \})
			    );
			
			    expect(msg.length).toBe(1);
			    console.error = baseWarn;
			  \});
			
			  it('observer component can be injected', (done) => \{
			    const msg = [];
			    const baseWarn = console.error;
			    console.error = (m) => msg.push(m);
			
			    const fooA = inject('foo')(observerWrap(() => null));
			
			    render(<fooA />, container);
			
			    // N.B, the injected component will be observer since mobx-react 4.0!
			    const fooB = inject(() => \{\})(observerWrap(() => null));
			
			    expect(msg.length).toBe(0);
			    console.error = baseWarn;
			    done();
			  \});
			
			  it('observerWrap should keep MobX from eating exceptions', () => \{
			    const exception = new Error('dummy error');
			    const Faulty = observerWrap(() => \{
			      throw exception;
			    \});
			    expect(() => \{
			      render(<Faulty />, container);
			    \}).toThrow(exception);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\observerWrap.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(12)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\stateless.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ observer \} from 'inferno-mobx';
			import \{ createClass \} from 'inferno-create-class';
			import \{ createElement \} from 'inferno-create-element';
			
			const stateLessComp = (\{ testProp \}) => <div>result: \{testProp\}</div>;
			
			stateLessComp.defaultProps = \{
			  testProp: 'default value for prop testProp'
			\};
			
			describe('Stateless components MOBX', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('stateless component', (done) => \{
			    const StatelessCompObserver = observer(stateLessComp);
			    expect(StatelessCompObserver.defaultProps.testProp).toBe('default value for prop testProp');
			    const wrapper = <StatelessCompObserver testProp=\{10\} />;
			
			    render(<StatelessCompObserver testProp="hello world" />, container);
			
			    expect(container.textContent).toBe('result: hello world');
			    done();
			  \});
			
			  it('stateless component with context support', (done) => \{
			    const StateLessCompWithContext = (props, context) => createElement('div', \{\}, 'context: ' + context.testContext);
			    const StateLessCompWithContextObserver = observer(StateLessCompWithContext);
			    const ContextProvider = createClass(\{
			      getChildContext: () => (\{ testContext: 'hello world' \}),
			      render: () => <StateLessCompWithContextObserver />
			    \});
			    render(<ContextProvider />, container);
			    expect(container.textContent.replace(/\\n/, '')).toBe('context: hello world');
			    done();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\stateless.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\transactions.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ observer \} from 'inferno-mobx';
			import \{ createClass \} from 'inferno-create-class';
			import \{ autorun, computed, observable, runInAction \} from 'mobx';
			
			describe('Mobx Transacations', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('mobx issue 50', () => \{
			    const foo = \{
			      a: observable.box(true),
			      b: observable.box(false),
			      c: computed(function () \{
			        return foo.b.get();
			      \})
			    \};
			    function flipStuff() \{
			      runInAction(() => \{
			        foo.a.set(!foo.a.get());
			        foo.b.set(!foo.b.get());
			      \});
			    \}
			    let asText = '';
			    let willReactCount = 0;
			    autorun(() => (asText = [foo.a.get(), foo.b.get(), foo.c.get()].join(':')));
			    const Test = observer(
			      createClass(\{
			        componentWillReact: () => willReactCount++,
			        render: () => <div id="x">\{[foo.a.get(), foo.b.get(), foo.c.get()].join(',')\}</div>
			      \})
			    );
			
			    render(<Test />, container);
			    // In 3 seconds, flip a and b. This will change c.
			    flipStuff();
			
			    expect(asText).toBe('false:true:true');
			    expect(document.getElementById('x').textContent).toBe('false,true,true');
			    expect(willReactCount).toBe(1);
			  \});
			
			  it('React.render should respect transaction', () => \{
			    const a = observable.box(2);
			    const loaded = observable.box(false);
			    const valuesSeen = [];
			
			    const Component = observer(() => \{
			      valuesSeen.push(a.get());
			      if (loaded.get()) return <div>\{a.get()\}</div>;
			      else return <div>loading</div>;
			    \});
			
			    render(<Component />, container);
			    runInAction(() => \{
			      a.set(3);
			      a.set(4);
			      loaded.set(true);
			    \});
			
			    expect(container.textContent.replace(/\\s+/g, '')).toBe('4');
			    expect(valuesSeen).toEqual([2, 4]);
			  \});
			
			  it('React.render in transaction should succeed', () => \{
			    const a = observable.box(2);
			    const loaded = observable.box(false);
			    const valuesSeen = [];
			    const Component = observer(() => \{
			      valuesSeen.push(a.get());
			      if (loaded.get()) return <div>\{a.get()\}</div>;
			      else return <div>loading</div>;
			    \});
			
			    runInAction(() => \{
			      a.set(3);
			      render(<Component />, container);
			      a.set(4);
			      loaded.set(true);
			    \});
			
			    expect(container.textContent.replace(/\\s+/g, '')).toBe('4');
			    expect(valuesSeen).toEqual([3, 4]);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\transactions.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-mobx\\__tests__\\types.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ Provider \} from 'inferno-mobx';
			import \{ observable \} from 'mobx';
			
			describe('top level context', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  describe('Rendering types', () => \{
			    it('Should render SFC', () => \{
			      // SFC
			      const MyComponent = (props) => \{
			        return <div>\{props.children\}</div>;
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    it('Should be possible to return string from render SFC', () => \{
			      // SFC
			      const MyComponent = () => \{
			        return 'd';
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    it('Should be possible to return number from render SFC', () => \{
			      // SFC
			      const MyComponent = () => \{
			        return 1;
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    it('Should be possible to return null from render SFC', () => \{
			      // SFC
			      const MyComponent = () => \{
			        return null;
			      \};
			
			      render(<MyComponent />, container);
			    \});
			
			    it('Should render Provider', () => \{
			      class MyComponent extends Component \{
			        public render() \{
			          return <div>1</div>;
			        \}
			      \}
			
			      const store = observable(\{
			        todos: [
			          \{
			            completed: false,
			            title: 'a'
			          \}
			        ]
			      \});
			
			      render(
			        <Provider store=\{store\}>
			          <MyComponent />
			        </Provider>,
			        container
			      );
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-mobx\\__tests__\\types.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno-redux\\__tests__\\components\\connect.spec.js', () => {
        const sourceCode = `
			import \{ Component, render as _render, rerender \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			import \{ connect \} from 'inferno-redux';
			import \{ findRenderedVNodeWithType, Wrapper \} from 'inferno-test-utils';
			import \{ createStore \} from 'redux';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('Inferno', () => \{
			  // IE does not support function names so error messages are different
			  const testFunction = function testFunction() \{\};
			  const supportFnName = testFunction.name === 'testFunction';
			  const unmountDOM = (elm) => render(null, elm);
			  let container;
			
			  function render(vNode, container, cb) \{
			    _render(vNode, container, cb);
			
			    if (vNode && vNode.flags & VNodeFlags.Component) \{
			      return vNode.children;
			    \}
			  \}
			
			  beforeEach(() => \{
			    rerender();
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  function renderToContainer(vNode) \{
			    return render(vNode, container);
			  \}
			
			  describe('redux', () => \{
			    class Passthrough extends Component \{
			      render() \{
			        return <div />;
			      \}
			    \}
			
			    class ProviderMock extends Component \{
			      getChildContext() \{
			        return \{ store: this.props.store \};
			      \}
			
			      render() \{
			        return this.props.children;
			      \}
			    \}
			
			    class ContextBoundStore \{
			      constructor(reducer) \{
			        this.reducer = reducer;
			        this.listeners = [];
			        this.state = undefined;
			        this.dispatch(\{\});
			      \}
			
			      getState() \{
			        return this.state;
			      \}
			
			      subscribe(listener) \{
			        let live = true;
			        const call = (...args) => \{
			          if (live) \{
			            listener(...args);
			          \}
			        \};
			        this.listeners.push(call);
			        return () => \{
			          live = false;
			          this.listeners = this.listeners.filter((c) => c !== call);
			        \};
			      \}
			
			      dispatch(action) \{
			        this.state = this.reducer(this.state, action);
			        this.listeners.forEach((l) => l());
			        return action;
			      \}
			    \}
			
			    const stringBuilder = (prev = '', action) => (action.type === 'APPEND' ? prev + action.payload : prev);
			
			    const renderWithBadConnect = (Component) => \{
			      const store = createStore(() => (\{\}));
			
			      try \{
			        renderToContainer(
			          <ProviderMock store=\{store\}>
			            <Component pass="through" />
			          </ProviderMock>
			        );
			
			        return null;
			      \} catch (e) \{
			        return e.message;
			      \}
			    \};
			
			    it('should receive the store in the context', () => \{
			      const store = createStore(() => (\{\}));
			
			      const Container = connect()(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Container pass="through" />
			        </ProviderMock>
			      );
			
			      const container = findRenderedVNodeWithType(tree, Container).children;
			      expect(container.context.store).toBe(store);
			    \});
			
			    it('should pass state and props to the given component', () => \{
			      const store = createStore(() => (\{
			        foo: 'bar',
			        baz: 42,
			        hello: 'world'
			      \}));
			
			      const Container = connect((\{ foo, baz \}) => (\{ foo, baz \}))(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Container pass="through" baz=\{50\} />
			        </ProviderMock>
			      );
			
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(stub.props.pass).toBe('through');
			      expect(stub.props.foo).toBe('bar');
			      expect(stub.props.baz).toBe(42);
			      expect(stub.props.hello).toBe(undefined);
			      findRenderedVNodeWithType(tree, Container);
			    \});
			
			    it('should subscribe class components to the store changes', () => \{
			      const store = createStore(stringBuilder);
			
			      const Container = connect((state) => (\{ string: state \}))(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      const tree = renderToContainer(vNode);
			
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(stub.props.string).toBe('');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(stub.props.string).toBe('a');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'b' \});
			      renderToContainer(vNode);
			      expect(stub.props.string).toBe('ab');
			    \});
			
			    it('should subscribe pure function components to the store changes', () => \{
			      const store = createStore(stringBuilder);
			
			      const Container = connect((state) => (\{
			        string: state
			      \}))(function Container(props) \{
			        return <Passthrough \{...props\} />;
			      \});
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      const tree = renderToContainer(vNode);
			
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(stub.props.string).toBe('');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(stub.props.string).toBe('a');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'b' \});
			      renderToContainer(vNode);
			      expect(stub.props.string).toBe('ab');
			    \});
			
			    it("should retain the store's context", () => \{
			      const store = new ContextBoundStore(stringBuilder);
			
			      const Container = connect((state) => (\{
			        string: state
			      \}))(function Container(props) \{
			        return <Passthrough \{...props\} />;
			      \});
			
			      const spy = spyOn(console, 'error');
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      const tree = renderToContainer(vNode);
			
			      expect(spy.calls.count()).toBe(0);
			
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(stub.props.string).toBe('');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(stub.props.string).toBe('a');
			    \});
			
			    it('should handle dispatches before componentDidMount', (done) => \{
			      const store = createStore(stringBuilder);
			
			      const Container = connect((state) => (\{ string: state \}))(
			        class Container extends Component \{
			          componentDidMount() \{
			            store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			          \}
			
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			
			      setTimeout(() => \{
			        const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			        expect(stub.props.string).toBe('a');
			        done();
			      \}, 20);
			    \});
			
			    it('should handle additional prop changes in addition to slice', () => \{
			      const store = createStore(() => (\{
			        foo: 'bar'
			      \}));
			
			      const ConnectContainer = connect((state) => state)(
			        class ConnectContainer extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} pass=\{this.props.bar.baz\} />;
			          \}
			        \}
			      );
			
			      class Container extends Component \{
			        constructor() \{
			          super();
			          this.state = \{
			            bar: \{
			              baz: ''
			            \}
			          \};
			        \}
			
			        componentDidMount() \{
			          const newBar = \{\};
			
			          for (const key in this.state.bar) \{
			            newBar[key] = this.state.bar[key];
			          \}
			          newBar.baz = 'through';
			          this.setState(\{
			            bar: newBar
			          \});
			        \}
			
			        render() \{
			          return (
			            <ProviderMock store=\{store\}>
			              <ConnectContainer bar=\{this.state.bar\} />
			            </ProviderMock>
			          );
			        \}
			      \}
			
			      const vNode = <Container />;
			      const tree = renderToContainer(vNode);
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			
			      renderToContainer(vNode);
			
			      rerender();
			
			      expect(stub.props.foo).toBe('bar');
			      expect(stub.props.pass).toBe('through');
			    \});
			
			    it('should handle unexpected prop changes with forceUpdate()', (done) => \{
			      const store = createStore(() => (\{\}));
			
			      const ConnectContainer = connect((state) => state)(
			        class ConnectContainer extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} pass=\{this.props.bar\} />;
			          \}
			        \}
			      );
			
			      class Container extends Component \{
			        constructor() \{
			          super();
			          this.baz = 'baz';
			        \}
			
			        componentDidMount() \{
			          this.bar = 'foo';
			          this.forceUpdate();
			          this.c.forceUpdate();
			        \}
			
			        render() \{
			          return (
			            <ProviderMock store=\{store\}>
			              <ConnectContainer
			                bar=\{this.bar\}
			                ref=\{(c) => \{
			                  this.c = c;
			                \}\}
			              />
			            </ProviderMock>
			          );
			        \}
			      \}
			
			      const tree = renderToContainer(<Container />);
			
			      setTimeout(() => \{
			        const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			        expect(stub.props.bar).toBe('foo');
			        done();
			      \}, 20);
			    \});
			
			    it('should remove undefined props', () => \{
			      const store = createStore(() => \{\});
			      let props = \{ x: true \};
			      let container;
			
			      const ConnectContainer = connect(
			        () => (\{\}),
			        () => (\{\})
			      )(
			        class ConnectContainer extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class HolderContainer extends Component \{
			        render() \{
			          return <ConnectContainer \{...props\} />;
			        \}
			      \}
			
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <HolderContainer
			            ref=\{(instance) => \{
			              container = instance;
			            \}\}
			          />
			        </ProviderMock>
			      );
			
			      const propsBefore = \{
			        ...findRenderedVNodeWithType(container, Passthrough).children.props
			      \};
			
			      props = \{\};
			      container.forceUpdate();
			
			      const propsAfter = \{
			        ...findRenderedVNodeWithType(container, Passthrough).children.props
			      \};
			
			      expect(propsBefore.x).toBe(true);
			      expect('x' in propsAfter).toBe(false);
			    \});
			
			    it('should remove undefined props without mapDispatch', () => \{
			      const store = createStore(() => (\{\}));
			      let props = \{ x: true \};
			      let container;
			
			      const ConnectContainer = connect(() => (\{\}))(
			        class ConnectContainer extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class HolderContainer extends Component \{
			        render() \{
			          return <ConnectContainer \{...props\} />;
			        \}
			      \}
			
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <HolderContainer
			            ref=\{(instance) => \{
			              container = instance;
			            \}\}
			          />
			        </ProviderMock>
			      );
			
			      const propsBefore = \{
			        ...findRenderedVNodeWithType(container, Passthrough).children.props
			      \};
			
			      props = \{\};
			      container.forceUpdate();
			
			      const propsAfter = \{
			        ...findRenderedVNodeWithType(container, Passthrough).children.props
			      \};
			
			      expect(propsBefore.x).toBe(true);
			      expect('x' in propsAfter).toBe(false);
			    \});
			
			    it('should ignore deep mutations in props', () => \{
			      const store = createStore(() => (\{
			        foo: 'bar'
			      \}));
			
			      const ConnectContainer = connect((state) => state)(
			        class ConnectContainer extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} pass=\{this.props.bar.baz\} />;
			          \}
			        \}
			      );
			
			      class Container extends Component \{
			        constructor() \{
			          super();
			          this.state = \{
			            bar: \{
			              baz: ''
			            \}
			          \};
			        \}
			
			        componentDidMount() \{
			          // Simulate deep object mutation
			          const bar = this.state.bar;
			          bar.baz = 'through';
			          this.setState(\{
			            bar
			          \});
			        \}
			
			        render() \{
			          return (
			            <ProviderMock store=\{store\}>
			              <ConnectContainer bar=\{this.state.bar\} />
			            </ProviderMock>
			          );
			        \}
			      \}
			
			      const tree = renderToContainer(<Container />);
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(stub.props.foo).toBe('bar');
			      expect(stub.props.pass).toBe('');
			    \});
			
			    it('should allow for merge to incorporate state and prop changes', (done) => \{
			      const store = createStore(stringBuilder);
			
			      const doSomething = (thing) => (\{
			        type: 'APPEND',
			        payload: thing
			      \});
			
			      const Container = connect(
			        (state) => (\{ stateThing: state \}),
			        (dispatch) => (\{
			          doSomething: (whatever) => dispatch(doSomething(whatever))
			        \}),
			        (stateProps, actionProps, parentProps) => (\{
			          ...stateProps,
			          ...actionProps,
			          mergedDoSomething(thing) \{
			            const seed = stateProps.stateThing === '' ? 'HELLO ' : '';
			            actionProps.doSomething(seed + thing + parentProps.extra);
			          \}
			        \})
			      )(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class OuterContainer extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ extra: 'z' \};
			        \}
			
			        render() \{
			          return (
			            <ProviderMock store=\{store\}>
			              <Container extra=\{this.state.extra\} />
			            </ProviderMock>
			          );
			        \}
			      \}
			
			      const outerStub = render(<OuterContainer />, document.createElement('div'));
			      const stub = findRenderedVNodeWithType(outerStub, Passthrough).children;
			      expect(stub.props.stateThing).toBe('');
			      stub.props.mergedDoSomething('a');
			      outerStub.setState(\{\}, () => \{
			        expect(stub.props.stateThing).toBe('HELLO az');
			
			        stub.props.mergedDoSomething('b');
			        outerStub.setState(\{\}, () => \{
			          expect(stub.props.stateThing).toBe('HELLO azbz');
			
			          outerStub.setState(\{ extra: 'Z' \});
			          outerStub.setState(\{\}, () => \{
			            stub.props.mergedDoSomething('c');
			            outerStub.setState(\{\}, () => \{
			              expect(stub.props.stateThing).toBe('HELLO azbzcZ');
			
			              done();
			            \});
			          \});
			        \});
			      \});
			    \});
			
			    it('should merge actionProps into WrappedComponent', () => \{
			      const store = createStore(() => (\{
			        foo: 'bar'
			      \}));
			
			      const Container = connect(
			        (state) => state,
			        (dispatch) => (\{ dispatch \})
			      )(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Container pass="through" />
			        </ProviderMock>
			      );
			
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(stub.props.dispatch).toBe(store.dispatch);
			      expect(stub.props.foo).toBe('bar');
			      expect(() => findRenderedVNodeWithType(tree, Container).children).not.toThrowError();
			      const decorated = findRenderedVNodeWithType(tree, Container).children;
			      expect(decorated.isSubscribed()).toBe(true);
			    \});
			
			    it('should not invoke mapState when props change if it only has one argument', () => \{
			      const store = createStore(stringBuilder);
			
			      let invocationCount = 0;
			
			      const WithoutProps = connect((_arg1) => \{
			        invocationCount++;
			        return \{\};
			      \})(
			        class WithoutProps extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class OuterComponent extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ foo: 'FOO' \};
			        \}
			
			        setFoo(foo) \{
			          this.setState(\{ foo \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              <WithoutProps \{...this.state\} />
			            </div>
			          );
			        \}
			      \}
			
			      let outerComponent;
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <OuterComponent
			            ref=\{(c) => \{
			              outerComponent = c;
			            \}\}
			          />
			        </ProviderMock>
			      );
			
			      outerComponent.setFoo('BAR');
			      outerComponent.setFoo('DID');
			
			      expect(invocationCount).toBe(1);
			    \});
			
			    it('should invoke mapState every time props are changed if it has zero arguments', () => \{
			      const store = createStore(stringBuilder);
			
			      let invocationCount = 0;
			
			      const WithoutProps = connect(() => \{
			        invocationCount++;
			        return \{\};
			      \})(
			        class WithoutProps extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class OuterComponent extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ foo: 'FOO' \};
			        \}
			
			        setFoo(foo) \{
			          this.setState(\{ foo \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              <WithoutProps \{...this.state\} />
			            </div>
			          );
			        \}
			      \}
			
			      let outerComponent;
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <OuterComponent
			            ref=\{(c) => \{
			              outerComponent = c;
			            \}\}
			          />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      outerComponent.setFoo('BAR');
			      renderToContainer(vNode);
			      outerComponent.setFoo('DID');
			      renderToContainer(vNode);
			      expect(invocationCount).toBe(3);
			    \});
			
			    it('should invoke mapState every time props are changed if it has a second argument', () => \{
			      const store = createStore(stringBuilder);
			
			      let propsPassedIn;
			      let invocationCount = 0;
			
			      const WithoutProps = connect((_state, props) => \{
			        invocationCount++;
			        propsPassedIn = props;
			        return \{\};
			      \})(
			        class WithoutProps extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class OuterComponent extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ foo: 'FOO' \};
			        \}
			
			        setFoo(foo) \{
			          this.setState(\{ foo \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              <WithoutProps \{...this.state\} />
			            </div>
			          );
			        \}
			      \}
			
			      let outerComponent;
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <OuterComponent
			            ref=\{(c) => \{
			              outerComponent = c;
			            \}\}
			          />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      outerComponent.setFoo('BAR');
			      renderToContainer(vNode);
			      outerComponent.setFoo('BAZ');
			      renderToContainer(vNode);
			
			      expect(invocationCount).toBe(3);
			      expect(propsPassedIn).toEqual(\{
			        foo: 'BAZ'
			      \});
			    \});
			
			    it('should not invoke mapDispatch when props change if it only has one argument', () => \{
			      const store = createStore(stringBuilder);
			
			      let invocationCount = 0;
			
			      const WithoutProps = connect(null, (_arg1) => \{
			        invocationCount++;
			        return \{\};
			      \})(
			        class WithoutProps extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class OuterComponent extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ foo: 'FOO' \};
			        \}
			
			        setFoo(foo) \{
			          this.setState(\{ foo \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              <WithoutProps \{...this.state\} />
			            </div>
			          );
			        \}
			      \}
			
			      let outerComponent;
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <OuterComponent
			            ref=\{(c) => \{
			              outerComponent = c;
			            \}\}
			          />
			        </ProviderMock>
			      );
			
			      outerComponent.setFoo('BAR');
			      outerComponent.setFoo('DID');
			
			      expect(invocationCount).toBe(1);
			    \});
			
			    it('should invoke mapDispatch every time props are changed if it has zero arguments', () => \{
			      const store = createStore(stringBuilder);
			
			      let invocationCount = 0;
			
			      const WithoutProps = connect(null, () => \{
			        invocationCount++;
			        return \{\};
			      \})(
			        class WithoutProps extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class OuterComponent extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ foo: 'FOO' \};
			        \}
			
			        setFoo(foo) \{
			          this.setState(\{ foo \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              <WithoutProps \{...this.state\} />
			            </div>
			          );
			        \}
			      \}
			
			      let outerComponent;
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <OuterComponent
			            ref=\{(c) => \{
			              outerComponent = c;
			            \}\}
			          />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      outerComponent.setFoo('BAR');
			      renderToContainer(vNode);
			      outerComponent.setFoo('DID');
			      renderToContainer(vNode);
			      expect(invocationCount).toBe(3);
			    \});
			
			    it('should invoke mapDispatch every time props are changed if it has a second argument', () => \{
			      const store = createStore(stringBuilder);
			
			      let propsPassedIn;
			      let invocationCount = 0;
			
			      const WithoutProps = connect(null, (_state, props) => \{
			        invocationCount++;
			        propsPassedIn = props;
			        return \{\};
			      \})(
			        class WithoutProps extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      class OuterComponent extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ foo: 'FOO' \};
			        \}
			
			        setFoo(foo) \{
			          this.setState(\{ foo \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              <WithoutProps \{...this.state\} />
			            </div>
			          );
			        \}
			      \}
			
			      let outerComponent;
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <OuterComponent
			            ref=\{(c) => \{
			              outerComponent = c;
			            \}\}
			          />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      outerComponent.setFoo('BAR');
			      renderToContainer(vNode);
			      outerComponent.setFoo('BAZ');
			      renderToContainer(vNode);
			
			      expect(invocationCount).toBe(3);
			      expect(propsPassedIn).toEqual(\{
			        foo: 'BAZ'
			      \});
			    \});
			
			    it('should pass dispatch and avoid subscription if arguments are falsy', () => \{
			      const store = createStore(() => (\{
			        foo: 'bar'
			      \}));
			
			      const runCheck = (...connectArgs) => \{
			        const Container = connect(...connectArgs)(
			          class Container extends Component \{
			            render() \{
			              return <Passthrough \{...this.props\} />;
			            \}
			          \}
			        );
			
			        const vNode = (
			          <ProviderMock store=\{store\}>
			            <Container pass="through" />
			          </ProviderMock>
			        );
			        const tree = renderToContainer(vNode);
			
			        const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			        expect(stub.props.dispatch).toBe(store.dispatch);
			        expect(stub.props.foo).toBeUndefined();
			        expect(stub.props.pass).toBe('through');
			        expect(() => findRenderedVNodeWithType(tree, Container).children).not.toThrowError();
			
			        const decorated = findRenderedVNodeWithType(tree, Container).children;
			        expect(decorated.isSubscribed()).toBe(false);
			      \};
			
			      runCheck();
			      runCheck(null, null, null);
			      runCheck(false, false, false);
			    \});
			
			    it('should unsubscribe before unmounting', () => \{
			      const store = createStore(stringBuilder);
			      const subscribe = store.subscribe;
			
			      // Keep track of unsubscribe by wrapping subscribe()
			      let unsubscribeCalls = 0;
			      store.subscribe = (listener) => \{
			        const unsubscribe = subscribe(listener);
			        return () => \{
			          unsubscribeCalls++;
			          return unsubscribe();
			        \};
			      \};
			
			      const Container = connect(
			        (state) => (\{ string: state \}),
			        (dispatch) => (\{ dispatch \})
			      )(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const div = document.createElement('div');
			      render(
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>,
			        div
			      );
			
			      expect(unsubscribeCalls).toBe(0);
			      unmountDOM(div);
			      expect(unsubscribeCalls).toBe(1);
			    \});
			
			    it('should not attempt to set state after unmounting', () => \{
			      const store = createStore(stringBuilder);
			      let mapStateToPropsCalls = 0;
			
			      const Container = connect(
			        () => (\{ calls: ++mapStateToPropsCalls \}),
			        (dispatch) => (\{ dispatch \})
			      )(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const div = document.createElement('div');
			      store.subscribe(() => \{
			        unmountDOM(div);
			      \});
			      render(
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>,
			        div
			      );
			
			      expect(mapStateToPropsCalls).toBe(1);
			      const spy = spyOn(console, 'error');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      expect(spy.calls.count()).toBe(0);
			      expect(mapStateToPropsCalls).toBe(1);
			    \});
			
			    it('should not attempt to notify unmounted child of state change', () => \{
			      class ProviderMockTest extends Component \{
			        getChildContext() \{
			          return \{ store: this.props.store \};
			        \}
			
			        render() \{
			          return this.props.children;
			        \}
			      \}
			
			      const store = createStore(stringBuilder);
			
			      const App = connect((state) => (\{ hide: state === 'AB' \}))(
			        class App extends Component \{
			          getDisplayName() \{
			            return 'App';
			          \}
			
			          render() \{
			            return this.props.hide ? null : <Container />;
			          \}
			        \}
			      );
			
			      const Container = connect((state) => (\{ state \}))(
			        class Container extends Component \{
			          getDisplayName() \{
			            return 'Container';
			          \}
			          componentWillReceiveProps(nextProps) \{
			            if (nextProps.state === 'A') \{
			              store.dispatch(\{ type: 'APPEND', payload: 'B' \});
			            \}
			          \}
			
			          render() \{
			            return null;
			          \}
			        \}
			      );
			
			      const div = document.createElement('div');
			      render(
			        <ProviderMockTest store=\{store\}>
			          <App />
			        </ProviderMockTest>,
			        div
			      );
			
			      try \{
			        store.dispatch(\{ type: 'APPEND', payload: 'A' \});
			      \} finally \{
			        unmountDOM(div);
			      \}
			    \});
			
			    it('should not attempt to set state after unmounting nested components', () => \{
			      const store = createStore(() => (\{\}));
			      let mapStateToPropsCalls = 0;
			
			      let linkA;
			      let linkB;
			
			      let App = (\{ children, setLocation \}) => \{
			        const onClick = (to) => (event) => \{
			          event.preventDefault();
			          setLocation(to);
			        \};
			
			        return (
			          <div>
			            <a
			              href="#"
			              onClick=\{onClick('a')\}
			              ref=\{(c) => \{
			                linkA = c;
			              \}\}
			            >
			              A
			            </a>
			            <a
			              href="#"
			              onClick=\{onClick('b')\}
			              ref=\{(c) => \{
			                linkB = c;
			              \}\}
			            >
			              B
			            </a>
			            \{children\}
			          </div>
			        );
			      \};
			      App = connect(() => (\{\}))(App);
			
			      let A = () => <h1>A</h1>;
			      A = connect(() => (\{ calls: ++mapStateToPropsCalls \}))(A);
			
			      const B = () => <h1>B</h1>;
			
			      class RouterMock extends Component \{
			        constructor(...args) \{
			          super(...args);
			          this.state = \{ location: \{ pathname: 'a' \} \};
			          this.setLocation = this.setLocation.bind(this);
			        \}
			
			        setLocation(pathname) \{
			          store.dispatch(\{ type: 'TEST' \});
			          this.setState(\{ location: \{ pathname \} \});
			        \}
			
			        getChildComponent(location) \{
			          switch (location) \{
			            case 'a':
			              return <A />;
			            case 'b':
			              return <B />;
			            default:
			              throw new Error('Unknown location: ' + location);
			          \}
			        \}
			
			        render() \{
			          return <App setLocation=\{this.setLocation\}>\{this.getChildComponent(this.state.location.pathname)\}</App>;
			        \}
			      \}
			
			      let wrapper;
			      const div = document.createElement('div');
			      document.body.appendChild(div);
			      const vNode = (
			        <Wrapper
			          ref=\{(w) => \{
			            wrapper = w;
			          \}\}
			        >
			          <ProviderMock store=\{store\}>
			            <RouterMock />
			          </ProviderMock>
			        </Wrapper>
			      );
			      render(vNode, div);
			
			      const spy = spyOn(console, 'error');
			      expect(mapStateToPropsCalls).toBe(1);
			      linkA.click();
			      render(vNode, div);
			      expect(mapStateToPropsCalls).toBe(2);
			      linkB.click();
			      render(vNode, div);
			
			      expect(mapStateToPropsCalls).toBe(3);
			      linkB.click();
			      render(vNode, div);
			
			      expect(spy.calls.count()).toBe(0);
			
			      unmountDOM(div);
			      document.body.removeChild(div);
			      expect(mapStateToPropsCalls).toBe(3);
			    \});
			
			    it('should not attempt to set state when dispatching in componentWillUnmount', () => \{
			      const store = createStore(stringBuilder);
			      let mapStateToPropsCalls = 0;
			
			      const Container = connect(
			        (state) => (\{ calls: mapStateToPropsCalls++ \}),
			        (dispatch) => (\{ dispatch \})
			      )(
			        class Container extends Component \{
			          componentWillUnmount() \{
			            this.props.dispatch(\{ type: 'APPEND', payload: 'a' \});
			          \}
			
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const div = document.createElement('div');
			      render(
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>,
			        div
			      );
			
			      expect(mapStateToPropsCalls).toBe(1);
			
			      const spy = spyOn(console, 'error');
			
			      unmountDOM(div);
			
			      expect(spy.calls.count()).toBe(0);
			
			      expect(mapStateToPropsCalls).toBe(1);
			    \});
			
			    it('should shallowly compare the selected state to prevent unnecessary updates', () => \{
			      const store = createStore(stringBuilder);
			      let renderCallCount = 0;
			
			      const Container = connect(
			        (state) => (\{ string: state \}),
			        (dispatch) => (\{ dispatch \})
			      )(
			        class Container extends Component \{
			          render() \{
			            const \{ string \} = this.props;
			
			            renderCallCount++;
			            return <Passthrough string=\{string\} />;
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      const tree = renderToContainer(vNode);
			
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(renderCallCount).toBe(1);
			      expect(stub.props.string).toBe('');
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(2);
			      store.dispatch(\{ type: 'APPEND', payload: 'b' \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(3);
			      store.dispatch(\{ type: 'APPEND', payload: '' \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(3);
			    \});
			
			    it('should shallowly compare the merged state to prevent unnecessary updates', () => \{
			      const store = createStore(stringBuilder);
			      let renderCallCount = 0;
			
			      const Container = connect(
			        (state) => (\{ string: state \}),
			        (dispatch) => (\{ dispatch \}),
			        (stateProps, dispatchProps, parentProps) => (\{
			          ...dispatchProps,
			          ...stateProps,
			          ...parentProps
			        \})
			      )(
			        class Container extends Component \{
			          render() \{
			            const \{ string, pass \} = this.props;
			
			            renderCallCount++;
			            return <Passthrough string=\{string\} pass=\{pass\} passVal=\{pass.val\} />;
			          \}
			        \}
			      );
			
			      class Root extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{ pass: '' \};
			        \}
			
			        render() \{
			          return (
			            <ProviderMock store=\{store\}>
			              <Container pass=\{this.state.pass\} />
			            </ProviderMock>
			          );
			        \}
			      \}
			
			      const vNode = <Root />;
			      const rootStub = renderToContainer(vNode);
			      const stub = findRenderedVNodeWithType(rootStub, Passthrough).children;
			
			      expect(renderCallCount).toBe(1);
			      expect(stub.props.string).toBe('');
			      expect(stub.props.pass).toBe('');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(2);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.pass).toBe('');
			
			      rootStub.setState(\{ pass: '' \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(2);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.pass).toBe('');
			
			      rootStub.setState(\{ pass: 'through' \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(3);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.pass).toBe('through');
			
			      rootStub.setState(\{ pass: 'through' \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(3);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.pass).toBe('through');
			
			      const obj = \{ prop: 'val' \};
			      rootStub.setState(\{ pass: obj \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(4);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.pass).toBe(obj);
			
			      rootStub.setState(\{ pass: obj \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(4);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.pass).toBe(obj);
			
			      const obj2 = \{ ...obj, val: 'otherval' \};
			      rootStub.setState(\{ pass: obj2 \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(5);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.pass).toBe(obj2);
			
			      obj2.val = 'mutation';
			      rootStub.setState(\{ pass: obj2 \});
			      renderToContainer(vNode);
			      expect(renderCallCount).toBe(5);
			      expect(stub.props.string).toBe('a');
			      expect(stub.props.passVal).toBe('otherval');
			    \});
			
			    it('should throw an error if a component is not passed to the function returned by connect', () => \{
			      expect(connect()).toThrowError(/You must pass a component to the function/);
			    \});
			
			    // TODO: Refactor this test. Regex way of matching values vary per browser
			    // it('should throw an error if mapState, mapDispatch, or mergeProps returns anything but a plain object', () => \{
			    //   const store = createStore(() => (\{\}));
			    //
			    //   const makeContainer = (mapState, mapDispatch, mergeProps) =>
			    //     createElement(
			    //       connect(mapState, mapDispatch, mergeProps)(
			    //         class Container extends Component \{
			    //           render() \{
			    //             return <Passthrough />;
			    //           \}
			    //         \}
			    //       )
			    //     );
			    //
			    //   function AwesomeMap() \{\}
			    //
			    //   let spyValue = '';
			    //   // mapStateToProps
			    //   const spy = spyOn(console, 'error').and.callFake(e => (spyValue = e));
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => 1, () => (\{\}), () => (\{\}))\}</ProviderMock>);
			    //
			    //   const errorMsg = supportFnName
			    //     ? /mapStateToProps\\(\\) in Connect\\(Container\\) must return a plain object/
			    //     : /mapStateToProps\\(\\) in Connect\\(Component\\) must return a plain object/;
			    //
			    //   expect(spy.calls.count()).toBe(1);
			    //   expect(spyValue).toMatch(errorMsg);
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => 'hey', () => (\{\}), () => (\{\}))\}</ProviderMock>);
			    //
			    //   expect(spy.calls.count()).toBe(2);
			    //   expect(spyValue).toMatch(errorMsg);
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => new AwesomeMap(), () => (\{\}), () => (\{\}))\}</ProviderMock>);
			    //
			    //   expect(spy.calls.count()).toBe(3);
			    //   expect(spyValue).toMatch(errorMsg);
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => (\{\}), () => 1, () => (\{\}))\}</ProviderMock>);
			    //
			    //   const errorMsg2 = supportFnName
			    //     ? /mapDispatchToProps\\(\\) in Connect\\(Container\\) must return a plain object/
			    //     : /mapDispatchToProps\\(\\) in Connect\\(Component\\) must return a plain object/;
			    //
			    //   expect(spy.calls.count()).toBe(4);
			    //   expect(spyValue).toMatch(errorMsg2);
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => (\{\}), () => 'hey', () => (\{\}))\}</ProviderMock>);
			    //
			    //   expect(spy.calls.count()).toBe(5);
			    //   expect(spyValue).toMatch(errorMsg2);
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => (\{\}), () => new AwesomeMap(), () => (\{\}))\}</ProviderMock>);
			    //
			    //   expect(spy.calls.count()).toBe(6);
			    //   expect(spyValue).toMatch(errorMsg2);
			    //
			    //   // mergeProps
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => (\{\}), () => (\{\}), () => 1)\}</ProviderMock>);
			    //
			    //   const errorMsg3 = supportFnName
			    //     ? /mergeProps\\(\\) in Connect\\(Container\\) must return a plain object/
			    //     : /mergeProps\\(\\) in Connect\\(Component\\) must return a plain object/;
			    //
			    //   expect(spy.calls.count()).toBe(7);
			    //   expect(spyValue).toMatch(errorMsg3);
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => (\{\}), () => (\{\}), () => 'hey')\}</ProviderMock>);
			    //
			    //   expect(spy.calls.count()).toBe(8);
			    //   expect(spyValue).toMatch(errorMsg3);
			    //
			    //   renderToContainer(<ProviderMock store=\{store\}>\{makeContainer(() => (\{\}), () => (\{\}), () => new AwesomeMap())\}</ProviderMock>);
			    //
			    //   expect(spy.calls.count()).toBe(9);
			    //   expect(spyValue).toMatch(errorMsg3);
			    // \});
			
			    it('should recalculate the state and rebind the actions on hot update', () => \{
			      const store = createStore(() => \{\});
			
			      const ContainerBefore = connect(null, () => (\{ scooby: 'doo' \}))(
			        class ContainerBefore extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const ContainerAfter = connect(
			        () => (\{ foo: 'baz' \}),
			        () => (\{ scooby: 'foo' \})
			      )(
			        class ContainerAfter extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const ContainerNext = connect(
			        () => (\{ foo: 'bar' \}),
			        () => (\{ scooby: 'boo' \})
			      )(
			        class ContainerNext extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <ContainerBefore />
			        </ProviderMock>
			      );
			
			      const container = findRenderedVNodeWithType(tree, ContainerBefore).children;
			      const stub = findRenderedVNodeWithType(tree, Passthrough).children;
			      expect(stub.props.foo).toBeUndefined();
			      expect(stub.props.scooby).toBe('doo');
			
			      const imitateHotReloading = (TargetClass, SourceClass) => \{
			        // Crude imitation of hot reloading that does the job
			        Object.getOwnPropertyNames(SourceClass.prototype)
			          .filter((key) => typeof SourceClass.prototype[key] === 'function')
			          .forEach((key) => \{
			            if (key !== 'render' && key !== 'constructor') \{
			              TargetClass.prototype[key] = SourceClass.prototype[key];
			            \}
			          \});
			
			        container.forceUpdate();
			      \};
			
			      imitateHotReloading(ContainerBefore, ContainerAfter);
			      expect(stub.props.foo).toBe('baz');
			      expect(stub.props.scooby).toBe('foo');
			
			      imitateHotReloading(ContainerBefore, ContainerNext);
			      expect(stub.props.foo).toBe('bar');
			      expect(stub.props.scooby).toBe('boo');
			    \});
			
			    it('should set the displayName correctly', () => \{
			      expect(
			        connect((state) => state)(
			          class Foo extends Component \{
			            render() \{
			              return <div />;
			            \}
			          \}
			        ).displayName
			      ).not.toEqual(undefined);
			
			      expect(
			        connect((state) => state)(
			          createClass(\{
			            displayName: 'Bar',
			            render() \{
			              return <div />;
			            \}
			          \})
			        ).displayName
			      ).not.toEqual(undefined);
			
			      expect(
			        connect((state) => state)(
			          createClass(\{
			            render() \{
			              return <div />;
			            \}
			          \})
			        ).displayName
			      ).not.toEqual(undefined);
			    \});
			
			    it('should expose the wrapped component as WrappedComponent', () => \{
			      class Container extends Component \{
			        render() \{
			          return <Passthrough />;
			        \}
			      \}
			
			      const decorator = connect((state) => state);
			      const decorated = decorator(Container);
			
			      expect(decorated.WrappedComponent).toBe(Container);
			    \});
			
			    it('should hoist non-react statics from wrapped component', () => \{
			      class Container extends Component \{
			        render() \{
			          return <Passthrough />;
			        \}
			      \}
			
			      Container.howIsRedux = () => 'Awesome!';
			      Container.foo = 'bar';
			
			      const decorator = connect((state) => state);
			      const decorated = decorator(Container);
			
			      expect(typeof decorated.howIsRedux).toBe('function');
			      expect(decorated.howIsRedux()).toBe('Awesome!');
			      expect(decorated.foo).toBe('bar');
			    \});
			
			    it('should use the store from the props instead of from the context if present', () => \{
			      class Container extends Component \{
			        render() \{
			          return <Passthrough />;
			        \}
			      \}
			
			      let actualState;
			
			      const expectedState = \{ foos: \{\} \};
			      const decorator = connect((state) => \{
			        actualState = state;
			        return \{\};
			      \});
			
			      const Decorated = decorator(Container);
			      const mockStore = \{
			        dispatch: () => \{\},
			        subscribe: () => \{\},
			        getState: () => expectedState
			      \};
			
			      renderToContainer(<Decorated store=\{mockStore\} />);
			      expect(actualState).toBe(expectedState);
			    \});
			
			    it('should throw an error if the store is not in the props or context', () => \{
			      class Container extends Component \{
			        render() \{
			          return <Passthrough />;
			        \}
			      \}
			
			      const decorator = connect(() => \{\});
			      const Decorated = decorator(Container);
			
			      expect(() => renderToContainer(<Decorated />)).toThrowError(/Could not find "store"/);
			    \});
			
			    it('should throw when trying to access the wrapped instance if withRef is not specified', () => \{
			      const store = createStore(() => (\{\}));
			
			      class Container extends Component \{
			        render() \{
			          return <Passthrough />;
			        \}
			      \}
			
			      const decorator = connect((state) => state);
			      const Decorated = decorator(Container);
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Decorated />
			        </ProviderMock>
			      );
			
			      const decorated = findRenderedVNodeWithType(tree, Decorated).children;
			      expect(() => decorated.getWrappedInstance()).toThrowError(
			        /To access the wrapped instance, you need to specify \\\{ withRef: true \\\} in the options argument of the connect\\(\\) call\\./
			      );
			    \});
			
			    it('should return the instance of the wrapped component for use in calling child methods', () => \{
			      const store = createStore(() => (\{\}));
			
			      const someData = \{
			        some: 'data'
			      \};
			
			      class Container extends Component \{
			        someInstanceMethod() \{
			          return someData;
			        \}
			
			        render() \{
			          return <Passthrough />;
			        \}
			      \}
			
			      const decorator = connect((state) => state, null, null, \{ withRef: true \});
			      const Decorated = decorator(Container);
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Decorated />
			        </ProviderMock>
			      );
			
			      const decorated = findRenderedVNodeWithType(tree, Decorated).children;
			      expect(() => decorated.someInstanceMethod()).toThrowError();
			      expect(decorated.getWrappedInstance().someInstanceMethod()).toEqual(someData);
			      expect(decorated.wrappedInstance.someInstanceMethod()).toBe(someData);
			    \});
			
			    it('should wrap impure components without supressing updates', () => \{
			      const store = createStore(() => (\{\}));
			
			      class ImpureComponent extends Component \{
			        render() \{
			          return <Passthrough statefulValue=\{this.context.statefulValue\} />;
			        \}
			      \}
			
			      const decorator = connect((state) => state, null, null, \{ pure: false \});
			      const Decorated = decorator(ImpureComponent);
			
			      class StatefulWrapper extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ value: 0 \};
			        \}
			
			        getChildContext() \{
			          return \{
			            statefulValue: this.state.value
			          \};
			        \}
			
			        render() \{
			          return <Decorated />;
			        \}
			      \}
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <StatefulWrapper />
			        </ProviderMock>
			      );
			      const tree = renderToContainer(vNode);
			
			      const target = findRenderedVNodeWithType(tree, Passthrough).children;
			      const wrapper = findRenderedVNodeWithType(tree, StatefulWrapper).children;
			      expect(target.props.statefulValue).toBe(0);
			
			      wrapper.setState(\{ value: 1 \});
			      renderToContainer(vNode);
			      expect(target.props.statefulValue).toBe(1);
			    \});
			
			    it('calls mapState and mapDispatch for impure components', () => \{
			      const store = createStore(() => (\{
			        foo: 'foo',
			        bar: 'bar'
			      \}));
			
			      let mapStateToPropsCalls = 0;
			      let mapDispatchToPropsCalls = 0;
			
			      class ImpureComponent extends Component \{
			        render() \{
			          return <Passthrough statefulValue=\{this.props.value\} />;
			        \}
			      \}
			
			      const decorator = connect(
			        (state, \{ storeGetter \}) => \{
			          mapStateToPropsCalls++;
			          return \{ value: state[storeGetter.storeKey] \};
			        \},
			        () => \{
			          mapDispatchToPropsCalls++;
			          return \{\};
			        \},
			        null,
			        \{ pure: false \}
			      );
			      const Decorated = decorator(ImpureComponent);
			
			      class StatefulWrapper extends Component \{
			        constructor() \{
			          super();
			          this.state = \{
			            storeGetter: \{ storeKey: 'foo' \}
			          \};
			        \}
			
			        render() \{
			          return <Decorated storeGetter=\{this.state.storeGetter\} />;
			        \}
			      \}
			
			      const tree = renderToContainer(
			        <ProviderMock store=\{store\}>
			          <StatefulWrapper />
			        </ProviderMock>
			      );
			
			      const target = findRenderedVNodeWithType(tree, Passthrough).children;
			      const wrapper = findRenderedVNodeWithType(tree, StatefulWrapper).children;
			
			      expect(mapStateToPropsCalls).toBe(2);
			      expect(mapDispatchToPropsCalls).toBe(2);
			      expect(target.props.statefulValue).toBe('foo');
			
			      // Impure update
			      const storeGetter = wrapper.state.storeGetter;
			      storeGetter.storeKey = 'bar';
			      wrapper.setState(\{ storeGetter \});
			
			      expect(mapStateToPropsCalls).toBe(3);
			      expect(mapDispatchToPropsCalls).toBe(3);
			      expect(target.props.statefulValue).toBe('bar');
			    \});
			
			    it('should pass state consistently to mapState', () => \{
			      const store = createStore(stringBuilder);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      let childMapStateInvokes = 0;
			
			      const Container = connect((state) => (\{ state \}), null, null, \{
			        withRef: true
			      \})(
			        class Container extends Component \{
			          emitChange() \{
			            store.dispatch(\{ type: 'APPEND', payload: 'b' \});
			          \}
			
			          render() \{
			            return (
			              <div>
			                <button
			                  ref=\{(btn) => \{
			                    this.button = btn;
			                  \}\}
			                  onClick=\{this.emitChange.bind(this)\}
			                >
			                  change
			                </button>
			                <ChildContainer parentState=\{this.props.state\} />
			              </div>
			            );
			          \}
			        \}
			      );
			
			      const ChildContainer = connect((state, parentProps) => \{
			        childMapStateInvokes++;
			
			        // The state from parent props should always be consistent with the current state.
			        expect(state).toBe(parentProps.parentState);
			        return \{\};
			      \})(
			        class ChildContainer extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      const tree = renderToContainer(vNode);
			
			      expect(childMapStateInvokes).toBe(1);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'c' \});
			      renderToContainer(vNode);
			      expect(childMapStateInvokes).toBe(2);
			
			      const container = findRenderedVNodeWithType(tree, Container).children;
			      const button = container.getWrappedInstance().button;
			      button.click();
			      renderToContainer(vNode);
			      expect(childMapStateInvokes).toBe(3);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'd' \});
			      renderToContainer(vNode);
			      expect(childMapStateInvokes).toBe(4);
			    \});
			
			    it('should not render the wrapped component when mapState does not produce change', () => \{
			      const store = createStore(stringBuilder);
			      let renderCalls = 0;
			      let mapStateCalls = 0;
			
			      const Container = connect(() => \{
			        mapStateCalls++;
			        return \{\}; // no change!
			      \})(
			        class Container extends Component \{
			          render() \{
			            renderCalls++;
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      expect(renderCalls).toBe(1);
			      expect(mapStateCalls).toBe(1);
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			
			      // After store a change mapState has been called
			      expect(mapStateCalls).toBe(2);
			      // But render is not because it did not make any actual changes
			      expect(renderCalls).toBe(1);
			    \});
			
			    it('should bail out early if mapState does not depend on props', () => \{
			      const store = createStore(stringBuilder);
			      let renderCalls = 0;
			      let mapStateCalls = 0;
			      let setStateCalls = 0;
			
			      const Container = connect((state) => \{
			        mapStateCalls++;
			        return state === 'aaa' ? \{ change: 1 \} : \{\};
			      \})(
			        class Container extends Component \{
			          render() \{
			            renderCalls++;
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const oldSetState = Container.prototype.setState;
			      Container.prototype.setState = function setState(...args) \{
			        setStateCalls++;
			        oldSetState.apply(this, args);
			      \};
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      expect(renderCalls).toBe(1);
			      expect(mapStateCalls).toBe(1);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(mapStateCalls).toBe(2);
			      expect(renderCalls).toBe(1);
			      expect(setStateCalls).toBe(0);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(mapStateCalls).toBe(3);
			      expect(renderCalls).toBe(1);
			      expect(setStateCalls).toBe(0);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			      expect(mapStateCalls).toBe(4);
			      expect(renderCalls).toBe(2);
			      expect(setStateCalls).toBe(1);
			    \});
			
			    it('should not swallow errors when bailing out early', () => \{
			      const store = createStore(stringBuilder);
			      let renderCalls = 0;
			      let mapStateCalls = 0;
			
			      const Container = connect((state) => \{
			        mapStateCalls++;
			        if (state === 'a') \{
			          throw new Error('Oops');
			        \} else \{
			          return \{\};
			        \}
			      \})(
			        class Container extends Component \{
			          render() \{
			            renderCalls++;
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			
			      expect(renderCalls).toBe(1);
			      expect(mapStateCalls).toBe(1);
			      expect(() => store.dispatch(\{ type: 'APPEND', payload: 'a' \})).toThrowError('Oops');
			    \});
			
			    it('should allow providing a factory function to mapStateToProps', () => \{
			      let updateCount = 0;
			      let memoizedReturnCount = 0;
			      const store = createStore(() => (\{ value: 1 \}));
			
			      const mapStateFactory = () => \{
			        let lastProp;
			        let lastVal;
			        let lastResult;
			        return (state, props) => \{
			          if (props.name === lastProp && lastVal === state.value) \{
			            memoizedReturnCount++;
			            return lastResult;
			          \}
			
			          lastProp = props.name;
			          lastVal = state.value;
			          lastResult = \{
			            someObject: \{ prop: props.name, stateVal: state.value \}
			          \};
			          return lastResult;
			        \};
			      \};
			
			      const Container = connect(mapStateFactory)(
			        class Container extends Component \{
			          componentWillUpdate() \{
			            updateCount++;
			          \}
			
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <div>
			            <Container name="a" />
			            <Container name="b" />
			          </div>
			        </ProviderMock>
			      );
			
			      store.dispatch(\{ type: 'test' \});
			      expect(updateCount).toBe(0);
			      expect(memoizedReturnCount).toBe(2);
			    \});
			
			    it('should allow a mapStateToProps factory consuming just state to return a function that gets ownProps', () => \{
			      const store = createStore(() => (\{ value: 1 \}));
			
			      let initialState;
			      let initialOwnProps;
			      let secondaryOwnProps;
			      const mapStateFactory = function (factoryInitialState) \{
			        initialState = factoryInitialState;
			        initialOwnProps = arguments[1];
			        return (state, props) => \{
			          secondaryOwnProps = props;
			          return \{\};
			        \};
			      \};
			
			      const Container = connect(mapStateFactory)(
			        class Container extends Component \{
			          render() \{
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <div>
			            <Container name="a" />
			          </div>
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      store.dispatch(\{ type: 'test' \});
			      renderToContainer(vNode);
			      expect(initialOwnProps).toBeUndefined();
			      expect(initialState).toBeDefined();
			      expect(secondaryOwnProps).toBeDefined();
			      expect(secondaryOwnProps.name).toBe('a');
			    \});
			
			    it('should allow providing a factory function to mapDispatchToProps', (done) => \{
			      let updatedCount = 0;
			      let memoizedReturnCount = 0;
			      const store = createStore(() => (\{ value: 1 \}));
			
			      const mapDispatchFactory = () => \{
			        let lastProp;
			        let lastResult;
			        return (dispatch, props) => \{
			          if (props.name === lastProp) \{
			            memoizedReturnCount++;
			            return lastResult;
			          \}
			
			          lastProp = props.name;
			          lastResult = \{ someObject: \{ dispatchFn: dispatch \} \};
			          return lastResult;
			        \};
			      \};
			
			      const mergeParentDispatch = (stateProps, dispatchProps, parentProps) => (\{
			        ...stateProps,
			        ...dispatchProps,
			        name: parentProps.name
			      \});
			
			      const Passthrough = connect(
			        null,
			        mapDispatchFactory,
			        mergeParentDispatch
			      )(
			        class Passthrough extends Component \{
			          componentWillUpdate() \{
			            updatedCount++;
			          \}
			
			          render() \{
			            return <div />;
			          \}
			        \}
			      );
			
			      class Container extends Component \{
			        constructor(props) \{
			          super(props);
			          this.state = \{ count: 0 \};
			        \}
			
			        componentDidMount() \{
			          this.setState(\{ count: 1 \});
			        \}
			
			        render() \{
			          const \{ count \} = this.state;
			          return (
			            <div>
			              <Passthrough count=\{count\} name="a" />
			              <Passthrough count=\{count\} name="b" />
			            </div>
			          );
			        \}
			      \}
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      setTimeout(() => \{
			        store.dispatch(\{ type: 'test' \});
			        renderToContainer(vNode);
			        expect(updatedCount).toBe(0);
			        expect(memoizedReturnCount).toBe(2);
			        done();
			      \}, 20);
			    \});
			
			    it('should not call update if mergeProps return value has not changed', () => \{
			      let mapStateCalls = 0;
			      let renderCalls = 0;
			      const store = createStore(stringBuilder);
			
			      const Container = connect(
			        () => (\{ a: ++mapStateCalls \}),
			        null,
			        () => (\{
			          changed: false
			        \})
			      )(
			        class Container extends Component \{
			          render() \{
			            renderCalls++;
			            return <Passthrough \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Container />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      expect(mapStateCalls).toBe(1);
			      expect(renderCalls).toBe(1);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      renderToContainer(vNode);
			
			      expect(mapStateCalls).toBe(2);
			      expect(renderCalls).toBe(1);
			    \});
			
			    it('should update impure components with custom mergeProps', (done) => \{
			      const store = createStore(() => (\{\}));
			      let renderCount = 0;
			
			      const Container = connect(null, null, () => (\{ a: 1 \}), \{ pure: false \})(
			        class Container extends Component \{
			          render() \{
			            renderCount++;
			            return <div />;
			          \}
			        \}
			      );
			
			      class Parent extends Component \{
			        componentDidMount() \{
			          this.forceUpdate();
			        \}
			
			        render() \{
			          return <Container />;
			        \}
			      \}
			
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <Parent>
			            <Container />
			          </Parent>
			        </ProviderMock>
			      );
			
			      expect(renderCount).toBe(1);
			
			      setTimeout(() => \{
			        expect(renderCount).toBe(2);
			        done();
			      \}, 20);
			    \});
			
			    it('should allow to clean up child state in parent componentWillUnmount', () => \{
			      const reducer = (state = \{ data: null \}, action) => \{
			        switch (action.type) \{
			          case 'fetch':
			            return \{ data: \{ profile: \{ name: 'April' \} \} \};
			          case 'clean':
			            return \{ data: null \};
			          default:
			            return state;
			        \}
			      \};
			
			      const Child = connect((state) => (\{
			        profile: state.data && state.data.profile
			      \}))(
			        class Child extends Component \{
			          render() \{
			            return null;
			          \}
			        \}
			      );
			
			      const Parent = connect(null)(
			        class Parent extends Component \{
			          componentWillMount() \{
			            this.props.dispatch(\{ type: 'fetch' \});
			          \}
			
			          componentWillUnmount() \{
			            this.props.dispatch(\{ type: 'clean' \});
			          \}
			
			          render() \{
			            return <Child />;
			          \}
			        \}
			      );
			
			      const store = createStore(reducer);
			      const div = document.createElement('div');
			      render(
			        <ProviderMock store=\{store\}>
			          <Parent />
			        </ProviderMock>,
			        div
			      );
			
			      unmountDOM(div);
			      expect(store.getState().data).toEqual(null);
			    \});
			
			    it('should allow custom displayName', () => \{
			      const MyComponent = connect(null, null, null, \{
			        getDisplayName: (name) => \`Custom(\$\{name\})\`
			      \})(
			        class MyComponent extends Component \{
			          render() \{
			            return <div />;
			          \}
			        \}
			      );
			
			      // This depends on minification, browser support, etc
			      expect(MyComponent.displayName).not.toBe(undefined);
			    \});
			
			    it('should update impure components whenever the state of the store changes', () => \{
			      const store = createStore(() => (\{\}));
			      let renderCount = 0;
			
			      const ImpureComponent = connect(() => (\{\}), null, null, \{ pure: false \})(
			        class ImpureComponent extends Component \{
			          render() \{
			            renderCount++;
			            return <div />;
			          \}
			        \}
			      );
			
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <ImpureComponent />
			        </ProviderMock>
			      );
			
			      const rendersBeforeStateChange = renderCount;
			      store.dispatch(\{ type: 'ACTION' \});
			      expect(renderCount).toBe(rendersBeforeStateChange + 1);
			    \});
			
			    it('should throw a helpful error for invalid mapStateToProps arguments', () => \{
			      const InvalidMapState = connect('invalid')(
			        class InvalidMapState extends Component \{
			          render() \{
			            return <div />;
			          \}
			        \}
			      );
			
			      const error = renderWithBadConnect(InvalidMapState);
			      expect(error).toContain('string');
			      expect(error).toContain('mapStateToProps');
			      if (supportFnName) \{
			        expect(error).toContain('InvalidMapState');
			      \}
			    \});
			
			    it('should throw a helpful error for invalid mapDispatchToProps arguments', () => \{
			      const InvalidMapDispatch = connect(
			        null,
			        'invalid'
			      )(
			        class InvalidMapDispatch extends Component \{
			          render() \{
			            return <div />;
			          \}
			        \}
			      );
			
			      const error = renderWithBadConnect(InvalidMapDispatch);
			      expect(error).toContain('string');
			      expect(error).toContain('mapDispatchToProps');
			      if (supportFnName) \{
			        expect(error).toContain('InvalidMapDispatch');
			      \}
			    \});
			
			    it('should throw a helpful error for invalid mergeProps arguments', () => \{
			      const InvalidMerge = connect(
			        null,
			        null,
			        'invalid'
			      )(
			        class InvalidMerge extends Component \{
			          render() \{
			            return <div />;
			          \}
			        \}
			      );
			
			      const error = renderWithBadConnect(InvalidMerge);
			      expect(error).toContain('string');
			      expect(error).toContain('mergeProps');
			    \});
			
			    it('should notify nested components through a blocking component', () => \{
			      const store = createStore((state = 0, action) => (action.type === 'INC' ? state + 1 : state));
			
			      let mapStateCalls = 0;
			      const mapStateToProps = (state) => \{
			        mapStateCalls++;
			        return \{ count: state \};
			      \};
			
			      const Child = connect(mapStateToProps)(
			        class Child extends Component \{
			          render() \{
			            return <div>\{this.props.count\}</div>;
			          \}
			        \}
			      );
			
			      class BlockUpdates extends Component \{
			        shouldComponentUpdate() \{
			          return false;
			        \}
			
			        render() \{
			          return this.props.children;
			        \}
			      \}
			
			      const Parent = connect((state) => (\{ count: state \}))(
			        class Parent extends Component \{
			          render() \{
			            return (
			              <BlockUpdates>
			                <Child />
			              </BlockUpdates>
			            );
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store\}>
			          <Parent />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      expect(mapStateCalls).toBe(1);
			      store.dispatch(\{ type: 'INC' \});
			      renderToContainer(vNode);
			      expect(mapStateCalls).toBe(2);
			    \});
			
			    it('should subscribe properly when a middle connected component does not subscribe', () => \{
			      const store = createStore((state = 0, action) => (action.type === 'INC' ? state + 1 : state));
			
			      const C = connect((state, props) => \{
			        expect(props.count).toBe(state);
			        return \{ count: state * 10 + props.count \};
			      \})(
			        class C extends Component \{
			          render() \{
			            return <div>\{this.props.count\}</div>;
			          \}
			        \}
			      );
			
			      // no mapStateToProps. therefore it should be transparent for subscriptions
			      const B = connect()(
			        class B extends Component \{
			          render() \{
			            return <C \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const A = connect((state) => (\{ count: state \}))(
			        class A extends Component \{
			          render() \{
			            return <B \{...this.props\} />;
			          \}
			        \}
			      );
			
			      renderToContainer(
			        <ProviderMock store=\{store\}>
			          <A />
			        </ProviderMock>
			      );
			
			      store.dispatch(\{ type: 'INC' \});
			    \});
			
			    it('should subscribe properly when a new store is provided via props', () => \{
			      const store1 = createStore((state = 0, action) => (action.type === 'INC' ? state + 1 : state));
			      const store2 = createStore((state = 0, action) => (action.type === 'INC' ? state + 1 : state));
			
			      const A = connect((state) => (\{ count: state \}))(
			        class A extends Component \{
			          render() \{
			            return <B store=\{store2\} />;
			          \}
			        \}
			      );
			
			      const mapStateToPropsB = jasmine.createSpy((state) => (\{ count: state \}));
			      const B = connect(mapStateToPropsB)(
			        class B extends Component \{
			          render() \{
			            return <C \{...this.props\} />;
			          \}
			        \}
			      );
			
			      const mapStateToPropsC = jasmine.createSpy((state) => (\{ count: state \}));
			      const C = connect(mapStateToPropsC)(
			        class C extends Component \{
			          render() \{
			            return <D />;
			          \}
			        \}
			      );
			
			      const mapStateToPropsD = jasmine.createSpy((state) => (\{ count: state \}));
			      const D = connect(mapStateToPropsD)(
			        class D extends Component \{
			          render() \{
			            return <div>\{this.props.count\}</div>;
			          \}
			        \}
			      );
			
			      const vNode = (
			        <ProviderMock store=\{store1\}>
			          <A />
			        </ProviderMock>
			      );
			      renderToContainer(vNode);
			
			      expect(mapStateToPropsB).toHaveBeenCalledTimes(1);
			      expect(mapStateToPropsC).toHaveBeenCalledTimes(1);
			      expect(mapStateToPropsD).toHaveBeenCalledTimes(1);
			
			      store1.dispatch(\{ type: 'INC' \});
			      renderToContainer(vNode);
			      expect(mapStateToPropsB).toHaveBeenCalledTimes(1);
			      expect(mapStateToPropsC).toHaveBeenCalledTimes(1);
			      expect(mapStateToPropsD).toHaveBeenCalledTimes(2);
			
			      store2.dispatch(\{ type: 'INC' \});
			      renderToContainer(vNode);
			      expect(mapStateToPropsB).toHaveBeenCalledTimes(2);
			      expect(mapStateToPropsC).toHaveBeenCalledTimes(2);
			      expect(mapStateToPropsD).toHaveBeenCalledTimes(2);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-redux\\__tests__\\components\\connect.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(56)
    });
    it('infernojs_inferno\\packages\\inferno-redux\\__tests__\\components\\Provider.spec.js', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			import \{ connect, Provider \} from 'inferno-redux';
			import \{ findRenderedVNodeWithType \} from 'inferno-test-utils';
			import \{ createStore \} from 'redux';
			import \{ VNodeFlags \} from 'inferno-vnode-flags';
			
			describe('redux', () => \{
			  let container;
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  function renderIntoContainer(vNode) \{
			    render(vNode, container);
			
			    if (vNode && vNode.flags & VNodeFlags.Component) \{
			      return vNode.children;
			    \}
			  \}
			
			  describe('Provider', () => \{
			    class Child extends Component \{
			      render() \{
			        return createElement('div', \{\});
			      \}
			    \}
			
			    it('should add the store to the child context', () => \{
			      const store1 = createStore(() => (\{\}));
			      const store2 = createStore(() => (\{\}));
			
			      spyOn(console, 'error');
			
			      let tree = renderIntoContainer(createElement(Provider, \{ store: store1 \}, createElement(Child, \{\})));
			      expect(console.error).toHaveBeenCalledTimes(0);
			
			      let child = findRenderedVNodeWithType(tree, Child).children;
			      expect(child.context.store).toBe(store1);
			
			      tree = renderIntoContainer(createElement(Provider, \{ store: store1 \}, createElement(Provider, \{ store: store2 \}, createElement(Child, \{\}))));
			
			      expect(console.error).toHaveBeenCalledTimes(0);
			
			      child = findRenderedVNodeWithType(tree, Child).children;
			      expect(child.context.store).toBe(store2);
			    \});
			
			    it('should warn once when receiving a new store in props', () => \{
			      const store1 = createStore((state = 10) => state + 1);
			      const store2 = createStore((state = 10) => state * 2);
			      const store3 = createStore((state = 10) => state * state);
			
			      class ProviderContainer extends Component \{
			        constructor() \{
			          super();
			          this.state = \{ store: store1 \};
			        \}
			
			        render() \{
			          return (
			            <Provider store=\{this.state.store\}>
			              <Child />
			            </Provider>
			          );
			        \}
			      \}
			
			      const vNode = <ProviderContainer />;
			      const container = renderIntoContainer(vNode);
			      const child = findRenderedVNodeWithType(container, Child).children;
			      expect(child.context.store.getState()).toEqual(11);
			
			      spyOn(console, 'error');
			      container.setState(\{ store: store2 \});
			      renderIntoContainer(vNode);
			
			      expect(child.context.store.getState()).toEqual(11);
			      expect(console.error).toHaveBeenCalledTimes(1);
			      expect(console.error).toHaveBeenCalledWith('<Provider> does not support changing \`store\` on the fly.');
			
			      container.setState(\{ store: store3 \});
			      renderIntoContainer(vNode);
			
			      expect(child.context.store.getState()).toEqual(11);
			      expect(console.error).toHaveBeenCalledTimes(1);
			    \});
			
			    it('should handle subscriptions correctly when there is nested Providers', () => \{
			      const reducer1 = (state = 2, action) => (action.type === 'INC' ? state + 1 : state);
			      const reducer2 = (state = 5, action) => (action.type === 'INC' ? state + 2 : state);
			
			      const innerStore = createStore(reducer1);
			      innerStore.__store_name__ = 'innerStore'; // for debugging
			      const innerMapStateToProps = jasmine.createSpy((state) => (\{ count: state \}));
			
			      const Inner = connect(innerMapStateToProps)(
			        class Inner extends Component \{
			          render() \{
			            return <div>\{this.props.count\}</div>;
			          \}
			        \}
			      );
			
			      const outerStore = createStore(reducer2);
			      outerStore.__store_name__ = 'outerStore'; // for debugging
			      const Outer = connect((state) => (\{ count: state \}))(
			        class Outer extends Component \{
			          render() \{
			            return (
			              <Provider store=\{innerStore\}>
			                <Inner />
			              </Provider>
			            );
			          \}
			        \}
			      );
			
			      renderIntoContainer(
			        <Provider store=\{outerStore\}>
			          <Outer />
			        </Provider>
			      );
			      expect(innerMapStateToProps.calls.count()).toEqual(1);
			
			      innerStore.dispatch(\{ type: 'INC' \});
			      expect(innerMapStateToProps.calls.count()).toEqual(2);
			    \});
			
			    it('should pass state consistently to mapState', () => \{
			      const stringBuilder = (prev = '', action) => (action.type === 'APPEND' ? prev + action.payload : prev);
			
			      const store = createStore(stringBuilder);
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			      let childMapStateInvokes = 0;
			
			      const ChildContainer = connect((state, parentProps) => \{
			        childMapStateInvokes++;
			        // The state from parent props should always be consistent with the current state
			        expect(state).toBe(parentProps.parentState);
			        return \{\};
			      \})(
			        class ChildContainer extends Component \{
			          render() \{
			            return <div />;
			          \}
			        \}
			      );
			
			      const Container = connect((state) => (\{ state \}), null, null, \{
			        withRef: true
			      \})(
			        class Container extends Component \{
			          emitChange() \{
			            store.dispatch(\{ type: 'APPEND', payload: 'b' \});
			          \}
			
			          render() \{
			            // NOTE: This should really be onClick not onclick. More bugs in inferno event delegation?
			            return (
			              <div>
			                <button
			                  ref=\{(btn) => \{
			                    this.button = btn;
			                  \}\}
			                  onClick=\{this.emitChange.bind(this)\}
			                >
			                  change
			                </button>
			                <ChildContainer parentState=\{this.props.state\} />
			              </div>
			            );
			          \}
			        \}
			      );
			
			      const vNode = (
			        <Provider store=\{store\}>
			          <Container />
			        </Provider>
			      );
			      const tree = renderIntoContainer(vNode);
			
			      expect(childMapStateInvokes).toEqual(1);
			
			      // The store state stays consistent when setState calls are batched
			      store.dispatch(\{ type: 'APPEND', payload: 'c' \});
			      renderIntoContainer(vNode);
			      expect(childMapStateInvokes).toEqual(2);
			
			      // setState calls DOM handlers are batched
			      const container = findRenderedVNodeWithType(tree, Container).children;
			      const node = container.getWrappedInstance().button;
			      node.click();
			      renderIntoContainer(vNode);
			      expect(childMapStateInvokes).toEqual(3);
			
			      // Provider uses unstable_batchedUpdates() under the hood
			      store.dispatch(\{ type: 'APPEND', payload: 'd' \});
			      renderIntoContainer(vNode);
			      expect(childMapStateInvokes).toEqual(4);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-redux\\__tests__\\components\\Provider.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-redux\\__tests__\\components\\Provider.typings.tsx', () => {
        const sourceCode = `
			import \{ AnyAction, createStore \} from 'redux';
			
			import \{ render \} from 'inferno';
			import \{ Provider \} from 'inferno-redux';
			
			describe('Component typings', () => \{
			  // Basic app state for typing reducer arguments.
			  interface AppState \{
			    posts?: string[];
			  \}
			
			  let container: Element;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  it('should accept store with default action type', () => \{
			    const rootReducer = (state: AppState = \{\}, _: AnyAction) => \{
			      return state;
			    \};
			
			    const store = createStore(rootReducer);
			
			    render(<Provider store=\{store\}></Provider>, container);
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should accept store with custom action type', () => \{
			    // Some custom action interfaces
			    interface FetchPostsAction \{
			      type: 'FETCH_ACTION';
			      data: string;
			    \}
			
			    interface ReceivePostsAction \{
			      type: 'RECEIVE_ACTION';
			      data: string;
			    \}
			
			    type MyAction = FetchPostsAction | ReceivePostsAction;
			
			    const rootReducer = (state: AppState = \{\}, _: MyAction) => state;
			    const store = createStore(rootReducer);
			
			    render(<Provider store=\{store\}></Provider>, container);
			    expect(container.innerHTML).toBe('');
			  \});
			
			  it('should accept children', () => \{
			    const HelloComponent = () => <p>Hello my friends!</p>;
			
			    const store = createStore(() => (\{\}));
			
			    render(
			      <Provider store=\{store\}>
			        <h1>Hello Page</h1>
			        <HelloComponent />
			        <p>Another greetings!</p>
			      </Provider>,
			      container
			    );
			    expect(container.innerHTML).toBe('<h1>Hello Page</h1><p>Hello my friends!</p><p>Another greetings!</p>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-redux\\__tests__\\components\\Provider.typings.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-redux\\__tests__\\functional.spec.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ connect \} from 'inferno-redux';
			import \{ createStore \} from 'redux';
			
			describe('Inferno - redux -specifics', () => \{
			  let container;
			
			  const stringBuilder = (prev = '', action) => (action.type === 'APPEND' ? prev + action.payload : prev);
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  describe('Functional component connect', () => \{
			    it('Should be possible to define lifecycle events', () => \{
			      const store = createStore(stringBuilder);
			      let mountedCalled = 0;
			
			      function FunctionalComponent() \{
			        return <div>Hello world</div>;
			      \}
			
			      const Container = connect(
			        () => (\{\}),
			        (dispatch) => (\{
			          dispatch,
			          ref: \{
			            onComponentDidMount() \{
			              mountedCalled++;
			            \}
			          \}
			        \})
			      )(FunctionalComponent);
			
			      const div = document.createElement('div');
			
			      render(<Container store=\{store\} />, div);
			
			      expect(mountedCalled).toBe(1);
			
			      expect(div.innerHTML).toBe('<div>Hello world</div>');
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			
			      render(<Container store=\{store\} />, div);
			
			      expect(div.innerHTML).toBe('<div>Hello world</div>');
			      expect(mountedCalled).toBe(1);
			    \});
			
			    it('Should be possible to define default lifecycle events', () => \{
			      const store = createStore(stringBuilder);
			      let mountedCalled = 0;
			      let updateCounter = 0;
			
			      function FunctionalComponent(props) \{
			        return <div>Hello \{props.name\}!</div>;
			      \}
			
			      FunctionalComponent.defaultHooks = \{
			        onComponentWillUpdate() \{
			          updateCounter++;
			        \}
			      \};
			
			      const Container = connect(
			        () => (\{\}),
			        (dispatch) => (\{
			          dispatch,
			          ref: \{
			            onComponentDidMount() \{
			              mountedCalled++;
			            \}
			          \}
			        \})
			      )(FunctionalComponent);
			
			      const div = document.createElement('div');
			
			      render(<Container name="Inferno" store=\{store\} />, div);
			
			      expect(updateCounter).toBe(0);
			      expect(mountedCalled).toBe(1);
			
			      expect(div.innerHTML).toBe('<div>Hello Inferno!</div>');
			
			      store.dispatch(\{ type: 'APPEND', payload: 'a' \});
			
			      render(<Container name="Inferno1" store=\{store\} />, div);
			      expect(div.innerHTML).toBe('<div>Hello Inferno1!</div>');
			      expect(updateCounter).toBe(1);
			      expect(mountedCalled).toBe(1);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-redux\\__tests__\\functional.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-redux\\__tests__\\utils\\shallowEqual.spec.js', () => {
        const sourceCode = `
			import \{ shallowEqual \} from '../../src/utils/shallowEqual';
			
			describe('redux', () => \{
			  describe('utils', () => \{
			    describe('shallowEqual', () => \{
			      it('should return true if arguments fields are equal', () => \{
			        expect(shallowEqual(\{ a: 1, b: 2, c: undefined \}, \{ a: 1, b: 2, c: undefined \})).toBe(true);
			
			        expect(shallowEqual(\{ a: 1, b: 2, c: 3 \}, \{ a: 1, b: 2, c: 3 \})).toBe(true);
			
			        const o = \{\};
			        expect(shallowEqual(\{ a: 1, b: 2, c: o \}, \{ a: 1, b: 2, c: o \})).toBe(true);
			
			        const d = function () \{
			          return 1;
			        \};
			        expect(shallowEqual(\{ a: 1, b: 2, c: o, d \}, \{ a: 1, b: 2, c: o, d \})).toBe(true);
			      \});
			
			      it('should return false if arguments fields are different function identities', () => \{
			        expect(
			          shallowEqual(
			            // tslint:disable-next-line:object-literal-shorthand
			            \{
			              a: 1,
			              b: 2,
			              d: function () \{
			                return 1;
			              \}
			            \},
			            // tslint:disable-next-line:object-literal-shorthand
			            \{
			              a: 1,
			              b: 2,
			              d: function () \{
			                return 1;
			              \}
			            \}
			          )
			        ).toBe(false);
			      \});
			
			      it('should return false if first argument has too many keys', () => \{
			        expect(shallowEqual(\{ a: 1, b: 2, c: 3 \}, \{ a: 1, b: 2 \})).toBe(false);
			      \});
			
			      it('should return false if second argument has too many keys', () => \{
			        expect(shallowEqual(\{ a: 1, b: 2 \}, \{ a: 1, b: 2, c: 3 \})).toBe(false);
			      \});
			
			      it('should return false if arguments have different keys', () => \{
			        expect(shallowEqual(\{ a: 1, b: 2, c: undefined \}, \{ a: 1, bb: 2, c: undefined \})).toBe(false);
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-redux\\__tests__\\utils\\shallowEqual.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(5)
    });
    it('infernojs_inferno\\packages\\inferno-redux\\__tests__\\utils\\wrapActionCreators.spec.js', () => {
        const sourceCode = `
			import \{ wrapActionCreators \} from 'inferno-redux';
			
			describe('Utils', () => \{
			  describe('wrapActionCreators', () => \{
			    it('should return a function that wraps argument in a call to bindActionCreators', () => \{
			      const dispatch = (action) => (\{ dispatched: action \});
			      const actionResult = \{ an: 'action' \};
			      const actionCreators = \{
			        action: () => actionResult
			      \};
			
			      const wrapped = wrapActionCreators(actionCreators);
			      expect(typeof wrapped).toBe('function');
			      expect(() => wrapped(dispatch)).not.toThrowError();
			      expect(() => wrapped().action()).toThrowError();
			
			      const bound = wrapped(dispatch);
			      expect(bound.action).not.toThrowError();
			      expect(bound.action().dispatched).toBe(actionResult);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-redux\\__tests__\\utils\\wrapActionCreators.spec.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\BrowserRouter.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ BrowserRouter \} from 'inferno-router';
			
			describe('BrowserRouter (jsx)', () => \{
			  it('puts history on context.router', () => \{
			    const node = document.createElement('div');
			    let history;
			    const ContextChecker = (_props, context) => \{
			      history = context.router.history;
			      return null;
			    \};
			
			    render(
			      <BrowserRouter>
			        <ContextChecker />
			      </BrowserRouter>,
			      node
			    );
			
			    expect(typeof history).toBe('object');
			  \});
			
			  it('warns when passed a history prop', () => \{
			    const node = document.createElement('div');
			    const history = \{\};
			
			    const consoleSpy = spyOn(console, 'error');
			
			    // @ts-ignore
			    render(<BrowserRouter history=\{history\} />, node);
			
			    expect(consoleSpy).toHaveBeenCalledTimes(1);
			
			    // browser only?
			    expect(consoleSpy.calls.argsFor(0)[0]).toContain('<BrowserRouter> ignores the history prop');
			
			    // node only?
			    // expect(console.error).toHaveBeenCalledWith(
			    //  expect.stringContaining('<BrowserRouter> ignores the history prop')
			    // )
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\BrowserRouter.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\github1176.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ Link, Route, Router, Switch \} from 'inferno-router';
			import \{ triggerEvent \} from 'inferno-utils';
			import \{ createMemoryHistory \} from 'history';
			
			describe('Github1176', () => \{
			  let container;
			  const browserHistory = createMemoryHistory();
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should not crash', (done) => \{
			    const Loader = () => <div className="loader">Loader...</div>;
			
			    class Component1 extends Component<any, any> \{
			      public render() \{
			        return (
			          <div className="component1">
			            Component 1 <br />
			            <Link id="com2" to="/component2">
			              Link to component 2
			            </Link>
			          </div>
			        );
			      \}
			    \}
			
			    class Component2 extends Component<any, any> \{
			      constructor(props) \{
			        super(props);
			
			        this.state = \{
			          loading: true
			        \};
			      \}
			
			      public componentDidMount() \{
			        setTimeout(() => \{
			          this.setState(\{
			            loading: false
			          \});
			        \}, 10);
			      \}
			
			      public clearApp() \{
			        render(null, container);
			      \}
			
			      public render() \{
			        if ((this.state as any).loading) \{
			          return <Loader />;
			        \}
			
			        return (
			          <div className="component2">
			            Component 2 <br />
			            <span id="clear" onClick=\{this.clearApp\}>
			              clear app
			            </span>
			          </div>
			        );
			      \}
			    \}
			
			    function Foobar() \{
			      return <div>Ok</div>;
			    \}
			
			    const routes = (
			      <Router history=\{browserHistory\}>
			        <Switch>
			          <Route component=\{Component1\} path="/" exact />
			          <Route component=\{Component2\} path="/component2" exact />
			          <Route component=\{Foobar\} path="/component333" exact />
			        </Switch>
			      </Router>
			    );
			
			    render(routes, container);
			
			    expect(container.querySelectorAll('.component1').length).toBe(1);
			    const div2 = container.querySelector('#com2');
			    triggerEvent('click', div2);
			
			    setTimeout(() => \{
			      expect(container.querySelectorAll('.component1').length).toBe(0);
			      expect(container.querySelectorAll('.component2').length).toBe(1);
			
			      const clear = container.querySelector('#clear');
			      clear.click();
			
			      expect(container.innerHTML).toBe('');
			      expect(container.querySelectorAll('.component2').length).toBe(0);
			      expect(container.querySelectorAll('.component1').length).toBe(0);
			      done();
			    \}, 25);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\github1176.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\HashRouter.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ HashRouter \} from 'inferno-router';
			
			describe('A <HashRouter>', () => \{
			  it('puts history on context.router', () => \{
			    let history;
			    const ContextChecker = (_props, context) => \{
			      history = context.router.history;
			      return null;
			    \};
			
			    const node = document.createElement('div');
			
			    render(
			      <HashRouter>
			        <ContextChecker />
			      </HashRouter>,
			      node
			    );
			
			    expect(typeof history).toBe('object');
			  \});
			
			  it('warns when passed a history prop', () => \{
			    const history = \{\};
			    const node = document.createElement('div');
			
			    const consoleSpy = spyOn(console, 'error');
			
			    // @ts-ignore
			    render(<HashRouter history=\{history\} />, node);
			
			    expect(consoleSpy).toHaveBeenCalledTimes(1);
			    expect(consoleSpy.calls.argsFor(0)[0]).toContain('<HashRouter> ignores the history prop');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\HashRouter.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\integration.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ MemoryRouter, Route \} from 'inferno-router';
			
			describe('Integration Tests', () => \{
			  it('renders nested matches', () => \{
			    const node = document.createElement('div');
			    const TEXT1 = 'Ms. Tripp';
			    const TEXT2 = 'Mrs. Schiffman';
			    render(
			      <MemoryRouter initialEntries=\{['/nested']\}>
			        <Route
			          path="/"
			          render=\{() => (
			            <div>
			              <h1>\{TEXT1\}</h1>
			              <Route path="/nested" render=\{() => <h2>\{TEXT2\}</h2>\} />
			            </div>
			          )\}
			        />
			      </MemoryRouter>,
			      node
			    );
			    expect(node.innerHTML).toContain(TEXT1);
			    expect(node.innerHTML).toContain(TEXT2);
			  \});
			
			  it('renders only as deep as the matching Route', () => \{
			    const node = document.createElement('div');
			    const TEXT1 = 'Ms. Tripp';
			    const TEXT2 = 'Mrs. Schiffman';
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{() => (
			            <div>
			              <h1>\{TEXT1\}</h1>
			              <Route path="/nested" render=\{() => <h2>\{TEXT2\}</h2>\} />
			            </div>
			          )\}
			        />
			      </MemoryRouter>,
			      node
			    );
			    expect(node.innerHTML).toContain(TEXT1);
			    expect(node.innerHTML).not.toContain(TEXT2);
			  \});
			
			  it('renders multiple matching routes', () => \{
			    const node = document.createElement('div');
			    const TEXT1 = 'Mrs. Schiffman';
			    const TEXT2 = 'Mrs. Burton';
			    render(
			      <MemoryRouter initialEntries=\{['/double']\}>
			        <div>
			          <aside>
			            <Route path="/double" render=\{() => <h1>\{TEXT1\}</h1>\} />
			          </aside>
			          <main>
			            <Route path="/double" render=\{() => <h1>\{TEXT2\}</h1>\} />
			          </main>
			        </div>
			      </MemoryRouter>,
			      node
			    );
			    expect(node.innerHTML).toContain(TEXT1);
			    expect(node.innerHTML).toContain(TEXT2);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\integration.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\issue1322.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ Link, MemoryRouter, NavLink, Route \} from 'inferno-router';
			
			describe('Github #1322', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should _always_ patch children when route is changed', () => \{
			    const Home = () => (
			      <div>
			        <h2>Home</h2>
			      </div>
			    );
			
			    const About = () => (
			      <div>
			        <h2>About</h2>
			      </div>
			    );
			
			    const Topic = (\{ match \}) => (
			      <div>
			        <h3>\{match.params.topicId\}</h3>
			      </div>
			    );
			
			    const Topics = (\{ match \}) => (
			      <div>
			        <h2>Topics</h2>
			        <ul>
			          <li>
			            <Link to=\{\`\$\{match.url\}/rendering\`\}>Rendering with React</Link>
			          </li>
			          <li>
			            <Link to=\{\`\$\{match.url\}/components\`\}>Components</Link>
			          </li>
			          <li>
			            <Link to=\{\`\$\{match.url\}/props-v-state\`\}>Props v. State</Link>
			          </li>
			        </ul>
			
			        <Route path=\{\`\$\{match.url\}/:topicId\`\} component=\{Topic\} />
			        <Route exact path=\{match.url\} render=\{() => <h3>Please select a topic.</h3>\} />
			      </div>
			    );
			
			    const MyWebsite = () => (
			      <MemoryRouter>
			        <div>
			          <ul>
			            <li>
			              <Link to="/">Home</Link>
			            </li>
			            <li>
			              <Link to="/about">About</Link>
			            </li>
			            <li>
			              <Link to="/topics">Topics</Link>
			            </li>
			          </ul>
			
			          <hr />
			
			          <Route exact path="/" component=\{Home\} />
			          <Route path="/about" component=\{About\} />
			          <Route path="/topics" component=\{Topics\} />
			        </div>
			      </MemoryRouter>
			    );
			
			    render(<MyWebsite />, container);
			
			    expect(container.querySelector('h2').innerHTML).toEqual('Home');
			
			    const aboutLink = container.querySelectorAll('a')[1];
			
			    aboutLink.click();
			
			    expect(container.querySelector('h2').innerHTML).toEqual('About');
			
			    const homeLink = container.querySelectorAll('a')[0];
			
			    homeLink.click();
			
			    expect(container.querySelector('h2').innerHTML).toEqual('Home');
			  \});
			
			  it('Should change activeClass on links without functional component Wrapper, Github #1345', () => \{
			    function CompList() \{
			      return <div id="first">FIRST</div>;
			    \}
			
			    function CreateComp() \{
			      return <div id="second">SECOND</div>;
			    \}
			
			    const tree = (
			      <MemoryRouter>
			        <div>
			          <nav class="navbar navbar-expand-lg navbar-light bg-light">
			            <div class="container py-2" style="border-bottom: 1px solid rgba(0, 0, 0, 0.13);">
			              <div class="collapse navbar-collapse" id="navbarNav">
			                <ul class="navbar-nav text-muted">
			                  <li class="nav-item mr-2">
			                    <NavLink exact to="/" activeClassName="active">
			                      Play
			                    </NavLink>
			                  </li>
			                  <li class="nav-item mr-2">
			                    <NavLink to="/create" activeClassName="active">
			                      Create
			                    </NavLink>
			                  </li>
			                  <li class="nav-item mr-2">
			                    <NavLink to="/publish" activeClassName="active">
			                      Publish
			                    </NavLink>
			                  </li>
			                </ul>
			              </div>
			            </div>
			          </nav>
			          <Route exact path="/" component=\{CompList\} />
			          <Route path="/create" component=\{CreateComp\} />
			          <Route path="/publish" component=\{() => <div>Publish</div>\} />
			        </div>
			      </MemoryRouter>
			    );
			
			    render(tree, container);
			
			    expect(container.querySelector('#first')).toBeDefined();
			
			    const links = container.querySelectorAll('li');
			
			    expect(links[0].firstChild.classList.contains('active')).toBeTruthy();
			
			    links[1].firstChild.click();
			
			    expect(links[0].firstChild.classList.contains('active')).toBeFalsy();
			    expect(links[1].firstChild.classList.contains('active')).toBeTruthy();
			    expect(container.querySelector('#first')).toBeNull();
			    expect(container.querySelector('#second')).toBeDefined();
			
			    links[0].firstChild.click();
			    expect(links[0].firstChild.classList.contains('active')).toBeTruthy();
			    expect(links[1].firstChild.classList.contains('active')).toBeFalsy();
			    expect(container.querySelector('#first')).toBeDefined();
			    expect(container.querySelector('#second')).toBeNull();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\issue1322.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\Link.ext.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ triggerEvent \} from 'inferno-utils';
			import \{ Link, MemoryRouter \} from 'inferno-router';
			
			// These tests are not part of RR4 but it seems to be like they should pass
			describe('Link (jsx)', () => \{
			  let node;
			  beforeEach(function () \{
			    node = document.createElement('div');
			    document.body.appendChild(node);
			  \});
			
			  afterEach(function () \{
			    render(null, node);
			    document.body.removeChild(node);
			  \});
			
			  it('should trigger when clicked', () => \{
			    let history;
			    const ContextChecker = (props, context) => \{
			      history = context.router.history;
			      return props.children;
			    \};
			
			    render(
			      <div>
			        <MemoryRouter>
			          <ContextChecker>
			            <Link to="/clicked">link</Link>
			          </ContextChecker>
			        </MemoryRouter>
			      </div>,
			      node
			    );
			
			    const element = node.querySelector('a');
			    triggerEvent('click', element);
			    expect(history.location.pathname).toBe('/clicked');
			  \});
			
			  it('should trigger custom onClick', () => \{
			    const spy = jasmine.createSpy('spy');
			
			    render(
			      <MemoryRouter>
			        <Link to="/" onClick=\{spy\}>
			          link
			        </Link>
			      </MemoryRouter>,
			      node
			    );
			    expect(spy).toHaveBeenCalledTimes(0);
			    const element = node.querySelector('a');
			    triggerEvent('click', element);
			    expect(spy).toHaveBeenCalledTimes(1);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\Link.ext.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\Link.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ HashRouter, Link, MemoryRouter \} from 'inferno-router';
			import \{ createMemoryHistory, parsePath \} from 'history';
			
			describe('Link (jsx)', () => \{
			  let node;
			  beforeEach(function () \{
			    node = document.createElement('div');
			    document.body.appendChild(node);
			  \});
			
			  afterEach(function () \{
			    render(null, node);
			    document.body.removeChild(node);
			  \});
			
			  it('accepts a location \`to\` prop', () => \{
			    render(
			      <MemoryRouter>
			        <Link to=\{parsePath('/the/path?the=query#the-hash')\}>link</Link>
			      </MemoryRouter>,
			      node
			    );
			
			    const href = node.querySelector('a').getAttribute('href');
			
			    expect(href).toEqual('/the/path?the=query#the-hash');
			  \});
			
			  it('throws with no <Router>', () => \{
			    expect(() => \{
			      render(<Link to="/">link</Link>, node);
			    \}).toThrowError(/You should not use <Link> outside a <Router>/);
			  \});
			
			  it('exposes its ref via an innerRef prop', (done) => \{
			    const testNode = document.createElement('div');
			    const refCallback = (n) => \{
			      expect(n.tagName).toEqual('A');
			      done();
			    \};
			
			    render(
			      <MemoryRouter>
			        <Link to="/" innerRef=\{refCallback\}>
			          link
			        </Link>
			      </MemoryRouter>,
			      testNode
			    );
			
			    expect(testNode.textContent).toEqual('link');
			  \});
			\});
			
			describe('A <Link> underneath a <HashRouter>', () => \{
			  let node;
			  beforeEach(function () \{
			    node = document.createElement('div');
			    document.body.appendChild(node);
			  \});
			
			  afterEach(function () \{
			    render(null, node);
			    document.body.removeChild(node);
			  \});
			
			  const createLinkNode = (to) => \{
			    render(
			      <HashRouter>
			        <Link to=\{to\} />
			      </HashRouter>,
			      node
			    );
			
			    return node.querySelector('a');
			  \};
			
			  it('has the correct href', () => \{
			    const linkNode = createLinkNode('/foo');
			    expect(linkNode.getAttribute('href')).toEqual('#/foo');
			  \});
			
			  it('has the correct href #2', () => \{
			    const linkNode = createLinkNode('foo');
			    expect(linkNode.getAttribute('href')).toEqual('#foo');
			  \});
			
			  it('accepts a string \`to\` prop', () => \{
			    const to = '/the/path?the=query#the-hash';
			
			    render(
			      <MemoryRouter>
			        <Link to=\{to\}>link</Link>
			      </MemoryRouter>,
			      node
			    );
			
			    const a = node.querySelector('a');
			
			    expect(a.getAttribute('href')).toEqual('/the/path?the=query#the-hash');
			  \});
			
			  it('accepts an object \`to\` prop', () => \{
			    const to = \{
			      hash: '#the-hash',
			      pathname: '/the/path',
			      search: 'the=query'
			    \};
			
			    render(
			      <MemoryRouter>
			        <Link to=\{to\}>link</Link>
			      </MemoryRouter>,
			      node
			    );
			
			    const a = node.querySelector('a');
			
			    expect(a.getAttribute('href')).toEqual('/the/path?the=query#the-hash');
			  \});
			
			  it('accepts an object \`to\` prop with state', () => \{
			    const memoryHistoryFoo = createMemoryHistory(\{
			      initialEntries: ['/foo']
			    \});
			    memoryHistoryFoo.push = jasmine.createSpy();
			
			    const clickHandler = jasmine.createSpy();
			
			    const to = \{
			      hash: '#the-hash',
			      pathname: '/the/path',
			      search: 'the=query',
			      state: \{ test: 'ok' \}
			    \};
			
			    class ContextChecker extends Component \{
			      public getChildContext() \{
			        const \{ context \} = this;
			        context.router.history = memoryHistoryFoo;
			
			        return \{
			          router: context.router
			        \};
			      \}
			
			      public render(\{ children \}) \{
			        return children;
			      \}
			    \}
			
			    render(
			      <MemoryRouter>
			        <ContextChecker>
			          <Link to=\{to\} onClick=\{clickHandler\}>
			            link
			          </Link>
			        </ContextChecker>
			      </MemoryRouter>,
			      node
			    );
			
			    const a = node.querySelector('a');
			    a.click();
			
			    expect(clickHandler).toHaveBeenCalledTimes(1);
			    expect(memoryHistoryFoo.push).toHaveBeenCalledTimes(1);
			    const \{ hash, pathname, search, state \} = to;
			    expect(memoryHistoryFoo.push).toHaveBeenCalledWith(\{ hash, pathname, search \}, state);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\Link.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\loaderOnRoute.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ BrowserRouter, MemoryRouter, StaticRouter, Route, NavLink, useLoaderData, useLoaderError, resolveLoaders, traverseLoaders \} from 'inferno-router';
			// Cherry picked relative import so we don't get node-stuff from inferno-server in browser test
			import \{ createEventGuard, createResponse \} from './testUtils';
			
			describe('A <Route> with loader in a MemoryRouter', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('renders on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEXT \};
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const data = useLoaderData(props);
			            return <h1>\{data?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('renders error on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'An error';
			    const loaderFunc = async () => \{
			      setDone();
			      throw new Error(TEXT);
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const err = useLoaderError(props);
			            return <h1>\{err?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Can access initialData (for hydration)', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			    const initialData = \{
			      '/flowers': \{ res: await loaderFunc(), err: undefined \}
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/flowers']\} initialData=\{initialData\}>
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFunc\} />
			      </MemoryRouter>,
			      container
			    );
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Should render component after after click', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEST = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEST \};
			    \};
			
			    function RootComp() \{
			      return <div id="root">ROOT</div>;
			    \}
			
			    function CreateComp(props) \{
			      const res = useLoaderData(props);
			      return <div id="create">\{res.message\}</div>;
			    \}
			
			    function PublishComp() \{
			      return <div id="publish">PUBLISH</div>;
			    \}
			
			    const tree = (
			      <MemoryRouter>
			        <div>
			          <nav>
			            <ul>
			              <li>
			                <NavLink exact to="/">
			                  Play
			                </NavLink>
			              </li>
			              <li id="createNav">
			                <NavLink to="/create">Create</NavLink>
			              </li>
			              <li>
			                <NavLink to="/publish">Publish</NavLink>
			              </li>
			            </ul>
			          </nav>
			          <Route exact path="/" component=\{RootComp\} />
			          <Route path="/create" component=\{CreateComp\} loader=\{loaderFunc\} />
			          <Route path="/publish" component=\{PublishComp\} />
			        </div>
			      </MemoryRouter>
			    );
			
			    render(tree, container);
			
			    expect(container.innerHTML).toContain('ROOT');
			
			    // Click create
			    const link = container.querySelector('#createNav');
			    link.firstChild.click();
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.querySelector('#create').innerHTML).toContain(TEST);
			  \});
			
			  it('Should recieve params in loader', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return (
			        <div>
			          <h1>\{res?.message\}</h1>
			          <p>\{res?.slug\}</p>
			        </div>
			      );
			    \};
			    const loaderFunc = async (\{ params: paramsIn \}: any) => \{
			      return \{ message: TEXT, slug: paramsIn?.slug \};
			    \};
			
			    const params = \{ slug: 'flowers' \};
			    const initialData = \{
			      '/:slug': \{ res: await loaderFunc(\{ params \}), err: undefined \}
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/flowers']\} initialData=\{initialData\}>
			        <Route path="/:slug" render=\{Component\} loader=\{loaderFunc\} />
			      </MemoryRouter>,
			      container
			    );
			
			    expect(container.innerHTML).toContain(TEXT);
			    expect(container.innerHTML).toContain('flowers');
			  \});
			
			  it('Can abort fetch', async () => \{
			    const abortCalls = \{
			      nrofCalls: 0
			    \};
			    const _abortFn = AbortController.prototype.abort;
			    AbortController.prototype.abort = () => \{
			      abortCalls.nrofCalls++;
			    \};
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEST = 'ok';
			
			    const loaderFunc = async (\{ request \}) => \{
			      expect(request).toBeDefined();
			      expect(request.signal).toBeDefined();
			      return new Promise((resolve) => \{
			        setTimeout(() => \{
			          setDone();
			          resolve(\{ message: TEST \});
			        \}, 5);
			      \});
			    \};
			
			    function RootComp() \{
			      return <div id="root">ROOT</div>;
			    \}
			
			    function CreateComp(props) \{
			      const res = useLoaderData(props);
			      return <div id="create">\{res.message\}</div>;
			    \}
			
			    function PublishComp() \{
			      return <div id="publish">PUBLISH</div>;
			    \}
			
			    const tree = (
			      <MemoryRouter>
			        <div>
			          <nav>
			            <ul>
			              <li>
			                <NavLink exact to="/">
			                  Play
			                </NavLink>
			              </li>
			              <li id="createNav">
			                <NavLink to="/create">Create</NavLink>
			              </li>
			              <li id="publishNav">
			                <NavLink to="/publish">Publish</NavLink>
			              </li>
			            </ul>
			          </nav>
			          <Route exact path="/" component=\{RootComp\} />
			          <Route path="/create" component=\{CreateComp\} loader=\{loaderFunc\} />
			          <Route path="/publish" component=\{PublishComp\} />
			        </div>
			      </MemoryRouter>
			    );
			
			    render(tree, container);
			
			    expect(container.innerHTML).toContain('ROOT');
			
			    // Click create
			    container.querySelector('#createNav').firstChild.click();
			    container.querySelector('#publishNav').firstChild.click();
			
			    await waitForRerender();
			
			    expect(abortCalls.nrofCalls).toEqual(1);
			    expect(container.querySelector('#create')).toBeNull();
			    AbortController.prototype.abort = _abortFn;
			  \});
			\});
			
			describe('A <Route> with loader in a BrowserRouter', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    // Reset history to root
			    history.replaceState(undefined, '', '/');
			  \});
			
			  it('renders on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEXT \};
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const data = useLoaderData(props);
			            return <h1>\{data?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('renders error on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'An error';
			    const loaderFunc = async () => \{
			      setDone();
			      throw new Error(TEXT);
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const err = useLoaderError(props);
			            return <h1>\{err?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Can access initialData (for hydration)', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			
			    const initialData = \{
			      '/flowers': \{ res: await loaderFunc(), err: undefined \}
			    \};
			
			    history.replaceState(undefined, '', '/flowers');
			    render(
			      <BrowserRouter initialData=\{initialData\}>
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFunc\} />
			      </BrowserRouter>,
			      container
			    );
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Should render component after after click', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			    const TEST = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEST \};
			    \};
			
			    function RootComp() \{
			      return <div id="root">ROOT</div>;
			    \}
			
			    function CreateComp(props) \{
			      const res = useLoaderData(props);
			      return <div id="create">\{res.message\}</div>;
			    \}
			
			    function PublishComp() \{
			      return <div id="publish">PUBLISH</div>;
			    \}
			
			    const tree = (
			      <BrowserRouter>
			        <div>
			          <nav>
			            <ul>
			              <li>
			                <NavLink exact to="/">
			                  Play
			                </NavLink>
			              </li>
			              <li id="createNav">
			                <NavLink to="/create">Create</NavLink>
			              </li>
			              <li>
			                <NavLink to="/publish">Publish</NavLink>
			              </li>
			            </ul>
			          </nav>
			          <Route exact path="/" component=\{RootComp\} />
			          <Route path="/create" component=\{CreateComp\} loader=\{loaderFunc\} />
			          <Route path="/publish" component=\{PublishComp\} />
			        </div>
			      </BrowserRouter>
			    );
			
			    render(tree, container);
			
			    expect(container.innerHTML).toContain('ROOT');
			
			    // Click create
			    const link = container.querySelector('#createNav');
			    link.firstChild.click();
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.querySelector('#create').innerHTML).toContain(TEST);
			  \});
			
			  it('calls json() when response is received', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      const data = \{ message: TEXT \};
			      return createResponse(data, 'json', 200);
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const data = useLoaderData(props);
			            return <h1>\{data?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('calls text() when response is received', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      const data = TEXT;
			      return createResponse(data, 'text', 200);
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const data = useLoaderData(props);
			            return <h1>\{data\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			\});
			
			describe('A <Route> with loader in a StaticRouter', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    // Reset history to root
			    history.replaceState(undefined, '', '/');
			  \});
			
			  it('renders on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEXT \};
			    \};
			
			    render(
			      <StaticRouter context=\{\{\}\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const data = useLoaderData(props);
			            return <h1>\{data?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </StaticRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('renders error on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'An error';
			    const loaderFunc = async () => \{
			      setDone();
			      throw new Error(TEXT);
			    \};
			
			    render(
			      <StaticRouter context=\{\{\}\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const err = useLoaderError(props);
			            return <h1>\{err?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </StaticRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Can access initialData (for hydration)', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			
			    const initialData = \{
			      '/flowers': \{ res: await loaderFunc(), err: undefined \}
			    \};
			
			    render(
			      <StaticRouter context=\{\{\}\} location="/flowers" initialData=\{initialData\}>
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFunc\} />
			      </StaticRouter>,
			      container
			    );
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			\});
			
			describe('Resolve loaders during server side rendering', () => \{
			  it('Can resolve with single route', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			
			    const initialData = \{
			      '/flowers': \{ res: await loaderFunc() \}
			    \};
			
			    const app = (
			      <StaticRouter context=\{\{\}\} location="/flowers">
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFunc\} />
			      </StaticRouter>
			    );
			
			    const loaderEntries = traverseLoaders('/flowers', app);
			    const result = await resolveLoaders(loaderEntries);
			    expect(result).toEqual(initialData);
			  \});
			
			  it('Can resolve with multiple routes', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			
			    const loaderFuncNoHit = async () => \{
			      return \{ message: 'no' \};
			    \};
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			
			    const initialData = \{
			      '/birds': \{ res: await loaderFunc() \}
			    \};
			
			    const app = (
			      <StaticRouter context=\{\{\}\} location="/birds">
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFuncNoHit\} />
			        <Route path="/birds" render=\{Component\} loader=\{loaderFunc\} />
			        <Route path="/bees" render=\{Component\} loader=\{loaderFuncNoHit\} />
			      </StaticRouter>
			    );
			
			    const loaderEntries = traverseLoaders('/birds', app);
			    const result = await resolveLoaders(loaderEntries);
			    expect(result).toEqual(initialData);
			  \});
			
			  it('Can resolve with nested routes', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			
			    const loaderFuncNoHit = async () => \{
			      return \{ message: 'no' \};
			    \};
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			
			    const initialData = \{
			      '/flowers': \{ res: await loaderFunc() \},
			      '/flowers/birds': \{ res: await loaderFunc() \}
			    \};
			
			    const app = (
			      <StaticRouter context=\{\{\}\} location="/flowers/birds">
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFunc\}>
			          <Route path="/flowers/birds" render=\{Component\} loader=\{loaderFunc\} />
			          <Route path="/flowers/bees" render=\{Component\} loader=\{loaderFuncNoHit\} />
			          \{null\}
			        </Route>
			      </StaticRouter>
			    );
			
			    const loaderEntries = traverseLoaders('/flowers/birds', app);
			    const result = await resolveLoaders(loaderEntries);
			    expect(result).toEqual(initialData);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\loaderOnRoute.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(18)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\loaderWithSwitch.spec.tsx', () => {
        const sourceCode = `
			import \{ render, rerender \} from 'inferno';
			import \{ MemoryRouter, Route, Switch, NavLink, useLoaderData, useLoaderError \} from 'inferno-router';
			// Cherry picked relative import so we don't get node-stuff from inferno-server in browser test
			import \{ createEventGuard \} from './testUtils';
			
			describe('A <Route> with loader in a MemoryRouter', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('renders on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEXT \};
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const data = useLoaderData(props);
			            return <h1>\{data?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('renders error on initial', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEXT = 'An error';
			    const loaderFunc = async () => \{
			      setDone();
			      throw new Error(TEXT);
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route
			          path="/"
			          render=\{(props: any) => \{
			            const err = useLoaderError(props);
			            return <h1>\{err?.message\}</h1>;
			          \}\}
			          loader=\{loaderFunc\}
			        />
			      </MemoryRouter>,
			      container
			    );
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Can access initialData (for hydration)', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			    const initialData = \{
			      '/flowers': \{ res: await loaderFunc(), err: undefined \}
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/flowers']\} initialData=\{initialData\}>
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFunc\} />
			      </MemoryRouter>,
			      container
			    );
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Should render component after click', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEST = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEST \};
			    \};
			
			    function RootComp() \{
			      return <div id="root">ROOT</div>;
			    \}
			
			    function CreateComp(props) \{
			      const res = useLoaderData(props);
			      return <div id="create">\{res.message\}</div>;
			    \}
			
			    function PublishComp() \{
			      return <div id="publish">PUBLISH</div>;
			    \}
			
			    const tree = (
			      <MemoryRouter>
			        <div>
			          <nav>
			            <ul>
			              <li>
			                <NavLink exact to="/">
			                  Play
			                </NavLink>
			              </li>
			              <li id="createNav">
			                <NavLink to="/create">Create</NavLink>
			              </li>
			              <li>
			                <NavLink to="/publish">Publish</NavLink>
			              </li>
			            </ul>
			          </nav>
			          <Switch>
			            <Route exact path="/" component=\{RootComp\} />
			            <Route path="/create" component=\{CreateComp\} loader=\{loaderFunc\} />
			            <Route path="/publish" component=\{PublishComp\} />
			          </Switch>
			        </div>
			      </MemoryRouter>
			    );
			
			    render(tree, container);
			
			    expect(container.innerHTML).toContain('ROOT');
			
			    // Click create
			    const link = container.querySelector('#createNav');
			    link.firstChild.click();
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.querySelector('#create').innerHTML).toContain(TEST);
			  \});
			
			  it('Can access initialData (for hydration)', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			    const initialData = \{
			      '/flowers': \{ res: await loaderFunc(), err: undefined \}
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/flowers']\} initialData=\{initialData\}>
			        <Route path="/flowers" render=\{Component\} loader=\{loaderFunc\} />
			      </MemoryRouter>,
			      container
			    );
			
			    expect(container.innerHTML).toContain(TEXT);
			  \});
			
			  it('Should only render one (1) component after click', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEST = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEST \};
			    \};
			
			    function RootComp() \{
			      return <div id="root">ROOT</div>;
			    \}
			
			    function CreateComp(props) \{
			      const res = useLoaderData(props);
			      return <div id="create">\{res.message\}</div>;
			    \}
			
			    function PublishComp() \{
			      return <div id="publish">PUBLISH</div>;
			    \}
			
			    const tree = (
			      <MemoryRouter>
			        <div>
			          <nav>
			            <ul>
			              <li>
			                <NavLink exact to="/">
			                  Play
			                </NavLink>
			              </li>
			              <li id="createNav">
			                <NavLink to="/create">Create</NavLink>
			              </li>
			              <li>
			                <NavLink to="/publish">Publish</NavLink>
			              </li>
			            </ul>
			          </nav>
			          <Switch>
			            <Route exact path="/" component=\{RootComp\} />
			            <Route path="/create" component=\{CreateComp\} loader=\{loaderFunc\} />
			            <Route path="/create" component=\{PublishComp\} />
			          </Switch>
			        </div>
			      </MemoryRouter>
			    );
			
			    render(tree, container);
			
			    expect(container.innerHTML).toContain('ROOT');
			
			    // Click create
			    const link = container.querySelector('#createNav');
			    link.firstChild.click();
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.querySelector('#create').innerHTML).toContain(TEST);
			    expect(container.querySelector('#publish')).toBeNull();
			  \});
			
			  it('can use a \`location\` prop instead of \`router.location\`', async () => \{
			    const [setSwitch, waitForSwitch] = createEventGuard();
			    const [setDone, waitForRerender] = createEventGuard();
			
			    const TEST = 'ok';
			    const loaderFunc = async () => \{
			      await waitForSwitch();
			      setDone();
			      return \{ message: TEST \};
			    \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <NavLink id="link" to="/two">
			          Link
			        </NavLink>
			        <Switch>
			          <Route path="/one" render=\{() => <h1>one</h1>\} />
			          <Route
			            path="/two"
			            render=\{(props: any) => \{
			              const res = useLoaderData(props);
			              return <h1>\{res.message\}</h1>;
			            \}\}
			            loader=\{loaderFunc\}
			          />
			        </Switch>
			      </MemoryRouter>,
			      container
			    );
			
			    // Check that we are starting in the right place
			    expect(container.innerHTML).toContain('one');
			
			    const link = container.querySelector('#link');
			    link.click();
			
			    // Complete any pending render and make sure we don't
			    // prematurely update view
			    rerender();
			    expect(container.innerHTML).toContain('one');
			    // Now loader can be allowed to complete
			
			    setSwitch();
			    // and now wait for the loader to complete
			    await waitForRerender();
			    // so /two is rendered
			    expect(container.innerHTML).toContain(TEST);
			  \});
			
			  it('Should only render one (1) component after click with subclass of Switch', async () => \{
			    const [setDone, waitForRerender] = createEventGuard();
			
			    class SubSwitch extends Switch \{\}
			
			    const TEST = 'ok';
			    const loaderFunc = async () => \{
			      setDone();
			      return \{ message: TEST \};
			    \};
			
			    function RootComp() \{
			      return <div id="root">ROOT</div>;
			    \}
			
			    function CreateComp(props) \{
			      const res = useLoaderData(props);
			      return <div id="create">\{res.message\}</div>;
			    \}
			
			    function PublishComp() \{
			      return <div id="publish">PUBLISH</div>;
			    \}
			
			    const tree = (
			      <MemoryRouter>
			        <div>
			          <nav>
			            <ul>
			              <li>
			                <NavLink exact to="/">
			                  Play
			                </NavLink>
			              </li>
			              <li id="createNav">
			                <NavLink to="/create">Create</NavLink>
			              </li>
			              <li>
			                <NavLink to="/publish">Publish</NavLink>
			              </li>
			            </ul>
			          </nav>
			          <SubSwitch>
			            <Route exact path="/" component=\{RootComp\} />
			            <Route path="/create" component=\{CreateComp\} loader=\{loaderFunc\} />
			            <Route path="/create" component=\{PublishComp\} />
			          </SubSwitch>
			        </div>
			      </MemoryRouter>
			    );
			
			    render(tree, container);
			
			    expect(container.innerHTML).toContain('ROOT');
			
			    // Click create
			    const link = container.querySelector('#createNav');
			    link.firstChild.click();
			
			    // Wait until async loader has completed
			    await waitForRerender();
			
			    expect(container.querySelector('#create').innerHTML).toContain(TEST);
			    expect(container.querySelector('#publish')).toBeNull();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\loaderWithSwitch.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\matchPath.spec.ts', () => {
        const sourceCode = `
			import \{ matchPath \} from 'inferno-router';
			
			describe('matchPath', () => \{
			  describe('with path="/"', () => \{
			    it('returns correct url at "/"', () => \{
			      const path = '/';
			      const pathname = '/';
			      const match = matchPath(pathname, path);
			      expect(match?.url).toBe('/');
			    \});
			
			    it('returns correct url at "/somewhere/else"', () => \{
			      const path = '/';
			      const pathname = '/somewhere/else';
			      const match = matchPath(pathname, path);
			      expect(match?.url).toBe('/');
			    \});
			  \});
			
			  describe('with path="/somewhere"', () => \{
			    it('returns correct url at "/somewhere"', () => \{
			      const path = '/somewhere';
			      const pathname = '/somewhere';
			      const match = matchPath(pathname, path);
			      expect(match?.url).toBe('/somewhere');
			    \});
			
			    it('returns correct url at "/somewhere/else"', () => \{
			      const path = '/somewhere';
			      const pathname = '/somewhere/else';
			      const match = matchPath(pathname, path);
			      expect(match?.url).toBe('/somewhere');
			    \});
			  \});
			
			  describe('with sensitive path', () => \{
			    it('returns non-sensitive url', () => \{
			      const options = \{
			        path: '/SomeWhere'
			      \};
			      const pathname = '/somewhere';
			      const match = matchPath(pathname, options);
			      expect(match?.url).toBe('/somewhere');
			    \});
			
			    it('returns sensitive url', () => \{
			      const options = \{
			        path: '/SomeWhere',
			        sensitive: true
			      \};
			      const pathname = '/somewhere';
			      const match = matchPath(pathname, options);
			      expect(match).toBe(null);
			    \});
			  \});
			
			  describe('with no path', () => \{
			    it('matches the root URL', () => \{
			      const match = matchPath('/test-location/7', \{\});
			      expect(match?.path).toBe('/');
			      expect(match?.url).toBe('/');
			      expect(match?.isExact).toBe(false);
			      expect(match?.params).toEqual(\{\});
			    \});
			  \});
			
			  describe('cache', () => \{
			    it('creates a cache entry for each exact/strict pair', () => \{
			      // true/false and false/true will collide when adding booleans
			      const trueFalse = matchPath('/one/two', \{
			        exact: true,
			        path: '/one/two/',
			        strict: false
			      \});
			      const falseTrue = matchPath('/one/two', \{
			        exact: false,
			        path: '/one/two/',
			        strict: true
			      \});
			      expect(!!trueFalse).toBe(true);
			      expect(!!falseTrue).toBe(false);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\matchPath.spec.ts')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\MemoryRouter.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ Link, MemoryRouter, Route, Switch \} from 'inferno-router';
			
			describe('A <MemoryRouter>', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('puts history on context.router', () => \{
			    let history;
			    const ContextChecker = (_props, context) => \{
			      history = context.router.history;
			      return null;
			    \};
			
			    ContextChecker.contextTypes = \{
			      router: () => \{\}
			    \};
			
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter>
			        <ContextChecker />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(typeof history).toBe('object');
			  \});
			
			  it('warns when passed a history prop', () => \{
			    const history = \{\};
			    const node = document.createElement('div');
			
			    const consoleSpy = spyOn(console, 'error');
			
			    // @ts-ignore
			    render(<MemoryRouter history=\{history\} />, node);
			
			    expect(consoleSpy).toHaveBeenCalledTimes(1);
			    expect(consoleSpy.calls.argsFor(0)[0]).toContain('<MemoryRouter> ignores the history prop');
			  \});
			
			  it('Should be possible to render multiple sub routes, Github #1360', () => \{
			    function Home() \{
			      return <h1>You are in home!</h1>;
			    \}
			
			    function Test() \{
			      return <h1>You are in test route!</h1>;
			    \}
			
			    function TestOne() \{
			      return <h1>You are in test-1 route!</h1>;
			    \}
			
			    render(
			      <MemoryRouter>
			        <div>Header</div>
			        <Route path="/:lang">
			          <Switch>
			            <Route exact path="/" component=\{Home\} />
			            <Route path="/test" component=\{Test\} />
			            <Route path="/test-1" component=\{TestOne\} />
			          </Switch>
			        </Route>
			        <ul>
			          <li>
			            <Link to="/test">Home</Link>
			          </li>
			        </ul>
			        <div>Footer</div>
			      </MemoryRouter>,
			      container
			    );
			
			    expect(container.innerHTML).toBe('<div>Header</div><h1>You are in home!</h1><ul><li><a href="/test">Home</a></li></ul><div>Footer</div>');
			
			    container.querySelector('a').click();
			
			    expect(container.innerHTML).toBe('<div>Header</div><h1>You are in test route!</h1><ul><li><a href="/test">Home</a></li></ul><div>Footer</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\MemoryRouter.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\mobx-router.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ inject, observer, Provider \} from 'inferno-mobx';
			import \{ Route, Router \} from 'inferno-router';
			import \{ createMemoryHistory \} from 'history';
			import \{ action, observable \} from 'mobx';
			
			describe('Github #1236', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('Should not patch twice', () => \{
			    /*
			       This is pre-compiled from old decorator pattern
			     */
			    const _createClass = (function () \{
			      function defineProperties(target, props) \{
			        for (let i = 0; i < props.length; i++) \{
			          const descriptor = props[i];
			          descriptor.enumerable = descriptor.enumerable || false;
			          descriptor.configurable = true;
			          if ('value' in descriptor) descriptor.writable = true;
			          Object.defineProperty(target, descriptor.key, descriptor);
			        \}
			      \}
			      return function (Constructor, protoProps, staticProps = undefined) \{
			        if (protoProps) defineProperties(Constructor.prototype, protoProps);
			        if (staticProps) defineProperties(Constructor, staticProps);
			        return Constructor;
			      \};
			    \})();
			
			    function _initDefineProp(target, property, descriptor, context) \{
			      if (!descriptor) return;
			      Object.defineProperty(target, property, \{
			        configurable: descriptor.configurable,
			        enumerable: descriptor.enumerable,
			        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
			        writable: descriptor.writable
			      \});
			    \}
			
			    function _classCallCheck(instance, Constructor) \{
			      if (!(instance instanceof Constructor)) \{
			        throw new TypeError('Cannot call a class as a function');
			      \}
			    \}
			
			    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context?) \{
			      let desc: any = \{\};
			      Object['ke' + 'ys'](descriptor).forEach(function (key) \{
			        desc[key] = descriptor[key];
			      \});
			      desc.enumerable = !!desc.enumerable;
			      desc.configurable = !!desc.configurable;
			
			      if ('value' in desc || desc.initializer) \{
			        desc.writable = true;
			      \}
			
			      desc = decorators
			        .slice()
			        .reverse()
			        .reduce(function (descIn, decorator) \{
			          return decorator(target, property, descIn) || descIn;
			        \}, desc);
			
			      if (context && desc.initializer !== void 0) \{
			        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
			        desc.initializer = undefined;
			      \}
			
			      if (desc.initializer === void 0) \{
			        Object['define' + 'Property'](target, property, desc);
			        desc = null;
			      \}
			
			      return desc;
			    \}
			    let _class;
			    let _descriptor;
			    const SearchStore =
			      ((_class = (function () \{
			        function TestSearchStore() \{
			          _classCallCheck(this, TestSearchStore);
			
			          _initDefineProp(this, 'query', _descriptor, this);
			        \}
			
			        _createClass(TestSearchStore, [
			          \{
			            key: 'doSearch',
			            value: function doSearch(search) \{
			              this.query = search;
			            \}
			          \}
			        ]);
			
			        return TestSearchStore;
			      \})()),
			      ((_descriptor = _applyDecoratedDescriptor(_class.prototype, 'query', [observable], \{
			        enumerable: true,
			        initializer: function initializer() \{
			          return undefined;
			        \}
			      \})),
			      _applyDecoratedDescriptor(_class.prototype, 'doSearch', [action], Object.getOwnPropertyDescriptor(_class.prototype, 'doSearch'), _class.prototype)),
			      _class);
			
			    let SearchPage = observer(
			      class TestSearchPage extends Component \{
			        constructor(props) \{
			          super(props);
			          this.doSearch = this.doSearch.bind(this);
			        \}
			
			        public componentWillReceiveProps(nextProps) \{
			          nextProps.searchStore.doSearch(nextProps.location.search);
			        \}
			
			        public doSearch(e) \{
			          e.preventDefault();
			          const nextLoc = this.context.router.history.location.pathname + '?q=test';
			          this.context.router.history.push(nextLoc);
			        \}
			
			        public render(\{ searchStore: searchStoreIn \}: any) \{
			          const showView = searchStoreIn.query ? 'results' : 'default';
			
			          return (
			            <div key="search-container">
			              <a key="asd" id="test-btn" href="#front" onClick=\{this.doSearch\}>
			                link
			              </a>
			              \{showView === 'default' && <div key="search-default">default</div>\}
			              \{showView === 'results' && <SearchResult key="search-results" />\}
			            </div>
			          );
			        \}
			      \}
			    );
			
			    SearchPage = inject('searchStore')(SearchPage);
			
			    class SearchResult extends Component \{
			      public render() \{
			        return <div>results</div>;
			      \}
			    \}
			
			    /**
			     * Routing
			     */
			    const searchStore = new SearchStore();
			    const memHistory = createMemoryHistory();
			
			    const appRoutes = (
			      <Provider searchStore=\{searchStore\}>
			        <Router history=\{memHistory\}>
			          <Route component=\{SearchPage\} />
			        </Router>
			      </Provider>
			    );
			
			    render(appRoutes, container);
			
			    expect(container.innerHTML).toEqual('<div><a id="test-btn" href="#front">link</a><div>default</div></div>');
			
			    const btn = container.querySelector('#test-btn');
			
			    btn.click();
			
			    expect(container.innerHTML).toEqual('<div><a id="test-btn" href="#front">link</a><div>results</div></div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\mobx-router.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\NavLink.spec.tsx', () => {
        const sourceCode = `
			import \{ createMemoryHistory \} from 'history';
			import \{ Component, render \} from 'inferno';
			import \{ HashRouter, MemoryRouter, NavLink \} from 'inferno-router';
			
			describe('NavLink', () => \{
			  let node;
			
			  beforeEach(function () \{
			    node = document.createElement('div');
			    document.body.appendChild(node);
			  \});
			
			  afterEach(function () \{
			    render(null, node);
			    document.body.removeChild(node);
			  \});
			
			  describe('When a <NavLink> is active', () => \{
			    it('applies its default activeClassName', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pizza">Pizza!</NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).toEqual('active');
			    \});
			
			    it('applies its passed activeClassName', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pizza" activeClassName="selected">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).toEqual('selected');
			    \});
			
			    it('applies its activeStyle', () => \{
			      const defaultStyle = \{ color: 'black' \};
			      const activeStyle = \{ color: 'red' \};
			
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pizza" style=\{defaultStyle\} activeStyle=\{activeStyle\}>
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.style.color).toBe(activeStyle.color);
			    \});
			  \});
			
			  describe('When a <NavLink> is not active', () => \{
			    it('does not apply its default activeClassName', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/salad" activeClassName="selected">
			            Salad?
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			    \});
			
			    it('does not apply its passed activeClassName', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/salad" activeClassName="selected">
			            Salad?
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).not.toContain('selected');
			    \});
			
			    it('does not apply its activeStyle', () => \{
			      const defaultStyle = \{ color: 'black' \};
			      const activeStyle = \{ color: 'red' \};
			
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/salad" style=\{defaultStyle\} activeStyle=\{activeStyle\}>
			            Salad?
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.style.color).toBe(defaultStyle.color);
			    \});
			  \});
			
			  describe('isActive', () => \{
			    it('applies active default props when isActive returns true', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pizza" isActive=\{() => true\}>
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).toEqual('active');
			    \});
			
			    it('applies active passed props when isActive returns true', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pizza" activeClassName="selected" isActive=\{() => true\}>
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).toEqual('selected');
			    \});
			
			    it('does not apply active default props when isActive returns false', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pizza" isActive=\{() => false\}>
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			    \});
			
			    it('does not apply active passed props when isActive returns false', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pizza" activeClassName="selected" isActive=\{() => false\}>
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).not.toContain('selected');
			    \});
			  \});
			
			  it('applies its className when provided as a function', () => \{
			    render(
			      <MemoryRouter initialEntries=\{['/pizza']\}>
			        <NavLink to="/pizza" className=\{(isActive: boolean) => (isActive ? 'active-pizza' : 'chill-pizza')\}>
			          Pizza!
			        </NavLink>
			      </MemoryRouter>,
			      node
			    );
			
			    const a = node.querySelector('a');
			    expect(a.className).toContain('active-pizza');
			  \});
			
			  it('applies its style when provided as a function', () => \{
			    const defaultStyle = \{ color: 'black' \};
			    const activeStyle = \{ color: 'red' \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/pizza']\}>
			        <NavLink to="/pizza" style=\{(isActive) => (isActive ? activeStyle : defaultStyle)\}>
			          Pizza!
			        </NavLink>
			      </MemoryRouter>,
			      node
			    );
			
			    const a = node.querySelector('a');
			    expect(a.style.color).toBe(activeStyle.color);
			  \});
			
			  it('applies its className when provided as a function #2', () => \{
			    render(
			      <MemoryRouter initialEntries=\{['/pizza']\}>
			        <NavLink to="/salad" className=\{(isActive) => (isActive ? 'active-salad' : 'chill-salad')\}>
			          Salad?
			        </NavLink>
			      </MemoryRouter>,
			      node
			    );
			
			    const a = node.querySelector('a');
			    expect(a.className).toContain('chill-salad');
			  \});
			
			  it('applies its style when provided as a function', () => \{
			    const defaultStyle = \{ color: 'black' \};
			    const activeStyle = \{ color: 'red' \};
			
			    render(
			      <MemoryRouter initialEntries=\{['/pizza']\}>
			        <NavLink to="/salad" style=\{(isActive) => (isActive ? activeStyle : defaultStyle)\}>
			          Salad?
			        </NavLink>
			      </MemoryRouter>,
			      node
			    );
			
			    const a = node.querySelector('a');
			    expect(a.style.color).toBe(defaultStyle.color);
			  \});
			
			  describe('exact', () => \{
			    it('does not do exact matching by default', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza/anchovies']\}>
			          <NavLink to="/pizza" activeClassName="active">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).toEqual('active');
			    \});
			
			    it('sets active default value only for exact matches', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink exact to="/pizza">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).toEqual('active');
			      expect(a.getAttribute('exact')).toBeNull();
			    \});
			
			    it('sets active passed value only for exact matches', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink exact to="/pizza" activeClassName="selected">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).toEqual('selected');
			    \});
			
			    it('does not set active default value for partial matches', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza/anchovies']\}>
			          <NavLink exact to="/pizza">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			    \});
			
			    it('does not set active passed value for partial matches', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza/anchovies']\}>
			          <NavLink exact to="/pizza" activeClassName="selected">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).not.toContain('selected');
			    \});
			  \});
			
			  describe("strict (enforce path's trailing slash)", () => \{
			    const PATH = '/pizza/';
			    it('does not do strict matching by default', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to=\{PATH\}>Pizza!</NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).toEqual('active');
			    \});
			
			    it('does not set active default value when location.pathname has no trailing slash', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink strict to=\{PATH\}>
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			    \});
			
			    it('does not set active passed value when location.pathname has no trailing slash', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink strict to=\{PATH\} activeClassName="selected">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).not.toContain('selected');
			    \});
			
			    it('sets active default value when pathname has trailing slash', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza/']\}>
			          <NavLink strict to=\{PATH\}>
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).toEqual('active');
			    \});
			
			    it('sets active passed value when pathname has trailing slash', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza/']\}>
			          <NavLink strict to=\{PATH\} activeClassName="selected">
			            Pizza!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			
			      expect(a.className).not.toContain('active');
			      expect(a.className).toEqual('selected');
			    \});
			  \});
			
			  describe('location property', () => \{
			    it('overrides the current location', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pizza']\}>
			          <NavLink to="/pasta" activeClassName="selected" location=\{\{ pathname: '/pasta' \}\}>
			            Pasta!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).toContain('selected');
			    \});
			
			    it('is not overwritten by the current location', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pasta']\}>
			          <NavLink to="/pasta" activeClassName="selected" location=\{\{ pathname: '/pizza' \}\}>
			            Pasta!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.className).not.toContain('active');
			      expect(a.className).not.toContain('selected');
			      expect(node.textContent).toEqual('Pasta!');
			    \});
			  \});
			
			  describe('html link attributes', () => \{
			    it('accept html link attributes', () => \{
			      render(
			        <MemoryRouter initialEntries=\{['/pasta']\}>
			          <NavLink to="/pasta" title="pasta">
			            Pasta!
			          </NavLink>
			        </MemoryRouter>,
			        node
			      );
			      const a = node.getElementsByTagName('a')[0];
			      expect(a.title).toEqual('pasta');
			    \});
			  \});
			
			  describe('A <NavLink> underneath a <HashRouter>', () => \{
			    let tmpNode;
			    beforeEach(function () \{
			      tmpNode = document.createElement('div');
			      document.body.appendChild(tmpNode);
			    \});
			
			    afterEach(function () \{
			      render(null, tmpNode);
			      document.body.removeChild(tmpNode);
			    \});
			
			    const createLinkNode = (to) => \{
			      render(
			        <HashRouter>
			          <NavLink to=\{to\} />
			        </HashRouter>,
			        tmpNode
			      );
			
			      return tmpNode.querySelector('a');
			    \};
			
			    it('has the correct href', () => \{
			      const linkNode = createLinkNode('/foo');
			      expect(linkNode.getAttribute('href')).toEqual('#/foo');
			    \});
			
			    it('has the correct href #2', () => \{
			      const linkNode = createLinkNode('foo');
			      expect(linkNode.getAttribute('href')).toEqual('#foo');
			    \});
			
			    it('accepts a string \`to\` prop', () => \{
			      const to = '/the/path?the=query#the-hash';
			
			      render(
			        <MemoryRouter>
			          <NavLink to=\{to\}>link</NavLink>
			        </MemoryRouter>,
			        tmpNode
			      );
			
			      const a = tmpNode.querySelector('a');
			
			      expect(a.getAttribute('href')).toEqual('/the/path?the=query#the-hash');
			    \});
			
			    it('accepts an object \`to\` prop', () => \{
			      const to = \{
			        hash: '#the-hash',
			        key: '1',
			        pathname: '/the/path',
			        search: 'the=query',
			        state: null
			      \};
			
			      render(
			        <MemoryRouter>
			          <NavLink to=\{to\}>link</NavLink>
			        </MemoryRouter>,
			        tmpNode
			      );
			
			      const a = tmpNode.querySelector('a');
			
			      expect(a.getAttribute('href')).toEqual('/the/path?the=query#the-hash');
			    \});
			
			    it('accepts an object \`to\` prop with state', async () => \{
			      const memoryHistoryFoo = createMemoryHistory(\{
			        initialEntries: ['/foo']
			      \});
			      memoryHistoryFoo.push = jasmine.createSpy();
			
			      const clickHandler = jasmine.createSpy();
			
			      const to = \{
			        hash: '#the-hash',
			        key: '1',
			        pathname: '/the/path',
			        search: 'the=query',
			        state: \{ test: 'ok' \}
			      \};
			
			      class ContextChecker extends Component \{
			        public getChildContext() \{
			          const \{ context \} = this;
			          context.router.history = memoryHistoryFoo;
			
			          return \{
			            router: context.router
			          \};
			        \}
			
			        public render(\{ children \}) \{
			          return children;
			        \}
			      \}
			
			      render(
			        <MemoryRouter>
			          <ContextChecker>
			            <NavLink to=\{to\} onClick=\{clickHandler\}>
			              link
			            </NavLink>
			          </ContextChecker>
			        </MemoryRouter>,
			        tmpNode
			      );
			
			      const a = tmpNode.querySelector('a');
			      a.click();
			
			      expect(clickHandler).toHaveBeenCalledTimes(1);
			      expect(memoryHistoryFoo.push).toHaveBeenCalledTimes(1);
			      const \{ hash, pathname, search, state \} = to;
			      expect(memoryHistoryFoo.push).toHaveBeenCalledWith(\{ hash, pathname, search \}, state);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\NavLink.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(32)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\Prompt.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ Prompt, StaticRouter \} from 'inferno-router';
			
			describe('A <Prompt>', () => \{
			  it('ask if sure to transition', () => \{
			    const context = \{\};
			    const node = document.createElement('div');
			
			    expect(() => \{
			      render(
			        <StaticRouter context=\{context\}>
			          <Prompt when=\{true\} message="this is only a test" />
			        </StaticRouter>,
			        node
			      );
			    \}).not.toThrow();
			
			    expect(() => \{
			      render(
			        <StaticRouter context=\{context\}>
			          <Prompt when=\{false\} message="this is only a test" />
			        </StaticRouter>,
			        node
			      );
			    \}).not.toThrow();
			
			    expect(() => \{
			      render(
			        <StaticRouter context=\{context\}>
			          <Prompt when=\{true\} message="this is only a test" />
			        </StaticRouter>,
			        node
			      );
			    \}).not.toThrow();
			  \});
			
			  it('blocks transition', () => \{
			    const context = \{\};
			    const node = document.createElement('div');
			    let promptWhen;
			
			    class App extends Component \{
			      private ref: any;
			      public state: any;
			
			      constructor() \{
			        super();
			        this.state = \{ when: true \};
			        promptWhen = this._setActive = this._setActive.bind(this);
			      \}
			
			      private _setActive() \{
			        this.setState(\{
			          when: false
			        \});
			      \}
			
			      public componentWillUpdate(_nextProps, nextState) \{
			        expect(this.ref.unblock).toBeTruthy();
			        expect(this.state.when).toBe(true);
			        expect(nextState.when).toBe(false);
			      \}
			
			      public componentDidUpdate() \{
			        expect(this.ref.unblock).toBeFalsy();
			      \}
			
			      public render() \{
			        return <Prompt when=\{this.state.when\} message="this is only a test" ref=\{(c) => (this.ref = c)\} />;
			      \}
			    \}
			
			    render(
			      <StaticRouter context=\{context\}>
			        <App />
			      </StaticRouter>,
			      node
			    );
			
			    promptWhen();
			
			    render(null, node);
			  \});
			
			  it('throws when used outside Router', () => \{
			    const node = document.createElement('div');
			
			    expect(() => \{
			      // @ts-ignore
			      render(<Prompt />, node);
			    \}).toThrow();
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\Prompt.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\Route.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ MemoryRouter, Route, Router \} from 'inferno-router';
			import \{ createMemoryHistory \} from 'history';
			
			describe('A <Route>', () => \{
			  it('renders at the root', () => \{
			    const TEXT = 'Mrs. Kato';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route path="/" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain(TEXT);
			  \});
			
			  it('does not render when it does not match', () => \{
			    const TEXT = 'bubblegum';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/bunnies']\}>
			        <Route path="/flowers" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).not.toContain(TEXT);
			  \});
			
			  it('can use a \`location\` prop instead of \`context.router.route.location\`', () => \{
			    const TEXT = 'tamarind chutney';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/mint']\}>
			        <Route location=\{\{ pathname: '/tamarind' \}\} path="/tamarind" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain(TEXT);
			  \});
			
			  it('supports preact by nulling out children prop when empty array is passed', () => \{
			    const TEXT = 'Mrs. Kato';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route path="/" render=\{() => <h1>\{TEXT\}</h1>\}>
			          \{[]\}
			        </Route>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain(TEXT);
			  \});
			
			  it('matches using nextContext when updating', () => \{
			    const node = document.createElement('div');
			
			    let push;
			    render(
			      <MemoryRouter initialEntries=\{['/sushi/california']\}>
			        <Route
			          path="/sushi/:roll"
			          render=\{(\{ history, match \}) => \{
			            push = history.push;
			            return <div>\{match.url\}</div>;
			          \}\}
			        />
			      </MemoryRouter>,
			      node
			    );
			    push('/sushi/spicy-tuna');
			    expect(node.innerHTML).toContain('/sushi/spicy-tuna');
			  \});
			
			  it('throws with no <Router>', () => \{
			    const node = document.createElement('div');
			
			    expect(() => \{
			      render(<Route path="/" render=\{() => null\} />, node);
			    \}).toThrowError(/You should not use <Route> or withRouter\\(\\) outside a <Router>/);
			  \});
			\});
			
			describe('A <Route> with dynamic segments in the path', () => \{
			  // https://github.com/remix-run/history/commit/78f016f6e5b49e2a23ec41799faf160dd68d6b6b
			  it('does not decode them', () => \{
			    const node = document.createElement('div');
			    render(
			      <MemoryRouter initialEntries=\{['/a%20dynamic%20segment']\}>
			        <Route path="/:id" render=\{(\{ match \}) => <div>\{match.params.id\}</div>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain('a%20dynamic%20segment');
			  \});
			\});
			
			describe('A unicode <Route>', () => \{
			  it('is able to match', () => \{
			    const node = document.createElement('div');
			    render(
			      <MemoryRouter initialEntries=\{['/パス名']\}>
			        <Route path="/パス名" render=\{(\{ match \}) => <div>\{match.url\}</div>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain('/パス名');
			  \});
			\});
			
			describe('<Route render>', () => \{
			  const history = createMemoryHistory();
			  const node = document.createElement('div');
			
			  it('renders its return value', () => \{
			    const TEXT = 'Mrs. Kato';
			    const testNode = document.createElement('div');
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route path="/" render=\{() => <div>\{TEXT\}</div>\} />
			      </MemoryRouter>,
			      testNode
			    );
			
			    expect(testNode.innerHTML).toContain(TEXT);
			  \});
			
			  it('receives \{ match, location, history \} props', () => \{
			    let actual: any = null;
			
			    render(
			      <Router history=\{history\}>
			        <Route path="/" render=\{(props) => (actual = props) && null\} />
			      </Router>,
			      node
			    );
			
			    expect(actual?.history).toBe(history);
			    expect(typeof actual?.match).toBe('object');
			    expect(typeof actual?.location).toBe('object');
			  \});
			\});
			
			describe('<Route component>', () => \{
			  const history = createMemoryHistory();
			  const node = document.createElement('div');
			
			  it('renders the component', () => \{
			    const TEXT = 'Mrs. Kato';
			    const testNode = document.createElement('div');
			    const Home = () => <div>\{TEXT\}</div>;
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route path="/" component=\{Home\} />
			      </MemoryRouter>,
			      testNode
			    );
			
			    expect(testNode.innerHTML).toContain(TEXT);
			  \});
			
			  it('receives \{ match, location, history \} props', () => \{
			    let actual: any = null;
			    const Component = (props) => (actual = props) && null;
			
			    render(
			      <Router history=\{history\}>
			        <Route path="/" component=\{Component\} />
			      </Router>,
			      node
			    );
			
			    expect(actual?.history).toBe(history);
			    expect(typeof actual?.match).toBe('object');
			    expect(typeof actual?.location).toBe('object');
			  \});
			\});
			
			describe('<Route children>', () => \{
			  const history = createMemoryHistory();
			  const node = document.createElement('div');
			
			  it('renders a function', () => \{
			    const TEXT = 'Mrs. Kato';
			    const testNode = document.createElement('div');
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route path="/" children=\{() => <div>\{TEXT\}</div>\} />
			      </MemoryRouter>,
			      testNode
			    );
			
			    expect(testNode.innerHTML).toContain(TEXT);
			  \});
			
			  it('renders a child element', () => \{
			    const TEXT = 'Mrs. Kato';
			    const testNode = document.createElement('div');
			    render(
			      <MemoryRouter initialEntries=\{['/']\}>
			        <Route path="/">
			          <div>\{TEXT\}</div>
			        </Route>
			      </MemoryRouter>,
			      testNode
			    );
			
			    expect(testNode.innerHTML).toContain(TEXT);
			  \});
			
			  it('receives \{ match, location, history \} props', () => \{
			    let actual: any = null;
			
			    render(
			      <Router history=\{history\}>
			        <Route path="/" children=\{(props) => (actual = props) && null\} />
			      </Router>,
			      node
			    );
			
			    expect(actual?.history).toBe(history);
			    expect(typeof actual?.match).toBe('object');
			    expect(typeof actual?.location).toBe('object');
			  \});
			\});
			
			describe('A <Route exact>', () => \{
			  it('renders when the URL does not have a trailing slash', () => \{
			    const TEXT = 'bubblegum';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/somepath/']\}>
			        <Route exact path="/somepath" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain(TEXT);
			  \});
			
			  it('renders when the URL has trailing slash', () => \{
			    const TEXT = 'bubblegum';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/somepath']\}>
			        <Route exact path="/somepath/" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain(TEXT);
			  \});
			\});
			
			describe('A <Route exact strict>', () => \{
			  it('does not render when the URL has a trailing slash', () => \{
			    const TEXT = 'bubblegum';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/somepath/']\}>
			        <Route exact strict path="/somepath" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).not.toContain(TEXT);
			  \});
			
			  it('does not render when the URL does not have a trailing slash', () => \{
			    const TEXT = 'bubblegum';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/somepath']\}>
			        <Route exact strict path="/somepath/" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).not.toContain(TEXT);
			  \});
			\});
			
			describe('A <Route location>', () => \{
			  it('can use a \`location\` prop instead of \`router.location\`', () => \{
			    const TEXT = 'tamarind chutney';
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/mint']\}>
			        <Route location=\{\{ pathname: '/tamarind' \}\} path="/tamarind" render=\{() => <h1>\{TEXT\}</h1>\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain(TEXT);
			  \});
			
			  describe('children', () => \{
			    it("uses parent's prop location", () => \{
			      const TEXT = 'cheddar pretzel';
			      const node = document.createElement('div');
			
			      render(
			        <MemoryRouter initialEntries=\{['/popcorn']\}>
			          <Route
			            location=\{\{ pathname: '/pretzels/cheddar' \}\}
			            path="/pretzels"
			            render=\{() => <Route path="/pretzels/cheddar" render=\{() => <h1>\{TEXT\}</h1>\} />\}
			          />
			        </MemoryRouter>,
			        node
			      );
			
			      expect(node.innerHTML).toContain(TEXT);
			    \});
			
			    it("continues to use parent's prop location after navigation", () => \{
			      const TEXT = 'cheddar pretzel';
			      const node = document.createElement('div');
			      let push;
			      render(
			        <MemoryRouter initialEntries=\{['/popcorn']\}>
			          <Route
			            location=\{\{ pathname: '/pretzels/cheddar' \}\}
			            path="/pretzels"
			            render=\{(\{ history \}) => \{
			              push = history.push;
			              return <Route path="/pretzels/cheddar" render=\{() => <h1>\{TEXT\}</h1>\} />;
			            \}\}
			          />
			        </MemoryRouter>,
			        node
			      );
			      expect(node.innerHTML).toContain(TEXT);
			      push('/chips');
			      expect(node.innerHTML).toContain(TEXT);
			    \});
			
			    it('Should throw error if element vNode is passed to component property', () => \{
			      const node = document.createElement('div');
			
			      expect(() =>
			        render(
			          <MemoryRouter initialEntries=\{['/popcorn']\}>
			            <Route component=\{<div>test</div>\} />
			          </MemoryRouter>,
			          node
			        )
			      ).toThrow(); // All browsers format error msg differently
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\Route.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(23)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\Route.typings.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ Route, Router \} from 'inferno-router';
			import \{ createMemoryHistory \} from 'history';
			import \{ IRouteProps \} from '../src/Route';
			
			describe('<Route component>', () => \{
			  const history = createMemoryHistory();
			  const node = document.createElement('div');
			
			  it('receives \{ history, location, match \} props', () => \{
			    type RouteProps = \{
			      history: any;
			      location: any;
			      match: any;
			    \};
			    let actual: RouteProps = \{
			      history: null,
			      location: null,
			      match: null
			    \};
			    const ComponentAb = (props: RouteProps) => (actual = props) && null;
			
			    render(
			      <Router history=\{history\}>
			        <Route path="/" component=\{ComponentAb\} />
			      </Router>,
			      node
			    );
			
			    expect(actual.history).toBe(history);
			    expect(typeof actual.match).toBe('object');
			    expect(typeof actual.location).toBe('object');
			  \});
			
			  it('type check props class component', () => \{
			    class ComponentA extends Component<any, any> \{
			      public render() \{
			        return 'foo';
			      \}
			    \}
			
			    render(
			      <Router history=\{history\}>
			        <Route path="/" component=\{ComponentA\} />
			      </Router>,
			      node
			    );
			  \});
			
			  it('type check props render method', () => \{
			    class ComponentA extends Component<any, any> \{
			      public render() \{
			        return 'foo';
			      \}
			    \}
			
			    const props: IRouteProps = \{
			      component: ComponentA
			    \};
			
			    const C = props.component!;
			
			    render(
			      <Router history=\{history\}>
			        <Route path="/" render=\{(_) => <C \{...props\} />\} />
			      </Router>,
			      node
			    );
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\Route.typings.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\Router.spec.tsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ Router \} from 'inferno-router';
			import \{ createMemoryHistory \} from 'history';
			
			describe('A <Router>', () => \{
			  describe('with exactly one child', () => \{
			    it('does not throw an error', () => \{
			      const node = document.createElement('div');
			      expect(() => \{
			        render(
			          <Router history=\{createMemoryHistory()\}>
			            <p>Bar</p>
			          </Router>,
			          node
			        );
			      \}).not.toThrow();
			    \});
			  \});
			
			  describe('with no children', () => \{
			    it('does not throw an error', () => \{
			      const node = document.createElement('div');
			      expect(() => \{
			        // @ts-ignore
			        render(<Router history=\{createMemoryHistory()\} />, node);
			      \}).not.toThrow();
			    \});
			  \});
			
			  describe('context', () => \{
			    let rootContext;
			    const ContextChecker = (_props, context) => \{
			      rootContext = context;
			      return null;
			    \};
			
			    afterEach(() => \{
			      rootContext = undefined;
			    \});
			
			    it('puts history on context.history', () => \{
			      const node = document.createElement('div');
			      const history = createMemoryHistory();
			      render(
			        <Router history=\{history\}>
			          <ContextChecker />
			        </Router>,
			        node
			      );
			
			      expect(rootContext.router.history).toBe(history);
			    \});
			
			    it('sets context.router.route at the root', () => \{
			      const node = document.createElement('div');
			      const history = createMemoryHistory(\{
			        initialEntries: ['/']
			      \});
			
			      render(
			        <Router history=\{history\}>
			          <ContextChecker />
			        </Router>,
			        node
			      );
			
			      expect(rootContext.router.route.match.path).toEqual('/');
			      expect(rootContext.router.route.match.url).toEqual('/');
			      expect(rootContext.router.route.match.params).toEqual(\{\});
			      expect(rootContext.router.route.match.isExact).toEqual(true);
			      expect(rootContext.router.route.location).toEqual(history.location);
			    \});
			
			    it('updates context.router.route upon navigation', () => \{
			      const node = document.createElement('div');
			      const history = createMemoryHistory(\{
			        initialEntries: ['/']
			      \});
			
			      render(
			        <Router history=\{history\}>
			          <ContextChecker />
			        </Router>,
			        node
			      );
			
			      expect(rootContext.router.route.match.isExact).toBe(true);
			
			      const newLocation = \{ pathname: '/new' \};
			      history.push(newLocation);
			
			      expect(rootContext.router.route.match.isExact).toBe(false);
			    \});
			
			    it('does not contain context.router.staticContext by default', () => \{
			      const node = document.createElement('div');
			      const history = createMemoryHistory(\{
			        initialEntries: ['/']
			      \});
			
			      render(
			        <Router history=\{history\}>
			          <ContextChecker />
			        </Router>,
			        node
			      );
			
			      expect(rootContext.router.staticContext).toBe(undefined);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\Router.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\Switch.spec.tsx', () => {
        const sourceCode = `
			/* tslint:disable:no-console */
			import \{ render, rerender, Component \} from 'inferno';
			import \{ MemoryRouter, Redirect, Route, Switch \} from 'inferno-router';
			import \{ IRouteProps \} from '../src/Route';
			
			describe('Switch (jsx)', () => \{
			  it('renders the first <Route> that matches the URL', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Route path="/one" render=\{() => <h1>one</h1>\} />
			          <Route path="/two" render=\{() => <h1>two</h1>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toMatch(/one/);
			  \});
			
			  it('renders the first <Redirect from> that matches the URL', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/three']\}>
			        <Switch>
			          <Route path="/one" render=\{() => <h1>one</h1>\} />
			          <Redirect from="/four" to="/one" />
			          <Redirect from="/three" to="/two" />
			          <Route path="/two" render=\{() => <h1>two</h1>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    rerender();
			
			    expect(node.innerHTML).toMatch(/two/);
			  \});
			
			  it('does not render a second <Route> or <Redirect> that also matches the URL', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Route path="/one" render=\{() => <h1>one</h1>\} />
			          <Redirect from="/one" to="/two" />
			          <Route path="/one" render=\{() => <h1>two</h1>\} />
			          <Route path="/two" render=\{() => <h1>two</h1>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).not.toMatch(/two/);
			  \});
			
			  it('renders pathless Routes', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/cupcakes']\}>
			        <Switch>
			          <Route path="/bubblegum" render=\{() => <div>one</div>\} />
			          <Route render=\{() => <div>two</div>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).not.toContain('one');
			    expect(node.innerHTML).toContain('two');
			  \});
			
			  it('handles from-less Redirects', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/cupcakes']\}>
			        <Switch>
			          <Route path="/bubblegum" render=\{() => <div>bub</div>\} />
			          <Redirect to="/bubblegum" />
			          <Route path="/cupcakes" render=\{() => <div>cup</div>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    rerender();
			
			    expect(node.innerHTML).not.toContain('cup');
			    expect(node.innerHTML).toContain('bub');
			  \});
			
			  it('handles subsequent redirects', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Redirect exact from="/one" to="/two" />
			          <Redirect exact from="/two" to="/three" />
			
			          <Route path="/three" render=\{() => <div>three</div>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    rerender();
			
			    expect(node.textContent).toBe('three');
			  \});
			
			  it('warns when redirecting to same route, both strings', () => \{
			    const node = document.createElement('div');
			    const redirected = false;
			    let done = false;
			
			    const consoleErrSpy = spyOn(console, 'error');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Route
			            path="/one"
			            render=\{() => \{
			              if (done) return <h1>done</h1>;
			
			              if (!redirected) \{
			                return <Redirect to="/one" />;
			              \}
			              done = true;
			
			              return <Redirect to="/one" />;
			            \}\}
			          />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    rerender();
			
			    expect(node.innerHTML).not.toContain('done');
			    expect(consoleErrSpy.calls.count()).toBe(1);
			    expect(consoleErrSpy.calls.argsFor(0)[0]).toContain('/one');
			  \});
			
			  it('warns when redirecting to same route, mixed types', () => \{
			    const node = document.createElement('div');
			    let redirected = false;
			    let done = false;
			
			    const consoleErrSpy = spyOn(console, 'error');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Route
			            path="/one"
			            render=\{() => \{
			              if (done) return <h1>done</h1>;
			
			              if (!redirected) \{
			                redirected = true;
			                return <Redirect to="/one" />;
			              \}
			              done = true;
			
			              return <Redirect to=\{\{ pathname: '/one' \}\} />;
			            \}\}
			          />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    rerender();
			
			    expect(node.innerHTML).not.toContain('done');
			    expect(consoleErrSpy.calls.count()).toBe(1);
			    expect(consoleErrSpy.calls.argsFor(0)[0]).toContain('/one');
			  \});
			
			  it('warns when redirecting to same route, mixed types, string with query', () => \{
			    const node = document.createElement('div');
			    let redirected = false;
			    let done = false;
			
			    const consoleErrSpy = spyOn(console, 'error');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Route
			            path="/one"
			            render=\{() => \{
			              if (done) return <h1>done</h1>;
			
			              if (!redirected) \{
			                redirected = true;
			                return <Redirect to="/one?utm=1" />;
			              \}
			              done = true;
			
			              return <Redirect to=\{\{ pathname: '/one', search: '?utm=1' \}\} />;
			            \}\}
			          />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    rerender();
			
			    expect(node.innerHTML).not.toContain('done');
			    expect(consoleErrSpy.calls.count()).toBe(1);
			    expect(consoleErrSpy.calls.argsFor(0)[0]).toContain('/one?utm=1');
			  \});
			
			  it('does NOT warn when redirecting to same route with different \`search\`', () => \{
			    const node = document.createElement('div');
			    let redirected = false;
			    let done = false;
			
			    const consoleErrSpy = spyOn(console, 'error');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Route
			            path="/one"
			            render=\{() => \{
			              if (done) return <h1>done</h1>;
			
			              if (!redirected) \{
			                redirected = true;
			                return <Redirect to=\{\{ pathname: '/one', search: '?utm=1' \}\} />;
			              \}
			              done = true;
			
			              return <Redirect to=\{\{ pathname: '/one', search: '?utm=2' \}\} />;
			            \}\}
			          />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    rerender();
			
			    expect(node.innerHTML).toContain('done');
			    expect(consoleErrSpy.calls.count()).toBe(0);
			  \});
			
			  it('handles comments', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/cupcakes']\}>
			        <Switch>
			          <Route path="/bubblegum" render=\{() => <div>bub</div>\} />
			          \{/* this is a comment */\}
			          <Route path="/cupcakes" render=\{() => <div>cup</div>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).not.toContain('bub');
			    expect(node.innerHTML).toContain('cup');
			  \});
			
			  it('renders with non-element children', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch>
			          <Route path="/one" render=\{() => <h1>one</h1>\} />
			          \{false\}
			          \{undefined\}
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toMatch(/one/);
			  \});
			
			  it('throws with no <Router>', () => \{
			    const node = document.createElement('div');
			    expect(() => \{
			      render(
			        <Switch>
			          <Route path="/one" render=\{() => <h1>one</h1>\} />
			          <Route path="/two" render=\{() => <h1>two</h1>\} />
			        </Switch>,
			        node
			      );
			    \}).toThrowError(/You should not use <Switch> outside a <Router>/);
			  \});
			
			  it('matches and renders array children correctly', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/bubblegum']\}>
			        <Switch>
			          <Route path="/ice-cream" render=\{() => <div>beb</div>\} />
			          \{[<Route path="/bubblegum" render=\{() => <div>bub</div>\} />]\}
			          <Route path="/cupcakes" render=\{() => <div>cup</div>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).not.toContain('beb');
			    expect(node.innerHTML).toContain('bub');
			    expect(node.innerHTML).not.toContain('cup');
			  \});
			
			  it('matches and renders children in nested arrays correctly', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/bubblegum']\}>
			        <Switch>
			          \{[[<Route path="/ice-cream" render=\{() => <div>beb</div>\} />]]\}
			          \{[
			            <Route path="/something" render=\{() => <div>bab</div>\} />,
			            <Route path="/something-else" render=\{() => <div>bib</div>\} />,
			            [<Route path="/bubblegum" render=\{() => <div>bub</div>\} />]
			          ]\}
			          <Route path="/cupcakes" render=\{() => <div>cup</div>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toContain('bub');
			    expect(node.innerHTML).not.toContain('beb');
			    expect(node.innerHTML).not.toContain('bab');
			    expect(node.innerHTML).not.toContain('bib');
			    expect(node.innerHTML).not.toContain('cup');
			  \});
			
			  // TODO: This will not work because component is not mandatory
			  it('Should allow using component child parameter as result, Github #1601', () => \{
			    const node = document.createElement('div');
			
			    class Component1 extends Component<any, any> \{
			      public state = \{ foo: 0 \};
			      constructor(p, s) \{
			        super(p, s);
			
			        this.state.foo = 1;
			      \}
			      public render() \{
			        return <div>Component</div>;
			      \}
			    \}
			
			    const routes: IRouteProps[] = [
			      \{
			        component: Component1,
			        exact: true,
			        path: \`/\`
			      \}
			    ];
			
			    render(
			      <MemoryRouter initialEntries=\{['/bubblegum']\}>
			        <Switch>
			          \{routes.map((\{ path, exact, component: Comp, ...rest \}) => (
			            <Route key=\{path\} path=\{path\} exact=\{exact\} render=\{(props) => <Component1 \{...props\} \{...rest\} />\} />
			          ))\}
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			  \});
			\});
			
			describe('A <Switch location>', () => \{
			  it('can use a \`location\` prop instead of \`router.location\`', () => \{
			    const node = document.createElement('div');
			
			    render(
			      <MemoryRouter initialEntries=\{['/one']\}>
			        <Switch location=\{\{ pathname: '/two' \}\}>
			          <Route path="/one" render=\{() => <h1>one</h1>\} />
			          <Route path="/two" render=\{() => <h1>two</h1>\} />
			        </Switch>
			      </MemoryRouter>,
			      node
			    );
			
			    expect(node.innerHTML).toMatch(/two/);
			  \});
			
			  describe('children', () => \{
			    it('passes location prop to matched <Route>', () => \{
			      const node = document.createElement('div');
			
			      let propLocation;
			      const RouteHoneytrap = (props) => \{
			        propLocation = props.location;
			        return <Route \{...props\} />;
			      \};
			
			      const switchLocation = \{ pathname: '/two' \};
			      render(
			        <MemoryRouter initialEntries=\{['/one']\}>
			          <Switch location=\{switchLocation\}>
			            <Route path="/one" render=\{() => <h1>one</h1>\} />
			            <RouteHoneytrap path="/two" render=\{() => <h1>two</h1>\} />
			          </Switch>
			        </MemoryRouter>,
			        node
			      );
			      expect(propLocation).toEqual(switchLocation);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\Switch.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(18)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\SwitchMount.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ Route, Router, Switch \} from 'inferno-router';
			import \{ createMemoryHistory \} from 'history';
			
			describe('A <Switch>', () => \{
			  it('does not remount a <Route>', () => \{
			    const node = document.createElement('div');
			
			    let mountCount = 0;
			
			    class App extends Component \{
			      public componentWillMount() \{
			        mountCount++;
			      \}
			
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    const history = createMemoryHistory(\{
			      initialEntries: ['/one']
			    \});
			
			    render(
			      <Router history=\{history\}>
			        <Switch>
			          <Route path="/one" component=\{App\} />
			          <Route path="/two" component=\{App\} />
			        </Switch>
			      </Router>,
			      node
			    );
			
			    expect(mountCount).toBe(1);
			
			    history.push('/two');
			
			    expect(mountCount).toBe(1);
			    history.push('/one');
			
			    expect(mountCount).toBe(1);
			  \});
			
			  it('Should be possible to have multiple children in Route', () => \{
			    const node = document.createElement('div');
			
			    // @ts-ignore
			    let mountCount = 0;
			
			    class App extends Component \{
			      public componentWillMount() \{
			        mountCount++;
			      \}
			
			      public render() \{
			        return <div />;
			      \}
			    \}
			
			    function Foobar() \{
			      return <span>Okay</span>;
			    \}
			
			    const history = createMemoryHistory(\{
			      initialEntries: ['/one']
			    \});
			
			    render(
			      <Router history=\{history\}>
			        <Switch>
			          <Route path="/one">
			            <App />
			            <App />
			            <div>Test</div>
			          </Route>
			          <Route path="/two">
			            <Foobar />
			          </Route>
			        </Switch>
			      </Router>,
			      node
			    );
			
			    expect(node.innerHTML).toBe('<div></div><div></div><div>Test</div>');
			
			    history.push('/two');
			
			    expect(node.innerHTML).toBe('<span>Okay</span>');
			
			    history.push('/one');
			
			    expect(node.innerHTML).toBe('<div></div><div></div><div>Test</div>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\SwitchMount.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(2)
    });
    it('infernojs_inferno\\packages\\inferno-router\\__tests__\\withRouter.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ MemoryRouter, Route, StaticRouter, withRouter \} from 'inferno-router';
			
			describe('withRouter', () => \{
			  let node;
			
			  beforeEach(function () \{
			    node = document.createElement('div');
			    document.body.appendChild(node);
			  \});
			
			  afterEach(function () \{
			    render(null, node);
			    document.body.removeChild(node);
			  \});
			
			  it('provides \{ match, location, history \} props', () => \{
			    const PropsChecker = withRouter((props) => \{
			      expect(typeof props.match).toBe('object');
			      expect(typeof props.location).toBe('object');
			      expect(typeof props.history).toBe('object');
			      return null;
			    \});
			
			    render(
			      <MemoryRouter initialEntries=\{['/bubblegum']\}>
			        <Route path="/bubblegum" render=\{() => <PropsChecker />\} />
			      </MemoryRouter>,
			      node
			    );
			  \});
			
			  it('provides the parent match as a prop to the wrapped component', () => \{
			    let parentMatch;
			    const PropsChecker = withRouter((props) => \{
			      expect(props.match).toEqual(parentMatch);
			      return null;
			    \});
			
			    render(
			      <MemoryRouter initialEntries=\{['/bubblegum']\}>
			        <Route
			          path="/:flavor"
			          render=\{(\{ match \}) => \{
			            parentMatch = match;
			            return <PropsChecker />;
			          \}\}
			        />
			      </MemoryRouter>,
			      node
			    );
			  \});
			
			  describe('inside a <StaticRouter>', () => \{
			    it('provides the staticContext prop', () => \{
			      const PropsChecker = withRouter((props) => \{
			        expect(typeof props.staticContext).toBe('object');
			        expect(props.staticContext).toBe(context);
			        return null;
			      \});
			
			      const context = \{\};
			
			      render(
			        <StaticRouter context=\{context\}>
			          <Route component=\{PropsChecker\} />
			        </StaticRouter>,
			        node
			      );
			    \});
			  \});
			
			  it('exposes the wrapped component as WrappedComponent', () => \{
			    const TestComponent = () => <div />;
			    const decorated = withRouter(TestComponent);
			    expect(decorated.WrappedComponent).toBe(TestComponent);
			  \});
			
			  it('exposes the instance of the wrapped component via wrappedComponentRef', () => \{
			    class WrappedComponent extends Component \{
			      public render() \{
			        return null;
			      \}
			    \}
			    const TestComponent = withRouter(WrappedComponent);
			
			    let ref;
			    render(
			      <MemoryRouter initialEntries=\{['/bubblegum']\}>
			        <Route path="/bubblegum" render=\{() => <TestComponent wrappedComponentRef=\{(r) => (ref = r)\} />\} />
			      </MemoryRouter>,
			      node
			    );
			
			    expect(ref instanceof Component).toBe(true);
			  \});
			
			  it('hoists non-react statics from the wrapped component', () => \{
			    class TestComponent extends Component \{
			      public static hello: string = 'world';
			
			      public static foo() \{
			        return 'bar';
			      \}
			
			      public render() \{
			        return null;
			      \}
			    \}
			
			    const decorated = withRouter(TestComponent);
			
			    expect(decorated.hello).toBe('world');
			    expect(typeof decorated.foo).toBe('function');
			    expect(decorated.foo()).toBe('bar');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-router\\__tests__\\withRouter.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\animationHooks.spec.server.jsx', () => {
        const sourceCode = `
			import \{ renderToStaticMarkup, renderToString \} from 'inferno-server';
			import \{ Component \} from 'inferno';
			
			/**
			 * NOTE! Animation hooks aren't called during SSR because they use different rendering paths
			 */
			
			describe('SSR Creation (JSX)', () => \{
			  it('should not call "componentDidAppear" when component is rendered with renderToStaticMarkup', (done) => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      componentDidAppear(dom) \{
			        spyer('didAppear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			      \}
			      render() \{
			        return <div />;
			      \}
			    \}
			
			    const outp = renderToStaticMarkup(<App />);
			
			    // Doing this async to be sure
			    setTimeout(() => \{
			      expect(spyer).toHaveBeenCalledTimes(0);
			      expect(outp).toEqual('<div></div>');
			      done();
			    \}, 10);
			  \});
			
			  it('should not call "componentDidAppear" when component is rendered with renderToString', (done) => \{
			    const spyer = jasmine.createSpy();
			    class App extends Component \{
			      componentDidAppear(dom) \{
			        spyer('didAppear');
			        expect(dom instanceof HTMLDivElement).toEqual(true);
			      \}
			      render() \{
			        return <div />;
			      \}
			    \}
			
			    const outp = renderToString(<App />);
			
			    // Doing this async to be sure
			    setTimeout(() => \{
			      expect(spyer).toHaveBeenCalledTimes(0);
			      expect(outp).toEqual('<div></div>');
			      done();
			    \}, 10);
			  \});
			
			  it('should not call "onComponentDidAppear" when component is rendered with renderToStaticMarkup', (done) => \{
			    const spyer = jasmine.createSpy();
			
			    const MyComp = () => \{
			      return <div />;
			    \};
			
			    const onComponentDidAppear = (dom) => \{
			      spyer('didAppear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			    \};
			
			    class App extends Component \{
			      render() \{
			        return <MyComp onComponentDidAppear=\{onComponentDidAppear\} />;
			      \}
			    \}
			
			    const outp = renderToStaticMarkup(<App />);
			
			    // Doing this async to be sure
			    setTimeout(() => \{
			      expect(spyer).toHaveBeenCalledTimes(0);
			      expect(outp).toEqual('<div></div>');
			      done();
			    \}, 10);
			  \});
			
			  it('should not call "onComponentDidAppear" when component is rendered with renderToString', (done) => \{
			    const spyer = jasmine.createSpy();
			
			    const MyComp = () => \{
			      return <div />;
			    \};
			
			    const onComponentDidAppear = (dom) => \{
			      spyer('didAppear');
			      expect(dom instanceof HTMLDivElement).toEqual(true);
			    \};
			
			    class App extends Component \{
			      render() \{
			        return <MyComp onComponentDidAppear=\{onComponentDidAppear\} />;
			      \}
			    \}
			
			    const outp = renderToString(<App />);
			
			    // Doing this async to be sure
			    setTimeout(() => \{
			      expect(spyer).toHaveBeenCalledTimes(0);
			      expect(outp).toEqual('<div></div>');
			      done();
			    \}, 10);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\animationHooks.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\creation-queuestream.spec.server.jsx', () => {
        const sourceCode = `
			import \{ Component \} from 'inferno';
			import \{ streamQueueAsString \} from 'inferno-server';
			
			import concatStream from 'concat-stream-es6';
			import \{ createElement \} from 'inferno-create-element';
			
			class StatefulComponent extends Component \{
			  render() \{
			    return createElement('span', null, \`stateless \$\{this.props.value\}!\`);
			  \}
			\}
			
			function WrappedInput(props) \{
			  return <input type="text" value=\{props.value\} />;
			\}
			
			class StatefulPromiseComponent extends Component \{
			  getInitialProps() \{
			    return new Promise((resolve, reject) => \{
			      // Waits incremenetally for each subindex
			      setTimeout(() => \{
			        resolve(\{
			          value: 'I waited long enough!'
			        \});
			      \}, 5 * this.props.index);
			    \});
			  \}
			
			  render() \{
			    return createElement('span', null, \`Stateless Item \$\{this.props.index\}: \$\{this.props.value\}\`);
			  \}
			\}
			
			class StatefulHierchicalPromiseComponent extends Component \{
			  getInitialProps() \{
			    return new Promise((resolve, reject) => \{
			      // Waits incremenetally for each subindex
			      setTimeout(() => \{
			        resolve(\{
			          value: \`I waited long enough for \$\{this.props.index\}!\`
			        \});
			      \}, 0);
			    \});
			  \}
			
			  render() \{
			    if (this.props.index > 4) \{
			      return createElement('span', null, \`Final Stateless Item \$\{this.props.index\}: \$\{this.props.value\}\`);
			    \} else \{
			      return createElement(
			        'div',
			        \{ className: 'child' \},
			        \`Stateless Item \$\{this.props.index\}: \$\{this.props.value\}\`,
			        createElement(StatefulHierchicalPromiseComponent, \{
			          index: this.props.index + 1
			        \})
			      );
			    \}
			  \}
			\}
			
			const FunctionalComponent = (\{ value \}) => createElement('span', null, \`stateless \$\{value\}!\`);
			
			describe('SSR Creation Queue Streams - (non-JSX)', () => \{
			  const testEntries = [
			    \{
			      description: 'should render div with span child',
			      template: () => createElement('div', null, createElement('span', null)),
			      result: '<div><span></span></div>'
			    \},
			    \{
			      description: 'should render div with span child and styling',
			      template: () => createElement('div', null, createElement('span', \{ style: 'border-left: 10px;' \})),
			      result: '<div><span style="border-left: 10px;"></span></div>'
			    \},
			    // TODO: Fix this
			    // \{
			    //   description: "should render select element with selected property",
			    //   template: () =>
			    //     createElement('select', \{
			    //       value: 'dog'
			    //     \}, [
			    //       createElement('option', \{value: 'cat'\}, 'A cat'),
			    //       createElement('option', \{value: 'dog'\}, 'A dog')
			    //     ]),
			    //   result: '<select value="dog"><option value="cat">A cat</option><option value="dog" selected>A dog</option></select>'
			    // \},
			    \{
			      description: 'should render div with span child and styling #2',
			      template: () => createElement('div', null, createElement('span', \{ style: \{ 'border-left': '10px' \} \})),
			      result: '<div><span style="border-left:10px;"></span></div>'
			    \},
			    \{
			      description: 'should render div with span child and styling #3',
			      template: () => createElement('div', null, createElement('span', \{ style: \{ 'font-family': 'Arial' \} \})),
			      result: '<div><span style="font-family:Arial;"></span></div>'
			    \},
			    \{
			      description: 'should render div with span child (with className)',
			      template: () => createElement('div', \{ className: 'foo' \}, createElement('span', \{ className: 'bar' \})),
			      result: '<div class="foo"><span class="bar"></span></div>'
			    \},
			    \{
			      description: 'should render div with text child #1',
			      template: () => createElement('div', null, 'Hello world'),
			      result: '<div>Hello world</div>'
			    \},
			    \{
			      description: 'should render div with text child (XSS script attack)',
			      template: () => createElement('div', null, 'Hello world <img src="x" onerror="alert(\\'XSS\\')">'),
			      result: '<div>Hello world &lt;img src=&quot;x&quot; onerror=&quot;alert(&#039;XSS&#039;)&quot;&gt;</div>'
			    \},
			    \{
			      description: 'should render div with text children',
			      template: () => createElement('div', null, 'Hello', ' world'),
			      result: '<div>Hello world</div>'
			    \},
			    \{
			      description: 'should render a void element correct',
			      template: () => createElement('input', null),
			      result: '<input>'
			    \},
			    \{
			      description: 'should render div with node children',
			      template: () => createElement('div', null, createElement('span', null, 'Hello'), createElement('span', null, ' world!')),
			      result: '<div><span>Hello</span><span> world!</span></div>'
			    \},
			    \{
			      description: 'should render div with node children #2',
			      template: () => createElement('div', null, createElement('span', \{ id: '123' \}, 'Hello'), createElement('span', \{ className: 'foo' \}, ' world!')),
			      result: '<div><span id="123">Hello</span><span class="foo"> world!</span></div>'
			    \},
			    \{
			      description: 'should render div with falsy children',
			      template: () => createElement('div', null, 0),
			      result: '<div>0</div>'
			    \},
			    \{
			      description: 'should render div with dangerouslySetInnerHTML',
			      template: () =>
			        createElement('div', \{
			          dangerouslySetInnerHTML: \{ __html: '<span>test</span>' \}
			        \}),
			      result: '<div><span>test</span></div>'
			    \},
			    \{
			      description: 'should render a stateless component',
			      template: (value) => createElement('div', null, createElement(FunctionalComponent, \{ value \})),
			      result: '<div><span>stateless foo!</span></div>'
			    \},
			    \{
			      description: 'should render a div with styles',
			      template: () => createElement('div', \{ style: \{ display: 'block', width: '50px' \} \}),
			      result: '<div style="display:block;width:50px;"></div>'
			    \},
			    \{
			      description: 'should ignore null className',
			      template: () => createElement('div', \{ className: null \}),
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should ignore undefined className',
			      template: () => createElement('div', \{ className: undefined \}),
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render a stateful component',
			      template: (value) => createElement('div', null, createElement(StatefulComponent, \{ value \})),
			      result: '<div><span>stateless foo!</span></div>'
			    \},
			    // Following tests check for not only concatenated output, but chunked streams
			    \{
			      description: 'should render a stateless component',
			      template: (value) => createElement('div', null, createElement(FunctionalComponent, \{ value \})),
			      result: [['<div>', '<span>', 'stateless foo!', '</span>', '</div>'], '<div><span>stateless foo!</span></div>']
			    \},
			    \{
			      description: 'should render a stateful component with promise',
			      template: (value) => createElement('div', null, createElement(StatefulPromiseComponent, \{ index: 1 \})),
			      result: [['<div>', '<span>Stateless Item 1: I waited long enough!</span>', '</div>'], '<div><span>Stateless Item 1: I waited long enough!</span></div>']
			    \},
			    \{
			      description: 'should render a stateful component with promise as hierarchy',
			      template: (value) => createElement(StatefulHierchicalPromiseComponent, \{ index: 1 \}),
			      result: [
			        [
			          '<div class="child">Stateless Item 1: I waited long enough for 1!',
			          '<div class="child">Stateless Item 2: I waited long enough for 2!',
			          '<div class="child">Stateless Item 3: I waited long enough for 3!',
			          '<div class="child">Stateless Item 4: I waited long enough for 4!',
			          '<span>Final Stateless Item 5: I waited long enough for 5!</span>',
			          '</div>',
			          '</div>',
			          '</div>',
			          '</div>'
			        ],
			        '<div class="child">Stateless Item 1: I waited long enough for 1!<div class="child">Stateless Item 2: I waited long enough for 2!<div class="child">Stateless Item 3: I waited long enough for 3!<div class="child">Stateless Item 4: I waited long enough for 4!<span>Final Stateless Item 5: I waited long enough for 5!</span></div></div></div></div>'
			      ]
			    \},
			    \{
			      description: 'should render a stack of stateful component with promise',
			      template: (value) =>
			        createElement(
			          'div',
			          null,
			          createElement(StatefulPromiseComponent, \{ index: 1 \}),
			          createElement(StatefulPromiseComponent, \{ index: 2 \}),
			          createElement(StatefulPromiseComponent, \{ index: 3 \})
			        ),
			      result: [
			        [
			          '<div>',
			          '<span>Stateless Item 1: I waited long enough!</span>',
			          '<span>Stateless Item 2: I waited long enough!</span>',
			          '<span>Stateless Item 3: I waited long enough!</span>',
			          '</div>'
			        ],
			        '<div><span>Stateless Item 1: I waited long enough!</span><span>Stateless Item 2: I waited long enough!</span><span>Stateless Item 3: I waited long enough!</span></div>'
			      ]
			    \},
			    \{
			      description: 'should render opacity style',
			      template: () => createElement('div', \{ style: \{ opacity: 0.8 \} \}),
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render div className as number',
			      template: () => createElement('div', \{ className: 123 \}),
			      result: '<div class="123"></div>'
			    \},
			    \{
			      description: 'Should render input defaultValue as number',
			      template: () => createElement('input', \{ defaultValue: 123 \}),
			      result: '<input value="123">'
			    \},
			    // JSX
			    \{
			      description: 'should render a null component',
			      template: () => <div>\{null\}</div>,
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render a component with null children',
			      template: () => (
			        <div>
			          \{null\}
			          <span>emptyValue: \{null\}</span>
			        </div>
			      ),
			      result: '<div><span>emptyValue: </span></div>'
			    \},
			    \{
			      description: 'should render a component with valueless attribute',
			      template: () => <script src="foo" async />,
			      result: '<script src="foo" async></script>'
			    \},
			    \{
			      description: 'should render a stateless component with text',
			      template: () => (
			        <div>
			          Hello world, \{'1'\}2\{'3'\}
			        </div>
			      ),
			      result: '<div>Hello world, 123</div>'
			    \},
			    \{
			      description: 'should render text with escaped symbols',
			      template: () => <div>"Hello world"</div>,
			      result: '<div>&quot;Hello world&quot;</div>'
			    \},
			    \{
			      description: 'should render a stateless component with comments',
			      template: () => <div>Hello world, \{/* comment*/\}</div>,
			      result: '<div>Hello world, </div>'
			    \},
			    \{
			      description: 'should render mixed invalid/valid children',
			      template: () => <div>\{[null, '123', null, '456']\}</div>,
			      result: '<div>123456</div>'
			    \},
			    \{
			      description: 'should ignore children as props',
			      template: () => <p children="foo">foo</p>,
			      result: '<p>foo</p>'
			    \},
			    \{
			      description: 'should render input with value',
			      template: () => <input value="bar" />,
			      result: '<input value="bar">'
			    \},
			    \{
			      description: 'should render input with value when defaultValue is present',
			      template: () => <input value="bar" defaultValue="foo" />,
			      result: '<input value="bar">'
			    \},
			    \{
			      description: 'should render input when value is not present with defaultValue',
			      template: () => <input defaultValue="foo" />,
			      result: '<input value="foo">'
			    \},
			    \{
			      description: 'should render input when defaultValue is number',
			      template: () => <input defaultValue=\{123\} />,
			      result: '<input value="123">'
			    \},
			    \{
			      description: 'should render input of type text with value when input is wrapped',
			      template: () => <WrappedInput value="foo" />,
			      result: '<input type="text" value="foo">'
			    \},
			    // \{
			    //   description: 'should render select element with selected property',
			    //   template: () => (
			    //     <select value="dog">
			    //       <option value="cat">A cat</option>
			    //       <option value="dog">A dog</option>
			    //     </select>
			    //   ),
			    //   result:
			    //     '<select value="dog"><option value="cat">A cat</option><option value="dog" selected>A dog</option></select>'
			    // \},
			    \{
			      description: 'should render a text placeholder',
			      template: () => (
			        <div>
			          <div>\{''\}</div>
			          <p>Test</p>
			        </div>
			      ),
			      result: '<div><div> </div><p>Test</p></div>'
			    \},
			    \{
			      description: 'Should render background color',
			      template: () => <div style=\{\{ 'background-color': 'red', 'border-bottom-color': 'green' \}\} />,
			      result: '<div style="background-color:red;border-bottom-color:green;"></div>'
			    \},
			    \{
			      description: 'Should not render null styles',
			      template: () => <div style=\{\{ 'background-color': null, 'border-bottom-color': null \}\} />,
			      result: '<div style=""></div>'
			    \},
			    \{
			      description: 'Should style attribute if null',
			      template: () => <div style=\{null\} />,
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render div with text child (XSS script attack) #2',
			      template: () => createElement('div', null, 'Hello world <img src="x" onerror="alert(\\'&XSS&\\')">'),
			      result: '<div>Hello world &lt;img src=&quot;x&quot; onerror=&quot;alert(&#039;&amp;XSS&amp;&#039;)&quot;&gt;</div>'
			    \},
			    \{
			      description: 'Should render style opacity #1',
			      template: () => <div style=\{\{ opacity: 0.8 \}\} />,
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render style opacity #2',
			      template: () => <div style="opacity:0.8;" />,
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render div className as number',
			      template: () => <div className=\{123\} />,
			      result: '<div class="123"></div>'
			    \},
			    \{
			      description: 'Should render input defaultValue as number',
			      template: () => <input defaultValue=\{123\} />,
			      result: '<input value="123">'
			    \},
			    \{
			      description: 'BR should not be closed',
			      template: () => (
			        <div>
			          <br />
			        </div>
			      ),
			      result: '<div><br></div>'
			    \},
			    \{
			      description: 'You should be able to render an array',
			      template: () => [<p>1</p>, <p>2</p>, <p>3</p>],
			      result: '<p>1</p><p>2</p><p>3</p>'
			    \},
			    \{
			      description: 'You should be able to render an empty array',
			      template: () => [],
			      result: '<!--!-->'
			    \},
			    \{
			      description: 'You should be able to render a fragment',
			      template: () => (
			        <>
			          <p>1</p>
			          <p>2</p>
			          <p>3</p>
			        </> /* reset syntax highlighting */
			      ),
			      result: '<p>1</p><p>2</p><p>3</p>'
			    \},
			    \{
			      description: 'You should be able to render an empty fragment',
			      template: () => <></> /* reset syntax highlighting */,
			      result: '<!--!-->'
			    \},
			    \{
			      description: 'You should be able to render fragment with single child',
			      template: () => (
			        <>
			          <p>1</p>
			        </>
			      ) /* reset syntax highlighting */,
			      result: '<p>1</p>'
			    \}
			  ];
			
			  testEntries.forEach((test) => \{
			    it(test.description, (done) => \{
			      const vDom = test.template('foo');
			      return streamPromise(vDom).then(function (output) \{
			        if (typeof test.result === 'object') \{
			          expect(output[0]).toEqual(test.result[0]);
			          expect(output[1]).toBe(test.result[1]);
			        \} else \{
			          const container = document.createElement('div');
			          document.body.appendChild(container);
			          container.innerHTML = output;
			          expect(output[1]).toBe(test.result);
			          document.body.removeChild(container);
			        \}
			        done();
			      \});
			    \});
			  \});
			
			  describe('Component hook', () => \{
			    it('Should allow changing state in CWM', () => \{
			      class Another extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return <div>\{this.state.foo\}</div>;
			        \}
			      \}
			
			      class Tester extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              \{this.state.foo\}
			              <Another />
			            </div>
			          );
			        \}
			      \}
			
			      const vDom = <Tester />;
			      return streamPromise(vDom).then(function (output) \{
			        const container = document.createElement('div');
			        document.body.appendChild(container);
			        container.innerHTML = output;
			        expect(output[1]).toBe('<div>bar2<div>bar2</div></div>');
			        document.body.removeChild(container);
			      \});
			    \});
			  \});
			
			  describe('misc', () => \{
			    it('Should render single text node using state', (done) => \{
			      class Foobar extends Component \{
			        render() \{
			          return this.state.text;
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            text: 'foo'
			          \});
			        \}
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output[1]).toEqual('<div>foo</div>');
			        done();
			      \});
			    \});
			
			    it('Should render single (number) text node using state', (done) => \{
			      class Foobar extends Component \{
			        render() \{
			          return this.state.text;
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            text: 331
			          \});
			        \}
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output[1]).toEqual('<div>331</div>');
			        done();
			      \});
			    \});
			
			    it('Should render single text node Functional Component', (done) => \{
			      function Foobar() \{
			        return 'foo';
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output[1]).toEqual('<div>foo</div>');
			        done();
			      \});
			    \});
			
			    it('Should render single (number) text node Functional Component', (done) => \{
			      function Foobar() \{
			        return 0;
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output[1]).toEqual('<div>0</div>');
			        done();
			      \});
			    \});
			
			    it('Should render checked attribute for input when there is no checked in props', (done) => \{
			      class Foobar extends Component \{
			        render() \{
			          return <input count=\{1\} type="checkbox" defaultChecked=\{true\} />;
			        \}
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output[1]).toEqual('<div><input count="1" type="checkbox" checked="true"></div>');
			        done();
			      \});
			    \});
			
			    it('Should render comment when component returns invalid node', (done) => \{
			      function Foobar() \{
			        return null;
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output[1]).toEqual('<div><!--!--></div>');
			        done();
			      \});
			    \});
			
			    it('Should render single text node Class Component', (done) => \{
			      class Foobar extends Component \{
			        render() \{
			          return null;
			        \}
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output[1]).toEqual('<div><!--!--></div>');
			        done();
			      \});
			    \});
			
			    it('Should be possible to use getDerivedStateFromProps', (done) => \{
			      class Test extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            value: 0
			          \};
			        \}
			
			        static getDerivedStateFromProps(props, state) \{
			          return \{
			            value: state.value + 1
			          \};
			        \}
			
			        render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			      return streamPromise(<Test />).then(function (output) \{
			        expect(output[1]).toEqual('<div>1</div>');
			        done();
			      \});
			    \});
			  \});
			\});
			
			function streamPromise(dom) \{
			  return new Promise(function (res, rej) \{
			    const chunks = [];
			    streamQueueAsString(dom)
			      .on('error', rej)
			      .on('data', (chunk) => \{
			        chunks.push(chunk.toString());
			      \})
			      .pipe(
			        concatStream(function (buffer) \{
			          res([chunks, buffer.toString('utf-8')]);
			        \})
			      );
			  \});
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\creation-queuestream.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(10)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\creation-stream.spec.server.js', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			import \{ createElement \} from 'inferno-create-element';
			import \{ streamAsStaticMarkup \} from 'inferno-server';
			import concatStream from 'concat-stream-es6';
			
			describe('SSR Root Creation Streams - (non-JSX)', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    document.body.removeChild(container);
			  \});
			
			  it('should throw with invalid children', () => \{
			    const test = (value) => createElement('a', null, true);
			
			    return streamPromise(test('foo')).catch((err) => \{
			      expect(err.toString()).toBe('Error: invalid component');
			    \});
			  \});
			
			  it('should use getChildContext', () => \{
			    const TestComponent = createClass(\{
			      getChildContext() \{
			        return \{ hello: 'world' \};
			      \},
			      render() \{
			        return createElement('a', null, this.context.hello);
			      \}
			    \});
			    return streamPromise(createElement(TestComponent, null)).then(function (output) \{
			      expect(output).toBe('<a>world</a>');
			    \});
			  \});
			
			  describe('Component hook', () => \{
			    it('Should allow changing state in CWM', () => \{
			      class Another extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return createElement('div', null, this.state.foo);
			        \}
			      \}
			
			      class Tester extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return createElement('div', null, [this.state.foo, createElement(Another)]);
			        \}
			      \}
			
			      const vDom = createElement(Tester);
			      return streamPromise(vDom).then(function (output) \{
			        const container = document.createElement('div');
			        document.body.appendChild(container);
			        container.innerHTML = output;
			        expect(output).toBe('<div>bar2<div>bar2</div></div>');
			        document.body.removeChild(container);
			      \});
			    \});
			  \});
			\});
			
			function streamPromise(dom) \{
			  return new Promise(function (res, rej) \{
			    streamAsStaticMarkup(dom)
			      .on('error', rej)
			      .pipe(
			        concatStream(function (buffer) \{
			          res(buffer.toString('utf-8'));
			        \})
			      );
			  \});
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\creation-stream.spec.server.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(4)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\creation-stream.spec.server.jsx', () => {
        const sourceCode = `
			import \{ Component \} from 'inferno';
			import \{ streamAsString \} from 'inferno-server';
			import concatStream from 'concat-stream-es6';
			import \{ createElement \} from 'inferno-create-element';
			
			class StatefulComponent extends Component \{
			  render() \{
			    return createElement('span', null, \`stateless \$\{this.props.value\}!\`);
			  \}
			\}
			
			function WrappedInput(props) \{
			  return <input type="text" value=\{props.value\} />;
			\}
			
			const FunctionalComponent = (\{ value \}) => createElement('span', null, \`stateless \$\{value\}!\`);
			
			describe('SSR Creation Streams - (non-JSX)', () => \{
			  const testEntries = [
			    \{
			      description: 'should render div with span child',
			      template: () => createElement('div', null, createElement('span', null)),
			      result: '<div><span></span></div>'
			    \},
			    \{
			      description: 'should render div with span child and styling',
			      template: () => createElement('div', null, createElement('span', \{ style: 'border-left: 10px;' \})),
			      result: '<div><span style="border-left: 10px;"></span></div>'
			    \},
			    // TODO: Fix this
			    // \{
			    //   description: "should render select element with selected property",
			    //   template: () =>
			    //     createElement('select', \{
			    //       value: 'dog'
			    //     \}, [
			    //       createElement('option', \{value: 'cat'\}, 'A cat'),
			    //       createElement('option', \{value: 'dog'\}, 'A dog')
			    //     ]),
			    //   result: '<select value="dog"><option value="cat">A cat</option><option value="dog" selected>A dog</option></select>'
			    // \},
			    \{
			      description: 'should render div with span child and styling #2',
			      template: () => createElement('div', null, createElement('span', \{ style: \{ 'border-left': '10px' \} \})),
			      result: '<div><span style="border-left:10px;"></span></div>'
			    \},
			    \{
			      description: 'should render div with span child and styling #3',
			      template: () => createElement('div', null, createElement('span', \{ style: \{ 'font-family': 'Arial' \} \})),
			      result: '<div><span style="font-family:Arial;"></span></div>'
			    \},
			    \{
			      description: 'should render div with span child (with className)',
			      template: () => createElement('div', \{ className: 'foo' \}, createElement('span', \{ className: 'bar' \})),
			      result: '<div class="foo"><span class="bar"></span></div>'
			    \},
			    \{
			      description: 'should render div with text child #2',
			      template: () => createElement('div', null, 'Hello world'),
			      result: '<div>Hello world</div>'
			    \},
			    \{
			      description: 'should render div with text child (XSS script attack)',
			      template: () => createElement('div', null, 'Hello world <img src="x" onerror="alert(\\'XSS\\')">'),
			      result: '<div>Hello world &lt;img src=&quot;x&quot; onerror=&quot;alert(&#039;XSS&#039;)&quot;&gt;</div>'
			    \},
			    \{
			      description: 'should render div with text children',
			      template: () => createElement('div', null, 'Hello', ' world'),
			      result: '<div>Hello world</div>'
			    \},
			    \{
			      description: 'should render a void element correct',
			      template: () => createElement('input', null),
			      result: '<input>'
			    \},
			    \{
			      description: 'should render div with node children',
			      template: () => createElement('div', null, createElement('span', null, 'Hello'), createElement('span', null, ' world!')),
			      result: '<div><span>Hello</span><span> world!</span></div>'
			    \},
			    \{
			      description: 'should render div with node children #2',
			      template: () => createElement('div', null, createElement('span', \{ id: '123' \}, 'Hello'), createElement('span', \{ className: 'foo' \}, ' world!')),
			      result: '<div><span id="123">Hello</span><span class="foo"> world!</span></div>'
			    \},
			    \{
			      description: 'should render div with falsy children',
			      template: () => createElement('div', null, 0),
			      result: '<div>0</div>'
			    \},
			    \{
			      description: 'should render div with dangerouslySetInnerHTML',
			      template: () =>
			        createElement('div', \{
			          dangerouslySetInnerHTML: \{ __html: '<span>test</span>' \}
			        \}),
			      result: '<div><span>test</span></div>'
			    \},
			    \{
			      description: 'should render a stateful component',
			      template: (value) => createElement('div', null, createElement(StatefulComponent, \{ value \})),
			      result: '<div><span>stateless foo!</span></div>'
			    \},
			    \{
			      description: 'should render a stateless component',
			      template: (value) => createElement('div', null, createElement(FunctionalComponent, \{ value \})),
			      result: '<div><span>stateless foo!</span></div>'
			    \},
			    \{
			      description: 'should render a stateless component with object props',
			      template: (value) => createElement('a', \{ [value]: true \}),
			      result: '<a foo></a>'
			    \},
			    \{
			      description: 'should render with array text children',
			      template: (value) => createElement('a', null, ['a', 'b']),
			      result: '<a>ab</a>'
			    \},
			    \{
			      description: 'should render with array children containing an array of text children',
			      template: (value) => createElement('a', null, [['a', 'b']]),
			      result: '<a>ab</a>'
			    \},
			    \{
			      description: 'should render with array null children',
			      template: (value) => createElement('a', null, ['a', null]),
			      result: '<a>a</a>'
			    \},
			    \{
			      description: 'should ignore null className',
			      template: () => createElement('div', \{ className: null \}),
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should ignore undefined className',
			      template: () => createElement('div', \{ className: undefined \}),
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render opacity style',
			      template: () => createElement('div', \{ style: \{ opacity: 0.8 \} \}),
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render div className as number',
			      template: () => createElement('div', \{ className: 123 \}),
			      result: '<div class="123"></div>'
			    \},
			    \{
			      description: 'should render a null component',
			      template: () => <div>\{null\}</div>,
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render a component with null children',
			      template: () => (
			        <div>
			          \{null\}
			          <span>emptyValue: \{null\}</span>
			        </div>
			      ),
			      result: '<div><span>emptyValue: </span></div>'
			    \},
			    \{
			      description: 'should render a component with valueless attribute',
			      template: () => <script src="foo" async />,
			      result: '<script src="foo" async></script>'
			    \},
			    \{
			      description: 'should render a stateless component with text',
			      template: () => (
			        <div>
			          Hello world, \{'1'\}2\{'3'\}
			        </div>
			      ),
			      result: '<div>Hello world, 123</div>'
			    \},
			    \{
			      description: 'should render text with escaped symbols',
			      template: () => <div>"Hello world"</div>,
			      result: '<div>&quot;Hello world&quot;</div>'
			    \},
			    \{
			      description: 'should render a stateless component with comments',
			      template: () => <div>Hello world, \{/* comment*/\}</div>,
			      result: '<div>Hello world, </div>'
			    \},
			    \{
			      description: 'should render mixed invalid/valid children',
			      template: () => <div>\{[null, '123', null, '456']\}</div>,
			      result: '<div>123456</div>'
			    \},
			    \{
			      description: 'should ignore children as props',
			      template: () => <p children="foo">foo</p>,
			      result: '<p>foo</p>'
			    \},
			    \{
			      description: 'should render input with value',
			      template: () => <input value="bar" />,
			      result: '<input value="bar">'
			    \},
			    \{
			      description: 'should render input with value when defaultValue is present',
			      template: () => <input value="bar" defaultValue="foo" />,
			      result: '<input value="bar">'
			    \},
			    \{
			      description: 'should render input when value is not present with defaultValue',
			      template: () => <input defaultValue="foo" />,
			      result: '<input value="foo">'
			    \},
			    \{
			      description: 'should render input when defaultValue is number',
			      template: () => <input defaultValue=\{123\} />,
			      result: '<input value="123">'
			    \},
			    \{
			      description: 'should render input of type text with value when input is wrapped',
			      template: () => <WrappedInput value="foo" />,
			      result: '<input type="text" value="foo">'
			    \},
			    // \{
			    //   description: 'should render select element with selected property',
			    //   template: () => (
			    //     <select value="dog">
			    //       <option value="cat">A cat</option>
			    //       <option value="dog">A dog</option>
			    //     </select>
			    //   ),
			    //   result:
			    //     '<select value="dog"><option value="cat">A cat</option><option value="dog" selected>A dog</option></select>'
			    // \},
			    \{
			      description: 'should render a text placeholder',
			      template: () => (
			        <div>
			          <div>\{''\}</div>
			          <p>Test</p>
			        </div>
			      ),
			      result: '<div><div> </div><p>Test</p></div>'
			    \},
			    \{
			      description: 'Should render background color',
			      template: () => <div style=\{\{ 'background-color': 'red', 'border-bottom-color': 'green' \}\} />,
			      result: '<div style="background-color:red;border-bottom-color:green;"></div>'
			    \},
			    \{
			      description: 'Should not render null styles',
			      template: () => <div style=\{\{ 'background-color': null, 'border-bottom-color': null \}\} />,
			      result: '<div style=""></div>'
			    \},
			    \{
			      description: 'Should style attribute if null',
			      template: () => <div style=\{null\} />,
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render div with text child (XSS script attack) #2',
			      template: () => createElement('div', null, 'Hello world <img src="x" onerror="alert(\\'&XSS&\\')">'),
			      result: '<div>Hello world &lt;img src=&quot;x&quot; onerror=&quot;alert(&#039;&amp;XSS&amp;&#039;)&quot;&gt;</div>'
			    \},
			    \{
			      description: 'Should render style opacity #1',
			      template: () => <div style=\{\{ opacity: 0.8 \}\} />,
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render style opacity #2',
			      template: () => <div style="opacity:0.8;" />,
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render div className as number',
			      template: () => <div className=\{123\} />,
			      result: '<div class="123"></div>'
			    \},
			    \{
			      description: 'Should render input defaultValue as number',
			      template: () => <input defaultValue=\{123\} />,
			      result: '<input value="123">'
			    \},
			    \{
			      description: 'BR should not be closed',
			      template: () => (
			        <div>
			          <br />
			        </div>
			      ),
			      result: '<div><br></div>'
			    \},
			    \{
			      description: 'You should be able to render an array',
			      template: () => [<p>1</p>, <p>2</p>, <p>3</p>],
			      result: '<p>1</p><p>2</p><p>3</p>'
			    \},
			    \{
			      description: 'You should be able to render an empty array',
			      template: () => [],
			      result: '<!--!-->'
			    \},
			    \{
			      description: 'You should be able to render a fragment',
			      template: () => (
			        <>
			          <p>1</p>
			          <p>2</p>
			          <p>3</p>
			        </> /* reset syntax highlighting */
			      ),
			      result: '<p>1</p><p>2</p><p>3</p>'
			    \},
			    \{
			      description: 'You should be able to render an empty fragment',
			      template: () => <></> /* reset syntax highlighting */,
			      result: '<!--!-->'
			    \},
			    \{
			      description: 'You should be able to render fragment with single child',
			      template: () => (
			        <>
			          <p>1</p>
			        </>
			      ) /* reset syntax highlighting */,
			      result: '<p>1</p>'
			    \}
			  ];
			
			  testEntries.forEach((test) => \{
			    it(test.description, () => \{
			      const container = document.createElement('div');
			      const vDom = test.template('foo');
			      return streamPromise(vDom).then(function (output) \{
			        document.body.appendChild(container);
			        container.innerHTML = output;
			        expect(output).toBe(test.result);
			        document.body.removeChild(container);
			      \});
			    \});
			  \});
			
			  describe('Component hook', () => \{
			    it('Should allow changing state in CWM', () => \{
			      class Another extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return <div>\{this.state.foo\}</div>;
			        \}
			      \}
			
			      class Tester extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              \{this.state.foo\}
			              <Another />
			            </div>
			          );
			        \}
			      \}
			
			      const vDom = <Tester />;
			      return streamPromise(vDom).then(function (output) \{
			        const container = document.createElement('div');
			        document.body.appendChild(container);
			        container.innerHTML = output;
			        expect(output).toBe('<div>bar2<div>bar2</div></div>');
			        document.body.removeChild(container);
			      \});
			    \});
			  \});
			
			  describe('misc', () => \{
			    it('Should render single text node using state', (done) => \{
			      class Foobar extends Component \{
			        render() \{
			          return this.state.text;
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            text: 'foo'
			          \});
			        \}
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output).toEqual('<div>foo</div>');
			        done();
			      \});
			    \});
			
			    it('Should render single (number) text node using state', (done) => \{
			      class Foobar extends Component \{
			        render() \{
			          return this.state.text;
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            text: 331
			          \});
			        \}
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output).toEqual('<div>331</div>');
			        done();
			      \});
			    \});
			
			    it('Should render single text node Functional Component', (done) => \{
			      function Foobar() \{
			        return 'foo';
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output).toEqual('<div>foo</div>');
			        done();
			      \});
			    \});
			
			    it('Should render single (number) text node Functional Component', (done) => \{
			      function Foobar() \{
			        return 0;
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output).toEqual('<div>0</div>');
			        done();
			      \});
			    \});
			
			    // it('Should render checked attribute for input when there is no checked in props', (done) => \{
			    //   class Foobar extends Component \{
			    //     render() \{
			    //       return <input count=\{1\} type="checkbox" defaultChecked=\{true\}/>;
			    //     \}
			    //   \}
			    //
			    //   return streamPromise(<div><Foobar /></div>).then(function(output) \{
			    //     expect(output).toEqual('<div><input count="1" type="checkbox" checked="true"></div>');
			    //     done();
			    //   \});
			    // \});
			
			    it('Should render comment when component returns invalid node', (done) => \{
			      function Foobar() \{
			        return null;
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output).toEqual('<div><!--!--></div>');
			        done();
			      \});
			    \});
			
			    it('Should render single text node Class Component', (done) => \{
			      class Foobar extends Component \{
			        render() \{
			          return null;
			        \}
			      \}
			
			      return streamPromise(
			        <div>
			          <Foobar />
			        </div>
			      ).then(function (output) \{
			        expect(output).toEqual('<div><!--!--></div>');
			        done();
			      \});
			    \});
			
			    it('Should be possible to use getDerivedStateFromProps', (done) => \{
			      class Test extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            value: 0
			          \};
			        \}
			
			        static getDerivedStateFromProps(props, state) \{
			          return \{
			            value: state.value + 1
			          \};
			        \}
			
			        render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			      return streamPromise(<Test />).then(function (output) \{
			        expect(output).toEqual('<div>1</div>');
			        done();
			      \});
			    \});
			  \});
			\});
			
			function streamPromise(dom) \{
			  return new Promise(function (res, rej) \{
			    streamAsString(dom)
			      .on('error', rej)
			      .pipe(
			        concatStream(function (buffer) \{
			          res(buffer.toString('utf-8'));
			        \})
			      );
			  \});
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\creation-stream.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\creation.spec.server.js', () => {
        const sourceCode = `
			import \{ createElement \} from 'inferno-create-element';
			import \{ renderToStaticMarkup \} from 'inferno-server';
			
			/*
			 class StatefulComponent extends Component \{
			 render() \{
			 return createElement('span', null, \`stateless \$\{ this.props.value \}!\`);
			 \}
			 \}*/
			
			const FunctionalComponent = (\{ value \}) => createElement('span', null, \`stateless \$\{value\}!\`);
			
			describe('SSR Creation (non-JSX)', () => \{
			  const testEntries = [
			    \{
			      description: 'should render div with span child',
			      template: () => createElement('div', null, createElement('span', null)),
			      result: '<div><span></span></div>'
			    \},
			    \{
			      description: 'should render div with span child and styling',
			      template: () => createElement('div', null, createElement('span', \{ style: 'border-left: 10px;' \})),
			      result: '<div><span style="border-left: 10px;"></span></div>'
			    \},
			    \{
			      description: 'should render div with span child and styling #2',
			      template: () => createElement('div', null, createElement('span', \{ style: \{ 'border-left': 10 \} \})),
			      result: '<div><span style="border-left:10;"></span></div>'
			    \},
			    \{
			      description: 'should render div with span child and styling #3',
			      template: () => createElement('div', null, createElement('span', \{ style: \{ 'font-family': 'Arial' \} \})),
			      result: '<div><span style="font-family:Arial;"></span></div>'
			    \},
			    \{
			      description: 'should render div with span child (with className)',
			      template: () => createElement('div', \{ className: 'foo' \}, createElement('span', \{ className: 'bar' \})),
			      result: '<div class="foo"><span class="bar"></span></div>'
			    \},
			    \{
			      description: 'should render div with text child',
			      template: () => createElement('div', null, 'Hello world'),
			      result: '<div>Hello world</div>'
			    \},
			    \{
			      description: 'should render div with text child (XSS script attack)',
			      template: () => createElement('div', null, 'Hello world <img src="x" onerror="alert(\\'XSS\\')">'),
			      result: '<div>Hello world &lt;img src=&quot;x&quot; onerror=&quot;alert(&#039;XSS&#039;)&quot;&gt;</div>'
			    \},
			    \{
			      description: 'should render div with text children',
			      template: () => createElement('div', null, 'Hello', ' world'),
			      result: '<div>Hello world</div>'
			    \},
			    \{
			      description: 'should render a void element correct',
			      template: () => createElement('input', null),
			      result: '<input>'
			    \},
			    \{
			      description: 'should render div with node children',
			      template: () => createElement('div', null, createElement('span', null, 'Hello'), createElement('span', null, ' world!')),
			      result: '<div><span>Hello</span><span> world!</span></div>'
			    \},
			    \{
			      description: 'should render div with node children #2',
			      template: () => createElement('div', null, createElement('span', \{ id: '123' \}, 'Hello'), createElement('span', \{ className: 'foo' \}, ' world!')),
			      result: '<div><span id="123">Hello</span><span class="foo"> world!</span></div>'
			    \},
			    \{
			      description: 'should render div with falsy children',
			      template: () => createElement('div', null, 0),
			      result: '<div>0</div>'
			    \},
			    \{
			      description: 'should render div with dangerouslySetInnerHTML',
			      template: () =>
			        createElement('div', \{
			          dangerouslySetInnerHTML: \{ __html: '<span>test</span>' \}
			        \}),
			      result: '<div><span>test</span></div>'
			    \},
			    \{
			      description: 'should render a stateless component',
			      template: (value) => createElement('div', null, createElement(FunctionalComponent, \{ value \})),
			      result: '<div><span>stateless foo!</span></div>'
			    \},
			    \{
			      description: 'should render a div with styles',
			      template: () => createElement('div', \{ style: \{ display: 'block', width: '50px' \} \}),
			      result: '<div style="display:block;width:50px;"></div>'
			    \},
			    \{
			      description: 'should ignore null className',
			      template: () => createElement('div', \{ className: null \}),
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should ignore undefined className',
			      template: () => createElement('div', \{ className: undefined \}),
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should ignore children as props',
			      template: () => createElement('p', \{\}, 'foo'),
			      result: '<p>foo</p>'
			    \}
			  ];
			
			  testEntries.forEach((test) => \{
			    it(test.description, () => \{
			      const container = document.createElement('div');
			      const vDom = test.template('foo');
			      const output = renderToStaticMarkup(vDom);
			
			      document.body.appendChild(container);
			      container.innerHTML = output;
			      expect(output).toBe(test.result);
			      document.body.removeChild(container);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\creation.spec.server.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\creation.spec.server.jsx', () => {
        const sourceCode = `
			import \{ renderToStaticMarkup, renderToString \} from 'inferno-server';
			import \{ Component, createFragment \} from 'inferno';
			import \{ createElement \} from 'inferno-create-element';
			import \{ ChildFlags \} from 'inferno-vnode-flags';
			import \{ hydrate \} from 'inferno-hydrate';
			
			function WrappedInput(props) \{
			  return <input type="text" value=\{props.value\} />;
			\}
			
			describe('SSR Creation (JSX)', () => \{
			  const testEntries = [
			    \{
			      description: 'should render a null component',
			      template: () => <div>\{null\}</div>,
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render a component with null children',
			      template: () => (
			        <div>
			          \{null\}
			          <span>emptyValue: \{null\}</span>
			        </div>
			      ),
			      result: '<div><span>emptyValue: </span></div>'
			    \},
			    \{
			      description: 'should render a component with valueless attribute',
			      template: () => <script src="foo" async />,
			      result: '<script src="foo" async></script>'
			    \},
			    \{
			      description: 'should render a stateless component with text',
			      template: () => (
			        <div>
			          Hello world, \{'1'\}2\{'3'\}
			        </div>
			      ),
			      result: '<div>Hello world, 123</div>'
			    \},
			    \{
			      description: 'should render text with escaped symbols',
			      template: () => <div>"Hello world"</div>,
			      result: '<div>&quot;Hello world&quot;</div>'
			    \},
			    \{
			      description: 'should render a stateless component with comments',
			      template: () => <div>Hello world, \{/* comment*/\}</div>,
			      result: '<div>Hello world, </div>'
			    \},
			    \{
			      description: 'should render mixed invalid/valid children',
			      template: () => <div>\{[null, '123', null, '456']\}</div>,
			      result: '<div>123456</div>'
			    \},
			    \{
			      description: 'should ignore children as props',
			      template: () => <p children="foo">foo</p>,
			      result: '<p>foo</p>'
			    \},
			    \{
			      description: 'should render input with value',
			      template: () => <input value="bar" />,
			      result: '<input value="bar">'
			    \},
			    \{
			      description: 'should render input with value when defaultValue is present',
			      template: () => <input value="bar" defaultValue="foo" />,
			      result: '<input value="bar">'
			    \},
			    \{
			      description: 'should render input when value is not present with defaultValue',
			      template: () => <input defaultValue="foo" />,
			      result: '<input value="foo">'
			    \},
			    \{
			      description: 'should render input when defaultValue is number',
			      template: () => <input defaultValue=\{123\} />,
			      result: '<input value="123">'
			    \},
			    \{
			      description: 'should render input of type text with value when input is wrapped',
			      template: () => <WrappedInput value="foo" />,
			      result: '<input type="text" value="foo">'
			    \},
			    \{
			      description: 'should render select element with selected property',
			      template: () => (
			        <select value="dog">
			          <option value="cat">A cat</option>
			          <option value="dog">A dog</option>
			        </select>
			      ),
			      result: '<select value="dog"><option value="cat">A cat</option><option value="dog" selected>A dog</option></select>'
			    \},
			    \{
			      description: 'should render a text placeholder',
			      template: () => (
			        <div>
			          <div>\{''\}</div>
			          <p>Test</p>
			        </div>
			      ),
			      result: '<div><div> </div><p>Test</p></div>'
			    \},
			    \{
			      description: 'Should render background color',
			      template: () => <div style=\{\{ 'background-color': 'red', 'border-bottom-color': 'green' \}\} />,
			      result: '<div style="background-color:red;border-bottom-color:green;"></div>'
			    \},
			    \{
			      description: 'Should not render null styles',
			      template: () => <div style=\{\{ 'background-color': null, 'border-bottom-color': null \}\} />,
			      result: '<div style=""></div>'
			    \},
			    \{
			      description: 'Should style attribute if null',
			      template: () => <div style=\{null\} />,
			      result: '<div></div>'
			    \},
			    \{
			      description: 'should render div with text child (XSS script attack) #2',
			      template: () => createElement('div', null, 'Hello world <img src="x" onerror="alert(\\'&XSS&\\')">'),
			      result: '<div>Hello world &lt;img src=&quot;x&quot; onerror=&quot;alert(&#039;&amp;XSS&amp;&#039;)&quot;&gt;</div>'
			    \},
			    \{
			      description: 'Should render style opacity #1',
			      template: () => <div style=\{\{ opacity: 0.8 \}\} />,
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render style opacity #2',
			      template: () => <div style="opacity:0.8;" />,
			      result: '<div style="opacity:0.8;"></div>'
			    \},
			    \{
			      description: 'Should render div className as number',
			      template: () => <div className=\{123\} />,
			      result: '<div class="123"></div>'
			    \},
			    \{
			      description: 'Should render input defaultValue as number',
			      template: () => <input defaultValue=\{123\} />,
			      result: '<input value="123">'
			    \},
			    \{
			      description: 'BR should not be closed',
			      template: () => (
			        <div>
			          <br />
			        </div>
			      ),
			      result: '<div><br></div>'
			    \},
			    \{
			      description: 'You should be able to render an array',
			      template: () => [<p>1</p>, <p>2</p>, <p>3</p>],
			      result: '<p>1</p><p>2</p><p>3</p>'
			    \},
			    \{
			      description: 'You should be able to render an empty array',
			      template: () => [],
			      result: '<!--!-->'
			    \},
			    \{
			      description: 'You should be able to render a fragment',
			      template: () => (
			        <>
			          <p>1</p>
			          <p>2</p>
			          <p>3</p>
			        </> /* reset syntax highlighting */
			      ),
			      result: '<p>1</p><p>2</p><p>3</p>'
			    \},
			    \{
			      description: 'You should be able to render an empty fragment',
			      template: () => <></> /* reset syntax highlighting */,
			      result: '<!--!-->'
			    \},
			    \{
			      description: 'You should be able to render fragment with single child',
			      template: () => (
			        <>
			          <p>1</p>
			        </>
			      ) /* reset syntax highlighting */,
			      result: '<p>1</p>'
			    \}
			  ];
			
			  testEntries.forEach((test) => \{
			    it(test.description, () => \{
			      const container = document.createElement('div');
			      const vDom = test.template('foo');
			      const output = renderToStaticMarkup(vDom);
			
			      document.body.appendChild(container);
			      container.innerHTML = output;
			      expect(output).toBe(test.result);
			      document.body.removeChild(container);
			    \});
			  \});
			
			  describe('Component hook', () => \{
			    it('Should allow changing state in CWM', () => \{
			      class Another extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return <div>\{this.state.foo\}</div>;
			        \}
			      \}
			
			      class Tester extends Component \{
			        constructor(props, context) \{
			          super(props, context);
			
			          this.state = \{
			            foo: 'bar'
			          \};
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            foo: 'bar2'
			          \});
			        \}
			
			        render() \{
			          return (
			            <div>
			              \{this.state.foo\}
			              <Another />
			            </div>
			          );
			        \}
			      \}
			
			      const container = document.createElement('div');
			      const vDom = <Tester />;
			
			      const output = renderToStaticMarkup(vDom);
			
			      document.body.appendChild(container);
			      container.innerHTML = output;
			      expect(output).toBe('<div>bar2<div>bar2</div></div>');
			      document.body.removeChild(container);
			    \});
			  \});
			
			  describe('Component string output', () => \{
			    it('Should render single text node', () => \{
			      class Foobar extends Component \{
			        render() \{
			          return 'foo';
			        \}
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div>foo</div>');
			    \});
			
			    it('Should render single text node using state', () => \{
			      class Foobar extends Component \{
			        render() \{
			          return this.state.text;
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            text: 'foo'
			          \});
			        \}
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div>foo</div>');
			    \});
			
			    it('Should render single (number)text node using state', () => \{
			      class Foobar extends Component \{
			        render() \{
			          return this.state.text;
			        \}
			
			        componentWillMount() \{
			          this.setState(\{
			            text: 33
			          \});
			        \}
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div>33</div>');
			    \});
			
			    it('Should render comment when component returns invalid node', () => \{
			      function Foobar() \{
			        return null;
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div><!--!--></div>');
			    \});
			
			    it('Should render single text node Class Component', () => \{
			      class Foobar extends Component \{
			        render() \{
			          return null;
			        \}
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div><!--!--></div>');
			    \});
			
			    it('Should render single text node Functional Component', () => \{
			      function Foobar() \{
			        return 'foo';
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div>foo</div>');
			    \});
			
			    it('Should render single (number)text node Functional Component', () => \{
			      function Foobar() \{
			        return 2;
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div>2</div>');
			    \});
			
			    it('Should render checked attribute for input when there is no checked in props', () => \{
			      class Foobar extends Component \{
			        render() \{
			          return <input count=\{1\} type="checkbox" defaultChecked=\{true\} />;
			        \}
			      \}
			
			      const output = renderToString(
			        <div>
			          <Foobar />
			        </div>
			      );
			
			      expect(output).toBe('<div><input count="1" type="checkbox" checked="true"></div>');
			    \});
			
			    it('Should throw error if invalid object is sent to renderToString', () => \{
			      expect(() => renderToString(\{ failure: 'guaranteed' \})).toThrow();
			      expect(() => renderToString(2)).toThrow();
			    \});
			
			    it('Should re-use Css property names from cache when its used multiple times', () => \{
			      expect(
			        renderToString(
			          <div style=\{\{ 'background-color': 'red' \}\}>
			            <div style=\{\{ 'background-color': 'red' \}\} />
			          </div>
			        )
			      ).toEqual('<div style="background-color:red;"><div style="background-color:red;"></div></div>');
			    \});
			
			    it('text nodes should match 1:1 after hydration', () => \{
			      class LinkComponent extends Component \{
			        render() \{
			          return (
			            <a target="_blank" rel="noopener noreferrer" href="https://github.com/infernojs/create-inferno-app">
			              create-inferno-app
			            </a>
			          );
			        \}
			      \}
			      const container = document.createElement('div');
			      const version = '4.0.0-21';
			      const renderedString = renderToString(
			        <div className="built">
			          Website built with Inferno \{version\} using <LinkComponent />
			        </div>
			      );
			      expect(renderedString).toEqual(
			        '<div class="built">Website built with Inferno 4.0.0-21 using <a target="_blank" rel="noopener noreferrer" href="https://github.com/infernojs/create-inferno-app">create-inferno-app</a></div>'
			      );
			
			      container.innerHTML = renderedString;
			
			      const AnchorNode = container.querySelector('a');
			      const wrapperDiv = container.firstChild;
			
			      function WrapperComponent() \{
			        return (
			          <div className="built">
			            Website built with Inferno \{version\} using <LinkComponent />
			          </div>
			        );
			      \}
			
			      hydrate(<WrapperComponent />, container);
			      expect(container.firstChild).toBe(wrapperDiv);
			      expect(wrapperDiv.childNodes.length).toBe(4);
			      expect(wrapperDiv.childNodes[0].nodeValue).toBe('Website built with Inferno ');
			      expect(wrapperDiv.childNodes[1].nodeValue).toBe('4.0.0-21');
			      expect(wrapperDiv.childNodes[2].nodeValue).toBe(' using ');
			      expect(wrapperDiv.childNodes[3]).toBe(AnchorNode);
			    \});
			
			    it('Should be possible to render Fragment #1', () => \{
			      const vNode = (
			        <div>
			          \{createFragment(
			            [<div>Lets go!</div>, null, createFragment([<div>World</div>, 'Of', <em>Fragments</em>], ChildFlags.UnknownChildren), 'text node'],
			            ChildFlags.UnknownChildren
			          )\}
			        </div>
			      );
			      const renderedString = renderToString(vNode);
			
			      expect(renderedString).toBe('<div><div>Lets go!</div><div>World</div>Of<em>Fragments</em>text node</div>');
			
			      const container = document.createElement('div');
			
			      container.innerHTML = renderedString;
			
			      const emTag = container.querySelector('em');
			
			      hydrate(vNode, container);
			
			      expect(container.innerHTML).toBe('<div><div>Lets go!</div><div>World</div>Of<em>Fragments</em>text node</div>');
			      expect(container.querySelector('em')).toBe(emTag);
			    \});
			
			    it('Should be possible to render Fragment #2', () => \{
			      class Fragmented extends Component \{
			        render() \{
			          return createFragment([<div id="m">More</div>, 'Fragments'], ChildFlags.UnknownChildren);
			        \}
			      \}
			
			      const vNode = (
			        <div>
			          \{createFragment(
			            [
			              <div>Lets go!</div>,
			              <Fragmented />,
			              null,
			              createFragment([<div>World</div>, 'Of', <em>Fragments</em>], ChildFlags.UnknownChildren),
			              'text node',
			              createFragment([null, 'Go', <em>Code</em>], ChildFlags.UnknownChildren)
			            ],
			            ChildFlags.UnknownChildren
			          )\}
			        </div>
			      );
			      const renderedString = renderToString(vNode);
			
			      expect(renderedString).toBe('<div><div>Lets go!</div><div id="m">More</div>Fragments<div>World</div>Of<em>Fragments</em>text nodeGo<em>Code</em></div>');
			
			      const container = document.createElement('div');
			
			      container.innerHTML = renderedString;
			
			      const moreDiv = container.querySelector('#m');
			      const emTag = container.querySelector('em');
			
			      hydrate(vNode, container);
			
			      expect(container.innerHTML).toBe(
			        '<div><div>Lets go!</div><div id="m">More</div>Fragments<div>World</div>Of<em>Fragments</em>text nodeGo<em>Code</em></div>'
			      );
			      expect(container.querySelector('em')).toBe(emTag);
			      expect(container.querySelector('#m')).toBe(moreDiv);
			    \});
			
			    it('Should be possible to use getDerivedStateFromProps', () => \{
			      class Test extends Component \{
			        constructor(props) \{
			          super(props);
			
			          this.state = \{
			            value: 0
			          \};
			        \}
			
			        static getDerivedStateFromProps(props, state) \{
			          return \{
			            value: state.value + 1
			          \};
			        \}
			
			        render() \{
			          return <div>\{this.state.value\}</div>;
			        \}
			      \}
			
			      expect(renderToString(<Test />)).toBe('<div>1</div>');
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\creation.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(16)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\hydration-ext.spec.server.jsx', () => {
        const sourceCode = `
			import \{ Component, createTextVNode, render \} from 'inferno';
			import \{ createContainerWithHTML \} from 'inferno-utils';
			import \{ hydrate \} from 'inferno-hydrate';
			
			class Comp extends Component \{
			  render() \{
			    return (
			      <div>
			        <div id="b1">block 1</div>
			        <div id="b2">block 2</div>
			        <div id="b3">block 3</div>
			      </div>
			    );
			  \}
			\}
			
			class InnerNested extends Component \{
			  render(\{ children \}) \{
			    return children;
			  \}
			\}
			
			function Nested(\{ children \}) \{
			  return children;
			\}
			
			class Comp2 extends Component \{
			  render() \{
			    return (
			      <div>
			        <div id="b1">C 1</div>
			        <div id="b2">C 2</div>
			        <div id="b3">C 3</div>
			      </div>
			    );
			  \}
			\}
			
			const compHtml = '<div><div id="b1">block 1</div><div id="b2">block 2</div><div id="b3">block 3</div></div>';
			const compHtml2 = '<div><div id="b1">C 1</div><div id="b2">C 2</div><div id="b3">C 3</div></div>';
			
			describe('SSR Hydration Extended - (JSX)', () => \{
			  [
			    \{
			      html: '<div><div>Hello world</div></div>',
			      component: <Comp />
			    \},
			    \{
			      html: '<div><div>Hello world</div><div>Hello world</div><div>Hello world</div><div>Hello world</div><div>Hello world</div></div>',
			      component: <Comp />
			    \},
			    \{
			      html: '<div><div><div>Hello world</div></div></div>',
			      component: <Comp />
			    \},
			    \{
			      html: '<div><div><div>Hello world</div></div><span>Hola</span></div>',
			      component: <Comp />
			    \},
			    \{
			      html: '<div><span><div>Hello world</div></span><div><div id="b1">block 1</div><div id="b2">block 2</div><div id="b3">block 3</div></div></div>',
			      component: <Comp />
			    \},
			    \{
			      html: '<div><span><div>Hello world</div></span><div><div id="b1">block 1</div><div id="b2">block 2</div><div id="b3">block 3</div></div><span>Hola</span></div>',
			      component: <Comp />
			    \},
			    \{
			      html: '<div><div></div></div>',
			      component: (
			        <InnerNested>
			          <Nested>
			            <Comp />
			          </Nested>
			        </InnerNested>
			      )
			    \}
			  ].forEach((\{ html, component \}, i) => \{
			    it(\`do test #\$\{i + 1\}\`, () => \{
			      const container = createContainerWithHTML(html);
			      hydrate(component, container);
			
			      expect(container.innerHTML).toEqual(compHtml);
			    \});
			  \});
			
			  it('Should hydrate correctly when CSR children is missing', () => \{
			    const container = createContainerWithHTML('<div> </div></div>');
			
			    hydrate(
			      <InnerNested>
			        <Nested>
			          <Comp2 />
			        </Nested>
			      </InnerNested>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual(compHtml2);
			  \});
			
			  it('Should hydrate correctly when CSR component returns null', () => \{
			    const container = createContainerWithHTML('<div></div>');
			
			    hydrate(
			      <div>
			        <Nested>
			          <InnerNested />
			        </Nested>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<div></div>');
			  \});
			
			  it('Should hydrate correctly when there are comment nodes', () => \{
			    const container = createContainerWithHTML('<div></div>');
			
			    hydrate(
			      <div>
			        <Nested>
			          <InnerNested />
			        </Nested>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<div></div>');
			  \});
			
			  it('Should hydrate correctly when there are comment nodes #2', () => \{
			    const container = createContainerWithHTML('<div></div>');
			
			    hydrate(
			      <div>
			        <Nested>
			          <InnerNested>
			            <p>Hello World!</p>
			          </InnerNested>
			        </Nested>
			      </div>,
			      container
			    );
			
			    expect(container.innerHTML).toEqual('<div><p>Hello World!</p></div>');
			  \});
			
			  it('hasTextChildren - Should handle empty textNodes correctly Github #1137', () => \{
			    const container = createContainerWithHTML('<span class="error"></span>');
			
			    const vNode = <span className="error">\{''\}</span>;
			
			    expect(vNode.children).toEqual('');
			
			    hydrate(vNode, container); // This should create empty text node
			
			    render(<span className="error">\{'Okay!'\}</span>, container);
			
			    expect(container.textContent).toBe('Okay!');
			  \});
			
			  it('hasTextChildren - Should handle empty textNodes correctly Github #1137 variation#2', () => \{
			    const container = createContainerWithHTML('<div><span class="error"></span></div>');
			
			    const vNode = (
			      <div>
			        <span className="error">\{''\}</span>
			      </div>
			    );
			
			    expect(vNode.children.children).toEqual('');
			
			    hydrate(vNode, container); // This should create empty text node
			
			    render(
			      <div>
			        <span className="error">\{'Okay!'\}</span>
			      </div>,
			      container
			    );
			
			    expect(container.textContent).toBe('Okay!');
			  \});
			
			  it('createTextVNode - Should handle empty textNodes correctly Github #1137 variation#3', () => \{
			    const container = createContainerWithHTML('<span class="error"></span>');
			
			    const vNode = <span className="error">\{createTextVNode('')\}</span>;
			
			    hydrate(vNode, container); // This should create empty text node
			
			    expect(container.firstChild.firstChild).not.toBeNull();
			
			    render(<span className="error">\{'Okay!'\}</span>, container);
			
			    expect(container.textContent).toBe('Okay!');
			  \});
			
			  it('createTextVNode - Should handle empty textNodes correctly Github #1137 variation#4', () => \{
			    const container = createContainerWithHTML('<div><span class="error"></span></div>');
			
			    const vNode = (
			      <div>
			        <span className="error">\{createTextVNode('')\}</span>
			      </div>
			    );
			
			    hydrate(vNode, container); // This should create empty text node
			
			    expect(container.firstChild.firstChild.firstChild).not.toBeNull();
			
			    render(
			      <div>
			        <span className="error">\{'Okay!'\}</span>
			      </div>,
			      container
			    );
			
			    expect(container.textContent).toBe('Okay!');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\hydration-ext.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(9)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\hydration.spec.server.js', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ renderToString \} from 'inferno-server';
			import \{ hydrate \} from 'inferno-hydrate';
			import \{ createElement \} from 'inferno-create-element';
			import \{ createContainerWithHTML, validateNodeTree \} from 'inferno-utils';
			
			describe('SSR Hydration - (non-JSX)', () => \{
			  [
			    \{
			      node: createElement('div', null, createElement('span', null, 'Hello world')),
			      expect1: '<div><span>Hello world</span></div>',
			      expect2: '<div><span>Hello world</span></div>'
			    \}
			  ].forEach((\{ node, expect1, expect2 \}, i) => \{
			    it(\`Validate various structures #\$\{i + 1\}\`, () => \{
			      const html = renderToString(node);
			      const container = createContainerWithHTML(html);
			
			      expect(container.innerHTML).toBe(expect1);
			      hydrate(node, container);
			      expect(validateNodeTree(node)).toBe(true);
			      expect(container.innerHTML).toBe(expect2);
			      render(node, container);
			      expect(container.innerHTML).toBe(expect2);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\hydration.spec.server.js')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\hydration.spec.server.jsx', () => {
        const sourceCode = `
			import \{ Component, createTextVNode, createVNode, render \} from 'inferno';
			import \{ renderToString \} from 'inferno-server';
			import \{ createContainerWithHTML, validateNodeTree \} from 'inferno-utils';
			import \{ ChildFlags, VNodeFlags \} from 'inferno-vnode-flags';
			import \{ hydrate \} from 'inferno-hydrate';
			
			function Comp1() \{
			  return <span>Worked!</span>;
			\}
			
			function Comp2() \{
			  return <em>Worked 2!</em>;
			\}
			
			class Comp3 extends Component \{
			  render() \{
			    return (
			      <em>
			        \{['Works', ' ']\}
			        <span>again</span>!
			      </em>
			    );
			  \}
			\}
			
			function Comp4(\{ children \}) \{
			  return <section>\{children\}</section>;
			\}
			
			class Comp5 extends Component \{
			  render() \{
			    return null;
			  \}
			\}
			
			class A extends Component \{
			  render() \{
			    return <span>A</span>;
			  \}
			\}
			
			class B extends Component \{
			  render() \{
			    return <span>B</span>;
			  \}
			\}
			
			describe('SSR Hydration - (JSX)', () => \{
			  [
			    \{
			      node: (
			        <div>
			          <span>Hello world</span>
			        </div>
			      ),
			      expect1: '<div><span>Hello world</span></div>',
			      expect2: '<div><span>Hello world</span></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <p>
			            Hello world
			            <sup>
			              <a>Foo</a>
			            </sup>
			          </p>
			        </div>
			      ),
			      expect1: '<div><p>Hello world<sup><a>Foo</a></sup></p></div>',
			      expect2: '<div><p>Hello world<sup><a>Foo</a></sup></p></div>'
			    \},
			    \{
			      node: <div>\{<span>Hello world</span>\}</div>,
			      expect1: '<div><span>Hello world</span></div>',
			      expect2: '<div><span>Hello world</span></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <span>\{<span>Hello world</span>\}</span>
			        </div>
			      ),
			      expect1: '<div><span><span>Hello world</span></span></div>',
			      expect2: '<div><span><span>Hello world</span></span></div>'
			    \},
			    \{
			      node: <div>Hello world</div>,
			      expect1: '<div>Hello world</div>',
			      expect2: '<div>Hello world</div>'
			    \},
			    \{
			      node: (
			        <div>
			          <svg className=\{(() => 'foo')()\} viewBox="0 0 64 64" />
			        </div>
			      ),
			      expect1: '<div><svg class="foo" viewBox="0 0 64 64"></svg></div>',
			      expect2: '<div><svg class="foo" viewBox="0 0 64 64"></svg></div>'
			    \},
			    \{
			      node: (
			        <Comp4>
			          <h1>Hello world</h1>
			          <p>
			            <em>Foo</em>
			          </p>
			          <p>Woot</p>
			          <p>
			            <em>Bar</em>
			          </p>
			        </Comp4>
			      ),
			      expect1: '<section><h1>Hello world</h1><p><em>Foo</em></p><p>Woot</p><p><em>Bar</em></p></section>',
			      expect2: '<section><h1>Hello world</h1><p><em>Foo</em></p><p>Woot</p><p><em>Bar</em></p></section>'
			    \},
			    \{
			      node: <div>Hello world, \{'Foo!'\}</div>,
			      expect1: '<div>Hello world, Foo!</div>',
			      expect2: '<div>Hello world, Foo!</div>'
			    \},
			    \{
			      node: <div>Hello world, \{['Foo!', 'Bar!']\}</div>,
			      expect1: '<div>Hello world, Foo!Bar!</div>',
			      expect2: '<div>Hello world, Foo!Bar!</div>'
			    \},
			    \{
			      node: (
			        <div>
			          Hello world!
			          \{null\}
			        </div>
			      ),
			      expect1: '<div>Hello world!</div>',
			      expect2: '<div>Hello world!</div>'
			    \},
			    \{
			      node: (
			        <div>
			          Hello world, \{'1'\}2\{'3'\}
			        </div>
			      ),
			      expect1: '<div>Hello world, 123</div>',
			      expect2: '<div>Hello world, 123</div>'
			    \},
			    \{
			      node: (
			        <div id="1">
			          <div id="2">
			            <div id="3" />
			          </div>
			        </div>
			      ),
			      expect1: '<div id="1"><div id="2"><div id="3"></div></div></div>',
			      expect2: '<div id="1"><div id="2"><div id="3"></div></div></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <Comp1 />
			        </div>
			      ),
			      expect1: '<div><span>Worked!</span></div>',
			      expect2: '<div><span>Worked!</span></div>'
			    \},
			    \{
			      node: (
			        <div className="test">
			          <Comp1 />
			        </div>
			      ),
			      expect1: '<div class="test"><span>Worked!</span></div>',
			      expect2: '<div class="test"><span>Worked!</span></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <Comp1 />
			          <Comp1 />
			          <Comp1 />
			        </div>
			      ),
			      expect1: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>',
			      expect2: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <Comp3 />
			        </div>
			      ),
			      expect1: '<div><em>Works <span>again</span>!</em></div>',
			      expect2: '<div><em>Works <span>again</span>!</em></div>'
			    \}
			  ].forEach((\{ node, expect1, expect2 \}, i) => \{
			    it(\`Validate various structures #\$\{i + 1\}\`, () => \{
			      const html = renderToString(node);
			      const container = createContainerWithHTML(html);
			
			      expect(container.innerHTML).toBe(expect1);
			      hydrate(node, container);
			      expect(validateNodeTree(node)).toBe(true);
			      expect(container.innerHTML).toBe(expect2);
			      render(node, container);
			      expect(container.innerHTML).toBe(expect2);
			    \});
			  \});
			
			  [
			    \{
			      node: <div>Hello world</div>,
			      expect1: '<div>Hello world</div>',
			      node2: <div>Hello world 2</div>,
			      expect2: '<div>Hello world 2</div>',
			      node3: <div>Hello world</div>,
			      expect3: '<div>Hello world</div>'
			    \},
			    \{
			      node: <div>Hello world, \{'Foo!'\}</div>,
			      expect1: '<div>Hello world, Foo!</div>',
			      node2: (
			        <div>
			          \{'Start'\} Hello world, \{'Foo!'\}
			        </div>
			      ),
			      expect2: '<div>Start Hello world, Foo!</div>',
			      node3: <div>Hello world, \{'Foo!'\}</div>,
			      expect3: '<div>Hello world, Foo!</div>'
			    \},
			    \{
			      node: (
			        <div>
			          Hello world, \{'1'\}2\{'3'\}
			        </div>
			      ),
			      expect1: '<div>Hello world, 123</div>',
			      node2: (
			        <div>
			          Hello world, \{'3'\}2\{'1'\}
			        </div>
			      ),
			      expect2: '<div>Hello world, 321</div>',
			      node3: (
			        <div>
			          Hello world, \{'1'\}2\{'3'\}
			        </div>
			      ),
			      expect3: '<div>Hello world, 123</div>'
			    \},
			    \{
			      node: (
			        <div id="1">
			          <div id="2">
			            <div id="3" />
			          </div>
			        </div>
			      ),
			      expect1: '<div id="1"><div id="2"><div id="3"></div></div></div>',
			      node2: (
			        <div id="3">
			          <div id="2">
			            <div id="1" />
			          </div>
			        </div>
			      ),
			      expect2: '<div id="3"><div id="2"><div id="1"></div></div></div>',
			      node3: (
			        <div id="1">
			          <div id="2">
			            <div id="3" />
			          </div>
			        </div>
			      ),
			      expect3: '<div id="1"><div id="2"><div id="3"></div></div></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <Comp1 />
			        </div>
			      ),
			      expect1: '<div><span>Worked!</span></div>',
			      node2: <div />,
			      expect2: '<div></div>',
			      node3: (
			        <div>
			          <Comp1 />
			        </div>
			      ),
			      expect3: '<div><span>Worked!</span></div>'
			    \},
			    \{
			      node: (
			        <div className="test">
			          <Comp1 />
			        </div>
			      ),
			      expect1: '<div class="test"><span>Worked!</span></div>',
			      node2: (
			        <div className="test">
			          <Comp2 />
			        </div>
			      ),
			      expect2: '<div class="test"><em>Worked 2!</em></div>',
			      node3: (
			        <div className="test">
			          <Comp1 />
			        </div>
			      ),
			      expect3: '<div class="test"><span>Worked!</span></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <Comp1 />
			          <Comp1 />
			          <Comp1 />
			        </div>
			      ),
			      expect1: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>',
			      node2: (
			        <div>
			          <Comp2 />
			          <Comp2 />
			          <Comp2 />
			        </div>
			      ),
			      expect2: '<div><em>Worked 2!</em><em>Worked 2!</em><em>Worked 2!</em></div>',
			      node3: (
			        <div>
			          <Comp1 />
			          <Comp1 />
			          <Comp1 />
			        </div>
			      ),
			      expect3: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <Comp3 />
			        </div>
			      ),
			      expect1: '<div><em>Works <span>again</span>!</em></div>',
			      node2: (
			        <div>
			          <Comp1 />
			          <Comp3 />
			        </div>
			      ),
			      expect2: '<div><span>Worked!</span><em>Works <span>again</span>!</em></div>',
			      node3: (
			        <div>
			          <Comp3 />
			        </div>
			      ),
			      expect3: '<div><em>Works <span>again</span>!</em></div>'
			    \},
			    \{
			      node: (
			        <div>
			          <Comp5 />
			        </div>
			      ),
			      expect1: '<div><!--!--></div>',
			      node2: (
			        <div>
			          <Comp5 />
			          <Comp3 />
			          <Comp5 />
			        </div>
			      ),
			      expect2: '<div><em>Works <span>again</span>!</em></div>',
			      node3: (
			        <div>
			          <Comp5 />
			        </div>
			      ),
			      expect3: '<div></div>'
			    \}
			  ].forEach((\{ node, expect1, node2, node3, expect2, expect3 \}, i) => \{
			    it(\`Update various structures #\$\{i + 1\}\`, () => \{
			      const html = renderToString(node);
			      const container = createContainerWithHTML(html);
			
			      expect(container.innerHTML).toBe(expect1);
			      hydrate(node, container);
			      expect(validateNodeTree(node)).toBe(true);
			      render(node2, container);
			      expect(validateNodeTree(node2)).toBe(true);
			      expect(container.innerHTML).toBe(expect2);
			      render(node3, container);
			      expect(validateNodeTree(node3)).toBe(true);
			      expect(container.innerHTML).toBe(expect3);
			    \});
			  \});
			
			  it('should rebuild and patch from existing DOM content', () => \{
			    const container = document.createElement('div');
			    const vNode = createVNode(VNodeFlags.HtmlElement, 'div', 'example', createTextVNode('Hello world!'), ChildFlags.HasVNodeChildren);
			
			    container.innerHTML = '<h1><div>Existing DOM content</div></h1>';
			    hydrate(vNode, container);
			    expect(container.innerHTML).toBe('<div class="example">Hello world!</div>');
			  \});
			
			  it('should rebuild and patch from existing DOM content (whitespace) ', () => \{
			    const container = document.createElement('div');
			    const vNode = createVNode(VNodeFlags.HtmlElement, 'div', 'example', createTextVNode('Hello world!'), ChildFlags.HasVNodeChildren);
			
			    container.appendChild(document.createTextNode(''));
			    container.appendChild(document.createElement('h1'));
			    container.appendChild(document.createTextNode(''));
			    hydrate(vNode, container);
			    expect(container.innerHTML).toBe('<div class="example">Hello world!</div>');
			  \});
			
			  it('should rebuild and patch from existing DOM content #2', () => \{
			    const container = document.createElement('div');
			    const vNode = createVNode(
			      VNodeFlags.HtmlElement,
			      'div',
			      'example',
			      [
			        createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('Item 1'), ChildFlags.HasVNodeChildren),
			        createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('Item 2'), ChildFlags.HasVNodeChildren)
			      ],
			      ChildFlags.HasNonKeyedChildren
			    );
			
			    container.innerHTML =
			      '<h1><div>Existing DOM content</div><div>Existing DOM content</div><div>Existing DOM content</div></h1><div>Existing DOM content</div>';
			    hydrate(vNode, container);
			    expect(container.innerHTML).toBe('<div class="example"><div>Item 1</div><div>Item 2</div></div>');
			  \});
			
			  it('should rebuild and patch from existing DOM content #3', () => \{
			    const container = document.createElement('div');
			    const vNode = createVNode(
			      VNodeFlags.HtmlElement,
			      'div',
			      'example',
			      [
			        createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('Item 1'), ChildFlags.HasVNodeChildren),
			        createVNode(VNodeFlags.HtmlElement, 'div', null, createTextVNode('Item 2'), ChildFlags.HasVNodeChildren)
			      ],
			      ChildFlags.HasNonKeyedChildren
			    );
			
			    container.innerHTML = '<div><div>Existing DOM content</div><div>Existing DOM content</div><div>Existing DOM content</div></div>';
			    hydrate(vNode, container);
			    expect(container.innerHTML).toBe('<div class="example"><div>Item 1</div><div>Item 2</div></div>');
			  \});
			
			  it('Should work with setState', () => \{
			    class Comp3 extends Component \{
			      constructor(props, context) \{
			        super(props, context);
			
			        this.state = \{
			          i: 0
			        \};
			
			        this.clicker = this.clicker.bind(this);
			      \}
			
			      componentWillMount() \{
			        this.setState(\{
			          i: ++this.state.i
			        \});
			      \}
			
			      clicker() \{
			        this.setState(\{
			          i: ++this.state.i
			        \});
			      \}
			
			      render() \{
			        return (
			          <div>
			            \{this.state.i\}
			            <span onClick=\{this.clicker\}>1</span>
			          </div>
			        );
			      \}
			    \}
			
			    const container = document.createElement('div');
			
			    document.body.appendChild(container);
			    container.innerHTML = '<div>1<span>1</span></div>';
			    hydrate(<Comp3 />, container);
			    expect(container.innerHTML).toBe('<div>1<span>1</span></div>');
			
			    container.querySelector('span').click();
			
			    expect(container.innerHTML).toBe('<div>2<span>1</span></div>');
			
			    container.querySelector('span').click();
			
			    expect(container.innerHTML).toBe('<div>3<span>1</span></div>');
			
			    document.body.removeChild(container);
			  \});
			
			  describe('Hydration SSR - CSR mismatches', () => \{
			    [
			      \{
			        SSR: (
			          <div>
			            <span>Hello world</span>
			          </div>
			        ),
			        SSR_expected: '<div><span>Hello world</span></div>',
			        CSR: (
			          <div>
			            <em>Hello world</em>
			          </div>
			        ),
			        CSR_expected: '<div><em>Hello world</em></div>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <p>
			              Hello world
			              <sup>
			                <a>Foo</a>
			              </sup>
			            </p>
			          </div>
			        ),
			        SSR_expected: '<div><p>Hello world<sup><a>Foo</a></sup></p></div>',
			        CSR: (
			          <div>
			            <p>
			              Hello bar
			              <span>
			                <em>Foo</em>
			              </span>
			            </p>
			          </div>
			        ),
			        CSR_expected: '<div><p>Hello bar<span><em>Foo</em></span></p></div>'
			      \},
			      \{
			        SSR: <div>\{<span>Hello world</span>\}</div>,
			        SSR_expected: '<div><span>Hello world</span></div>',
			        CSR: <em>\{<span>Hello 11</span>\}</em>,
			        CSR_expected: '<em><span>Hello 11</span></em>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <span>\{<span>Hello world</span>\}</span>
			          </div>
			        ),
			        SSR_expected: '<div><span><span>Hello world</span></span></div>',
			        CSR: <em>\{<span>Hello 11</span>\}</em>,
			        CSR_expected: '<em><span>Hello 11</span></em>'
			      \},
			      \{
			        SSR: <div>Hello world</div>,
			        SSR_expected: '<div>Hello world</div>',
			        CSR: (
			          <div>
			            <p>
			              Hello bar
			              <span>
			                <em>Foo</em>
			              </span>
			            </p>
			          </div>
			        ),
			        CSR_expected: '<div><p>Hello bar<span><em>Foo</em></span></p></div>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <svg className=\{(() => 'foo')()\} viewBox="0 0 64 64" />
			          </div>
			        ),
			        SSR_expected: '<div><svg class="foo" viewBox="0 0 64 64"></svg></div>',
			        CSR: (
			          <div>
			            <svg className=\{(() => 'bar1')()\} viewBox="0 0 64 11" />
			          </div>
			        ),
			        CSR_expected: '<div><svg class="bar1" viewBox="0 0 64 11"></svg></div>'
			      \},
			      \{
			        SSR: (
			          <Comp4>
			            <h1>Hello world</h1>
			            <p>
			              <em>Foo</em>
			            </p>
			            <p>Woot</p>
			            <p>
			              <em>Bar</em>
			            </p>
			          </Comp4>
			        ),
			        SSR_expected: '<section><h1>Hello world</h1><p><em>Foo</em></p><p>Woot</p><p><em>Bar</em></p></section>',
			        CSR: (
			          <Comp4>
			            <h1>Hello world again!</h1>
			            <p>
			              <em>\{[1, 2, 3]\}</em>
			            </p>
			            <p>\{null\}</p>
			            <p>
			              <em>Foo</em>
			            </p>
			          </Comp4>
			        ),
			        CSR_expected: '<section><h1>Hello world again!</h1><p><em>123</em></p><p></p><p><em>Foo</em></p></section>'
			      \},
			      \{
			        SSR: <div>Hello world, \{'Foo!'\}</div>,
			        SSR_expected: '<div>Hello world, Foo!</div>',
			        CSR: (
			          <Comp4>
			            <h1>Hello world again!</h1>
			            <p>
			              <em>\{[1, 2, 3]\}</em>
			            </p>
			            <p>\{null\}</p>
			            <p>
			              <em>Foo</em>
			            </p>
			          </Comp4>
			        ),
			        CSR_expected: '<section><h1>Hello world again!</h1><p><em>123</em></p><p></p><p><em>Foo</em></p></section>'
			      \},
			      \{
			        SSR: <div>Hello world, \{'Foo!'\}</div>,
			        SSR_expected: '<div>Hello world, Foo!</div>',
			        CSR: <div>Hello world, \{'BarBar!'\}</div>,
			        CSR_expected: '<div>Hello world, BarBar!</div>'
			      \},
			      \{
			        SSR: <div>Hello world, \{['Foo!', 'Bar!']\}</div>,
			        SSR_expected: '<div>Hello world, Foo!Bar!</div>',
			        CSR: <div>Hello world, \{['Foo!', 'Bar!']\}</div>,
			        CSR_expected: '<div>Hello world, Foo!Bar!</div>'
			      \},
			      \{
			        SSR: (
			          <div>
			            Hello world!
			            \{null\}
			          </div>
			        ),
			        SSR_expected: '<div>Hello world!</div>',
			        CSR: (
			          <div>
			            Hello world!
			            \{false\}
			          </div>
			        ),
			        CSR_expected: '<div>Hello world!</div>'
			      \},
			      \{
			        SSR: (
			          <div>
			            Hello world, \{'1'\}2\{'3'\}
			          </div>
			        ),
			        SSR_expected: '<div>Hello world, 123</div>',
			        CSR: (
			          <div>
			            Hello world, \{'1'\}2\{[3, 4, 5, [6, 7]]\}
			          </div>
			        ),
			        CSR_expected: '<div>Hello world, 1234567</div>'
			      \},
			      \{
			        SSR: (
			          <div id="1">
			            <div id="2">
			              <div id="3" />
			            </div>
			          </div>
			        ),
			        SSR_expected: '<div id="1"><div id="2"><div id="3"></div></div></div>',
			        CSR: (
			          <div id="1">
			            \{[null, false, true, undefined]\}
			            <i id="2">
			              <em>1</em>
			              <span id="3" />
			            </i>
			          </div>
			        ),
			        CSR_expected: '<div id="1"><i id="2"><em>1</em><span id="3"></span></i></div>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <Comp1 />
			          </div>
			        ),
			        SSR_expected: '<div><span>Worked!</span></div>',
			        CSR: (
			          <div id="1">
			            \{[null, false, true, undefined]\}
			            <i id="2">
			              <em>1</em>
			              <span id="3" />
			            </i>
			          </div>
			        ),
			        CSR_expected: '<div id="1"><i id="2"><em>1</em><span id="3"></span></i></div>'
			      \},
			      \{
			        SSR: (
			          <div className="test">
			            <Comp1 />
			          </div>
			        ),
			        SSR_expected: '<div class="test"><span>Worked!</span></div>',
			        CSR: (
			          <div>
			            <Comp1 />
			            <Comp1 />
			            <Comp1 />
			          </div>
			        ),
			        CSR_expected: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <Comp1 />
			            <Comp1 />
			            <Comp1 />
			          </div>
			        ),
			        SSR_expected: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>',
			        CSR: (
			          <div className="test">
			            <Comp1 />
			          </div>
			        ),
			        CSR_expected: '<div class="test"><span>Worked!</span></div>'
			      \},
			      \{
			        SSR: <div>foobar</div>,
			        SSR_expected: '<div>foobar</div>',
			        CSR: <A />,
			        CSR_expected: '<span>A</span>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <span>Hello world</span>
			          </div>
			        ),
			        SSR_expected: '<div><span>Hello world</span></div>',
			        CSR: (
			          <div>
			            <em>Hello world</em>
			          </div>
			        ),
			        CSR_expected: '<div><em>Hello world</em></div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <p>
			              Hello world
			              <sup>
			                <a>Foo</a>
			              </sup>
			            </p>
			          </div>
			        ),
			        SSR_expected: '<div><p>Hello world<sup><a>Foo</a></sup></p></div>',
			        CSR: (
			          <div>
			            <p>
			              Hello bar
			              <span>
			                <em>Foo</em>
			              </span>
			            </p>
			          </div>
			        ),
			        CSR_expected: '<div><p>Hello bar<span><em>Foo</em></span></p></div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: <div>\{<span>Hello world</span>\}</div>,
			        SSR_expected: '<div><span>Hello world</span></div>',
			        CSR: <em>\{<span>Hello 11</span>\}</em>,
			        CSR_expected: '<em><span>Hello 11</span></em>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <span>\{<span>Hello world</span>\}</span>
			          </div>
			        ),
			        SSR_expected: '<div><span><span>Hello world</span></span></div>',
			        CSR: <em>\{<span>Hello 11</span>\}</em>,
			        CSR_expected: '<em><span>Hello 11</span></em>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: <div>Hello world</div>,
			        SSR_expected: '<div>Hello world</div>',
			        CSR: (
			          <div>
			            <p>
			              Hello bar
			              <span>
			                <em>Foo</em>
			              </span>
			            </p>
			          </div>
			        ),
			        CSR_expected: '<div><p>Hello bar<span><em>Foo</em></span></p></div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <svg className=\{(() => 'foo')()\} viewBox="0 0 64 64" />
			          </div>
			        ),
			        SSR_expected: '<div><svg class="foo" viewBox="0 0 64 64"></svg></div>',
			        CSR: (
			          <div>
			            <svg className=\{(() => 'bar1')()\} viewBox="0 0 64 11" />
			          </div>
			        ),
			        CSR_expected: '<div><svg class="bar1" viewBox="0 0 64 11"></svg></div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <Comp4>
			            <h1>Hello world</h1>
			            <p>
			              <em>Foo</em>
			            </p>
			            <p>Woot</p>
			            <p>
			              <em>Bar</em>
			            </p>
			          </Comp4>
			        ),
			        SSR_expected: '<section><h1>Hello world</h1><p><em>Foo</em></p><p>Woot</p><p><em>Bar</em></p></section>',
			        CSR: (
			          <Comp4>
			            <h1>Hello world again!</h1>
			            <p>
			              <em>\{[1, 2, 3]\}</em>
			            </p>
			            <p>\{null\}</p>
			            <p>
			              <em>Foo</em>
			            </p>
			          </Comp4>
			        ),
			        CSR_expected: '<section><h1>Hello world again!</h1><p><em>123</em></p><p></p><p><em>Foo</em></p></section>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: <div>Hello world, \{'Foo!'\}</div>,
			        SSR_expected: '<div>Hello world, Foo!</div>',
			        CSR: (
			          <Comp4>
			            <h1>Hello world again!</h1>
			            <p>
			              <em>\{[1, 2, 3]\}</em>
			            </p>
			            <p>\{null\}</p>
			            <p>
			              <em>Foo</em>
			            </p>
			          </Comp4>
			        ),
			        CSR_expected: '<section><h1>Hello world again!</h1><p><em>123</em></p><p></p><p><em>Foo</em></p></section>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: <div>Hello world, \{'Foo!'\}</div>,
			        SSR_expected: '<div>Hello world, Foo!</div>',
			        CSR: <div>Hello world, \{'BarBar!'\}</div>,
			        CSR_expected: '<div>Hello world, BarBar!</div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: <div>Hello world, \{['Foo!', 'Bar!']\}</div>,
			        SSR_expected: '<div>Hello world, Foo!Bar!</div>',
			        CSR: <div>Hello world, \{['Foo!', 'Bar!']\}</div>,
			        CSR_expected: '<div>Hello world, Foo!Bar!</div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            Hello world!
			            \{null\}
			          </div>
			        ),
			        SSR_expected: '<div>Hello world!</div>',
			        CSR: (
			          <div>
			            Hello world!
			            \{false\}
			          </div>
			        ),
			        CSR_expected: '<div>Hello world!</div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            Hello world, \{'1'\}2\{'3'\}
			          </div>
			        ),
			        SSR_expected: '<div>Hello world, 123</div>',
			        CSR: (
			          <div>
			            Hello world, \{'1'\}2\{[3, 4, 5, [6, 7]]\}
			          </div>
			        ),
			        CSR_expected: '<div>Hello world, 1234567</div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div id="1">
			            <div id="2">
			              <div id="3" />
			            </div>
			          </div>
			        ),
			        SSR_expected: '<div id="1"><div id="2"><div id="3"></div></div></div>',
			        CSR: (
			          <div id="1">
			            \{[null, false, true, undefined]\}
			            <i id="2">
			              <em>1</em>
			              <span id="3" />
			            </i>
			          </div>
			        ),
			        CSR_expected: '<div id="1"><i id="2"><em>1</em><span id="3"></span></i></div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <Comp1 />
			          </div>
			        ),
			        SSR_expected: '<div><span>Worked!</span></div>',
			        CSR: (
			          <div id="1">
			            \{[null, false, true, undefined]\}
			            <i id="2">
			              <em>1</em>
			              <span id="3" />
			            </i>
			          </div>
			        ),
			        CSR_expected: '<div id="1"><i id="2"><em>1</em><span id="3"></span></i></div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div className="test">
			            <Comp1 />
			          </div>
			        ),
			        SSR_expected: '<div class="test"><span>Worked!</span></div>',
			        CSR: (
			          <div>
			            <Comp1 />
			            <Comp1 />
			            <Comp1 />
			          </div>
			        ),
			        CSR_expected: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>',
			        CSR2: <B />,
			        CSR2_expected: '<span>B</span>'
			      \},
			      \{
			        SSR: (
			          <div>
			            <Comp1 />
			            <Comp1 />
			            <Comp1 />
			          </div>
			        ),
			        SSR_expected: '<div><span>Worked!</span><span>Worked!</span><span>Worked!</span></div>',
			        CSR: (
			          <div className="test">
			            <Comp1 />
			          </div>
			        ),
			        CSR_expected: '<div class="test"><span>Worked!</span></div>',
			        CSR2: (
			          <div>
			            <B />
			          </div>
			        ),
			        CSR2_expected: '<div><span>B</span></div>'
			      \}
			    ].forEach((\{ SSR, CSR, CSR2, SSR_expected, CSR_expected, CSR2_expected \}, i) => \{
			      it(\`Validate various structures #\$\{i + 1\}\`, () => \{
			        const ssrString = renderToString(SSR);
			        const SsrContainer = createContainerWithHTML(ssrString);
			
			        expect(SsrContainer.innerHTML).toBe(SSR_expected);
			        hydrate(CSR, SsrContainer);
			
			        if (CSR2) \{
			          // Do some repeating here to verify vNodes are correctly set
			          render(CSR2, SsrContainer); // patch 2
			          expect(SsrContainer.innerHTML).toBe(CSR2_expected);
			          render(CSR2, SsrContainer); // patch 2
			          expect(SsrContainer.innerHTML).toBe(CSR2_expected);
			          render(CSR, SsrContainer); // patch 1
			          expect(SsrContainer.innerHTML).toBe(CSR_expected);
			          render(CSR2, SsrContainer); // patch 2
			          expect(SsrContainer.innerHTML).toBe(CSR2_expected);
			        \} else \{
			          expect(SsrContainer.innerHTML).toBe(CSR_expected);
			          render(CSR, SsrContainer); // patch 1
			          expect(SsrContainer.innerHTML).toBe(CSR_expected);
			        \}
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\hydration.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(8)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\loaderOnRoute.spec.server.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ renderToString \} from 'inferno-server';
			import \{ BrowserRouter, StaticRouter, Route, useLoaderData, resolveLoaders, traverseLoaders \} from 'inferno-router';
			
			describe('Resolve loaders during server side rendering', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			    // Reset history to root
			    history.replaceState(undefined, undefined, '/');
			  \});
			
			  it('SSR renders same result as browser', async () => \{
			    const TEXT = 'bubblegum';
			    const Component = (props, \{ router \}) => \{
			      const res = useLoaderData(props);
			      return <h1>\{res?.message\}</h1>;
			    \};
			
			    const loaderFuncNoHit = async () => \{
			      return \{ message: 'no' \};
			    \};
			    const loaderFunc = async () => \{
			      return \{ message: TEXT \};
			    \};
			
			    const routes = [
			      <Route path="/flowers" render=\{Component\} loader=\{loaderFuncNoHit\} />,
			      <Route path="/birds" render=\{Component\} loader=\{loaderFunc\} />,
			      <Route path="/bees" render=\{Component\} loader=\{loaderFuncNoHit\} />
			    ];
			
			    const loaderEntries = traverseLoaders('/birds', routes);
			    const initialData = await resolveLoaders(loaderEntries);
			
			    // Render on server
			    const html = renderToString(
			      <StaticRouter location="/birds" initialData=\{initialData\}>
			        \{routes\}
			      </StaticRouter>
			    );
			
			    // Render in browser
			    history.replaceState(undefined, undefined, '/birds');
			    render(<BrowserRouter initialData=\{initialData\}>\{routes\}</BrowserRouter>, container);
			
			    expect(\`<!--!-->\$\{container.innerHTML\}<!--!-->\`).toEqual(html);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\loaderOnRoute.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\observer.spec.server.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ observer, useStaticRendering \} from 'inferno-mobx';
			import \{ renderToStaticMarkup \} from 'inferno-server';
			import \{ getObserverTree, observable \} from 'mobx';
			
			describe('Mobx Observer Server', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  it('does not views alive when using static + string rendering', function () \{
			    useStaticRendering(true);
			
			    let renderCount = 0;
			    const data = observable(\{
			      z: 'hi'
			    \});
			
			    const TestComponent = observer(function testComponent() \{
			      renderCount++;
			      return <div>\{data.z\}</div>;
			    \});
			
			    const output = renderToStaticMarkup(<TestComponent />);
			
			    data.z = 'hello';
			
			    expect(output).toBe('<div>hi</div>');
			    expect(renderCount).toBe(1);
			
			    expect(getObserverTree(data, 'z').observers).not.toBeDefined();
			
			    useStaticRendering(false);
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\observer.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\props-context.spec.server.jsx', () => {
        const sourceCode = `
			import \{ renderToStaticMarkup \} from 'inferno-server';
			import \{ Component \} from 'inferno';
			
			describe('SSR render() arguments', () => \{
			  class TestProvider extends Component \{
			    getChildContext() \{
			      return \{ testContext: 'context-works' \};
			    \}
			    render(\{ children \}) \{
			      return children;
			    \}
			  \}
			
			  it('should have props as 1st argument', () => \{
			    class TestChild extends Component \{
			      render(props) \{
			        return <p>\{props.testProps\}</p>;
			      \}
			    \}
			
			    const output = renderToStaticMarkup(<TestChild testProps="props-works" />);
			    expect(output).toBe('<p>props-works</p>');
			  \});
			
			  it('should have state as 2nd argument', () => \{
			    class TestChild extends Component \{
			      constructor() \{
			        super();
			        this.state = \{ testState: 'state-works' \};
			      \}
			      render(props, state) \{
			        return <p>\{state.testState\}</p>;
			      \}
			    \}
			    const output = renderToStaticMarkup(<TestChild />);
			    expect(output).toBe('<p>state-works</p>');
			  \});
			
			  it('statefull has context as 3rd argument', () => \{
			    class TestChild extends Component \{
			      render(props, state, context) \{
			        return <p>\{context.testContext\}</p>;
			      \}
			    \}
			
			    const output = renderToStaticMarkup(
			      <TestProvider>
			        <TestChild />
			      </TestProvider>
			    );
			    expect(output).toBe('<p>context-works</p>');
			  \});
			
			  it('stateless has context as 2nd argument', () => \{
			    function TestChild(props, context) \{
			      return <p>\{context.testContext\}</p>;
			    \}
			
			    const output = renderToStaticMarkup(
			      <TestProvider>
			        <TestChild />
			      </TestProvider>
			    );
			    expect(output).toBe('<p>context-works</p>');
			  \});
			
			  it('nested stateless has context as 2nd argument', () => \{
			    function ChildWrapper(props, context) \{
			      return props.children;
			    \}
			    function TestChild(props, context) \{
			      return <p>\{context.testContext\}</p>;
			    \}
			    const output = renderToStaticMarkup(
			      <TestProvider>
			        <ChildWrapper>
			          <ChildWrapper>
			            <TestChild />
			          </ChildWrapper>
			        </ChildWrapper>
			      </TestProvider>
			    );
			    expect(output).toBe('<p>context-works</p>');
			  \});
			
			  it('nested providers should have merged context', () => \{
			    class TestContext extends Component \{
			      getChildContext() \{
			        return \{ testContextWrap: 'context-wrap-works' \};
			      \}
			      render(\{ children \}) \{
			        return children;
			      \}
			    \}
			    function TestChild(props, context) \{
			      return (
			        <p>
			          \{context.testContext\}|\{context.testContextWrap\}
			        </p>
			      );
			    \}
			    const output = renderToStaticMarkup(
			      <TestProvider>
			        <TestContext>
			          <TestChild />
			        </TestContext>
			      </TestProvider>
			    );
			    expect(output).toBe('<p>context-works|context-wrap-works</p>');
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\props-context.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\security.spec.server.jsx', () => {
        const sourceCode = `
			import \{ createElement \} from 'inferno-create-element';
			import \{ renderToString, streamAsString, streamQueueAsString \} from 'inferno-server';
			import concatStream from 'concat-stream-es6';
			
			describe('Security - SSR', () => \{
			  describe('renderToString', () => \{
			    it('Should not render invalid tagNames', () => \{
			      expect(() => renderToString(createElement('div'))).not.toThrow();
			      expect(() => renderToString(createElement('x-💩'))).not.toThrow();
			      expect(() => renderToString(createElement('a b'))).toThrow(/<a b>/);
			      expect(() => renderToString(createElement('a\\0b'))).toThrow(/<a\\0b>/);
			      expect(() => renderToString(createElement('a>'))).toThrow(/<a>>/);
			      expect(() => renderToString(createElement('<'))).toThrow(/<<>/);
			      expect(() => renderToString(createElement('"'))).toThrow(/<">/);
			    \});
			
			    it('Should not render invalid attribute names', () => \{
			      const props = \{\};
			      const userProvidedData = '></div><script>alert("hi")</script>';
			
			      props[userProvidedData] = 'hello';
			
			      let html = renderToString(<div \{...props\} />);
			
			      expect(html).toBe('<div></div>');
			    \});
			
			    it('should reject attribute key injection attack on markup', () => \{
			      const element1 = createElement('div', \{ 'blah" onclick="beevil" noise="hi': 'selected' \}, null);
			      const element2 = createElement('div', \{ '></div><script>alert("hi")</script>': 'selected' \}, null);
			      let result1 = renderToString(element1);
			      let result2 = renderToString(element2);
			      expect(result1.toLowerCase()).not.toContain('onclick');
			      expect(result2.toLowerCase()).not.toContain('script');
			    \});
			  \});
			
			  describe('streams', () => \{
			    [streamAsString, streamQueueAsString].forEach((method) => \{
			      it('Should not render invalid attribute names', () => \{
			        const props = \{\};
			        const userProvidedData = '></div><script>alert("hi")</script>';
			
			        props[userProvidedData] = 'hello';
			
			        streamPromise(<div \{...props\} />, method).then((html) => expect(html).toBe('<div></div>'));
			      \});
			
			      it('should reject attribute key injection attack on markup', (done) => \{
			        const element1 = createElement('div', \{ 'blah" onclick="beevil" noise="hi': 'selected' \}, null);
			        streamPromise(element1, method).then((result1) => \{
			          expect(result1.toLowerCase()).not.toContain('onclick');
			          done();
			        \});
			      \});
			
			      it('should reject attribute key injection attack on markup #2', (done) => \{
			        const element2 = createElement('div', \{ '></div><script>alert("hi")</script>': 'selected' \}, null);
			        streamPromise(element2, method).then((result2) => \{
			          expect(result2.toLowerCase()).not.toContain('script');
			          done();
			        \});
			      \});
			    \});
			  \});
			\});
			
			function streamPromise(dom, method) \{
			  return new Promise(function (res, rej) \{
			    method(dom)
			      .on('error', rej)
			      .pipe(
			        concatStream(function (buffer) \{
			          res(buffer.toString('utf-8'));
			        \})
			      );
			  \});
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\security.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(6)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\ssr-forwardref.spec.tsx', () => {
        const sourceCode = `
			import \{ Component, createRef, forwardRef, RefObject, render \} from 'inferno';
			import \{ renderToString, streamAsString, streamQueueAsString \} from 'inferno-server';
			import \{ hydrate \} from 'inferno-hydrate';
			import \{ isString \} from 'inferno-shared';
			import concatStream from 'concat-stream-es6';
			
			describe('SSR -> Hydrate - Forward Ref', () => \{
			  let container;
			
			  beforeEach(function () \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(function () \{
			    render(null, container);
			    container.innerHTML = '';
			    document.body.removeChild(container);
			  \});
			
			  function SSRtoString(method, vNode, callback) \{
			    const val = method(vNode);
			
			    if (isString(val)) \{
			      callback(val);
			    \} else \{
			      val.pipe(
			        concatStream(function (buffer) \{
			          callback(buffer.toString('utf-8'));
			        \})
			      );
			    \}
			  \}
			
			  [renderToString, streamAsString, streamQueueAsString].forEach(function (method) \{
			    it('Should be possible to forward createRef', (done) => \{
			      const FancyButton = forwardRef((props, ref) => (
			        <button ref=\{ref\} className="FancyButton">
			          \{props.children\}
			        </button>
			      ));
			
			      expect(FancyButton.render).toBeDefined();
			
			      class Hello extends Component<any, any> \{
			        private readonly btn: RefObject<any>;
			
			        constructor(props) \{
			          super(props);
			
			          // You can now get a ref directly to the DOM button:
			          this.btn = createRef();
			        \}
			
			        public componentDidMount() \{
			          expect(this.btn.current).toBe(container.querySelector('button'));
			        \}
			
			        public render() \{
			          return <FancyButton ref=\{this.btn\}>Click me!</FancyButton>;
			        \}
			      \}
			
			      SSRtoString(method, <Hello />, function (htmlString) \{
			        expect(htmlString).toBe('<button class="FancyButton">Click me!</button>');
			
			        container.innerHTML = htmlString;
			
			        renderToString(<Hello />);
			
			        expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			
			        hydrate(<Hello />, container);
			
			        expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			
			        done();
			      \});
			    \});
			
			    it('Should be possible to forward callback ref', (done) => \{
			      const FancyButton = forwardRef((props, ref) => (
			        <button ref=\{ref\} className="FancyButton">
			          \{props.children\}
			        </button>
			      ));
			
			      expect(FancyButton.render).toBeDefined();
			
			      class Hello extends Component \{
			        public render() \{
			          return (
			            <FancyButton
			              ref=\{(btn) => \{
			                if (btn) \{
			                  expect(btn).toBe(container.querySelector('button'));
			                \}
			              \}\}
			            >
			              Click me!
			            </FancyButton>
			          );
			        \}
			      \}
			
			      SSRtoString(method, <Hello />, function (htmlString) \{
			        container.innerHTML = htmlString;
			
			        expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			
			        hydrate(<Hello />, container);
			
			        expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			
			        render(null, container);
			
			        expect(container.innerHTML).toBe('');
			
			        done();
			      \});
			    \});
			
			    it('Should be possible to patch forwardRef component', () => \{
			      const FancyButton = forwardRef((props, ref) => \{
			        return (
			          <button ref=\{ref\} className="FancyButton">
			            \{props.children\}
			          </button>
			        );
			      \});
			
			      expect(FancyButton.render).toBeDefined();
			
			      SSRtoString(method, <FancyButton />, function (htmlString) \{
			        let firstVal: Element | null = null;
			
			        container.innerHTML = htmlString;
			
			        hydrate(
			          <FancyButton
			            ref=\{(btn) => \{
			              firstVal = btn;
			            \}\}
			          >
			            Click me!
			          </FancyButton>,
			          container
			        );
			
			        expect(container.innerHTML).toBe('<button class="FancyButton">Click me!</button>');
			        expect(firstVal).not.toBe(null);
			
			        let secondVal: Element | null = null;
			
			        render(
			          <FancyButton
			            ref=\{(btn) => \{
			              secondVal = btn;
			            \}\}
			          >
			            Click me! 222
			          </FancyButton>,
			          container
			        );
			
			        expect(firstVal).toBe(null);
			        expect(secondVal).not.toBe(null);
			
			        expect(container.innerHTML).toBe('<button class="FancyButton">Click me! 222</button>');
			      \});
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\ssr-forwardref.spec.tsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\StaticRouter.spec.server-nodom.jsx', () => {
        const sourceCode = `
			import \{ renderToStaticMarkup \} from 'inferno-server';
			import \{ Prompt, Redirect, Route, StaticRouter \} from 'inferno-router';
			
			describe('A <StaticRouter>', () => \{
			  it('provides context.router.staticContext in props.staticContext', () => \{
			    const ContextChecker = (props, reactContext) => \{
			      expect(typeof reactContext.router).toBe('object');
			      expect(reactContext.router.staticContext).toBe(props.staticContext);
			      return null;
			    \};
			
			    ContextChecker.contextTypes = \{
			      router: () => \{\}
			    \};
			
			    const context = \{\};
			
			    renderToStaticMarkup(
			      <StaticRouter context=\{context\}>
			        <Route component=\{ContextChecker\} />
			      </StaticRouter>
			    );
			  \});
			
			  it('context.router.staticContext persists inside of a <Route>', () => \{
			    const ContextChecker = (props, reactContext) => \{
			      expect(typeof reactContext.router).toBe('object');
			      expect(reactContext.router.staticContext).toBe(context);
			      return null;
			    \};
			
			    ContextChecker.contextTypes = \{
			      router: () => \{\}
			    \};
			
			    const context = \{\};
			
			    renderToStaticMarkup(
			      <StaticRouter context=\{context\}>
			        <Route component=\{ContextChecker\} />
			      </StaticRouter>
			    );
			  \});
			
			  it('provides context.router.history', () => \{
			    const ContextChecker = (props, reactContext) => \{
			      expect(typeof reactContext.router.history).toBe('object');
			      return null;
			    \};
			
			    ContextChecker.contextTypes = \{
			      router: () => \{\}
			    \};
			
			    const context = \{\};
			
			    renderToStaticMarkup(
			      <StaticRouter context=\{context\}>
			        <ContextChecker />
			      </StaticRouter>
			    );
			  \});
			
			  it('warns when passed a history prop', () => \{
			    const context = \{\};
			    const history = \{\};
			
			    spyOn(console, 'error');
			
			    renderToStaticMarkup(<StaticRouter context=\{context\} history=\{history\} />);
			
			    expect(console.error).toHaveBeenCalledTimes(1);
			    expect(console.error.calls.argsFor(0)[0]).toContain('<StaticRouter> ignores the history prop');
			    // expect(console.error).toHaveBeenCalledWith(
			    //   expect.stringContaining('<StaticRouter> ignores the history prop')
			    // )
			  \});
			
			  it('reports PUSH actions on the context object', () => \{
			    const context = \{\};
			
			    renderToStaticMarkup(
			      <StaticRouter context=\{context\}>
			        <Redirect push to="/somewhere-else" />
			      </StaticRouter>
			    );
			
			    expect(context.action).toBe('PUSH');
			    expect(context.url).toBe('/somewhere-else');
			  \});
			
			  it('reports REPLACE actions on the context object', () => \{
			    const context = \{\};
			
			    renderToStaticMarkup(
			      <StaticRouter context=\{context\}>
			        <Redirect to="/somewhere-else" />
			      </StaticRouter>
			    );
			
			    expect(context.action).toBe('REPLACE');
			    expect(context.url).toBe('/somewhere-else');
			  \});
			
			  it('knows how to serialize location objects', () => \{
			    const context = \{\};
			
			    renderToStaticMarkup(
			      <StaticRouter context=\{context\}>
			        <Redirect to=\{\{ pathname: '/somewhere-else' \}\} />
			      </StaticRouter>
			    );
			
			    //expect(context.action).toBe('REPLACE')
			    //expect(context.location.pathname).toBe('/somewhere-else')
			    //expect(context.location.search).toBeFalsy()
			    //expect(context.location.hash).toBeFalsy()
			    //expect(context.url).toBe('/somewhere-else')
			    expect(context).toEqual(\{
			      action: 'REPLACE',
			      url: '/somewhere-else',
			      location: \{
			        pathname: '/somewhere-else',
			        search: undefined,
			        hash: undefined
			      \}
			    \});
			  \});
			
			  it('knows how to parse raw URLs', () => \{
			    const LocationChecker = (props) => \{
			      expect(props.location).toEqual(\{
			        pathname: '/the/path',
			        search: '?the=query',
			        hash: '#the-hash'
			      \});
			      return null;
			    \};
			
			    const context = \{\};
			
			    renderToStaticMarkup(
			      <StaticRouter context=\{context\} location="/the/path?the=query#the-hash">
			        <Route component=\{LocationChecker\} />
			      </StaticRouter>
			    );
			  \});
			
			  describe('with a basename', () => \{
			    it('strips the basename from location pathnames', () => \{
			      const LocationChecker = (props) => \{
			        expect(props.location.pathname).toBe('/path');
			        return null;
			      \};
			
			      const context = \{\};
			
			      renderToStaticMarkup(
			        <StaticRouter context=\{context\} basename="/the-base" location="/the-base/path">
			          <Route component=\{LocationChecker\} />
			        </StaticRouter>
			      );
			    \});
			
			    it('reports PUSH actions on the context object', () => \{
			      const context = \{\};
			
			      renderToStaticMarkup(
			        <StaticRouter context=\{context\} basename="/the-base">
			          <Redirect push to="/somewhere-else" />
			        </StaticRouter>
			      );
			
			      expect(context.action).toBe('PUSH');
			      expect(context.url).toBe('/the-base/somewhere-else');
			    \});
			
			    it('reports REPLACE actions on the context object', () => \{
			      const context = \{\};
			
			      renderToStaticMarkup(
			        <StaticRouter context=\{context\} basename="/the-base">
			          <Redirect to="/somewhere-else" />
			        </StaticRouter>
			      );
			
			      expect(context.action).toBe('REPLACE');
			      expect(context.url).toBe('/the-base/somewhere-else');
			    \});
			  \});
			
			  describe('no basename', () => \{
			    it('createHref does not append extra leading slash', () => \{
			      const context = \{\};
			      const pathname = '/test-path-please-ignore';
			
			      const Link = (\{ to, children \}) => <Route children=\{(\{ history: \{ createHref \} \}) => <a href=\{createHref(to)\}>\{children\}</a>\} />;
			
			      const outp = renderToStaticMarkup(
			        <StaticRouter context=\{context\}>
			          <Link to=\{pathname\} />
			        </StaticRouter>
			      );
			
			      expect(outp).toEqual(\`<a href="\$\{pathname\}"></a>\`);
			    \});
			  \});
			
			  describe('render a <Prompt>', () => \{
			    it('does nothing', () => \{
			      const context = \{\};
			
			      expect(() => \{
			        renderToStaticMarkup(
			          <StaticRouter context=\{context\}>
			            <Prompt message="this is only a test" />
			          </StaticRouter>
			        );
			      \}).not.toThrow();
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\StaticRouter.spec.server-nodom.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(13)
    });
    it('infernojs_inferno\\packages\\inferno-server\\__tests__\\utils.spec.server.jsx', () => {
        const sourceCode = `
			import \{ render \} from 'inferno';
			import \{ renderToString \} from 'inferno-server';
			import \{ createContainerWithHTML, validateNodeTree \} from 'inferno-utils';
			
			describe('Utils - SSR', () => \{
			  describe('validateNodeTree', () => \{
			    it('should return true on a valid node tree', () => \{
			      const node = (
			        <div>
			          <span>Hello world</span>
			        </div>
			      );
			      const html = renderToString(node);
			      const container = createContainerWithHTML(html);
			      render(node, container);
			      expect(validateNodeTree(node)).toBe(true);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-server\\__tests__\\utils.spec.server.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(1)
    });
    it('infernojs_inferno\\packages\\inferno-test-utils\\__tests__\\snapshots.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, createFragment, Fragment \} from 'inferno';
			import \{ renderToSnapshot \} from 'inferno-test-utils';
			import \{ ChildFlags \} from 'inferno-vnode-flags';
			
			if (window.usingJest) \{
			  describe('Snapshots', () => \{
			    class Foobar extends Component \{
			      render(\{ children \}) \{
			        return <div className="Testing">\{children\}</div>;
			      \}
			    \}
			
			    function Testing(\{ children \}) \{
			      return (
			        <span>
			          \{children\}
			          Extra
			        </span>
			      );
			    \}
			
			    describe('JSX', () => \{
			      it('Should render attributes and className', () => \{
			        expect(renderToSnapshot(<Foobar />)).toMatchSnapshot();
			      \});
			
			      it('Should render component children', () => \{
			        expect(
			          renderToSnapshot(
			            <Foobar>
			              <div className="ok">ABC</div>
			            </Foobar>
			          )
			        ).toMatchSnapshot();
			      \});
			
			      it('Should render html element', () => \{
			        expect(
			          renderToSnapshot(
			            <a onClick=\{() => \{\}\} aria-colspan="3" className="foo">
			              Bar
			            </a>
			          )
			        ).toMatchSnapshot();
			      \});
			
			      it('Should render multiple elements', () => \{
			        expect(
			          renderToSnapshot(
			            <Testing>
			              <a>T</a>
			              <span className="foo">est</span>
			              12
			            </Testing>
			          )
			        ).toMatchSnapshot();
			      \});
			
			      it('Should render deeper component', () => \{
			        class ComP extends Component \{
			          render() \{
			            return (
			              <div>
			                Okay
			                \{this.props.children\}
			                <span className="yea" />
			              </div>
			            );
			          \}
			        \}
			
			        expect(
			          renderToSnapshot(
			            <div className="okay" aria-rowindex=\{1\} onClick=\{() => console.log\}>
			              <ComP>
			                <div>
			                  <ul>
			                    <li>Okay</li>
			                  </ul>
			                </div>
			              </ComP>
			            </div>
			          )
			        ).toMatchSnapshot();
			      \});
			
			      it('Should render fragment', () => \{
			        const fragmentA = createFragment([<div id="a1">A1</div>, <div>A2</div>], ChildFlags.HasNonKeyedChildren, 'A');
			
			        const fragmentB = createFragment([<div id="b1">B1</div>], ChildFlags.HasNonKeyedChildren, 'B');
			
			        const fragmentC = createFragment([<div id="c1">C1</div>, <div>C2</div>, <div>C3</div>], ChildFlags.HasNonKeyedChildren, 'C');
			
			        expect(
			          renderToSnapshot(
			            <div>
			              \{fragmentA\}
			              \{fragmentB\}
			              \{fragmentC\}
			            </div>
			          )
			        ).toMatchSnapshot();
			      \});
			
			      it('Should render fragment root', () => \{
			        expect(
			          renderToSnapshot(
			            <Fragment>
			              <div>First</div>
			              <div>Second</div>
			            </Fragment>
			          )
			        ).toMatchSnapshot();
			      \});
			
			      it('Should render fragment from component root', () => \{
			        class Comp extends Component \{
			          render() \{
			            return <>\{this.props.children\}</>;
			          \}
			        \}
			
			        expect(
			          renderToSnapshot(
			            <Comp>
			              <div>1</div>
			            </Comp>
			          )
			        ).toMatchSnapshot();
			      \});
			
			      it('Should not fail when returning children array from component root, which contains text node. Github #1404', () => \{
			        const Label = (\{ label, htmlFor, children, optional = false, ...props \}) => \{
			          if (optional && !label) \{
			            return children;
			          \}
			          return (
			            <>
			              <label \{...props\} htmlFor=\{htmlFor\}>
			                \{label\}
			              </label>
			              \{children\}
			            </>
			          );
			        \};
			        expect(renderToSnapshot(<Label>\{[<span>o</span>, <span>k</span>, 'asd', 1, null, false, true, void 0]\}</Label>)).toMatchSnapshot();
			      \});
			
			      it('Should not fail when returning children array from component root, Github #1404', () => \{
			        const Label = (\{ label, htmlFor, children, optional = false, ...props \}) => \{
			          if (optional && !label) \{
			            return children;
			          \}
			
			          return (
			            <>
			              <label \{...props\} htmlFor=\{htmlFor\}>
			                \{label\}
			              </label>
			              \{children\}
			            </>
			          );
			        \};
			
			        expect(renderToSnapshot(<Label>\{[<span>o</span>, <span>k</span>]\}</Label>)).toMatchSnapshot();
			      \});
			
			      it('Should flush setStates before building snapshot', () => \{
			        class App extends Component \{
			          constructor(props) \{
			            super(props);
			
			            this.state = \{
			              foo: ''
			            \};
			          \}
			
			          componentDidMount() \{
			            this.setState(\{
			              foo: '##BAR##'
			            \});
			          \}
			
			          render() \{
			            return (
			              <div className="App">
			                <header className="App-header">
			                  <img src="logo" className="App-logo" alt="logo" />
			                  <p>
			                    Edit <code>src/App.js</code> and save to reload.
			                  </p>
			                  <a className="App-link" href="https://reactjs.org" target="_blank" rel="noopener noreferrer">
			                    \{this.state.foo\}
			                  </a>
			                </header>
			              </div>
			            );
			          \}
			        \}
			
			        expect(renderToSnapshot(<App />)).toMatchSnapshot();
			      \});
			    \});
			  \});
			\}
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-test-utils\\__tests__\\snapshots.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(11)
    });
    it('infernojs_inferno\\packages\\inferno-test-utils\\__tests__\\testUtils.jest.spec.jsx', () => {
        const sourceCode = `
			import \{ createElement \} from 'inferno-create-element';
			import * as TestUtils from 'inferno-test-utils';
			
			const FunctionalComponent = function (props) \{
			  return createElement('div', props);
			\};
			
			const usingJest = window.usingJest;
			
			describe('renderToSnapshot', () => \{
			  it('should return a snapshot from a valid vNode', () => \{
			    const snapshot = TestUtils.renderToSnapshot(<FunctionalComponent foo="bar" />);
			
			    if (usingJest) \{
			      expect(snapshot).toMatchSnapshot();
			    \} else \{
			      expect(snapshot.props.foo).toBeDefined();
			      expect(snapshot.props.foo).toBe('bar');
			    \}
			  \});
			
			  it('should return a snapshot with className prop', () => \{
			    const TestComponent = () => <div className="test">Test</div>;
			
			    const snapshot = TestUtils.renderToSnapshot(<TestComponent />);
			
			    if (usingJest) \{
			      expect(snapshot).toMatchSnapshot();
			    \} else \{
			      expect(snapshot.props.className).toBe('test');
			    \}
			  \});
			
			  it('should return a snapshot with className prop, multiple children', () => \{
			    const TestComponent = (props) => (
			      <div className="test">
			        \{props.children\}
			        <span>1</span>
			      </div>
			    );
			
			    const snapshot = TestUtils.renderToSnapshot(<TestComponent>\{[<span>a</span>, <span>b</span>]\}</TestComponent>);
			
			    if (usingJest) \{
			      expect(snapshot).toMatchSnapshot();
			    \} else \{
			      expect(snapshot.props.className).toBe('test');
			    \}
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-test-utils\\__tests__\\testUtils.jest.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(3)
    });
    it('infernojs_inferno\\packages\\inferno-test-utils\\__tests__\\testUtils.spec.jsx', () => {
        const sourceCode = `
			import \{ Component, render \} from 'inferno';
			import \{ createClass \} from 'inferno-create-class';
			import \{ createElement \} from 'inferno-create-element';
			import \{
			  findAllInRenderedTree,
			  findAllInVNodeTree,
			  findRenderedDOMElementWithClass,
			  findRenderedDOMElementWithTag,
			  findRenderedVNodeWithType,
			  findVNodeWithType,
			  isClassVNode,
			  isClassVNodeOfType,
			  isComponentVNodeOfType,
			  isDOMElement,
			  isDOMElementOfType,
			  isDOMVNode,
			  isDOMVNodeOfType,
			  isFunctionalVNode,
			  isFunctionalVNodeOfType,
			  isRenderedClassComponent,
			  isRenderedClassComponentOfType,
			  isVNode,
			  isVNodeOfType,
			  renderIntoContainer,
			  scryRenderedDOMElementsWithClass,
			  scryRenderedDOMElementsWithTag,
			  scryRenderedVNodesWithType,
			  scryVNodesWithType
			\} from 'inferno-test-utils';
			
			const VNodeKeys = ['children', 'childFlags', 'className', 'dom', 'flags', 'isValidated', 'key', 'ref', 'props', 'type'].sort();
			
			const createDOMElement = (tagName) => document.createElement(tagName);
			
			const FunctionalComponent = function (props) \{
			  return createElement('div', props);
			\};
			
			const AnotherFunctionalComponent = function (props) \{
			  return createElement('div', props);
			\};
			
			const CreateClassComponent = createClass(\{
			  render() \{
			    return createElement('div', this.props);
			  \}
			\});
			
			const AnotherCreateClassComponent = createClass(\{
			  render() \{
			    return createElement('div', this.props);
			  \}
			\});
			
			class ExtendClassComponent extends Component \{
			  render() \{
			    return createElement('div', this.props);
			  \}
			\}
			
			class AnotherExtendClassComponent extends Component \{
			  render() \{
			    return createElement('div', this.props);
			  \}
			\}
			
			describe('Test Utils', () => \{
			  let container;
			
			  beforeEach(() => \{
			    container = document.createElement('div');
			    document.body.appendChild(container);
			  \});
			
			  afterEach(() => \{
			    render(null, container);
			    container.innerHTML = '';
			  \});
			
			  describe('isVNode', () => \{
			    it('should return true for VNodes', () => \{
			      expect(isVNode(createElement('div'))).toBe(true);
			      expect(isVNode(createElement(CreateClassComponent))).toBe(true);
			      expect(isVNode(createElement(ExtendClassComponent))).toBe(true);
			      expect(isVNode(createElement(FunctionalComponent))).toBe(true);
			      expect(isVNode(<CreateClassComponent />)).toBe(true);
			      expect(isVNode(<ExtendClassComponent />)).toBe(true);
			      expect(isVNode(<FunctionalComponent />)).toBe(true);
			      expect(isVNode(<div />)).toBe(true);
			    \});
			
			    it('should return false for non-VNodes', () => \{
			      expect(isVNode(CreateClassComponent)).toBe(false);
			      expect(isVNode(ExtendClassComponent)).toBe(false);
			      expect(isVNode(FunctionalComponent)).toBe(false);
			      expect(isVNode(createDOMElement('div'))).toBe(false);
			      expect(isVNode('foo')).toBe(false);
			      expect(isVNode(\{\})).toBe(false);
			      expect(isVNode([])).toBe(false);
			      expect(isVNode(10)).toBe(false);
			      expect(isVNode(undefined)).toBe(false);
			      expect(isVNode(null)).toBe(false);
			    \});
			  \});
			
			  describe('isComponentVNodeOfType', () => \{
			    it('Should return true if Component is same', () => \{
			      class Foobar extends Component \{
			        render() \{
			          return <div>1</div>;
			        \}
			      \}
			
			      expect(isComponentVNodeOfType(<Foobar />, Foobar)).toBe(true);
			      expect(isComponentVNodeOfType(<div />, Foobar)).toBe(false);
			    \});
			  \});
			
			  describe('isVNodeOfType', () => \{
			    it('should return true for VNodes with a specified type', () => \{
			      expect(isVNodeOfType(createElement('div'), 'div')).toBe(true);
			      expect(isVNodeOfType(createElement(FunctionalComponent), FunctionalComponent)).toBe(true);
			      expect(isVNodeOfType(createElement(CreateClassComponent), CreateClassComponent)).toBe(true);
			      expect(isVNodeOfType(createElement(ExtendClassComponent), ExtendClassComponent)).toBe(true);
			    \});
			
			    it('should return false for VNodes with a specified type', () => \{
			      expect(isVNodeOfType(createElement('div'), 'h1')).toBe(false);
			      expect(isVNodeOfType(createElement(FunctionalComponent), CreateClassComponent)).toBe(false);
			      expect(isVNodeOfType(createElement(CreateClassComponent), ExtendClassComponent)).toBe(false);
			      expect(isVNodeOfType(createElement(ExtendClassComponent), FunctionalComponent)).toBe(false);
			    \});
			  \});
			
			  describe('isDOMVNode', () => \{
			    it('should return true for VNodes of type string', () => \{
			      expect(isDOMVNode(createElement('div'))).toBe(true);
			      expect(isDOMVNode(createElement('h1'))).toBe(true);
			      expect(isDOMVNode(createElement('p'))).toBe(true);
			    \});
			
			    it('should return false for VNodes of type function or class', () => \{
			      expect(isDOMVNode(createElement(CreateClassComponent))).toBe(false);
			      expect(isDOMVNode(createElement(ExtendClassComponent))).toBe(false);
			      expect(isDOMVNode(createElement(FunctionalComponent))).toBe(false);
			    \});
			  \});
			
			  describe('isDOMVNodeOfType', () => \{
			    it('should return true for VNodes of specific string type', () => \{
			      expect(isDOMVNodeOfType(createElement('div'), 'div')).toBe(true);
			      expect(isDOMVNodeOfType(createElement('h1'), 'h1')).toBe(true);
			      expect(isDOMVNodeOfType(createElement('p'), 'p')).toBe(true);
			    \});
			
			    it('should return false for VNodes of incorrect type', () => \{
			      expect(isDOMVNodeOfType(createElement('div'), 'foo')).toBe(false);
			      expect(isDOMVNodeOfType(createElement('div'), \{\})).toBe(false);
			      expect(isDOMVNodeOfType(createElement('div'), [])).toBe(false);
			      expect(isDOMVNodeOfType(createElement('div'), 10)).toBe(false);
			      expect(isDOMVNodeOfType(createElement('div'), undefined)).toBe(false);
			      expect(isDOMVNodeOfType(createElement('div'), null)).toBe(false);
			    \});
			  \});
			
			  describe('isFunctionalVNode', () => \{
			    it('should return true for VNodes of stateless function type', () => \{
			      expect(isFunctionalVNode(createElement(FunctionalComponent))).toBe(true);
			    \});
			
			    it('should return false for VNodes of incorrect type', () => \{
			      expect(isFunctionalVNode(createElement(CreateClassComponent))).toBe(false);
			      expect(isFunctionalVNode(createElement(ExtendClassComponent))).toBe(false);
			      expect(isFunctionalVNode(createElement('div'))).toBe(false);
			    \});
			  \});
			
			  describe('isFunctionalVNodeOfType', () => \{
			    it('should return true for VNodes of specific stateless function type', () => \{
			      expect(isFunctionalVNodeOfType(createElement(FunctionalComponent), FunctionalComponent)).toBe(true);
			    \});
			
			    it('should return false for VNodes of incorrect type', () => \{
			      expect(isFunctionalVNodeOfType(createElement(FunctionalComponent), AnotherFunctionalComponent)).toBe(false);
			      expect(isFunctionalVNodeOfType(createElement(FunctionalComponent), CreateClassComponent)).toBe(false);
			      expect(isFunctionalVNodeOfType(createElement(FunctionalComponent), ExtendClassComponent)).toBe(false);
			    \});
			  \});
			
			  describe('isClassVNode', () => \{
			    it('should return true for VNodes of class type', () => \{
			      expect(isClassVNode(createElement(CreateClassComponent))).toBe(true);
			      expect(isClassVNode(createElement(ExtendClassComponent))).toBe(true);
			    \});
			
			    it('should return false for VNodes of incorrect type', () => \{
			      expect(isClassVNode(createElement(FunctionalComponent))).toBe(false);
			      expect(isClassVNode(createElement('div'))).toBe(false);
			    \});
			  \});
			
			  describe('isClassVNodeOfType', () => \{
			    it('should return true for VNodes of specific class type', () => \{
			      expect(isClassVNodeOfType(createElement(CreateClassComponent), CreateClassComponent)).toBe(true);
			      expect(isClassVNodeOfType(createElement(ExtendClassComponent), ExtendClassComponent)).toBe(true);
			    \});
			
			    it('should return false for VNodes of incorrect type', () => \{
			      expect(isClassVNodeOfType(createElement(CreateClassComponent), AnotherCreateClassComponent)).toBe(false);
			      expect(isClassVNodeOfType(createElement(CreateClassComponent), AnotherExtendClassComponent)).toBe(false);
			      expect(isClassVNodeOfType(createElement(CreateClassComponent), FunctionalComponent)).toBe(false);
			
			      expect(isClassVNodeOfType(createElement(ExtendClassComponent), AnotherCreateClassComponent)).toBe(false);
			      expect(isClassVNodeOfType(createElement(ExtendClassComponent), AnotherExtendClassComponent)).toBe(false);
			      expect(isClassVNodeOfType(createElement(ExtendClassComponent), FunctionalComponent)).toBe(false);
			    \});
			  \});
			
			  describe('isDOMElement', () => \{
			    it('should return true for DOMElements', () => \{
			      expect(isDOMElement(createDOMElement('div'))).toBe(true);
			      expect(isDOMElement(createDOMElement('h1'))).toBe(true);
			      expect(isDOMElement(createDOMElement('p'))).toBe(true);
			    \});
			
			    it('should return false for non-DOMElements', () => \{
			      expect(isDOMElement(createElement(CreateClassComponent))).toBe(false);
			      expect(isDOMElement(createElement(ExtendClassComponent))).toBe(false);
			      expect(isDOMElement(createElement(FunctionalComponent))).toBe(false);
			      expect(isDOMElement(createElement('div'))).toBe(false);
			      expect(isDOMElement(CreateClassComponent)).toBe(false);
			      expect(isDOMElement(ExtendClassComponent)).toBe(false);
			      expect(isDOMElement(FunctionalComponent)).toBe(false);
			      expect(isDOMElement('div')).toBe(false);
			      expect(isDOMElement(undefined)).toBe(false);
			      expect(isDOMElement(null)).toBe(false);
			      expect(isDOMElement(\{\})).toBe(false);
			      expect(isDOMElement([])).toBe(false);
			      expect(isDOMElement(10)).toBe(false);
			    \});
			  \});
			
			  describe('isDOMElementOfType', () => \{
			    it('should return true for DOMElements of specific type', () => \{
			      expect(isDOMElementOfType(createDOMElement('div'), 'div')).toBe(true);
			      expect(isDOMElementOfType(createDOMElement('div'), 'DIV')).toBe(true);
			      expect(isDOMElementOfType(createDOMElement('h1'), 'h1')).toBe(true);
			      expect(isDOMElementOfType(createDOMElement('h1'), 'H1')).toBe(true);
			      expect(isDOMElementOfType(createDOMElement('p'), 'p')).toBe(true);
			      expect(isDOMElementOfType(createDOMElement('p'), 'P')).toBe(true);
			    \});
			
			    it('should return false for DOMElements of incorrect type', () => \{
			      expect(isDOMElementOfType(createDOMElement('div'), 'foo')).toBe(false);
			      expect(isDOMElementOfType(createDOMElement('div'), \{\})).toBe(false);
			      expect(isDOMElementOfType(createDOMElement('div'), [])).toBe(false);
			      expect(isDOMElementOfType(createDOMElement('div'), 10)).toBe(false);
			      expect(isDOMElementOfType(createDOMElement('div'), undefined)).toBe(false);
			      expect(isDOMElementOfType(createDOMElement('div'), null)).toBe(false);
			    \});
			  \});
			
			  describe('isRenderedClassComponent', () => \{
			    const DOMVNode = createElement('div');
			    const functionalVNode = createElement(FunctionalComponent);
			    const createClassVNode = createElement(CreateClassComponent);
			    const extendClassVNode = createElement(ExtendClassComponent);
			
			    it('should return true for rendered Class Components', () => \{
			      expect(isRenderedClassComponent(renderIntoContainer(createClassVNode))).toBe(true);
			      expect(isRenderedClassComponent(renderIntoContainer(extendClassVNode))).toBe(true);
			    \});
			
			    it('should return false for non-rendered Class Components', () => \{
			      expect(isRenderedClassComponent(createClassVNode)).toBe(false);
			      expect(isRenderedClassComponent(extendClassVNode)).toBe(false);
			      expect(isRenderedClassComponent(renderIntoContainer(functionalVNode))).toBe(false);
			      expect(isRenderedClassComponent(renderIntoContainer(DOMVNode))).toBe(false);
			    \});
			  \});
			
			  describe('isRenderedClassComponentOfType', () => \{
			    const createClassVNode = createElement(CreateClassComponent);
			    const extendClassVNode = createElement(ExtendClassComponent);
			
			    it('should return true for rendered Class Components of specific type', () => \{
			      expect(isRenderedClassComponentOfType(renderIntoContainer(createClassVNode), CreateClassComponent)).toBe(true);
			      expect(isRenderedClassComponentOfType(renderIntoContainer(extendClassVNode), ExtendClassComponent)).toBe(true);
			    \});
			
			    it('should return false for rendered Class Components of incorrect type', () => \{
			      expect(isRenderedClassComponentOfType(renderIntoContainer(createClassVNode), AnotherCreateClassComponent)).toBe(false);
			      expect(isRenderedClassComponentOfType(renderIntoContainer(createClassVNode), ExtendClassComponent)).toBe(false);
			      expect(isRenderedClassComponentOfType(renderIntoContainer(createClassVNode), FunctionalComponent)).toBe(false);
			      expect(isRenderedClassComponentOfType(renderIntoContainer(createClassVNode), 'div')).toBe(false);
			
			      expect(isRenderedClassComponentOfType(renderIntoContainer(extendClassVNode), AnotherExtendClassComponent)).toBe(false);
			      expect(isRenderedClassComponentOfType(renderIntoContainer(extendClassVNode), CreateClassComponent)).toBe(false);
			      expect(isRenderedClassComponentOfType(renderIntoContainer(extendClassVNode), FunctionalComponent)).toBe(false);
			      expect(isRenderedClassComponentOfType(renderIntoContainer(extendClassVNode), 'div')).toBe(false);
			    \});
			  \});
			
			  describe('findAllInRenderedTree', () => \{
			    let tree1;
			
			    beforeEach(() => \{
			      tree1 = (
			        <section className="outer">
			          <FunctionalComponent />
			        </section>
			      );
			      render(tree1, container);
			    \});
			
			    it('should call predicate for each VNode instance in a rendered tree', () => \{
			      const spy = jasmine.createSpy('spy');
			      expect(spy).not.toHaveBeenCalled();
			      findAllInRenderedTree(tree1, (args) => \{
			        spy(args.type);
			      \});
			      // 0: section
			      // 1: FunctionalComponent
			      // 2: div
			      expect(spy).toHaveBeenCalledTimes(3);
			      expect(spy).toHaveBeenCalledWith('section');
			      expect(spy).toHaveBeenCalledWith(FunctionalComponent);
			      expect(spy).toHaveBeenCalledWith('div');
			    \});
			
			    it('should call predicate in the correct order', () => \{
			      const types = [];
			      findAllInRenderedTree(tree1, (\{ type \}) => types.push(type));
			      expect(types).toEqual(['section', FunctionalComponent, 'div']);
			    \});
			
			    it('should work with interpolated text', () => \{
			      const predicate = jasmine.createSpy('spy');
			      const Hello = (\{ who \}) => <div>Hello, \{who\}!</div>;
			      const tree = <Hello who="world" />;
			      render(tree, container);
			      expect(predicate).not.toHaveBeenCalled();
			      findAllInRenderedTree(tree, predicate);
			
			      expect(predicate).toHaveBeenCalledTimes(5);
			    \});
			
			    it('should work without class wrappers', () => \{
			      const predicate = jasmine.createSpy('spy');
			      const Hello = (\{ who \}) => <div>Hello, \{who\}!</div>;
			      const treeWithText = <Hello who="world" />;
			      render(treeWithText, container);
			
			      expect(predicate).not.toHaveBeenCalled();
			      findAllInRenderedTree(treeWithText, predicate);
			
			      expect(predicate).toHaveBeenCalledTimes(5);
			    \});
			  \});
			
			  describe('findAllInVNodeTree', () => \{
			    const tree2 = (
			      <section className="outer">
			        <FunctionalComponent />
			      </section>
			    );
			
			    it('should throw an error when not passed a VNode', () => \{
			      const errorRegex = /findAllInVNodeTree/;
			      const predicate = (vNode) => \{
			        return true;
			      \};
			      const testValue = (value) => \{
			        expect(() => \{
			          findAllInVNodeTree(value, predicate);
			        \}).toThrowError();
			      \};
			      testValue(render(<div />, container));
			      testValue(CreateClassComponent);
			      testValue(ExtendClassComponent);
			      testValue(FunctionalComponent);
			      testValue(createDOMElement('div'));
			      testValue(undefined);
			      testValue(null);
			      testValue('foo');
			      testValue(\{\});
			      testValue([]);
			      testValue(10);
			    \});
			
			    it('should call predicate for each VNode instance in an non-rendered tree', () => \{
			      const predicate = jasmine.createSpy('spy');
			
			      findAllInVNodeTree(tree2, (args) => \{
			        predicate(args.type);
			      \});
			      // 0: section
			      // 1: FunctionalComponent
			      expect(predicate).toHaveBeenCalledTimes(2);
			      expect(predicate).toHaveBeenCalledWith('section');
			      expect(predicate).toHaveBeenCalledWith(FunctionalComponent);
			    \});
			
			    it('should call predicate in the correct order', () => \{
			      const types = [];
			      findAllInVNodeTree(tree2, (\{ type \}) => types.push(type));
			      expect(types).toEqual(['section', FunctionalComponent]);
			    \});
			  \});
			
			  describe('scryRenderedDOMElementsWithClass', () => \{
			    const tree3 = renderIntoContainer(
			      <div className="level-1 one">
			        <div className="level-2 one">
			          <div className="level-3 one" />
			        </div>
			        <div className="level-2 two">
			          <span className="level-3 two" />
			        </div>
			      </div>
			    );
			
			    it('should return an array of matched DOM elements', () => \{
			      const result1 = scryRenderedDOMElementsWithClass(tree3, 'one');
			      expect(result1 instanceof Array).toBeTruthy();
			      expect(result1.length).toBe(3);
			      result1.forEach((result) => \{
			        expect(result.tagName).toBe('DIV');
			      \});
			
			      const result2 = scryRenderedDOMElementsWithClass(tree3, 'two');
			      expect(result2 instanceof Array).toBeTruthy();
			      expect(result2.length).toBe(2);
			      expect(result2[0].tagName).toBe('DIV');
			      expect(result2[1].tagName).toBe('SPAN');
			
			      const result3 = scryRenderedDOMElementsWithClass(tree3, 'three');
			      expect(result3 instanceof Array).toBeTruthy();
			      expect(result3.length).toBe(0);
			    \});
			
			    it('should accept a space separated string of class names', () => \{
			      const result1 = scryRenderedDOMElementsWithClass(tree3, 'level-2');
			      expect(result1 instanceof Array).toBeTruthy();
			      expect(result1.length).toBe(2);
			
			      const result2 = scryRenderedDOMElementsWithClass(tree3, 'level-2 one');
			      expect(result2 instanceof Array).toBeTruthy();
			      expect(result2.length).toBe(1);
			    \});
			
			    it('should accept an array of class names', () => \{
			      const result = scryRenderedDOMElementsWithClass(tree3, ['level-2', 'one']);
			      expect(result instanceof Array).toBeTruthy();
			      expect(result.length).toBe(1);
			    \});
			  \});
			
			  describe('scryRenderedDOMElementsWithTag', () => \{
			    const tree4 = renderIntoContainer(
			      <div>
			        <header>
			          <h1>Hello</h1>
			        </header>
			        <section>
			          <h1>Hello Again</h1>
			          <p>Paragraph 1</p>
			          <p>Paragraph 2</p>
			          <p>Paragraph 3</p>
			        </section>
			      </div>
			    );
			
			    it('should return an array of matched DOM elements', () => \{
			      const testValue = (tagName, length, instance) => \{
			        const result = scryRenderedDOMElementsWithTag(tree4, tagName);
			        expect(result instanceof Array).toBeTruthy();
			        expect(result.length).toBe(length);
			        result.forEach((item) => \{
			          expect(item.tagName).toBe(tagName.toUpperCase());
			        \});
			      \};
			      testValue('div', 1);
			      testValue('h1', 2);
			      testValue('p', 3);
			      testValue('span', 0);
			    \});
			  \});
			
			  describe('scryRenderedVNodesWithType', () => \{
			    const tree5 = renderIntoContainer(
			      <div>
			        <FunctionalComponent />
			        <FunctionalComponent />
			        <CreateClassComponent />
			        <CreateClassComponent />
			        <ExtendClassComponent />
			        <ExtendClassComponent />
			      </div>
			    );
			
			    it('should return an array of matched VNodes', () => \{
			      const testValue = (type, length) => \{
			        const result = scryRenderedVNodesWithType(tree5, type);
			        expect(result instanceof Array).toBeTruthy();
			        expect(result.length).toBe(length);
			        result.forEach((item) => \{
			          expect(item instanceof Object).toBeTruthy();
			          expect(Object.keys(item).sort()).toEqual(VNodeKeys);
			          expect(isVNode(item)).toBe(true);
			        \});
			      \};
			      testValue('p', 0);
			      testValue('div', 7); // Outer div + each rendered component div
			      testValue(FunctionalComponent, 2);
			      testValue(CreateClassComponent, 2);
			      testValue(ExtendClassComponent, 2);
			      testValue(AnotherFunctionalComponent, 0);
			    \});
			  \});
			
			  describe('scryVNodesWithType', () => \{
			    const tree6 = (
			      <div>
			        <FunctionalComponent />
			        <FunctionalComponent />
			        <CreateClassComponent />
			        <CreateClassComponent />
			        <ExtendClassComponent />
			        <ExtendClassComponent />
			      </div>
			    );
			
			    it('should return an array of matched VNodes', () => \{
			      const testValue = (type, length) => \{
			        const result = scryVNodesWithType(tree6, type);
			        expect(result instanceof Array).toBeTruthy();
			        expect(result.length).toBe(length);
			        result.forEach((item) => \{
			          expect(item instanceof Object).toBeTruthy();
			          expect(Object.keys(item).sort()).toEqual(VNodeKeys);
			          expect(isVNode(item)).toBe(true);
			        \});
			      \};
			      testValue('p', 0);
			      testValue('div', 1); // Just the outer div
			      testValue(FunctionalComponent, 2);
			      testValue(CreateClassComponent, 2);
			      testValue(ExtendClassComponent, 2);
			      testValue(AnotherFunctionalComponent, 0);
			    \});
			  \});
			
			  describe('findRenderedDOMElementWithClass', () => \{
			    const tree7 = renderIntoContainer(
			      <div className="level-1 one">
			        <div className="level-2 one">
			          <div className="level-3 one" />
			        </div>
			        <div className="level-2 two">
			          <span className="level-3 two" />
			        </div>
			      </div>
			    );
			
			    it('should throw an error when more than one result is found #1', () => \{
			      const errorRegex = /Did not find exactly one match/;
			      const testValue = (classNames) => \{
			        expect(() => \{
			          findRenderedDOMElementWithClass(tree7, classNames);
			        \}).toThrowError();
			      \};
			      testValue('level-2');
			      testValue('level-3');
			    \});
			
			    it('should return a matched DOM element', () => \{
			      const testValue = (classNames, instance) => \{
			        const result = findRenderedDOMElementWithClass(tree7, classNames);
			        const arrOfClassName = classNames.split(' ');
			        for (let i = 0; i < arrOfClassName.length; i++) \{
			          expect(result.classList.contains(arrOfClassName[i])).toBe(true);
			        \}
			      \};
			      testValue('level-1');
			      testValue('level-2 one');
			      testValue('level-3 two');
			    \});
			
			    it('should be able to handle null elements', () => \{
			      const NoOp = () => null;
			      const Broken = () => (
			        <div className="dummy">
			          <NoOp />
			        </div>
			      );
			      const renderedTree = renderIntoContainer(<Broken />);
			      const dummy = findRenderedDOMElementWithClass(renderedTree, 'dummy');
			      expect(dummy.className).toBe('dummy');
			    \});
			  \});
			
			  describe('findRenderedDOMElementWithTag', () => \{
			    const tree8 = renderIntoContainer(
			      <div>
			        <header>
			          <h1>Head1</h1>
			          <span>Hello</span>
			        </header>
			        <section>
			          <h1>Hello Again</h1>
			          <p>Paragraph 1</p>
			          <p>Paragraph 2</p>
			          <p>Paragraph 3</p>
			          <a>test</a>
			        </section>
			      </div>
			    );
			
			    it('should throw an error when more than one result is found #2', () => \{
			      const errorRegex = /Did not find exactly one match/;
			      const testValue = (tagName) => \{
			        expect(() => \{
			          findRenderedDOMElementWithTag(tree8, tagName);
			        \}).toThrowError();
			      \};
			      testValue('h1');
			      testValue('p');
			    \});
			
			    it('should return a matched DOM element', () => \{
			      const testValue = (tagName, instance) => \{
			        const result = findRenderedDOMElementWithTag(tree8, tagName);
			
			        expect(result.tagName).toBe(tagName.toUpperCase());
			      \};
			      testValue('div');
			      testValue('span');
			      testValue('a');
			    \});
			  \});
			
			  describe('findRenderedVNodeWithType', () => \{
			    const tree9 = renderIntoContainer(
			      <div>
			        <h1>Hello</h1>
			        <FunctionalComponent />
			        <FunctionalComponent />
			        <CreateClassComponent />
			        <ExtendClassComponent />
			      </div>
			    );
			
			    it('should throw an error when more than one result is found #3', () => \{
			      const errorRegex = /Did not find exactly one match/;
			      const testValue = (type) => \{
			        expect(() => \{
			          findRenderedVNodeWithType(tree9, type);
			        \}).toThrowError();
			      \};
			      testValue('div');
			      testValue(FunctionalComponent);
			    \});
			
			    it('should return a matched VNode #1', () => \{
			      const testValue = (type) => \{
			        const result = findRenderedVNodeWithType(tree9, type);
			        expect(result instanceof Object).toBeTruthy();
			        expect(Object.keys(result).sort()).toEqual(VNodeKeys);
			        expect(isVNode(result)).toBe(true);
			        expect(result.type).toBe(type);
			      \};
			      testValue('h1');
			      testValue(CreateClassComponent);
			      testValue(ExtendClassComponent);
			    \});
			  \});
			
			  describe('findVNodeWithType', () => \{
			    const tree10 = (
			      <div>
			        <div>
			          <h1>Hello</h1>
			        </div>
			        <FunctionalComponent />
			        <FunctionalComponent />
			        <CreateClassComponent />
			        <ExtendClassComponent />
			      </div>
			    );
			
			    it('should throw an error when more than one result is found #4', () => \{
			      const errorRegex = /Did not find exactly one match/;
			      const testValue = (type) => \{
			        expect(() => \{
			          findVNodeWithType(tree10, type);
			        \}).toThrowError();
			      \};
			      testValue('div');
			      testValue(FunctionalComponent);
			    \});
			
			    it('should return a matched VNode #2', () => \{
			      const testValue = (type) => \{
			        const result = findVNodeWithType(tree10, type);
			        expect(result instanceof Object).toBeTruthy();
			        expect(Object.keys(result).sort()).toEqual(VNodeKeys);
			        expect(isVNode(result)).toBe(true);
			        expect(result.type).toBe(type);
			      \};
			      testValue('h1');
			      testValue(CreateClassComponent);
			      testValue(ExtendClassComponent);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-test-utils\\__tests__\\testUtils.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(47)
    });
    it('infernojs_inferno\\packages\\inferno-utils\\__tests__\\utils.spec.jsx', () => {
        const sourceCode = `
			import \{ createContainerWithHTML, triggerEvent, validateNodeTree \} from 'inferno-utils';
			
			describe('Utils', () => \{
			  describe('createContainerWithHTML', () => \{
			    it('should create a container with the passed in HTML', () => \{
			      const container = createContainerWithHTML('<h1>hello!</h1>');
			      expect(container.innerHTML).toBe('<h1>hello!</h1>');
			      expect(container.tagName).toBe('DIV');
			    \});
			  \});
			  describe('validateNodeTree', () => \{
			    it('should return true if called with falsy arguments', () => \{
			      expect(validateNodeTree(false)).toBe(true);
			      expect(validateNodeTree(null)).toBe(true);
			      expect(validateNodeTree(undefined)).toBe(true);
			    \});
			
			    it('should return true if called with a string', () => \{
			      expect(validateNodeTree('<div><h1>test</h1></div>')).toBe(true);
			    \});
			
			    it('should return true if called with a number', () => \{
			      expect(validateNodeTree(4)).toBe(true);
			    \});
			  \});
			
			  describe('triggerEvent', () => \{
			    let expectedEventType = '';
			    const element = \{
			      dispatchEvent(event) \{\}
			    \};
			    let spyDispatch;
			    let spyCreateMouseEvent;
			    let triggerName;
			    let spyEvent;
			
			    beforeEach(function () \{
			      spyDispatch = spyOn(element, 'dispatchEvent');
			
			      spyCreateMouseEvent = spyOn(document, 'createEvent').and.callFake((ev) => \{
			        expect(ev).toBe(expectedEventType);
			
			        spyEvent = \{
			          initEvent: (eventType, canBubble, cancelable) => \{
			            expect(eventType).toBe(triggerName);
			            // expect(canBubble).toBe(true);
			            expect(cancelable).toBe(true);
			          \}
			        \};
			
			        return spyEvent;
			      \});
			    \});
			
			    afterEach(function () \{
			      spyDispatch.calls.reset();
			      spyCreateMouseEvent.calls.reset();
			    \});
			
			    it('should trigger event on click', () => \{
			      expectedEventType = 'MouseEvents';
			      triggerName = 'click';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should trigger event on dblclick', () => \{
			      expectedEventType = 'MouseEvents';
			      triggerName = 'dblclick';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should trigger event on mousedown', () => \{
			      expectedEventType = 'MouseEvents';
			      triggerName = 'mousedown';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should trigger event on mouseup', () => \{
			      expectedEventType = 'MouseEvents';
			      triggerName = 'mouseup';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should trigger event on focus', () => \{
			      expectedEventType = 'HTMLEvents';
			      triggerName = 'focus';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should trigger event on change', () => \{
			      expectedEventType = 'HTMLEvents';
			      triggerName = 'change';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should trigger event on blur', () => \{
			      expectedEventType = 'HTMLEvents';
			      triggerName = 'blur';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should trigger event on select', () => \{
			      expectedEventType = 'HTMLEvents';
			      triggerName = 'select';
			
			      triggerEvent(triggerName, element);
			
			      expect(spyDispatch.calls.argsFor(0)[0]).toBe(spyEvent);
			    \});
			
			    it('should throw an error on unknown event', () => \{
			      expectedEventType = 'HTMLEvents';
			      triggerName = 'blah';
			
			      expect(triggerEvent.bind(triggerEvent, triggerName, element)).toThrowError(Error);
			    \});
			  \});
			\});
			`

		const tests = extractFromSource(sourceCode, 'infernojs_inferno\\packages\\inferno-utils\\__tests__\\utils.spec.jsx')
		const assertions = tests.flatMap(test => test.assertions).filter(assertion => ['expect', 'assert'].includes(assertion.identifier)).length;
		const snapshotAssertions = tests.flatMap(test => test.assertions).filter(assertion => assertion.isFileSnapshot || assertion.isInlineSnapshot).length;

		expect(tests.length).toBe(13)
    });
});
