id,repo,file,snippet,observation
"36","agraboso/redux-api-middleware","validation.test.js","  it('handles invalid actions', () => {
    expect(isValidRSAA('')).toBeFalsy();
    expect(validateRSAA('')).toMatchSnapshot();
  });",""
"82","airbnb/react-sketchapp","Image.tsx","    it('translates none', () => {
      const tree = renderer.create(<Image source=""foo"" resizeMode=""none"" />).toJSON();

      expect(tree).toMatchSnapshot();
    });",""
"209","algolia/autocomplete","components.test.tsx","  test('provides Snippet component that accepts tagName', async () => {
    const container = document.createElement('div');
    const panelContainer = document.createElement('div');

    document.body.appendChild(panelContainer);
    autocomplete<ProductHit>({
      container,
      panelContainer,
      getSources() {
        return [
          {
            ...createSource({
              getItems() {
                return productHits;
              },
            }),
            templates: {
              item({ item, components }) {
                return (
                  <components.Snippet
                    hit={item}
                    attribute=""name""
                    tagName=""em""
                  />
                );
              },
            },
          },
        ];
      },
    });

    const input = container.querySelector<HTMLInputElement>('.aa-Input');
    fireEvent.input(input, { target: { value: 'a' } });

    await waitFor(() => {
      expect(
        panelContainer.querySelector<HTMLElement>('.aa-Item').innerHTML
      ).toMatchInlineSnapshot(
        `""Apple - <em>iPhone</em> SE 16GB - Space Gray (Verizon)""`
      );
    });
  });",""
"249","algolia/instantsearch.js","CurrentRefinements-test.tsx","    it('can be used with a facet', () => {
      const props = {
        cssClasses,
        items: [
          {
            indexName: 'indexName',
            attribute: 'customFacet',
            label: 'customFacet',
            refine: () => {},
            refinements: [
              {
                attribute: 'customFacet',
                type: 'facet' as const,
                value: 'val1',
                label: 'val1',
              },
            ],
          },
        ],
      };

      const { container } = render(<CurrentRefinements {...props} />);

      expect(container).toMatchSnapshot();
    });",""
"269","algolia/instantsearch.js","GeoSearchToggle-test.tsx","  it('expect to render', () => {
    const props = {
      ...defaultProps,
    };

    const wrapper = shallow(
      <GeoSearchToggle {...props}>
        Clear the current map refinement
      </GeoSearchToggle>
    );

    expect(wrapper).toMatchSnapshot();
  });",""
"411","algolia/instantsearch.js","createRouterMiddleware.ts","  it('sets initial ui state correctly when instantSearchInstance is re-used', async () => {
    const currentRouteState = {
      value: {
        'my-index': {
          query: 'iPhone',
        },
      },
    };
    const searchClient = createSearchClient();
    const search = instantsearch({
      indexName: 'my-index',
      searchClient,
      routing: {
        router: {
          onUpdate: () => {},
          read: () => {
            return currentRouteState.value;
          },
          write: () => {},
          createURL: () => '',
          dispose: () => {},
        },
      },
    });
    search.addWidgets([
      searchBox({ container: document.createElement('div') }),
    ]);
    search.start();
    await wait(0);
    expect(search.getUiState()).toMatchInlineSnapshot(`
      {
        ""my-index"": {
          ""query"": ""iPhone"",
        },
      }
    `);

    search.dispose();
    currentRouteState.value = {
      'my-index': {
        query: 'MacBook',
      },
    };
    search.addWidgets([
      searchBox({ container: document.createElement('div') }),
    ]);
    search.start();
    await wait(0);
    expect(search.getUiState()).toMatchInlineSnapshot(`
      {
        ""my-index"": {
          ""query"": ""MacBook"",
        },
      }
    `);
  });",""
"427","algolia/instantsearch.js","geo-search-test.ts","  it('expect to render', () => {
    const container = createContainer();
    const instantSearchInstance = createFakeInstantSearch();
    const helper = createFakeHelper();
    const googleReference = createFakeGoogleReference();

    const widget = geoSearch({
      googleReference,
      container,
    });

    widget.init!(
      createInitOptions({
        instantSearchInstance,
        helper,
        state: helper.state,
      })
    );

    widget.render!(
      createRenderOptions({
        helper,
        instantSearchInstance,
        results: new SearchResults(helper.state, [
          createSingleSearchResponse({
            hits: [],
          }),
        ]),
      })
    );

    const [firstRender] = render.mock.calls;

    expect(container.innerHTML).toMatchSnapshot();
    expect((firstRender[0] as any).props).toMatchSnapshot();
    expect(firstRender[1]).toBe(container.querySelector('.ais-GeoSearch-tree'));
  });",""
"440","algolia/instantsearch.js","menu-test.ts","    it('renders transformed items', () => {
      const widget = menu({
        container: document.createElement('div'),
        attribute: 'test',
        transformItems: (items) =>
          items.map((item) => ({ ...item, transformed: true })),
      });

      const helper = jsHelper(createSearchClient(), '');

      helper.setState(
        widget.getWidgetSearchParameters(new SearchParameters({}), {
          uiState: {},
        })
      );

      const results = new SearchResults(helper.state, [
        createSingleSearchResponse({
          facets: {
            test: {
              foo: 123,
              bar: 456,
            },
          },
        }),
      ]);

      widget.init!(
        createInitOptions({
          helper,
          createURL: () => '#',
        })
      );
      widget.render!(
        createRenderOptions({
          helper,
          results,
        })
      );

      const firstRender = render.mock.calls[0][0] as VNode;

      expect(firstRender.props).toMatchSnapshot();
    });",""
"695","algolia/instantsearch","hierarchical-menu.test.tsx","    test('renders with templates using JSX', async () => {
      const container = document.createElement('div');
      const searchClient = createMockedSearchClient();

      const search = instantsearch({
        indexName: 'indexName',
        searchClient,
        initialUiState: {
          indexName: {
            hierarchicalMenu: {
              'categories.lvl0': ['Video Games'],
            },
          },
        },
      });

      search.addWidgets([
        hierarchicalMenu({
          container,
          attributes: ['categories.lvl0', 'categories.lvl1'],
          showMore: true,
          limit: 2,
          templates: {
            item({ label, count, isRefined, url }) {
              return (
                <a
                  href={url}
                  style={{ fontWeight: isRefined ? 'bold' : 'normal' }}
                >
                  <span>
                    {label} ({count})
                  </span>
                </a>
              );
            },
            showMoreText(data) {
              return data.isShowingMore ? 'Show less' : 'Show more';
            },
          },
        }),
      ]);

      search.start();

      await wait(0);

      expect(container).toMatchInlineSnapshot(`
<div>
  <div
    class=""ais-HierarchicalMenu""
  >
    <ul
      class=""ais-HierarchicalMenu-list""
    >
      <li
        class=""ais-HierarchicalMenu-item""
      >
        <div>
          <a
            href=""#""
            style=""font-weight: normal;""
          >
            <span>
              Cameras & Camcorders
               (
              1369
              )
            </span>
          </a>
        </div>
      </li>
      <li
        class=""ais-HierarchicalMenu-item ais-HierarchicalMenu-item--selected""
      >
        <div>
          <a
            href=""#""
            style=""font-weight: bold;""
          >
            <span>
              Video Games
               (
              505
              )
            </span>
          </a>
        </div>
      </li>
    </ul>
    <button
      class=""ais-HierarchicalMenu-showMore""
    >
      Show more
    </button>
  </div>
</div>
`);

      const showMoreButton = within(container).getByRole('button');

      fireEvent.click(showMoreButton);

      expect(showMoreButton).toHaveTextContent('Show less');
    });",""
"1016","algolia/instantsearch","PoweredBy.test.tsx","  test('renders for dark themes', () => {
    const props = createProps({ theme: 'dark' });
    const { container } = render(<PoweredBy {...props} />);

    expect(container).toMatchInlineSnapshot(`
      <div>
        <div
          class=""ais-PoweredBy ais-PoweredBy--dark""
        >
          <a
            aria-label=""Search by Algolia""
            class=""ais-PoweredBy-link""
            href=""https://www.algolia.com/""
            rel=""noopener noreferrer""
            target=""_blank""
          >
            <svg
              class=""ais-PoweredBy-logo""
              viewBox=""0 0 572 64""
            >
              <path
                d=""M16 48.3c-3.4 0-6.3-.6-8.7-1.7A12.4 12.4 0 0 1 1.9 42C.6 40 0 38 0 35.4h6.5a6.7 6.7 0 0 0 3.9 6c1.4.7 3.3 1.1 5.6 1.1 2.2 0 4-.3 5.4-1a7 7 0 0 0 3-2.4 6 6 0 0 0 1-3.4c0-1.5-.6-2.8-1.9-3.7-1.3-1-3.3-1.6-5.9-1.8l-4-.4c-3.7-.3-6.6-1.4-8.8-3.4a10 10 0 0 1-3.3-7.9c0-2.4.6-4.6 1.8-6.4a12 12 0 0 1 5-4.3c2.2-1 4.7-1.6 7.5-1.6s5.5.5 7.6 1.6a12 12 0 0 1 5 4.4c1.2 1.8 1.8 4 1.8 6.7h-6.5a6.4 6.4 0 0 0-3.5-5.9c-1-.6-2.6-1-4.4-1s-3.2.3-4.4 1c-1.1.6-2 1.4-2.6 2.4-.5 1-.8 2-.8 3.1a5 5 0 0 0 1.5 3.6c1 1 2.6 1.7 4.7 1.9l4 .3c2.8.2 5.2.8 7.2 1.8 2.1 1 3.7 2.2 4.9 3.8a9.7 9.7 0 0 1 1.7 5.8c0 2.5-.7 4.7-2 6.6a13 13 0 0 1-5.6 4.4c-2.4 1-5.2 1.6-8.4 1.6Zm35.6 0c-2.6 0-4.8-.4-6.7-1.3a13 13 0 0 1-4.7-3.5 17.1 17.1 0 0 1-3.6-10.4v-1c0-2 .3-3.8 1-5.6a13 13 0 0 1 7.3-8.3 15 15 0 0 1 6.3-1.4A13.2 13.2 0 0 1 64 24.3c1 2.2 1.6 4.6 1.6 7.2V34H39.4v-4.3h21.8l-1.8 2.2c0-2-.3-3.7-.9-5.1a7.3 7.3 0 0 0-2.7-3.4c-1.2-.7-2.7-1.1-4.6-1.1s-3.4.4-4.7 1.3a8 8 0 0 0-2.9 3.6c-.6 1.5-.9 3.3-.9 5.4 0 2 .3 3.7 1 5.3a7.9 7.9 0 0 0 2.8 3.7c1.3.8 3 1.3 5 1.3s3.8-.5 5.1-1.3c1.3-1 2.1-2 2.4-3.2h6a11.8 11.8 0 0 1-7 8.7 16 16 0 0 1-6.4 1.2ZM80 48c-2.2 0-4-.3-5.7-1a8.4 8.4 0 0 1-3.7-3.3 9.7 9.7 0 0 1-1.3-5.2c0-2 .5-3.8 1.5-5.2a9 9 0 0 1 4.3-3.1c1.8-.7 4-1 6.7-1H89v4.1h-7.5c-2 0-3.4.5-4.4 1.4-1 1-1.6 2.1-1.6 3.6s.5 2.7 1.6 3.6c1 1 2.5 1.4 4.4 1.4 1.1 0 2.2-.2 3.2-.7 1-.4 1.9-1 2.6-2 .6-1 1-2.4 1-4.2l1.7 2.1c-.2 2-.7 3.8-1.5 5.2a9 9 0 0 1-3.4 3.3 12 12 0 0 1-5.3 1Zm9.5-.7v-8.8h-1v-10c0-1.8-.5-3.2-1.4-4.1-1-1-2.4-1.4-4.2-1.4a142.9 142.9 0 0 0-10.2.4v-5.6a74.8 74.8 0 0 1 8.6-.4c3 0 5.5.4 7.5 1.2s3.4 2 4.4 3.6c1 1.7 1.4 4 1.4 6.7v18.4h-5Zm12.9 0V17.8h5v12.3h-.2c0-4.2 1-7.4 2.8-9.5a11 11 0 0 1 8.3-3.1h1v5.6h-2a9 9 0 0 0-6.3 2.2c-1.5 1.5-2.2 3.6-2.2 6.4v15.6h-6.4Zm34.4 1a15 15 0 0 1-6.6-1.3c-1.9-.9-3.4-2-4.7-3.5a15.5 15.5 0 0 1-2.7-5c-.6-1.7-1-3.6-1-5.4v-1c0-2 .4-3.8 1-5.6a15 15 0 0 1 2.8-4.9c1.3-1.5 2.8-2.6 4.6-3.5a16.4 16.4 0 0 1 13.3.2c2 1 3.5 2.3 4.8 4a12 12 0 0 1 2 6H144c-.2-1.6-1-3-2.2-4.1a7.5 7.5 0 0 0-5.2-1.7 8 8 0 0 0-4.7 1.3 8 8 0 0 0-2.8 3.6 13.8 13.8 0 0 0 0 10.3c.6 1.5 1.5 2.7 2.8 3.6s2.8 1.3 4.8 1.3c1.5 0 2.7-.2 3.8-.8a7 7 0 0 0 2.6-2c.7-1 1-2 1.2-3.2h6.2a11 11 0 0 1-2 6.2 15.1 15.1 0 0 1-11.8 5.5Zm19.7-1v-40h6.4V31h-1.3c0-3 .4-5.5 1.1-7.6a9.7 9.7 0 0 1 3.5-4.8A9.9 9.9 0 0 1 172 17h.3c3.5 0 6 1.1 7.9 3.5 1.7 2.3 2.6 5.7 2.6 10v16.8h-6.4V29.6c0-2.1-.6-3.8-1.8-5a6.4 6.4 0 0 0-4.8-1.8c-2 0-3.7.7-5 2a7.8 7.8 0 0 0-1.9 5.5v17h-6.4Zm63.8 1a12.2 12.2 0 0 1-10.9-6.2 19 19 0 0 1-1.8-7.3h1.4v12.5h-5.1v-40h6.4v19.8l-2 3.5c.2-3.1.8-5.7 1.9-7.7a11 11 0 0 1 4.4-4.5c1.8-1 3.9-1.5 6.1-1.5a13.4 13.4 0 0 1 12.8 9.1c.7 1.9 1 3.8 1 6v1c0 2.2-.3 4.1-1 6a13.6 13.6 0 0 1-13.2 9.4Zm-1.2-5.5a8.4 8.4 0 0 0 7.9-5c.7-1.5 1.1-3.3 1.1-5.3s-.4-3.8-1.1-5.3a8.7 8.7 0 0 0-3.2-3.6 9.6 9.6 0 0 0-9.2-.2 8.5 8.5 0 0 0-3.3 3.2c-.8 1.4-1.3 3-1.3 5v2.3a9 9 0 0 0 1.3 4.8 9 9 0 0 0 3.4 3c1.4.7 2.8 1 4.4 1Zm27.3 3.9-10-28.9h6.5l9.5 28.9h-6Zm-7.5 12.2v-5.7h4.9c1 0 2-.1 2.9-.4a4 4 0 0 0 2-1.4c.4-.7.9-1.6 1.2-2.7l8.6-30.9h6.2l-9.3 32.4a14 14 0 0 1-2.5 5 8.9 8.9 0 0 1-4 2.8c-1.5.6-3.4.9-5.6.9h-4.4Zm9-12.2v-5.2h6.4v5.2H248Z""
                fill=""#FFF""
              />
              <path
                d=""M534.4 9.1H528a.8.8 0 0 1-.7-.7V1.8c0-.4.2-.7.6-.8l6.5-1c.4 0 .8.2.9.6v7.8c0 .4-.4.7-.8.7zM428 35.2V.8c0-.5-.3-.8-.7-.8h-.2l-6.4 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.5 0 .8-.4.8-.8V43c0-.4-.3-.7-.6-.8-4.5-.5-4.5-6-4.5-7zm106.5-21.8H528c-.4 0-.7.4-.7.8v34c0 .4.3.8.7.8h6.5c.4 0 .8-.4.8-.8v-34c0-.5-.4-.8-.8-.8zm-17.7 21.8V.8c0-.5-.3-.8-.8-.8l-6.5 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.4 0 .8-.4.8-.8V43c0-.4-.3-.7-.7-.8-4.4-.5-4.4-6-4.4-7zm-22.2-20.6a16.5 16.5 0 0 1 8.6 9.3c.8 2.2 1.3 4.8 1.3 7.5a19.4 19.4 0 0 1-4.6 12.6 14.8 14.8 0 0 1-5.2 3.6c-2 .9-5.2 1.4-6.8 1.4a21 21 0 0 1-6.7-1.4 15.4 15.4 0 0 1-8.6-9.3 21.3 21.3 0 0 1 0-14.4 15.2 15.2 0 0 1 8.6-9.3c2-.8 4.3-1.2 6.7-1.2s4.6.4 6.7 1.2zm-6.7 27.6c2.7 0 4.7-1 6.2-3s2.2-4.3 2.2-7.8-.7-6.3-2.2-8.3-3.5-3-6.2-3-4.7 1-6.1 3c-1.5 2-2.2 4.8-2.2 8.3s.7 5.8 2.2 7.8 3.5 3 6.2 3zm-88.8-28.8c-6.2 0-11.7 3.3-14.8 8.2a18.6 18.6 0 0 0 4.8 25.2c1.8 1.2 4 1.8 6.2 1.7s.1 0 .1 0h.9c4.2-.7 8-4 9.1-8.1v7.4c0 .4.3.7.8.7h6.4a.7.7 0 0 0 .7-.7V14.2c0-.5-.3-.8-.7-.8h-13.5zm6.3 26.5a9.8 9.8 0 0 1-5.7 2h-.5a10 10 0 0 1-9.2-14c1.4-3.7 5-6.3 9-6.3h6.4v18.3zm152.3-26.5h13.5c.5 0 .8.3.8.7v33.7c0 .4-.3.7-.8.7h-6.4a.7.7 0 0 1-.8-.7v-7.4c-1.2 4-4.8 7.4-9 8h-.1a4.2 4.2 0 0 1-.5.1h-.9a10.3 10.3 0 0 1-7-2.6c-4-3.3-6.5-8.4-6.5-14.2 0-3.7 1-7.2 3-10 3-5 8.5-8.3 14.7-8.3zm.6 28.4c2.2-.1 4.2-.6 5.7-2V21.7h-6.3a9.8 9.8 0 0 0-9 6.4 10.2 10.2 0 0 0 9.1 13.9h.5zM452.8 13.4c-6.2 0-11.7 3.3-14.8 8.2a18.5 18.5 0 0 0 3.6 24.3 10.4 10.4 0 0 0 13 .6c2.2-1.5 3.8-3.7 4.5-6.1v7.8c0 2.8-.8 5-2.2 6.3-1.5 1.5-4 2.2-7.5 2.2l-6-.3c-.3 0-.7.2-.8.5l-1.6 5.5c-.1.4.1.8.5 1h.1c2.8.4 5.5.6 7 .6 6.3 0 11-1.4 14-4.1 2.7-2.5 4.2-6.3 4.5-11.4V14.2c0-.5-.4-.8-.8-.8h-13.5zm6.3 8.2v18.3a9.6 9.6 0 0 1-5.6 2h-1a10.3 10.3 0 0 1-8.8-14c1.4-3.7 5-6.3 9-6.3h6.4zM291 31.5A32 32 0 0 1 322.8 0h30.8c.6 0 1.2.5 1.2 1.2v61.5c0 1.1-1.3 1.7-2.2 1l-19.2-17a18 18 0 0 1-11 3.4 18.1 18.1 0 1 1 18.2-14.8c-.1.4-.5.7-.9.6-.1 0-.3 0-.4-.2l-3.8-3.4c-.4-.3-.6-.8-.7-1.4a12 12 0 1 0-2.4 8.3c.4-.4 1-.5 1.6-.2l14.7 13.1v-46H323a26 26 0 1 0 10 49.7c.8-.4 1.6-.2 2.3.3l3 2.7c.3.2.3.7 0 1l-.2.2a32 32 0 0 1-47.2-28.6z""
                fill=""#FFF""
              />
            </svg>
          </a>
        </div>
      </div>
    `);
  });",""
"1115","algolia/instantsearch","Breadcrumb.js","  it('renders correctly with a selected item', () => {
    __setState({
      ...defaultState,
    });

    const wrapper = mount(Breadcrumb, {
      propsData: defaultProps,
    });

    const selected = wrapper.find('.ais-Breadcrumb-item--selected');

    expect(selected.text()).toContain('Streaming Media Players');
    expect(wrapper.html()).toMatchSnapshot();
  });",""
"1138","algolia/instantsearch","DynamicWidgets.js","it('renders attributesToRender (refinement list)', () => {
  __setState({
    attributesToRender: ['test2'],
  });

  const wrapper = mount({
    template: `
      <DynamicWidgets :transformItems=""items => items"">
        <MockMenu attribute=""test1"" />
        <MockRefinementList attribute=""test2"" />
      </DynamicWidgets>
    `,
    components: {
      DynamicWidgets,
      MockRefinementList,
      MockMenu,
    },
  });

  expect(wrapper.html()).toMatchInlineSnapshot(`
<div class=""ais-DynamicWidgets"">
  <div class=""ais-DynamicWidgets-widget"">
    <div>
      {
      ""widgetName"": ""ais-refinement-list"",
      ""attribute"": ""test2""
      }
    </div>
  </div>
</div>
`);
});",""
"1314","algolia/react-instantsearch","Highlighter.js","  it('renders a highlighted value', () => {
    const props = {
      ...defaultProps,
      highlight: () => [
        { value: 'Ap', isHighlighted: true },
        { value: 'ple', isHighlighted: false },
      ],
    };

    const wrapper = shallow(
      <Highlighter cx={(...x) => x.join(' ')} {...props} />
    );

    expect(wrapper).toMatchSnapshot();
  });",""
"1382","algolia/react-instantsearch","RangeInput.js","  it(""render when can't refine"", () => {
    const props = {
      canRefine: false,
      min: 0,
      max: 100,
      currentRefinement: {
        min: 10,
        max: 90,
      },
    };

    const component = shallowRender(props);

    expect(component).toMatchSnapshot();
  });",""
"1793","amzn/style-dictionary","swiftFile.test.js","    it('should match default snapshot', () => {
      expect(format(createFormatArgs({
        dictionary,
        file,
        platform: {}
      }), {}, file)).toMatchSnapshot();
    });",""
"1794","amzn/style-dictionary","swiftFile.test.js","    it('with import override should match snapshot', () => {
      file.options.import = [""UIKit"", ""AnotherModule""];
      expect(format(createFormatArgs({
        dictionary,
        file,
        platform: {}
      }), {}, file)).toMatchSnapshot();
    });",""
"1837","ant-design/ant-design-mobile","notice-bar.test.tsx","  test('long content', async () => {
    const { container } = render(
      <NoticeBar
        delay={100}
        speed={500}
        content='cupidatat nostrud est nisi excepteur cupidatat deserunt irure consectetur veniam eiusmod labore reprehenderit elit pariatur aute reprehenderit amet ex officia'
      />
    )

    // mock offset width
    const contentEl = document.querySelectorAll(`.${classPrefix}-content`)[0]
    const innerEl = document.querySelectorAll(
      `.${classPrefix}-content-inner`
    )[0]
    Object.defineProperty(contentEl, 'offsetWidth', {
      configurable: true,
      value: 300,
    })
    Object.defineProperty(innerEl, 'offsetWidth', {
      configurable: true,
      value: 600,
    })

    await sleep(200)
    expect(container).toMatchSnapshot()
  })",""
"1859","ant-design/ant-design","Avatar.test.js","  it('support size is number', () => {
    const wrapper = mount(<Avatar size={100}>TestString</Avatar>);
    expect(wrapper.render()).toMatchSnapshot();
  });",""
"2052","ant-design/ant-design","Table.expand.test.js","  it('click to expand', () => {
    const wrapper = mount(<Table columns={columns} dataSource={data} />);
    wrapper.find('.ant-table-row-expand-icon').last().simulate('click');
    expect(wrapper.render()).toMatchSnapshot();
  });",""
"2056","ant-design/ant-design","Table.filter.test.js","  it('renders custom content correctly', () => {
    const filter = <div className=""custom-filter-dropdown"">custom filter</div>;
    const wrapper = mount(
      createTable({
        columns: [
          {
            ...column,
            filterDropdown: filter,
          },
        ],
      }),
    );

    const dropdownWrapper = mount(wrapper.find('Trigger').instance().getComponent());
    expect(dropdownWrapper.render()).toMatchSnapshot();
  });",""
"2057","ant-design/ant-design","Table.filter.test.js","  it('override custom filter correctly', () => {
    const filter = ({ prefixCls, setSelectedKeys, confirm, clearFilters }) => (
      <div className={`${prefixCls}-view`} id=""customFilter"">
        <span onClick={() => setSelectedKeys([42])} id=""setSelectedKeys"">
          setSelectedKeys
        </span>
        <span onClick={() => confirm()} id=""confirm"">
          Confirm
        </span>
        <span onClick={() => clearFilters()} id=""reset"">
          Reset
        </span>
        <span
          onClick={() => {
            setSelectedKeys([43]);
            confirm();
          }}
          id=""simulateOnSelect""
        >
          SimulateOnSelect
        </span>
      </div>
    );

    const wrapper = mount(
      createTable({
        columns: [
          {
            ...column,
            filterDropdown: filter,
          },
        ],
      }),
    );

    function getFilterMenu() {
      return wrapper.find('FilterDropdown');
    }

    // check if renderer well
    wrapper.find('span.ant-dropdown-trigger').simulate('click', nativeEvent);
    expect(wrapper.find('#customFilter')).toMatchSnapshot();

    // try to use reset btn
    expect(getFilterMenu().props().filterState.filteredKeys).toBeFalsy();
    wrapper.find('#setSelectedKeys').simulate('click');
    wrapper.find('#confirm').simulate('click');
    expect(getFilterMenu().props().filterState.filteredKeys).toEqual([42]);
    wrapper.find('#reset').simulate('click');
    wrapper.find('#confirm').simulate('click');
    expect(getFilterMenu().props().filterState.filteredKeys).toBeFalsy();

    // try to use confirm btn
    wrapper.find('span.ant-dropdown-trigger').simulate('click', nativeEvent);
    wrapper.find('#setSelectedKeys').simulate('click');
    expect(getFilterMenu().find('Dropdown').first().props().visible).toBeTruthy();
    wrapper.find('#confirm').simulate('click');
    expect(getFilterMenu().props().filterState.filteredKeys).toEqual([42]);
    expect(getFilterMenu().find('Dropdown').first().props().visible).toBeFalsy();

    // Simulate onSelect, setSelectedKeys & confirm
    wrapper.find('span.ant-dropdown-trigger').simulate('click', nativeEvent);
    wrapper.find('#simulateOnSelect').simulate('click');
    expect(getFilterMenu().props().filterState.filteredKeys).toEqual([43]);
  });",""
"2104","ant-design/ant-design","index.test.js","  it('switcherIcon should be loading icon when loadData', () => {
    const onLoadData = () =>
      new Promise(resolve => {
        setTimeout(() => {
          resolve();
        }, 1000);
      });
    const wrapper = mount(
      <Tree switcherIcon=""switcherIcon"" defaultExpandAll loadData={onLoadData}>
        <TreeNode icon=""icon"">
          <TreeNode id=""node1"" title=""node1"" icon=""icon"" key=""0-0-2"" />
          <TreeNode id=""node2"" title=""node2"" key=""0-0-3"" />
        </TreeNode>
      </Tree>,
    );
    expect(wrapper.render()).toMatchSnapshot();
  });",""
"2107","ant-design/ant-design","index.test.js","    it('should `treeIcon` work', () => {
      const wrapper = mount(
        <TreeSelect treeIcon open>
          <TreeNode value=""parent 1"" title=""parent 1"" icon={<span>Bamboo</span>} />
        </TreeSelect>,
      );

      expect(wrapper.render()).toMatchSnapshot();
    });",""
"2191","ant-design/pro-components","pageContainer.test.tsx","  it('🐲 content is text and title is null', () => {
    const wrapper = render(<PageContainer content=""just so so"" />);
    expect(wrapper.asFragment()).toMatchSnapshot();

    const html2 = render(<PageContainer extraContent={<div>extraContent</div>} />);
    expect(html2.asFragment()).toMatchSnapshot();
  });",""
"2222","ant-design/pro-components","columnSetting.test.tsx","  it('🎏 columnsState use the column key or dataIndex as index name', async () => {
    const onChange = jest.fn();
    const html = render(
      <ProTable
        size=""small""
        columnsState={{
          onChange,
        }}
        columns={[
          {
            title: 'Name',
            key: 'name',
            dataIndex: 'name',
            copyable: true,
          },
          {
            title: 'Name2',
            dataIndex: 'name2',
          },
          {
            title: 'Name3',
            dataIndex: 'name3',
          },
          {
            valueType: 'option',
            render() {
              return null;
            },
          },
        ]}
        request={async () => {
          return {
            data: [
              {
                key: 1,
                name: `TradeCode ${1}`,
                name2: `TradeCode ${1}`,
                name3: `TradeCode ${1}`,
                createdAt: 1602572994055,
              },
            ],
            success: true,
          };
        }}
        rowKey=""key""
      />,
    );
    act(() => {
      html.baseElement.querySelector<HTMLDivElement>(`span[aria-label=""setting""]`)?.click();
    });
    await waitTime(200);
    act(() => {
      html.baseElement
        .querySelector<HTMLDivElement>(`.ant-pro-table-column-setting-action-rest-button`)
        ?.click();
    });

    act(() => {
      const input = html.baseElement
        ?.querySelector<HTMLDivElement>('.ant-pro-table-column-setting-title .ant-checkbox-wrapper')
        ?.querySelector<HTMLInputElement>('.ant-checkbox-input');
      input?.click();
    });

    act(() => {
      html.baseElement
        .querySelector<HTMLDivElement>(`.ant-pro-table-column-setting-action-rest-button`)
        ?.click();
    });

    expect(onChange).toBeCalledTimes(2);
    expect((onChange.mock as any).lastCall[0]).toMatchInlineSnapshot(`
      {
        ""3"": {
          ""disable"": undefined,
          ""fixed"": undefined,
          ""show"": true,
        },
        ""name"": {
          ""disable"": undefined,
          ""fixed"": undefined,
          ""show"": true,
        },
        ""name2"": {
          ""disable"": undefined,
          ""fixed"": undefined,
          ""show"": true,
        },
        ""name3"": {
          ""disable"": undefined,
          ""fixed"": undefined,
          ""show"": true,
        },
      }
    `);
  });",""
"2285","apollographql/apollo-tooling","check.test.ts","        it(""--json"", async () => {
          captureApplicationOutput();
          mockPartialSchemaCheckFailure();

          expect.assertions(2);

          // JSON formatted output should not throw
          await expect(
            ServiceCheck.run([
              ...cliKeyParameter,
              ""--serviceName=accounts"",
              `--endpoint=${localURL}/graphql`,
              ""--json"",
            ])
          ).resolves.not.toThrow();

          // Inline snapshots don't work here due to https://github.com/facebook/jest/issues/6744.
          expect(uncaptureApplicationOutput()).toMatchSnapshot();
        });",""
"2406","apollographql/apollo-tooling","codeGeneration.ts","  test(""query with fragment spreads"", () => {
    const context = compile(`
      fragment simpleFragment on Character {
        name
      }

      query HeroFragment($episode: Episode) {
        hero(episode: $episode) {
          ...simpleFragment
          id
        }
      }
    `);

    const output = generateLocalSource(context).map((f) => ({
      ...f,
      content: f.content({
        outputPath: ""/some/file/ComponentA.tsx"",
        globalSourcePath: ""/__generated__/globalTypes.ts"",
      }),
    }));
    expect(output).toMatchSnapshot();
    expect(generateGlobalSource(context)).toMatchSnapshot();
  });",""
"2588","artsy/eigen","routes.tests.ts","  it(""routes to MyCollection"", () => {
    expect(matchRoute(""/my-collection"")).toMatchInlineSnapshot(`
      Object {
        ""module"": ""MyCollection"",
        ""params"": Object {},
        ""type"": ""match"",
      }
    `)
  })",""
"2688","atomiks/tippyjs","createTippy.test.js","  it('returns the instance with expected properties', () => {
    instance = createTippy(h(), defaultProps);

    expect(instance).toMatchSnapshot();
  });",""
"2689","atomiks/tippyjs","inlinePositioning.test.js","  it('does not have its popper modifier removed when updating popperOptions', () => {
    const instance = tippy(h());

    instance.setProps({
      popperOptions: {},
    });

    expect(instance.props.popperOptions).toMatchSnapshot();
  });",""
"2803","auth0/lock","login_pane.test.jsx","  it('shows username pane when user usernameStyle !== email', () => {
    expectComponent(<LoginPane {...defaultProps} usernameStyle=""any"" />).toMatchSnapshot();
    expectComponent(<LoginPane {...defaultProps} usernameStyle=""username"" />).toMatchSnapshot();
  });",""
"2833","auth0/lock","social_buttons_pane.test.jsx","  it('calls `logIn` with social connection 1 when first button is clicked', () => {
    let SocialButtonsPane = getComponent();

    const wrapper = mount(<SocialButtonsPane {...defaultProps} />);
    const props = extractPropsFromWrapper(wrapper, 2);

    props.onClick();

    const { mock } = require('quick-auth/actions').logIn;
    expect(mock.calls.length).toBe(1);
    expect(mock.calls[0]).toMatchSnapshot();
  });",""
"2835","auth0/lock","username.test.js","    it(`returns database connection's username validation`, () => {
      expect(
        username.getUsernameValidation(
          Immutable.fromJS({
            validation: {
              username: { min: 1, max: 2 }
            }
          })
        )
      ).toMatchSnapshot();
    });",""
"2975","automattic/wp-calypso","create-explat-client.ts","	it( 'should log and return fallback when given an invalid name', () => {
		const mockedConfig = createMockedConfig();
		const client = createExPlatClient( mockedConfig );
		const firstNow = Date.now();
		spiedMonotonicNow.mockImplementationOnce( () => firstNow );
		expect( client.dangerouslyGetExperimentAssignment( '' ) ).toEqual( {
			experimentName: '',
			retrievedTimestamp: firstNow,
			ttl: 60,
			variationName: null,
			isFallbackExperimentAssignment: true,
		} );
		expect( ( mockedConfig.logError as MockedFunction ).mock.calls ).toMatchInlineSnapshot( `
		Array [
		  Array [
		    Object {
		      ""experimentName"": """",
		      ""message"": ""Invalid experimentName: "",
		      ""source"": ""dangerouslyGetExperimentAssignment-error"",
		    },
		  ],
		]
	` );
	} );",""
"2976","automattic/wp-calypso","create-explat-client.ts","	it( `should log and return fallback when the matching experiment hasn't loaded yet`, () => {
		const mockedConfig = createMockedConfig();
		const client = createExPlatClient( mockedConfig );
		const firstNow = Date.now();
		spiedMonotonicNow.mockImplementationOnce( () => firstNow );
		expect( client.dangerouslyGetExperimentAssignment( 'experiment_name_a' ) ).toEqual( {
			experimentName: 'experiment_name_a',
			retrievedTimestamp: firstNow,
			ttl: 60,
			variationName: null,
			isFallbackExperimentAssignment: true,
		} );
		expect( ( mockedConfig.logError as MockedFunction ).mock.calls ).toMatchInlineSnapshot( `
		Array [
		  Array [
		    Object {
		      ""experimentName"": ""experiment_name_a"",
		      ""message"": ""Trying to dangerously get an ExperimentAssignment that hasn't loaded."",
		      ""source"": ""dangerouslyGetExperimentAssignment-error"",
		    },
		  ],
		]
	` );
	} );",""
"3076","awslabs/diagram-maker","hierarchicalLayout.spec.ts","  it('handles nodes with varying sizes', () => {
    let graph = fromAdjacencyList({
      'node-start': ['node-1'],
      'node-1': ['node-2'],
      'node-2': [],
    });
    graph = produce(graph, (draft) => {
      draft.nodes['node-start'].diagramMakerData.position = { x: 300, y: 300 };

      draft.nodes['node-start'].diagramMakerData.size = { width: 150, height: 10 };
      draft.nodes['node-1'].diagramMakerData.size = { width: 20, height: 80 };
      draft.nodes['node-2'].diagramMakerData.size = { width: 50, height: 50 };
    });
    const layoutConfig: HierarchicalLayoutConfig = {
      layoutType: LayoutType.HIERARCHICAL,
      fixedNodeIds: ['node-start'],
      distanceMin: 100,
      distanceMax: 100,
      gravityAngle: 0,
    };

    expect(hierarchicalLayout(graph, layoutConfig)).toMatchSnapshot();
  });",""
"3421","baidu/amis","Image.test.tsx","  test('images:enlargeAble & originalSrc & source & title & description', async () => {
    const {container, baseElement} = render(
      amisRender({
        type: 'page',
        data: {
          images: [
            {
              image:
                'https://internal-amis-res.cdn.bcebos.com/images/2020-1/1578395692722/4f3cb4202335.jpeg@s_0,w_216,l_1,f_jpg,q_80',
              src: 'https://internal-amis-res.cdn.bcebos.com/images/2020-1/1578395692722/4f3cb4202335.jpeg',
              title: '图片1',
              description: '图片1的描述'
            },
            {
              image:
                'https://internal-amis-res.cdn.bcebos.com/images/2020-1/1578395692942/d8e4992057f9.jpeg@s_0,w_216,l_1,f_jpg,q_80',
              src: 'https://internal-amis-res.cdn.bcebos.com/images/2020-1/1578395692942/d8e4992057f9.jpeg',
              title: '图片2',
              description: '图片2的描述'
            },
            {
              image:
                'https://internal-amis-res.cdn.bcebos.com/images/2020-1/1578395693148/1314a2a3d3f6.jpeg@s_0,w_216,l_1,f_jpg,q_80',
              src: 'https://internal-amis-res.cdn.bcebos.com/images/2020-1/1578395693148/1314a2a3d3f6.jpeg',
              title: '图片3',
              description: '图片3的描述'
            }
          ]
        },
        body: {
          type: 'images',
          source: '${images}',
          originalSrc: '${source}',
          enlargeAble: true
        }
      })
    );

    expect(container).toMatchSnapshot();
    expect(
      container.querySelectorAll('.cxd-Images .cxd-Images-item')!.length
    ).toBe(3);

    fireEvent.mouseEnter(
      container.querySelector(
        '.cxd-Images .cxd-Images-item .cxd-Image-thumbWrap'
      )!
    );

    fireEvent.click(container.querySelector('.cxd-Image-overlay a icon-mock')!);

    expect(
      baseElement.querySelectorAll(
        '.cxd-ImageGallery-footer .cxd-ImageGallery-itemsWrap .cxd-ImageGallery-item'
      )!.length
    ).toBe(3);
  });",""
"3447","baidu/amis","Page.test.tsx","test('Renderer:Page classNames', async () => {
  const {container, getByText, getByTestId} = render(
    amisRender({
      type: 'page',
      title: 'This is Title',
      subTitle: 'This is SubTitle',
      remark: 'Remark Text',
      toolbar: 'This is toolbar',
      body: 'This is body',
      aside: 'This is aside',

      headerClassName: 'header-class-name',
      bodyClassName: 'body-class-name',
      asideClassName: 'aside-class-name',
      toolbarClassName: 'toolbar-class-name'
    })
  );
  await waitFor(() => {
    expect(getByText('This is body')).toBeInTheDocument();
  });

  expect(container).toMatchSnapshot();
});",""
"3583","balajmarius/svg2jsx","transform.spec.js","  test('convert nested nodes', async () => {
    const transformed = await transform(`
      <svg id=""Layer_1"" xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 45 45"">
        <defs>
          <clipPath id=""svg-test"">
            <path style=""margin-left: auto;"" d=""M43,24c1.1-1.5,2.3-3""/>
          </clipPath>
        </defs>
        <circle cx=""110"" cy=""110"" r=""100"" fill=""#9c6"" clip-path=""url(#svg-test)"" />
      </svg>      
    `);

    expect(transformed.match(/>\s*>/gm)).toBeFalsy();
    expect(transformed.match(/<svg/g)).toHaveLength(1);
    expect(transformed.match(/<\/svg/g)).toHaveLength(1);
    expect(transformed.match(/<defs/g)).toHaveLength(1);
    expect(transformed.match(/<\/defs/g)).toHaveLength(1);
    expect(transformed).toMatchSnapshot();
  });",""
"3654","bearer/pizzly","index.test.ts","    it('throws an InvalidGrantType error', async () => {
      const test = setup('invalid' as GrantType)

      await test.get().expect(422)

      expect(test.err).toMatchSnapshot()
    })",""
"3689","boostio/boostnote-legacy","markdown.test.js","test('Markdown.render() should renders KaTeX correctly', () => {
  const rendered = md.render(markdownFixtures.katex)
  expect(rendered).toMatchSnapshot()
})",""
"3715","boostio/boostnote","markdown.test.js","test('Markdown.render() should renders definition lists correctly', () => {
  const rendered = md.render(markdownFixtures.deflists)
  expect(rendered).toMatchSnapshot()
})",""
"3738","brimdata/zui","get-persistable.test.ts","test(""global persist"", () => {
  store.dispatch(
    Lakes.add({
      id: ""1"",
      authType: ""auth0"",
      host: ""me.com"",
      port: ""123"",
      name: ""test"",
      authData: {
        audience: ""a"",
        clientId: ""1"",
        accessToken: ""SECRET"",
        domain: ""me.com"",
      },
    })
  )
  const persist = getPersistedGlobalState(store.getState())
  const persistedLake = Lakes.id(""1"")(persist)
  expect(persistedLake.authData).toMatchInlineSnapshot(`
    Object {
      ""audience"": ""a"",
      ""clientId"": ""1"",
      ""domain"": ""me.com"",
    }
  `)
  expect(Object.keys(persist)).toEqual(GLOBAL_PERSIST)
})",""
"3739","btd/rollup-plugin-visualizer","sourcemap.test.ts","    it(""test"", async () => {
      const inputOptions = {
        input,
        plugins: [
          visualizer({
            filename: `stats`,
            template: 'raw-data',
            emitFile: true,
            sourcemap: true,
            brotliSize: true,
            gzipSize: true
          }),
        ],
      };
      const outputOptions: OutputOptions = {
        format: ""es"",
        dir: ""./temp/"",
        sourcemap: true
      };
  
      const bundle = await rollup(inputOptions);
  
      const result = await bundle.generate(outputOptions);

      const bundleChunk = result.output.find(file => file.fileName === ""index.js"")

      expect(bundleChunk).not.toBeNull();
      const bundleChunkCode = (bundleChunk as OutputChunk).code
      expect(bundleChunkCode).toMatchSnapshot();
      expect(Buffer.byteLength(bundleChunkCode)).toMatchSnapshot();
  
      const generatedStats = result.output.find((file) => file.fileName === ""stats"");
  
      expect(generatedStats).not.toBeNull();
      expect((generatedStats as OutputAsset).source).toMatchSnapshot();
    });",""
"3831","callstack/react-native-paper","Button.test.tsx","it('renders disabled button', () => {
  const tree = render(<Button disabled>Disabled Button</Button>).toJSON();

  expect(tree).toMatchSnapshot();
});",""
"3870","callstack/react-native-paper","FAB.test.tsx","it('renders small FAB', () => {
  const tree = render(
    <FAB size=""small"" onPress={() => {}} icon=""plus"" />
  ).toJSON();

  expect(tree).toMatchSnapshot();
});",""
"3986","carbon-design-system/carbon-components-react","Breadcrumb.Skeleton-test.js","  it('should render', () => {
    const wrapper = mount(<BreadcrumbSkeleton />);
    expect(wrapper).toMatchSnapshot();
  });",""
"4209","cartodb/cartodb","SharedBrief.spec.js","  it('should render the text for groups', () => {
    const colleaguesData = [
      { type: 'group',
        entity: {
          name: 'grupoprueba'
        }
      }
    ];
    const sharedBrief = createSharedBriefComponent(colleaguesData);
    expect(sharedBrief).toMatchSnapshot();
  });",""
"4440","chakra-ui/chakra-ui","css.test.ts","test(""flexBasis uses theme.sizes"", () => {
  const style = css({
    flexBasis: ""sidebar"",
  })(toCSSVar(theme))
  expect(style).toMatchInlineSnapshot(`
    Object {
      ""flexBasis"": ""var(--sizes-sidebar)"",
    }
  `)
})",""
"4487","chakra-ui/chakra-ui","responsive.test.ts","test(""should work with createBreakpoint output"", () => {
  expect(
    analyzeBreakpoints({
      base: ""0em"",
      sm: ""320px"",
      md: ""640px"",
      lg: ""1000px"",
      xl: ""4000px"",
    })?.details,
  ).toMatchInlineSnapshot(`
    Array [
      Object {
        ""_minW"": ""-0.01em"",
        ""breakpoint"": ""base"",
        ""maxW"": ""319.98px"",
        ""maxWQuery"": ""@media screen and (max-width: 319.98px)"",
        ""minMaxQuery"": ""@media screen and (min-width: 0em) and (max-width: 319.98px)"",
        ""minW"": ""0em"",
        ""minWQuery"": ""@media screen and (min-width: 0em)"",
      },
      Object {
        ""_minW"": ""319.98px"",
        ""breakpoint"": ""sm"",
        ""maxW"": ""639.98px"",
        ""maxWQuery"": ""@media screen and (max-width: 639.98px)"",
        ""minMaxQuery"": ""@media screen and (min-width: 320px) and (max-width: 639.98px)"",
        ""minW"": ""320px"",
        ""minWQuery"": ""@media screen and (min-width: 320px)"",
      },
      Object {
        ""_minW"": ""639.98px"",
        ""breakpoint"": ""md"",
        ""maxW"": ""999.98px"",
        ""maxWQuery"": ""@media screen and (max-width: 999.98px)"",
        ""minMaxQuery"": ""@media screen and (min-width: 640px) and (max-width: 999.98px)"",
        ""minW"": ""640px"",
        ""minWQuery"": ""@media screen and (min-width: 640px)"",
      },
      Object {
        ""_minW"": ""999.98px"",
        ""breakpoint"": ""lg"",
        ""maxW"": ""3999.98px"",
        ""maxWQuery"": ""@media screen and (max-width: 3999.98px)"",
        ""minMaxQuery"": ""@media screen and (min-width: 1000px) and (max-width: 3999.98px)"",
        ""minW"": ""1000px"",
        ""minWQuery"": ""@media screen and (min-width: 1000px)"",
      },
      Object {
        ""_minW"": ""3999.98px"",
        ""breakpoint"": ""xl"",
        ""maxW"": undefined,
        ""maxWQuery"": ""@media screen"",
        ""minMaxQuery"": ""@media screen and (min-width: 4000px)"",
        ""minW"": ""4000px"",
        ""minWQuery"": ""@media screen and (min-width: 4000px)"",
      },
    ]
  `)
})",""
"4541","changesets/changesets","index.test.ts","test(""associated with multiple PRs with only one merged"", async () => {
  nock(""https://api.github.com"", {
    reqheaders: {
      Authorization: `Token ${process.env.GITHUB_TOKEN}`,
    },
  })
    .post(apiPath, ({ query }) => {
      expect(prettier.format(query, { parser: ""graphql"" }))
        .toMatchInlineSnapshot(`
        ""query {
          a0: repository(owner: ""emotion-js"", name: ""emotion"") {
            pr__1613: pullRequest(number: 1613) {
              url
              author {
                login
                url
              }
              mergeCommit {
                commitUrl
                abbreviatedOid
              }
            }
          }
        }
        ""
      `);
      return true;
    })
    .reply(
      200,
      JSON.stringify({
        data: {
          a0: {
            pr__1613: {
              url: ""https://github.com/emotion-js/emotion/pull/1613"",
              author: {
                login: ""Andarist"",
                url: ""https://github.com/Andarist"",
              },
              mergeCommit: {
                commitUrl:
                  ""https://github.com/emotion-js/emotion/commit/a085003d4c8ca284c116668d7217fb747802ed85"",
                abbreviatedOid: ""a085003"",
              },
            },
          },
        },
      })
    );
  let result = await getInfoFromPullRequest({
    pull: 1613,
    repo: ""emotion-js/emotion"",
  });
  expect(result).toMatchInlineSnapshot(`
    {
      ""commit"": ""a085003"",
      ""links"": {
        ""commit"": ""[\`a085003\`](https://github.com/emotion-js/emotion/commit/a085003d4c8ca284c116668d7217fb747802ed85)"",
        ""pull"": ""[#1613](https://github.com/emotion-js/emotion/pull/1613)"",
        ""user"": ""[@Andarist](https://github.com/Andarist)"",
      },
      ""user"": ""Andarist"",
    }
  `);
});",""
"4736","cloudflare/cf-ui","Text.js","test('should render lowercase', () => {
  const Text = applyTheme(TextUnstyled, () => ({
    textTransformLowercase: 'lowercase'
  }));

  const snapshot = felaSnapshot(<Text case=""lowercase"">Hello</Text>);
  expect(snapshot.component).toMatchSnapshot();
  expect(snapshot.styles).toMatchSnapshot();
});",""
"4802","coinbase/rest-hooks","endpoint.ts","    it('should use provided context in fetch and key', async () => {
      const UserCurrent = new Endpoint(fetchAuthd, { token: 'password', key });

      const response = await UserCurrent();
      expect(response).toEqual(payload);
      expect(response.username).toBe(payload.username);
      // @ts-expect-error
      expect(response.notexist).toBeUndefined();

      expect(UserCurrent.key()).toMatchInlineSnapshot(
        `""current user password""`,
      );
    });",""
"4852","coinbase/rest-hooks","normalizr.test.js","  test('denormalizes schema with extra members', () => {
    const entities = {
      Tacos: {
        1: { id: '1', type: 'foo' },
        2: { id: '2', type: 'bar' },
      },
    };
    expect(
      denormalize(
        {
          data: ['1', '2'],
          extra: '5',
          page: {
            first: null,
            second: { thing: 'two' },
            third: 1,
            complex: { complex: false, next: true },
          },
        },
        {
          data: [Tacos],
          extra: '',
          page: {
            first: null,
            second: undefined,
            third: 0,
            complex: { complex: true, next: false },
          },
        },
        entities,
      ),
    ).toMatchSnapshot();
  });",""
"4892","coinbase/rest-hooks","Entity.test.ts","    test('can use a custom merging strategy', () => {
      class MergeTaco extends Tacos {
        static merge<T extends typeof Entity>(
          this: T,
          existing: AbstractInstanceType<T>,
          incoming: AbstractInstanceType<T>,
        ) {
          const props = Object.assign({}, existing, incoming, {
            name: (existing as MergeTaco).name,
          });
          return this.fromJS(props);
        }
      }

      expect(
        normalize(
          [
            { id: '1', name: 'foo' },
            { id: '1', name: 'bar', alias: 'bar' },
          ],
          [MergeTaco],
        ),
      ).toMatchSnapshot();
    });",""
"4899","coinbase/rest-hooks","Entity.test.ts","  it('should handle optional schema entries Entity', () => {
    class MyEntity extends Entity {
      readonly name: string = '';
      readonly secondthing: string = '';
      readonly blarb: Date | undefined = undefined;
      pk() {
        return this.name;
      }

      static schema = {
        blarb: Date,
      };
    }
    const schema = MyEntity;

    expect(
      denormalize('bob', schema, {
        MyEntity: { bob: { name: 'bob', secondthing: 'hi' } },
      }),
    ).toMatchInlineSnapshot(`
      Array [
        MyEntity {
          ""blarb"": undefined,
          ""name"": ""bob"",
          ""secondthing"": ""hi"",
        },
        true,
        false,
      ]
    `);
  });",""
"4981","coinbase/rest-hooks","index.test.js","  test('denormalizes schema with extra members', () => {
    const entities = {
      Tacos: {
        1: { id: '1', type: 'foo' },
        2: { id: '2', type: 'bar' },
      },
    };
    expect(
      denormalize(
        {
          data: ['1', '2'],
          extra: '5',
          page: {
            first: null,
            second: { thing: 'two' },
            third: 1,
            complex: { complex: false, next: true },
          },
        },
        {
          data: [Tacos],
          extra: '',
          page: {
            first: null,
            second: undefined,
            third: 0,
            complex: { complex: true, next: false },
          },
        },
        entities,
      ),
    ).toMatchSnapshot();
  });",""
"5030","couds/react-bulma-components","button.test.js","  it('Should render focused state', () => {
    const component = renderer.create(<Button status=""focused"" />);
    expect(component.toJSON()).toMatchSnapshot();
  });",""
"5037","couds/react-bulma-components","button.test.js","    it('Should group buttons together', () => {
      const component = renderer.create(
        <Button.Group hasAddons>
          <Button>test 1</Button>
          <Button>test 2</Button>
        </Button.Group>,
      );
      expect(component.toJSON()).toMatchSnapshot();
    });",""
"5160","couds/react-bulma-components","level.test.js","  it('Should have is-mobile class if mobile prop is true', () => {
    const component = renderer.create(
      <Level breakpoint=""mobile"">
        <Level.Side>
          <Level.Item>Item 1</Level.Item>
          <Level.Item>Item 2</Level.Item>
        </Level.Side>
        <Level.Side align=""right"">
          <Level.Item>Item 3</Level.Item>
        </Level.Side>
      </Level>,
    );
    expect(component.toJSON()).toMatchSnapshot();
  });",""
"5330","danger/danger-js","_bitbucket_cloud_git.test.ts","  it(""shows the diff for a specific file"", async () => {
    const { diff } = (await gitDSL.diffForFile(""tsconfig.json""))!

    expect(stripWhitespaceForSnapshot(diff)).toMatchSnapshot()
  })",""
"5348","danger/danger-js","_github_git.test.ts","  it(""show diff chunks for a specific file"", async () => {
    const { chunks } = (await gitDSL.structuredDiffForFile(""tsconfig.json""))!

    expect(chunks).toMatchSnapshot()
  })",""
"5401","danilowoz/react-content-loader","ListStyle.test.tsx","  test('renders correctly', () => {
    const tree = wrapper.toJSON()

    expect(tree).toMatchSnapshot()
  })",""
"5540","denisraslov/react-spreadsheet-grid","ScrollDummy.js","test('ScrollDummy with rows', () => {
  const ref = React.createRef()
  const tree = renderer
    .create(
      <ScrollDummy
        headerHeight={50}
        rowHeight={50}
        rows={[1, 2, 3]}
        refEl={ref}
      />
    )
    .toJSON()

  expect(tree).toMatchSnapshot()
})",""
"5621","diegomura/react-pdf","resolvePercentHeight.test.js","  test('Should keep empty page untouched', () => {
    const root = {
      type: 'DOCUMENT',
      children: [{ type: 'PAGE' }],
    };
    const result = resolvePercentHeight(root);

    expect(result).toMatchSnapshot();
  });",""
"5686","downshift-js/downshift","set-a11y-status.js","test('replaces the status with a different one', () => {
  const setA11yStatus = setup()
  setA11yStatus('hello')
  setA11yStatus('goodbye')
  expect(document.body.firstChild).toMatchSnapshot()
})",""
"5694","ealush/vest","cascade.test.ts","    it('Maintains normal context behavior when runs within context.run', () => {
      return new Promise<void>(done => {
        const fn = () => {
          expect(ctx.use()).toMatchObject({ value: 200, value2: 300 });
          expect(ctx.use()).toMatchInlineSnapshot(`
            Object {
              ""value"": 200,
              ""value2"": 300,
            }
          `);
          done();
        };

        const bound = ctx.bind({ value2: 300 }, fn);
        ctx.run({ value: 200, value2: 200 }, bound);
      });
    });",""
"5729","ealush/vest","include.test.ts","          it('Should skip run included field', () => {
            const suite = vest.create(() => {
              vest.only('field_1');
              vest.include('field_2').when(false);

              vest.test('field_1', () => false);
              vest.test('field_2', () => false);
              vest.test('field_3', () => false);
            });

            const res = suite();
            expect(res.hasErrors('field_1')).toBe(true);
            expect(res.tests.field_1.testCount).toBe(1);
            expect(res.hasErrors('field_2')).toBe(false);
            expect(res.tests.field_2.testCount).toBe(0);
            expect(res.hasErrors('field_3')).toBe(false);
            expect(res.tests.field_3.testCount).toBe(0);
            expect(res).toMatchSnapshot();
          });",""
"5843","effector/effector","di.test.ts","test('effect.create multiple arguments', async () => {
  const useSpy = jest.fn()
  const baz = jest.fn()
  const effect = variadicEffect('long request')

  //@ts-expect-error
  effect.use(async (a, b) => {
    useSpy({a, b})
    await 1
    return 'done!'
  })
  effect.done.watch(baz)

  await effect(100, 200)
  await effect(200, 300)
  await effect(300, 400)

  expect(effect.create.mock.calls).toMatchInlineSnapshot(`
    Array [
      Array [
        100,
        Array [
          200,
        ],
      ],
      Array [
        200,
        Array [
          300,
        ],
      ],
      Array [
        300,
        Array [
          400,
        ],
      ],
    ]
  `)
  expect(argumentHistory(useSpy)).toMatchInlineSnapshot(`
    Array [
      Object {
        ""a"": 100,
        ""b"": 200,
      },
      Object {
        ""a"": 200,
        ""b"": 300,
      },
      Object {
        ""a"": 300,
        ""b"": 400,
      },
    ]
  `)
  expect(argumentHistory(baz)).toMatchInlineSnapshot(`
    Array [
      Object {
        ""params"": Array [
          100,
          200,
        ],
        ""result"": ""done!"",
      },
      Object {
        ""params"": Array [
          200,
          300,
        ],
        ""result"": ""done!"",
      },
      Object {
        ""params"": Array [
          300,
          400,
        ],
        ""result"": ""done!"",
      },
    ]
  `)
})",""
"5844","effector/effector","index.test.ts","  test(`if used function will resolve`, async () => {
    const fn = jest.fn()
    const effect = createEffect({
      async handler({fail}) {
        if (fail) throw Error('[expected error]')
        return 'done!'
      },
    })
    effect.finally.watch(e => fn(e))
    await effect({fail: false})
    expect(argumentHistory(fn)).toMatchInlineSnapshot(`
      Array [
        Object {
          ""params"": Object {
            ""fail"": false,
          },
          ""result"": ""done!"",
          ""status"": ""done"",
        },
      ]
    `)
  })",""
"6008","effector/effector","list.test.ts","  it('works with keyed list', async () => {
    const [s1, s2] = await exec(async () => {
      type User = {
        team: 'a' | 'b'
        name: string
      }
      const setTeam = createEvent<'a' | 'b'>()
      const currentTeam = restore(setTeam, 'a')
      const users = createStore<User[]>([
        {name: 'alice', team: 'a'},
        {name: 'bob', team: 'b'},
        {name: 'carol', team: 'b'},
        {name: 'dave', team: 'a'},
        {name: 'eve', team: 'a'},
      ])

      using(el, () => {
        list(
          {source: users, key: 'name', fields: ['name', 'team']},
          ({fields: [name, team]}) => {
            h('p', () => {
              spec({
                visible: combine(
                  currentTeam,
                  team,
                  (current, team) => team === current,
                ),
              })
              h('div', {text: name})
              h('div', {text: team})
            })
          },
        )
      })
      await act()
      await act(() => {
        setTeam('b')
      })
    })
    expect(s1).toMatchInlineSnapshot(
      `""<p><div>alice</div><div>a</div></p><p><div>dave</div><div>a</div></p><p><div>eve</div><div>a</div></p>""`,
    )
    expect(s2).toMatchInlineSnapshot(
      `""<p><div>bob</div><div>b</div></p><p><div>carol</div><div>b</div></p>""`,
    )
  })",""
"6009","effector/effector","list.test.ts","it('create list from [fn] option', async () => {
  const [s1] = await exec(async () => {
    const users = createStore([
      {name: 'alice', id: 1},
      {name: 'bob', id: 2},
    ])

    using(el, () => {
      list({
        source: users,
        key: 'id',
        fn: ({store}) => {
          h('li', {text: store.map(v => v.name)})
        },
      })
    })
    await act()
  })
  expect(s1).toMatchInlineSnapshot(`
    ""
    <li>alice</li>
    <li>bob</li>
    ""
  `)
})",""
"6174","effector/effector","computeVariants.test.ts","test('unused match', () => {
  const suite = suiteGenerator(() => {
    const source = union(['event', 'store'], 'source')
    const clock = union(['store', 'event', 'none '], 'clock')
    const feature = union(['a', 'b', 'c'], 'feature')

    const tag = computeVariants({
      name: 'tag',
      source: {source, clock, feature},
      variant: {
        base: {
          events: {source: 'event', clock: 'event'},
          noClock: {clock: 'none '},
          sourceStore: {source: 'store'},
          rest: {},
        },
        byFeature: {
          aBranch: {feature: 'a'},
          bBranch: {feature: 'b'},
        },
      },
      cases: {
        events: 'events only',
        noClock: {
          aBranch: 'no a clock',
          bBranch: 'no b clock',
        },
        sourceStore: 'source store',
        rest: {
          aBranch: 'rest a',
          bBranch: 'rest b',
        },
      },
    })
    config({
      grouping: {
        getHash: [source, clock, feature],
        describeGroup: value(''),
        pass: value(true),
        createTestLines: {
          type: 'table',
          fields: [source, clock, feature, tag],
        },
      },
    })
  })
  expect(suite).toMatchInlineSnapshot(`
    ""
    ## pass
    * source * clock * feature * tag          * 
    | event  | store | a       | rest a       | 
    | event  | store | b       | rest b       | 
    | event  | store | c       |              | 
    | event  | event | a       | events only  | 
    | event  | event | b       | events only  | 
    | event  | event | c       | events only  | 
    | event  | none  | a       | no a clock   | 
    | event  | none  | b       | no b clock   | 
    | event  | none  | c       |              | 
    | store  | store | a       | source store | 
    | store  | store | b       | source store | 
    | store  | store | c       | source store | 
    | store  | event | a       | source store | 
    | store  | event | b       | source store | 
    | store  | event | c       | source store | 
    | store  | none  | a       | no a clock   | 
    | store  | none  | b       | no b clock   | 
    | store  | none  | c       | source store | 
    ""
  `)
})",""
"6180","effector/effector","separate.test.ts","test('rest match', () => {
  const suite = suiteGenerator(() => {
    const source = union(['event', 'store'], 'source')
    const clock = union(['store', 'event', 'none '], 'clock')
    const feature = union(['a', 'b', 'c'], 'feature')

    const tag = separate({
      name: 'tag',
      source: {source, clock, feature},
      variant: {
        base: {
          events: {source: 'event', clock: 'event'},
          noClock: {clock: 'none '},
          sourceStore: {source: 'store'},
          rest: {},
        },
        byFeature: {
          aBranch: {feature: 'a'},
          restBranch: {},
        },
      } as const,
      cases: {
        events: value('events only'),
        noClock: {
          aBranch: value('no a clock'),
          restBranch: value('no b|c clock'),
        },
        sourceStore: value('source store'),
        rest: {
          aBranch: value('rest a'),
          restBranch: value('rest b|c'),
        },
      },
    })
    config({
      grouping: {
        getHash: [source, clock, feature],
        describeGroup: value(''),
        pass: value(true),
        createTestLines: {
          type: 'table',
          fields: [source, clock, feature, tag],
        },
      },
    })
  })

  expect(suite).toMatchInlineSnapshot(`
    ""
    ## pass
    * source * clock * feature * tag          * 
    | event  | store | a       | rest a       | 
    | event  | store | b       | rest b|c     | 
    | event  | store | c       | rest b|c     | 
    | event  | event | a       | events only  | 
    | event  | event | b       | events only  | 
    | event  | event | c       | events only  | 
    | event  | none  | a       | no a clock   | 
    | event  | none  | b       | no b|c clock | 
    | event  | none  | c       | no b|c clock | 
    | store  | store | a       | source store | 
    | store  | store | b       | source store | 
    | store  | store | c       | source store | 
    | store  | event | a       | source store | 
    | store  | event | b       | source store | 
    | store  | event | c       | source store | 
    | store  | none  | a       | no a clock   | 
    | store  | none  | b       | no b|c clock | 
    | store  | none  | c       | no b|c clock | 
    ""
  `)
})",""
"6388","effector/effector","guard.test.ts","    test('unit -> unit wide (should pass)', () => {
      //prettier-ignore
      {
        guard({source:ab        , target:aNum, filter:(val) => val.a > 0})
        guard({source:ab        , target:aNum, filter:$filter           })
        guard({source:ab        , target:aNum, filter:Boolean           })
        guard({source:nullableAB, target:aNum, filter:Boolean           })
      }
      expect(typecheck).toMatchInlineSnapshot(`
        ""
        no errors
        ""
      `)
    })",""
"6396","effector/effector","guard.test.ts","    test('unit -> array wide (should pass)', () => {
      //prettier-ignore
      {
        guard({source:ab        , target:[aNum]           , filter:(val) => val.a > 0})
        guard({source:ab        , target:[aNum,anyt]      , filter:(val) => val.a > 0})
        guard({source:ab        , target:[aNum,voidt]     , filter:(val) => val.a > 0})
        guard({source:ab        , target:[aNum,anyt,voidt], filter:(val) => val.a > 0})
        guard({source:ab        , target:[aNum]           , filter:$filter           })
        guard({source:ab        , target:[aNum,anyt]      , filter:$filter           })
        guard({source:ab        , target:[aNum,voidt]     , filter:$filter           })
        guard({source:ab        , target:[aNum,anyt,voidt], filter:$filter           })
        guard({source:ab        , target:[aNum]           , filter:Boolean           })
        guard({source:ab        , target:[aNum,anyt]      , filter:Boolean           })
        guard({source:ab        , target:[aNum,voidt]     , filter:Boolean           })
        guard({source:ab        , target:[aNum,anyt,voidt], filter:Boolean           })
        guard({source:nullableAB, target:[aNum]           , filter:Boolean           })
        guard({source:nullableAB, target:[aNum,anyt]      , filter:Boolean           })
        guard({source:nullableAB, target:[aNum,voidt]     , filter:Boolean           })
        guard({source:nullableAB, target:[aNum,anyt,voidt], filter:Boolean           })
      }
      expect(typecheck).toMatchInlineSnapshot(`
        ""
        no errors
        ""
      `)
    })",""
"6527","effector/effector","sampleFilter.test.ts","    test('[clock] -> unit same (should pass)', () => {
      //prettier-ignore
      {
        sample({clock:[ab,nullableAB], target:$ab, filter:Boolean                         })
        sample({clock:[ab,nullableAB], target:$ab, filter:(clk): clk is AB => clk !== null})
      }
      expect(typecheck).toMatchInlineSnapshot(`
        ""
        no errors
        ""
      `)
    })",""
"6685","effector/effector","arrayTarget.test.ts","  test('{ source: [$num], clock: any, target: [l_num] } (should pass)', () => {
    const $num = createStore<number>(0)
    const l_num = createEvent<[number]>()
    const anyt = createEvent<any>()

    sample({source: [$num], clock: anyt, target: [l_num]})

    expect(typecheck).toMatchInlineSnapshot(`
      ""
      Argument of type '{ source: Store<number>[]; clock: Event<any>; target: Event<[number]>[]; }' is not assignable to parameter of type '{ error: \\""source should extend target type\\""; targets: { sourceType: number[]; targetType: [number]; }[]; }'.
        Object literal may only specify known properties, and 'source' does not exist in type '{ error: \\""source should extend target type\\""; targets: { sourceType: number[]; targetType: [number]; }[]; }'.
      ""
    `)
  })",""
"6706","effector/effector","clockArray.test.ts","  it('with fn (should pass)', () => {
    const source = createStore({a: '', b: ''})
    const clockA = createEvent()
    const clockB = createEvent<any>()
    const clockC = createEvent<string>()

    const target1 = sample({
      source,
      clock: [clockA, clockB, clockC],
      fn: ({a, b}, clock) => ({a, b, clock}),
    })
    const target2: Event<{a: string; b: string; clock: any}> = sample({
      source,
      clock: [clockA, clockB, clockC],
      fn: ({a, b}, clock) => ({a, b, clock}),
    })
    const target3: Event<{a: string; b: string; clock: any}> = sample({
      source,
      clock: [clockA, clockB, clockC],
      fn: ({a, b}: {a: string; b: string}, clock: any) => ({a, b, clock}),
    })
    expect(typecheck).toMatchInlineSnapshot(`
      ""
      no errors
      ""
    `)
  })",""
"6797","effector/effector","sampleFilterOther.test.ts","  test('filter infer + target', () => {
    const clock = createEvent<number | null>()
    const source = createEvent<number | null>()
    sample({
      clock,
      source,
      filter: (arg): arg is number => typeof arg === 'number',
      fn: () => 'ok',
      target,
    })
    sample({
      clock,
      filter: (arg): arg is number => typeof arg === 'number',
      fn: () => 'ok',
      target,
    })
    sample({
      source,
      filter: (arg): arg is number => typeof arg === 'number',
      fn: () => 'ok',
      target,
    })
    expect(typecheck).toMatchInlineSnapshot(`
      ""
      no errors
      ""
    `)
  })",""
"6840","effector/effector","sampleFilter.test.ts","      test('type mismatch (should fail)', () => {
        const trigger = createEvent<number>()
        const target = createStore<string>('no')

        sample({
          //@ts-expect-error
          source: trigger,
          filter: x => x > 0,
          target,
        })
        expect(typecheck).toMatchInlineSnapshot(`
          ""
          Argument of type '{ source: Event<number>; filter: (x: number) => boolean; target: Store<string>; }' is not assignable to parameter of type '{ error: \\""source should extend target type\\""; targets: { sourceType: number; targetType: string; }; }'.
            Object literal may only specify known properties, and 'source' does not exist in type '{ error: \\""source should extend target type\\""; targets: { sourceType: number; targetType: string; }; }'.
          ""
        `)
      })",""
"6917","effector/effector","split.test.ts","    test('case name: match == cases, type: source != cases, array case + unit case (should fail)', () => {
      const source = createEvent<{foo: 1}>()
      const $case = createStore<'a' | 'b'>('a')
      const a = createEvent<{foo: 2}>()
      const b = createEvent<{foo: 2}>()
      split({
        //@ts-expect-error
        source,
        match: $case,
        cases: {
          a: [a],
          b,
        },
      })
      expect(typecheck).toMatchInlineSnapshot(`
        ""
        Argument of type '{ source: Event<{ foo: 1; }>; match: Store<\\""a\\"" | \\""b\\"">; cases: { a: Event<{ foo: 2; }>[]; b: Event<{ foo: 2; }>; }; }' is not assignable to parameter of type '{ error: \\""source type should extends cases\\""; sourceType: { foo: 1; }; caseType: { foo: 2; } | { foo: 2; }; }'.
          Object literal may only specify known properties, and 'source' does not exist in type '{ error: \\""source type should extends cases\\""; sourceType: { foo: 1; }; caseType: { foo: 2; } | { foo: 2; }; }'.
        ""
      `)
    })",""
"6943","effector/effector","split.test.ts","    test('case name: match > cases, type: source != cases, array case + unit case (should fail)', () => {
      const source = createEvent<{foo: 1}>()
      const a = createEvent<{foo: 2}>()
      const b = createEvent<{foo: 2}>()
      split({
        //@ts-expect-error
        source,
        //@ts-expect-error src is any
        match: (src): 'a' | 'b' | 'c' => 'a',
        cases: {
          a: [a],
          b,
        },
      })
      expect(typecheck).toMatchInlineSnapshot(`
        ""
        Argument of type '{ source: Event<{ foo: 1; }>; match: (src: any) => \\""a\\"" | \\""b\\"" | \\""c\\""; cases: { a: Event<{ foo: 2; }>[]; b: Event<{ foo: 2; }>; }; }' is not assignable to parameter of type '{ error: \\""source type should extends cases\\""; sourceType: { foo: 1; }; caseType: { foo: 2; } | { foo: 2; }; }'.
          Object literal may only specify known properties, and 'source' does not exist in type '{ error: \\""source type should extends cases\\""; sourceType: { foo: 1; }; caseType: { foo: 2; } | { foo: 2; }; }'.
        Parameter 'src' implicitly has an 'any' type.
        ""
      `)
    })",""
"7223","elastic/kibana","run.test.ts","test('excludes projects if multiple `exclude` filter are specified', async () => {
  await runCommand(command, {
    ...config,
    options: { exclude: ['foo', 'bar', 'baz'] },
  });

  expect(command.run).toHaveBeenCalledTimes(1);
  expect(getExpectedProjectsAndGraph(command.run)).toMatchSnapshot();
});",""
"7267","elastic/kibana","args.test.js","  it('displays as expected', () => {
    expect(displayHelp()).toMatchSnapshot();
  });",""
"7324","elastic/kibana","router.test.tsx","  it('can navigate between two applications with custom appRoutes', async () => {
    const chromelessAppA = mounters.get('app3')!;
    const chromelessAppB = mounters.get('app4')!;
    let dom = await navigate('/chromeless-a/path');

    expect(chromelessAppA.mounter.mount).toHaveBeenCalled();
    expect(dom?.html()).toMatchInlineSnapshot(`
      ""<span class=\\""euiLoadingElastic euiLoadingElastic--xxLarge appContainer__loading\\"" aria-label=\\""Loading application\\""><span data-euiicon-type=\\""logoElastic\\""></span></span><div class=\\""kbnAppWrapper\\"" aria-busy=\\""false\\""><div>
      basename: /chromeless-a/path
      html: <div>Chromeless A</div>
      </div></div>""
    `);

    const chromelessAppAUnmount = await getUnmounter(chromelessAppA);
    dom = await navigate('/chromeless-b/path');

    expect(chromelessAppAUnmount).toHaveBeenCalled();
    expect(chromelessAppB.mounter.mount).toHaveBeenCalled();
    expect(dom?.html()).toMatchInlineSnapshot(`
      ""<span class=\\""euiLoadingElastic euiLoadingElastic--xxLarge appContainer__loading\\"" aria-label=\\""Loading application\\""><span data-euiicon-type=\\""logoElastic\\""></span></span><div class=\\""kbnAppWrapper\\"" aria-busy=\\""false\\""><div>
      basename: /chromeless-b/path
      html: <div>Chromeless B</div>
      </div></div>""
    `);

    const chromelessAppBUnmount = await getUnmounter(chromelessAppB);
    dom = await navigate('/chromeless-a/path');

    expect(chromelessAppBUnmount).toHaveBeenCalled();
    expect(chromelessAppA.mounter.mount).toHaveBeenCalledTimes(2);
    expect(dom?.html()).toMatchInlineSnapshot(`
      ""<span class=\\""euiLoadingElastic euiLoadingElastic--xxLarge appContainer__loading\\"" aria-label=\\""Loading application\\""><span data-euiicon-type=\\""logoElastic\\""></span></span><div class=\\""kbnAppWrapper\\"" aria-busy=\\""false\\""><div>
      basename: /chromeless-a/path
      html: <div>Chromeless A</div>
      </div></div>""
    `);
  });",""
"7380","elastic/kibana","fatal_errors_screen.test.tsx","    it('render matches snapshot', () => {
      expect(shallowWithIntl(<FatalErrorsScreen {...defaultProps} />)).toMatchSnapshot();
    });",""
"7410","elastic/kibana","app_containers.test.tsx","  it('toggles the `hidden-chrome` class depending on the chrome visibility state', () => {
    const chromeVisible$ = new BehaviorSubject<boolean>(true);

    const component = mount(
      <AppWrapper chromeVisible$={chromeVisible$} classes$={of([])}>
        app-content
      </AppWrapper>
    );
    expect(component.getDOMNode()).toMatchInlineSnapshot(`
      <div
        class=""kbnAppWrapper""
      >
        app-content
      </div>
    `);

    act(() => chromeVisible$.next(false));
    component.update();
    expect(component.getDOMNode()).toMatchInlineSnapshot(`
      <div
        class=""kbnAppWrapper kbnAppWrapper--hiddenChrome""
      >
        app-content
      </div>
    `);

    act(() => chromeVisible$.next(true));
    component.update();
    expect(component.getDOMNode()).toMatchInlineSnapshot(`
      <div
        class=""kbnAppWrapper""
      >
        app-content
      </div>
    `);
  });",""
"7412","elastic/kibana","rendering_service.test.tsx","  it('renders application service into provided DOM element', () => {
    startService();
    expect(targetDomElement.querySelector('div.kbnAppWrapper')).toMatchInlineSnapshot(`
      <div
        class=""kbnAppWrapper kbnAppWrapper--hiddenChrome""
      >
        <div
          id=""app-fixed-viewport""
        />
        <div>
          Hello application!
        </div>
      </div>
    `);
  });",""
"7427","elastic/kibana","saved_objects_client.test.ts","    test('rejects if `type` is undefined', async () => {
      expect(
        savedObjectsClient.update(undefined as any, undefined as any, undefined as any)
      ).rejects.toMatchInlineSnapshot(`[Error: requires type, id and attributes]`);
    });",""
"7550","elastic/kibana","elasticsearch_service.test.ts","    it('falls back to elasticsearch config if custom config not passed', async () => {
      const setupContract = await elasticsearchService.setup(setupDeps);

      // reset all mocks called during setup phase
      MockLegacyClusterClient.mockClear();

      setupContract.legacy.createClient('another-type');

      const config = MockLegacyClusterClient.mock.calls[0][0];
      expect(config).toMatchInlineSnapshot(`
        Object {
          ""healthCheckDelay"": ""PT0.01S"",
          ""hosts"": Array [
            ""http://1.2.3.4"",
          ],
          ""requestHeadersWhitelist"": Array [
            undefined,
          ],
          ""ssl"": Object {
            ""alwaysPresentCertificate"": undefined,
            ""certificate"": undefined,
            ""certificateAuthorities"": undefined,
            ""key"": undefined,
            ""keyPassphrase"": undefined,
            ""verificationMode"": ""none"",
          },
        }
      `);
    });",""
"7568","elastic/kibana","status.test.ts","  it('emits status updates when node compatibility changes', () => {
    const nodeCompat$ = new Subject<NodesVersionCompatibility>();

    const statusUpdates: ServiceStatus[] = [];
    const subscription = calculateStatus$(nodeCompat$).subscribe((status) =>
      statusUpdates.push(status)
    );

    nodeCompat$.next({
      isCompatible: false,
      kibanaVersion: '2.1.1',
      incompatibleNodes: [],
      warningNodes: [],
      message: 'Unable to retrieve version info',
    });
    nodeCompat$.next({
      isCompatible: false,
      kibanaVersion: '2.1.1',
      incompatibleNodes: [nodeInfo],
      warningNodes: [],
      message: 'Incompatible with Elasticsearch',
    });
    nodeCompat$.next({
      isCompatible: true,
      kibanaVersion: '1.1.1',
      warningNodes: [nodeInfo],
      incompatibleNodes: [],
      message: 'Some nodes are incompatible',
    });
    nodeCompat$.next({
      isCompatible: true,
      kibanaVersion: '1.1.1',
      warningNodes: [],
      incompatibleNodes: [],
    });

    subscription.unsubscribe();
    expect(statusUpdates).toMatchInlineSnapshot(`
      Array [
        Object {
          ""level"": unavailable,
          ""meta"": Object {
            ""incompatibleNodes"": Array [],
            ""warningNodes"": Array [],
          },
          ""summary"": ""Waiting for Elasticsearch"",
        },
        Object {
          ""level"": critical,
          ""meta"": Object {
            ""incompatibleNodes"": Array [],
            ""warningNodes"": Array [],
          },
          ""summary"": ""Unable to retrieve version info"",
        },
        Object {
          ""level"": critical,
          ""meta"": Object {
            ""incompatibleNodes"": Array [
              Object {
                ""http"": Object {
                  ""publish_address"": ""https://1.1.1.1:9200"",
                },
                ""ip"": ""1.1.1.1"",
                ""name"": ""node1"",
                ""version"": ""1.1.1"",
              },
            ],
            ""warningNodes"": Array [],
          },
          ""summary"": ""Incompatible with Elasticsearch"",
        },
        Object {
          ""level"": available,
          ""meta"": Object {
            ""incompatibleNodes"": Array [],
            ""warningNodes"": Array [
              Object {
                ""http"": Object {
                  ""publish_address"": ""https://1.1.1.1:9200"",
                },
                ""ip"": ""1.1.1.1"",
                ""name"": ""node1"",
                ""version"": ""1.1.1"",
              },
            ],
          },
          ""summary"": ""Some nodes are incompatible"",
        },
        Object {
          ""level"": available,
          ""meta"": Object {
            ""incompatibleNodes"": Array [],
            ""warningNodes"": Array [],
          },
          ""summary"": ""Elasticsearch is available"",
        },
      ]
    `);
  });",""
"7575","elastic/kibana","ensure_es_version.test.ts","  it('returns isCompatible=true with a message if a node is only off by a patch version and without http publish address', async () => {
    const result = mapNodesVersionCompatibility(createNodes('5.1.1'), KIBANA_VERSION, false);
    expect(result.isCompatible).toBe(true);
    expect(result.message).toMatchInlineSnapshot(
      `""You're running Kibana 5.1.0 with some different versions of Elasticsearch. Update Kibana or Elasticsearch to the same version to prevent compatibility issues: v5.1.1 @ http_address (ip)""`
    );
  });",""
"7605","elastic/kibana","http_config.test.ts","  test('accepts valid referrer whitelist', () => {
    const {
      compression: { referrerWhitelist },
    } = config.schema.validate({
      compression: {
        referrerWhitelist: validHostnames,
      },
    });

    expect(referrerWhitelist).toMatchSnapshot();
  });",""
"7695","elastic/kibana","plugins_service.test.ts","      it('contains internal properties for plugins', async () => {
        config$.next({ plugins: { initialize: true }, plugin1: { enabled: false } });
        const { uiPlugins } = await pluginsService.discover({ environment: environmentSetup });
        expect(uiPlugins.internal).toMatchInlineSnapshot(`
          Map {
            ""plugin-1"" => Object {
              ""publicAssetsDir"": <absolute path>/path-1/public/assets,
              ""publicTargetDir"": <absolute path>/path-1/target/public,
              ""requiredBundles"": Array [],
              ""version"": ""version-1"",
            },
            ""plugin-2"" => Object {
              ""publicAssetsDir"": <absolute path>/path-2/public/assets,
              ""publicTargetDir"": <absolute path>/path-2/target/public,
              ""requiredBundles"": Array [],
              ""version"": ""version-2"",
            },
          }
        `);
      });",""
"7699","elastic/kibana","plugins_system.test.ts","test('`setupPlugins` throws if plugins have circular required dependency', async () => {
  pluginsSystem.addPlugin(createPlugin('no-dep'));
  pluginsSystem.addPlugin(createPlugin('depends-on-1', { required: ['depends-on-2'] }));
  pluginsSystem.addPlugin(createPlugin('depends-on-2', { required: ['depends-on-1'] }));

  await expect(pluginsSystem.setupPlugins(setupDeps)).rejects.toMatchInlineSnapshot(
    `[Error: Topological ordering of plugins did not complete, these plugins have cyclic or missing dependencies: [""depends-on-1"",""depends-on-2""]]`
  );
});",""
"7837","elastic/kibana","decode_version.test.ts","  it('throws Boom error if not in base64', () => {
    let error;
    try {
      decodeVersion('[1,4]');
    } catch (err) {
      error = err;
    }

    expect(error.message).toMatchInlineSnapshot(`""Invalid version [[1,4]]""`);
    expect(Boom.isBoom(error)).toBe(true);
    expect(error.output).toMatchInlineSnapshot(`
Object {
  ""headers"": Object {},
  ""payload"": Object {
    ""error"": ""Bad Request"",
    ""message"": ""Invalid version [[1,4]]"",
    ""statusCode"": 400,
  },
  ""statusCode"": 400,
}
`);
  });",""
"7974","elastic/kibana","dashboard_migrations.test.ts","    test('skips errors when searchSourceJSON is undefined', () => {
      const doc = {
        id: '1',
        type: 'dashboard',
        attributes: {
          kibanaSavedObjectMeta: {
            searchSourceJSON: undefined,
          },
          panelsJSON:
            '[{""id"":""1"",""type"":""visualization"",""foo"":true},{""id"":""2"",""type"":""visualization"",""bar"":true}]',
        },
      };
      const migratedDoc = migration(doc, contextMock);
      expect(migratedDoc).toMatchInlineSnapshot(`
        Object {
          ""attributes"": Object {
            ""kibanaSavedObjectMeta"": Object {
              ""searchSourceJSON"": undefined,
            },
            ""panelsJSON"": ""[{\\""foo\\"":true,\\""panelRefName\\"":\\""panel_0\\""},{\\""bar\\"":true,\\""panelRefName\\"":\\""panel_1\\""}]"",
          },
          ""id"": ""1"",
          ""references"": Array [
            Object {
              ""id"": ""1"",
              ""name"": ""panel_0"",
              ""type"": ""visualization"",
            },
            Object {
              ""id"": ""2"",
              ""name"": ""panel_1"",
              ""type"": ""visualization"",
            },
          ],
          ""type"": ""dashboard"",
        }
      `);
    });",""
"7980","elastic/kibana","dashboard_migrations.test.ts","    test('skips error when panelsJSON is not a string', () => {
      const doc = {
        id: '1',
        attributes: {
          panelsJSON: 123,
        },
      } as SavedObjectUnsanitizedDoc;
      expect(migration(doc, contextMock)).toMatchInlineSnapshot(`
        Object {
          ""attributes"": Object {
            ""panelsJSON"": 123,
          },
          ""id"": ""1"",
          ""references"": Array [],
        }
      `);
    });",""
"8043","elastic/kibana","range.test.ts","    test('generates a serialized field format in the expected shape', () => {
      const aggConfigs = getAggConfigs();
      const agg = aggConfigs.aggs[0];
      expect(agg.type.getSerializedFormat(agg)).toMatchInlineSnapshot(`
        Object {
          ""id"": ""range"",
          ""params"": Object {
            ""id"": ""number"",
            ""params"": Object {
              ""pattern"": ""0,0.[000] b"",
            },
          },
        }
      `);
    });",""
"8297","elastic/kibana","build_function.test.ts","    test('allows you to replace an existing argument with multi args', () => {
      const fn = buildExpressionFunction('hello', { world: [true] });
      fn.replaceArgument('world', [true, false]);
      expect(fn.toAst().arguments).toMatchInlineSnapshot(`
        Object {
          ""world"": Array [
            true,
            false,
          ],
        }
      `);
    });",""
"8321","elastic/kibana","manage_data.test.tsx","  test('render empty without any features', () => {
    const component = shallowWithIntl(<ManageData addBasePath={addBasePathMock} features={[]} />);
    expect(component).toMatchSnapshot();
  });",""
"8413","elastic/kibana","time_field.test.tsx","  it('should render something if hiding time field', () => {
    const component = shallowWithI18nProvider(
      <TimeField
        isVisible={false}
        fetchTimeFields={() => {}}
        timeFieldOptions={[{ text: '@timestamp', value: '@timestamp' }]}
        isLoading={false}
        selectedTimeField={''}
        onTimeFieldChanged={() => {}}
      />
    );

    expect(component).toMatchSnapshot();
  });",""
"8423","elastic/kibana","step_time_field.test.tsx","  it('should render a loading state when creating the index pattern', () => {
    const component = createComponentWithContext(
      StepTimeField,
      {
        indexPattern: 'ki*',
        goToPreviousStep: noop,
        createIndexPattern: noop,
        indexPatternCreationType: mockIndexPatternCreationType,
      },
      mockContext
    );

    component.setState({ isCreating: true });

    expect(component).toMatchSnapshot();
  });",""
"8507","elastic/kibana","list_control.test.tsx","test('renders ListControl', () => {
  const component = shallowWithIntl(
    <ListControl.WrappedComponent
      id=""mock-list-control""
      label=""list control""
      options={options}
      selectedOptions={[]}
      multiselect={true}
      controlIndex={0}
      stageFilter={stageFilter}
      formatOptionLabel={formatOptionLabel}
      intl={{} as any}
    />
  );
  expect(component).toMatchSnapshot();
});",""
"8637","elastic/kibana","create_field_list.test.ts","  it(`generates a field for the object's references`, () => {
    const obj = createObject(
      {
        someString: 'foo',
      },
      [
        { id: 'ref1', type: 'type', name: 'Ref 1' },
        { id: 'ref12', type: 'other-type', name: 'Ref 2' },
      ]
    );
    expect(createFieldList(obj)).toMatchInlineSnapshot(`
      Array [
        Object {
          ""name"": ""someString"",
          ""type"": ""text"",
          ""value"": ""foo"",
        },
        Object {
          ""name"": ""references"",
          ""type"": ""array"",
          ""value"": ""[
        {
          \\""id\\"": \\""ref1\\"",
          \\""type\\"": \\""type\\"",
          \\""name\\"": \\""Ref 1\\""
        },
        {
          \\""id\\"": \\""ref12\\"",
          \\""type\\"": \\""other-type\\"",
          \\""name\\"": \\""Ref 2\\""
        }
      ]"",
        },
      ]
    `);
  });",""
"8839","elastic/kibana","y_extents.test.tsx","  it('should init with the default set of props', () => {
    const comp = shallow(<YExtents {...defaultProps} />);

    expect(comp).toMatchSnapshot();
  });",""
"8862","elastic/kibana","actions_authorization.test.ts","  test('ensures the user has privileges to execute an Actions Saved Object type', async () => {
    const { authorization } = mockSecurity();
    const checkPrivileges: jest.MockedFunction<
      ReturnType<typeof authorization.checkPrivilegesDynamicallyWithRequest>
    > = jest.fn();
    authorization.checkPrivilegesDynamicallyWithRequest.mockReturnValue(checkPrivileges);
    const actionsAuthorization = new ActionsAuthorization({
      request,
      authorization,
      auditLogger,
    });

    checkPrivileges.mockResolvedValueOnce({
      username: 'some-user',
      hasAllRequested: true,
      privileges: [
        {
          privilege: mockAuthorizationAction('myType', 'execute'),
          authorized: true,
        },
      ],
    });

    await actionsAuthorization.ensureAuthorized('execute', 'myType');

    expect(authorization.actions.savedObject.get).toHaveBeenCalledWith(
      ACTION_SAVED_OBJECT_TYPE,
      'get'
    );
    expect(authorization.actions.savedObject.get).toHaveBeenCalledWith(
      ACTION_TASK_PARAMS_SAVED_OBJECT_TYPE,
      'create'
    );
    expect(checkPrivileges).toHaveBeenCalledWith({
      kibana: [
        mockAuthorizationAction(ACTION_SAVED_OBJECT_TYPE, 'get'),
        mockAuthorizationAction(ACTION_TASK_PARAMS_SAVED_OBJECT_TYPE, 'create'),
      ],
    });

    expect(auditLogger.actionsAuthorizationSuccess).toHaveBeenCalledTimes(1);
    expect(auditLogger.actionsAuthorizationFailure).not.toHaveBeenCalled();
    expect(auditLogger.actionsAuthorizationSuccess.mock.calls[0]).toMatchInlineSnapshot(`
      Array [
        ""some-user"",
        ""execute"",
        ""myType"",
      ]
    `);
  });",""
"8870","elastic/kibana","email.test.ts","  test('returns expected result when an error is thrown', async () => {
    const customExecutorOptions: EmailActionTypeExecutorOptions = {
      ...executorOptions,
      config: {
        ...config,
        service: null,
        hasAuth: false,
      },
      secrets: {
        ...secrets,
        user: null,
        password: null,
      },
    };

    sendEmailMock.mockReset();
    sendEmailMock.mockRejectedValue(new Error('wops'));
    const result = await actionType.executor(customExecutorOptions);
    expect(result).toMatchInlineSnapshot(`
      Object {
        ""actionId"": ""some-id"",
        ""message"": ""error sending email"",
        ""serviceMessage"": ""wops"",
        ""status"": ""error"",
      }
    `);
  });",""
"8920","elastic/kibana","action_executor.test.ts","test('provides empty config when config and / or secrets is empty', async () => {
  const actionType: jest.Mocked<ActionType> = {
    id: 'test',
    name: 'Test',
    minimumLicenseRequired: 'basic',
    executor: jest.fn(),
  };
  const actionSavedObject = {
    id: '1',
    type: 'action',
    attributes: {
      actionTypeId: 'test',
    },
    references: [],
  };
  const actionResult = {
    id: actionSavedObject.id,
    name: actionSavedObject.id,
    actionTypeId: actionSavedObject.attributes.actionTypeId,
    isPreconfigured: false,
  };
  actionsClient.get.mockResolvedValueOnce(actionResult);
  encryptedSavedObjectsClient.getDecryptedAsInternalUser.mockResolvedValueOnce(actionSavedObject);
  actionTypeRegistry.get.mockReturnValueOnce(actionType);
  await actionExecutor.execute(executeParams);

  expect(actionType.executor).toHaveBeenCalledTimes(1);
  const executorCall = actionType.executor.mock.calls[0][0];
  expect(executorCall.config).toMatchInlineSnapshot(`undefined`);
});",""
"8964","elastic/kibana","list_action_types.test.ts","  it('ensures the license allows listing action types', async () => {
    const licenseState = licenseStateMock.create();
    const router = httpServiceMock.createRouter();

    listActionTypesRoute(router, licenseState);

    const [config, handler] = router.get.mock.calls[0];

    expect(config.path).toMatchInlineSnapshot(`""/api/actions/list_action_types""`);

    const listTypes = [
      {
        id: '1',
        name: 'name',
        enabled: true,
        enabledInConfig: true,
        enabledInLicense: true,
        minimumLicenseRequired: 'gold' as LicenseType,
      },
    ];

    const actionsClient = actionsClientMock.create();
    actionsClient.listTypes.mockResolvedValueOnce(listTypes);

    const [context, req, res] = mockHandlerArguments(
      { actionsClient },
      {
        params: { id: '1' },
      },
      ['ok']
    );

    await handler(context, req, res);

    expect(verifyApiAccess).toHaveBeenCalledWith(licenseState);
  });",""
"8973","elastic/kibana","actions_telemetry.test.ts","  test('getInUseTotalCount should count preconfigured alert history connector usage', async () => {
    const mockEsClient = elasticsearchClientMock.createClusterClient().asScoped().asInternalUser;
    mockEsClient.search.mockReturnValue(
      // @ts-expect-error not full search response
      elasticsearchClientMock.createSuccessTransportRequestPromise({
        aggregations: {
          refs: {
            actionRefIds: {
              value: {
                connectorIds: {
                  '1': 'action_0',
                  '123': 'action_1',
                  'preconfigured-alert-history-es-index': 'action_2',
                },
                total: 3,
              },
            },
          },
          hits: {
            hits: [],
          },
        },
      })
    );
    const actionsBulkGet = jest.fn();
    actionsBulkGet.mockReturnValue({
      saved_objects: [
        {
          id: '1',
          attributes: {
            actionTypeId: '.server-log',
          },
        },
        {
          id: '123',
          attributes: {
            actionTypeId: '.slack',
          },
        },
        {
          id: 'preconfigured-alert-history-es-index',
          error: {
            statusCode: 404,
            error: 'Not Found',
            message: 'Saved object [action/preconfigured-alert-history-es-index] not found',
          },
        },
      ],
    });
    const telemetry = await getInUseTotalCount(mockEsClient, actionsBulkGet, 'test');

    expect(mockEsClient.search).toHaveBeenCalledTimes(1);
    expect(actionsBulkGet).toHaveBeenCalledTimes(1);

    expect(telemetry).toMatchInlineSnapshot(`
Object {
  ""countByAlertHistoryConnectorType"": 1,
  ""countByType"": Object {
    ""__server-log"": 1,
    ""__slack"": 1,
  },
  ""countTotal"": 3,
}
`);
  });",""
"8977","elastic/kibana","audit_events.test.ts","  test('creates event with `success` outcome', () => {
    expect(
      ruleAuditEvent({
        action: RuleAuditAction.CREATE,
        savedObject: { type: 'alert', id: 'ALERT_ID' },
      })
    ).toMatchInlineSnapshot(`
      Object {
        ""error"": undefined,
        ""event"": Object {
          ""action"": ""rule_create"",
          ""category"": Array [
            ""database"",
          ],
          ""outcome"": ""success"",
          ""type"": Array [
            ""creation"",
          ],
        },
        ""kibana"": Object {
          ""saved_object"": Object {
            ""id"": ""ALERT_ID"",
            ""type"": ""alert"",
          },
        },
        ""message"": ""User has created rule [id=ALERT_ID]"",
      }
    `);
  });",""
"9052","elastic/kibana","alert_execution_status.test.ts","    test('error with a reason', () => {
      const status = executionStatusFromError(
        new ErrorWithReason(AlertExecutionStatusErrorReasons.Execute, new Error('hoo!'))
      );
      expect(status.status).toBe('error');
      expect(status.error).toMatchInlineSnapshot(`
        Object {
          ""message"": ""hoo!"",
          ""reason"": ""execute"",
        }
      `);
    });",""
"9099","elastic/kibana","find.test.ts","  it('finds alerts with proper parameters', async () => {
    const licenseState = licenseStateMock.create();
    const router = httpServiceMock.createRouter();

    findAlertRoute(router, licenseState);

    const [config, handler] = router.get.mock.calls[0];

    expect(config.path).toMatchInlineSnapshot(`""/api/alerts/_find""`);

    const findResult = {
      page: 1,
      perPage: 1,
      total: 0,
      data: [],
    };
    alertsClient.find.mockResolvedValueOnce(findResult);

    const [context, req, res] = mockHandlerArguments(
      { alertsClient },
      {
        query: {
          per_page: 1,
          page: 1,
          default_search_operator: 'OR',
        },
      },
      ['ok']
    );

    expect(await handler(context, req, res)).toMatchInlineSnapshot(`
      Object {
        ""body"": Object {
          ""data"": Array [],
          ""page"": 1,
          ""perPage"": 1,
          ""total"": 0,
        },
      }
    `);

    expect(alertsClient.find).toHaveBeenCalledTimes(1);
    expect(alertsClient.find.mock.calls[0]).toMatchInlineSnapshot(`
      Array [
        Object {
          ""options"": Object {
            ""defaultSearchOperator"": ""OR"",
            ""page"": 1,
            ""perPage"": 1,
          },
        },
      ]
    `);

    expect(res.ok).toHaveBeenCalledWith({
      body: findResult,
    });
  });",""
"9239","elastic/kibana","get_commands.test.ts","    it('renders with secret token and url', () => {
      const commands = getCommands({
        variantId: 'rack',
        policyDetails: {
          apmServerUrl: 'localhost:8220',
          secretToken: 'foobar',
        },
      });
      expect(commands).not.toBe('');
      expect(commands).toMatchInlineSnapshot(`
        ""# config/elastic_apm.yml:

        # Set the service name - allowed characters: a-z, A-Z, 0-9, -, _ and space
        # Defaults to the name of your Rack app's class.
        service_name: 'my-service'

        # Use if APM Server requires a token
        secret_token: 'foobar'

        # Set custom APM Server URL (default: http://localhost:8200)
        server_url: 'localhost:8220',

        # Set the service environment
        environment: 'production'""
      `);
    });",""
"9300","elastic/kibana","queries.test.ts","  it('fetches breakdown data for transactions for a transaction name', async () => {
    mock = await inspectSearchParams((setup) =>
      getTransactionBreakdown({
        serviceName: 'foo',
        transactionType: 'bar',
        transactionName: 'baz',
        setup,
      })
    );

    expect(mock.params).toMatchSnapshot();
  });",""
"9307","elastic/kibana","loading.test.tsx","  it('uses EuiIcon by default', () => {
    expect(shallow(<Loading />)).toMatchInlineSnapshot(`
      <div
        className=""canvasLoading""
      >
        <EuiIcon
          color=""ghost""
          type=""clock""
        />
      </div>
    `);
  });",""
"9577","elastic/kibana","filebeat_iis.test.ts","    test('iis access log', () => {
      const flattenedDocument = {
        '@timestamp': ['2018-01-01T10:11:12.000Z'],
        'destination.address': ['127.0.0.1'],
        'destination.domain': ['example.com'],
        'destination.ip': ['127.0.0.1'],
        'destination.port': [80],
        'ecs.version': ['1.0.0-beta2'],
        'event.dataset': ['iis.access'],
        'event.duration': [789000000],
        'event.module': ['iis'],
        'fileset.name': ['access'],
        'http.request.body.bytes': [456],
        'http.request.method': ['GET'],
        'http.request.referrer': ['-'],
        'http.response.body.bytes': [123],
        'http.response.status_code': [200],
        'http.version': ['1.1'],
        'iis.access.cookie': ['-'],
        'iis.access.server_name': ['MACHINE-NAME'],
        'iis.access.site_name': ['W3SVC1'],
        'iis.access.sub_status': [0],
        'iis.access.win32_status': [0],
        'input.type': ['log'],
        'log.offset': [1204],
        'service.type': ['iis'],
        'source.address': ['85.181.35.98'],
        'source.geo.city_name': ['Berlin'],
        'source.geo.continent_name': ['Europe'],
        'source.geo.country_iso_code': ['DE'],
        'source.geo.location.lat': [52.4908],
        'source.geo.location.lon': [13.3275],
        'source.geo.region_iso_code': ['DE-BE'],
        'source.geo.region_name': ['Land Berlin'],
        'source.ip': ['85.181.35.98'],
        'url.path': ['/'],
        'url.query': ['q=100'],
        'user.name': ['-'],
        'user_agent.device.name': ['Other'],
        'user_agent.name': ['Chrome'],
        'user_agent.original': [
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
        ],
        'user_agent.os.full': ['Mac OS X 10.14.0'],
        'user_agent.os.name': ['Mac OS X'],
        'user_agent.os.version': ['10.14.0'],
        'user_agent.version': ['70.0.3538'],
      };

      expect(format(flattenedDocument, {})).toMatchInlineSnapshot(`
        Array [
          Object {
            ""constant"": ""["",
          },
          Object {
            ""field"": ""event.module"",
            ""highlights"": Array [],
            ""value"": Array [
              ""iis"",
            ],
          },
          Object {
            ""constant"": ""][access] "",
          },
          Object {
            ""field"": ""source.ip"",
            ""highlights"": Array [],
            ""value"": Array [
              ""85.181.35.98"",
            ],
          },
          Object {
            ""constant"": "" "",
          },
          Object {
            ""field"": ""user.name"",
            ""highlights"": Array [],
            ""value"": Array [
              ""-"",
            ],
          },
          Object {
            ""constant"": "" \\"""",
          },
          Object {
            ""field"": ""http.request.method"",
            ""highlights"": Array [],
            ""value"": Array [
              ""GET"",
            ],
          },
          Object {
            ""constant"": "" "",
          },
          Object {
            ""field"": ""url.path"",
            ""highlights"": Array [],
            ""value"": Array [
              ""/"",
            ],
          },
          Object {
            ""constant"": ""?"",
          },
          Object {
            ""field"": ""url.query"",
            ""highlights"": Array [],
            ""value"": Array [
              ""q=100"",
            ],
          },
          Object {
            ""constant"": "" HTTP/"",
          },
          Object {
            ""field"": ""http.version"",
            ""highlights"": Array [],
            ""value"": Array [
              ""1.1"",
            ],
          },
          Object {
            ""constant"": ""\\"" "",
          },
          Object {
            ""field"": ""http.response.status_code"",
            ""highlights"": Array [],
            ""value"": Array [
              200,
            ],
          },
          Object {
            ""constant"": "" "",
          },
          Object {
            ""field"": ""http.response.body.bytes"",
            ""highlights"": Array [],
            ""value"": Array [
              123,
            ],
          },
        ]
      `);
    });",""
"9807","elastic/kibana","layer_control.test.tsx","      test('Should render expand button with loading icon when layer is loading', () => {
        const component = shallow(
          <LayerControl
            {...defaultProps}
            isLayerTOCOpen={false}
            layerList={[mockLayerThatIsLoading]}
          />
        );
        expect(component).toMatchSnapshot();
      });",""
"9907","elastic/kibana","delete_filter_list_modal.test.js","  test('renders as disabled delete button', () => {
    mockCheckPermission.mockImplementationOnce(() => {
      return false;
    });

    const component = shallowWithIntl(<DeleteFilterListModal {...testProps} />);

    expect(component).toMatchSnapshot();
  });",""
"9924","elastic/kibana","toolbar.test.js","  test('renders the toolbar with one item selected', () => {
    const props = {
      ...requiredProps,
      selectedItemCount: 1,
    };

    const component = shallowWithIntl(<EditFilterListToolbar {...props} />);

    expect(component).toMatchSnapshot();
  });",""
"9926","elastic/kibana","header.test.js","  test('renders header', () => {
    const props = {
      ...requiredProps,
    };

    const component = shallowWithIntl(<FilterListsHeader {...props} />);

    expect(component).toMatchSnapshot();
  });",""
"10083","elastic/kibana","validate_proxy.test.ts","  test(`rejects proxy address when the port is invalid`, () => {
    expect(validateProxy('noport')).toMatchSnapshot();
  });",""
"10260","elastic/kibana","role_mapping_validation.test.ts","  it('validates a correct role mapping using roles', () => {
    expect(
      validateRoleMappingForSave(({
        name: 'foo',
        enabled: true,
        roles: ['superuser'],
        rules: { field: { username: '*' } },
      } as unknown) as RoleMapping)
    ).toMatchInlineSnapshot(`
      Object {
        ""isInvalid"": false,
      }
    `);
  });",""
"10364","elastic/kibana","cases.test.ts","      it('grants `read` privileges under feature', () => {
        const actions = new Actions(version);
        const casesFeaturePrivilege = new FeaturePrivilegeCasesBuilder(actions);

        const privilege: FeatureKibanaPrivileges = {
          cases: {
            read: ['observability'],
          },

          savedObject: {
            all: [],
            read: [],
          },
          ui: [],
        };

        const feature = new KibanaFeature({
          id: 'my-feature',
          name: 'my-feature',
          app: [],
          category: { id: 'foo', label: 'foo' },
          privileges: {
            all: privilege,
            read: privilege,
          },
        });

        expect(casesFeaturePrivilege.getActions(privilege, feature)).toMatchInlineSnapshot(`
          Array [
            ""cases:1.0.0-zeta1:observability/getCase"",
            ""cases:1.0.0-zeta1:observability/getComment"",
            ""cases:1.0.0-zeta1:observability/getTags"",
            ""cases:1.0.0-zeta1:observability/getReporters"",
            ""cases:1.0.0-zeta1:observability/getUserActions"",
            ""cases:1.0.0-zeta1:observability/findConfigurations"",
          ]
        `);
      });",""
"10367","elastic/kibana","cases.test.ts","      it('grants both `all` and `read` privileges under feature with multiple values in cases array', () => {
        const actions = new Actions(version);
        const casesFeaturePrivilege = new FeaturePrivilegeCasesBuilder(actions);

        const privilege: FeatureKibanaPrivileges = {
          cases: {
            all: ['security', 'other-security'],
            read: ['obs', 'other-obs'],
          },

          savedObject: {
            all: [],
            read: [],
          },
          ui: [],
        };

        const feature = new KibanaFeature({
          id: 'my-feature',
          name: 'my-feature',
          app: [],
          category: { id: 'foo', label: 'foo' },
          privileges: {
            all: privilege,
            read: privilege,
          },
        });

        expect(casesFeaturePrivilege.getActions(privilege, feature)).toMatchInlineSnapshot(`
          Array [
            ""cases:1.0.0-zeta1:security/getCase"",
            ""cases:1.0.0-zeta1:security/getComment"",
            ""cases:1.0.0-zeta1:security/getTags"",
            ""cases:1.0.0-zeta1:security/getReporters"",
            ""cases:1.0.0-zeta1:security/getUserActions"",
            ""cases:1.0.0-zeta1:security/findConfigurations"",
            ""cases:1.0.0-zeta1:security/createCase"",
            ""cases:1.0.0-zeta1:security/deleteCase"",
            ""cases:1.0.0-zeta1:security/updateCase"",
            ""cases:1.0.0-zeta1:security/pushCase"",
            ""cases:1.0.0-zeta1:security/createComment"",
            ""cases:1.0.0-zeta1:security/deleteComment"",
            ""cases:1.0.0-zeta1:security/updateComment"",
            ""cases:1.0.0-zeta1:security/createConfiguration"",
            ""cases:1.0.0-zeta1:security/updateConfiguration"",
            ""cases:1.0.0-zeta1:other-security/getCase"",
            ""cases:1.0.0-zeta1:other-security/getComment"",
            ""cases:1.0.0-zeta1:other-security/getTags"",
            ""cases:1.0.0-zeta1:other-security/getReporters"",
            ""cases:1.0.0-zeta1:other-security/getUserActions"",
            ""cases:1.0.0-zeta1:other-security/findConfigurations"",
            ""cases:1.0.0-zeta1:other-security/createCase"",
            ""cases:1.0.0-zeta1:other-security/deleteCase"",
            ""cases:1.0.0-zeta1:other-security/updateCase"",
            ""cases:1.0.0-zeta1:other-security/pushCase"",
            ""cases:1.0.0-zeta1:other-security/createComment"",
            ""cases:1.0.0-zeta1:other-security/deleteComment"",
            ""cases:1.0.0-zeta1:other-security/updateComment"",
            ""cases:1.0.0-zeta1:other-security/createConfiguration"",
            ""cases:1.0.0-zeta1:other-security/updateConfiguration"",
            ""cases:1.0.0-zeta1:obs/getCase"",
            ""cases:1.0.0-zeta1:obs/getComment"",
            ""cases:1.0.0-zeta1:obs/getTags"",
            ""cases:1.0.0-zeta1:obs/getReporters"",
            ""cases:1.0.0-zeta1:obs/getUserActions"",
            ""cases:1.0.0-zeta1:obs/findConfigurations"",
            ""cases:1.0.0-zeta1:other-obs/getCase"",
            ""cases:1.0.0-zeta1:other-obs/getComment"",
            ""cases:1.0.0-zeta1:other-obs/getTags"",
            ""cases:1.0.0-zeta1:other-obs/getReporters"",
            ""cases:1.0.0-zeta1:other-obs/getUserActions"",
            ""cases:1.0.0-zeta1:other-obs/findConfigurations"",
          ]
        `);
      });",""
"10535","elastic/kibana","index.test.tsx","  it('renders correctly when item details expanded', async () => {
    const store = createGlobalNoMiddlewareStore();

    store.dispatch(
      createTrustedAppsListResourceStateChangedAction(
        createListLoadedResourceState({ pageSize: 20 }, now)
      )
    );

    const element = renderList(store);

    (await element.findAllByTestId('trustedAppsListItemExpandButton'))[0].click();

    expect(element.container).toMatchSnapshot();
  });",""
"10794","elastic/kibana","helpers.test.tsx","  test('Only Data Provider with a date type (string input)', () => {
    const dataProviders = cloneDeep(mockDataProviders.slice(0, 1));
    dataProviders[0].queryMatch.field = 'event.end';
    dataProviders[0].queryMatch.value = '2018-03-23T23:36:23.232Z';
    const { filterQuery } = combineQueries({
      config,
      dataProviders,
      indexPattern: mockIndexPattern,
      browserFields: mockBrowserFields,
      filters: [],
      kqlQuery: { query: '', language: 'kuery' },
      kqlMode: 'search',
    })!;
    expect(filterQuery).toMatchInlineSnapshot(
      `""{\\""bool\\"":{\\""must\\"":[],\\""filter\\"":[{\\""bool\\"":{\\""should\\"":[{\\""match\\"":{\\""event.end\\"":\\""1521848183232\\""}}],\\""minimum_should_match\\"":1}}],\\""should\\"":[],\\""must_not\\"":[]}}""`
    );
  });",""
"10816","elastic/kibana","list_form.test.tsx","  test('Minimal initialization', () => {
    const item: PivotGroupByConfig = {
      agg: PIVOT_SUPPORTED_GROUP_BY_AGGS.TERMS,
      field: 'the-group-by-field',
      aggName: 'the-group-by-agg-name',
      dropDownName: 'the-group-by-drop-down-name',
    };
    const props = {
      list: { 'the-options-data-id': item },
      options: {},
      deleteHandler() {},
      onChange() {},
    };

    const wrapper = shallow(<GroupByListForm {...props} />);

    expect(wrapper).toMatchSnapshot();
  });",""
"10886","elastic/kibana","alert_details.test.tsx","  it('should render an edit button when alert editable but actions arent when there are no actions on the alert', async () => {
    const { hasExecuteActionsCapability } = jest.requireMock('../../../lib/capabilities');
    hasExecuteActionsCapability.mockReturnValue(false);
    const alert = mockAlert({
      enabled: true,
      muteAll: false,
      actions: [],
    });

    const alertType: AlertType = {
      id: '.noop',
      name: 'No Op',
      actionGroups: [{ id: 'default', name: 'Default' }],
      recoveryActionGroup,
      actionVariables: { context: [], state: [], params: [] },
      defaultActionGroupId: 'default',
      producer: 'alerting',
      authorizedConsumers,
      minimumLicenseRequired: 'basic',
      enabledInLicense: true,
    };

    const pageHeaderProps = shallow(
      <AlertDetails
        alert={alert}
        alertType={alertType}
        actionTypes={actionTypes}
        {...mockAlertApis}
      />
    )
      .find('EuiPageHeader')
      .props() as EuiPageHeaderProps;
    const rightSideItems = pageHeaderProps.rightSideItems;
    expect(!!rightSideItems && rightSideItems[2]!).toMatchInlineSnapshot(`
    <React.Fragment>
      <EuiButtonEmpty
        data-test-subj=""openEditAlertFlyoutButton""
        disabled={false}
        iconType=""pencil""
        name=""edit""
        onClick={[Function]}
      >
        <FormattedMessage
          defaultMessage=""Edit""
          id=""xpack.triggersActionsUI.sections.alertDetails.editAlertButtonLabel""
          values={Object {}}
        />
      </EuiButtonEmpty>
    </React.Fragment>
  `);
  });",""
"10892","elastic/kibana","alert_conditions_group.test.tsx","  it('renders a reset button when onResetConditionsFor is specified', async () => {
    const onResetConditionsFor = jest.fn();
    const wrapper = await setup(
      <AlertConditionsGroup
        actionGroup={{
          id: 'myGroup',
          name: 'My Group',
        }}
        onResetConditionsFor={onResetConditionsFor}
      >
        <div>{'inner component'}</div>
      </AlertConditionsGroup>
    );

    expect(wrapper.find(EuiButtonIcon).prop('aria-label')).toMatchInlineSnapshot(`""Remove""`);

    wrapper.find(EuiButtonIcon).simulate('click');

    expect(onResetConditionsFor).toHaveBeenCalledWith({
      id: 'myGroup',
      name: 'My Group',
    });
  });",""
"11053","elastic/kibana","monitor_list.test.tsx","  it('renders loading state', () => {
    const component = shallowWithRouter(
      <MonitorListComponent
        monitorList={{ list: getMonitorList(), loading: true }}
        pageSize={10}
        setPageSize={jest.fn()}
      />
    );

    expect(component).toMatchSnapshot();
  });",""
"11151","elastic/kibana","status_check.test.ts","    it('supports auto generated monitor status alerts', async () => {
      toISOStringSpy.mockImplementation(() => 'foo date string');
      const mockGetter: jest.Mock<GetMonitorStatusResult[]> = jest.fn();

      mockGetter.mockReturnValue(mockMonitors);
      const { server, libs, plugins } = bootstrapDependencies({ getMonitorStatus: mockGetter });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        isAutoGenerated: true,
        timerange: { from: 'now-15m', to: 'now' },
        numTimes: 5,
      });
      const {
        services: { alertWithLifecycle },
      } = options;
      // @ts-ignore the executor can return `void`, but ours never does
      const state: Record<string, any> = await alert.executor(options);
      expect(mockGetter).toHaveBeenCalledTimes(1);
      expect(alertWithLifecycle).toHaveBeenCalledTimes(2);
      mockMonitors.forEach((monitor) => {
        expect(alertWithLifecycle).toBeCalledWith(mockStatusAlertDocument(monitor, true));
      });
      expect(mockGetter.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          filters: undefined,
          locations: [],
          numTimes: 5,
          timespanRange: {
            from: 'now-15m',
            to: 'now',
          },
        })
      );
      const [{ value: alertInstanceMock }] = alertWithLifecycle.mock.results;
      expect(alertInstanceMock.replaceState).toHaveBeenCalledTimes(2);
      expect(alertInstanceMock.replaceState.mock.calls[0]).toMatchInlineSnapshot(`
        Array [
          Object {
            ""currentTriggerStarted"": ""foo date string"",
            ""firstCheckedAt"": ""foo date string"",
            ""firstTriggeredAt"": ""foo date string"",
            ""isTriggered"": true,
            ""lastCheckedAt"": ""foo date string"",
            ""lastResolvedAt"": undefined,
            ""lastTriggeredAt"": ""foo date string"",
            ""latestErrorMessage"": ""error message 1"",
            ""monitorId"": ""first"",
            ""monitorName"": ""first"",
            ""monitorType"": ""myType"",
            ""monitorUrl"": ""localhost:8080"",
            ""observerHostname"": undefined,
            ""observerLocation"": ""harrisburg"",
            ""reason"": ""Monitor first with url localhost:8080 is down from harrisburg. The latest error message is error message 1"",
            ""statusMessage"": ""down"",
          },
        ]
      `);
      expect(alertInstanceMock.scheduleActions).toHaveBeenCalledTimes(2);
      expect(alertInstanceMock.scheduleActions.mock.calls[0]).toMatchInlineSnapshot(`
        Array [
          ""xpack.uptime.alerts.actionGroups.monitorStatus"",
        ]
      `);
    });",""
"11236","elderjs/elderjs","Elder.spec.ts","  it('srcPlugin found', async () => {
    jest.mock(`..${sep}utils${sep}validations`, () => ({
      validatePlugin: (i) => i,
      validateHook: (i) => i,
      validateRoute: (i) => i,
      validateShortcode: (i) => i,
    }));
    jest.mock('fs-extra', () => ({
      existsSync: () => true,
    }));
    jest.mock(
      `${process.cwd()}${sep}test${sep}___ELDER___${sep}compiled${sep}fakepath${sep}Test.js`,
      () => () => ({}),
      { virtual: true },
    );
    jest.mock(
      `${process.cwd()}${sep}test${sep}src${sep}hooks.js`,
      () => ({
        default: [
          {
            hook: 'bootstrap',
            name: 'test hook from file',
            description: 'just for testing',
            run: () => jest.fn(),
          },
        ],
      }),
      { virtual: true },
    );
    jest.mock(
      `${process.cwd()}${sep}test${sep}src${sep}plugins${sep}elder-plugin-upload-s3${sep}index.js`,
      () => ({
        hooks: [
          {
            hook: 'customizeHooks',
            name: 'test hook',
            description: 'just for testing',
            run: () => Promise.resolve({ plugin: 'elder-plugin-upload-s3' }),
            $$meta: {
              type: 'hooks.js',
              addedBy: 'validations.spec.ts',
            },
          },
          {
            hook: 'bootstrap',
            name: 'test hook 2',
            description: 'just for testing',
            run: () => Promise.resolve({}),
            $$meta: {
              type: 'hooks.js',
              addedBy: 'validations.spec.ts',
            },
          },
          {
            hook: 'bootstrap',
            name: 'test hook 3',
            description: 'just for testing',
            run: () => Promise.resolve(null),
            $$meta: {
              type: 'hooks.js',
              addedBy: 'validations.spec.ts',
            },
          },
        ],
        routes: {
          'test-a': {
            hooks: [],
            template: `fakepath${sep}Test.svelte`,
            all: () => Promise.resolve([{ slug: `${sep}test` }]),
            permalink: () => '/',
          },
          'test-b': { data: () => {}, all: [], permalink: () => '/' },
        },
        config: {},
        name: 'test',
        description: 'test',
        init: jest.fn().mockImplementation((p) => p),
      }),
      {
        virtual: true,
      },
    );
    // eslint-disable-next-line import/no-dynamic-require
    const { Elder } = require(`..${sep}index`);
    const elder = await new Elder({ context: 'server', worker: false });
    await elder.bootstrap();

    delete elder.perf.timings;
    expect(normalizeSnapshot(elder)).toMatchSnapshot();
  });",""
"11245","electron/fiddle","dialog-add-version-spec.tsx","    it('shows dialog warning when adding duplicate local versions', async () => {
      const wrapper = shallow(<AddVersionDialog appState={store} />);

      wrapper.setState({
        isValidElectron: true,
        folderPath: '/test/path',
        version: '3.3.3',
        existingLocalVersion: {
          version: '2.2.2',
          localPath: '/test/path',
        },
      });

      expect(wrapper).toMatchSnapshot();
    });",""
"11343","facebookarchive/rebound-js","reboundSpec.js","  it('performs the expected numerical integration', () => {
    const actualValues = [];
    const actualVelocities = [];

    spring.addListener({
      onSpringUpdate: jest.fn(() => {
        actualValues.push(spring.getCurrentValue());
        actualVelocities.push(spring.getVelocity());
      }),
    });

    spring.setEndValue(1);
    expect(actualValues).toMatchSnapshot();
    expect(actualVelocities).toMatchSnapshot();
  });",""
"11381","facebook/docusaurus","routeConfig.test.ts","  it('sorts route config correctly', () => {
    const routes: RouteConfig[] = [
      {
        path: '/',
        component: '',
        routes: [
          {path: '/someDoc', component: ''},
          {path: '/someOtherDoc', component: ''},
        ],
      },
      {
        path: '/',
        component: '',
      },
      {
        path: '/',
        component: '',
        routes: [{path: '/subroute', component: ''}],
      },
      {
        path: '/docs',
        component: '',
        routes: [
          {path: '/docs/someDoc', component: ''},
          {path: '/docs/someOtherDoc', component: ''},
        ],
      },
      {
        path: '/community',
        component: '',
      },
      {
        path: '/some-page',
        component: '',
      },
    ];

    sortConfig(routes);

    expect(routes).toMatchSnapshot();
  });",""
"11417","facebook/docusaurus","index.test.ts","  it('recognizes valid flags', () => {
    expect(
      logger.interpolate`(keepAnsi) The package at path=${'packages/docusaurus'} has number=${10} files. name=${'Babel'} is exported here subdue=${'(as a preset)'} that you can with code=${""require.resolve('@docusaurus/core/lib/babel/preset')""}`,
    ).toMatchInlineSnapshot(
      `""(keepAnsi) The package at <cyan><underline>""packages/docusaurus""</underline></color> has <yellow>10</color> files. <blue><bold>Babel</intensity></color> is exported here <gray>(as a preset)</color> that you can with <cyan>\`require.resolve('@docusaurus/core/lib/babel/preset')\`</color>""`,
    );
  });",""
"11433","facebook/docusaurus","index.test.ts","  it('works for basic mermaid code blocks', async () => {
    const result = await process(`# Heading 1

\`\`\`mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
\`\`\``);
    expect(result).toMatchInlineSnapshot(`
      ""<h1>Heading 1</h1>
      <mermaid value=""graph TD;
          A-->B;
          A-->C;
          B-->D;
          C-->D;""></mermaid>""
    `);
  });",""
"11454","facebook/docusaurus","footnoteIDFixer.test.ts","  it('appends a hash to each footnote def/ref', async () => {
    const hash = simpleHash(path.join(__dirname, `__fixtures__/post.md`), 6);
    expect(
      (await processFixture('post')).replace(new RegExp(hash, 'g'), '[HASH]'),
    ).toMatchSnapshot();
  });",""
"11487","facebook/docusaurus","normalization.test.ts","  it('normalizes shorthands', () => {
    expect(
      normalizeSidebars({
        sidebar: {
          Category: ['doc1', 'doc2'],
          'Category 2': {
            'Subcategory 1': ['doc3', 'doc4'],
            'Subcategory 2': ['doc5', 'doc6'],
          },
        },
      }),
    ).toMatchSnapshot();

    expect(
      normalizeSidebars({
        sidebar: [
          {
            type: 'link',
            label: 'Google',
            href: 'https://google.com',
          },
          {
            'Category 1': ['doc1', 'doc2'],
            'Category 2': ['doc3', 'doc4'],
          },
        ],
      }),
    ).toMatchSnapshot();
  });",""
"11496","facebook/docusaurus","docs.test.ts","  it('docs with invalid id', async () => {
    const {defaultTestUtils} = await loadSite();

    const error = await defaultTestUtils.getProcessDocFileError(
      createFakeDocFile({
        source: 'some/fake/path',
        frontMatter: {
          id: 'Hello/world',
        },
      }),
    );

    expect(error.message).toMatchInlineSnapshot(
      `""Can't process doc metadata for doc at path path=some/fake/path in version name=current""`,
    );
    expect(error.cause).toBeDefined();
    expect(error.cause!.message).toMatchInlineSnapshot(
      `""Document id ""Hello/world"" cannot include slash.""`,
    );
  });",""
"11505","facebook/docusaurus","index.test.ts","  it('getPathToWatch', async () => {
    const {siteDir, plugin} = await loadSite();
    const pathToWatch = plugin.getPathsToWatch!();
    const matchPattern = pathToWatch.map((filepath) =>
      posixPath(path.relative(siteDir, filepath)),
    );
    expect(matchPattern).not.toEqual([]);
    expect(matchPattern).toMatchSnapshot();
    expect(isMatch('community/team.md', matchPattern)).toBe(true);
    expect(
      isMatch('community_versioned_docs/version-1.0.0/team.md', matchPattern),
    ).toBe(true);

    // Non existing version
    expect(
      isMatch('community_versioned_docs/version-2.0.0/team.md', matchPattern),
    ).toBe(false);
    expect(
      isMatch(
        'community_versioned_sidebars/version-2.0.0-sidebars.json',
        matchPattern,
      ),
    ).toBe(false);

    expect(isMatch('community/team.js', matchPattern)).toBe(false);
    expect(
      isMatch('community_versioned_docs/version-1.0.0/team.js', matchPattern),
    ).toBe(false);
  });",""
"11795","facebook/jest","watchModeUpdateSnapshot.test.ts","test('can press ""u"" to update snapshots', () => {
  const input = [{keys: ['u']}, {keys: ['q']}];
  setupFiles(input);

  const {exitCode, stderr} = runJest(DIR, ['--no-watchman', '--watchAll']);
  const results = extractSummaries(stderr);
  expect(results).toHaveLength(2);
  results.forEach(({rest, summary}) => {
    expect(rest).toMatchSnapshot('test results');
    expect(summary).toMatchSnapshot('test summary');
  });
  expect(exitCode).toBe(0);
});",""
"11851","facebook/jest","getNoTestsFoundMessage.test.ts","  test('returns correct message with passWithNoTests', () => {
    const config = createGlobalConfig({passWithNoTests: true});
    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();
  });",""
"11998","facebook/jest","mockSerializer.test.ts","test('mock with 0 calls and default name in React element', () => {
  const fn = jest.fn();
  const val = {
    $$typeof: Symbol.for('react.test.json'),
    children: ['Mock me!'],
    props: {
      onClick: fn,
    },
    type: 'button',
  };
  expect(val).toMatchSnapshot();
});",""
"12051","facebook/jest","ScriptTransformer.test.ts","  it('in async mode, uses the supplied preprocessor', async () => {
    config = {...config, transform: [['\\.js$', 'test_preprocessor', {}]]};
    const scriptTransformer = await createScriptTransformer(config);
    const res1 = await scriptTransformer.transformAsync(
      '/fruits/banana.js',
      getCoverageOptions(),
    );

    expect(require('test_preprocessor').getCacheKey).toBeCalled();

    expect(res1.code).toMatchSnapshot();

    const res2 = await scriptTransformer.transformAsync(
      '/node_modules/react.js',
      getCoverageOptions(),
    );
    // ignores preprocessor
    expect(res2.code).toMatchSnapshot();
  });",""
"12053","facebook/jest","ScriptTransformer.test.ts","  it('uses multiple preprocessors', async () => {
    config = {
      ...config,
      transform: [
        ['\\.js$', 'test_preprocessor', {}],
        ['\\.css$', 'css-preprocessor', {}],
      ],
    };
    const scriptTransformer = await createScriptTransformer(config);

    const res1 = scriptTransformer.transform(
      '/fruits/banana.js',
      getCoverageOptions(),
    );
    const res2 = scriptTransformer.transform(
      '/styles/App.css',
      getCoverageOptions(),
    );

    expect(require('test_preprocessor').getCacheKey).toBeCalled();
    expect(require('css-preprocessor').getCacheKey).toBeCalled();
    expect(res1.code).toMatchSnapshot();
    expect(res2.code).toMatchSnapshot();

    const res3 = scriptTransformer.transform(
      '/node_modules/react.js',
      getCoverageOptions(),
    );
    // ignores preprocessor
    expect(res3.code).toMatchSnapshot();
  });",""
"12093","faceyspacey/react-universal-component","index.js","  it('es6: default export automatically resolved', async () => {
    const asyncComponent = createComponent(40, null)
    const Component = universal(asyncComponent, {
      path: path.join(__dirname, '../__fixtures__/component')
    })

    const component = renderer.create(<Component />)

    expect(component.toJSON()).toMatchSnapshot() // serverside
  })",""
"12148","faridsafi/react-native-gifted-chat","Send.test.tsx","  it('should render <Send /> where there is input and compare with snapshot', () => {
    const tree = renderer.create(<Send text='test input' />).toJSON()
    expect(tree).toMatchSnapshot()
  })",""
"12502","frontity/frontity","index.test.tsx","  test(""works with a single container id"", () => {
    // Instantiate the Frontity state and specify the `containerId` prop.
    const state = getState();
    state.googleTagManagerAnalytics.containerId = ""GTM-XXXXXXX"";

    // Render the GTM's root component.
    const { rendered, head } = renderGTM(state);

    // The GTM's script library with the specified container ID should have been
    // rendered, an also an inline script that adds the `gtm.start` event.
    expect(head.script.toComponent()).toMatchInlineSnapshot(`
      Array [
        <script
          async={true}
          data-rh={true}
          src=""https://www.googletagmanager.com/gtm.js?id=GTM-XXXXXXX""
        />,
        <script
          dangerouslySetInnerHTML={
            Object {
              ""__html"": ""
              var dataLayer = window.dataLayer || [];
              dataLayer.push({
                \\""gtm.start\\"": new Date().getTime(),
                event: \\""gtm.js\\"",
              })
              "",
            }
          }
          data-rh={true}
        />,
      ]
    `);

    // A `<noscript>` tag with an `<iframe>` should be rendered as well, to make
    // GTM work when JS is not available.
    expect(rendered).toMatchInlineSnapshot(`
      <noscript>
        <style
          dangerouslySetInnerHTML={
            Object {
              ""__html"": "".css-llz5b9-GtmCode{display:none;visibility:hidden;}"",
            }
          }
          data-emotion=""css llz5b9-GtmCode""
        />
        <iframe
          className=""css-llz5b9-GtmCode""
          height=""0""
          src=""https://www.googletagmanager.com/ns.html?id=GTM-XXXXXXX""
          title=""GTM-XXXXXXX""
          width=""0""
        />
      </noscript>
    `);
  });",""
"12607","frontity/frontity","author.tests.ts","  test(""returns 404 if the page fetched is out of range"", async () => {
    // Mock Api responses
    api.get = jest
      .fn()
      .mockResolvedValueOnce(mockResponse([author1]))
      .mockResolvedValueOnce(mockResponse([]));
    // Fetch entities
    await store.actions.source.fetch(""/author/author-1/page/3"");
    expect(store.state.source).toMatchSnapshot();
  });",""
"12694","frontity/frontity","tag.tests.ts","  test(""doesn't return 404 if the first page is empty"", async () => {
    // Mock Api responses
    api.get = jest
      .fn()
      .mockResolvedValueOnce(mockResponse([tag1]))
      .mockResolvedValueOnce(
        mockResponse([], {
          ""X-WP-Total"": ""0"",
          ""X-WP-TotalPages"": ""0"",
        })
      );
    // Fetch entities
    await store.actions.source.fetch(""/tag/tag-1/"");
    expect(store.state.source).toMatchSnapshot();
  });",""
"12770","fuse-box/fuse-box","bundle.fast.condition.test.ts","    it('should unwrap isServer', () => {
      const res = testTranspile({
        NODE_ENV: 'production',
        code: `
        if ( FuseBox.isServer){
          console.log(""isServer"")
        }
      `,
        target: 'server',
      });

      expect(res.code).toMatchSnapshot();
    });",""
"12775","fuse-box/fuse-box","bundle.polyfill.transform.test.ts","        it(`shuold insert ${moduleName}`, () => {
          const result = testTranspile({
            code: `console.log(${moduleName})`,
          });
          expect(result.requireStatementCollection).toEqual([
            {
              importType: ImportType.REQUIRE,
              statement: {
                arguments: [{ type: 'Literal', value: moduleName }],
                callee: { name: 'require', type: 'Identifier' },
                type: 'CallExpression',
              },
            },
          ]);
          expect(result.code).toMatchSnapshot();
        });",""
"12806","fuse-box/fuse-box","class-constructor-properties.test.ts","    it('should add a computed property', () => {
      const result = testTranspile({
        code: `
        const hey = ""oi""
        class A {
          public static [hey] : string = ""some value""
        }
        `,
      });

      expect(result.code).toMatchSnapshot();
    });",""
"12837","fuse-box/fuse-box","decorators.test.ts","    it('should decorate class method', () => {
      const res = testTranspile({
        code: `
        class A {
          @foo
          public hey(){}
        }
    `,
      });

      expect(res.code).toMatchSnapshot();
    });",""
"12888","fuse-box/fuse-box","es.exports.test.ts","    it('should export object with keys2 (late)  function', () => {
      const result = testTranspile({
        code: `
          export {name1 as fun, name2}
          function name1(){}
          const name2 = 2;
          `,
      });

      expect(result.code).toMatchSnapshot();
    });",""
"12913","fuse-box/fuse-box","es.exports.test.ts","      it('User defines a compiler reserved keywors ""exports""', () => {
        const result = testTranspile({
          code: `
            var exports = {};
            export { exports as default };
            exports.foo = function(){}
          `,
        });

        expect(result.code).toMatchSnapshot();
      });",""
"12984","fuse-box/fuse-box","require.statement.interceptor.test.ts","  it('it should replace require ref 2', () => {
    const result = testTranspile({
      code: `
      if (typeof require === 'function' && typeof require.ensure) {
        console.log(1);
      }
    `,
    });

    expect(result.code).toMatchSnapshot();
  });",""
"13023","fuse-box/fuse-box","scopes.test.ts","    it('Export spread 1', () => {
      const result = testTranspile({
        code: `
        const [foo, bar] = []
        export {foo, bar}
      `,
      });

      expect(result.code).toMatchSnapshot();
    });",""
"13220","geist-org/react","icon.test.tsx","  it('should work without text', () => {
    const wrapper = mount(<Button iconRight={<Icon />} />)
    const text = wrapper.find('.text')
    expect(wrapper.html()).toMatchSnapshot()
    expect(text.length).toBe(0)
  })",""
"13480","glennreyes/react-countup","CountUp.test.js","  it('re-renders change of start value correctly', (done) => {
    const { container, rerender } = render(<CountUp end={10} />);

    rerender(<CountUp start={5} end={10} />);

    setTimeout(() => {
      expect(container).toMatchSnapshot();
      done();
    }, 2000);
  });",""
"13482","glennreyes/react-countup","CountUp.test.js","  it('re-renders change of end value correctly', () => {
    const { container, rerender } = render(<CountUp end={10} />);

    rerender(<CountUp end={5} />);

    expect(container).toMatchSnapshot();
  });",""
"13497","googlechromelabs/critters","index.test.js","    it('should match snapshot', () => {
      expect(output.html).toMatchSnapshot();
    });",""
"13505","googlechromelabs/prerender-loader","index.test.js","    it('should inject returned HTML into <body>', async () => {
      const { html, document } = await compileToHtml('factory', withPrerender);

      // verify that our DOM-generated content has been prerendered into the static HTML:
      expect(html).toMatch(/<div>some returned HTML<\/div>/);
      // ... and that there's no extra children:
      expect(document.body.children).toHaveLength(2);
      // ... and that html-webpack-plugin was able to inject scripts after the content:
      expect(document.body.firstElementChild).toHaveProperty('outerHTML', '<div>some returned HTML</div>');
      expect(html).toMatchSnapshot();
    });",""
"13593","google/site-kit-wp","WidgetRenderer.test.js","	it( 'should output children directly', async () => {
		const { container } = render( <WidgetRenderer slug=""TestWidget"" />, {
			setupRegistry: setupRegistry(),
		} );

		expect( Object.values( container.firstChild.classList ) ).toEqual( [] );
		expect( container.firstChild ).toMatchSnapshot();
	} );",""
"13628","gqless/gqless","helpers.test.ts","  test('named recursive, depth 2', async () => {
    const { query, resolved } = await createTestClient();

    const data = await resolved(() => {
      return selectFields(
        query.human({
          name: 'bar',
        }),
        ['father'],
        2
      );
    });

    expect(data).toMatchInlineSnapshot(`
      Object {
        ""father"": Object {
          ""__typename"": ""Human"",
          ""dogs"": Array [
            Object {
              ""__typename"": ""Dog"",
              ""id"": ""1"",
              ""name"": ""a"",
              ""owner"": null,
            },
            Object {
              ""__typename"": ""Dog"",
              ""id"": ""2"",
              ""name"": ""b"",
              ""owner"": null,
            },
          ],
          ""father"": Object {
            ""__typename"": ""Human"",
            ""dogs"": Array [
              null,
              null,
            ],
            ""father"": null,
            ""id"": ""2"",
            ""name"": ""default"",
            ""nullFather"": null,
            ""sons"": Array [
              null,
              null,
            ],
          },
          ""id"": ""2"",
          ""name"": ""default"",
          ""nullFather"": null,
          ""sons"": Array [
            Object {
              ""__typename"": ""Human"",
              ""dogs"": Array [
                null,
                null,
              ],
              ""father"": null,
              ""id"": ""2"",
              ""name"": ""default"",
              ""nullFather"": null,
              ""sons"": Array [
                null,
                null,
              ],
            },
            Object {
              ""__typename"": ""Human"",
              ""dogs"": Array [
                null,
                null,
              ],
              ""father"": null,
              ""id"": ""2"",
              ""name"": ""default"",
              ""nullFather"": null,
              ""sons"": Array [
                null,
                null,
              ],
            },
          ],
        },
      }
    `);
  });",""
"13806","grafana/grafana","UsersListPage.test.tsx","  it('should render List page', () => {
    const { wrapper } = setup({
      hasFetched: true,
    });

    expect(wrapper).toMatchSnapshot();
  });",""
"13904","graphql-nexus/nexus","backingTypes.spec.ts","  it('throws error if root typing path does not exist', async () => {
    const metadata = new TypegenMetadata({
      outputs: { typegen: null, schema: null },
    })
    const someType = objectType({
      name: 'SomeType',
      sourceType: {
        export: 'invalid',
        module: __dirname + '/invalid_path.ts',
      },
      definition(t) {
        t.id('id')
      },
    })

    const schema = makeSchema({
      types: [someType],
      outputs: false,
    })

    const typegenInfo = await metadata.getTypegenInfo(schema)
    const typegen = new TypegenPrinter(schema as NexusGraphQLSchema, {
      ...typegenInfo,
      typegenPath: '',
    })

    try {
      typegen.print()
    } catch (e) {
      expect(e.message.replace(__dirname, '')).toMatchInlineSnapshot(
        `""Root typing path \\""/invalid_path.ts\\"" for the type \\""SomeType\\"" does not exist""`
      )
    }
  })",""
"13963","graphql-nexus/nexus","connectionPlugin.spec.ts","  it('can configure edge names per-instance', () => {
    const suffix = 'TestFieldEdge'
    const schema = makeTestSchema(
      {},
      {
        getEdgeName(fieldName, parentTypeName) {
          return `${parentTypeName}${upperFirst(fieldName)}${suffix}`
        },
      }
    )

    expect(schema.getType(`QueryUsers${suffix}`)).toMatchSnapshot()
  })",""
"14126","gregberge/loadable-components","ChunkExtractor.test.js","    it('should return other chunks if referenced', () => {
      extractor.addChunk('letters-A')
      expect(extractor.getStyleTags()).toMatchInlineSnapshot(`
                ""<link data-chunk=\\""main\\"" rel=\\""stylesheet\\"" href=\\""/dist/node/main.css\\"">
                <link data-chunk=\\""letters-A\\"" rel=\\""stylesheet\\"" href=\\""/dist/node/letters-A.css\\"">""
            `)
    })",""
"14266","gregberge/svgr","index.test.ts","  it('should convert file with previousExport of url plugin', async () => {
    const code = await compile([url(), svgr({ babel: false })])
    expect(getCode(code)).toMatchSnapshot()
  })",""
"14378","grommet/grommet","Box-test.tsx","  test('default', () => {
    const { container } = render(
      <Grommet>
        <Box />
      </Grommet>,
    );

    expect(container.firstChild).toMatchSnapshot();
  });",""
"14426","grommet/grommet","Button-kind-test.js","  test(`should apply styling according to theme size definitions`, () => {
    const { container } = render(
      <Grommet
        theme={{
          button: {
            default: {},
            size: {
              small: {
                border: {
                  radius: '4px',
                },
                pad: {
                  vertical: '4px',
                  horizontal: '8px',
                },
              },
              medium: {
                border: {
                  radius: '4px',
                },
                pad: {
                  vertical: '6px',
                  horizontal: '12px',
                },
              },
              large: {
                border: {
                  radius: '6px',
                },
                pad: {
                  vertical: '6px',
                  horizontal: '16px',
                },
              },
            },
          },
        }}
      >
        <Button label=""Button"" size=""small"" />
        {/* button with no size specified should have medium styling applied 
        by default */}
        <Button label=""Button"" />
        <Button label=""Button"" size=""medium"" />
        <Button label=""Button"" size=""large"" />
      </Grommet>,
    );
    expect(container.firstChild).toMatchSnapshot();
  });",""
"14487","grommet/grommet","Carousel-test.tsx","  test('controlled component', async () => {
    const { asFragment } = render(
      <Grommet>
        <Carousel controls=""arrows"" activeChild={1}>
          <div>Slide One</div>
          <div>Slide Two</div>
        </Carousel>
      </Grommet>,
    );

    expect(asFragment()).toMatchSnapshot();
    expect(getSlideOne()).not.toBeVisible();
    expect(getSlideTwo()).toBeVisible();
  });",""
"14763","grommet/grommet","FormField-test.js","  test(`should render custom indicator when requiredIndicator is
  element`, () => {
    const { container } = render(
      <Grommet
        theme={{
          formField: {
            label: {
              requiredIndicator: <New size=""small"" />,
            },
          },
        }}
      >
        <Form>
          <FormField label=""label"" required />
        </Form>
      </Grommet>,
    );

    expect(container.firstChild).toMatchSnapshot();
  });",""
"14777","grommet/grommet","Grid-test.js","  test('responsive', () => {
    const { container } = render(
      <Grommet>
        <Grid responsive />
        <Grid responsive={false} />
      </Grommet>,
    );

    expect(container.firstChild).toMatchSnapshot();
  });",""
"14871","grommet/grommet","MaskedInput-test.js","  test('basic', () => {
    const { container } = render(<MaskedInput name=""item"" />);
    expect(container.firstChild).toMatchSnapshot();
  });",""
"14875","grommet/grommet","MaskedInput-test.js","  test('mask', async () => {
    const onChange = jest.fn();
    const onFocus = jest.fn();
    const { getByTestId, container } = render(
      <MaskedInput
        data-testid=""test-input""
        id=""item""
        name=""item""
        mask={[
          {
            length: [1, 2],
            options: ['aa', 'bb'],
            regexp: /^[ab][ab]$|^[ab]$/,
          },
          { fixed: '!' },
          {
            length: 1,
            regexp: /^[ab]$/,
          },
        ]}
        value=""a""
        onChange={onChange}
        onFocus={onFocus}
      />,
    );
    expect(container.firstChild).toMatchSnapshot();

    fireEvent.focus(getByTestId('test-input'));

    await waitFor(() => screen.findByText('aa'));

    expectPortal('masked-input-drop__item').toMatchSnapshot();
    expect(onChange).not.toBeCalled();
    expect(onFocus).toBeCalled();
  });",""
"15018","grommet/grommet","RangeSelector-test.js","  test('step renders correct values', () => {
    let values;
    const setValues = (newValues) => {
      values = newValues;
    };
    const onChange = jest.fn((nextValues) => setValues(nextValues));
    const { container, getByLabelText } = render(
      <Grommet>
        <RangeSelector values={[0, 100]} step={3} onChange={onChange} />
      </Grommet>,
    );
    expect(container.firstChild).toMatchSnapshot();

    const lowerControl = getByLabelText('Lower Bounds');
    fireEvent.mouseDown(lowerControl);
    // fireEvent.mouseDown(lowerControl);
    fireEvent.mouseMove(document, { clientX: 31, clientY: 20 });
    fireEvent.mouseUp(document);
    expect(onChange).toBeCalled();
    expect(values).toStrictEqual([33, 100]);

    const upperControl = getByLabelText('Upper Bounds');
    fireEvent.mouseDown(upperControl);
    fireEvent.mouseMove(document, { clientX: 80, clientY: 15 });
    fireEvent.mouseUp(document);
    expect(onChange).toBeCalled();
    expect(values).toStrictEqual([0, 81]);
  });",""
"15050","grommet/grommet","Select-test.js","  test(`renders styled select options backwards compatible with legacy
      documentation (select.options.box)`, () => {
    const customTheme = {
      select: {
        options: {
          box: {
            background: 'lightblue',
          },
        },
      },
    };

    const { getByPlaceholderText, getByText, container } = render(
      <Grommet theme={customTheme}>
        <Select
          data-testid=""test-select-style-options-1""
          id=""test-options-style-id""
          options={['morning', 'afternoon', 'evening']}
          placeholder=""Select...""
        />
      </Grommet>,
    );

    expect(container.firstChild).toMatchSnapshot();

    const selectButton = getByPlaceholderText('Select...');
    fireEvent.click(selectButton);

    const optionButton = getByText('morning').closest('button');
    const style = window.getComputedStyle(optionButton.firstChild);
    expect(style.background).toBe('lightblue');
  });",""
"15059","grommet/grommet","Select-test.js","  test('Search timeout', () => {
    jest.useFakeTimers();
    const onSearch = jest.fn();
    const { container, getByPlaceholderText } = render(
      <Grommet>
        <Select
          id=""test-select""
          placeholder=""test select""
          options={['one', 'two']}
          onSearch={onSearch}
        />
      </Grommet>,
    );

    fireEvent.click(getByPlaceholderText('test select'));

    // advance timers so select can open & have focus
    act(() => {
      jest.advanceTimersByTime(200);
    });
    // add content to search box
    fireEvent.change(document.activeElement, { target: { value: 'o' } });
    expect(container.firstChild).toMatchSnapshot();
    // advance timers to cause search timeout
    act(() => {
      jest.advanceTimersByTime(100);
    });
    expect(document.activeElement).toMatchSnapshot();
  });",""
"15082","grommet/grommet","Spinner-test.tsx","  test('size renders', () => {
    const { container } = render(
      <Grommet>
        <Spinner size=""xsmall"" />
        <Spinner size=""small"" />
        <Spinner size=""medium"" />
        <Spinner size=""large"" />
        <Spinner size=""xlarge"" />
      </Grommet>,
    );

    expect(container.firstChild).toMatchSnapshot();
  });",""
"15151","grommet/grommet","TextInput-test.tsx","  test('should not have accessibility violations', async () => {
    const { container } = render(
      <Grommet>
        <TextInput a11yTitle=""aria-test"" name=""item"" />
      </Grommet>,
    );
    const results = await axe(container);
    expect(container.firstChild).toMatchSnapshot();
    expect(results).toHaveNoViolations();
  });",""
"15161","grommet/grommet","TextInput-test.tsx","  test('select suggestion', (done) => {
    const onSelect = jest.fn();
    const { getByTestId, container } = render(
      <Grommet>
        <TextInput
          data-testid=""test-input""
          plain
          size=""large""
          id=""item""
          name=""item""
          suggestions={['test', 'test1']}
          onSelect={onSelect}
        />
      </Grommet>,
    );
    expect(container.firstChild).toMatchSnapshot();

    fireEvent.focus(getByTestId('test-input'));
    fireEvent.change(getByTestId('test-input'), { target: { value: ' ' } });
    setTimeout(() => {
      expectPortal('text-input-drop__item').toMatchSnapshot();

      // Casting a custom to a primitive by erasing type with unknown.
      fireEvent.click(getByText(document as unknown as HTMLElement, 'test1'));
      expect(container.firstChild).toMatchSnapshot();
      expect(document.getElementById('text-input-drop__item')).toBeNull();
      expect(onSelect).toBeCalledWith(
        expect.objectContaining({ suggestion: 'test1' }),
      );
      done();
    }, 50);
  });",""
"15314","hashicorp/terraform-cdk","config.test.ts","    it(""parses scp"", async () => {
      const input = {
        terraformModules: [""git::username@example.com:storage.git""],
      };

      expect(parseConfig(JSON.stringify(input))).toMatchInlineSnapshot(`
        {
          ""codeMakerOutput"": "".gen"",
          ""output"": ""cdktf.out"",
          ""terraformModules"": [
            TerraformModuleConstraint {
              ""fqn"": ""storage"",
              ""name"": ""storage"",
              ""namespace"": undefined,
              ""source"": ""git::username@example.com:storage.git"",
              ""version"": undefined,
            },
          ],
        }
      `);
    });",""
"15628","hashicorp/terraform-cdk","tfExpression.test.ts","test(""propertyAccess resolves target properly"", () => {
  expect(
    resolveExpression(
      propertyAccess(
        Fn.tolist(ref(""some_resource.my_resource.some_attribute_array"", stack)),
        [0, ""name""]
      )
    )
  ).toMatchInlineSnapshot(
    `""\${tolist(some_resource.my_resource.some_attribute_array).0.name}""`
  );
});",""
"15680","hashicorp/terraform-cdk","test.ts","  test(""synth generates JSON"", async () => {
    await driver.synth();
    expect(
      driver.synthesizedStack(""python-simple"").toString()
    ).toMatchSnapshot();
  });",""
"15748","hypeserver/react-date-range","index.test.js","  test('Should render dynamic static label contents correctly', () => {
    const renderItalicLabelContent = () => (
      <i className={'italic-label-content'}>{'Italic Content'}</i>
    );
    const renderBoldLabelContent = () => <b className={'bold-label-content'}>{'Bold Content'}</b>;
    const renderSomethingElse = () => <img className={'random-image'} />;

    const renderStaticRangeLabel = function(staticRange) {
      let result;

      if (staticRange.id === 'italic') {
        result = renderItalicLabelContent();
      } else if (staticRange.id === 'bold') {
        result = renderBoldLabelContent();
      } else {
        result = renderSomethingElse();
      }

      return result;
    };

    const wrapper = shallow(
      <DefinedRange
        staticRanges={[
          {
            id: 'italic',
            range: {},
            isSelected(range) {
              const definedRange = this.range();
              return (
                isSameDay(range.startDate, definedRange.startDate) &&
                isSameDay(range.endDate, definedRange.endDate)
              );
            },
            hasCustomRendering: true,
          },
          {
            label: 'Static Label',
            range: {},
            isSelected(range) {
              const definedRange = this.range();
              return (
                isSameDay(range.startDate, definedRange.startDate) &&
                isSameDay(range.endDate, definedRange.endDate)
              );
            },
          },
          {
            id: 'whatever',
            range: {},
            isSelected(range) {
              const definedRange = this.range();
              return (
                isSameDay(range.startDate, definedRange.startDate) &&
                isSameDay(range.endDate, definedRange.endDate)
              );
            },
            hasCustomRendering: true,
          },
          {
            id: 'bold',
            range: {},
            isSelected(range) {
              const definedRange = this.range();
              return (
                isSameDay(range.startDate, definedRange.startDate) &&
                isSameDay(range.endDate, definedRange.endDate)
              );
            },
            hasCustomRendering: true,
          },
        ]}
        renderStaticRangeLabel={renderStaticRangeLabel}
      />
    );

    expect(wrapper).toMatchSnapshot();
  });",""
"16046","integrations/slack","pull-request.test.js","  test('works for notification messages with statuses', async () => {
    const pullRequest = {
      ...pullRequestOpened.pull_request,
      labels: [],
    };
    const prMessage = new PullRequest({
      pullRequest,
      repository: pullRequestOpened.repository,
      eventType: 'pull_request.opened',
      unfurl: false,
      statuses: combinedStatus.statuses,
      sender: pullRequestOpened.sender,
    });
    const rendered = prMessage.getRenderedMessage();
    expect(rendered).toMatchSnapshot();
  });",""
"16055","integrations/slack","push.test.js","  test('works', async () => {
    const pushMessage = new Push({
      push,
    });
    const rendered = pushMessage.getRenderedMessage();
    expect(rendered).toMatchSnapshot();
  });",""
"16076","integrations/slack","auto-unfurl-prompt.test.js","  test('works', async () => {
    const unfurl = {
      githubRepoId: 12345678,
    };
    const team = {
      domain: 'bestslackteam',
    };
    const message = new AutoUnfurlPrompt('integrations', 'snappydoo', unfurl, team);
    expect(message.getAttachment()).toMatchSnapshot();
  });",""
"16213","jbetancur/react-data-table-component","DataTable.test.tsx","	test('should render correctly with a default sort field and the native sort icon', () => {
		const mock = dataMock({ sortable: true });
		const { container } = render(<DataTable data={mock.data} columns={mock.columns} />);

		expect(container.firstChild).toMatchSnapshot();
	});",""
"16395","jestjs/jest","coverageReport.test.ts","test('collects coverage from duplicate files avoiding shared cache', () => {
  const args = [
    '--coverage',
    // Ensure the exitCode is non-zero if super edge case with coverage triggers
    '--coverageThreshold',
    '{""global"": {""lines"": 100}}',
    '--collectCoverageFrom',
    'cached-duplicates/a/identical.js',
    '--collectCoverageFrom',
    'cached-duplicates/b/identical.js',
    '--',
    'identical.test.js',
  ];
  // Run once to prime the cache
  runJest(DIR, args, {stripAnsi: true});

  // Run for the second time
  const {stdout, exitCode} = runJest(DIR, args, {stripAnsi: true});
  expect(stdout).toMatchSnapshot();
  expect(exitCode).toBe(0);
});",""
"16526","jestjs/jest","testFailing.test.ts","test('works with concurrent mode', () => {
  const result = runWithJson(dir, ['worksWithConcurrentMode.test.js']);
  expect(result.exitCode).toBe(1);
  const {rest} = extractSummary(result.stderr);
  expect(rest).toMatchSnapshot();
});",""
"16686","jestjs/jest","diff.test.ts","    test('diff default no color', () => {
      expect(diff(aTrailingSpaces, bTrailingSpaces)).toMatchSnapshot();
    });",""
"16729","jestjs/jest","printDiffOrStringify.test.ts","  test('expected and received are single line with multiple changes', () => {
    const expected = 'delete common expected common prev';
    const received = 'insert common received common next';
    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();
  });",""
"16787","jestjs/jest","utils.test.ts","  it('wraps a long string containing ansi chars', () => {
    const string =
      `abcde ${chalk.red.bold('red-bold')} 1234456` +
      `${chalk.dim('bcd')} ` +
      '123ttttttththththththththththththththththththththth' +
      `tetetetetettetetetetetetetete${chalk.underline.bold('stnhsnthsnth')}` +
      'ssot';
    expect(wrapAnsiString(string, 10)).toMatchSnapshot();
    expect(stripAnsi(wrapAnsiString(string, 10))).toMatchSnapshot();
  });",""
"16797","jestjs/jest","related.test.js","test('sample', () => {
  expect({}).toMatchSnapshot();
});",""
"16981","jsonresume/resume-cli","main.test.js","    it('should export a resume from the path specified by --resume to the path specified immediately after the export command', async () => {
      const { stdout } = await run([
        'export',
        '/test-resumes/exported-resume.html',
        '--resume',
        '/test-resumes/resume.json',
      ]);
      expect(stdout).toMatchInlineSnapshot(`
        ""
        Done! Find your new .html resume at:
         /test-resumes/exported-resume.html
        ""
      `);
    });",""
"17049","juliomrqz/statusfy","links.spec.js","  test('should render external links correctly', () => {
    for (const link of externalLinks) {
      const output = mdL.render(link)

      expect(output).toMatchSnapshot()
    }
  })",""
"17093","katex/katex","render-a11y-string-spec.js","        test(""\\phase"", () => {
            const result = renderA11yString(""\\phase{a}"");
            expect(result).toMatchInlineSnapshot(
                `""start phase angle, a, end phase angle""`,
            );
        });",""
"17105","katex/katex","render-a11y-string-spec.js","        test(""\\overbrace"", () => {
            const result = renderA11yString(""\\overbrace{1+2}"");
            expect(result).toMatchInlineSnapshot(
                `""start overbrace, 1, plus, 2, end overbrace""`,
            );
        });",""
"17154","katex/katex","katex-spec.js","    it(""should render with trust setting"", function() {
        const built = getBuilt(img, trustSettings);
        expect(built).toMatchSnapshot();
    });",""
"17273","keystonejs/keystone","insert-break-and-delete.test.tsx","test('insert break in last (inline) child prop', () => {
  let editor = makeEditor(
    <editor>
      <component-block
        component=""withChildElements""
        props={{ prop: '', block: null, inline: null }}
      >
        <component-block-prop propPath={['block']}>
          <paragraph>
            <text>some text</text>
          </paragraph>
        </component-block-prop>
        <component-inline-prop propPath={['inline']}>
          <text>
            some more
            <cursor /> text
          </text>
        </component-inline-prop>
      </component-block>
      <paragraph>
        <text />
      </paragraph>
    </editor>,
    { componentBlocks }
  );
  editor.insertBreak();
  expect(editor).toMatchInlineSnapshot(`
    <editor>
      <component-block
        component=""withChildElements""
        props={
          Object {
            ""block"": null,
            ""inline"": null,
            ""prop"": """",
          }
        }
      >
        <component-block-prop
          propPath={
            Array [
              ""block"",
            ]
          }
        >
          <paragraph>
            <text>
              some text
            </text>
          </paragraph>
        </component-block-prop>
        <component-inline-prop
          propPath={
            Array [
              ""inline"",
            ]
          }
        >
          <text>
            some more
          </text>
        </component-inline-prop>
      </component-block>
      <paragraph>
        <text>
          <cursor />
           text
        </text>
      </paragraph>
      <paragraph>
        <text>
          
        </text>
      </paragraph>
    </editor>
  `);
});",""
"17489","kong/httpsnippet","utils.test.ts","  it('returns all available targets', () => {
    expect(availableTargets()).toMatchSnapshot();
  });",""
"17565","kyleamathews/typography.js","typography.test.js","  it(""should return CSS as a string"", () => {
    expect(
      typography({
        includeNormalize: false,
      }).toString()
    ).toMatchSnapshot()
  })",""
"17602","lensapp/lens","hiding-preference-when-disabled.test.ts","  it(""renders"", () => {
    expect(result.baseElement).toMatchSnapshot();
  });",""
"17786","lensapp/lens","listing-active-helm-repositories-in-preferences.test.ts","      it(""renders"", () => {
        expect(rendered.baseElement).toMatchSnapshot();
      });",""
"17852","lensapp/lens","navigation-to-application-preferences.test.tsx","      it(""renders"", () => {
        expect(rendered.container).toMatchSnapshot();
      });",""
"17867","lensapp/lens","navigation-to-proxy-preferences.test.ts","    it(""renders"", () => {
      expect(rendered.container).toMatchSnapshot();
    });",""
"17873","lensapp/lens","navigation-to-telemetry-preferences.test.tsx","    it(""renders"", () => {
      expect(rendered.container).toMatchSnapshot();
    });",""
"17950","lensapp/lens","projected.test.tsx","  it(""renders a secret source, when provided"", () => {
    const projectedVolume: ProjectedSource = {
      defaultMode: 0o777,
      sources: [{
        secret: {
          name: ""my-projected-secret"",
          items: [{
            key: ""foo"",
            path: ""/bar"",
          }],
        },
      }],
    };
    const projectedVolumeName = ""my-projected"";
    const pod = new Pod({
      apiVersion: ""v1"",
      kind: ""Pod"",
      metadata: {
        name: ""my-pod"",
        namespace: ""default"",
        resourceVersion: ""1"",
        uid: ""123"",
        selfLink: ""/api/v1/pod/default/my-pod"",
      },
      spec: {
        volumes: [{
          name: projectedVolumeName,
          projected: projectedVolume,
        }],
      },
    });
    const result = render((
      <Projected
        pod={pod}
        volumeName={projectedVolumeName}
        variant={projectedVolume}
      />
    ));

    expect(result.baseElement).toMatchSnapshot();
    expect(result.getByText(""foo⇢/bar"", { exact: false })).toBeTruthy();
  });",""
"17957","lensapp/lens","secret-key.test.tsx","      it(""renders"", () => {
        expect(result.baseElement).toMatchSnapshot();
      });",""
"17982","lensapp/lens","tooltip.test.tsx","    it(""renders"", () => {
      expect(result.baseElement).toMatchSnapshot();
    });",""
"18252","ln-zap/zap-desktop","invoice.spec.js","    it('should handle ADD_INVOICE_FAILURE', () => {
      const action = {
        type: ADD_INVOICE_FAILURE,
        error: 'some error',
      }
      expect(snapshotDiff(reducer(undefined, {}), reducer(undefined, action))).toMatchSnapshot()
    })",""
"18303","ln-zap/zap-desktop","neutrino.spec.js","    it('should handle SET_SYNC_STATUS_IN_PROGRESS', () => {
      const action = {
        type: SET_SYNC_STATUS_IN_PROGRESS,
      }
      expect(snapshotDiff(reducer(undefined, {}), reducer(undefined, action))).toMatchSnapshot()
    })",""
"18640","magento/pwa-studio","useCheckoutPage.spec.js","test('should dispatch checkout review button clicked event', () => {
    const mockDispatchEvent = jest.fn();

    useEventingContext.mockReturnValue([{}, { dispatch: mockDispatchEvent }]);

    const { talonProps, update } = getTalonProps(defaultProps);

    talonProps.handleReviewOrder();

    update();

    expect(mockDispatchEvent).toBeCalledTimes(1);
    expect(mockDispatchEvent.mock.calls[0][0]).toMatchSnapshot();
});",""
"18754","magento/pwa-studio","useActionMenu.spec.js","    test('handleEditWishlist() runs the mutation with the expected values', () => {
        const editWishlist = jest.fn();
        useMutation.mockReturnValueOnce([editWishlist, {}]);

        const tree = createTestInstance(<Component {...baseProps} />);

        const { root } = tree;
        const { talonProps } = root.findByType('i').props;

        const { handleEditWishlist } = talonProps;

        const data = {
            name: 'Birthday Party',
            wishlistId: 5
        };

        act(() => {
            handleEditWishlist(data);
        });

        expect(editWishlist.mock.calls[0][0]).toMatchSnapshot();
    });",""
"18873","magento/pwa-studio","editForm.spec.js","test('renders form when shouldShowNewPassword is false', () => {
    const props = {
        ...defaultProps,
        shouldShowNewPassword: false
    };

    const tree = createTestInstance(
        <Form>
            <EditForm {...props} />
        </Form>
    );
    expect(tree.toJSON()).toMatchSnapshot();
});",""
"18973","magento/pwa-studio","priceSummary.spec.js","test('renders summary with loading state if query is loading', () => {
    usePriceSummary.mockReturnValueOnce({
        ...defaultTalonProps,
        isLoading: true
    });

    const tree = createTestInstance(<PriceSummary />);

    expect(tree.toJSON()).toMatchSnapshot();
});",""
"18997","magento/pwa-studio","product.spec.js","test('renders configurable product with options', () => {
    useProduct.mockReturnValueOnce({
        addToWishlistProps: {
            atwProp1: 'value1'
        },
        errorMessage: undefined,
        handleEditItem: jest.fn(),
        handleRemoveFromCart: jest.fn(),
        handleUpdateItemQuantity: jest.fn(),
        isEditable: true,
        product: {
            currency: 'USD',
            image: {},
            name: '',
            urlKey: 'unittest',
            urlSuffix: '.html',
            options: [
                {
                    option_label: 'Option 1',
                    value_label: 'Value 1'
                },
                {
                    option_label: 'Option 2',
                    value_label: 'Value 2'
                }
            ],
            quantity: 1,
            unitPrice: 1
        },
        loginToastProps: null,
        isProductUpdating: false
    });

    const tree = createTestInstance(<Product {...props} />);

    expect(tree.toJSON()).toMatchSnapshot();
});",""
"19112","magento/pwa-studio","cmsDynamicBlock.ee.spec.js","    it('renders null when loading', () => {
        useCmsDynamicBlock.mockReturnValueOnce({
            data: null,
            error: undefined,
            loading: true
        });

        const component = createTestInstance(<Component />);

        expect(component.toJSON()).toMatchSnapshot();
    });",""
"19315","magento/pwa-studio","textarea.spec.js","    it('renders label only when data is missing', () => {
        givenDefaultValues();
        const tree = createTestInstance(<Component />);

        expect(tree.toJSON()).toMatchSnapshot();
    });",""
"19451","magento/pwa-studio","wishlistItems.spec.js","test('it renders list of items', () => {
    const props = {
        items: [{ id: 1, sku: 'chain-wallet' }, { id: 2, sku: 'nike-shoes' }]
    };

    const tree = createTestInstance(<WishlistItems {...props} />);

    expect(tree.toJSON()).toMatchSnapshot();
});",""
"19714","mattermost/mattermost-webapp","add_groups_to_team_modal.test.tsx","    test('should match when renderOption is called', () => {
        const wrapper = shallow<AddGroupsToTeamModal>(
            <AddGroupsToTeamModal {...baseProps}/>,
        );

        const option = {id: 'id_1', label: 'label_1', value: 'value_1'};
        let isSelected = false;
        const onAdd = jest.fn();
        const onMouseMove = jest.fn();

        expect(wrapper.instance().renderOption(option, isSelected, onAdd, onMouseMove)).toMatchSnapshot();

        isSelected = true;
        expect(wrapper.instance().renderOption(option, isSelected, onAdd, onMouseMove)).toMatchSnapshot();
    });",""
"19775","mattermost/mattermost-webapp","data_grid.test.tsx","    test('should match snapshot with custom classes', () => {
        const wrapper = shallow(
            <DataGrid
                {...baseProps}
                rows={[
                    {cells: {name: 'Joe Schmoe', team: 'Admin Team'}},
                    {cells: {name: 'Foo Bar', team: 'Admin Team'}},
                    {cells: {name: 'Some Guy', team: 'Admin Team'}},
                ]}
                columns={[
                    {name: 'Name', field: 'name'},
                    {name: 'Team', field: 'team'},
                ]}
                className={'customTable'}
            />,
        );
        expect(wrapper).toMatchSnapshot();
    });",""
"19783","mattermost/mattermost-webapp","data_retention_settings.test.tsx","    test('should match snapshot with Global Policies disabled', () => {
        const props = baseProps;
        props.config.DataRetentionSettings.EnableMessageDeletion = false;
        props.config.DataRetentionSettings.EnableFileDeletion = false;
        props.config.DataRetentionSettings.EnableBoardsDeletion = false;
        const wrapper = shallow(
            <DataRetentionSettings
                {...props}
            />,
        );
        expect(wrapper).toMatchSnapshot();
    });",""
"19870","mattermost/mattermost-webapp","guest_permissions_tree.test.tsx","    test('should match snapshot on license without LDAPGroups', () => {
        const wrapper = shallow(
            <GuestPermissionsTree
                {...defaultProps}
                license={{}}
            />,
        );
        expect(wrapper).toMatchSnapshot();
    });",""
"19962","mattermost/mattermost-webapp","system_users_list.test.tsx","        it('and mfa disabled', () => {
            const wrapper = shallow(
                <SystemUsersList
                    {...props}
                    mfaEnabled={false}
                />,
            );
            expect(wrapper).toMatchSnapshot();
        });",""
"20253","mattermost/mattermost-webapp","custom_status_emoji.test.tsx","    it('should match snapshot', () => {
        const wrapper = mount(<CustomStatusEmoji/>, {wrappingComponent: Provider, wrappingComponentProps: {store}});
        expect(wrapper).toMatchSnapshot();
    });",""
"20319","mattermost/mattermost-webapp","add_emoji.test.tsx","    test('should match snapshot', () => {
        const wrapper = shallow(
            <AddEmoji {...baseProps}/>,
            {context},
        );

        expect(wrapper).toMatchSnapshot();
        expect(wrapper.state('image')).toBeNull();
        expect(wrapper.state('imageUrl')).toEqual('');
        expect(wrapper.state('name')).toEqual('');
    });",""
"20449","mattermost/mattermost-webapp","hint_toast.test.tsx","    test('should match snapshot', () => {
        const wrapper = shallow(
            <HintToast
                onDismiss={jest.fn()}
            >{'A hint'}</HintToast>,
        );

        expect(wrapper).toMatchSnapshot();
    });",""
"20696","mattermost/mattermost-webapp","channel_intro_message.test.tsx","        test('should match snapshot, with teammate', () => {
            const wrapper = shallow(
                <ChannelIntroMessage
                    {...props}
                    teammate={user1 as UserProfile}
                    teammateName='my teammate'
                />,
            );
            expect(wrapper).toMatchSnapshot();
        });",""
"20875","mattermost/mattermost-webapp","select_team.test.tsx","    test('should match snapshot, on loading', () => {
        const wrapper = shallow<SelectTeam>(
            <SelectTeam {...baseProps}/>,
        );
        wrapper.setState({loadingTeamId: 'loading_team_id'});
        expect(wrapper).toMatchSnapshot();
    });",""
"20890","mattermost/mattermost-webapp","setting_picture.test.tsx","    test('should match snapshot, user icon on source', () => {
        const props = {...baseProps, onSetDefault: jest.fn()};
        const wrapper = shallow(
            <SettingPicture {...props}/>,
        );

        expect(wrapper).toMatchSnapshot();
    });",""
"20920","mattermost/mattermost-webapp","sidebar_channel.test.tsx","    test('should match snapshot when DM channel', () => {
        const props = {
            ...baseProps,
            channel: {
                ...baseProps.channel,
                type: 'D' as ChannelType,
            },
        };

        const wrapper = shallow(
            <SidebarChannel {...props}/>,
        );

        expect(wrapper).toMatchSnapshot();
    });",""
"20922","mattermost/mattermost-webapp","sidebar_channel_link.test.tsx","    test('should match snapshot', () => {
        const wrapper = shallow(
            <SidebarChannelLink {...baseProps}/>,
        );

        expect(wrapper).toMatchSnapshot();
    });",""
"21142","mattermost/mattermost-webapp","menu.test.tsx","    test('should hide the correct dividers on mobile', () => {
        const utils = require('utils/utils'); //eslint-disable-line global-require
        utils.isMobile.mockReturnValue(false);
        const pseudoMenu = document.createElement('div');
        const listOfItems = [
            'mobile-menu-divider',
            'mobile-menu-divider',
            'mobile-menu-divider',
            'mobile-menu-divider',
            'other',
            'other',
            'mobile-menu-divider',
            'mobile-menu-divider',
            'other',
            'mobile-menu-divider',
            'mobile-menu-divider',
            'mobile-menu-divider',
            'other',
            'other',
            'other',
            'mobile-menu-divider',
            'mobile-menu-divider',
            'mobile-menu-divider',
            'mobile-menu-divider',
        ];
        for (const className of listOfItems) {
            const element = document.createElement('div');
            element.classList.add(className);
            pseudoMenu.append(element);
        }

        const wrapper = shallow<Menu>(<Menu ariaLabel='test-label'>{'text'}</Menu>);
        const instance = wrapper.instance();
        Object.assign(instance.node, {current: pseudoMenu});
        instance.hideUnneededDividers();

        expect(instance.node.current).toMatchInlineSnapshot(`
        <div>
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""other""
          />
          <div
            class=""other""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: block;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""other""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: block;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""other""
          />
          <div
            class=""other""
          />
          <div
            class=""other""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
          <div
            class=""mobile-menu-divider""
            style=""display: none;""
          />
        </div>
        `);
    });",""
"21196","mattermost/mattermost-webapp","channel_header_plug.test.tsx","    test('should match snapshot with one extended component', () => {
        const wrapper = mountWithIntl(
            <ChannelHeaderPlug
                components={[testPlug]}
                channel={{} as Channel}
                channelMember={{} as ChannelMembership}
                theme={{} as Theme}
                sidebarOpen={false}
                actions={{
                    handleBindingClick: jest.fn(),
                    postEphemeralCallResponseForChannel: jest.fn(),
                    openAppsModal: jest.fn(),
                }}
                appBindings={[]}
                appsEnabled={false}
                shouldShowAppBar={false}
            />,
        );
        expect(wrapper).toMatchSnapshot();
    });",""
"21318","maxchehab/phelia","reconciler.spec.tsx","    it(""renders a default Channel Select Menu"", async () => {
      const blocks = await render(React.createElement(component));
      expect(blocks).toMatchSnapshot();
    });",""
"21324","maxchehab/phelia","reconciler.spec.tsx","    it(""renders a Multi Static Select Menu with one option group"", async () => {
      const blocks = await render(React.createElement(component));
      expect(blocks).toMatchSnapshot();
    });",""
"21486","metamask/metamask-mobile","index.test.tsx","  it('should render correctly', () => {
    const wrapper = shallow(
      <Provider store={store}>
        <Step2 />
      </Provider>,
    );
    expect(wrapper).toMatchSnapshot();
  });",""
"21539","metamask/metamask-mobile","index.test.tsx","  it('should render correctly', () => {
    const wrapper = shallow(
      <Provider store={store}>
        <AccountBackupStep1 />
      </Provider>,
    );
    expect(wrapper).toMatchSnapshot();
  });",""
"21597","michallytek/type-graphql","default-values.ts","    it(""should not infer default value from a property initializer"", async () => {
      const sampleOptionInputType = schema.getType(""SampleOptionInput"")!;
      const sampleOptionInputSDL = printType(sampleOptionInputType);

      expect(sampleOptionInputSDL).toMatchInlineSnapshot(`
        ""input SampleOptionInput {
          inputField: String! = ""defaultValueFromOption""
        }""
      `);
    });",""
"21759","mikro-orm/mikro-orm","EntityGenerator.test.ts","  test('enum with default value [postgres]', async () => {
    const orm = await initORMPostgreSql();
    await orm.getSchemaGenerator().dropSchema();
    const schema = `create table ""publisher2"" (""id"" serial primary key, ""test"" varchar null default '123', ""type"" text check (""type"" in ('local', 'global')) not null default 'local', ""type2"" text check (""type2"" in ('LOCAL', 'GLOBAL')) default 'LOCAL')`;
    await orm.getSchemaGenerator().execute(schema);
    const generator = orm.getEntityGenerator();
    const dump = await generator.generate({ save: false, baseDir: './temp/entities' });
    expect(dump).toMatchSnapshot('postgres-entity-dump-enum-default-value');
    await orm.getSchemaGenerator().execute(`drop table if exists ""publisher2""`);
    await orm.close(true);
  });",""
"21769","mikro-orm/mikro-orm","Migrator.sqlite.test.ts","  test('generate js schema migration', async () => {
    const dateMock = jest.spyOn(Date.prototype, 'toISOString');
    dateMock.mockReturnValue('2019-10-13T21:48:13.382Z');
    const migrationsSettings = orm.config.get('migrations');
    orm.config.set('migrations', { ...migrationsSettings, emit: 'js' }); // Set migration type to js
    const migrator = orm.getMigrator();
    const migration = await migrator.createMigration();
    expect(migration).toMatchSnapshot('migration-js-dump');
    orm.config.set('migrations', migrationsSettings); // Revert migration config changes
    await remove(process.cwd() + '/temp/migrations/' + migration.fileName);
  });",""
"21811","mikro-orm/mikro-orm","GH3230.test.ts","test('mediumint column type in mysql as FK', async () => {
  const sql = await orm.getSchemaGenerator().getCreateSchemaSQL();
  expect(sql).toMatchSnapshot();
  await orm.getSchemaGenerator().execute(sql);
  const diff = await orm.getSchemaGenerator().getUpdateSchemaSQL();
  expect(diff).toBe('');
});",""
"21890","mlaursen/react-md","usePanels.tsx","  it(""should provide the correct props to be passed to an ExpansionList and a list of ExpansionPanel components"", () => {
    const { container, getByTestId } = render(<Test />);
    const list = getByTestId(""list"");

    expect(container).toMatchSnapshot();
    expect(list.childNodes.length).toBe(3);
  });",""
"21909","mlaursen/react-md","Select.tsx","  it(""should update the label and select class names when focused as well as hiding the placeholder text"", () => {
    const onBlur = jest.fn();
    const onFocus = jest.fn();
    const { container } = render(
      <Select
        {...PROPS}
        label=""Label""
        placeholder=""Choose...""
        onBlur={onBlur}
        onFocus={onFocus}
      />
    );

    const select = getSelect();
    expect(container).toMatchSnapshot();

    fireEvent.focus(select);
    expect(onFocus).toBeCalledTimes(1);
    expect(container).toMatchSnapshot();

    fireEvent.blur(select);
    expect(onBlur).toBeCalledTimes(1);
  });",""
"21947","mlaursen/react-md","ToggleContainer.tsx","  it(""should render correctly"", () => {
    const props = { children: <input type=""checkbox"" /> };
    const { container, rerender } = render(<ToggleContainer {...props} />);

    expect(container).toMatchSnapshot();

    rerender(<ToggleContainer {...props} inline />);
    expect(container).toMatchSnapshot();

    rerender(<ToggleContainer {...props} stacked />);
    expect(container).toMatchSnapshot();

    rerender(<ToggleContainer {...props} inline stacked />);
    expect(container).toMatchSnapshot();
  });",""
"22007","mlaursen/react-md","useContextMenu.tsx","  it(""should allow the anchor, baseId, and menuLabel to be configured"", () => {
    const { getByTestId, getByRole } = render(
      <Test
        anchor={BELOW_CENTER_ANCHOR}
        baseId=""custom-context-menu""
        menuLabel=""Custom Label""
      />
    );
    const container = getByTestId(""container"");

    expect(() => getByRole(""menu"")).toThrow();

    fireEvent.contextMenu(container);
    expect(document.body).toMatchSnapshot();
    const menu = getByRole(""menu"", { name: ""Custom Label"" });
    expect(menu).toBeInTheDocument();
  });",""
"22030","mlaursen/react-md","CrossFade.tsx","  it(""should default to using appear transitions"", () => {
    const { container, getByTestId, rerender } = render(
      <CrossFade>
        <div data-testid=""element"">This is some content.</div>
      </CrossFade>
    );
    const getElement = (): HTMLElement => getByTestId(""element"");

    expect(getElement).not.toThrow();
    expect(container).toMatchSnapshot();

    act(() => {
      jest.runAllTimers();
    });
    expect(getElement).not.toThrow();
    expect(container).toMatchSnapshot();

    rerender(
      <CrossFade key=""new-transition"">
        <div data-testid=""element"">This is some new content.</div>
      </CrossFade>
    );
    expect(getElement).not.toThrow();
    expect(container).toMatchSnapshot();

    act(() => {
      jest.runAllTimers();
    });
    expect(getElement).not.toThrow();
    expect(container).toMatchSnapshot();
  });",""
"22059","mlaursen/react-md","Tree.tsx","    it(""should work with the tree item hooks for multi selection"", () => {
      function Test(): ReactElement {
        const selection = useTreeItemSelection([], true);
        const expansion = useTreeItemExpansion([]);

        return (
          <Tree
            id=""multi-select-tree""
            data={folders}
            aria-label=""Tree""
            {...selection}
            {...expansion}
          />
        );
      }

      const { getByRole, container } = render(<Test />);

      const tree = getByRole(""tree"", { name: ""Tree"" });
      expect(tree).toHaveAttribute(""aria-multiselectable"", ""true"");
      expect(container).toMatchSnapshot();

      const folder1 = getByRole(""treeitem"", { name: ""Folder 1"" });
      const folder2 = getByRole(""treeitem"", { name: ""Folder 2"" });
      const folder3 = getByRole(""treeitem"", { name: ""Folder 3"" });
      expect(folder1).toHaveAttribute(""aria-selected"", ""false"");
      expect(folder2).toHaveAttribute(""aria-selected"", ""false"");
      expect(folder3).toHaveAttribute(""aria-selected"", ""false"");

      fireEvent.click(folder1);
      expect(folder1).toHaveAttribute(""aria-selected"", ""true"");
      expect(folder2).toHaveAttribute(""aria-selected"", ""false"");
      expect(folder3).toHaveAttribute(""aria-selected"", ""false"");
      expect(container).toMatchSnapshot();

      fireEvent.click(folder2);
      expect(folder1).toHaveAttribute(""aria-selected"", ""true"");
      expect(folder2).toHaveAttribute(""aria-selected"", ""true"");
      expect(folder3).toHaveAttribute(""aria-selected"", ""false"");
      expect(container).toMatchSnapshot();

      fireEvent.click(folder2);
      expect(folder1).toHaveAttribute(""aria-selected"", ""true"");
      expect(folder2).toHaveAttribute(""aria-selected"", ""false"");
      expect(folder3).toHaveAttribute(""aria-selected"", ""false"");
      expect(container).toMatchSnapshot();
    });",""
"22196","mycryptohq/mycrypto","helpers.spec.ts","  it('correctly process advanced erc20 form data for gas limit estimate', () => {
    expect(processFormForEstimateGas(fAdvancedERC20TxSendFormikFields)).toMatchSnapshot();
  });",""
"22268","necolas/react-native-web","index-test.js","    test('value is set', () => {
      const { container } = render(<CheckBox aria-readonly={true} />);
      expect(container.firstChild).toMatchSnapshot();
    });",""
"22324","necolas/react-native-web","compiler-createReactDOMStyle-test.js","    test('""Noto, System""', () => {
      expect(createReactDOMStyle({ fontFamily: 'Noto, System' }))
        .toMatchInlineSnapshot(`
        {
          ""fontFamily"": ""Noto,-apple-system,BlinkMacSystemFont,\\""Segoe UI\\"",Roboto,Helvetica,Arial,sans-serif"",
        }
      `);
      expect(createReactDOMStyle({ font: '14px Noto, System' }))
        .toMatchInlineSnapshot(`
        {
          ""font"": ""14px Noto, -apple-system,BlinkMacSystemFont,\\""Segoe UI\\"",Roboto,Helvetica,Arial,sans-serif"",
        }
      `);
    });",""
"22557","nitin42/redocx","Bullets.test.js","it('should render a list of dots with style prop', () => {
  const App = () => (
    <List style={{ color: 'red' }}>
      <BulletItem>One</BulletItem>
      <BulletItem>Two</BulletItem>
    </List>
  )

  expect(render(<App />)).toMatchSnapshot();
})",""
"22570","nitin42/redocx","Footer.test.js","it('sanity check', () => {
  expect(render(<Footer />)).toMatchSnapshot();
})",""
"22611","node-gh/gh","cmd.test.ts","    it('returns ', () => {
        tryResolvingByPlugin(234).fork(
            path => {
                expect(path).toMatchInlineSnapshot(`""Both args should be strings""`)
            },
            () => {}
        )
    })",""
"22857","okonet/lint-staged","loadConfig.spec.js","  it('should return empty object "".lintstagedrc.json"" file is invalid', async () => {
    expect.assertions(1)

    const configFile = path.join(__dirname, '__mocks__', '.lintstagedrc.json')

    await fs.writeFile(configFile, '{')

    const result = await loadConfig({ configPath: configFile }, logger)

    expect(result).toMatchInlineSnapshot(`{}`)

    await fs.rm(configFile)
  })",""
"22879","okonet/lint-staged","validateConfig.spec.js","  it('should throw when detecting deprecated advanced configuration', () => {
    const advancedConfig = {
      chunkSize: 10,
      concurrent: false,
      globOptions: { matchBase: false },
      ignore: ['test.js'],
      linters: {
        '*.js': ['eslint'],
      },
      relative: true,
      renderer: 'silent',
      subTaskConcurrency: 10,
    }

    expect(() => validateConfig(advancedConfig, configPath, logger)).toThrowErrorMatchingSnapshot()
    expect(logger.printHistory()).toMatchSnapshot()
  })",""
"22951","opensearch-project/opensearch-dashboards","env.test.ts","test('correctly creates default environment in prod non-distributable mode.', () => {
  mockPackage.raw = {
    branch: 'feature-v1',
    version: 'v1',
    build: {
      distributable: false,
      number: 100,
      sha: 'feature-v1-build-sha',
    },
  };

  const defaultEnv = Env.createDefault(
    REPO_ROOT,
    getEnvOptions({
      cliArgs: { dev: false },
      configs: ['/some/other/path/some-opensearch-dashboards.yml'],
    })
  );

  expect(defaultEnv).toMatchSnapshot('env properties');
});",""
"22983","opensearch-project/opensearch-dashboards","flags.test.ts","it('guesses types for unexpected flags', () => {
  expect(
    getFlags(['-abc', '--abc=bcd', '--no-foo', '--bar'], {
      allowUnexpected: true,
      guessTypesForUnexpectedFlags: true,
    })
  ).toMatchInlineSnapshot(`
    Object {
      ""_"": Array [],
      ""a"": true,
      ""abc"": ""bcd"",
      ""b"": true,
      ""bar"": true,
      ""c"": true,
      ""debug"": false,
      ""foo"": false,
      ""help"": false,
      ""quiet"": false,
      ""silent"": false,
      ""unexpected"": Array [
        ""-a"",
        ""-b"",
        ""-c"",
        ""-abc"",
        ""--abc=bcd"",
        ""--no-foo"",
        ""--bar"",
      ],
      ""v"": false,
      ""verbose"": false,
    }
  `);
});",""
"23026","opensearch-project/opensearch-dashboards","theme_tags.test.ts","it('returns specific tags when passed a comma separated list', () => {
  expect(parseThemeTags('v8light, v7dark,v7light')).toMatchInlineSnapshot(`
    Array [
      ""v7dark"",
      ""v7light"",
      ""v8light"",
    ]
  `);
});",""
"23052","opensearch-project/opensearch-dashboards","filter_by_id.test.ts","it('combines mutliple filters to select any bundle which is matched', () => {
  expect(print(filterById(['foo', 'bar'], bundles))).toMatchInlineSnapshot(`""bar, foo""`);
  expect(print(filterById(['bar', 'abc*'], bundles))).toMatchInlineSnapshot(
    `""abc, abcd, abcde, bar""`
  );
});",""
"23092","opensearch-project/opensearch-dashboards","get_failures.test.ts","it('discovers failures in ftr report', async () => {
  const failures = getFailures(await parseTestReport(FTR_REPORT));
  expect(failures).toMatchInlineSnapshot(`
    Array [
      Object {
        ""classname"": ""Chrome X-Pack UI Functional Tests.x-pack/test/functional/apps/maps/sample_data·js"",
        ""failure"": ""
            Error: retry.try timeout: TimeoutError: Waiting for element to be located By(css selector, [data-test-subj~=\\""layerTocActionsPanelToggleButtonRoad_Map_-_Bright\\""])
    Wait timed out after 10055ms
        at /var/lib/jenkins/workspace/elastic+kibana+master/JOB/x-pack-ciGroup7/node/immutable/kibana/node_modules/selenium-webdriver/lib/webdriver.js:834:17
        at process._tickCallback (internal/process/next_tick.js:68:7)
        at lastError (/var/lib/jenkins/workspace/elastic+kibana+master/JOB/x-pack-ciGroup7/node/immutable/kibana/test/common/services/retry/retry_for_success.ts:28:9)
        at onFailure (/var/lib/jenkins/workspace/elastic+kibana+master/JOB/x-pack-ciGroup7/node/immutable/kibana/test/common/services/retry/retry_for_success.ts:68:13)
          "",
        ""likelyIrrelevant"": false,
        ""name"": ""maps app  maps loaded from sample data ecommerce \\""before all\\"" hook"",
        ""time"": ""154.378"",
      },
      Object {
        ""classname"": ""Chrome X-Pack UI Functional Tests.x-pack/test/functional/apps/maps"",
        ""failure"": ""
            { NoSuchSessionError: This driver instance does not have a valid session ID (did you call WebDriver.quit()?) and may no longer be used.
        at promise.finally (/var/lib/jenkins/workspace/elastic+kibana+master/JOB/x-pack-ciGroup7/node/immutable/kibana/node_modules/selenium-webdriver/lib/webdriver.js:726:38)
        at Object.thenFinally [as finally] (/var/lib/jenkins/workspace/elastic+kibana+master/JOB/x-pack-ciGroup7/node/immutable/kibana/node_modules/selenium-webdriver/lib/promise.js:124:12)
        at process._tickCallback (internal/process/next_tick.js:68:7) name: 'NoSuchSessionError', remoteStacktrace: '' }
          "",
        ""likelyIrrelevant"": true,
        ""metadata-json"": ""{\\""messages\\"":[\\""foo\\""],\\""screenshots\\"":[{\\""name\\"":\\""failure[dashboard app using current data dashboard snapshots compare TSVB snapshot]\\"",\\""url\\"":\\""https://storage.googleapis.com/kibana-ci-artifacts/jobs/elastic+kibana+7.x/1632/kibana-oss-tests/test/functional/screenshots/failure/dashboard%20app%20using%20current%20data%20dashboard%20snapshots%20compare%20TSVB%20snapshot.png\\""}]}"",
        ""name"": ""maps app \\""after all\\"" hook"",
        ""time"": ""0.179"",
      },
      Object {
        ""classname"": ""Firefox XPack UI Functional Tests.x-pack/test/functional/apps/machine_learning/anomaly_detection/saved_search_job·ts"",
        ""failure"": ""{ NoSuchSessionError: Tried to run command without establishing a connection
        at Object.throwDecodedError (/dev/shm/workspace/kibana/node_modules/selenium-webdriver/lib/error.js:550:15)
        at parseHttpResponse (/dev/shm/workspace/kibana/node_modules/selenium-webdriver/lib/http.js:563:13)
        at Executor.execute (/dev/shm/workspace/kibana/node_modules/selenium-webdriver/lib/http.js:489:26)
        at process._tickCallback (internal/process/next_tick.js:68:7) name: 'NoSuchSessionError', remoteStacktrace: '' }"",
        ""likelyIrrelevant"": true,
        ""name"": ""machine learning anomaly detection saved search  with lucene query job creation opens the advanced section"",
        ""time"": ""6.040"",
      },
    ]
  `);
});",""
"23419","opensearch-project/opensearch-dashboards","ui_settings_client.test.ts","    it('calls subscriber with new and previous value', () => {
      const handler = jest.fn();
      const { client } = setup();

      client.getUpdate$().subscribe(handler);
      client.overrideLocalDefault('dateFormat', 'bar');
      expect(handler.mock.calls).toMatchSnapshot('single subscriber call');
    });",""
"23474","opensearch-project/opensearch-dashboards","http_server.test.ts","    it('default headers', async () => {
      const { registerRouter, server: innerServer } = await server.setup(config);

      const router = new Router('', logger, enhanceWithContext);
      router.get({ path: '/', validate: false }, (context, req, res) =>
        res.ok({ body: req.route })
      );
      registerRouter(router);

      await server.start();
      const response = await supertest(innerServer.listener).get('/').expect(200);

      const restHeaders = omit(response.header, ['date', 'content-length']);
      expect(restHeaders).toMatchInlineSnapshot(`
        Object {
          ""accept-ranges"": ""bytes"",
          ""cache-control"": ""private, no-cache, no-store, must-revalidate"",
          ""connection"": ""close"",
          ""content-type"": ""application/json; charset=utf-8"",
        }
      `);
    });",""
"23532","opensearch-project/opensearch-dashboards","cgroup.test.ts","  it('collects default cgroup data', async () => {
    mockFs({
      '/proc/self/cgroup': `
123:memory:/groupname
123:cpu:/groupname
123:cpuacct:/groupname
      `,
      '/sys/fs/cgroup/cpuacct/groupname/cpuacct.usage': '111',
      '/sys/fs/cgroup/cpu/groupname/cpu.cfs_period_us': '222',
      '/sys/fs/cgroup/cpu/groupname/cpu.cfs_quota_us': '333',
      '/sys/fs/cgroup/cpu/groupname/cpu.stat': `
nr_periods 444
nr_throttled 555
throttled_time 666
      `,
    });

    const collector = new OsCgroupMetricsCollector({ logger: loggerMock.create() });
    expect(await collector.collect()).toMatchInlineSnapshot(`
      Object {
        ""cpu"": Object {
          ""cfs_period_micros"": 222,
          ""cfs_quota_micros"": 333,
          ""control_group"": ""/groupname"",
          ""stat"": Object {
            ""number_of_elapsed_periods"": 444,
            ""number_of_times_throttled"": 555,
            ""time_throttled_nanos"": 666,
          },
        },
        ""cpuacct"": Object {
          ""control_group"": ""/groupname"",
          ""usage_nanos"": 111,
        },
      }
    `);
  });",""
"23703","opensearch-project/opensearch-dashboards","ui_settings_client.test.ts","    it('validates value if a schema presents', async () => {
      const defaults = { foo: { schema: schema.string() } };
      const { uiSettings, savedObjectsClient } = setup({ defaults });

      await expect(uiSettings.set('foo', 1)).rejects.toMatchInlineSnapshot(
        `[Error: [validation [foo]]: expected value of type [string] but got [number]]`
      );

      expect(savedObjectsClient.update).toHaveBeenCalledTimes(0);
    });",""
"23845","opensearch-project/opensearch-dashboards","agg_config.test.ts","    it('creates a subexpression for params of type ""agg""', () => {
      const ac = new AggConfigs(indexPattern, [], { typesRegistry });
      const configStates = {
        type: 'terms',
        params: {
          field: 'machine.os.keyword',
          order: 'asc',
          orderAgg: {
            enabled: true,
            type: 'terms',
            params: {
              field: 'bytes',
              order: 'asc',
              size: 5,
            },
          },
        },
      };
      const aggConfig = ac.createAggConfig(configStates);
      const aggArg = aggConfig.toExpressionAst()?.arguments.orderAgg;
      expect(aggArg).toMatchInlineSnapshot(`
        Array [
          Object {
            ""chain"": Array [
              Object {
                ""arguments"": Object {
                  ""enabled"": Array [
                    true,
                  ],
                  ""field"": Array [
                    ""bytes"",
                  ],
                  ""id"": Array [
                    ""1-orderAgg"",
                  ],
                  ""missingBucket"": Array [
                    false,
                  ],
                  ""missingBucketLabel"": Array [
                    ""Missing"",
                  ],
                  ""order"": Array [
                    ""asc"",
                  ],
                  ""otherBucket"": Array [
                    false,
                  ],
                  ""otherBucketLabel"": Array [
                    ""Other"",
                  ],
                  ""schema"": Array [
                    ""orderAgg"",
                  ],
                  ""size"": Array [
                    5,
                  ],
                },
                ""function"": ""aggTerms"",
                ""type"": ""function"",
              },
            ],
            ""type"": ""expression"",
          },
        ]
      `);
    });",""
"23865","opensearch-project/opensearch-dashboards","geo_tile_fn.test.ts","    test('includes optional params when they are provided', () => {
      const actual = fn({
        field: 'geo_field',
        useGeocentroid: false,
        precision: 10,
      });

      expect(actual.value).toMatchInlineSnapshot(`
        Object {
          ""enabled"": true,
          ""id"": undefined,
          ""params"": Object {
            ""customLabel"": undefined,
            ""field"": ""geo_field"",
            ""json"": undefined,
            ""precision"": 10,
            ""useGeocentroid"": false,
          },
          ""schema"": undefined,
          ""type"": ""geotile_grid"",
        }
      `);
    });",""
"23898","opensearch-project/opensearch-dashboards","min_fn.test.ts","    test('required args are provided', () => {
      const actual = fn({
        field: 'machine.os.keyword',
      });
      expect(actual).toMatchInlineSnapshot(`
        Object {
          ""type"": ""agg_type"",
          ""value"": Object {
            ""enabled"": true,
            ""id"": undefined,
            ""params"": Object {
              ""customLabel"": undefined,
              ""field"": ""machine.os.keyword"",
              ""json"": undefined,
            },
            ""schema"": undefined,
            ""type"": ""min"",
          },
        }
      `);
    });",""
"24089","opensearch-project/opensearch-dashboards","tutorials_registry.test.ts","    test('has a router that retrieves registered tutorials', () => {
      const mockResponse = httpServerMock.createResponseFactory();
      expect(mockResponse.ok.mock.calls).toMatchInlineSnapshot(`Array []`);
    });",""
"24220","opensearch-project/opensearch-dashboards","list_control_editor.test.tsx","    test('should display dynamic options for string fields', async () => {
      const controlParams: ControlParams = {
        id: '1',
        label: 'mock',
        indexPattern: 'mockIndexPattern',
        fieldName: 'keywordField',
        type: 'list',
        options: {
          type: 'terms',
          multiselect: true,
          dynamicOptions: true,
          size: 5,
        },
        parent: '',
      };
      const component = shallow(
        <ListControlEditor
          deps={deps}
          getIndexPattern={getIndexPatternMock}
          controlIndex={0}
          controlParams={controlParams}
          handleFieldNameChange={handleFieldNameChange}
          handleIndexPatternChange={handleIndexPatternChange}
          handleOptionsChange={handleOptionsChange}
          handleParentChange={() => {}}
          parentCandidates={[]}
        />
      );

      await updateComponent(component);

      expect(component).toMatchSnapshot();
    });",""
"24316","opensearch-project/opensearch-dashboards","hash_unhash_url.test.ts","      it('if uses multiple states params', () => {
        const stateParamKey1 = '_g';
        const stateParamValue1 = '(yes:!t)';
        const stateParamKey2 = '_a';
        const stateParamValue2 = '(yes:!f)';
        const stateParamKey3 = '_b';
        const stateParamValue3 = '(yes:!f)';
        const url = `https://localhost:5601/app/discover#/?foo=bar&${stateParamKey1}=${stateParamValue1}&${stateParamKey2}=${stateParamValue2}&${stateParamKey3}=${stateParamValue3}`;
        const result = hashUrl(url);
        expect(result).toMatchInlineSnapshot(
          `""https://localhost:5601/app/discover#/?foo=bar&_g=h@4e60e02&_a=h@61fa078&_b=(yes:!f)""`
        );
        expect(mockStorage.getItem('h@4e60e02')).toEqual(JSON.stringify({ yes: true }));
        expect(mockStorage.getItem('h@61fa078')).toEqual(JSON.stringify({ yes: false }));
        if (!HashedItemStore.PERSISTED_INDEX_KEY) {
          // This is very brittle and depends upon HashedItemStore implementation details,
          // so let's protect ourselves from accidentally breaking this test.
          throw new Error('Missing HashedItemStore.PERSISTED_INDEX_KEY');
        }
        expect(mockStorage.getItem(HashedItemStore.PERSISTED_INDEX_KEY)).toBeTruthy();
        expect(mockStorage.length).toBe(3);
      });",""
"24370","opensearch-project/opensearch-dashboards","relationships.test.tsx","  it('should render index patterns normally', async () => {
    const props: RelationshipsProps = {
      goInspectObject: () => {},
      canGoInApp: () => true,
      basePath: httpServiceMock.createSetupContract().basePath,
      getRelationships: jest.fn().mockImplementation(() => [
        {
          type: 'search',
          id: '1',
          relationship: 'parent',
          meta: {
            editUrl: '/management/opensearch-dashboards/objects/savedSearches/1',
            icon: 'search',
            inAppUrl: {
              path: '/app/discover#//1',
              uiCapabilitiesPath: 'discover.show',
            },
            title: 'My Search Title',
          },
        },
        {
          type: 'visualization',
          id: '2',
          relationship: 'parent',
          meta: {
            editUrl: '/management/opensearch-dashboards/objects/savedVisualizations/2',
            icon: 'visualizeApp',
            inAppUrl: {
              path: '/app/visualize#/edit/2',
              uiCapabilitiesPath: 'visualize.show',
            },
            title: 'My Visualization Title',
          },
        },
      ]),
      savedObject: {
        id: '1',
        type: 'index-pattern',
        attributes: {},
        references: [],
        meta: {
          title: 'MyIndexPattern*',
          icon: 'indexPatternApp',
          editUrl: '#/management/opensearch-dashboards/indexPatterns/patterns/1',
          inAppUrl: {
            path: '/management/opensearch-dashboards/indexPatterns/patterns/1',
            uiCapabilitiesPath: 'management.opensearchDashboards.indexPatterns',
          },
        },
      },
      close: jest.fn(),
    };

    const component = shallowWithI18nProvider(<Relationships {...props} />);

    // Make sure we are showing loading
    expect(component.find('EuiLoadingSpinner').length).toBe(1);

    // Ensure all promises resolve
    await new Promise((resolve) => process.nextTick(resolve));
    // Ensure the state changes are reflected
    component.update();

    expect(props.getRelationships).toHaveBeenCalled();
    expect(component).toMatchSnapshot();
  });",""
"24512","opensearch-project/opensearch-dashboards","vega_visualization.test.js","    test('should show vega blank rectangle on top of a map (vegamap)', async () => {
      let vegaVis;
      try {
        vegaVis = new VegaVisualization(domNode, vis);
        const vegaParser = new VegaParser(
          JSON.stringify(vegaMapGraph),
          new SearchAPI({
            search: dataPluginStart.search,
            uiSettings: coreStart.uiSettings,
            injectedMetadata: coreStart.injectedMetadata,
          }),
          0,
          0,
          mockGetServiceSettings
        );
        await vegaParser.parseAsync();

        mockedWidthValue = 256;
        mockedHeightValue = 256;

        await vegaVis.render(vegaParser);
        expect(domNode.innerHTML).toMatchSnapshot();
      } finally {
        vegaVis.destroy();
      }
    });",""
"24879","peggyrayzis/react-native-create-bridge","ios-swift.test.js","  it('creates a Template.m', async () => {
    const fileData = await readFile('Template.m', readDirPath);
    const parsedFile = parseFile(fileData, { templateName });
    expect(parsedFile).toMatchSnapshot();
  });",""
"25033","pinterest/querybook","Select.test.js","    it('matches snapshot', () => {
        const wrapper = shallow(<Select value=""test"" onChange={() => null} />);
        const serialized = toJson(wrapper);
        expect(serialized).toMatchSnapshot();
    });",""
"25356","primer/components","TextInput.tsx","  it('renders small', () => {
    expect(render(<TextInput name=""zipcode"" variant=""small"" />)).toMatchSnapshot()
  })",""
"25507","privatenumber/esbuild-loader","loader.test.ts","	test('target', async () => {
		const built = await build(fixtures.js, (config) => {
			configureEsbuildLoader(config);

			config.module.rules[0].options = {
				target: 'es2015',
			};
		}, webpack);

		expect(built.stats.hasWarnings()).toBe(false);
		expect(built.stats.hasErrors()).toBe(false);

		expect(built.require('/dist')).toMatchSnapshot();
	});",""
"25527","probablyup/markdown-to-jsx","index.compiler.spec.tsx","it('#234 perf regression', () => {
  render(
    compiler(theredoc`
      <br /><b>1</b><b>2</b><b>3</b><b>4</b><b>5</b><b>6</b><b>7</b><b>8</b><b>9</b><b>10</b>
      <b>1</b><b>2</b><b>3</b><b>4</b><b>5</b><b>6</b><b>7</b><b>8</b><b>9</b><b>20</b>
      <b>1</b><b>2</b><b>3</b><b>4</b><b>5</b><b>6</b><b>7</b><b>8</b><b>9</b><b>30</b>
    `)
  )

  expect(root.innerHTML).toMatchInlineSnapshot(`
    <div>
      <br>
      <b>
        1
      </b>
      <b>
        2
      </b>
      <b>
        3
      </b>
      <b>
        4
      </b>
      <b>
        5
      </b>
      <b>
        6
      </b>
      <b>
        7
      </b>
      <b>
        8
      </b>
      <b>
        9
      </b>
      <b>
        10
      </b>
      <b>
        1
      </b>
      <b>
        2
      </b>
      <b>
        3
      </b>
      <b>
        4
      </b>
      <b>
        5
      </b>
      <b>
        6
      </b>
      <b>
        7
      </b>
      <b>
        8
      </b>
      <b>
        9
      </b>
      <b>
        20
      </b>
      <b>
        1
      </b>
      <b>
        2
      </b>
      <b>
        3
      </b>
      <b>
        4
      </b>
      <b>
        5
      </b>
      <b>
        6
      </b>
      <b>
        7
      </b>
      <b>
        8
      </b>
      <b>
        9
      </b>
      <b>
        30
      </b>
    </div>
  `)
})",""
"25580","probablyup/markdown-to-jsx","index.compiler.spec.tsx","  it('should not link URL if it is nested inside an anchor tag', () => {
    render(
      compiler(
        '<a href=""https://google.com"">some text <span>with a link https://google.com</span></a>'
      )
    )

    expect(root.innerHTML).toMatchInlineSnapshot(`
      <a href=""https://google.com"">
        some text
        <span>
          with a link https://google.com
        </span>
      </a>
    `)

    render(
      compiler(
        '<a href=""https://google.com"">some text <span>with a nested link <span>https://google.com</span></span></a>'
      )
    )

    expect(root.innerHTML).toMatchInlineSnapshot(`
      <a href=""https://google.com"">
        some text
        <span>
          with a nested link
          <span>
            https://google.com
          </span>
        </span>
      </a>
    `)
  })",""
"25685","probablyup/markdown-to-jsx","index.compiler.spec.tsx","  it('should substitute custom components when found', () => {
    const CustomButton: React.FC<JSX.IntrinsicElements['button']> = props => (
      <button {...props} />
    )

    render(
      compiler('<CustomButton>Click me!</CustomButton>', {
        overrides: { CustomButton },
      })
    )

    expect(root.innerHTML).toMatchInlineSnapshot(`
      <button>
        Click me!
      </button>
    `)
  })",""
"25759","rahuldkjain/github-profile-readme-generator","markdown.test.js","  it('renders githubProfileTrophy is true', () => {
    const component = shallow(
      <Markdown
        {...props}
        data={{
          ...props.data,
          githubProfileTrophy: true,
        }}
      />,
    );
    expect(toJson(component)).toMatchSnapshot();
  });",""
"25888","react-cosmos/react-cosmos","getFixtures.test.ts","it('renders fixture elements', async () => {
  const cosmosConfig = createCosmosConfig(rootDir, {
    ignore: ['**/*.mdx'],
  });

  const fixures = getFixtures(cosmosConfig, {
    rendererUrl: 'http://localhost:5000/renderer.html',
  });

  function testFixtureElement(relPath: string, name: string | null = null) {
    const match = fixures.find(
      f => f.relativeFilePath === relPath && f.name === name
    );
    expect(create(match!.getElement())).toMatchSnapshot();
  }

  testFixtureElement('src/CounterButton.fixture.tsx');
  testFixtureElement('src/Counter.fixture.tsx', 'large number');
  testFixtureElement('src/WelcomeMessage/WelcomeMessage.fixture.tsx');
});",""
"25972","react-figma/react-figma","transformColors.test.ts","    it('colorToRGB aliceblue', () => {
        const result = colorToRGB('aliceblue');
        expect(result).toMatchSnapshot();
    });",""
"26012","react-figma/react-figma","applyStyleToYogaNode.test.ts","    it('flexGrow', () => {
        const yogaNode = yoga.Node.create();
        applyStyleToYogaNodeConnected(yogaNode, {
            flexGrow: 2
        });
        expect(serializeYogaNodeStyle(yogaNode)).toMatchSnapshot();
    });",""
"26231","react-syntax-highlighter/react-syntax-highlighter","line-numbers.js","test('SyntaxHighlighter allows lineNumberStyle as function for inline line numbers', () => {
  const tree = renderer
    .create(
      <SyntaxHighlighter
        language=""javascript""
        showLineNumbers
        showInlineLineNumbers
        lineNumberStyle={() => ({ color: 'red' })}
      >
        {code}
      </SyntaxHighlighter>
    )
    .toJSON();
  expect(tree).toMatchSnapshot();
});",""
"26382","reakit/reakit","PopoverDisclosure-test.tsx","test(""render"", () => {
  const { baseElement } = render(
    <PopoverDisclosure {...props}>disclosure</PopoverDisclosure>
  );
  expect(baseElement).toMatchInlineSnapshot(`
    <body>
      <div>
        <button
          aria-controls=""base""
          aria-expanded=""false""
          aria-haspopup=""dialog""
          type=""button""
        >
          disclosure
        </button>
      </div>
    </body>
  `);
});",""
"26422","reakit/reakit","Separator-test.tsx","test(""render"", () => {
  const { baseElement } = render(<Separator />);
  expect(baseElement).toMatchInlineSnapshot(`
    <body>
      <div>
        <hr
          aria-orientation=""horizontal""
          role=""separator""
        />
      </div>
    </body>
  `);
});",""
"26551","redocly/redoc","DiscriminatorDropdown.test.tsx","      it('should correctly render SchemaView', () => {
        const parser = new OpenAPIParser(simpleDiscriminatorFixture, undefined, options);

        const schema = new SchemaModel(
          parser,
          { $ref: '#/components/schemas/Pet' },
          '#/components/schemas/Pet',
          options,
        );
        const schemaViewElement = shallow(<Schema schema={schema} />).getElement();
        expect(schemaViewElement).toMatchSnapshot();
        expect(schemaViewElement.props.discriminator).toBeDefined();
        expect(schemaViewElement.props.discriminator.parentSchema).toBeDefined();
        expect(schemaViewElement.props.discriminator.fieldName).toEqual('type');
      });",""
"26867","remix-run/react-router","route-depth-order-matching-test.tsx","  it(""matches them depth-first"", () => {
    let renderer: TestRenderer.ReactTestRenderer;
    TestRenderer.act(() => {
      renderer = TestRenderer.create(
        <MemoryRouter initialEntries={[""/""]}>
          <Routes>
            <Route element={<First />}>
              <Route element={<Second />}>
                <Route path=""/"" element={<Third />} />
              </Route>
            </Route>
          </Routes>
        </MemoryRouter>
      );
    });

    expect(renderer.toJSON()).toMatchInlineSnapshot(`
      <div>
        First 
        <div>
          Second 
          <div>
            Third
          </div>
        </div>
      </div>
    `);
  });",""
"26898","remix-run/react-router","useHref-basename-test.tsx","    it(""does not change"", () => {
      let element = (
        <MemoryRouter basename=""/app"" initialEntries={[""/app/admin""]}>
          <Routes>
            <Route path=""admin"" element={<ShowHref to=""/invoices"" />} />
          </Routes>
        </MemoryRouter>
      );

      let renderer: TestRenderer.ReactTestRenderer;
      TestRenderer.act(() => {
        renderer = TestRenderer.create(element);
      });

      TestRenderer.act(() => {
        renderer.update(element);
      });

      expect(renderer.toJSON()).toMatchInlineSnapshot(`
        <p>
          /app/invoices
        </p>
      `);
    });",""
"27168","renovatebot/renovate","index.spec.ts","    it('returns commits from bitbucket cloud', async () => {
      const body = {
        pagelen: 0,
        values: [],
        page: 1,
      };
      httpMock
        .scope('https://api.bitbucket.org')
        .get('/2.0/repositories/some/dep2')
        .reply(200, { mainbranch: { name: 'master' } });
      httpMock
        .scope('https://api.bitbucket.org')
        .get('/2.0/repositories/some/dep2/commits/master')
        .reply(200, body);
      const res = await getDigest({
        datasource,
        depName: 'some/dep2',
      });
      expect(res).toMatchSnapshot();
      expect(res).toBeNull();
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"27171","renovatebot/renovate","index.spec.ts","    it('throws for error', async () => {
      httpMock.scope(baseUrl).get(pathFor('foo/bar')).replyWithError('error');
      await expect(
        getPkgReleases({
          datasource: CdnJsDatasource.id,
          depName: 'foo/bar',
        })
      ).rejects.toThrow(EXTERNAL_HOST_ERROR);
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"27203","renovatebot/renovate","index.spec.ts","    it('processes real data', async () => {
      httpMock.scope(baseUrl).get('/shared_preferences').reply(200, body);
      const res = await getPkgReleases({
        datasource: DartDatasource.id,
        depName: 'shared_preferences',
      });
      expect(res).toMatchSnapshot();
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"27206","renovatebot/renovate","common.spec.ts","    it('supports http registryUrls', () => {
      const res = dockerCommon.getRegistryRepository(
        'my.local.registry/prefix/image',
        'http://my.local.registry/prefix'
      );
      expect(res).toMatchInlineSnapshot(`
        Object {
          ""dockerRepository"": ""prefix/image"",
          ""registryHost"": ""http://my.local.registry"",
        }
      `);
    });",""
"27226","renovatebot/renovate","index.spec.ts","    it('uses custom registry in depName', async () => {
      const tags = ['1.0.0'];
      httpMock
        .scope('https://registry.company.com/v2')
        .get('/')
        .reply(200, '', {})
        .get('/node/tags/list?n=10000')
        .reply(200, { tags }, {})
        .get('/')
        .reply(200, '', {})
        .get('/node/manifests/1.0.0')
        .reply(200, '', {});
      const res = await getPkgReleases({
        datasource: id,
        depName: 'registry.company.com/node',
      });
      expect(res.releases).toHaveLength(1);
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"27329","renovatebot/renovate","index.spec.ts","  it('returns null when metadata is not found', async () => {
    httpMock
      .scope(baseUrl)
      .get('/org/example/package/maven-metadata.xml')
      .reply(404);

    const res = await get();

    expect(res).toBeNull();
    expect(httpMock.getTrace()).toMatchSnapshot();
  });",""
"27395","renovatebot/renovate","index.spec.ts","    it('returns null for unknown error (v2)', async () => {
      httpMock
        .scope('https://www.nuget.org')
        .get(
          '/api/v2/FindPackagesById()?id=%27nunit%27&$select=Version,IsLatestVersion,ProjectUrl,Published'
        )
        .replyWithError('');
      expect(
        await getPkgReleases({
          ...configV2,
        })
      ).toBeNull();
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"27479","renovatebot/renovate","index.spec.ts","    it('processes with registry in name', async () => {
      httpMock
        .scope(baseUrl)
        .get('/v1/modules/hashicorp/consul/aws')
        .reply(200, consulData)
        .get('/.well-known/terraform.json')
        .reply(200, serviceDiscoveryResult);
      const res = await getPkgReleases({
        datasource,
        depName: 'registry.terraform.io/hashicorp/consul/aws',
      });
      expect(res).toMatchSnapshot();
      expect(res).not.toBeNull();
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"27491","renovatebot/renovate","index.spec.ts","    it('returns null for empty result', async () => {
      httpMock
        .scope(primaryUrl)
        .get('/v1/providers/hashicorp/azurerm/versions')
        .reply(200, {})
        .get('/.well-known/terraform.json')
        .reply(200, serviceDiscoveryResult);

      const result = await terraformProviderDatasource.getBuilds(
        terraformProviderDatasource.defaultRegistryUrls[0],
        'hashicorp/azurerm',
        '2.50.0'
      );
      expect(result).toBeNull();
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"27584","renovatebot/renovate","artifacts.spec.ts","  it('returns updated Podfile', async () => {
    const execSnapshots = mockExecAll(exec);
    setAdminConfig({ ...adminConfig, binarySource: 'docker' });
    fs.readFile.mockResolvedValueOnce('Old Podfile' as any);
    git.getRepoStatus.mockResolvedValueOnce({
      modified: ['Podfile.lock'],
    } as StatusResult);
    fs.readFile.mockResolvedValueOnce('New Podfile' as any);
    expect(
      await updateArtifacts({
        packageFileName: 'Podfile',
        updatedDeps: [{ depName: 'foo' }],
        newPackageFileContent: 'plugin ""cocoapods-acknowledgements""',
        config,
      })
    ).toMatchSnapshot();
    expect(execSnapshots).toMatchSnapshot();
  });",""
"27604","renovatebot/renovate","extract.spec.ts","    it('extracts repositories and registryUrls', async () => {
      const res = await extractPackageFile(requirements4, packageFile);
      expect(res).toMatchSnapshot();
      expect(res.registryUrls).toHaveLength(3);
    });",""
"27783","renovatebot/renovate","npm.spec.ts","    it('extracts', async () => {
      const plocktest1Lock = loadFixture('plocktest1/package-lock.json', '..');
      fs.readLocalFile.mockResolvedValueOnce(plocktest1Lock as never);
      const res = await getNpmLock('package.json');
      expect(res).toMatchSnapshot();
      expect(Object.keys(res.lockedVersions)).toHaveLength(7);
    });",""
"27798","renovatebot/renovate","lerna.spec.ts","    it('defaults to latest if lerna version unspecified', async () => {
      const execSnapshots = mockExecAll(exec);
      const res = await lernaHelper.generateLockFiles(
        lernaPkgFileWithoutLernaDep('npm'),
        'some-dir',
        {},
        {}
      );
      expect(res.error).toBe(false);
      expect(execSnapshots).toMatchSnapshot();
    });",""
"27807","renovatebot/renovate","npm.spec.ts","  it('uses docker npm', async () => {
    const execSnapshots = mockExecAll(exec);
    fs.readFile = jest.fn(() => 'package-lock-contents') as never;
    const res = await npmHelper.generateLockFile(
      'some-dir',
      {},
      'package-lock.json',
      { binarySource: 'docker', constraints: { npm: '^6.0.0' } }
    );
    expect(fs.readFile).toHaveBeenCalledTimes(1);
    expect(res.lockFile).toEqual('package-lock-contents');
    expect(execSnapshots).toMatchSnapshot();
  });",""
"28004","renovatebot/renovate","index.spec.ts","    it('returns updated pr body', () => {
      const input =
        '<details>https://github.com/foo/bar/issues/5 plus also [a link](https://github.com/foo/bar/issues/5)';
      expect(azure.massageMarkdown(input)).toMatchSnapshot();
    });",""
"28024","renovatebot/renovate","comments.spec.ts","    it('deletes nothing', async () => {
      expect.assertions(1);
      httpMock
        .scope(baseUrl)
        .get('/2.0/repositories/some/repo/pullrequests/5/comments?pagelen=100')
        .reply(200, { values: [] });
      await comments.ensureCommentRemoval(config, 5, 'topic');
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"28110","renovatebot/renovate","index.spec.ts","        it('gets a PR', async () => {
          const scope = await initRepo();
          scope
            .get(
              `${urlPath}/rest/api/1.0/projects/SOME/repos/repo/pull-requests/5`
            )
            .reply(200, prMock(url, 'SOME', 'repo'))
            .get(
              `${urlPath}/rest/api/1.0/projects/SOME/repos/repo/pull-requests/5/merge`
            )
            .reply(200, { conflicted: false });

          expect(await bitbucket.getPr(5)).toMatchSnapshot();
          expect(httpMock.getTrace()).toMatchSnapshot();
        });",""
"28306","renovatebot/renovate","index.spec.ts","    it('should return true', async () => {
      await initRepo(
        {
          repository: 'some/repo/project',
        },
        {
          default_branch: 'master',
          http_url_to_repo: null,
          merge_method: 'ff',
        }
      );
      expect(await gitlab.getRepoForceRebase()).toBe(true);
      expect(httpMock.getTrace()).toMatchSnapshot();
    });",""
"28470","renovatebot/renovate","index.spec.ts","    it('returns if pr creation limit exceeded and branch exists', async () => {
      getUpdated.getUpdatedPackageFiles.mockResolvedValueOnce({
        ...updatedPackageFiles,
      });
      npmPostExtract.getAdditionalFiles.mockResolvedValueOnce({
        artifactErrors: [],
        updatedArtifacts: [],
      });
      git.branchExists.mockReturnValue(true);
      prWorker.ensurePr.mockResolvedValueOnce({
        prBlockedBy: 'RateLimited',
      });
      limits.isLimitReached.mockReturnValue(false);
      expect(await branchWorker.processBranch(config)).toMatchSnapshot();
    });",""
"28604","renovatebot/renovate","base-branch.spec.ts","    it('describes baseBranches', () => {
      config.baseBranches = ['some-branch', 'some-other-branch'];
      const res = getBaseBranchDesc(config);
      expect(res).toMatchSnapshot();
    });",""
"28626","renovatebot/renovate","filter-checks.spec.ts","    it('returns non-pending latest release if internalChecksFilter=flexible and none pass checks', async () => {
      config.internalChecksFilter = 'flexible';
      config.stabilityDays = 10;
      const res = await filterInternalChecks(
        config,
        versioning,
        'patch',
        sortedReleases
      );
      expect(res).toMatchSnapshot();
      expect(res.pendingChecks).toBe(false);
      expect(res.pendingReleases).toHaveLength(0);
      expect(res.release.version).toEqual('1.0.4');
    });",""
"28675","renovatebot/renovate","index.spec.ts","    it('upgrades less than ranges without pinning', async () => {
      config.rangeStrategy = 'replace';
      config.currentValue = '< 0.7.2';
      config.depName = 'q';
      config.datasource = datasourceNpmId;
      httpMock.scope('https://registry.npmjs.org').get('/q').reply(200, qJson);
      expect((await lookup.lookupUpdates(config)).updates).toMatchSnapshot();
    });",""
"28889","salesforce-ux/theo","formats.js","it(""raw.json"", () => {
  expect(format(""raw.json"")).toMatchSnapshot();
});",""
"28890","salesforce-ux/theo","formats.js","it(""json"", () => {
  expect(format(""json"")).toMatchSnapshot();
});",""
"28921","samdenty/gqless","generate.test.ts","  test('generate works', async () => {
    const { schemaCode, generatedSchema, scalarsEnumsHash } = await generate(
      server.graphql.schema
    );

    expect(schemaCode).toMatchInlineSnapshot(`
      ""/**
       * GQLESS AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
       */

      import { SchemaUnionsKey } from 'gqless';

      export type Maybe<T> = T | null;
      export type Exact<T extends { [key: string]: unknown }> = {
        [K in keyof T]: T[K];
      };
      export type MakeOptional<T, K extends keyof T> = Omit<T, K> &
        { [SubKey in K]?: Maybe<T[SubKey]> };
      export type MakeMaybe<T, K extends keyof T> = Omit<T, K> &
        { [SubKey in K]: Maybe<T[SubKey]> };
      /** All built-in and custom scalars, mapped to their actual values */
      export interface Scalars {
        ID: string;
        String: string;
        Boolean: boolean;
        Int: number;
        Float: number;
        ExampleScalar: any;
      }

      /** Greetings Enum */
      export enum GreetingsEnum {
        /** Hello */
        Hello = 'Hello',
        /** Hi */
        Hi = 'Hi',
        /** Hey */
        Hey = 'Hey',
        Bye = 'Bye',
      }

      export enum OtherEnum {
        Other = 'Other',
      }

      /** Greetings Input */
      export interface GreetingsInput {
        /** Language */
        language: Scalars['String'];
        value?: Maybe<Scalars['String']>;
        scal?: Maybe<Scalars['ExampleScalar']>;
      }

      export const scalarsEnumsHash: import('gqless').ScalarsEnumsHash = {
        ExampleScalar: true,
        GreetingsEnum: true,
        OtherEnum: true,
        String: true,
        Int: true,
        Boolean: true,
      };
      export const generatedSchema = {
        query: {
          __typename: { __type: 'String!' },
          simpleString: { __type: 'String!' },
          stringWithArgs: { __type: 'String!', __args: { hello: 'String!' } },
          stringNullableWithArgs: {
            __type: 'String',
            __args: { hello: 'String!', helloTwo: 'String' },
          },
          stringNullableWithArgsArray: {
            __type: 'String',
            __args: { hello: '[String]!' },
          },
          object: { __type: 'Human' },
          objectArray: { __type: '[Human]' },
          objectWithArgs: { __type: 'Human!', __args: { who: 'String!' } },
          arrayString: { __type: '[String!]!' },
          arrayObjectArgs: { __type: '[Human!]!', __args: { limit: 'Int' } },
          greetings: { __type: 'GreetingsEnum!' },
          giveGreetingsInput: {
            __type: 'String!',
            __args: { input: 'GreetingsInput!' },
          },
          enumsInput: {
            __type: 'GreetingsEnum',
            __args: {
              nullableEnum: 'GreetingsEnum',
              notNullableEnum: 'GreetingsEnum!',
            },
          },
          number: { __type: 'Int!' },
        },
        mutation: {
          __typename: { __type: 'String!' },
          increment: { __type: 'Int!', __args: { n: 'Int!' } },
        },
        subscription: {},
        GreetingsInput: {
          language: { __type: 'String!' },
          value: { __type: 'String' },
          scal: { __type: 'ExampleScalar' },
        },
        NamedEntity: {
          __typename: { __type: 'String!' },
          name: { __type: 'String!' },
          other: { __type: 'String' },
          withArgs: { __type: 'Int', __args: { a: 'Int!', b: 'Int' } },
          withArgs2: { __type: 'Int!', __args: { a: 'Int' } },
        },
        Human: {
          __typename: { __type: 'String!' },
          name: { __type: 'String!' },
          other: { __type: 'String' },
          father: { __type: 'Human!' },
          fieldWithArgs: { __type: 'Int!', __args: { id: 'Int!' } },
          withArgs: { __type: 'Int', __args: { a: 'Int!', b: 'Int' } },
          withArgs2: { __type: 'Int!', __args: { a: 'Int' } },
        },
        OtherHuman: {
          __typename: { __type: 'String!' },
          name: { __type: 'String!' },
          other: { __type: 'String' },
          withArgs: { __type: 'Int', __args: { a: 'Int!', b: 'Int' } },
          withArgs2: { __type: 'Int!', __args: { a: 'Int' } },
        },
        [SchemaUnionsKey]: { HumanType: ['Human', 'OtherHuman'] },
      } as const;

      export interface Query {
        __typename: 'Query' | undefined;
        simpleString: ScalarsEnums['String'];
        stringWithArgs: (args: {
          hello: Scalars['String'];
        }) => ScalarsEnums['String'];
        stringNullableWithArgs: (args: {
          hello: Scalars['String']
          /**
           * @defaultValue \`\\""Hi\\""\`
           */;
          helloTwo?: Maybe<Scalars['String']>;
        }) => Maybe<ScalarsEnums['String']>;
        stringNullableWithArgsArray: (args: {
          hello: Array<Maybe<Scalars['String']>>;
        }) => Maybe<ScalarsEnums['String']>;
        object?: Maybe<Human>;
        objectArray?: Maybe<Array<Maybe<Human>>>;
        objectWithArgs: (args: {
          /**
           * Who?
           */
          who: Scalars['String'];
        }) => Human;
        arrayString: Array<ScalarsEnums['String']>;
        arrayObjectArgs: (args?: {
          /**
           * @defaultValue \`10\`
           */
          limit?: Maybe<Scalars['Int']>;
        }) => Array<Human>;
        greetings: ScalarsEnums['GreetingsEnum'];
        giveGreetingsInput: (args: {
          input: GreetingsInput;
        }) => ScalarsEnums['String'];
        enumsInput: (args: {
          nullableEnum?: Maybe<GreetingsEnum>;
          notNullableEnum: GreetingsEnum;
        }) => Maybe<ScalarsEnums['GreetingsEnum']>;
        number: ScalarsEnums['Int'];
      }

      export interface Mutation {
        __typename: 'Mutation' | undefined;
        increment: (args: { n: Scalars['Int'] }) => ScalarsEnums['Int'];
      }

      export interface Subscription {
        __typename: 'Subscription' | undefined;
      }

      /**
       * Named Entity
       */
      export interface NamedEntity {
        __typename: 'NamedEntity' | undefined;
        /**
         * Named Entity Name
         */
        name: ScalarsEnums['String'];
        other?: Maybe<ScalarsEnums['String']>;
        withArgs: (args: {
          /**
           * A Arg
           */
          a: Scalars['Int']
          /**
           * @defaultValue \`0\`
           */;
          b?: Maybe<Scalars['Int']>;
        }) => Maybe<ScalarsEnums['Int']>;
        /**
         * @deprecated No longer supported
         */
        withArgs2: (args?: { a?: Maybe<Scalars['Int']> }) => ScalarsEnums['Int'];
      }

      export interface Human extends Omit<NamedEntity, '__typename'> {
        __typename: 'Human' | undefined;
        name: ScalarsEnums['String'];
        other?: Maybe<ScalarsEnums['String']>;
        father: Human;
        fieldWithArgs: (args: { id: Scalars['Int'] }) => ScalarsEnums['Int'];
        withArgs: (args: {
          a: Scalars['Int'];
          b?: Maybe<Scalars['Int']>;
        }) => Maybe<ScalarsEnums['Int']>;
        withArgs2: (args?: { a?: Maybe<Scalars['Int']> }) => ScalarsEnums['Int'];
      }

      export interface OtherHuman {
        __typename: 'OtherHuman' | undefined;
        name: ScalarsEnums['String'];
        other?: Maybe<ScalarsEnums['String']>;
        withArgs: (args: {
          a: Scalars['Int'];
          b?: Maybe<Scalars['Int']>;
        }) => Maybe<ScalarsEnums['Int']>;
        withArgs2: (args?: { a?: Maybe<Scalars['Int']> }) => ScalarsEnums['Int'];
      }

      export interface SchemaObjectTypes {
        Query: Query;
        Mutation: Mutation;
        Subscription: Subscription;
        NamedEntity: NamedEntity;
        Human: Human;
        OtherHuman: OtherHuman;
      }
      export type SchemaObjectTypesNames =
        | 'Query'
        | 'Mutation'
        | 'Subscription'
        | 'NamedEntity'
        | 'Human'
        | 'OtherHuman';

      export type HumanType =
        | {
            __typename: 'Human' | undefined;
            father: Human;
            fieldWithArgs: (args: { id: Scalars['Int'] }) => ScalarsEnums['Int'];
            name: ScalarsEnums['String'];
            other?: Maybe<ScalarsEnums['String']>;
            withArgs: (args: {
              a: Scalars['Int'];
              b?: Maybe<Scalars['Int']>;
            }) => Maybe<ScalarsEnums['Int']>;
            withArgs2: (args?: { a?: Maybe<Scalars['Int']> }) => ScalarsEnums['Int'];
          }
        | {
            __typename: 'OtherHuman' | undefined;
            father?: undefined;
            fieldWithArgs?: undefined;
            name: ScalarsEnums['String'];
            other?: Maybe<ScalarsEnums['String']>;
            withArgs: (args: {
              a: Scalars['Int'];
              b?: Maybe<Scalars['Int']>;
            }) => Maybe<ScalarsEnums['Int']>;
            withArgs2: (args?: { a?: Maybe<Scalars['Int']> }) => ScalarsEnums['Int'];
          };

      /**
       * Named Entity
       */
      export interface NamedEntity {
        /**
         * Named Entity Name
         */
        name: ScalarsEnums['String'];
        other?: Maybe<ScalarsEnums['String']>;
      }

      export interface GeneratedSchema {
        query: Query;
        mutation: Mutation;
        subscription: Subscription;
      }

      export type MakeNullable<T> = {
        [K in keyof T]: T[K] | undefined;
      };

      export interface ScalarsEnums extends MakeNullable<Scalars> {
        GreetingsEnum: GreetingsEnum | undefined;
        OtherEnum: OtherEnum | undefined;
      }
      ""
    `);
    expect(JSON.stringify(generatedSchema)).toMatchInlineSnapshot(
      `""{\\""query\\"":{\\""__typename\\"":{\\""__type\\"":\\""String!\\""},\\""simpleString\\"":{\\""__type\\"":\\""String!\\""},\\""stringWithArgs\\"":{\\""__type\\"":\\""String!\\"",\\""__args\\"":{\\""hello\\"":\\""String!\\""}},\\""stringNullableWithArgs\\"":{\\""__type\\"":\\""String\\"",\\""__args\\"":{\\""hello\\"":\\""String!\\"",\\""helloTwo\\"":\\""String\\""}},\\""stringNullableWithArgsArray\\"":{\\""__type\\"":\\""String\\"",\\""__args\\"":{\\""hello\\"":\\""[String]!\\""}},\\""object\\"":{\\""__type\\"":\\""Human\\""},\\""objectArray\\"":{\\""__type\\"":\\""[Human]\\""},\\""objectWithArgs\\"":{\\""__type\\"":\\""Human!\\"",\\""__args\\"":{\\""who\\"":\\""String!\\""}},\\""arrayString\\"":{\\""__type\\"":\\""[String!]!\\""},\\""arrayObjectArgs\\"":{\\""__type\\"":\\""[Human!]!\\"",\\""__args\\"":{\\""limit\\"":\\""Int\\""}},\\""greetings\\"":{\\""__type\\"":\\""GreetingsEnum!\\""},\\""giveGreetingsInput\\"":{\\""__type\\"":\\""String!\\"",\\""__args\\"":{\\""input\\"":\\""GreetingsInput!\\""}},\\""enumsInput\\"":{\\""__type\\"":\\""GreetingsEnum\\"",\\""__args\\"":{\\""nullableEnum\\"":\\""GreetingsEnum\\"",\\""notNullableEnum\\"":\\""GreetingsEnum!\\""}},\\""number\\"":{\\""__type\\"":\\""Int!\\""}},\\""mutation\\"":{\\""__typename\\"":{\\""__type\\"":\\""String!\\""},\\""increment\\"":{\\""__type\\"":\\""Int!\\"",\\""__args\\"":{\\""n\\"":\\""Int!\\""}}},\\""subscription\\"":{},\\""GreetingsInput\\"":{\\""language\\"":{\\""__type\\"":\\""String!\\""},\\""value\\"":{\\""__type\\"":\\""String\\""},\\""scal\\"":{\\""__type\\"":\\""ExampleScalar\\""}},\\""NamedEntity\\"":{\\""__typename\\"":{\\""__type\\"":\\""String!\\""},\\""name\\"":{\\""__type\\"":\\""String!\\""},\\""other\\"":{\\""__type\\"":\\""String\\""},\\""withArgs\\"":{\\""__type\\"":\\""Int\\"",\\""__args\\"":{\\""a\\"":\\""Int!\\"",\\""b\\"":\\""Int\\""}},\\""withArgs2\\"":{\\""__type\\"":\\""Int!\\"",\\""__args\\"":{\\""a\\"":\\""Int\\""}}},\\""Human\\"":{\\""__typename\\"":{\\""__type\\"":\\""String!\\""},\\""name\\"":{\\""__type\\"":\\""String!\\""},\\""other\\"":{\\""__type\\"":\\""String\\""},\\""father\\"":{\\""__type\\"":\\""Human!\\""},\\""fieldWithArgs\\"":{\\""__type\\"":\\""Int!\\"",\\""__args\\"":{\\""id\\"":\\""Int!\\""}},\\""withArgs\\"":{\\""__type\\"":\\""Int\\"",\\""__args\\"":{\\""a\\"":\\""Int!\\"",\\""b\\"":\\""Int\\""}},\\""withArgs2\\"":{\\""__type\\"":\\""Int!\\"",\\""__args\\"":{\\""a\\"":\\""Int\\""}}},\\""OtherHuman\\"":{\\""__typename\\"":{\\""__type\\"":\\""String!\\""},\\""name\\"":{\\""__type\\"":\\""String!\\""},\\""other\\"":{\\""__type\\"":\\""String\\""},\\""withArgs\\"":{\\""__type\\"":\\""Int\\"",\\""__args\\"":{\\""a\\"":\\""Int!\\"",\\""b\\"":\\""Int\\""}},\\""withArgs2\\"":{\\""__type\\"":\\""Int!\\"",\\""__args\\"":{\\""a\\"":\\""Int\\""}}}}""`
    );
    expect(JSON.stringify(scalarsEnumsHash)).toMatchInlineSnapshot(
      `""{\\""ExampleScalar\\"":true,\\""GreetingsEnum\\"":true,\\""OtherEnum\\"":true,\\""String\\"":true,\\""Int\\"":true,\\""Boolean\\"":true}""`
    );
  });",""
"28962","sanity-io/sanity","useConditionalProperty.test.tsx","  it('calls callback function', () => {
    renderHook(() =>
      useConditionalProperty({
        checkProperty: callbackFn,
        ...DEFAULT_PROPS,
      })
    )
    expect(callbackFn).toBeCalled()
    expect(callbackFn.mock.calls).toMatchInlineSnapshot(`
Array [
  Array [
    Object {
      ""currentUser"": null,
      ""document"": Object {
        ""_createdAt"": ""2021-11-04T15:41:48Z"",
        ""_id"": ""drafts.10053a07-8647-4ebd-9d1d-33a512d30d3a"",
        ""_rev"": ""5hb8s6-k75-ip4-4bq-5ztbf3fbx"",
        ""_type"": ""conditionalFieldsTest"",
        ""_updatedAt"": ""2021-11-05T12:34:29Z"",
        ""isPublished"": true,
        ""title"": ""Hello world"",
      },
      ""parent"": Object {
        ""parentTest"": ""hello"",
      },
      ""value"": undefined,
    },
  ],
]
`)
  })",""
"29029","sanity-io/sanity","Document.test.ts","test('can construct with schema type instead of schema type name', () => {
  expect(
    S.document()
      .schemaType(getDefaultSchema().get('post') as SchemaType)
      .id('yeah')
      .documentId('wow')
      .serialize()
  ).toMatchSnapshot()
})",""
"29184","seek-oss/capsize","createFontStack.test.ts","      it('metric overrides with multiple fallbacks', () => {
        expect(
          createFontStack(
            [merriweatherSans, appleSystem, arial, helveticaNeue],
            {
              fontFaceFormat: 'styleString',
            },
          ),
        ).toMatchInlineSnapshot(`
          {
            ""fontFaces"": ""@font-face {
            font-family: ""Merriweather Sans Fallback: -apple-system"";
            src: local('-apple-system');
            ascent-override: 86.6128%;
            descent-override: 24.0298%;
            size-adjust: 113.6091%;
          }
          @font-face {
            font-family: ""Merriweather Sans Fallback: Arial"";
            src: local('Arial');
            ascent-override: 92.3409%;
            descent-override: 25.619%;
            size-adjust: 106.5617%;
          }
          @font-face {
            font-family: ""Merriweather Sans Fallback: Helvetica Neue"";
            src: local('Helvetica Neue');
            ascent-override: 93.6469%;
            descent-override: 25.9813%;
            size-adjust: 105.0756%;
          }"",
            ""fontFamily"": """"Merriweather Sans"", ""Merriweather Sans Fallback: -apple-system"", ""Merriweather Sans Fallback: Arial"", ""Merriweather Sans Fallback: Helvetica Neue"""",
          }
        `);
      });",""
"29270","seek-oss/vanilla-extract","index.test.ts","  it('should handle global keyframes', () => {
    const source = `
      import { globalKeyframes } from '@vanilla-extract/css';

      globalKeyframes('myKeyframes', {
        from: { transform: 'rotate(0deg)' },
        to: { transform: 'rotate(360deg)' }
      });
    `;

    expect(transform(source)).toMatchInlineSnapshot(`
      ""import * as __vanilla_filescope__ from '@vanilla-extract/css/fileScope';

      __vanilla_filescope__.setFileScope(\\""src/dir/mockFilename.css.ts\\"", \\""@vanilla-extract/babel-plugin\\"");

      import { globalKeyframes } from '@vanilla-extract/css';
      globalKeyframes('myKeyframes', {
        from: {
          transform: 'rotate(0deg)'
        },
        to: {
          transform: 'rotate(360deg)'
        }
      });

      __vanilla_filescope__.endFileScope();""
    `);
  });",""
"29535","seleniumhq/selenium-ide","command.spec.js","  it('should emit `assert alert` command', () => {
    const command = {
      command: 'assertAlert',
      target: 'an alert',
      value: '',
    }
    return expect(prettify(command)).resolves.toMatchSnapshot()
  })",""
"29640","seleniumhq/selenium-ide","index.spec.js","  it('should export a suite with commands that open a new window inside of a reused test method', async () => {
    const project = normalizeProject(readFile('nested-select-window.side'))
    const results = await emitSuite({
      baseUrl: project.url,
      suite: project.suites[0],
      tests: project.tests,
    })
    expect(results.body).toBeDefined()
    expect(results.body).toMatchSnapshot()
  })",""
"29801","seleniumhq/selenium-ide","command.spec.js","  it('should emit `assert not selected value` command', () => {
    const command = {
      command: 'assertNotSelectedValue',
      target: 'id=select',
      value: 'test',
    }
    return expect(prettify(command)).resolves.toMatchSnapshot()
  })",""
"29893","seleniumhq/selenium-ide","index.spec.js","  it('should export a test with a reused test method', async () => {
    const project = normalizeProject(readFile('test-case-reuse.side'))
    const results = await emitTest({
      baseUrl: project.url,
      test: project.tests[1],
      tests: project.tests,
    })
    expect(results.body).toBeDefined()
    expect(results.body).toMatchSnapshot()
  })",""
"30169","serverless-nextjs/serverless-next.js","cache-behavior-options.test.ts","  it(""creates distribution with custom behavior options"", async () => {
    await component.default({
      defaults: {
        minTTL: 0,
        defaultTTL: 0,
        maxTTL: 31536000
      },
      origins: [
        {
          url: ""https://mycustomorigin.com"",
          pathPatterns: {
            ""/sample/path"": {
              minTTL: 0,
              defaultTTL: 0,
              maxTTL: 0,
              forward: {
                headers: ""all"",
                cookies: [""auth-token""],
                queryString: true
              },
              allowedHttpMethods: [""GET"", ""HEAD""],
              viewerProtocolPolicy: ""redirect-to-https"",
              compress: false,
              fieldLevelEncryptionId: ""321""
            }
          }
        }
      ]
    });

    expect(mockCreateDistributionWithTags.mock.calls[0][0]).toMatchSnapshot();
  });",""
"30183","serverless-nextjs/serverless-next.js","s3-origin.test.ts","    it(""should use the origin's host at the DomainName"", async () => {
      await component.default({
        origins: [""https://mybucket.s3.eu-west-1.amazonaws.com""]
      });

      assertCDWTHasOrigin(mockCreateDistributionWithTags, {
        Id: ""mybucket"",
        DomainName: ""mybucket.s3.eu-west-1.amazonaws.com"",
        S3OriginConfig: {
          OriginAccessIdentity: """"
        },
        CustomHeaders: {
          Quantity: 0,
          Items: []
        },
        OriginPath: """"
      });

      expect(mockCreateDistributionWithTags.mock.calls[0][0]).toMatchSnapshot();
    });",""
"30281","shopify/quilt","validate.test.ts","    it('validates mutations', () => {
      const ast = createAST(
        `
        type Person {
          hadFunBirthday: Boolean
        }
        type Mutation {
          haveBirthday(wasFun: Boolean!): Person!
        }
        type Query {
          person: Person
        }
      `,
        `
        mutation MyMutation {
          haveBirthday(fun: true) {
            hadFunBirthday
          }
        }
      `,
      );

      expect(validateAgainstAST({}, ast)).toMatchSnapshot();
      expect(validateAgainstAST({haveBirthday: true}, ast)).toMatchSnapshot();
      expect(validateAgainstAST({haveBirthday: {}}, ast)).toMatchSnapshot();
      expect(
        validateAgainstAST({haveBirthday: {hadFunBirthday: null}}, ast),
      ).toMatchSnapshot();
      expect(
        validateAgainstAST({haveBirthday: {hadFunBirthday: 'true'}}, ast),
      ).toMatchSnapshot();
      expect(
        validateAgainstAST({haveBirthday: {hadFunBirthday: true}}, ast),
      ).toMatchSnapshot();
      expect(
        validateAgainstAST({haveBirthday: {hadFunBirthday: false}}, ast),
      ).toMatchSnapshot();
    });",""
"30414","sql-formatter-org/sql-formatter","Parser.test.ts","  it('parses square brackets', () => {
    expect(parse('SELECT [1, 2, 3];')).toMatchSnapshot();
  });",""
"30466","statelyai/xstate","graph.test.ts","    it('should represent a statechart as a directed graph', () => {
      const machine = createMachine({
        id: 'light',
        initial: 'green',
        states: {
          green: { on: { TIMER: 'yellow' } },
          yellow: { on: { TIMER: 'red' } },
          red: {
            initial: 'walk',
            states: {
              walk: { on: { COUNTDOWN: 'wait' } },
              wait: { on: { COUNTDOWN: 'stop' } },
              stop: { on: { COUNTDOWN: 'finished' } },
              finished: { type: 'final' }
            },
            onDone: 'green'
          }
        }
      });

      const digraph = toDirectedGraph(machine);

      expect(digraph).toMatchSnapshot();
    });",""
"30508","statoscope/statoscope","index.spec.ts","test('color', () => {
  expect(helpers.color('foo')).toMatchInlineSnapshot(`""hsl(54, 50%, 85%)""`);
  expect(helpers.color('bar')).toMatchInlineSnapshot(`""hsl(99, 50%, 85%)""`);
});",""
"30528","statoscope/statoscope","generator.spec.ts","test('should not add existing report', () => {
  const generator = new Generator(adapter);

  generator.handleReport({
    context: 'context',
    data: 'data',
    id: 'foo',
    name: 'name',
    view: ['some-ui'],
  });

  generator.handleReport({
    context: 'context2',
    data: 'data2',
    id: 'foo',
    name: 'name2',
    view: ['some-ui2'],
  });

  expect(generator.get()).toMatchSnapshot();
});",""
"30623","staylor/react-helmet-async","title.test.js","    it('uses defaultTitle if no title is defined', () => {
      render(
        <Helmet
          defaultTitle=""Fallback""
          title=""""
          titleTemplate=""This is a %s of the titleTemplate feature""
        />
      );

      expect(document.title).toMatchSnapshot();
    });",""
"30751","strapi/strapi","index.test.js","  it('should add field', async () => {
    const history = createMemoryHistory();

    const { container } = render(makeApp(history), { container: document.body });

    await waitFor(() =>
      expect(screen.getByText('Configure the view - Address')).toBeInTheDocument()
    );

    fireEvent.mouseDown(screen.getByTestId('add-field'));

    await waitFor(() => expect(screen.getByText('city')).toBeInTheDocument());

    fireEvent.mouseDown(screen.getByText('city'));
    fireEvent.mouseDown(screen.getByTestId('add-field'));

    expect(container).toMatchSnapshot();
  });",""
"31112","svg/svgo","svgo.test.js","test('allow to disable and customize plugins in preset', () => {
  const svg = `
    <?xml version=""1.0"" encoding=""utf-8""?>
    <svg viewBox=""0 0 120 120"">
      <desc>
        Not standard description
      </desc>
      <circle fill=""#ff0000"" cx=""60"" cy=""60"" r=""50""/>
    </svg>
  `;
  const { data } = optimize(svg, {
    plugins: [
      {
        name: 'preset-default',
        params: {
          overrides: {
            removeXMLProcInst: false,
            removeDesc: {
              removeAny: false,
            },
          },
        },
      },
    ],
    js2svg: { pretty: true, indent: 2 },
  });
  expect(data).toMatchInlineSnapshot(`
    ""<?xml version=""1.0"" encoding=""utf-8""?>
    <svg viewBox=""0 0 120 120"">
      <desc>
        Not standard description
      </desc>
      <circle cx=""60"" cy=""60"" r=""50"" fill=""red""/>
    </svg>
    ""
  `);
});",""
"31186","system-ui/theme-ui","index.tsx","  test('renders', () => {
    const json = renderJSON(
      <ThemeUIProvider theme={theme}>
        <AspectRatio />
      </ThemeUIProvider>
    )
    expect(json).toMatchSnapshot()
  })",""
"31235","tailwindlabs/tailwindcss-custom-forms","index.test.js","it('should be possible to change the iconColor of a `checkbox` component', async () => {
  expect(
    await diffOnly({
      theme: {
        extend: {
          customForms: {
            DEFAULT: {
              checkbox: {
                '&:checked': {
                  iconColor: 'pink',
                },
              },
            },
          },
        },
      },
    })
  ).toMatchInlineSnapshot(`
    ""

      -   background-image: url('data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e');
      +   background-image: url('data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='pink' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e');

    ""
  `)
})",""
"31296","testing-library/dom-testing-library","screen.js","test('logs Playground URL that are passed as element', () => {
  screen.logTestingPlaygroundURL(render(`<h1>Sign <em>up</em></h1>`).container)
  expect(console.log).toHaveBeenCalledTimes(1)
  expect(console.log.mock.calls[0][0]).toMatchInlineSnapshot(`
    Open this URL in your browser

    https://testing-playground.com/#markup=DwCwjAfAyglg5gOwATAKYFsIFcAOwD0GEB4EQA
  `)
})",""
"31401","trpc/trpc","index.test.tsx","  test('invalid input', async () => {
    const { client, close } = routerToServerAndClient(
      trpc.router().query('hello', {
        input: z
          .object({
            who: z.string(),
          })
          .nullish(),
        resolve({ input }) {
          expectTypeOf(input).toMatchTypeOf<Maybe<{ who: string }>>();
          return {
            text: `hello ${input?.who ?? 'world'}`,
          };
        },
      }),
    );
    const err = await waitError(
      client.query('hello', { who: 123 as any }),
      TRPCClientError,
    );
    expect(err.shape?.code).toMatchInlineSnapshot(`-32600`);
    expect(err.shape?.message).toMatchInlineSnapshot(`
        ""[
          {
            \\""code\\"": \\""invalid_type\\"",
            \\""expected\\"": \\""string\\"",
            \\""received\\"": \\""number\\"",
            \\""path\\"": [
              \\""who\\""
            ],
            \\""message\\"": \\""Expected string, received number\\""
          }
        ]""
      `);
    close();
  });",""
"31414","trpc/trpc","middleware.test.ts","test('not returning next result is an error at compile-time', async () => {
  const { client, close } = routerToServerAndClient(
    trpc
      .router()
      // @ts-expect-error Compiler makes sure we actually return the `next()` result.
      .middleware(async ({ next }) => {
        await next();
      })
      .query('helloQuery', {
        async resolve() {
          return 'hello';
        },
      }),
  );

  await expect(client.query('helloQuery')).rejects.toMatchInlineSnapshot(
    `[TRPCClientError: No result from middlewares - did you forget to \`return next()\`?]`,
  );

  close();
});",""
"31461","tusimple/naive-ui","Alert.spec.ts","  it('should work with type prop', async () => {
    ;(['info', 'success', 'warning', 'error'] as const).forEach((type) => {
      const wrapper = mount(NAlert, { props: { type } })
      expect(wrapper.find('.n-alert').attributes('style')).toMatchSnapshot()
    })
  })",""
"31902","vanilla-extract-css/vanilla-extract","vars.test.ts","  it('supports multiple fallbacks resolving to a string', () => {
    expect(
      fallbackVar('var(--foo)', 'var(--bar)', 'var(--baz)', 'blue'),
    ).toMatchInlineSnapshot(`""var(--foo, var(--bar, var(--baz, blue)))""`);
  });",""
"32000","vanilla-extract-css/vanilla-extract","sprinkles.test.ts","    it('should handle responsive arrays', () => {
      const map = createMapValueFn(conditionalProperties);
      const value = map(['one'], (value, key) => `${value}_${key}` as const);

      expect(value).toMatchInlineSnapshot(`
        {
          ""mobile"": ""one_mobile"",
        }
      `);
    });",""
"32025","vant-ui/vant-weapp","demo.spec.ts","test('should render demo and match snapshot', () => {
  const id = simulate.load(path.resolve(__dirname, '../demo/index'), {
    rootPath: path.resolve(__dirname, '../../'),
  });
  const comp = simulate.render(id);
  comp.attach(document.createElement('parent-wrapper'));
  expect(comp.toJSON()).toMatchSnapshot();
});",""
"32071","vercel/next.js","ReactRefreshLogBox.dev.test.js","test('stuck error', async () => {
  const [session, cleanup] = await sandbox()

  // We start here.
  await session.patch(
    'index.js',
    `
      import * as React from 'react';

      function FunctionDefault() {
        return <h1>Default Export Function</h1>;
      }

      export default FunctionDefault;
    `
  )

  // We add a new file. Let's call it Foo.js.
  await session.write(
    'Foo.js',
    `
      // intentionally skips export
      export default function Foo() {
        return React.createElement('h1', null, 'Foo');
      }
    `
  )

  // We edit our first file to use it.
  await session.patch(
    'index.js',
    `
      import * as React from 'react';
      import Foo from './Foo';
      function FunctionDefault() {
        return <Foo />;
      }
      export default FunctionDefault;
    `
  )

  // We get an error because Foo didn't import React. Fair.
  expect(await session.hasRedbox(true)).toBe(true)
  expect(await session.getRedboxSource()).toMatchInlineSnapshot(`
    ""Foo.js (4:8) @ Foo

      2 |   // intentionally skips export
      3 |   export default function Foo() {
    > 4 |     return React.createElement('h1', null, 'Foo');
        |    ^
      5 |   }
      6 | ""
  `)

  // Let's add that to Foo.
  await session.patch(
    'Foo.js',
    `
      import * as React from 'react';
      export default function Foo() {
        return React.createElement('h1', null, 'Foo');
      }
    `
  )

  // Expected: this fixes the problem
  expect(await session.hasRedbox()).toBe(false)

  await cleanup()
})",""
"32127","vercel/next.js","index.test.js","  it(`should've emitted a single CSS file`, async () => {
    const cssFolder = join(appDir, '.next/static/css')

    const files = await readdir(cssFolder)
    const cssFiles = files.filter((f) => /\.css$/.test(f))

    expect(cssFiles.length).toBe(1)
    const cssContent = await readFile(join(cssFolder, cssFiles[0]), 'utf8')

    expect(cssContent.replace(/\/\*.*?\*\//g, '').trim()).toMatchInlineSnapshot(
      `"".index_redText__3CwEB{color:red}""`
    )
  })",""
"32213","vercel/next.js","babel-plugin-next-ssg-transform.unit.test.js","    it(`should remove re-exported function declarations' dependents (variables, functions, imports)`, () => {
      const output = babel(trim`
        import keep_me from 'hello'
        import {keep_me2} from 'hello2'
        import * as keep_me3 from 'hello3'

        import drop_me from 'bla'
        import { drop_me2 } from 'foo'
        import { drop_me3, but_not_me } from 'bar'
        import * as remove_mua from 'hehe'

        var leave_me_alone = 1;
        function dont_bug_me_either() {}

        const inceptionVar = 'hahaa';
        var var1 = 1;
        let var2 = 2;
        const var3 = inceptionVar + remove_mua;

        function inception1() {var2;drop_me2;}

        function abc() {}
        const b = function() {var3;drop_me3;};
        const b2 = function apples() {};
        const bla = () => {inception1};

        function getStaticProps() {
          abc();
          drop_me;
          b;
          b2;
          bla();
          return { props: {var1} }
        }

        export { getStaticProps }

        export default function Test() {
          return <div />
        }
      `)

      expect(output).toMatchInlineSnapshot(
        `""import keep_me from'hello';import{keep_me2}from'hello2';import*as keep_me3 from'hello3';import{but_not_me}from'bar';var leave_me_alone=1;function dont_bug_me_either(){}export var __N_SSG=true;export default function Test(){return __jsx(\\""div\\"",null);}""`
      )
    })",""
"32225","vercel/next.js","next-babel-loader.unit.test.js","    it('should replace typeof window expression nested', async () => {
      const code = await babel('function a(){console.log(typeof window)}')
      expect(code).toMatchInlineSnapshot(
        `""function a(){console.log(\\""object\\"");}""`
      )
    })",""
"32268","vercel/next.js","oxford-comma.unit.test.js","  test('four item array', () => {
    expect(getOxfordCommaList(['1', '2', '3', '4'])).toMatchInlineSnapshot(
      `""1, 2, 3, and 4""`
    )
  })",""
"32312","vuejs/vue-router-next","RouterView.spec.ts","  it('displays nested views', async () => {
    const { wrapper } = await factory(routes.nested)
    expect(wrapper.html()).toMatchSnapshot()
  })",""
"32427","webpack-contrib/compression-webpack-plugin","exclude-option.test.js","  it(""matches snapshot for multiple `exclude` values ({Array<RegExp>})"", async () => {
    new CompressionPlugin({
      exclude: [/\.svg(\?.*)?$/i, /\.png(\?.*)?$/i],
      minRatio: 1,
    }).apply(compiler);

    const stats = await compile(compiler);

    expect(getAssetsNameAndSize(stats, compiler)).toMatchSnapshot(""assets"");
    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
  });",""
"32494","webpack-contrib/file-loader","publicPath-option.test.js","  it('should work with ""String"" value', async () => {
    const compiler = getCompiler('simple.js', {
      publicPath: 'public_path/',
    });
    const stats = await compile(compiler);

    expect(
      execute(readAsset('main.bundle.js', compiler, stats))
    ).toMatchSnapshot('result');
    expect(normalizeErrors(stats.compilation.warnings)).toMatchSnapshot(
      'warnings'
    );
    expect(normalizeErrors(stats.compilation.errors)).toMatchSnapshot('errors');
  });",""
"32502","webpack-contrib/html-loader","loader.test.js","  it(""should work with an empty file"", async () => {
    const compiler = getCompiler(""empty.js"");
    const stats = await compile(compiler);

    expect(getModuleSource(""./empty.html"", stats)).toMatchSnapshot(""module"");
    expect(
      execute(readAsset(""main.bundle.js"", compiler, stats))
    ).toMatchSnapshot(""result"");
    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
  });",""
"32536","webpack-contrib/html-loader","sources-option.test.js","  it('should work with an ""object"" notations', async () => {
    const compiler = getCompiler(""simple.js"", {
      sources: {
        list: [
          {
            tag: ""img"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""img"",
            attribute: ""data-src"",
            type: ""src"",
          },
          {
            tag: ""img"",
            attribute: ""data-srcset"",
            type: ""srcset"",
          },
          {
            tag: ""source"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""source"",
            attribute: ""srcset"",
            type: ""srcset"",
          },
          {
            tag: ""flag-icon"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""MyStrangeTag13"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""a-"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""a-."",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""a--"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""aÀ-豈"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""aÀ-Ⰰ"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""INVALID_TAG_NAME"",
            attribute: ""src"",
            type: ""src"",
          },
          {
            tag: ""invalid-CUSTOM-TAG"",
            attribute: ""src"",
            type: ""src"",
          },
        ],
        urlFilter: (attribute, value, resourcePath) => {
          expect(typeof attribute).toBe(""string"");
          expect(typeof value).toBe(""string"");
          expect(typeof resourcePath).toBe(""string"");

          if (value.includes(""example"")) {
            return false;
          }

          return true;
        },
        scriptingEnabled: false,
      },
    });
    const stats = await compile(compiler);

    expect(getModuleSource(""./simple.html"", stats)).toMatchSnapshot(""module"");
    expect(
      execute(readAsset(""main.bundle.js"", compiler, stats))
    ).toMatchSnapshot(""result"");
    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
  });",""
"32575","webpack-contrib/mini-css-extract-plugin","HMR.test.js","  it(""should works"", (done) => {
    const update = hotModuleReplacement(""./src/style.css"", {});

    update();

    setTimeout(() => {
      expect(console.log.mock.calls[0][0]).toMatchSnapshot();

      const links = Array.prototype.slice.call(
        document.querySelectorAll(""link"")
      );

      expect(links[0].visited).toBe(true);
      expect(document.head.innerHTML).toMatchSnapshot();

      links[1].dispatchEvent(getLoadEvent());

      expect(links[1].isLoaded).toBe(true);

      done();
    }, 100);
  });",""
"32611","webpack-contrib/postcss-loader","loader.test.js","  it('should register dependencies using the ""messages"" API', async () => {
    const plugin = () => (css, result) => {
      result.messages.push(
        {
          type: ""build-dependency"",
          file: path.resolve(__dirname, ""fixtures"", ""build-dep.html""),
          content: """",
          plugin,
        },
        {
          type: ""missing-dependency"",
          file: path.resolve(__dirname, ""fixtures"", ""missing-dep.html""),
          content: """",
          plugin,
        },
        {
          type: ""context-dependency"",
          file: path.resolve(__dirname, ""fixtures"", ""deps""),
          content: """",
          plugin,
        },
        {
          type: ""dir-dependency"",
          dir: path.resolve(__dirname, ""fixtures"", ""deps2""),
          content: """",
          plugin,
        }
      );
    };

    const postcssPlugin = postcss.plugin(""postcss-plugin"", plugin);
    const compiler = getCompiler(""./css/index.js"", {
      postcssOptions: {
        plugins: [postcssPlugin()],
      },
    });

    const stats = await compile(compiler);
    const { contextDependencies, missingDependencies, buildDependencies } =
      stats.compilation;

    expect(contextDependencies).toContain(
      path.resolve(__dirname, ""fixtures"", ""deps"")
    );
    expect(contextDependencies).toContain(
      path.resolve(__dirname, ""fixtures"", ""deps2"")
    );
    expect(missingDependencies).toContain(
      path.resolve(__dirname, ""fixtures"", ""missing-dep.html"")
    );
    expect(buildDependencies).toContain(
      path.resolve(__dirname, ""fixtures"", ""build-dep.html"")
    );

    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
  });",""
"32741","webpack-contrib/sass-loader","loader.test.js","        it(`should support resolving using the ""file"" schema ('${implementationName}', '${api}' API, '${syntax}' syntax)`, async () => {
          const testId = getTestId(""import-file-scheme"", syntax);
          const options = {
            implementation,
            api,
          };
          const compiler = getCompiler(testId, {
            loader: { options },
            resolve: {
              alias: {
                ""/language"": path.resolve(
                  ""./test"",
                  syntax,
                  `language.${syntax}`
                ),
              },
            },
          });
          const stats = await compile(compiler);
          const codeFromBundle = getCodeFromBundle(stats, compiler);
          const codeFromSass = await getCodeFromSass(testId, options);

          expect(codeFromBundle.css).toBe(codeFromSass.css);
          expect(codeFromBundle.css).toMatchSnapshot(""css"");
          expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
          expect(getErrors(stats)).toMatchSnapshot(""errors"");
        });",""
"32760","webpack-contrib/sass-loader","loader.test.js","          it(`should work when ""@use"" and use the ""sass"" field ('${implementationName}', '${api}' API, '${syntax}' syntax)`, async () => {
            const testId = getTestId(""use-sass-field"", syntax);
            const options = {
              implementation,
              api,
            };
            const compiler = getCompiler(testId, { loader: { options } });
            const stats = await compile(compiler);
            const codeFromBundle = getCodeFromBundle(stats, compiler);
            const codeFromSass = await getCodeFromSass(testId, options);

            expect(codeFromBundle.css).toBe(codeFromSass.css);
            expect(codeFromBundle.css).toMatchSnapshot(""css"");
            expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
            expect(getErrors(stats)).toMatchSnapshot(""errors"");
          });",""
"32762","webpack-contrib/sass-loader","loader.test.js","          it(`should work when ""@use"" and use the ""main"" field ('${implementationName}', '${api}' API, '${syntax}' syntax)`, async () => {
            const testId = getTestId(""use-main-field"", syntax);
            const options = {
              implementation,
              api,
            };
            const compiler = getCompiler(testId, { loader: { options } });
            const stats = await compile(compiler);
            const codeFromBundle = getCodeFromBundle(stats, compiler);
            const codeFromSass = await getCodeFromSass(testId, options);

            expect(codeFromBundle.css).toBe(codeFromSass.css);
            expect(codeFromBundle.css).toMatchSnapshot(""css"");
            expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
            expect(getErrors(stats)).toMatchSnapshot(""errors"");
          });",""
"32936","webpack-contrib/terser-webpack-plugin","extractComments-option.test.js","  it(""should match snapshot for the `true` value and dedupe duplicate comments"", async () => {
    new TerserPlugin({ extractComments: true }).apply(compiler);

    const stats = await compile(compiler);

    expect(readsAssets(compiler, stats)).toMatchSnapshot(""assets"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
  });",""
"32960","webpack-contrib/terser-webpack-plugin","include-option.test.js","  it(""should match snapshot for multiple RegExp values"", async () => {
    new TerserPlugin({
      include: [/included1/i, /included2/i],
    }).apply(compiler);

    const stats = await compile(compiler);

    expect(readsAssets(compiler, stats)).toMatchSnapshot(""assets"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
  });",""
"33055","webpack-contrib/terser-webpack-plugin","TerserPlugin.test.js","  it(""should respect the hash options #1"", async () => {
    const compiler = getCompiler({
      output: {
        pathinfo: false,
        path: path.resolve(__dirname, ""dist""),
        filename: ""[name].js"",
        chunkFilename: ""[id].[name].js"",
        hashDigest: ""hex"",
        hashDigestLength: 20,
        hashFunction: ""sha256"",
        hashSalt: ""salt"",
      },
    });

    new TerserPlugin().apply(compiler);

    const stats = await compile(compiler);

    expect(readsAssets(compiler, stats)).toMatchSnapshot(""assets"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
  });",""
"33281","webpack-contrib/webpack-serve","config.test.js","  test('toArray: Array', () => {
    const config = { entry: ['file'] };
    expect(toArray(config)).toMatchSnapshot();
  });",""
"33350","webpack-contrib/worker-loader","inline-option.test.js","  it('should work with ""no-fallback"" value and the ""devtool"" option (""eval-source-map"" value)', async () => {
    const compiler = getCompiler(
      ""./basic/entry.js"",
      { inline: ""no-fallback"" },
      { devtool: ""eval-source-map"" }
    );
    const stats = await compile(compiler);
    const result = await getResultFromBrowser(stats);
    const moduleSource = getModuleSource(""./basic/worker.js"", stats);
    const sourceUrlInternalIndex = moduleSource.indexOf(
      ""sourceURL=webpack-internal:///./basic/worker.js""
    );

    expect(moduleSource.indexOf(""inline.js"") > 0).toBe(true);
    expect(
      moduleSource.indexOf('__webpack_public_path__ + ""test.worker.js""') === -1
    ).toBe(true);
    expect(
      moduleSource.indexOf(
        ""sourceMappingURL=data:application/json;charset=utf-8;base64,""
      ) === -1
    ).toBe(true);
    expect(sourceUrlInternalIndex === -1).toBe(true);
    expect(stats.compilation.assets[""test.worker.js""]).toBeUndefined();
    expect(stats.compilation.assets[""test.worker.js.map""]).toBeUndefined();
    expect(result).toMatchSnapshot(""result"");
    expect(getWarnings(stats)).toMatchSnapshot(""warnings"");
    expect(getErrors(stats)).toMatchSnapshot(""errors"");
  });",""
"33420","webpack/webpack-dev-middleware","logging.test.js","  it('should logging on successfully build using the ""stats"" option for middleware with the ""true"" value', (done) => {
    let proc;

    try {
      proc = execa(runner, [], {
        stdio: ""pipe"",
        env: {
          WEBPACK_CONFIG: ""webpack.config"",
          WMC_stats: true,
          FORCE_COLOR: true,
        },
      });
    } catch (error) {
      throw error;
    }

    let stdout = """";
    let stderr = """";

    proc.stdout.on(""data"", (chunk) => {
      stdout += chunk.toString();

      if (/compiled-for-tests/gi.test(stdout)) {
        proc.stdin.write(""|exit|"");
      }
    });

    proc.stderr.on(""data"", (chunk) => {
      stderr += chunk.toString();
      proc.stdin.write(""|exit|"");
    });

    proc.on(""error"", (error) => {
      done(error);
    });

    proc.on(""exit"", () => {
      expect(stdout).toContain(""\u001b[1m"");
      expect(stdoutToSnapshot(stdout)).toMatchSnapshot(""stdout"");
      expect(stderrToSnapshot(stderr)).toMatchSnapshot(""stderr"");

      done();
    });
  });",""
"33466","webpack/webpack-dev-server","https-option.test.js","  it('should work using ""--https-key-reset --https-key <path> --https-pfx-reset --https-pfx <path> --https-passphrase webpack-dev-server --https-cert-reset  --https-cert <path> --https-ca-reset --https-ca <path>""', async () => {
    const pfxFile = path.join(httpsCertificateDirectory, ""server.pfx"");
    const key = path.join(httpsCertificateDirectory, ""server.key"");
    const cert = path.join(httpsCertificateDirectory, ""server.crt"");
    const ca = path.join(httpsCertificateDirectory, ""ca.pem"");
    const passphrase = ""webpack-dev-server"";

    const { exitCode, stderr } = await testBin([
      ""--port"",
      port,
      ""--https-key-reset"",
      ""--https-key"",
      key,
      ""--https-pfx-reset"",
      ""--https-pfx"",
      pfxFile,
      ""--https-passphrase"",
      passphrase,
      ""--https-cert-reset"",
      ""--https-cert"",
      cert,
      ""--https-ca-reset"",
      ""--https-ca"",
      ca,
    ]);

    expect(exitCode).toEqual(0);
    expect(
      normalizeStderr(stderr, { ipv6: true, https: true })
    ).toMatchSnapshot();
  });",""
"33698","webpack/webpack-dev-server","overlay.test.js","  it(""should show error for uncaught promise rejection"", async () => {
    const compiler = webpack(config);

    const server = new Server(
      {
        port,
      },
      compiler
    );

    await server.start();

    const { page, browser } = await runBrowser();

    await page.goto(`http://localhost:${port}/`, {
      waitUntil: ""networkidle0"",
    });

    await page.addScriptTag({
      content: `(function throwError() {
        setTimeout(function () {
          Promise.reject(new Error('Async error'));
        }, 0);
      })();`,
    });

    const overlayHandle = await page.$(""#webpack-dev-server-client-overlay"");
    const overlayFrame = await overlayHandle.contentFrame();
    const overlayHtml = await overlayFrame.evaluate(
      () => document.body.outerHTML
    );

    expect(prettier.format(overlayHtml, { parser: ""html"" })).toMatchSnapshot(
      ""overlay html""
    );

    await browser.close();
    await server.stop();
  });",""
"33964","wordpress/gutenberg","index.js","	test( 'should allow custom alignment controls to be specified', () => {
		const wrapperCustomControls = shallow(
			<AlignmentUI
				isToolbar
				value={ 'custom-right' }
				onChange={ onChangeSpy }
				alignmentControls={ [
					{
						icon: alignLeft,
						title: 'My custom left',
						align: 'custom-left',
					},
					{
						icon: alignCenter,
						title: 'My custom right',
						align: 'custom-right',
					},
				] }
			/>
		);
		expect( wrapperCustomControls ).toMatchSnapshot();
		const customControls = wrapperCustomControls.props().controls;
		expect( customControls ).toHaveLength( 2 );

		// should correctly call on change when right alignment is pressed (active alignment)
		const rightControl = customControls.find(
			( { align } ) => align === 'custom-right'
		);
		expect( rightControl.title ).toBe( 'My custom right' );
		rightControl.onClick();
		expect( onChangeSpy ).toHaveBeenCalledTimes( 1 );
		expect( onChangeSpy ).toHaveBeenCalledWith( undefined );
		onChangeSpy.mockClear();

		// should correctly call on change when right alignment is pressed (inactive alignment)
		const leftControl = customControls.find(
			( { align } ) => align === 'custom-left'
		);
		expect( leftControl.title ).toBe( 'My custom left' );
		leftControl.onClick();
		expect( onChangeSpy ).toHaveBeenCalledTimes( 1 );
		expect( onChangeSpy ).toHaveBeenCalledWith( 'custom-left' );
	} );",""
"34027","wordpress/gutenberg","index.native.js","		it( 'toggles resize for smaller devices media settings', async () => {
			const {
				getByA11yLabel,
				getByText,
			} = await initializeWithEmbedBlock( RICH_TEXT_EMBED_HTML );

			// Open Block Settings
			fireEvent.press(
				await waitFor( () => getByA11yLabel( 'Open Settings' ) )
			);

			// Untoggle resize for smaller devices
			fireEvent.press(
				await waitFor( () => getByText( /Resize for smaller devices/ ) )
			);

			expect( getEditorHtml() ).toMatchSnapshot();
		} );",""
"34139","wordpress/gutenberg","get-intermediate-representation.js","			it( 'named identifier with destructuring', () => {
				const tokenObject = fs.readFileSync(
					path.join(
						__dirname,
						'./fixtures/named-identifier-destructuring/exports.json'
					),
					'utf-8'
				);
				const astObject = fs.readFileSync(
					path.join(
						__dirname,
						'./fixtures/named-identifier-destructuring/ast.json'
					),
					'utf-8'
				);
				const irNamedIdDestructuring = getIntermediateRepresentation(
					null,
					JSON.parse( tokenObject ),
					JSON.parse( astObject )
				);
				expect( irNamedIdDestructuring ).toMatchInlineSnapshot( `
			Array [
			  Object {
			    ""description"": ""My declaration example."",
			    ""lineEnd"": 6,
			    ""lineStart"": 6,
			    ""name"": ""myDeclaration"",
			    ""path"": null,
			    ""tags"": Array [],
			  },
			]
		` );
			} );",""
"34142","wordpress/gutenberg","get-intermediate-representation.js","			it( 'named import', () => {
				const tokenImportNamed = fs.readFileSync(
					path.join(
						__dirname,
						'./fixtures/named-import-named/exports.json'
					),
					'utf-8'
				);
				const getModuleImportNamed = () =>
					JSON.parse(
						fs.readFileSync(
							path.join(
								__dirname,
								'./fixtures/named-identifiers/ir.json'
							),
							'utf-8'
						)
					);
				const ir = getIntermediateRepresentation(
					null,
					JSON.parse( tokenImportNamed ),
					{ body: [] },
					getModuleImportNamed
				);
				expect( ir ).toMatchInlineSnapshot( `
			Array [
			  Object {
			    ""description"": ""Function declaration example."",
			    ""lineEnd"": 2,
			    ""lineStart"": 2,
			    ""name"": ""functionDeclaration"",
			    ""path"": null,
			    ""tags"": Array [],
			  },
			  Object {
			    ""description"": ""Variable declaration example."",
			    ""lineEnd"": 3,
			    ""lineStart"": 3,
			    ""name"": ""variableDeclaration"",
			    ""path"": null,
			    ""tags"": Array [],
			  },
			  Object {
			    ""description"": ""Class declaration example."",
			    ""lineEnd"": 4,
			    ""lineStart"": 4,
			    ""name"": ""ClassDeclaration"",
			    ""path"": null,
			    ""tags"": Array [],
			  },
			]
		` );
			} );",""
"34293","wordpress/gutenberg","block-editor-keyboard-shortcuts.test.js","			it( 'should move the blocks up', async () => {
				await createTestParagraphBlocks();
				expect( await getEditedPostContent() ).toMatchSnapshot();
				await page.keyboard.down( 'Shift' );
				await page.keyboard.press( 'ArrowUp' );
				await page.keyboard.up( 'Shift' );
				await moveUp();
				expect( await getEditedPostContent() ).toMatchSnapshot();
			} );",""
"34474","wordpress/gutenberg","index.js","		it( 'should match snapshot', () => {
			const blocks = [ headingH2, headingH3 ].map( ( block, index ) => {
				// Set client IDs to a predictable value.
				return { ...block, clientId: `clientId_${ index }` };
			} );
			const wrapper = shallow( <DocumentOutline blocks={ blocks } /> );

			expect( wrapper ).toMatchSnapshot();
		} );",""
"34752","znck/vue-developer-experience","typecheck.spec.ts","  test(
    'format: json',
    async () => {
      expect(await run('typecheck-configured', ['--format', 'json']))
        .toMatchInlineSnapshot(`
        ""[
          {
            \\""fileName\\"": \\""src/App.vue\\"",
            \\""diagnostics\\"": [
              {
                \\""start\\"": {
                  \\""line\\"": 14,
                  \\""offset\\"": 18
                },
                \\""end\\"": {
                  \\""line\\"": 14,
                  \\""offset\\"": 22
                },
                \\""text\\"": \\""Type 'number' is not assignable to type 'string'.\\"",
                \\""code\\"": 2322,
                \\""category\\"": \\""error\\"",
                \\""source\\"": \\""VueDX/TS\\""
              }
            ]
          }
        ]""
      `)
    },
    TIMEOUT,
  )",""